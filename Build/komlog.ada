Version V6p1a of ee9 for Linux, built on Sun 21 Feb 2021 03:54:04 PM PST.
mk9 'ee9' build: optimised and with full language checks, using configuration options:

pragma Unsuppress(All_Checks);
pragma Optimize_Alignment(Time);
pragma Assertion_Policy(Ignore);
pragma Check_Policy(Debug, Off);
pragma Validity_Checks(Off);
pragma Restrictions(Max_Asynchronous_Select_Nesting => 0);
pragma Restrictions(Max_Tasks => 0);
pragma Restrictions(No_Abort_Statements);
pragma Restrictions(No_Implementation_Attributes);
pragma Restrictions(No_Obsolescent_Features);

Using the build command:
gnatmake -aI../Source -aO../Build -funwind-tables -gnatl12j96 -gnatw.e -gnatwD -gnatwH -gnatwP -gnatwT -gnatw.W -gnatw.B -gnatwC -gnatw.u -gnatyO -gnatw.Y -gnatw.N -fdata-sections -ffunction-sections -gnatf -mtune=native -O3 -flto -j1 ee9 -bargs -static -largs -Wl,--gc-sections -Wl,--as-needed -flto

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ee9.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:04

     1. -- This is the "main program" for the entire emulator.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with GNAT.Source_Info;
    18. --
    19. with Ada.Text_IO;
    20. with Ada.Command_Line;
    21. with Ada.Exceptions;
    22. --
    23. with exceptions;
    24. with HCI;
    25. with IOC.equipment;
    26. with IOC.slow.shift.TP;
    27. with IOC.slow.shift.TR;
    28. with settings;
    29.
    30. with execute;
    31. with say_goodbye;
    32.
    33. use  Ada.Text_IO;
    34. use  Ada.Exceptions;
    35. --
    36. use  exceptions;
    37. use  HCI;
    38. use  IOC.equipment;
    39. use  settings;
    40.
    41. procedure ee9 is
    42.
    43.    package CLI renames Ada.Command_Line;
    44.
    45.    the_log_file_name : constant String := "KDF9_log.txt";
    46.
    47.    a_command_line_error_is_detected : exception;
    48.
    49.    procedure show_proper_usage (message : in String := "") is
    50.    begin
    51.       if message /= "" then
    52.          log_line(message);
    53.       end if;
    54.       log_line(
    55.                "usage: ee9 { [ -s{b|p|t} ] | [ -d{f|p|t|x|-} ] | [ -m"
    56.              & miscellany_prompt
    57.              & " ] [ -TP{k|l}{k|l} ] [ -TR{k|l}{k|l} ] } +program_file_name"
    58.               );
    59.       CLI.Set_Exit_Status(CLI.Failure);
    60.       raise a_command_line_error_is_detected;
    61.    end show_proper_usage;
    62.
    63.    procedure complain (about : in String; because : in String := "") is
    64.    begin
    65.       show_proper_usage(
    66.                         "Parameter " & about & " is not valid"
    67.                       & (if because = "" then "." else " because " & because & ".")
    68.                        );
    69.    end complain;
    70.
    71.    the_program_name_position : Natural := 0;
    72.
    73.    procedure check_all_flag_settings is
    74.
    75.       procedure check_flag_setting (i : in Positive) is
    76.
    77.          subtype tape_code_flags is Character
    78.             with Predicate => tape_code_flags in 'K' | 'L' | 'k' | 'l';
    79.
    80.          subtype tape_device_flags is Character
    81.             with Predicate => tape_device_flags in 'P' | 'R' |'p' | 'r';
    82.
    83.          argument : constant String   := CLI.Argument(i);
    84.          index    : constant Positive := argument'First;
    85.
    86.       begin
    87.          -- Ignore an empty parameter.
    88.          if argument'Length = 0 then
    89.             return;
    90.          end if;
    91.
    92.          -- Take note of a program name parameter.
    93.          if argument(index) = '+' then
    94.             if the_program_name_position /= 0 then
    95.                complain(about   => argument,
    96.                         because => "more than one program has been specified");
    97.             end if;
    98.             if argument'Length < 3 then
    99.                complain(about   => argument,
   100.                         because => "it is too short for a program file name");
   101.             end if;
   102.             the_program_name_position := i;
   103.             return;
   104.          end if;
   105.
   106.          -- Fail any non-flag parameter.
   107.          if argument(index) /= '-'  then
   108.             complain(about => "'" & argument & "'");
   109.          end if;
   110.
   111.          -- Fail a too-short flag parameter.
   112.          if argument'Length < 2 then
   113.             complain(about   => argument,
   114.                      because => "it is too short");
   115.          end if;
   116.
   117.          -- Check for a miscellany parameter.
   118.          if argument'Length in 2 .. miscellany_flags'Length+2 and then
   119.                argument(index..index+1) = "-m"                    then
   120.             for i in index+2 .. argument'Last loop
   121.                if is_invalid_miscellany_flag(argument(i)) then
   122.                   complain(about => """" & argument & """ at """ & argument(i) & """");
   123.                end if;
   124.             end loop;
   125.             return;
   126.          end if;
   127.
   128.          -- Check for a state or diagnostic parameter.
   129.          if argument in "-sb" | "-sp" | "-st" | "-df" | "-dt" | "-dp" | "-dx" | "-d-" then
   130.             return;
   131.          end if;
   132.
   133.          -- Check for a Tape Punch/Reader parameter.
   134.          if argument'Length in 4 .. 5                    and then
   135.                argument(index+1) in 'T' | 't'            and then
   136.                   argument(index+2) in tape_device_flags and then
   137.                      argument(index+3) in tape_code_flags    then
   138.             if argument'Length = 4                  or else
   139.                   argument(index+4) in tape_code_flags then
   140.                return;
   141.             end if;
   142.          end if;
   143.
   144.          complain(about => argument);
   145.
   146.       end check_flag_setting;
   147.
   148.    begin -- check_all_flag_settings
   149.       if CLI.Argument_Count = 0 then
   150.          return;
   151.       end if;
   152.       for i in 1..CLI.Argument_Count loop
   153.          check_flag_setting(i);
   154.       end loop;
   155.    end check_all_flag_settings;
   156.
   157.    procedure impose_all_flag_settings is
   158.
   159.       procedure impose_flag_setting (i : in Positive) is
   160.
   161.          subtype Latin_1_code_flags is Character
   162.             with Predicate => Latin_1_code_flags in 'L' | 'l';
   163.
   164.          subtype punch_device_flags is Character
   165.             with Predicate => punch_device_flags in 'P' |'p';
   166.
   167.          argument : constant String   := CLI.Argument(i);
   168.          index    : constant Positive := argument'First;
   169.
   170.       begin -- impose_flag_setting
   171.          -- Ignore an empty parameter.
   172.          if argument'Length = 0 then
   173.             return;
   174.          end if;
   175.
   176.          -- Ignore a program_file_name parameter.
   177.          if argument(index) = '+'  then
   178.             return;
   179.          end if;
   180.
   181.          -- Impose a miscellany parameter.
   182.          if argument'Length in 2 .. miscellany_flags'Length+2 and then
   183.                argument(index..index+1) = "-m"  then
   184.             for i in index+2 .. argument'Last loop
   185.                set_this_miscellany_flag(argument(i));
   186.             end loop;
   187.             return;
   188.          end if;
   189.
   190.          -- Impose  a Tape Punch/Reader parameter.
   191.          if argument'Length in 4 .. 5 then
   192.             -- Set the code for the first device.
   193.             if argument(index+2) in punch_device_flags then
   194.                IOC.slow.shift.TP.set_unit_code(0, argument(index+3) in Latin_1_code_flags);
   195.             else
   196.                IOC.slow.shift.TR.set_unit_code(0, argument(index+3) in Latin_1_code_flags);
   197.             end if;
   198.          end if;
   199.          if argument'Length = 5 then
   200.             -- Set the code for the second device.
   201.             if argument(index+2) in punch_device_flags then
   202.                IOC.slow.shift.TP.set_unit_code(1, argument(index+4) in Latin_1_code_flags);
   203.             else
   204.                IOC.slow.shift.TR.set_unit_code(1, argument(index+4) in Latin_1_code_flags);
   205.             end if;
   206.          end if;
   207.
   208.          -- Impose a state or diagnostic parameter; argument is known to be 3 characters long.
   209.          if    argument = "-sb" then
   210.             set_execution_mode(boot_mode);
   211.          elsif argument = "-sp" then
   212.             set_execution_mode(program_mode);
   213.          elsif argument = "-st" then
   214.             set_execution_mode(test_program_mode);
   215.          elsif argument = "-d-" then
   216.             set_diagnostic_mode(fast_mode);
   217.          elsif argument = "-df" then
   218.             set_diagnostic_mode(fast_mode);
   219.          elsif argument = "-dt" then
   220.             set_diagnostic_mode(trace_mode);
   221.          elsif argument = "-dp" then
   222.             set_diagnostic_mode(pause_mode);
   223.          elsif argument = "-dx" then
   224.             set_diagnostic_mode(external_mode);
   225.          end if;
   226.       end impose_flag_setting;
   227.
   228.    begin -- impose_all_flag_settings
   229.       if CLI.Argument_Count = 0 then
   230.          return;
   231.       end if;
   232.       for i in 1..CLI.Argument_Count loop
   233.          impose_flag_setting(i);
   234.       end loop;
   235.    end impose_all_flag_settings;
   236.
   237.    function plain (f : String)
   238.    return String
   239.    is (f(f'First+1 .. f'Last));
   240.
   241.    function the_program_name
   242.    return String
   243.    is (plain(CLI.Argument(the_program_name_position)));
   244.
   245.    procedure tidy_up (reason : in String) is
   246.    begin
   247.       Put_Line(Standard_Error, reason & ".");
   248.       close(the_log_file_name);
   249.       CLI.Set_Exit_Status(CLI.Failure);
   250.    end tidy_up;
   251.
   252. begin -- ee9
   253.
   254.    check_all_flag_settings;
   255.    open(the_log_file_name);
   256.
   257.    if the_program_name_position /= 0 then
   258.       get_settings_from_file("1");
   259.       configure_the_IOC;
   260.       impose_all_flag_settings;
   261.       revise_the_configuration;
   262.       if the_log_is_wanted then
   263.          log_line(
   264.                   "This is ee9 6.1a, compiled by "
   265.                 & Standard'Compiler_Version
   266.                 & " on "
   267.                 & GNAT.Source_Info.Compilation_ISO_Date
   268.                 & "."
   269.                  );
   270.       end if;
   271.       display_execution_modes(the_program_name);
   272.       execute(the_program_name);
   273.    else
   274.       log_line("Cannot run ee9; no program file parameter was supplied.");
   275.    end if;
   276.
   277.    close(the_log_file_name);
   278.
   279. exception
   280.
   281.    when a_command_line_error_is_detected =>
   282.       tidy_up("Invalid command line");
   283.
   284.    when diagnostic : operator_error =>
   285.       say_goodbye("The KDF9 operator has made a mistake", Exception_Message(diagnostic));
   286.
   287.    when error : others =>
   288.       tidy_up("Failure in ee9; unexpected exception: " & Exception_Information(error));
   289.
   290. end ee9;

 290 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/exceptions.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:04

     1. -- Declare the exceptions used in emulation-mode control.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package exceptions is
    18.
    19.    -- program_exit is raised when a KDF9 program terminates normally.
    20.    program_exit : exception;
    21.
    22.   -- OUT_2_restart is raised when a KDF9 program terminates by means of OUT 2.
    23.    OUT_2_restart : exception;
    24.
    25.    -- time_expired is raised when a KDF9 program executes too many instructions.
    26.    time_expired : exception;
    27.
    28.    -- quit_request is raised when the user requests a quit at a break-in.
    29.    quit_request : exception;
    30.
    31.    -- input_is_impossible is raised when an attempt is made to read from the terminal in
    32.    --    noninteractive mode.  This prevents absent-user scripted usage from hanging.
    33.    input_is_impossible : exception;
    34.
    35.    -- operator_error is raised when the operating context is invalid; e.g. labelled tape not mounted.
    36.    operator_error : exception;
    37.
    38.    -- OUT_error is raised when an impossible OUT action is requested in problem program state.
    39.    OUT_error : exception;
    40.
    41.    -- IO_error is raised when an impossible I/O operation is attempted in problem program state.
    42.    IO_error : exception;
    43.
    44.    -- Director_IO_error when an impossible I/O operation is attempted in Director state.
    45.    Director_IO_error : exception;
    46.
    47.    -- Director_failure is raised for an instruction that would LIV in problem program state.
    48.    Director_failure : exception;
    49.
    50.    -- invalid_paper_tape_file is raised when given invalid data for a KDF9-code paper tape file.
    51.    invalid_paper_tape_file : exception;
    52.
    53.    -- not_yet_implemented is raised by an incomplete emulation.
    54.    not_yet_implemented : exception;
    55.
    56.    -- emulation_failure is raised when an emulator self-check fails.
    57.    emulation_failure : exception;
    58.
    59.    -- debugging_stop is raised when a debugging run needs to halt at once.
    60.    debugging_stop : exception;
    61.
    62. end exceptions;

 62 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/execute.adb
Source file time stamp: 2021-02-20 23:30:35
Compiled at: 2021-02-21 15:54:04

     1. -- This is the emulation-mode coordinate module.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with GNAT.Ctrl_C;
    18. --
    19. with Ada.Command_Line;
    20. with Ada.Exceptions;
    21. --
    22. with break_in;
    23. with dumping;
    24. with exceptions;
    25. with HCI;
    26. with IOC.slow.shift.TR;
    27. with KDF9;
    28. with KDF9.microcode;
    29. with settings;
    30. with state_display;
    31.
    32. with say_goodbye;
    33.
    34. use  Ada.Command_Line;
    35. use  Ada.Exceptions;
    36. --
    37. use  dumping;
    38. use  exceptions;
    39. use  HCI;
    40. use  IOC.slow.shift.TR;
    41. use  KDF9;
    42. use  KDF9.microcode;
    43. use  settings;
    44. use  state_display;
    45.
    46. procedure execute (program_name : in String) is
    47.
    48.    procedure check_times_and_modes
    49.       with Inline;
    50.
    51.    pause_count : KDF9.order_counter := 0;
    52.
    53.    procedure check_times_and_modes is
    54.    begin
    55.       if ICR > pause_count then
    56.          if ICR >= time_limit then
    57.             raise time_expired;
    58.          end if;
    59.          pause_count := pause_count + time_slice;
    60.          change_diagnostic_mode_if_requested;
    61.       end if;
    62.    end check_times_and_modes;
    63.
    64. begin  -- execute
    65.    GNAT.Ctrl_C.Install_Handler(break_in.note_user_interrupt'Access);
    66.
    67.    if the_external_trace_is_enabled then
    68.       log_an_external_trace_header;
    69.    end if;
    70.
    71.    case the_execution_mode is
    72.       when boot_mode =>
    73.          reset_the_internal_registers(Director_state);
    74.          boot_the_KDF9(program_name);
    75.       when test_program_mode=>
    76.          reset_the_internal_registers(Director_state);
    77.          load_a_program(program_name);
    78.       when program_mode =>
    79.          reset_the_internal_registers(program_state);
    80.          load_a_program(program_name);
    81.    end case;
    82.
    83.    if not loading_was_successful then
    84.       say_goodbye("Could not load the specified program.");
    85.       return;
    86.    end if;
    87.
    88.    poke_all_amendments;
    89.    show_all_prerun_dump_areas;
    90.
    91.    if do_not_execute then
    92.       log_new_line;
    93.       log_line("Run abandoned as requested.");
    94.       return;
    95.    end if;
    96.
    97.    reset_the_CPU_state;
    98.
    99. execution_loop:
   100.    loop
   101.
   102.       begin
   103.
   104.          check_times_and_modes;
   105.          if the_diagnostic_mode /= fast_mode then
   106.             -- Do a single, traced instruction, breaking-in conditionally.
   107.             do_a_traced_instruction_cycle;
   108.          else
   109.             -- Fast mode is designed for minimal overhead;
   110.             --    it interacts with the user only at the end of a time slice.
   111.             loop
   112.                do_a_fast_time_slice;
   113.                check_times_and_modes;
   114.             end loop;
   115.          end if;
   116.
   117.       exception  -- handler for execution_loop
   118.
   119.          when debugging_stop =>
   120.             null;
   121.
   122.          when mode_change_request =>
   123.             quit_if_requested;
   124.
   125.          when abandon_this_order =>
   126.             null;  -- Just get on with it after an interrupt or nullified order.
   127.
   128.          when LOV_exception =>
   129.             IOC.handle_a_main_store_lockout;
   130.
   131.          when program_exit =>
   132.             say_goodbye("", status => Success);
   133.             exit execution_loop;
   134.
   135.          when quit_request =>
   136.             say_goodbye("Run stopped by the user", status => Success);
   137.             exit execution_loop;
   138.
   139.          when time_expired =>
   140.             say_goodbye("Infinite loop? Run failed by exceeding the time limit");
   141.             exit execution_loop;
   142.
   143.          when diagnostic : NOUV_exception =>
   144.             say_goodbye("NOUV interrupt", Exception_Message(diagnostic));
   145.             exit execution_loop;
   146.
   147.          when input_is_impossible =>
   148.             say_goodbye("Noninteractive mode cannot handle a prompt");
   149.             exit execution_loop;
   150.
   151.          when diagnostic : not_yet_implemented =>
   152.             say_goodbye("Not yet implemented", Exception_Message(diagnostic));
   153.             exit execution_loop;
   154.
   155.          when diagnostic : RESET_exception =>
   156.             say_goodbye("RESET interrupt", Exception_Message(diagnostic));
   157.             exit execution_loop;
   158.
   159.          when diagnostic : LIV_exception =>
   160.             say_goodbye( "LIV interrupt", Exception_Message(diagnostic));
   161.             exit execution_loop;
   162.
   163.          when diagnostic : Director_failure =>
   164.             say_goodbye("Invalid operation in Director", Exception_Message(diagnostic));
   165.             exit execution_loop;
   166.
   167.          when diagnostic : OUT_error =>
   168.             say_goodbye("Failure in OUT", Exception_Message(diagnostic));
   169.             exit execution_loop;
   170.
   171.          when diagnostic : IO_error =>
   172.             say_goodbye("Impossible I/O operation", Exception_Message(diagnostic));
   173.             exit execution_loop;
   174.
   175.          when diagnostic : Director_IO_error =>
   176.             say_goodbye("Impossible I/O operation in Director", Exception_Message(diagnostic));
   177.             exit execution_loop;
   178.
   179.          when diagnostic : operator_error =>
   180.             say_goodbye("The KDF9 operator has made a mistake", Exception_Message(diagnostic));
   181.             exit execution_loop;
   182.
   183.       end;
   184.
   185.    end loop execution_loop;
   186.
   187. exception  -- handler for execute
   188.
   189.    when diagnostic : invalid_paper_tape_file =>
   190.       say_goodbye("Invalid paper tape file supplied", Exception_Message(diagnostic));
   191.
   192.    when diagnostic : operator_error =>
   193.       say_goodbye("The KDF9 operator must have made a mistake", Exception_Message(diagnostic));
   194.
   195.    when diagnostic : others =>
   196.       say_goodbye("Apologies for this dismal failure", Exception_Message(diagnostic));
   197.
   198. end execute;

 198 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/hci.adb
Source file time stamp: 2021-02-11 18:24:04
Compiled at: 2021-02-21 15:54:04

     1. -- Provide operations supporting replicated human-readable output:
     2. --    1: to an interactive user interface for transient display, and
     3. --    2: to a file for persistent storage.
     4. -- If no file has been opened, or if it has been explicitly closed,
     5. --    output is to the interactive interface only.
     6. --
     7. -- Also provide operations allowing synchronization with the user.
     8. --
     9. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
    10. -- Copyright (C) 2021, W. Findlay; all rights reserved.
    11. --
    12. -- The ee9 program is free software; you can redistribute it and/or
    13. -- modify it under terms of the GNU General Public License as published
    14. -- by the Free Software Foundation; either version 3, or (at your option)
    15. -- any later version. This program is distributed in the hope that it
    16. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    17. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    18. -- See the GNU General Public License for more details. You should have
    19. -- received a copy of the GNU General Public License distributed with
    20. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    21. --
    22.
    23. with generic_logger;
    24. with settings;
    25.
    26. use  settings;
    27.
    28. package body HCI is
    29.
    30.    package log_manager is new generic_logger(max_logger_list_size => 2);
    31.
    32.    cc_list : log_manager.replicator;
    33.
    34.    procedure tab_log (at_least : in Natural;
    35.                       spacing  : in Positive := 6;
    36.                       iff      : in Boolean := True) is
    37.    begin
    38.       cc_list.tab_log(at_least, spacing, iff);
    39.    end tab_log;
    40.
    41.    procedure tab_log_to (column : in Positive;
    42.                          iff    : in Boolean := True) is
    43.    begin
    44.       cc_list.tab_log_to(column, iff);
    45.    end tab_log_to;
    46.
    47.    procedure log (char : in Character;
    48.                   iff  : in Boolean := True) is
    49.    begin
    50.       cc_list.log(char, iff);
    51.    end log;
    52.
    53.    procedure log (text : in String;
    54.                   iff  : in Boolean := True) is
    55.    begin
    56.       cc_list.log(text, iff);
    57.    end log;
    58.
    59.    procedure log_line (text : in String;
    60.                        iff  : in Boolean := True) is
    61.    begin
    62.       if text /= "" then
    63.          cc_list.log(text, iff);
    64.       end if;
    65.       log_new_line(iff);
    66.    end log_line;
    67.
    68.    procedure log_new_line (iff : in Boolean := True) is
    69.    begin
    70.       cc_list.log_new_line(iff);
    71.    end log_new_line;
    72.
    73.    half_ruler : constant String (1 .. 40) := (others => '_');
    74.    half_blank : constant String (1 .. 40) := (others => ' ');
    75.    full_ruler : constant String (1 .. 80) := half_ruler & half_ruler;
    76.
    77.    procedure log_rule (start_a_new_line : in Boolean := False;
    78.                        iff              : in Boolean := True) is
    79.    begin
    80.       if start_a_new_line then
    81.          cc_list.log_new_line(iff);
    82.       end if;
    83.       log_line(full_ruler, iff);
    84.    end log_rule;
    85.
    86.    procedure log_rule_half (second_half : in Boolean := False) is
    87.    begin
    88.       if second_half then
    89.          log(half_blank);
    90.       end if;
    91.       log_line(half_ruler);
    92.    end log_rule_half;
    93.
    94.    procedure log_message (message : in String) is
    95.    begin
    96.       cc_list.log(message);
    97.       cc_list.log_new_line;
    98.    end log_message;
    99.
   100.    procedure log_title (message : in String) is
   101.    begin
   102.       cc_list.log_new_line;
   103.       cc_list.log(message);
   104.       cc_list.log_new_line;
   105.    end log_title;
   106.
   107.    procedure log_ee9_status (message  : in String;
   108.                              skip     : in Natural := 0;
   109.                              complete : in Boolean := True;
   110.                              iff      : in Boolean := True) is
   111.    begin
   112.       if not iff then return; end if;
   113.       panel_logger.tab_log_to(1);
   114.       for i in 1 .. skip loop
   115.          log_new_line;
   116.       end loop;
   117.       if complete then
   118.          log_line("ee9: " & message & ".");
   119.       else
   120.          log("ee9: " & message);
   121.       end if;
   122.    end log_ee9_status;
   123.
   124.    procedure log_API_message (message  : in String;
   125.                               skip     : in Natural := 1) is
   126.    begin
   127.       if API_logging_is_wanted then
   128.          log_ee9_status(message, skip, True);
   129.       end if;
   130.    end log_API_message;
   131.
   132.    procedure hoot (message : in String := "") is
   133.    begin
   134.       panel_logger.log(message & Character'Val (7));  -- Append a BEL to the message.
   135.    end hoot;
   136.
   137.    procedure show (message : in String) is
   138.    begin
   139.       if debugging_is_enabled then
   140.          panel_logger.show(message);
   141.          flush;
   142.       end if;
   143.    end show;
   144.
   145.    procedure show_line (message : in String) is
   146.    begin
   147.       if debugging_is_enabled then
   148.          panel_logger.show_line(message);
   149.          flush;
   150.       end if;
   151.    end show_line;
   152.
   153.    procedure interact (reason : in String := "Mode") is
   154.    begin
   155.       panel_logger.interact(reason);
   156.    end interact;
   157.
   158.    procedure open (logfile_name : in String) is
   159.    begin
   160.       cc_list.open(logfile_name);
   161.    end open;
   162.
   163.    procedure close (logfile_name : in String) is
   164.    begin
   165.       cc_list.close(logfile_name);
   166.    end close;
   167.
   168.    procedure flush (iff : in Boolean := True) is
   169.    begin
   170.       cc_list.flush(iff);
   171.    end flush;
   172.
   173.    procedure log_to_file (message : in String) is
   174.    begin
   175.       file_logger.log(message);
   176.       file_logger.log_new_line;
   177.    end log_to_file;
   178.
   179. begin
   180.    cc_list.set_logger_list((file_logger'Access, panel_logger'Access));
   181. end HCI;

Compiling: ../Source/hci.ads
Source file time stamp: 2021-02-11 18:23:37
Compiled at: 2021-02-21 15:54:04

     1. -- Provide operations supporting replicated human-readable output:
     2. --    1: to an interactive user interface for transient display, and
     3. --    2: to a file for persistent storage.
     4. -- If no file has been opened, or if it has been explicitly closed,
     5. --    output is to the interactive interface only.
     6. --
     7. -- Also provide operations allowing synchronization with the user.
     8. --
     9. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
    10. -- Copyright (C) 2021, W. Findlay; all rights reserved.
    11. --
    12. -- The ee9 program is free software; you can redistribute it and/or
    13. -- modify it under terms of the GNU General Public License as published
    14. -- by the Free Software Foundation; either version 3, or (at your option)
    15. -- any later version. This program is distributed in the hope that it
    16. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    17. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    18. -- See the GNU General Public License for more details. You should have
    19. -- received a copy of the GNU General Public License distributed with
    20. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    21. --
    22.
    23. with logging.file;
    24. with logging.panel;
    25.
    26. use  logging.file;
    27. use  logging.panel;
    28.
    29. package HCI is
    30.
    31.    file_logger  : aliased logging.file.output;
    32.    panel_logger : aliased logging.panel.display;
    33.
    34.    procedure tab_log (at_least : in Natural;
    35.                       spacing  : in Positive := 6;
    36.                       iff      : in Boolean := True);
    37.
    38.    procedure tab_log_to (column : in Positive;
    39.                          iff    : in Boolean := True);
    40.
    41.    procedure log (char : in Character;
    42.                   iff  : in Boolean := True);
    43.
    44.    procedure log (text : in String;
    45.                   iff  : in Boolean := True);
    46.
    47.    procedure log_line (text : in String;
    48.                        iff  : in Boolean := True);
    49.
    50.    procedure log_new_line (iff : in Boolean := True);
    51.
    52.    procedure log_rule (start_a_new_line : in Boolean := False;
    53.                        iff              : in Boolean := True);
    54.
    55.    procedure log_rule_half (second_half : in Boolean := False);
    56.
    57.    procedure log_message (message : in String);
    58.
    59.    procedure log_title (message : in String);
    60.
    61.    procedure log_ee9_status (message  : in String;
    62.                              skip     : in Natural := 0;
    63.                              complete : in Boolean := True;
    64.                              iff      : in Boolean := True);
    65.
    66.    procedure log_API_message (message  : in String;
    67.                               skip     : in Natural := 1);
    68.
    69.    procedure hoot (message : in String := "");
    70.
    71.    procedure show (message : in String);
    72.
    73.    procedure show_line (message : in String);
    74.
    75.    procedure interact (reason : in String := "Mode");
    76.
    77.    procedure open  (logfile_name : in String);
    78.
    79.    procedure close (logfile_name : in String);
    80.
    81.    procedure flush (iff : in Boolean := True);
    82.
    83.    procedure log_to_file (message : in String);
    84.
    85. end HCI;

 181 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc.adb
Source file time stamp: 2021-02-20 17:37:23
Compiled at: 2021-02-21 15:54:04

     1. -- Emulation of the common functionality of a KDF9 IOC "buffer" (DMA channel),
     2. --    with fail-stop stubs for operations having device-specific behaviour.
     3. --
     4. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with KDF9.CPU;
    19. with KDF9.PHU_store;
    20. with tracing;
    21.
    22. with IOC.the_locker_of;
    23.
    24. use  KDF9.CPU;
    25. use  KDF9.PHU_store;
    26. use  tracing;
    27.
    28. package body IOC is
    29.
    30.    procedure set_state_of (the_buffer : in device_class_access;
    31.                            allocated  : in Boolean) is
    32.    begin
    33.       if the_buffer /= null then
    34.          if the_buffer.is_allocated = allocated then
    35.             -- Allocating an already allocated device, or deallocating an unallocated device.
    36.             -- Both are benign, so ignore.
    37.             return;
    38.          else
    39.             the_buffer.is_allocated := allocated;
    40.             the_CPDAR(the_buffer.number) := allocated;
    41.          end if;
    42.       end if;
    43.     end set_state_of;
    44.
    45.    function is_allocated (the_buffer : device_class_access)
    46.    return Boolean
    47.    is (the_buffer.is_allocated);
    48.
    49.    function is_unallocated (the_buffer : device_class_access)
    50.    return Boolean
    51.    is (not the_buffer.is_allocated);
    52.
    53.    hex : constant String := "0123456789ABCDEF";
    54.
    55.    function device_name_of (the_buffer : IOC.device)
    56.    return IOC.device_name is
    57.       its : IOC.device'Class renames IOC.device'Class(the_buffer);
    58.    begin
    59.       return IOC.device_kind'Image(its.kind)(1..2) & hex(Natural(its.unit)+1);
    60.    end device_name_of;
    61.
    62.    function device_name_of (the_number : IOC.device_number)
    63.    return IOC.device_name
    64.    is (device_name_of(buffer(the_number).all));
    65.
    66.    function device_kind_of (the_number : IOC.device_number)
    67.    return IOC.device_kind
    68.    is (buffer(the_number).kind);
    69.
    70.    procedure install (the_device : in out IOC.device'Class) is
    71.    begin
    72.       buffer(the_device.number) := the_device'Unchecked_Access;
    73.    end install;
    74.
    75.    overriding
    76.    procedure Initialize (the_buffer : in out IOC.device) is
    77.    begin
    78.       if not IOC.device'Class(the_buffer).is_open then
    79.          the_buffer.is_abnormal := True;
    80.          the_buffer.is_offline  := True;
    81.       end if;
    82.       install(the_buffer);
    83.    end Initialize;
    84.
    85.    procedure open (the_buffer : in out IOC.device'Class;
    86.                    the_mode   : in POSIX.access_mode) is
    87.    begin
    88.       the_buffer.device_name := device_name_of(the_buffer);
    89.       host_IO.open(the_buffer.stream, the_buffer.device_name, the_mode);
    90.       if the_buffer.is_open then
    91.          if the_mode = write_mode then
    92.             truncate(the_buffer.stream);
    93.          end if;
    94.       else
    95.          trap_operator_error(the_buffer.device_name & " cannot be found");
    96.       end if;
    97.       IOC.device(the_buffer).Initialize;
    98.    end open;
    99.
   100.    overriding
   101.    procedure Finalize (the_buffer : in out IOC.device) is
   102.    begin
   103.       if IOC.device'Class(the_buffer).is_open   and then
   104.             IOC.device'Class(the_buffer).usage /= 0 then
   105.          IOC.device'Class(the_buffer).close;
   106.       end if;
   107.    end Finalize;
   108.
   109.    function usage (the_buffer : IOC.device)
   110.    return KDF9.word is
   111.    begin
   112.       return the_buffer.stream.bytes_moved;
   113.    end usage;
   114.
   115.    procedure flush (the_buffer : in out IOC.device) is
   116.    begin
   117.       flush(the_buffer.stream);
   118.    end flush;
   119.
   120.    procedure close (the_buffer : in out IOC.device) is
   121.    begin
   122.       close(the_buffer.stream);
   123.       IOC.buffer(the_buffer.number) := null;
   124.    end close;
   125.
   126.    procedure finalize_all_KDF9_buffers is
   127.    begin
   128.       for b in IOC.buffer'Range loop
   129.          if IOC.buffer(b) /= null then
   130.             Finalize(IOC.buffer(b).all);
   131.          end if;
   132.       end loop;
   133.    end finalize_all_KDF9_buffers;
   134.
   135.    procedure add_in_the_IO_lockout_CPU_time (Q_operand : in KDF9.Q_register) is
   136.       IO_size : constant KDF9.Q_part := Q_operand.M - Q_operand.I;
   137.    begin
   138.       the_CPU_delta := the_CPU_delta + KDF9.us(IO_size + group_size - 1) / group_size;
   139.    end add_in_the_IO_lockout_CPU_time;
   140.
   141.    function IO_elapsed_time (the_buffer   : IOC.device;
   142.                              atomic_items : KDF9.word)
   143.    return KDF9.us
   144.    is (
   145.        if IOC.device'Class(the_buffer).is_open then
   146.           KDF9.us(atomic_items) * IOC.device'Class(the_buffer).quantum
   147.        else
   148.           0
   149.       );
   150.
   151.    function IO_elapsed_time_total (the_buffer : IOC.device)
   152.    return KDF9.us
   153.    is (IO_elapsed_time(IOC.device'Class(the_buffer), IOC.device'Class(the_buffer).usage));
   154.
   155.    procedure validate_device (the_buffer : in IOC.device'Class) is
   156.    begin
   157.       if not the_CPDAR(the_buffer.number) and then
   158.             the_CPU_state /= Director_state   then
   159.          trap_illegal_instruction("unallocated I/O device " & the_buffer.device_name);
   160.       end if;
   161.    end validate_device;
   162.
   163.    procedure validate_bounds (Q_operand : in KDF9.Q_register) is
   164.    begin
   165.       if Q_operand.I > Q_operand.M then
   166.          trap_illegal_instruction("invalid I/O Q operand: I > M");
   167.       end if;
   168.       validate_address_range(Q_operand.I, Q_operand.M);
   169.    end validate_bounds;
   170.
   171.    procedure validate_transfer (the_buffer : in IOC.device'Class;
   172.                                 Q_operand  : in KDF9.Q_register) is
   173.    begin
   174.       validate_device(the_buffer);
   175.       validate_bounds(Q_operand);
   176.    end validate_transfer;
   177.
   178.    procedure validate_parity (the_buffer : in IOC.device'Class) is
   179.    begin
   180.       if the_buffer.is_abnormal then
   181.          trap_illegal_instruction(the_buffer.device_name & " is abnormal (parity error or EOF)");
   182.       end if;
   183.    end validate_parity;
   184.
   185.    procedure require_positive_count (count : in KDF9.Q_part) is
   186.    begin
   187.       if resign(count) <= 0 then
   188.          trap_illegal_instruction("I/O repetition count <= 0");
   189.       end if;
   190.    end require_positive_count;
   191.
   192.    procedure require_nonnegative_count (count : in KDF9.Q_part) is
   193.    begin
   194.       if resign(count) < 0 then
   195.          trap_illegal_instruction("I/O repetition count < 0");
   196.       end if;
   197.    end require_nonnegative_count;
   198.
   199.    function control_word_image (the_buffer : in IOC.device'Class)
   200.    return String
   201.    is (
   202.        the_buffer.device_name
   203.      & " Q"  & the_buffer.control_word.C'Image
   204.      & "/#"  & oct_of(the_buffer.control_word.I)
   205.      & "/#"  & oct_of(the_buffer.control_word.M)
   206.       );
   207.
   208.    -- In boot mode, punt the LOV interrupt to Director.
   209.    -- In other modes, advance the elapsed time to the next-interrupt time,
   210.    --    and suppress the LOV by simulating an earlier end of transfer.
   211.    procedure handle_a_buffer_lockout (the_buffer : in IOC.device'Class) is
   212.    begin
   213.       PHU(CPL) := (
   214.                    is_held_up => True,
   215.                    blockage   => (buffer_busy, the_buffer.number, by_INTQq => False)
   216.                   );
   217.       take_note_of_buffer_lockout(the_buffer.device_name, the_buffer.operation);
   218.       if the_execution_mode = boot_mode then
   219.          LOV_if_user_mode(the_buffer.device_name & " is busy");
   220.       else
   221.          advance_the_clock(the_buffer.completion_time);
   222.          act_on_pending_interrupts;
   223.       end if;
   224.    end handle_a_buffer_lockout;
   225.
   226.    procedure deal_with_a_busy_device (the_buffer  : in out IOC.device'Class;
   227.                                       order_time  : in KDF9.us;
   228.                                       set_offline : in Boolean) is
   229.    begin
   230.       advance_the_clock(the_clock_time+order_time);
   231.       if the_buffer.is_busy then
   232.          handle_a_buffer_lockout(the_buffer);
   233.       end if;
   234.       the_buffer.is_offline := set_offline;
   235.    end deal_with_a_busy_device;
   236.
   237.    procedure finalize_transfer (the_buffer : in out IOC.device'Class;
   238.                                 need_EDT,
   239.                                 need_PR    : out Boolean);
   240.
   241.    procedure start_data_transfer (the_buffer   : in out IOC.device'Class;
   242.                                   Q_operand    : in KDF9.Q_register;
   243.                                   set_offline  : in Boolean;
   244.                                   busy_time    : in KDF9.us;
   245.                                   operation    : in IOC.transfer_kind := some_other_operation) is
   246.       pragma Unreferenced(set_offline);
   247.       transferring_data : constant Boolean := operation in input_operation | output_operation;
   248.       time_now          : constant KDF9.us := the_clock_time;
   249.       real_Q            : KDF9.Q_register := Q_operand;
   250.       EDT_needed,
   251.       PR_needed         : Boolean;
   252.    begin
   253.       -- Check the IO parameters and the buffer state, and handle any lockout set by another device.
   254.       validate_device(the_buffer);
   255.
   256.       if transferring_data then
   257.          validate_bounds(real_Q);
   258.          real_Q := (real_Q.C, real_Q.I+BA, real_Q.M+BA);
   259.       else
   260.          require_nonnegative_count(real_Q.M);
   261.       end if;
   262.
   263.       validate_parity(the_buffer);
   264.
   265.       if the_buffer.is_busy then
   266.          handle_a_buffer_lockout(the_buffer);
   267.          if the_execution_mode = boot_mode then
   268.             finalize_transfer (the_buffer, EDT_needed, PR_needed);
   269.             if the_next_interrupt_time > time_now + 1_024_000 then
   270.                the_next_interrupt_time := time_now + 1_024_000;
   271.             end if;
   272.             if EDT_needed then
   273.                effect_interrupt(caused_by_EDT, the_buffer.control_word_image);
   274.             elsif PR_needed then
   275.                effect_interrupt(caused_by_PR, the_buffer.control_word_image);
   276.             end if;
   277.          end if;
   278.       end if;
   279.
   280.       if transferring_data                            and then
   281.             there_are_locks_in_physical_addresses(real_Q) then
   282.          LOV_if_user_mode(
   283.                           "in "
   284.                        &  "#"   & oct_of(the_buffer.control_word.I)
   285.                        &  "/#"  & oct_of(the_buffer.control_word.M)
   286.                        &  " for "
   287.                        &  the_buffer.device_name
   288.                          );
   289.       end if;
   290.
   291.       -- Set up the transfer parameters.
   292.       the_buffer.is_for_Director := (the_CPU_state = Director_state);
   293.       the_buffer.priority_level  := CPL;
   294.       the_buffer.control_word    := real_Q;
   295.       the_buffer.operation       := operation;
   296.       the_buffer.order_count     := ICR+1;
   297.       the_buffer.order_address   := CIA;
   298.       the_buffer.decoded_order   := INS;
   299.       the_buffer.initiation_time := time_now;
   300.       the_buffer.transfer_time   := busy_time;
   301.       the_buffer.completion_time := the_buffer.initiation_time + busy_time;
   302.
   303.       if busy_time > 0 or transferring_data then
   304.          if the_buffer.completion_time < the_next_interrupt_time then
   305.             the_next_interrupt_time := the_buffer.completion_time;
   306.          end if;
   307.          the_buffer.is_busy := True;
   308.          take_note_of_IO_start(
   309.                                the_buffer.device_name,
   310.                                the_buffer.completion_time,
   311.                                the_buffer.control_word,
   312.                                the_buffer.operation
   313.                               );
   314.       else
   315.          the_buffer.is_busy := False;
   316.          take_note_of_IO_finis (
   317.                                 the_buffer.order_count,
   318.                                 the_buffer.order_address,
   319.                                 the_buffer.decoded_order,
   320.                                 the_buffer.initiation_time,
   321.                                 the_buffer.device_name,
   322.                                 the_buffer.is_for_Director,
   323.                                 the_buffer.priority_level,
   324.                                 the_buffer.completion_time,
   325.                                 the_buffer.control_word,
   326.                                 the_buffer.operation
   327.                                );
   328.       end if;
   329.       PHU(CPL) := idle_PHU;
   330.    end start_data_transfer;
   331.
   332.    -- start_slow_transfer takes a pessimistic view of transfers-to-End_Message.
   333.    -- When the actual transfer length is known, the end-of-transfer time can be
   334.    --    made more realistic by specifying its real length to correct_transfer_time.
   335.    -- correct_transfer_time must be called before finalize_transfer is called.
   336.
   337.    procedure correct_transfer_time (the_buffer  : in out IOC.device'Class;
   338.                                     actual_time : in KDF9.us) is
   339.    begin
   340.       the_buffer.transfer_time :=  actual_time;
   341.       the_buffer.completion_time := the_buffer.initiation_time + the_buffer.transfer_time;
   342.       if the_buffer.completion_time < the_next_interrupt_time then
   343.          the_next_interrupt_time := the_buffer.completion_time;
   344.       end if;
   345.    end correct_transfer_time;
   346.
   347.    procedure correct_transfer_time (the_buffer    : in out IOC.device'Class;
   348.                                     actual_length : in KDF9.word) is
   349.    begin
   350.       the_buffer.transfer_time := IO_elapsed_time(the_buffer, actual_length);
   351.       the_buffer.completion_time := the_buffer.initiation_time + the_buffer.transfer_time;
   352.       if the_buffer.completion_time < the_next_interrupt_time then
   353.          the_next_interrupt_time := the_buffer.completion_time;
   354.       end if;
   355.    end correct_transfer_time;
   356.
   357.    -- If the buffer has a terminated transfer, clear its lockouts, reset its state,
   358.    --    update the PHUs, and demand an EDT or PR interrupt as needed.
   359.    procedure finalize_transfer (the_buffer : in out IOC.device'Class;
   360.                                 need_EDT,
   361.                                 need_PR    : out Boolean) is
   362.       the_PHU : KDF9.PHU_store.PHU_register renames KDF9.PHU_store.PHU(the_buffer.priority_level);
   363.       blocked : PHU_reason;
   364.    begin
   365.       if the_buffer.transfer_time /= 0 then
   366.          take_note_of_IO_finis (
   367.                                 the_buffer.order_count,
   368.                                 the_buffer.order_address,
   369.                                 the_buffer.decoded_order,
   370.                                 the_buffer.initiation_time,
   371.                                 the_buffer.device_name,
   372.                                 the_buffer.is_for_Director,
   373.                                 the_buffer.priority_level,
   374.                                 the_buffer.completion_time,
   375.                                 the_buffer.control_word,
   376.                                 the_buffer.operation
   377.                                );
   378.       end if;
   379.
   380.       need_EDT := the_buffer.is_for_Director;
   381.
   382.       -- Clear down the transfer and idle the buffer.
   383.       if the_buffer.operation in input_operation | output_operation then
   384.          unlock_absolute_addresses(the_buffer.control_word);
   385.       end if;
   386.       the_buffer.is_busy := False;
   387.       the_buffer.is_for_Director := False;
   388.
   389.       -- The following code is somewhat redundant, but written like this to exactly mirror the
   390.       -- logic stated in the KDF9 TIME-SHARING DIRECTOR SUPPORT DOCUMENTATION of 1-May-1965.
   391.       need_PR := False;
   392.       if the_PHU.is_held_up then
   393.          blocked := the_PHU.blockage;
   394.          if (blocked.reason = buffer_busy and then blocked.by_INTQq)                      or else
   395.             (blocked.reason = buffer_busy and then not buffer(blocked.buffer_nr).is_busy) or else
   396.             (blocked.reason = locked_core and then is_unlocked(blocked.group_nr))            then
   397.             the_PHU := idle_PHU;
   398.             need_PR := the_buffer.priority_level < CPL;
   399.          end if;
   400.       end if;
   401.
   402.       -- A PR interrupt may be wanted, BUT not if an EDT interrupt is wanted.
   403.       -- EDT is wanted if the transfer was for Director OR another program awaits the same buffer.
   404.
   405.       -- Check the rest of the PHU stores for an EDT interrupt.
   406.       -- This is needed only when running a Director.
   407.       if the_execution_mode = boot_mode then
   408.          -- Test for possible priority inversion, i.e. other program(s) blocked on this buffer.
   409.          for p of PHU loop
   410.             if p.is_held_up                               and then
   411.                   p.blockage.reason = buffer_busy         and then
   412.                      p.blockage.buffer_nr = the_buffer.number then
   413.                -- The KDF9 TIME-SHARING DIRECTOR SUPPORT DOCUMENTATION of 1-May-1965
   414.                --   says such a PHU is NOT cleared, but EDT is requested INSTEAD of PR,
   415.                --   so Director can take action according to what it finds there.
   416.                need_EDT := True;
   417.             end if;
   418.          end loop;
   419.       end if;
   420.       if need_EDT then
   421.          need_PR := False;
   422.       end if;
   423.    end finalize_transfer;
   424.
   425.    procedure act_on_pending_interrupts is
   426.       time_now   : constant KDF9.us := the_clock_time;
   427.       EDT_needed,
   428.       PR_needed  : Boolean := False;
   429.       number     : IOC.device_number;
   430.    begin
   431.       advance_the_clock(the_next_interrupt_time);
   432.       -- Predict another interrupt (at most 2**20 seconds in the future in boot mode).
   433.       the_next_interrupt_time := KDF9.us'Last;
   434.       for b of buffer loop
   435.          if b /= null and then
   436.                b.is_busy  then
   437.             if time_now >= b.completion_time then
   438.                finalize_transfer(b.all, EDT_needed, PR_needed);
   439.                if EDT_needed or PR_needed then
   440.                   number := b.number;
   441.                end if;
   442.             elsif the_next_interrupt_time > b.completion_time then
   443.                the_next_interrupt_time := b.completion_time;
   444.             end if;
   445.          end if;
   446.       end loop;
   447.       -- Prevent an inadvertant double clock interrupt.
   448.       if the_execution_mode = boot_mode                and then
   449.             the_next_interrupt_time > time_now + 2**24 - 1 then
   450.          the_next_interrupt_time := time_now + 2**24 - 1;
   451.       end if;
   452.       if EDT_needed then
   453.          effect_interrupt(caused_by_EDT, buffer(number).control_word_image);
   454.       elsif PR_needed then
   455.          effect_interrupt(caused_by_PR, buffer(number).control_word_image);
   456.       end if;
   457.    end act_on_pending_interrupts;
   458.
   459.    -- Advance the time to a point after all extant transfer have terminated,
   460.    --    finalizing all extant transfer in temporal order in the process.
   461.    procedure complete_all_extant_transfers is
   462.       EDT_needed,
   463.       PR_needed      : Boolean := False;
   464.       last_time      : KDF9.us := 0;
   465.       next_time      : KDF9.us;
   466.    begin
   467.       -- At least one transfer should be terminated each time around outer_loop,
   468.       --    if not, outer_loop is exited.
   469.    outer_loop:
   470.       for c in buffer'Range loop
   471.          -- Find the earliest transfer termination time.
   472.          next_time := KDF9.us'Last;
   473.          for b of buffer loop
   474.             if b /= null                       and then
   475.                   b.is_busy                    and then
   476.                      b.completion_time < next_time then
   477.                next_time := b.completion_time;
   478.             end if;
   479.          end loop;
   480.
   481.          if next_time = KDF9.us'Last then
   482.             -- All the buffers are quiescent.
   483.             exit outer_loop;
   484.          else
   485.             -- At least one transfer remains to be finalized.
   486.             advance_the_clock(next_time);
   487.             last_time := KDF9.us'Max(last_time, next_time);
   488.          end if;
   489.
   490.          -- Finalize all transfers with completion time <= next_time.
   491.          for b of buffer loop
   492.             if b /= null                        and then
   493.                   b.is_busy                     and then
   494.                      b.completion_time <= next_time then
   495.                finalize_transfer(b.all, EDT_needed, PR_needed);
   496.             end if;
   497.          end loop;
   498.
   499.       end loop outer_loop;
   500.    end complete_all_extant_transfers;
   501.
   502.    procedure handle_a_main_store_lockout is
   503.       the_locker : KDF9.buffer_number;
   504.       found      : Boolean;
   505.    begin
   506.       PHU(CPL) := (
   507.                    is_held_up => True,
   508.                    blockage   => (locked_core, group_address(group(the_locked_out_address)))
   509.                   );
   510.       -- Store access LOV interrupts invoke instruction restart outside Director.
   511.       the_locker := the_locker_of(the_locked_out_address, found);
   512.       if not found then
   513.          raise emulation_failure with "cannot find a buffer responsible for this store lockout";
   514.       end if;
   515.       take_note_of_store_lockout(device_name_of(buffer(the_locker).all));
   516.       if the_execution_mode = boot_mode then
   517.          if_user_mode_then_LOV(the_locked_out_address);
   518.       else
   519.          set_NIA_to(CIA);
   520.          advance_the_clock(buffer(the_locker).completion_time);
   521.          act_on_pending_interrupts;
   522.       end if;
   523.       ICR := ICR + 1;
   524.    end handle_a_main_store_lockout;
   525.
   526.    procedure MANUAL_CT (the_buffer  : in out IOC.device'Class;
   527.                         Q_operand   : in KDF9.Q_register;
   528.                         set_offline : in Boolean) is
   529.       EDT_needed, PR_needed : Boolean := False;
   530.    begin
   531.       validate_device(the_buffer);
   532.       take_note_of_test(the_buffer.device_name, Q_operand, the_buffer.is_busy);
   533.       -- ee9 allows the transfer to terminate normally, as if MANUALQ with set_offline = True;
   534.       --    even when set_offline = False, i.e. CTQ, which aborted any residual I/O on the KDF9.
   535.       if the_buffer.is_busy then
   536.          the_buffer.completion_time := KDF9.us'Min(the_buffer.completion_time, the_clock_time);
   537.          finalize_transfer(the_buffer, EDT_needed, PR_needed);
   538.       end if;
   539.       the_buffer.is_busy     := False;
   540.       the_buffer.operation   := some_other_operation;
   541.       the_buffer.is_abnormal := False;
   542.       the_buffer.is_offline  := set_offline;
   543.    end MANUAL_CT;
   544.
   545.    procedure INT (the_buffer  : in out IOC.device'Class;
   546.                   Q_operand   : in KDF9.Q_register;
   547.                   set_offline : in Boolean) is
   548.       now  : constant KDF9.us := the_clock_time;
   549.       step : KDF9.us;
   550.    begin
   551.       validate_device(the_buffer);
   552.       if the_buffer.is_busy then
   553.          PHU(CPL) := (
   554.                       is_held_up => True,
   555.                       blockage   => (buffer_busy, the_buffer.number, by_INTQq => True)
   556.                      );
   557.          take_note_of_buffer_lockout(the_buffer.device_name, the_buffer.operation);
   558.          if the_execution_mode = boot_mode then
   559.             step := KDF9.us'Max((the_buffer.completion_time - now) / 16, 1);
   560.             advance_the_clock(KDF9.us'Min(the_buffer.completion_time, now + step));
   561.             effect_interrupt(caused_by_PR, control_word_image(the_buffer));
   562.          else
   563.             advance_the_clock(the_buffer.completion_time);
   564.             act_on_pending_interrupts;
   565.          end if;
   566.       else
   567.          take_note_of_test(the_buffer.device_name, Q_operand, False);
   568.       end if;
   569.       the_buffer.is_offline := set_offline;
   570.    end INT;
   571.
   572.    procedure BUSY (the_buffer  : in out IOC.device'Class;
   573.                    Q_operand   : in KDF9.Q_register;
   574.                    set_offline : in Boolean;
   575.                    result      : out Boolean) is
   576.    begin
   577.       validate_device(the_buffer);
   578.       result := the_buffer.is_busy;
   579.       take_note_of_test(the_buffer.device_name, Q_operand, result);
   580.       if the_buffer.is_busy and then
   581.             (the_execution_mode /= boot_mode or the_CPU_state = Director_state) then
   582.          act_on_pending_interrupts;
   583.       end if;
   584.       the_buffer.is_offline := set_offline;
   585.    end BUSY;
   586.
   587.    procedure PAR (the_buffer  : in out IOC.device'Class;
   588.                   Q_operand   : in KDF9.Q_register;
   589.                   set_offline : in Boolean;
   590.                   result      : out Boolean) is
   591.    begin
   592.       validate_device(the_buffer);
   593.       deal_with_a_busy_device(the_buffer, 13, set_offline);
   594.       result := the_buffer.is_abnormal;
   595.       take_note_of_test(the_buffer.device_name, Q_operand, result);
   596.       the_buffer.is_abnormal := False;
   597.       the_buffer.is_offline := set_offline;
   598.    end PAR;
   599.
   600.    subtype IO_mnemonic is String(1 .. 5);
   601.    type synonyms       is array (1 .. 2) of IO_mnemonic;
   602.    type synonym_list   is array (Positive range <>) of synonyms;
   603.
   604.    FW_synonyms  : constant synonym_list
   605.                 := (
   606.                     ("POA  ", "TW   "), ("POB  ", "TWE  "),
   607.                     ("PIA  ", "TR   "), ("PIB  ", "TRE  ")
   608.                    );
   609.
   610.    TR_synonyms  : constant synonym_list
   611.                 := (
   612.                     ("PIA  ", "PR   "), ("PIB  ", "PRE  "),
   613.                     ("PIC  ", "PRC  "), ("PID  ", "PRCE ")
   614.                    );
   615.
   616.    TP_synonyms  : constant synonym_list
   617.                 := (
   618.                     ("POA  ", "PW   "), ("POB  ", "PWE  "),
   619.                     ("POC  ", "PWC  "), ("POD  ", "PWCE "),
   620.                     ("POE  ", "PGAP ")
   621.                    );
   622.
   623.    LP_synonyms  : constant synonym_list
   624.                 := (
   625.                     ("POA  ", "LP   "), ("POB  ", "LPE  ")
   626.                    );
   627.
   628.    MT_synonyms  : constant synonym_list
   629.                 := (
   630.                     ("PIA  ", "MFR  "), ("PIB  ", "MFRE "),
   631.                     ("PIE  ", "MBR  "), ("PIF  ", "MBRE "),
   632.                     ("POA  ", "MW   "), ("POB  ", "MWE  "),
   633.                     ("POC  ", "MLW  "), ("POD  ", "MLWE "),
   634.                     ("POE  ", "MGAP "), ("POF  ", "MWIPE"),
   635.                     ("PMA  ", "MFSK "), ("PMB  ", "MBT  "),
   636.                     ("PMC  ", "MLB  "), ("PMD  ", "MRWD "),
   637.                     ("PME  ", "MBSK "), ("PMF  ", "MET  ")
   638.                    );
   639.
   640.    function mnemonic (order : in String; class : in IOC.device_name)
   641.    return String is
   642.
   643.       key : constant IO_mnemonic := just_left(order(order'First..order'First+2), 5);
   644.       Qij : constant String      := order(order'First+3..order'Last);
   645.
   646.       function choose (synonyms : synonym_list)
   647.       return String is
   648.       begin
   649.          for s of synonyms loop
   650.             if s(1) = key then return trimmed(s(2)) & Qij; end if;
   651.          end loop;
   652.          return order;
   653.       end choose;
   654.
   655.       XY : constant String(1..2) := class(class'First..class'First+1);
   656.
   657.    begin
   658.       if key(1..3) in "TLO" | "CLO" | "PMH" | "SLO" then
   659.          -- These orders do not necessarily involve a device.
   660.          return order;
   661.       end if;
   662.       if XY in "AD" | "CP" | "CR" | "DR" | "FD" | "GP" | "ST" | "SI" then
   663.          return order;
   664.       elsif XY = "FW" then -- FlexoWriter
   665.          return choose(FW_synonyms);
   666.       elsif XY = "LP" then -- Line Printer
   667.          return choose(LP_synonyms);
   668.       elsif XY = "MT" then -- Magnetic Tape
   669.          return choose(MT_synonyms);
   670.       elsif XY = "TP" then -- Tape Punch
   671.          return choose(TP_synonyms);
   672.       elsif XY = "TR" then -- Tape Reader
   673.          return choose(TR_synonyms);
   674.       else
   675.          return "??";
   676.       end if;
   677.    end mnemonic;
   678.
   679.    procedure trap_failing_IO_operation (the_buffer : in out IOC.device; the_message : in String) is
   680.       the_diagnostic : constant String := "%" & the_message & " on " & the_buffer.device_name;
   681.    begin
   682.       if the_execution_mode in program_mode | test_program_mode then
   683.          raise IO_error with the_diagnostic;
   684.       elsif the_CPU_state = program_state then
   685.          the_buffer.is_abnormal := True;
   686.          raise abandon_this_order with the_diagnostic;
   687.       else
   688.          -- The Director itself has gone seriously wrong.
   689.          raise Director_IO_error with the_diagnostic;
   690.       end if;
   691.    end trap_failing_IO_operation;
   692.
   693.    procedure trap_illegal_IO_operation (order       : in String;
   694.                                         buffer      : in IOC.device;
   695.                                         Q_operand   : in KDF9.Q_register;
   696.                                         set_offline : in Boolean) is
   697.       pragma Unreferenced(Q_operand);
   698.       pragma Unreferenced(set_offline);
   699.    begin
   700.       trap_illegal_instruction(order & " cannot be used on " & buffer.device_name);
   701.    end trap_illegal_IO_operation;
   702.
   703.    --
   704.    -- The following bodies provide inheritable default actions for
   705.    -- operations that are not implemented by specific device types.
   706.    --
   707.
   708.    procedure PIA (the_buffer  : in out IOC.device;
   709.                   Q_operand   : in KDF9.Q_register;
   710.                   set_offline : in Boolean) is
   711.    begin
   712.       trap_illegal_IO_operation("PIA", the_buffer, Q_operand, set_offline);
   713.    end PIA;
   714.
   715.    procedure PIB (the_buffer  : in out IOC.device;
   716.                   Q_operand   : in KDF9.Q_register;
   717.                   set_offline : in Boolean) is
   718.    begin
   719.       trap_illegal_IO_operation("PIB", the_buffer, Q_operand, set_offline);
   720.    end PIB;
   721.
   722.    procedure PIC (the_buffer  : in out IOC.device;
   723.                   Q_operand   : in KDF9.Q_register;
   724.                   set_offline : in Boolean) is
   725.    begin
   726.       trap_illegal_IO_operation("PIC", the_buffer, Q_operand, set_offline);
   727.    end PIC;
   728.
   729.    procedure PID (the_buffer  : in out IOC.device;
   730.                   Q_operand   : in KDF9.Q_register;
   731.                   set_offline : in Boolean) is
   732.    begin
   733.       trap_illegal_IO_operation("PID", the_buffer, Q_operand, set_offline);
   734.    end PID;
   735.
   736.    procedure PIE (the_buffer  : in out IOC.device;
   737.                   Q_operand   : in KDF9.Q_register;
   738.                   set_offline : in Boolean) is
   739.    begin
   740.       trap_illegal_IO_operation("PIE", the_buffer, Q_operand, set_offline);
   741.    end PIE;
   742.
   743.    procedure PIF (the_buffer  : in out IOC.device;
   744.                   Q_operand   : in KDF9.Q_register;
   745.                   set_offline : in Boolean) is
   746.    begin
   747.       trap_illegal_IO_operation("PIF", the_buffer, Q_operand, set_offline);
   748.    end PIF;
   749.
   750.    procedure PIG (the_buffer  : in out IOC.device;
   751.                   Q_operand   : in KDF9.Q_register;
   752.                   set_offline : in Boolean) is
   753.    begin
   754.       trap_illegal_IO_operation("PIG", the_buffer, Q_operand, set_offline);
   755.    end PIG;
   756.
   757.    procedure PIH (the_buffer  : in out IOC.device;
   758.                   Q_operand   : in KDF9.Q_register;
   759.                   set_offline : in Boolean) is
   760.    begin
   761.       trap_illegal_IO_operation("PIH", the_buffer, Q_operand, set_offline);
   762.    end PIH;
   763.
   764.    procedure PMA (the_buffer  : in out IOC.device;
   765.                   Q_operand   : in KDF9.Q_register;
   766.                   set_offline : in Boolean) is
   767.    begin
   768.       trap_illegal_IO_operation("PMA", the_buffer, Q_operand, set_offline);
   769.    end PMA;
   770.
   771.    procedure PMB (the_buffer  : in out IOC.device;
   772.                   Q_operand   : in KDF9.Q_register;
   773.                   set_offline : in Boolean)
   774.    is null;
   775.
   776.    procedure PMC (the_buffer  : in out IOC.device;
   777.                   Q_operand   : in KDF9.Q_register;
   778.                   set_offline : in Boolean)
   779.    is null;
   780.
   781.    procedure PMD (the_buffer  : in out IOC.device;
   782.                   Q_operand   : in KDF9.Q_register;
   783.                   set_offline : in Boolean) is
   784.    begin
   785.       trap_illegal_IO_operation("PMD", the_buffer, Q_operand, set_offline);
   786.    end PMD;
   787.
   788.    procedure PME (the_buffer  : in out IOC.device;
   789.                   Q_operand   : in KDF9.Q_register;
   790.                   set_offline : in Boolean) is
   791.    begin
   792.       trap_illegal_IO_operation("PME", the_buffer, Q_operand, set_offline);
   793.    end PME;
   794.
   795.    procedure PMF (the_buffer  : in out IOC.device;
   796.                   Q_operand   : in KDF9.Q_register;
   797.                   set_offline : in Boolean)
   798.    is null;
   799.
   800.    procedure PMG (the_buffer  : in out IOC.device;
   801.                   Q_operand   : in KDF9.Q_register;
   802.                   set_offline : in Boolean) is
   803.    begin
   804.       trap_illegal_IO_operation("PMG", the_buffer, Q_operand, set_offline);
   805.    end PMG;
   806.
   807. -- procedure PMH is subsumed by SLOC.
   808.
   809.    procedure PMK (the_buffer  : in out IOC.device;
   810.                   Q_operand   : in KDF9.Q_register;
   811.                   set_offline : in Boolean) is
   812.    begin
   813.       trap_illegal_IO_operation("PMK", the_buffer, Q_operand, set_offline);
   814.    end PMK;
   815.
   816.    procedure PML (the_buffer  : in out IOC.device;
   817.                   Q_operand   : in KDF9.Q_register;
   818.                   set_offline : in Boolean) is
   819.    begin
   820.       trap_illegal_IO_operation("PML", the_buffer, Q_operand, set_offline);
   821.    end PML;
   822.
   823.    procedure POA (the_buffer  : in out IOC.device;
   824.                   Q_operand   : in KDF9.Q_register;
   825.                   set_offline : in Boolean) is
   826.    begin
   827.       trap_illegal_IO_operation("POA", the_buffer, Q_operand, set_offline);
   828.    end POA;
   829.
   830.    procedure POB (the_buffer  : in out IOC.device;
   831.                   Q_operand   : in KDF9.Q_register;
   832.                   set_offline : in Boolean) is
   833.    begin
   834.       trap_illegal_IO_operation("POB", the_buffer, Q_operand, set_offline);
   835.    end POB;
   836.
   837.    procedure POC (the_buffer  : in out IOC.device;
   838.                   Q_operand   : in KDF9.Q_register;
   839.                   set_offline : in Boolean) is
   840.    begin
   841.       trap_illegal_IO_operation("POC", the_buffer, Q_operand, set_offline);
   842.    end POC;
   843.
   844.    procedure POD (the_buffer  : in out IOC.device;
   845.                   Q_operand   : in KDF9.Q_register;
   846.                   set_offline : in Boolean) is
   847.    begin
   848.       trap_illegal_IO_operation("POD", the_buffer, Q_operand, set_offline);
   849.    end POD;
   850.
   851.    procedure POE (the_buffer  : in out IOC.device;
   852.                   Q_operand   : in KDF9.Q_register;
   853.                   set_offline : in Boolean) is
   854.    begin
   855.       trap_illegal_IO_operation("POE", the_buffer, Q_operand, set_offline);
   856.    end POE;
   857.
   858.    procedure POF (the_buffer  : in out IOC.device;
   859.                   Q_operand   : in KDF9.Q_register;
   860.                   set_offline : in Boolean) is
   861.    begin
   862.       trap_illegal_IO_operation("POF", the_buffer, Q_operand, set_offline);
   863.    end POF;
   864.
   865.    procedure POG (the_buffer  : in out IOC.device;
   866.                   Q_operand   : in KDF9.Q_register;
   867.                   set_offline : in Boolean) is
   868.    begin
   869.       trap_illegal_IO_operation("POG", the_buffer, Q_operand, set_offline);
   870.    end POG;
   871.
   872.    procedure POH (the_buffer  : in out IOC.device;
   873.                   Q_operand   : in KDF9.Q_register;
   874.                   set_offline : in Boolean) is
   875.    begin
   876.       trap_illegal_IO_operation("POH", the_buffer, Q_operand, set_offline);
   877.    end POH;
   878.
   879.    procedure POK (the_buffer  : in out IOC.device;
   880.                   Q_operand   : in KDF9.Q_register;
   881.                   set_offline : in Boolean) is
   882.    begin
   883.       trap_illegal_IO_operation("POK", the_buffer, Q_operand, set_offline);
   884.    end POK;
   885.
   886.    procedure POL (the_buffer  : in out IOC.device;
   887.                   Q_operand   : in KDF9.Q_register;
   888.                   set_offline : in Boolean) is
   889.    begin
   890.       trap_illegal_IO_operation("POL", the_buffer, Q_operand, set_offline);
   891.    end POL;
   892.
   893. end IOC;

Compiling: ../Source/ioc.ads
Source file time stamp: 2021-02-19 23:58:27
Compiled at: 2021-02-21 15:54:04

     1. -- Emulation of the common functionality of a KDF9 IOC "buffer" (DMA channel),
     2. --    with fail-stop stubs for operations having device-specific behaviour.
     3. --
     4. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with Ada.Finalization;
    19. --
    20. with KDF9;
    21.
    22. private with Ada.Exceptions;
    23. private with Ada.Characters.Latin_1;
    24. --
    25. private with exceptions;
    26. private with formatting;
    27. private with HCI;
    28. private with host_IO;
    29. private with KDF9_char_sets;
    30. private with KDF9.store;
    31. private with POSIX;
    32. private with settings;
    33.
    34. use  Ada.Finalization;
    35. --
    36. use  KDF9;
    37.
    38. package IOC is
    39.
    40.    -- N.B. the KDF9 'buffer' is a DMA controller in more modern terminology.
    41.
    42.    -- Each KDF9 buffer is externally characterized by:
    43.    --    its (absolute) number,
    44.    --    its (attached-device) kind, and
    45.    --    its unit (the number of that device within its kind).
    46.
    47.    -- A device of AD_kind is attached to a buffer with No Device connected.
    48.    -- If commanded, it performs a basic default action,
    49.    --    which is to cause a LIV interrupt in the case of transfers,
    50.    --       but is both benign and appropriate for all other operations.
    51.
    52.    type device_kind is
    53.       (CP_kind,  -- Card Punch
    54.        CR_kind,  -- Card Reader
    55.        DR_kind,  -- Drum
    56.        FD_kind,  -- Fixed Disc
    57.        FW_kind,  -- FlexoWriter (monitor typewriter)
    58.        GP_kind,  -- Graph Plotter (Calcomp 120' by 29.5" model)
    59.        LP_kind,  -- Line Printer
    60.        MT_kind,  -- Magnetic Tape
    61.        SI_kind,  -- Standard Interface buffer
    62.        ST_kind,  -- Seven Track (IBM) magnetic Tape
    63.        TP_kind,  -- Tape Punch
    64.        TR_kind,  -- Tape Reader
    65.        AD_kind   -- Absent Device
    66.       );
    67.
    68.    -- This is the number of the buffer a device is connected to.
    69.    subtype device_number is KDF9.Q_part range 0 .. 15;
    70.
    71.    -- This is the index of a device within devices of the type in the configuration.
    72.    subtype unit_number   is KDF9.Q_part range 0 .. 15;
    73.
    74.    -- An IOC.device_name is of the form XYu, where XY is a two-letter device-type code
    75.    --    and u is the logical unit number, in the range 0..F, of the device within its type.
    76.
    77.    subtype device_name is String(1..3);
    78.
    79. --
    80. --
    81.    -- This is the root for all I/O device types.
    82. --
    83. --
    84.
    85.    type device (number : IOC.device_number; unit : IOC.unit_number)
    86.    is abstract new Limited_Controlled with private;
    87.
    88.    -- The quantum is the time, in s, taken to transfer a basic datum.
    89.    -- For unit-record devices (CR, CP, LP) this is the card/line.
    90.    -- For other devices it is the KDF9 character.
    91.    function quantum (the_buffer : IOC.device)
    92.    return KDF9.us
    93.    is abstract;
    94.
    95.    function kind (the_buffer : IOC.device)
    96.    return IOC.device_kind
    97.    is abstract;
    98.
    99.    -- This is overridden separately for fast and slow devices.
   100.    procedure add_in_the_IO_CPU_time (the_buffer  : in IOC.device;
   101.                                      bytes_moved : in KDF9.word)
   102.    is abstract;
   103.
   104.    -- True iff the_buffer has been opened but not yet closed.
   105.    -- It is overridden separately for magnetic tapes and all other devices.
   106.    function is_open (the_buffer : IOC.device)
   107.    return Boolean
   108.    is abstract;
   109.
   110.    -- A measure of the I/O volume transferred by the_buffer, so far.
   111.    function usage (the_buffer : IOC.device)
   112.    return KDF9.word;
   113.
   114.    -- Ensure that all output to the_buffer has been transmitted.
   115.    procedure flush (the_buffer : in out IOC.device);
   116.
   117.    -- Make the_buffer unavailable for further I/O use, after flushing if necessary.
   118.    procedure close (the_buffer : in out IOC.device);
   119.
   120.    -- A IOC.device_name is of the form XYu, where XY is a two-letter device-type
   121.    --    code (e.g., "LP" or "CR"); and u is the one-digit logical unit number
   122.    --       of a device within its category.
   123.
   124.    function device_name_of (the_buffer : IOC.device)
   125.    return IOC.device_name;
   126.
   127.    function device_name_of (the_number : IOC.device_number)
   128.    return IOC.device_name;
   129.
   130.    function device_kind_of (the_number : IOC.device_number)
   131.    return IOC.device_kind;
   132.
   133.    function mnemonic (order : in String; class : in IOC.device_name)
   134.    return String;
   135.
   136.    -- An I/O operation may fail for two distict reasons:
   137.    -- 1. the order is illegal per se
   138.    -- 2. the order is legal, but is attempting an impossible effect.
   139.
   140.    -- trap_illegal_IO_operation fails the run because of an attempt to use an I/O order
   141.    --   that is illegal or undefined for the device concerned.
   142.    procedure trap_illegal_IO_operation (order       : in String;
   143.                                         buffer      : in IOC.device;
   144.                                         Q_operand   : in KDF9.Q_register;
   145.                                         set_offline : in Boolean)
   146.       with Inline => False;
   147.
   148.    -- trap_failing_IO_operation fails the run iff either:
   149.    -- 1. ee9 is running in a non-boot mode, because nothing more can usefully be done
   150.    -- OR
   151.    -- 2. Director is running, because an impossible operation implies a serious failure in Director.
   152.    --
   153.    -- In boot mode, when Director is not running, it sets the buffer abnormal and abandons the order.
   154.    -- It is then up to the problem program to act accordingly.  Failure to do so may LIV.
   155.    procedure trap_failing_IO_operation (the_buffer : in out IOC.device; the_message : in String)
   156.       with Inline => False;
   157.
   158.    -- The elapsed time for the I/O of the given number of atomic_items
   159.    --    which may be, e.g., bytes, or card images, or printer lines.
   160.    function IO_elapsed_time (the_buffer   : IOC.device;
   161.                              atomic_items : KDF9.word)
   162.    return KDF9.us;
   163.
   164.    -- The total elapsed time taken, so far, by transfers on the attached device.
   165.    function IO_elapsed_time_total (the_buffer : IOC.device)
   166.    return KDF9.us;
   167.
   168.
   169.    --
   170.    -- The CLOQq, SLOQq and TLOQq operations do NOT address a buffer,
   171.    --    and so are fully implemented elsewhere.
   172.    --
   173.
   174.    --
   175.    -- The INTQq, BUSYQq, PARQq and MANUALQq/CTQq operations DO address a buffer,
   176.    --    but do NOT initiate an I/O transfer, and are common to all devices,
   177.    --       so they operate on a class-wide parameter.
   178.    --
   179.
   180.    procedure INT (the_buffer  : in out IOC.device'Class;
   181.                   Q_operand   : in KDF9.Q_register;
   182.                   set_offline : in Boolean);
   183.
   184.    procedure BUSY (the_buffer  : in out IOC.device'Class;
   185.                    Q_operand   : in KDF9.Q_register;
   186.                    set_offline : in Boolean;
   187.                    result      : out Boolean);
   188.
   189.    procedure PAR (the_buffer   : in out IOC.device'Class;
   190.                    Q_operand   : in KDF9.Q_register;
   191.                    set_offline : in Boolean;
   192.                    result      : out Boolean);
   193.
   194.    procedure MANUAL_CT (the_buffer  : in out IOC.device'Class;
   195.                         Q_operand   : in KDF9.Q_register;
   196.                         set_offline : in Boolean);
   197.
   198.    -- These KDF9 data-transfer operations must be overridden for non-trivial functionality.
   199.    -- Invoking any of them raises a LIV exception. This exactly mirrors the action of the
   200.    --    KDF9 in causing a LIV interrupt when an invalid operation was applied to a device.
   201.    -- A device without some of these operations inherits them from this list and so
   202.    --    implements correctly the original semantics of the KDF9.
   203.
   204.    --
   205.    -- The PI* are input operations.
   206.    --
   207.
   208.    procedure PIA (the_buffer  : in out IOC.device;
   209.                   Q_operand   : in KDF9.Q_register;
   210.                   set_offline : in Boolean);
   211.
   212.    procedure PIB (the_buffer  : in out IOC.device;
   213.                   Q_operand   : in KDF9.Q_register;
   214.                   set_offline : in Boolean);
   215.
   216.    procedure PIC (the_buffer  : in out IOC.device;
   217.                   Q_operand   : in KDF9.Q_register;
   218.                   set_offline : in Boolean);
   219.
   220.    procedure PID (the_buffer  : in out IOC.device;
   221.                   Q_operand   : in KDF9.Q_register;
   222.                   set_offline : in Boolean);
   223.
   224.    procedure PIE (the_buffer  : in out IOC.device;
   225.                   Q_operand   : in KDF9.Q_register;
   226.                   set_offline : in Boolean);
   227.
   228.    procedure PIF (the_buffer  : in out IOC.device;
   229.                   Q_operand   : in KDF9.Q_register;
   230.                   set_offline : in Boolean);
   231.
   232.    procedure PIG (the_buffer  : in out IOC.device;
   233.                   Q_operand   : in KDF9.Q_register;
   234.                   set_offline : in Boolean);
   235.
   236.    procedure PIH (the_buffer  : in out IOC.device;
   237.                   Q_operand   : in KDF9.Q_register;
   238.                   set_offline : in Boolean);
   239.
   240.    --
   241.    -- The PM* are device-status operations.
   242.    --
   243.
   244.    procedure PMA (the_buffer  : in out IOC.device;
   245.                   Q_operand   : in KDF9.Q_register;
   246.                   set_offline : in Boolean);
   247.
   248.    procedure PMB (the_buffer  : in out IOC.device;
   249.                   Q_operand   : in KDF9.Q_register;
   250.                   set_offline : in Boolean);
   251.
   252.    procedure PMC (the_buffer  : in out IOC.device;
   253.                   Q_operand   : in KDF9.Q_register;
   254.                   set_offline : in Boolean);
   255.
   256.    procedure PMD (the_buffer  : in out IOC.device;
   257.                   Q_operand   : in KDF9.Q_register;
   258.                   set_offline : in Boolean);
   259.
   260.    procedure PME (the_buffer  : in out IOC.device;
   261.                   Q_operand   : in KDF9.Q_register;
   262.                   set_offline : in Boolean);
   263.
   264.    procedure PMF (the_buffer  : in out IOC.device;
   265.                   Q_operand   : in KDF9.Q_register;
   266.                   set_offline : in Boolean);
   267.
   268.    procedure PMG (the_buffer  : in out IOC.device;
   269.                   Q_operand   : in KDF9.Q_register;
   270.                   set_offline : in Boolean);
   271.
   272. -- procedure PMH is implemented by SLO
   273.
   274.    procedure PMK (the_buffer  : in out IOC.device;
   275.                   Q_operand   : in KDF9.Q_register;
   276.                   set_offline : in Boolean);
   277.
   278.    procedure PML (the_buffer  : in out IOC.device;
   279.                   Q_operand   : in KDF9.Q_register;
   280.                   set_offline : in Boolean);
   281.
   282.    --
   283.    -- The PO* are output operations.
   284.    --
   285.
   286.    procedure POA (the_buffer  : in out IOC.device;
   287.                   Q_operand   : in KDF9.Q_register;
   288.                   set_offline : in Boolean);
   289.
   290.    procedure POB (the_buffer  : in out IOC.device;
   291.                   Q_operand   : in KDF9.Q_register;
   292.                   set_offline : in Boolean);
   293.
   294.    procedure POC (the_buffer  : in out IOC.device;
   295.                   Q_operand   : in KDF9.Q_register;
   296.                   set_offline : in Boolean);
   297.
   298.    procedure POD (the_buffer  : in out IOC.device;
   299.                   Q_operand   : in KDF9.Q_register;
   300.                   set_offline : in Boolean);
   301.
   302.    procedure POE (the_buffer  : in out IOC.device;
   303.                   Q_operand   : in KDF9.Q_register;
   304.                   set_offline : in Boolean);
   305.
   306.    procedure POF (the_buffer  : in out IOC.device;
   307.                   Q_operand   : in KDF9.Q_register;
   308.                   set_offline : in Boolean);
   309.
   310.    procedure POG (the_buffer  : in out IOC.device;
   311.                   Q_operand   : in KDF9.Q_register;
   312.                   set_offline : in Boolean);
   313.
   314.    procedure POH (the_buffer  : in out IOC.device;
   315.                   Q_operand   : in KDF9.Q_register;
   316.                   set_offline : in Boolean);
   317.
   318.    procedure POK (the_buffer  : in out IOC.device;
   319.                   Q_operand   : in KDF9.Q_register;
   320.                   set_offline : in Boolean);
   321.
   322.    procedure POL (the_buffer  : in out IOC.device;
   323.                   Q_operand   : in KDF9.Q_register;
   324.                   set_offline : in Boolean);
   325.
   326.
   327. --
   328. --
   329.    -- The buffer_configuration type enables the dynamic setting-up of a complement of I/O devices.
   330. --
   331. --
   332.
   333.    type device_class_access  is access all IOC.device'Class;
   334.
   335.    type buffer_configuration is array (KDF9.buffer_number) of IOC.device_class_access;
   336.
   337.    -- These are the I/O devices installed in this configuration.
   338.    -- Each device installs itself into the configuration when the device is initialized.
   339.
   340.    buffer : buffer_configuration;
   341.
   342. --
   343.    -- These operations are used by Directors to manage device allocation to problem programs.
   344. --
   345.
   346.    procedure set_state_of (the_buffer : in device_class_access;
   347.                            allocated  : in Boolean);
   348.
   349.    function is_allocated (the_buffer : device_class_access)  -- N.B. IS_allocated.
   350.    return Boolean;
   351.
   352.    function is_unallocated (the_buffer : device_class_access)  -- N.B. is_UNallocated.
   353.    return Boolean;
   354.
   355. --
   356.    -- These buffer-implementation operations are used outside IOC and apply to all device types.
   357. --
   358.
   359.    -- Complete all extant transfers, then Finalize each buffer.
   360.    procedure finalize_all_KDF9_buffers;
   361.
   362.    -- Advance the elapsed time to a point after all extant transfer have terminated.
   363.    procedure complete_all_extant_transfers;
   364.
   365.    -- Complete any terminated transfer operations and take any needed interrupts.
   366.    procedure act_on_pending_interrupts;
   367.
   368.    -- Handle non-data transfer operations on busy device.
   369.    procedure deal_with_a_busy_device (the_buffer  : in out IOC.device'Class;
   370.                                       order_time  : in KDF9.us;
   371.                                       set_offline : in Boolean);
   372.
   373.    -- A LOV interupt caused by an attempted store access must arrange
   374.    --    for the interrupted instruction to be resumed.
   375.    -- In boot mode, effect the LOV interrupt to Director.
   376.    -- In other modes, advance the elapsed time to the end-of-transfer time
   377.    --    for the_locked_out_address, then act on pending interrupts.
   378.    procedure handle_a_main_store_lockout;
   379.
   380.    type transfer_kind  is (input_operation,
   381.                            output_operation,
   382.                            control_operation,
   383.                            some_other_operation);
   384.
   385.    -- Take note of the start of a transfer.
   386.    -- For I/O operations that do not entail an actual data transfer,
   387.    --    such as testing a buffer for a graph plotter,
   388.    --    set the busy time to the order's MC execution time.
   389.    -- This keeps elapsed time in sync with CPU time,
   390.    --    and ensures that the operation waits for any preceding transfer
   391.    --    on the same buffer to complete before the test is actioned.
   392.    procedure start_data_transfer (the_buffer  : in out IOC.device'Class;
   393.                                   Q_operand   : in KDF9.Q_register;
   394.                                   set_offline : in Boolean;
   395.                                   busy_time   : in KDF9.us;
   396.                                   operation   : in IOC.transfer_kind := IOC.some_other_operation);
   397.
   398. private
   399.
   400.    use Ada.Exceptions; pragma Warnings(Off, Ada.Exceptions);
   401.    --
   402.    use exceptions;     pragma Warnings(Off, exceptions);
   403.    use formatting;     pragma Warnings(Off, formatting);
   404.    use HCI;            pragma Warnings(Off, HCI);
   405.    use host_IO;        pragma Warnings(Off, host_IO);
   406.    use KDF9_char_sets; pragma Warnings(Off, KDF9_char_sets);
   407.    use KDF9.store;     pragma Warnings(Off, KDF9.store);
   408.    use settings;       pragma Warnings(Off, settings);
   409.
   410.    use POSIX;          -- Used here, so no need to suppress warnings.
   411.
   412.    type device (number : IOC.device_number; unit : IOC.unit_number)
   413.    is abstract new Limited_Controlled with
   414.       record
   415.          is_abnormal,
   416.          is_busy,
   417.          is_offline,
   418.          is_allocated,
   419.          is_for_Director : Boolean := False;
   420.          operation       : IOC.transfer_kind := IOC.some_other_operation;
   421.          initiation_time : KDF9.us := KDF9.us'Last;
   422.          transfer_time   : KDF9.us := KDF9.us'Last;
   423.          completion_time : KDF9.us := KDF9.us'Last;
   424.          priority_level  : KDF9.priority;
   425.          control_word    : KDF9.Q_register;
   426.          decoded_order   : KDF9.decoded_order;
   427.          device_name     : IOC.device_name;
   428.          order_address   : KDF9.syllable_address;
   429.          order_count     : KDF9.order_counter;
   430.          stream          : host_IO.stream;
   431.       end record;
   432.
   433.    overriding
   434.    procedure Initialize (the_buffer : in out IOC.device);
   435.
   436.    procedure open (the_buffer : in out IOC.device'Class;
   437.                    the_mode   : in POSIX.access_mode);
   438.
   439.    overriding
   440.    procedure Finalize (the_buffer : in out IOC.device)
   441.       with Inline => False;
   442.
   443.    -- Operations, used only within the IOC hierarchy, that apply to all device types.
   444.
   445.    -- Check that the buffer for the_device is unused, then set it to the_device.
   446.    procedure install (the_device : in out IOC.device'Class);
   447.
   448.    -- LIV if the_buffer is in the abnormal state.
   449.    procedure validate_parity (the_buffer : in IOC.device'Class)
   450.       with Inline => False;
   451.
   452.    -- Check that the_buffer is online, and that access to it is permitted; LIV if not.
   453.    procedure validate_device (the_buffer : in IOC.device'Class)
   454.       with Inline => False;
   455.
   456.    -- Check that the device and the transfer address bounds are valid;
   457.    --    LIV if not.
   458.    procedure validate_transfer (the_buffer : in IOC.device'Class;
   459.                                 Q_operand  : in KDF9.Q_register);
   460.
   461.    -- When the real duration of a variable-length transfer is known,
   462.    --    its completion time can be made accurate by giving its actual_time.
   463.    -- correct_transfer_time must be called before finalize_transfer is called.
   464.    procedure correct_transfer_time (the_buffer  : in out IOC.device'Class;
   465.                                     actual_time : in KDF9.us);
   466.
   467.    procedure correct_transfer_time (the_buffer    : in out IOC.device'Class;
   468.                                     actual_length : in KDF9.word);
   469.
   470.    -- LIV if the repetition count is negative.
   471.    procedure require_nonnegative_count (count : in KDF9.Q_part);
   472.
   473.    -- LIV if the repetition count is negative or zero.
   474.    procedure require_positive_count (count : in KDF9.Q_part);
   475.
   476.    -- Account for the CPU time taken by the buffer in setting store lockouts.
   477.    procedure add_in_the_IO_lockout_CPU_time (Q_operand : in KDF9.Q_register);
   478.
   479.    -- These are handy, and also prevent a unreferenced warning for Ada.Characters.Latin_1.
   480.    LF : constant Character := Ada.Characters.Latin_1.LF;
   481.    SP : constant Character := Ada.Characters.Latin_1.Space;
   482.
   483. end IOC;

 893 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-equipment.adb
Source file time stamp: 2021-02-15 18:20:53
Compiled at: 2021-02-21 15:54:04

     1. -- Data supporting the definition of a KDF9 I/O equipment configuration.
     2. --
     3. --
     4. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with IOC.absent;
    19. with IOC.fast.DR;
    20. with IOC.fast.FD;
    21. with IOC.fast.tape;
    22. with IOC.slow.shift.FW;
    23. with IOC.slow.shift.GP;
    24. with IOC.slow.shift.SI;
    25. with IOC.slow.shift.TP;
    26. with IOC.slow.shift.TR;
    27. with IOC.slow.unit.CP;
    28. with IOC.slow.unit.CR;
    29. with IOC.slow.unit.LP;
    30. with settings;
    31.
    32. package body IOC.equipment is
    33.
    34.    procedure configure_the_IOC is
    35.    begin
    36.       for b in KDF9.buffer_number loop
    37.          case equipment.choice(b) is
    38.             when AD => IOC.absent.enable(b);
    39.             when CP => IOC.slow.unit.CP.enable(b);
    40.             when CR => IOC.slow.unit.CR.enable(b);
    41.             when DR => IOC.fast.DR.enable(b);
    42.             when FD => IOC.fast.FD.enable(b);
    43.             when FW => IOC.slow.shift.FW.enable(b);
    44.             when GP => IOC.slow.shift.TP.remove_from_buffer(b);
    45.                        IOC.slow.shift.GP.enable(b);
    46.             when LP => IOC.slow.unit.LP.enable(b);
    47.             when MT => IOC.fast.tape.enable_MT_deck(b);
    48.             when SI => IOC.slow.shift.SI.enable(b);
    49.             when ST => IOC.fast.tape.enable_ST_deck(b);
    50.             when TP => IOC.slow.shift.TP.enable(b);
    51.             when TR => IOC.slow.shift.TR.enable(b);
    52.          end case;
    53.          if buffer(b) = null then
    54.             IOC.absent.enable(b);
    55.          end if;
    56.       end loop;
    57.       -- By this point every buffer must have an attached device.
    58.       if IOC.buffer(0).kind /= IOC.FW_kind then
    59.          trap_operator_error("buffer #00 must be a FW");
    60.       end if;
    61.       if IOC.buffer(1).kind /= IOC.TR_kind then
    62.          trap_operator_error("buffer #01 must be a TR");
    63.       end if;
    64.    end configure_the_IOC;
    65.
    66.    procedure revise_the_configuration is
    67.    begin
    68.       -- By this point every buffer has a device which must be removed before it is replaced.
    69.       for b in equipment.choice'Range loop
    70.          case equipment.choice(b) is
    71.             when DR => IOC.fast.FD.remove_from_buffer(b);
    72.                        IOC.fast.DR.replace_on_buffer(b);
    73.             when FD => IOC.fast.DR.remove_from_buffer(b);
    74.                        IOC.fast.FD.replace_on_buffer(b);
    75.             when GP => if buffer(b).device_name = "TP1" then
    76.                           IOC.slow.shift.TP.remove_from_buffer(b);
    77.                           IOC.slow.shift.GP.replace_on_buffer(b);
    78.                        end if;
    79.             when SI => IOC.slow.shift.SI.replace_on_buffer(b);
    80.             when others => null;
    81.          end case;
    82.       end loop;
    83.    end revise_the_configuration;
    84.
    85. end IOC.equipment;

Compiling: ../Source/ioc-equipment.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:04

     1. -- Enable the devices included in the chosen KDF9 I/O configuration.
     2. --
     3. --
     4. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with KDF9;
    19.
    20. package IOC.equipment is
    21.
    22.    -- These variables are used in the emulation of OUT 5.
    23.    -- They are set to the device buffer number at the start of each run by configure_the_IOC.
    24.    -- A value of 0 indicates that the device is not included in the configuration for the run.
    25.    -- Fast devices are not allocated by this mechanism and so do not appear here.
    26.
    27.    CP0_number  : KDF9.buffer_number := 0;
    28.    CP1_number  : KDF9.buffer_number := 0;
    29.    CR0_number  : KDF9.buffer_number := 0;
    30.    CR1_number  : KDF9.buffer_number := 0;
    31.    GP0_number  : KDF9.buffer_number := 0;
    32.    LP0_number  : KDF9.buffer_number := 0;
    33.    LP1_number  : KDF9.buffer_number := 0;
    34.    SI0_number  : KDF9.buffer_number := 0;
    35.    SI1_number  : KDF9.buffer_number := 0;
    36.    TP0_number  : KDF9.buffer_number := 0;
    37.    TP1_number  : KDF9.buffer_number := 0;
    38.    TR0_number  : KDF9.buffer_number := 0;
    39.    TR1_number  : KDF9.buffer_number := 0;
    40.
    41.    type kind   is (AD, CP, CR, DR, FD, FW, GP, LP, MT, SI, ST, TP, TR);
    42.
    43.    type setup  is array (KDF9.buffer_number) of equipment.kind;
    44.
    45.    -- These are the buffer numbers for the devices in the default configuration.
    46.    -- The Fixed Disc drive was on buffer 14 (#16) of Eldon 2 KDF9s, so I adopt that here.
    47.
    48.    FW0_default : constant KDF9.buffer_number := 0;
    49.    TR0_default : constant KDF9.buffer_number := 1;
    50.    TR1_default : constant KDF9.buffer_number := 2;
    51.    TP0_default : constant KDF9.buffer_number := 3;
    52.    TP1_default : constant KDF9.buffer_number := 4;
    53.    LP0_default : constant KDF9.buffer_number := 5;
    54.    CR0_default : constant KDF9.buffer_number := 6;
    55.    CP0_default : constant KDF9.buffer_number := 7;
    56.    MT0_default : constant KDF9.buffer_number := 8;
    57.    MT1_default : constant KDF9.buffer_number := 9;
    58.    MT2_default : constant KDF9.buffer_number := 10;
    59.    MT3_default : constant KDF9.buffer_number := 11;
    60.    MT4_default : constant KDF9.buffer_number := 12;
    61.    MT5_default : constant KDF9.buffer_number := 13;
    62.    DR0_default : constant KDF9.buffer_number := 14;
    63.    FD0_default : constant KDF9.buffer_number := 14;
    64.    ST0_default : constant KDF9.buffer_number := 15;
    65.
    66.    default : constant equipment.setup
    67.            := (
    68.                CP0_default => CP,
    69.                CR0_default => CR,
    70.                FD0_default => FD,
    71.                FW0_default => FW,
    72.                LP0_default => LP,
    73.                MT0_default => MT,
    74.                MT1_default => MT,
    75.                MT2_default => MT,
    76.                MT3_default => MT,
    77.                MT4_default => MT,
    78.                MT5_default => MT,
    79.                ST0_default => ST,
    80.                TP0_default => TP,
    81.                TP1_default => TP,
    82.                TR0_default => TR,
    83.                TR1_default => TR
    84.               );
    85.
    86.    choice  : equipment.setup := default;
    87.
    88.    -- Attach the chosen devices to their buffers.
    89.    procedure configure_the_IOC;
    90.
    91.    -- If a drum, disc or BSI has been enabled on the command line, make sure it is installed.
    92.    procedure revise_the_configuration;
    93.
    94. end IOC.equipment;

 85 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow.adb
Source file time stamp: 2021-02-19 00:23:40
Compiled at: 2021-02-21 15:54:04

     1. -- Emulation of the common functionality of a KDF9 "slow", byte-by-byte, devices.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with HCI;
    18. with OS_specifics;
    19. with environmental_value_of;
    20.
    21. use HCI;
    22.
    23. package body IOC.slow is
    24.
    25.    overriding
    26.    function is_open (the_buffer : slow.device)
    27.    return Boolean
    28.    is (the_buffer.stream.is_open);
    29.
    30.    overriding
    31.    procedure add_in_the_IO_CPU_time (the_buffer  : in slow.device;
    32.                                      bytes_moved : in KDF9.word) is
    33.       pragma Unreferenced(the_buffer);
    34.    begin
    35.       the_CPU_delta := the_CPU_delta + KDF9.us(bytes_moved) * 6; -- 6s/char
    36.    end add_in_the_IO_CPU_time;
    37.
    38.    procedure display_device_usage (the_buffer  : in slow.device;
    39.                                    the_action  : in String;
    40.                                    the_amount  : in KDF9.word;
    41.                                    the_quantum : in String) is
    42.    begin
    43.          if the_final_state_is_wanted and then
    44.                the_log_is_wanted      and then
    45.                   the_buffer.is_open  and then
    46.                the_amount /= 0            then
    47.          if (the_buffer.number = 0) and not (API_logging_is_wanted or the_log_is_wanted) then
    48.             -- Take a new line at the head of the list, for low-visibility modes.
    49.             log_new_line;
    50.          end if;
    51.          log_line(
    52.                   the_buffer.device_name
    53.                 & " on buffer #"
    54.                 & oct_of(KDF9.Q_part(the_buffer.number), 2)
    55.                 & " "
    56.                 & the_action
    57.                 & the_amount'Image
    58.                 & " "
    59.                 & the_quantum
    60.                 & "."
    61.                  );
    62.       end if;
    63.    end display_device_usage;
    64.
    65.    procedure close (the_buffer  : in out slow.device;
    66.                     the_action  : in String;
    67.                     the_amount  : in KDF9.word;
    68.                     the_quantum : in String) is
    69.    begin
    70.       display_device_usage (the_buffer, the_action, the_amount, the_quantum);
    71.       IOC.device(the_buffer).close;
    72.    end close;
    73.
    74.    function atomic_item_count (the_buffer : slow.device;
    75.                                Q_operand  : KDF9.Q_register)
    76.    return KDF9.word is
    77.       words : constant KDF9.Q_part := Q_operand.M - Q_operand.I + 1;
    78.    begin
    79.       if the_buffer.is_open then
    80.          return KDF9.word(words) * 8;
    81.       else
    82.          return 0;
    83.       end if;
    84.    end atomic_item_count;
    85.
    86.    procedure reattach (the_buffer   : in out slow.device;
    87.                        the_file     : in String) is
    88.    begin
    89.       reattach(the_buffer.stream, the_file, read_mode);
    90.    end reattach;
    91.
    92.    procedure deal_with_end_of_data (the_buffer : in out slow.device) is
    93.       BEL      : constant String := (1 => Character'Val(7));   -- Audible prompt
    94.       response : response_kind;
    95.
    96.       procedure reattach_the_text_file (name : in String) is
    97.       begin
    98.          if name = "" then
    99.             the_buffer.is_abnormal := True;
   100.             raise end_of_stream;
   101.          elsif exists(name) then
   102.             reattach(the_buffer, name);
   103.             return;
   104.          elsif exists(name & ".txt") then
   105.             reattach(the_buffer, name & ".txt");
   106.             return;
   107.          else
   108.             raise operator_error;
   109.          end if;
   110.       end reattach_the_text_file;
   111.
   112.    begin
   113.       output_line(BEL & "");
   114.       output_line("ee9: End of given data for " & the_buffer.device_name & ".");
   115.       loop
   116.          POSIX.data_prompt(
   117.                            noninteractive_usage_is_enabled,
   118.                            "Type @ or / to name a file, = to type the data, ENTER key for EOF, Q or q to quit",
   119.                            response
   120.                           );
   121.          if response = wrong_response then
   122.             null;  -- repeat the prompt
   123.          elsif response = quit_response then
   124.             trap_failing_IO_operation(the_buffer, "quit requested by the user");
   125.          elsif response = EOF_response then
   126.             the_buffer.is_abnormal := True;
   127.             raise end_of_stream;
   128.          elsif response = here_response then
   129.             reattach(the_buffer, OS_specifics.UI_in_name);
   130.             return;
   131.          elsif response = at_response then
   132.             declare
   133.                here : constant String := environmental_value_of("KDF9_DATA", default => "Data") & "/";
   134.                next : constant String := next_file_name(BEL & "Give the name of a file in " & here);
   135.             begin
   136.                reattach_the_text_file(here & next);
   137.                return;
   138.             exception
   139.                when operator_error =>
   140.                   output_line(BEL & "ee9: The file '" & here & next & "' could not be found");
   141.             end;
   142.          elsif response = name_response then
   143.             declare
   144.                next : constant String := next_file_name(BEL & "Give the pathname of the file");
   145.             begin
   146.                reattach_the_text_file(next);
   147.                return;
   148.             exception
   149.                when operator_error =>
   150.                   output_line(BEL & "ee9: The file '" & next & "' could not be found");
   151.             end;
   152.          end if;
   153.       end loop;
   154.    end deal_with_end_of_data;
   155.
   156.    procedure start_slow_transfer (the_buffer   : in out slow.device;
   157.                                   Q_operand    : in KDF9.Q_register;
   158.                                   set_offline  : in Boolean;
   159.                                   operation    : in IOC.transfer_kind := some_other_operation) is
   160.       atomic_items : constant KDF9.word := atomic_item_count(the_buffer, Q_operand);
   161.       time_needed  : constant KDF9.us := IO_elapsed_time(the_buffer, atomic_items);
   162.    begin
   163.       start_data_transfer(the_buffer, Q_operand, set_offline,
   164.                           busy_time => time_needed,
   165.                           operation => start_slow_transfer.operation);
   166.    end start_slow_transfer;
   167.
   168.    procedure get_byte_from_stream (byte       : out Character;
   169.                                    the_buffer : in out slow.device) is
   170.    begin
   171.       loop
   172.          begin
   173.             get_byte(byte, the_buffer.stream);
   174.             return;
   175.          exception
   176.             when end_of_stream =>
   177.                deal_with_end_of_data(the_buffer);
   178.          end;
   179.       end loop;
   180.    end get_byte_from_stream;
   181.
   182.    procedure get_char_from_stream (char       : out Character;
   183.                                    the_buffer : in out slow.device) is
   184.    begin
   185.       loop
   186.          begin
   187.             get_char(char, the_buffer.stream);
   188.             return;
   189.          exception
   190.             when end_of_stream =>
   191.                deal_with_end_of_data(the_buffer);
   192.          end;
   193.       end loop;
   194.    end get_char_from_stream;
   195.
   196. end IOC.slow;

Compiling: ../Source/ioc-slow.ads
Source file time stamp: 2021-02-13 13:46:28
Compiled at: 2021-02-21 15:54:04

     1. -- Emulation of the common functionality of a KDF9 "slow", i.e. byte-by-byte, devices.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. private with IOC.equipment;
    18. private with tracing;
    19.
    20. package IOC.slow is
    21.
    22.    --
    23.    -- This is the root type for all slow I/O device types.
    24.    --
    25.
    26.    type device is abstract new IOC.device with private;
    27.
    28.    -- Log the usage statistics for the device on the buffer.
    29.    procedure display_device_usage (the_buffer  : in slow.device;
    30.                                    the_action  : in String;
    31.                                    the_amount  : in KDF9.word;
    32.                                    the_quantum : in String);
    33.
    34.    -- Change the file associated with a device.
    35.    procedure reattach (the_buffer : in out slow.device;
    36.                        the_file   : in String);
    37.
    38. private
    39.
    40.    use IOC.equipment; pragma Warnings(Off, IOC.equipment);
    41.    use tracing;       pragma Warnings(Off, tracing);
    42.
    43.    type device is abstract new IOC.device with
    44.       record
    45.          is_transcribing : Boolean := True;
    46.          byte_count      : KDF9.word := 0;
    47.       end record;
    48.
    49.    overriding
    50.    function is_open (the_buffer : slow.device)
    51.    return Boolean;
    52.
    53.    overriding
    54.    procedure add_in_the_IO_CPU_time (the_buffer  : in slow.device;
    55.                                      bytes_moved : in KDF9.word);
    56.
    57.    -- Optionally log an activity message for the device; close its I/O stream.
    58.    procedure close (the_buffer  : in out slow.device;
    59.                     the_action  : in String;
    60.                     the_amount  : in KDF9.word;
    61.                     the_quantum : in String);
    62.
    63.    -- The number of timed transfer units in the designated core-store area.
    64.    -- In the case of unit-record devices, such as card readers and line printers,
    65.    --    this is the number of unit records (cards, or lines, respectively).
    66.    -- In all other cases it is the number of characters in the designated core-store area.
    67.    function atomic_item_count (the_buffer : slow.device;
    68.                                Q_operand  : KDF9.Q_register)
    69.    return KDF9.word;
    70.
    71.    -- Check the IO parameters and the buffer state, and handle any old lockout.
    72.    -- Set the new buffer state, and project the next interrupt time.
    73.    procedure start_slow_transfer (the_buffer   : in out slow.device;
    74.                                   Q_operand    : in KDF9.Q_register;
    75.                                   set_offline  : in Boolean;
    76.                                   operation    : in IOC.transfer_kind := some_other_operation);
    77.
    78.    -- Read a character from the stream and deal with any input file concatenation.
    79.    procedure get_char_from_stream (char       : out Character;
    80.                                    the_buffer : in out slow.device);
    81.
    82.    -- Read a raw byte from the stream and deal with any input file concatenation.
    83.    procedure get_byte_from_stream (byte       : out Character;
    84.                                    the_buffer : in out slow.device);
    85. end IOC.slow;

 196 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift.adb
Source file time stamp: 2021-02-13 13:25:23
Compiled at: 2021-02-21 15:54:05

     1. -- Emulation of the common functionality of a 2-case (Normal/Shift) buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.shift is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_device : in out shift.device) is
    23.    begin
    24.       -- Open the associated file.
    25.       open(the_device, read_mode);
    26.    end Initialize;
    27.
    28.    procedure do_input_housekeeping (the_device : in out shift.device;
    29.                                     read_in,
    30.                                     stored     : in KDF9.word) is
    31.    begin
    32.       add_in_the_IO_CPU_time(the_device, stored);
    33.       correct_transfer_time(the_device, read_in);
    34.       the_device.byte_count := the_device.byte_count + read_in;
    35.    end do_input_housekeeping;
    36.
    37.    procedure get_symbols (the_device    : in out shift.device;
    38.                           Q_operand     : in KDF9.Q_register;
    39.                           reading_to_EM : in Boolean) is
    40.       start_address : constant KDF9.address := Q_operand.I;
    41.       end_address   : constant KDF9.address := Q_operand.M;
    42.       fill   : KDF9.word := 0;
    43.       size   : KDF9.word := 0;
    44.       symbol : KDF9_char_sets.symbol;
    45.       char   : Character;
    46.    begin
    47.       check_addresses_and_lockouts(start_address, end_address);
    48.    word_loop:
    49.       for w in start_address .. end_address loop
    50.          store_word(0, w);
    51.          for c in KDF9_char_sets.symbol_index'Range loop
    52.             get_char_from_stream(char, the_device);
    53.             size := size + 1;
    54.             if char = KDF9_char_sets.W_F then
    55.                -- Filler was suppressed on normal input from the slow devices.
    56.                fill := fill + 1;
    57.             elsif case_of(char) /= both                   and then
    58.                      case_of(char) /= the_device.current_case then
    59.                store_symbol(CN_TR(next_case(the_device.current_case)), w, c);
    60.                the_device.current_case := the_device.current_case xor 1;
    61.                back_off(the_device.stream);
    62.             else
    63.                symbol := CN_TR(char) or CS_TR(char);
    64.                store_symbol(symbol, w, c);
    65.                if reading_to_EM and symbol = KDF9_char_sets.End_Message then
    66.                   for d in 1 .. 7-c loop
    67.                      store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
    68.                   end loop;
    69.                   exit word_loop;
    70.                end if;
    71.             end if;
    72.          end loop;
    73.       end loop word_loop;
    74.       do_input_housekeeping(the_device, read_in => size, stored => size-fill);
    75.    exception
    76.       when end_of_stream =>
    77.          flush(the_device.stream);
    78.          do_input_housekeeping(the_device, read_in => size, stored => size-fill);
    79.    end get_symbols;
    80.
    81.    procedure read (the_device : in out shift.device;
    82.                    Q_operand  : in KDF9.Q_register) is
    83.    begin
    84.       get_symbols(the_device, Q_operand, reading_to_EM => False);
    85.    end read;
    86.
    87.    procedure read_to_EM (the_device : in out shift.device;
    88.                          Q_operand  : in KDF9.Q_register) is
    89.    begin
    90.       get_symbols(the_device, Q_operand, reading_to_EM => True);
    91.    end read_to_EM;
    92.
    93.    procedure get_words (the_device    : in out shift.device;
    94.                         Q_operand     : in KDF9.Q_register;
    95.                         reading_to_EM : in Boolean) is
    96.       start_address : constant KDF9.address := Q_operand.I;
    97.       end_address   : constant KDF9.address := Q_operand.M;
    98.       size : KDF9.word := 0;
    99.       word : KDF9.word;
   100.       char : Character;
   101.    begin
   102.       check_addresses_and_lockouts(start_address, end_address);
   103.       for w in start_address .. end_address loop
   104.          get_char_from_stream(char, the_device);
   105.          word := KDF9.word(Character'Pos(char));
   106.          size := size + 1;
   107.          store_word(word, w);
   108.       exit when reading_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   109.       end loop;
   110.       do_input_housekeeping(the_device, read_in => size, stored => size);
   111.    exception
   112.       when end_of_stream =>
   113.          flush(the_device.stream);
   114.          do_input_housekeeping(the_device, read_in => size, stored => size);
   115.    end get_words;
   116.
   117.    procedure words_read (the_device : in out shift.device;
   118.                          Q_operand  : in KDF9.Q_register) is
   119.    begin
   120.       get_words(the_device, Q_operand, reading_to_EM => False);
   121.    end words_read;
   122.
   123.    procedure words_read_to_EM (the_device : in out shift.device;
   124.                                Q_operand  : in KDF9.Q_register) is
   125.    begin
   126.       get_words(the_device, Q_operand, reading_to_EM => True);
   127.    end words_read_to_EM;
   128.
   129.    procedure put_symbols (the_device    : in out shift.device;
   130.                           Q_operand     : in KDF9.Q_register;
   131.                           writing_to_EM : in Boolean) is
   132.       start_address : constant KDF9.address := Q_operand.I;
   133.       end_address   : constant KDF9.address := Q_operand.M;
   134.       fill   : KDF9.word := 0;
   135.       size   : KDF9.word := 0;
   136.       symbol : KDF9_char_sets.symbol;
   137.       char   : Character;
   138.    begin
   139.       check_addresses_and_lockouts(start_address, end_address);
   140.    word_loop:
   141.       for w in start_address .. end_address loop
   142.          for c in KDF9_char_sets.symbol_index'Range loop
   143.             symbol := fetch_symbol(w, c);
   144.             size := size + 1;
   145.             if symbol = KDF9_char_sets.Word_Filler then
   146.                -- Filler was suppressed on normal output to the slow devices.
   147.                fill := fill + 1;
   148.             elsif symbol = KDF9_char_sets.Case_Shift then
   149.                the_device.current_case := KDF9_char_sets.Case_Shift;
   150.             elsif  symbol = KDF9_char_sets.Case_Normal then
   151.                the_device.current_case := KDF9_char_sets.Case_Normal;
   152.             else
   153.                if the_device.current_case = KDF9_char_sets.Case_Normal then
   154.                   char := TP_CN(symbol);
   155.                else
   156.                   char := TP_CS(symbol);
   157.                end if;
   158.                put_char(char, the_device.stream);
   159.                exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
   160.             end if;
   161.          end loop;
   162.       end loop word_loop;
   163.       do_output_housekeeping(the_device, written => size-fill, fetched => size);
   164.    exception
   165.       when end_of_stream =>
   166.          do_output_housekeeping(the_device, written => size-fill, fetched => size);
   167.    end put_symbols;
   168.
   169.    procedure write (the_device : in out shift.device;
   170.                     Q_operand  : in KDF9.Q_register) is
   171.    begin
   172.       put_symbols(the_device, Q_operand, writing_to_EM => False);
   173.    end write;
   174.
   175.    procedure write_to_EM (the_device : in out shift.device;
   176.                           Q_operand  : in KDF9.Q_register) is
   177.    begin
   178.       put_symbols(the_device, Q_operand, writing_to_EM => True);
   179.    end write_to_EM;
   180.
   181.    procedure put_words (the_device    : in out shift.device;
   182.                         Q_operand     : in KDF9.Q_register;
   183.                         writing_to_EM : in Boolean) is
   184.       start_address : constant KDF9.address := Q_operand.I;
   185.       end_address   : constant KDF9.address := Q_operand.M;
   186.       size : KDF9.word := 0;
   187.       word : KDF9.word;
   188.       char : Character;
   189.    begin
   190.       check_addresses_and_lockouts(start_address, end_address);
   191.       for w in start_address .. end_address loop
   192.          word := fetch_word(w) and 8#377#;
   193.          char := Character'Val(word);
   194.          put_byte(char, the_device.stream);
   195.          size := size + 1;
   196.       exit when writing_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   197.       end loop;
   198.       do_output_housekeeping(the_device, written => size, fetched => size);
   199.    exception
   200.       when end_of_stream =>
   201.          do_output_housekeeping(the_device, written => size, fetched => size);
   202.    end put_words;
   203.
   204.    procedure words_write (the_device : in out shift.device;
   205.                           Q_operand  : in KDF9.Q_register) is
   206.    begin
   207.       put_words(the_device, Q_operand, writing_to_EM => False);
   208.    end words_write;
   209.
   210.    procedure words_write_to_EM (the_device : in out shift.device;
   211.                                 Q_operand  : in KDF9.Q_register) is
   212.    begin
   213.       put_words(the_device, Q_operand, writing_to_EM => True);
   214.    end words_write_to_EM;
   215.
   216.    procedure output_a_gap (the_device   : in out shift.device;
   217.                            Q_operand    : in KDF9.Q_register;
   218.                            set_offline  : in Boolean;
   219.                            word_mode    : in Boolean := False;
   220.                            text_mode    : in Boolean := False) is
   221.       length : constant KDF9.word :=  KDF9.word(Q_operand.M) * (if word_mode then 8 else 1);
   222.       char   : constant Character := Character'Val(0);
   223.       size   : KDF9.word := 0;
   224.    begin
   225.       require_positive_count(Q_operand.M);
   226.       for i in 1 .. length loop
   227.          size := size + 1;
   228.          if text_mode then
   229.             do_not_put_byte(char, the_device.stream);
   230.          else
   231.             put_byte(char, the_device.stream);
   232.          end if;
   233.       end loop;
   234.       start_data_transfer(
   235.                           the_device,
   236.                           (Q_operand.C, 0, Q_operand.M),
   237.                           set_offline,
   238.                           busy_time => IO_elapsed_time(the_device, length)
   239.                          );
   240.       do_output_housekeeping(the_device, written => length, fetched => 0);
   241.    exception
   242.       when end_of_stream =>
   243.          do_output_housekeeping(the_device, written => size, fetched => 0);
   244.    end output_a_gap;
   245.
   246.    procedure do_output_housekeeping (the_device : in out shift.device;
   247.                                      written,
   248.                                      fetched    : in KDF9.word) is
   249.    begin
   250.       flush(the_device.stream);
   251.       add_in_the_IO_CPU_time(the_device, fetched);
   252.       correct_transfer_time(the_device, written);
   253.       the_device.byte_count := the_device.byte_count + fetched;
   254.    end do_output_housekeeping;
   255.
   256.    procedure set_case (the_device  : in out shift.device;
   257.                        the_setting : in KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal) is
   258.    begin
   259.       the_device.current_case := the_setting;
   260.    end set_case;
   261.
   262.    function uses_Latin_1 (the_device : in shift.device)
   263.    return Boolean
   264.    is (the_device.is_transcribing);
   265.
   266.    overriding
   267.    procedure Finalize (the_device : in out shift.device) is
   268.    begin
   269.       close(
   270.             the_device,
   271.             "transferred",
   272.             the_device.byte_count,
   273.             "character" & plurality(the_device.byte_count)
   274.            );
   275.    end Finalize;
   276.
   277. end IOC.slow.shift;

Compiling: ../Source/ioc-slow-shift.ads
Source file time stamp: 2021-02-13 13:58:43
Compiled at: 2021-02-21 15:54:05

     1. -- Emulation of the common functionality of a 2-case (Normal/Shift) buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18.
    19. package IOC.slow.shift is
    20.
    21.    --
    22.    -- Abstract common functionality of Case Normal / Case Shift devices, e.g.,
    23.    --    the paper tape reader (TR), punch (TP) and console Flexowriter (FW).
    24.    --
    25.
    26.    type device is abstract new IOC.slow.device with private;
    27.
    28.    procedure set_case (the_device  : in out shift.device;
    29.                        the_setting : in KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal);
    30.
    31.    function uses_Latin_1 (the_device : in shift.device)
    32.    return Boolean;
    33.
    34. private
    35.
    36.    type device is abstract new IOC.slow.device with
    37.       record
    38.          current_case : KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal;
    39.       end record;
    40.
    41.    overriding
    42.    procedure Finalize (the_device : in out shift.device);
    43.
    44.    overriding
    45.    procedure Initialize (the_device : in out shift.device);
    46.
    47.    procedure do_input_housekeeping (the_device : in out shift.device;
    48.                                     read_in,
    49.                                     stored     : in KDF9.word);
    50.
    51.    procedure do_output_housekeeping (the_device : in out shift.device;
    52.                                      written,
    53.                                      fetched    : in KDF9.word);
    54.
    55.    procedure write (the_device : in out shift.device;
    56.                     Q_operand  : in KDF9.Q_register);
    57.
    58.    procedure read (the_device : in out shift.device;
    59.                    Q_operand  : in KDF9.Q_register);
    60.
    61.    procedure write_to_EM (the_device : in out shift.device;
    62.                           Q_operand  : in KDF9.Q_register);
    63.
    64.    procedure read_to_EM (the_device : in out shift.device;
    65.                          Q_operand  : in KDF9.Q_register);
    66.
    67.    procedure words_write (the_device : in out shift.device;
    68.                           Q_operand  : in KDF9.Q_register);
    69.
    70.    procedure words_read (the_device : in out shift.device;
    71.                          Q_operand  : in KDF9.Q_register);
    72.
    73.    procedure words_write_to_EM (the_device : in out shift.device;
    74.                                 Q_operand  : in KDF9.Q_register);
    75.
    76.    procedure words_read_to_EM (the_device : in out shift.device;
    77.                                Q_operand  : in KDF9.Q_register);
    78.
    79.    procedure output_a_gap (the_device   : in out shift.device;
    80.                            Q_operand    : in KDF9.Q_register;
    81.                            set_offline  : in Boolean;
    82.                            word_mode    : in Boolean := False;
    83.                            text_mode    : in Boolean := False);
    84.
    85. end IOC.slow.shift;

 277 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-tp.adb
Source file time stamp: 2021-02-19 16:40:08
Compiled at: 2021-02-21 15:54:05

     1. -- Emulation of a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.shift.TP is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_TP : in out TP.device) is
    23.    begin
    24.       open(the_TP, write_mode);
    25.    end Initialize;
    26.
    27.    -- the_T_bit_is_set := (the buffer has been switched from a tape punch to a graph plotter)
    28.    overriding
    29.    procedure PMB (the_TP      : in out TP.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean) is
    32.    begin
    33.       validate_device(the_TP);
    34.       validate_parity(the_TP);
    35.       deal_with_a_busy_device(the_TP, 13, set_offline);
    36.       the_T_bit_is_set := False;  -- We never get here if GP0 is enabled.
    37.       take_note_of_test(the_TP.device_name, Q_operand, the_T_bit_is_set);
    38.    end PMB;
    39.
    40. --
    41. --
    42.    --
    43.    -- See Manual, 17.4 for paper tape 8-bit frame format.
    44.    --
    45. --
    46. --
    47.
    48.    procedure write_KDF9_tape_code (the_TP        : in out TP.device;
    49.                                    Q_operand     : in KDF9.Q_register;
    50.                                    writing_to_EM : in Boolean := False) is
    51.
    52.       function framed (symbol : KDF9_char_sets.symbol)
    53.       return Natural is
    54.
    55.          SP : constant := 8#000#;
    56.
    57.          function channel_8
    58.          return KDF9.syllable
    59.          is (if symbol = SP then 2#10_000_000# else 0);
    60.
    61.          function parity
    62.          return KDF9.syllable is
    63.             frame  : KDF9.syllable := KDF9.syllable(KDF9_char_sets.symbol'Pos(symbol)) or channel_8;
    64.             parity : KDF9.syllable := 0;
    65.          begin -- parity
    66.             while frame /= 0 loop
    67.                parity := parity xor (frame and 1);
    68.                frame  := frame / 2;
    69.             end loop;
    70.             return (if parity = 0 then 0 else 2#00_010_000#);
    71.          end parity;
    72.
    73.          low_4_bits : constant KDF9.syllable := KDF9.syllable(symbol)   and 2#00_001_111#;
    74.          bits_5and6 : constant KDF9.syllable := KDF9.syllable(symbol)*2 and 2#01_100_000#;
    75.
    76.       begin -- framed
    77.          return KDF9.syllable'Pos(channel_8 or bits_5and6 or parity or low_4_bits);
    78.       end framed;
    79.
    80.       start_address : constant KDF9.address := Q_operand.I;
    81.       end_address   : constant KDF9.address := Q_operand.M;
    82.       size   : KDF9.word := 0;
    83.       symbol : KDF9_char_sets.symbol;
    84.       char   : Character;
    85.
    86.    begin -- write_KDF9_tape_code
    87.       check_addresses_and_lockouts(start_address, end_address);
    88.    word_loop:
    89.       for w in start_address .. end_address loop
    90.          for c in KDF9_char_sets.symbol_index'Range loop
    91.             symbol := fetch_symbol(w, c);
    92.             size := size + 1;
    93.             char := Character'Val(framed(symbol));
    94.             put_byte(char, the_TP.stream);
    95.          exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
    96.          end loop;
    97.       end loop word_loop;
    98.       do_output_housekeeping(the_TP, written => size, fetched => size);
    99.    exception
   100.       when end_of_stream =>
   101.          do_output_housekeeping(the_TP, written => size, fetched => size);
   102.    end write_KDF9_tape_code;
   103.
   104.    -- PWQq
   105.    overriding
   106.    procedure POA (the_TP      : in out TP.device;
   107.                   Q_operand   : in KDF9.Q_register;
   108.                   set_offline : in Boolean) is
   109.    begin
   110.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   111.       if the_TP.is_transcribing then
   112.          write(the_TP, Q_operand);
   113.       else
   114.          write_KDF9_tape_code(the_TP, Q_operand);
   115.       end if;
   116.       lock_out_relative_addresses(Q_operand);
   117.    end POA;
   118.
   119.    -- PWEQq
   120.    overriding
   121.    procedure POB (the_TP      : in out TP.device;
   122.                   Q_operand   : in KDF9.Q_register;
   123.                   set_offline : in Boolean) is
   124.    begin
   125.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   126.       if the_TP.is_transcribing then
   127.          write_to_EM(the_TP, Q_operand);
   128.       else
   129.          write_KDF9_tape_code(the_TP, Q_operand, writing_to_EM => True);
   130.       end if;
   131.       lock_out_relative_addresses(Q_operand);
   132.    end POB;
   133.
   134.    -- PWCQq
   135.    overriding
   136.    procedure POC (the_TP      : in out TP.device;
   137.                   Q_operand   : in KDF9.Q_register;
   138.                   set_offline : in Boolean) is
   139.    begin
   140.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   141.       words_write(the_TP, Q_operand);
   142.       lock_out_relative_addresses(Q_operand);
   143.    end POC;
   144.
   145.    -- PWCEQq
   146.    overriding
   147.    procedure POD (the_TP      : in out TP.device;
   148.                   Q_operand   : in KDF9.Q_register;
   149.                   set_offline : in Boolean) is
   150.    begin
   151.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   152.       words_write_to_EM(the_TP, Q_operand);
   153.       lock_out_relative_addresses(Q_operand);
   154.    end POD;
   155.
   156.    -- PGAPQq
   157.    overriding
   158.    procedure POE (the_TP      : in out TP.device;
   159.                   Q_operand   : in KDF9.Q_register;
   160.                   set_offline : in Boolean) is
   161.    begin
   162.       require_nonnegative_count(Q_operand.M);
   163.       output_a_gap(
   164.                    the_TP,
   165.                    Q_operand,
   166.                    set_offline,
   167.                    word_mode => False,
   168.                    text_mode => the_TP.is_transcribing
   169.                   );
   170.    end POE;
   171.
   172.    -- "word gap"
   173.    overriding
   174.    procedure POF (the_TP      : in out TP.device;
   175.                   Q_operand   : in KDF9.Q_register;
   176.                   set_offline : in Boolean) is
   177.    begin
   178.       require_nonnegative_count(Q_operand.M);
   179.       output_a_gap(
   180.                    the_TP,
   181.                    Q_operand,
   182.                    set_offline,
   183.                    word_mode => True,
   184.                    text_mode => the_TP.is_transcribing
   185.                   );
   186.    end POF;
   187.
   188.    overriding
   189.    procedure Finalize (the_TP : in out TP.device) is
   190.    begin
   191.       close(
   192.             the_TP,
   193.             "punched",
   194.             the_TP.byte_count,
   195.             "character" & plurality(the_TP.byte_count)
   196.           & " in "
   197.           & (if the_TP.is_transcribing then "Latin-1" else "KDF9")
   198.           & " code"
   199.            );
   200.    end Finalize;
   201.
   202.    type TP_access is access TP.device;
   203.
   204.    TP0  : TP_access with Warnings => Off;
   205.    TP1  : TP_access with Warnings => Off;
   206.
   207.    unit : IOC.unit_number := 0;
   208.
   209.    procedure enable (b : in KDF9.buffer_number) is
   210.    begin
   211.       case unit is
   212.          when 0 =>
   213.             TP0 := new TP.device (number => b, unit => 0);
   214.             TP0_number := b;
   215.          when 1 =>
   216.             TP1 := new TP.device (number => b, unit => 1);
   217.             TP1_number := b;
   218.          when others =>
   219.             trap_operator_error("more than two TP units have been configured");
   220.       end case;
   221.       unit := unit + 1;
   222.    end enable;
   223.
   224.    procedure remove_from_buffer (b : in KDF9.buffer_number) is
   225.    begin
   226.       if TP1 /= null   and then
   227.             TP1.number = b then
   228.          Finalize(TP1.all);
   229.          TP1 := null;
   230.       else
   231.          trap_operator_error("GP0 cannot be configured. TP1 is not on buffer #" & oct_of(b, 2));
   232.       end if;
   233.    end remove_from_buffer;
   234.
   235.    -- Set the character code to be used by the designated TP.
   236.    procedure set_unit_code (unit : in Natural; is_transcribing : in Boolean) is
   237.    begin
   238.       if unit = 0 and then TP0 /= null then
   239.          TP0.is_transcribing := set_unit_code.is_transcribing;
   240.       elsif unit = 1 and then TP1 /= null then
   241.          TP1.is_transcribing := set_unit_code.is_transcribing;
   242.       end if;
   243.    end set_unit_code;
   244.
   245. end IOC.slow.shift.TP;

Compiling: ../Source/ioc-slow-shift-tp.ads
Source file time stamp: 2021-02-15 01:13:24
Compiled at: 2021-02-21 15:54:05

     1. -- Emulation of a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.TP is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    -- PWQq
    22.    overriding
    23.    procedure POA (the_TP      : in out TP.device;
    24.                   Q_operand   : in KDF9.Q_register;
    25.                   set_offline : in Boolean);
    26.
    27.    -- PWEQq
    28.    overriding
    29.    procedure POB (the_TP      : in out TP.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    -- PWCQq
    34.    overriding
    35.    procedure POC (the_TP      : in out TP.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    -- PWCEQq
    40.    overriding
    41.    procedure POD (the_TP      : in out TP.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    -- PGAPQq
    46.    overriding
    47.    procedure POE (the_TP      : in out TP.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- This is called "word gap" in the Manual, but never defined.
    52.    overriding
    53.    procedure POF (the_TP      : in out TP.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- the_T_bit_is_set (the buffer has been switched from a tape punch to a graph plotter)
    58.    overriding
    59.    procedure PMB (the_TP      : in out TP.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    procedure enable (b : in KDF9.buffer_number);
    64.
    65.    -- Finalize TP1 if necessary and remove it from the configuration, to allow GP0 to be attached.
    66.    procedure remove_from_buffer (b : in KDF9.buffer_number);
    67.
    68.    -- Set the character code to be used by the TP unit.
    69.    procedure set_unit_code(unit : in Natural; is_transcribing : in Boolean);
    70.
    71. private
    72.
    73.    type device is new IOC.slow.shift.device with null record;
    74.
    75.    overriding
    76.    procedure Initialize (the_TP : in out TP.device);
    77.
    78.    overriding
    79.    procedure Finalize (the_TP : in out TP.device);
    80.
    81.    overriding
    82.    function kind (the_TP : TP.device)
    83.    return IOC.device_kind
    84.    is (TP_kind);
    85.
    86.    overriding
    87.    function quantum (the_TP : TP.device)
    88.    return KDF9.us
    89.    is (1E6 / 110);
    90.
    91. end IOC.slow.shift.TP;

 245 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-tr.adb
Source file time stamp: 2021-02-19 16:40:08
Compiled at: 2021-02-21 15:54:05

     1. -- Emulation of a paper tape reader buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18. with KDF9.TOD_clock;
    19. with KDF9.TSD.timing;
    20.
    21. use  KDF9_char_sets;
    22. use  KDF9.TOD_clock;
    23.
    24. package body IOC.slow.shift.TR is
    25.
    26.    use KDF9_char_sets;
    27.
    28.    overriding
    29.    procedure Initialize (the_TR : in out TR.device) is
    30.    begin
    31.       -- Open the associated file.
    32.       open(IOC.device(the_TR), read_mode);
    33.    end Initialize;
    34.
    35.    --
    36.    -- See Manual, 17.4 for paper tape 8-bit frame format.
    37.    --
    38.
    39.    function has_even_parity (octet : KDF9.syllable)
    40.    return Boolean is
    41.       frame  : KDF9.syllable := octet;
    42.       parity : KDF9.syllable := 0;
    43.    begin
    44.       while frame /= 0 loop
    45.          parity := parity xor (frame and 1);
    46.          frame  := frame / 2;
    47.       end loop;
    48.       return parity = 0;
    49.    end has_even_parity;
    50.
    51.    function symbol_from (octet : KDF9.syllable)
    52.    return KDF9_char_sets.symbol
    53.    is (KDF9_char_sets.symbol((octet and 2#01_100_000#)/2 or (octet and 2#00_001_111#)));
    54.
    55.    DEL_frame : constant := 8#377#;
    56.    NUL_frame : constant := 8#000#;
    57.
    58.    -- Read 8-bit paper tape frames, compress to 6-bit byteacters, and pack into words.
    59.    procedure read_KDF9_tape_code (the_TR        : in out TR.device;
    60.                                   Q_operand     : in KDF9.Q_register;
    61.                                   reading_to_EM,
    62.                                   loading_code  : in Boolean := False) is
    63.       c      : KDF9_char_sets.symbol_index := 0;
    64.       w      : KDF9.Q_part := Q_operand.I;
    65.       size   : KDF9.word := 0;
    66.       octet  : KDF9.syllable;
    67.       symbol : KDF9_char_sets.symbol;
    68.       byte   : Character;
    69.    begin
    70.       check_addresses_and_lockouts(Q_operand.I, Q_operand.M);
    71.    word_loop:
    72.       loop
    73.          loop
    74.             get_byte_from_stream(byte, the_TR);
    75.             octet := KDF9.syllable(Character'Pos(byte));
    76.          exit when octet not in NUL_frame | DEL_frame;
    77.          end loop;
    78.          if has_even_parity(octet) then
    79.             symbol := symbol_from(octet);
    80.          else
    81.             trap_invalid_paper_tape("probably not in KDF9 code (parity error detected)");
    82.          end if;
    83.          store_symbol(symbol, w, c);
    84.          size := size + 1;
    85.          c := c + 1;
    86.          if c = 0 then
    87.       exit word_loop when reading_to_EM and symbol = KDF9_char_sets.End_Message;
    88.             w := w + 1;
    89.       exit word_loop when w > Q_operand.M;
    90.          end if;
    91.          if reading_to_EM and then symbol = KDF9_char_sets.End_Message then
    92.             for d in c .. 7 loop
    93.                store_symbol(KDF9_char_sets.Blank_Space, w, d);
    94.             end loop;
    95.       exit word_loop;
    96.          end if;
    97.       exit word_loop when w > Q_operand.M;
    98.       end loop word_loop;
    99.       if not loading_code then
   100.          do_input_housekeeping(the_TR, read_in => size, stored => size);
   101.       end if;
   102.    exception
   103.       when end_of_stream =>
   104.          if size = 0 then
   105.             trap_invalid_paper_tape("there was no data on the tape");
   106.          end if;
   107.          if not loading_code then
   108.             do_input_housekeeping(the_TR, read_in => size, stored => size);
   109.          end if;
   110.          the_TR.is_abnormal := True;
   111.          if not reading_to_EM and c /= 0 then
   112.             trap_invalid_paper_tape("the last word on the tape was incomplete");
   113.          end if;
   114.    end read_KDF9_tape_code;
   115.
   116.    -- PRQq
   117.    overriding
   118.    procedure PIA (the_TR      : in out TR.device;
   119.                   Q_operand   : in KDF9.Q_register;
   120.                   set_offline : in Boolean) is
   121.    begin
   122.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   123.       if the_TR.is_transcribing then
   124.          read(the_TR, Q_operand);
   125.       else
   126.          read_KDF9_tape_code(the_TR, Q_operand);
   127.       end if;
   128.       lock_out_relative_addresses(Q_operand);
   129.    end PIA;
   130.
   131.    -- PREQq
   132.    overriding
   133.    procedure PIB (the_TR      : in out TR.device;
   134.                   Q_operand   : in KDF9.Q_register;
   135.                   set_offline : in Boolean) is
   136.    begin
   137.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   138.       if the_TR.is_transcribing then
   139.          read_to_EM(the_TR, Q_operand);
   140.       else
   141.          read_KDF9_tape_code(the_TR, Q_operand, reading_to_EM => True);
   142.       end if;
   143.       lock_out_relative_addresses(Q_operand);
   144.    end PIB;
   145.
   146.    -- PRCQq
   147.    overriding
   148.    procedure PIC (the_TR      : in out TR.device;
   149.                   Q_operand   : in KDF9.Q_register;
   150.                   set_offline : in Boolean) is
   151.    begin
   152.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   153.       words_read(the_TR, Q_operand);
   154.       lock_out_relative_addresses(Q_operand);
   155.    end PIC;
   156.
   157.    -- PRCEQq
   158.    overriding
   159.    procedure PID (the_TR      : in out TR.device;
   160.                   Q_operand   : in KDF9.Q_register;
   161.                   set_offline : in Boolean) is
   162.    begin
   163.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   164.       words_read_to_EM(the_TR, Q_operand);
   165.       lock_out_relative_addresses(Q_operand);
   166.    end PID;
   167.
   168.    -- as PIA
   169.    overriding
   170.    procedure PIE (the_TR      : in out TR.device;
   171.                   Q_operand   : in KDF9.Q_register;
   172.                   set_offline : in Boolean) is
   173.    begin
   174.       PIA(the_TR, Q_operand, set_offline);
   175.    end PIE;
   176.
   177.    -- as PIB
   178.    overriding
   179.    procedure PIF (the_TR      : in out TR.device;
   180.                   Q_operand   : in KDF9.Q_register;
   181.                   set_offline : in Boolean) is
   182.    begin
   183.       PIB(the_TR, Q_operand, set_offline);
   184.    end PIF;
   185.
   186.    -- as PIC
   187.    overriding
   188.    procedure PIG (the_TR      : in out TR.device;
   189.                   Q_operand   : in KDF9.Q_register;
   190.                   set_offline : in Boolean) is
   191.    begin
   192.       PIC(the_TR, Q_operand, set_offline);
   193.    end PIG;
   194.
   195.    -- as PID
   196.    overriding
   197.    procedure PIH (the_TR      : in out TR.device;
   198.                   Q_operand   : in KDF9.Q_register;
   199.                   set_offline : in Boolean) is
   200.    begin
   201.       PID(the_TR, Q_operand, set_offline);
   202.    end PIH;
   203.
   204.    -- the_T_bit_is_set := (the reader is set to 8-track mode);
   205.    --    it is always in 8-track mode, as 5-track input is not supported by ee9.
   206.    overriding
   207.    procedure PMB (the_TR      : in out TR.device;
   208.                   Q_operand   : in KDF9.Q_register;
   209.                   set_offline : in Boolean) is
   210.    begin
   211.       validate_device(the_TR);
   212.       validate_parity(the_TR);
   213.       deal_with_a_busy_device(the_TR, 13, set_offline);
   214.       the_T_bit_is_set := True;
   215.       take_note_of_test(the_TR.device_name, Q_operand, the_T_bit_is_set);
   216.    end PMB;
   217.
   218.    overriding
   219.    procedure Finalize (the_TR : in out TR.device) is
   220.    begin
   221.       close(
   222.             the_TR,
   223.             "read",
   224.             the_TR.byte_count,
   225.             "character" & plurality(the_TR.byte_count)
   226.           & " in "
   227.           & (if the_TR.is_transcribing then "Latin-1" else "KDF9")
   228.           & " code"
   229.            );
   230.    end Finalize;
   231.
   232.    type TR_access is access TR.device;
   233.
   234.    TR0  : TR_access with Warnings => Off;
   235.    TR1  : TR_access with Warnings => Off;
   236.
   237.    unit : IOC.unit_number := 0;
   238.
   239.    procedure enable (b : in KDF9.buffer_number) is
   240.    begin
   241.       case unit is
   242.          when 0 =>
   243.             TR0 := new TR.device (number => b, unit => 0);
   244.             TR0_number := b;
   245.          when 1 =>
   246.             TR1 := new TR.device (number => b, unit => 1);
   247.             TR1_number := b;
   248.          when others =>
   249.             trap_operator_error("more than two TR units have been configured");
   250.       end case;
   251.       unit := unit + 1;
   252.    end enable;
   253.
   254.    -- Set the character code to be used by the designated TR.
   255.    procedure set_unit_code (unit : in Natural; is_transcribing : in Boolean) is
   256.    begin
   257.       if unit = 0 then
   258.          TR0.is_transcribing := set_unit_code.is_transcribing;
   259.       elsif TR1 /= null then
   260.          TR1.is_transcribing := set_unit_code.is_transcribing;
   261.       end if;
   262.    end set_unit_code;
   263.
   264.    --
   265.    -- Support for loading programs and for bootstrapping the KDF9.
   266.    --
   267.
   268.    procedure reattach (unit : in Natural; next_file_name : in String) is
   269.       the_reader  : constant TR_access := (if unit = 0 then TR0 else TR1);
   270.    begin
   271.       reattach(the_reader.all, next_file_name);
   272.       if the_reader.is_open then
   273.          the_reader.current_case := KDF9_char_sets.Case_Normal;
   274.       else
   275.          trap_operator_error("'" & next_file_name & "' cannot be found");
   276.       end if;
   277.    end reattach;
   278.
   279.    procedure reset_loader_usage (unit : in Natural) is
   280.       the_reader  : constant TR_access := (if unit = 0 then TR0 else TR1);
   281.    begin
   282.       correct_transfer_time(the_reader.all, KDF9.us(0));
   283.       the_reader.byte_count := 0;
   284.       unlock_absolute_addresses((0, 0, 32767));
   285.    end reset_loader_usage;
   286.
   287.    -- This emulates the Director's program load from a designated  paper tape reader.
   288.    -- Once the loading is done, the tape reader is reattached to TR<unit>.
   289.
   290.    procedure load_a_program  (program_file_name : in String) is
   291.
   292.       -- This is the call sign for a program on Disc or Drum.
   293.       CN_LS_D_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   294.                                       or (KDF9.word(Line_Shift)   * 2**12)
   295.                                       or (KDF9.word(Upper_Case_D) * 2** 6)
   296.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   297.
   298.       -- This is the call sign for a program on Magnetic Tape.
   299.       CN_LS_M_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   300.                                       or (KDF9.word(Line_Shift)   * 2**12)
   301.                                       or (KDF9.word(Upper_Case_M) * 2** 6)
   302.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   303.
   304.       -- This is the call sign for a program on Paper Tape.
   305.       CN_LS_P_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   306.                                       or (KDF9.word(Line_Shift)   * 2**12)
   307.                                       or (KDF9.word(Upper_Case_P) * 2** 6)
   308.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   309.
   310.       threshold  : constant KDF9.word := 32767 * 2**24;
   311.       substitute : constant KDF9.word := 32736 * 2**24;
   312.       get_a_word : constant KDF9.Q_register := (TR0.number, 0, 0);
   313.
   314.       descriptor : KDF9.Q_register := (TR0.number, 1, 7);
   315.       word_count : Positive := 2;
   316.
   317.    begin -- load_a_program
   318.
   319.       loading_was_successful := False;
   320.
   321.       -- Access the program file as TR0.
   322.       reattach(0, program_file_name);
   323.
   324.       --
   325.       -- For the structure of a compiled program, see Manual 26.3.
   326.       --
   327.
   328.       -- Get the first word of the file into E0: it may start an A block or a B block.
   329.       read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True);
   330.
   331.       -- Check for an A block.  If one is found, check its validity, but otherwise ignore it.
   332.       if fetch_halfword(0, 0)/2**24 in CN_LS_D_LS | CN_LS_M_LS | CN_LS_P_LS then
   333.          -- We have an A block.
   334.          -- The next word completes the program name used by Director.  Ignore it.
   335.          read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True);
   336.
   337.       block_loop:
   338.          -- An A block is at most 8 words long but can end sooner with a word containing EM.
   339.          loop
   340.             word_count := word_count + 1;
   341.          exit block_loop when word_count > 8;
   342.             read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True, reading_to_EM => True);
   343.             for c in KDF9_char_sets.symbol_index loop
   344.          exit block_loop when fetch_symbol(0, c) = End_Message;
   345.             end loop;
   346.          end loop block_loop;
   347.
   348.          if word_count > 8 then
   349.             -- The file is not a valid program tape.
   350.             trap_invalid_paper_tape("excessively long A block");
   351.          end if;
   352.
   353.          -- Read the first word of the following B block.
   354.          read_KDF9_tape_code(TR0.all, (TR0.number, 0, 0), loading_code => True);
   355.       end if;
   356.
   357.       -- Check for an unconditional jump at the start of the B block.
   358.       if (fetch_word(0)/ 2**32 and 2#1111_0000_1111_0000#) /= 2#1000_0000_1011_0000# then
   359.          -- The file is not a valid program tape.
   360.          trap_invalid_paper_tape("no jump was found in E0H");
   361.       end if;
   362.
   363.       -- At this point, E0 contains the first word of the B block, so get the rest of it in E1-E7.
   364.       read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   365.
   366.       descriptor := as_Q(fetch_word(descriptor.M));
   367.       -- Read the non-final C blocks; the validity of the designated descriptors cannot be assumed.
   368.       while descriptor.C /= 0 loop
   369.          validate_address_range(descriptor.I, descriptor.M);
   370.          read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   371.          descriptor := as_Q(fetch_word(descriptor.M));
   372.       end loop;
   373.
   374.       -- Read the final C block.
   375.       validate_address_range(descriptor.I, descriptor.M);
   376.       read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   377.
   378.       -- Set up the rest of the stored image.
   379.
   380.       -- Preserve the initial jump in case of corruption by a buggy program.
   381.       save_the_initial_jump;
   382.
   383.       -- Set the (virtual) date in E7.
   384.       store_word(todays_date_28n_years_ago, 7);
   385.
   386.       -- Ensure valid parameters in E1 (some binaries may have invalid entries).
   387.       if fetch_halfword(1, 0) > threshold or else fetch_halfword(1, 0) = 0 then
   388.          store_halfword(substitute, 1, 0);
   389.       end if;
   390.       if fetch_halfword(1, 1) > threshold or else fetch_halfword(1, 1) = 0 then
   391.          store_halfword(substitute, 1, 1);
   392.       end if;
   393.
   394.       -- Do not set the time if we are computing a signature, so as to get a repeatable hash.
   395.       if not the_signature_is_enabled then
   396.          KDF9.TSD.timing.set_the_time_of_loading(the_time_of_day);
   397.       end if;
   398.
   399.       loading_was_successful := True;
   400.
   401.       -- Clear up the I/O system.
   402.       reattach(0, "TR0");
   403.       clear_IOC_FIFO;
   404.       reset_loader_usage(0);
   405.    end load_a_program;
   406.
   407.    -- TR0 is the hardware bootstrap device for reading initial orders.
   408.    procedure boot_the_KDF9 (program_file_name : in String) is
   409.       boot_descriptor : constant KDF9.Q_register := (C => TR0.number, I => 0, M => 8);
   410.    begin
   411.       loading_was_successful := False;
   412.       reattach(0, program_file_name);
   413.
   414.       -- The bootstrap is 9 words of instruction code, which reads in the rest of its file.
   415.       -- The validity of the bootstrap descriptor is hardware defined.
   416.       read_KDF9_tape_code(TR0.all, boot_descriptor, loading_code => True);
   417.
   418.       -- Reset the I/O system for execution of the Director.
   419.       clear_IOC_FIFO;
   420.       reset_loader_usage(0);
   421.       loading_was_successful := True;
   422.    end boot_the_KDF9;
   423.
   424. end IOC.slow.shift.TR;

Compiling: ../Source/ioc-slow-shift-tr.ads
Source file time stamp: 2021-02-15 01:13:04
Compiled at: 2021-02-21 15:54:05

     1. -- Emulation of a paper tape reader buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.TR is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    -- PRQq
    22.    overriding
    23.    procedure PIA (the_TR      : in out TR.device;
    24.                   Q_operand   : in KDF9.Q_register;
    25.                   set_offline : in Boolean);
    26.
    27.    -- PREQq
    28.    overriding
    29.    procedure PIB (the_TR      : in out TR.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    --PRCQq
    34.    overriding
    35.    procedure PIC (the_TR      : in out TR.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    -- PRCEQq
    40.    overriding
    41.    procedure PID (the_TR      : in out TR.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    -- as PIA
    46.    overriding
    47.    procedure PIE (the_TR      : in out TR.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- as PIB
    52.    overriding
    53.    procedure PIF (the_TR      : in out TR.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- as PIC
    58.    overriding
    59.    procedure PIG (the_TR      : in out TR.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    -- as PID
    64.    overriding
    65.    procedure PIH (the_TR      : in out TR.device;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    -- the_T_bit_is_set (the reader is set to 8-track mode)
    70.    overriding
    71.    procedure PMB (the_TR      : in out TR.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    procedure enable (b : in KDF9.buffer_number);
    76.
    77.    -- Reattach the designated TR to the specified file and set CASE NORMAL (may be irrelevant).
    78.    -- This is done after loading a binary program, to allow access any TR data file(s);
    79.    --    also to access a binary program for loading as an overlay.
    80.    procedure reattach (unit : in Natural; next_file_name : in String);
    81.
    82.    -- Read the 9-word bootstrap.
    83.    procedure boot_the_KDF9 (program_file_name : in String);
    84.
    85.    -- Read a binary program.
    86.    procedure load_a_program (program_file_name : in String);
    87.
    88.    -- Set the character code to be used by the TR unit.
    89.    procedure set_unit_code(unit : in Natural; is_transcribing : in Boolean);
    90.
    91. private
    92.
    93.    type device is new IOC.slow.shift.device with null record;
    94.
    95.    overriding
    96.    procedure Initialize (the_TR : in out TR.device);
    97.
    98.    overriding
    99.    procedure Finalize (the_TR : in out TR.device);
   100.
   101.    overriding
   102.    function kind (the_TR : TR.device)
   103.    return IOC.device_kind
   104.    is (TR_kind);
   105.
   106.    overriding
   107.    function quantum (the_TR : TR.device)
   108.    return KDF9.us
   109.    is (1_000);
   110.
   111. end IOC.slow.shift.TR;

 424 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/say_goodbye.adb
Source file time stamp: 2021-02-11 00:34:42
Compiled at: 2021-02-21 15:54:05

     1. -- Finalize emulation with a helpful message derived from exception information.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Command_Line;
    18. with Ada.Strings.Fixed;
    19. with finalize_ee9;
    20. with HCI;
    21. with settings;
    22.
    23. use  Ada.Command_Line;
    24. use  Ada.Strings.Fixed;
    25.
    26. use  HCI;
    27. use  settings;
    28.
    29. procedure say_goodbye (
    30.                        reason : in String;
    31.                        cause  : in String := "";
    32.                        status : in Exit_Status := Failure
    33.                       ) is
    34.    function explanation
    35.    return String is
    36.       CR   : constant Character := Character'Val(16#D#);
    37.       LF   : constant Character := Character'Val(16#A#);
    38.       L, R : Natural;
    39.    begin  -- explanation
    40.       if cause'Length < 3 then
    41.          return cause;
    42.       end if;
    43.       L := Index(cause, "%", from => cause'First) + 1;
    44.       if cause(cause'Last-1) = CR then
    45.          R := cause'Last - 2;
    46.       elsif cause(cause'Last) in LF | CR then
    47.          R := cause'Last - 1;
    48.       else
    49.          R := cause'Last;
    50.       end if;
    51.       return cause(L .. R);
    52.    end explanation;
    53.
    54. begin  -- say_goodbye
    55.    if reason = "" then
    56.       finalize_ee9("Normal end of run");
    57.    elsif reason'Length > 2 and then
    58.          reason(reason'Last-2..reason'Last) = "OUT" then
    59.       finalize_ee9(reason & " " & explanation);
    60.    elsif reason'Length = 0 then
    61.       finalize_ee9(explanation);
    62.    else
    63.       finalize_ee9(reason & ": " & explanation);
    64.    end if;
    65.    if the_log_is_wanted then
    66.       log_new_line;
    67.    end if;
    68.    Set_Exit_Status(status);
    69. end say_goodbye;

 69 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/settings.adb
Source file time stamp: 2021-02-21 12:55:54
Compiled at: 2021-02-21 15:54:05

     1. -- execution mode, diagnostic mode, and other emulation-control settings
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. with Ada.Long_Float_Text_IO;
    19. with Ada.Text_IO;
    20. --
    21. with dumping;
    22. with exceptions;
    23. with formatting;
    24. with HCI;
    25. with IOC.equipment;
    26. with KDF9.store;
    27. with postscript;
    28. with settings.IO;
    29. with tracing;
    30.
    31. use  Ada.Exceptions;
    32. use  Ada.Long_Float_Text_IO;
    33. use  Ada.Text_IO;
    34. --
    35. use  dumping;
    36. use  exceptions;
    37. use  formatting;
    38. use  HCI;
    39. use  KDF9.store;
    40. use  settings.IO;
    41. use  tracing;
    42.
    43. package body settings is
    44.
    45.    function is_invalid_miscellany_flag (option : in Character)
    46.    return Boolean is
    47.    begin
    48.       for f of miscellany_flags loop
    49.          if f = option then
    50.             return False;
    51.          end if;
    52.       end loop;
    53.       if option = '-' then  -- Ignore hyphens to make the calling scripts easier.
    54.          return False;
    55.       end if;
    56.       return True;
    57.    end is_invalid_miscellany_flag;
    58.
    59.    procedure set_this_miscellany_flag (option : in Character) is
    60.       use IOC.equipment;
    61.    begin
    62.       if is_invalid_miscellany_flag(option) then
    63.          log_line(
    64.                   "***** Error in a miscellany specification: '"
    65.                 & option
    66.                 & "'."
    67.                  );
    68.          return;
    69.       end if;
    70.       case option is
    71.          when '-'        =>
    72.             null;  -- Ignore hyphens, to make the calling scripts easier.
    73.          when '.'        =>
    74.             time_limit := 1_000_000;
    75.          when '0' .. '9' =>
    76.             time_limit := (Character'Pos(option) - Character'Pos('0') + 1) * 100_000_000;
    77.          when 'a' | 'A' =>
    78.             API_logging_is_wanted := False;
    79.          when 'b' | 'B' =>
    80.             choice(KDF9.buffer_number'(15)) := SI;
    81.          when 'd' | 'D' =>
    82.             debugging_is_enabled := True;
    83.          when 'e' | 'E' =>
    84.             the_log_is_wanted := False;
    85.          when 'f' | 'F' =>
    86.             the_final_state_is_wanted := False;
    87.          when 'g' | 'G' =>
    88.             choice(if TP1_number = 0 then TP1_default else TP1_number) := GP;
    89.          when 'h' | 'H' =>
    90.             any_histogram_is_wanted := False;
    91.          when 'i' | 'I' =>
    92.             interrupt_tracing_is_wanted := False;
    93.          when 'k' | 'K' =>
    94.             choice(DR0_default) := DR;
    95.          when 'm' | 'M' =>
    96.             the_terminal_is_ANSI_compatible := False;
    97.          when 'n' | 'N' =>
    98.             noninteractive_usage_is_enabled := True;
    99.             time_limit := offline_time_limit;
   100.           when 'o' |'O' =>
   101.             pre_overlay_state_is_enabled := True;
   102.          when 'p' |'P' =>
   103.             peripheral_tracing_is_wanted := False;
   104.          when 'q' | 'Q' =>
   105.             do_not_execute := True;
   106.          when 'r' | 'R' =>
   107.             retrospective_tracing_is_wanted := False;
   108.          when 's' | 'S' =>
   109.             the_signature_is_wanted := False;
   110.          when 't' | 'T' =>
   111.             authentic_timing_is_enabled := True;
   112.          when 'w' | 'W' =>
   113.             flexowriter_output_is_wanted := False;
   114.          when 'x' | 'X' =>
   115.             only_signature_tracing := True;
   116.          when 'z' | 'Z' =>
   117.             the_log_is_wanted := False;
   118.             debugging_is_enabled := False;
   119.             API_logging_is_wanted := False;
   120.             any_histogram_is_wanted := False;
   121.             the_signature_is_wanted := False;
   122.             the_final_state_is_wanted := False;
   123.             interrupt_tracing_is_wanted := False;
   124.             peripheral_tracing_is_wanted := False;
   125.             retrospective_tracing_is_wanted := False;
   126.          when others =>
   127.             null;
   128.       end case;
   129.       set_diagnostic_mode(the_diagnostic_mode);
   130.    end set_this_miscellany_flag;
   131.
   132.    procedure display_execution_modes (for_this_run : in String := "") is
   133.       needs_comma : Boolean := False;
   134.
   135.       procedure append_option (flag : in Boolean; name : in String) is
   136.       begin
   137.          if flag then
   138.             if needs_comma then
   139.                log(", ");
   140.             end if;
   141.             log(name);
   142.             needs_comma := True;
   143.          end if;
   144.       end append_option;
   145.
   146.       function description_of (type_of_run, name_of_code : String)
   147.       return String
   148.       is (if name_of_code = "" then type_of_run else type_of_run & " " & name_of_code);
   149.
   150.    begin -- display_execution_modes
   151.       if not the_log_is_wanted then return; end if;
   152.       log_new_line;
   153.       if for_this_run = "" then
   154.          log("Resuming the run");
   155.       else
   156.          log(
   157.              case the_execution_mode is
   158.                when boot_mode         => "Booting the KDF9 " & description_of("Director", for_this_run),
   159.                when program_mode      => "Running the KDF9 " & description_of("problem program", for_this_run),
   160.                when test_program_mode => "Running the KDF9 " & description_of("privileged program", for_this_run)
   161.             );
   162.       end if;
   163.       log(" in ");
   164.       log(
   165.           case the_diagnostic_mode is
   166.              when trace_mode    =>
   167.                 (if the_external_trace_is_enabled then "external trace mode" else "trace mode"),
   168.              when fast_mode     => "fast mode",
   169.              when pause_mode    => "pause mode",
   170.              when external_mode => "external trace mode"
   171.          );
   172.       if the_histogram_is_enabled           or else
   173.          the_interrupt_trace_is_enabled     or else
   174.          the_peripheral_trace_is_enabled    or else
   175.          the_retrospective_trace_is_enabled or else
   176.          the_signature_is_enabled           or else
   177.          the_external_trace_is_enabled      or else
   178.          authentic_timing_is_enabled        or else
   179.          debugging_is_enabled               or else
   180.          noninteractive_usage_is_enabled       then
   181.
   182.          log_line(", with option(s):");
   183.          log("   ");
   184.          append_option(authentic_timing_is_enabled,        "authentic timing");
   185.          append_option(debugging_is_enabled,               "debugging output");
   186.          append_option(the_histogram_is_enabled,           "histogram(s)");
   187.          append_option(the_interrupt_trace_is_enabled,     "interrupt trace");
   188.          append_option(noninteractive_usage_is_enabled,    "noninteractive");
   189.          append_option(the_peripheral_trace_is_enabled,    "peripheral trace");
   190.          append_option(the_retrospective_trace_is_enabled, "retro trace");
   191.          append_option(the_signature_is_enabled,           "signature hash");
   192.       end if;
   193.       log_line(".");
   194.       log_rule;
   195.    end display_execution_modes;
   196.
   197.    procedure quit_if_requested is
   198.    begin
   199.       if quit_was_requested then
   200.          raise quit_request;
   201.       end if;
   202.    end quit_if_requested;
   203.
   204.    procedure change_diagnostic_mode_if_requested is
   205.    begin
   206.       if the_diagnostic_mode_changed then
   207.          the_diagnostic_mode_changed := False;
   208.          raise mode_change_request;
   209.       end if;
   210.    end change_diagnostic_mode_if_requested;
   211.
   212.    procedure set_diagnostic_mode (a_diagnostic_mode : in settings.diagnostic_mode) is
   213.       the_signature_is_appropriate,
   214.       the_histogram_is_appropriate,
   215.       retrospective_tracing_is_appropriate,
   216.       peripheral_tracing_is_appropriate,
   217.       interrupt_tracing_is_appropriate : Boolean;
   218.    begin
   219.       if a_diagnostic_mode = external_mode then
   220.          if (the_diagnostic_mode /= external_mode) and (not the_external_trace_is_enabled) then
   221.             open(the_external_trace_file, the_external_trace_file_name);
   222.          end if;
   223.          the_diagnostic_mode := trace_mode;
   224.          the_external_trace_is_enabled := True;
   225.       else
   226.          the_diagnostic_mode := a_diagnostic_mode;
   227.       end if;
   228.       case a_diagnostic_mode is
   229.          when fast_mode =>
   230.             debugging_is_enabled := False;
   231.             the_signature_is_appropriate := False;
   232.             the_histogram_is_appropriate := False;
   233.             retrospective_tracing_is_appropriate := False;
   234.             peripheral_tracing_is_appropriate := False;
   235.             interrupt_tracing_is_appropriate := False;
   236.          when trace_mode | external_mode | pause_mode =>
   237.             the_signature_is_appropriate := True;
   238.             the_histogram_is_appropriate := True;
   239.             retrospective_tracing_is_appropriate := True;
   240.             peripheral_tracing_is_appropriate := True;
   241.             interrupt_tracing_is_appropriate := (the_execution_mode = boot_mode);
   242.       end case;
   243.       the_signature_is_enabled :=
   244.          the_signature_is_wanted and the_signature_is_appropriate;
   245.       the_histogram_is_enabled :=
   246.          any_histogram_is_wanted and the_histogram_is_appropriate;
   247.       the_retrospective_trace_is_enabled :=
   248.          retrospective_tracing_is_wanted and retrospective_tracing_is_appropriate;
   249.       the_peripheral_trace_is_enabled :=
   250.          peripheral_tracing_is_wanted and peripheral_tracing_is_appropriate;
   251.       the_interrupt_trace_is_enabled :=
   252.          interrupt_tracing_is_wanted and interrupt_tracing_is_appropriate;
   253.    end set_diagnostic_mode;
   254.
   255.    procedure set_execution_mode (an_execution_mode : in settings.execution_mode) is
   256.    begin
   257.       the_execution_mode := an_execution_mode;
   258.    end set_execution_mode;
   259.
   260.    package diagnostic_mode_IO   is new Ada.Text_IO.Enumeration_IO(settings.diagnostic_mode);
   261.
   262.    package execution_mode_IO    is new Ada.Text_IO.Enumeration_IO(settings.execution_mode);
   263.
   264.    package authenticity_mode_IO is new Ada.Text_IO.Enumeration_IO(KDF9.authenticity_mode);
   265.
   266.    package equipment_IO         is new Ada.Text_IO.Enumeration_IO(IOC.equipment.kind);
   267.
   268.    procedure get_settings_from_file (version : in String) is
   269.
   270.       the_settings_file_name : constant String := "settings_" & version & ".txt";
   271.       counts_are_set : Boolean := False;
   272.       settings_file  : File_Type;
   273.       flag           : Character;
   274.
   275.       procedure set_the_miscellany_flags is
   276.          option : Character;
   277.       begin
   278.          loop
   279.             get(settings_file, option);
   280.             if is_invalid_miscellany_flag(option) then
   281.                raise Data_Error;
   282.             else
   283.                set_this_miscellany_flag(option);
   284.             end if;
   285.          exit when End_Of_Line(settings_file);
   286.          end loop;
   287.       exception
   288.          when error : others =>
   289.             if not End_Of_Line(settings_file) then
   290.                Skip_Line(settings_file);
   291.             end if;
   292.             log_new_line;
   293.             log_line(
   294.                      "***** Error in a miscellany specification: '"
   295.                    & option
   296.                    & "' at "
   297.                    & Exception_Message(error)
   298.                     );
   299.       end set_the_miscellany_flags;
   300.
   301.       procedure set_breakpoints is
   302.          start, end_point : KDF9.order_word_number;
   303.       begin
   304.          begin
   305.             get_word(settings_file, KDF9.word(start));
   306.          exception
   307.             when others =>
   308.                log_new_line;
   309.                log_line("***** Error in lower address; no breakpoint set.");
   310.                return;
   311.          end;
   312.
   313.          log_new_line;
   314.          log_line(
   315.                   "Lower breakpoint: "
   316.                 & oct_of(KDF9.syllable_address'(start, 0))
   317.                 & " ("
   318.                 & dec_of(KDF9.syllable_address'(start, 0))
   319.                 & ")",
   320.                   iff => the_log_is_wanted
   321.                  );
   322.          breakpoints(start) := True;
   323.
   324.          begin
   325.             get_word(settings_file, KDF9.word(end_point));
   326.          exception
   327.             when Data_Error =>
   328.                log_line("      No upper address: one breakpoint set.", iff => the_log_is_wanted);
   329.                set_breakpoints(start, start);
   330.                return;
   331.          end;
   332.          log_line(
   333.                   "Upper breakpoint: "
   334.                 & oct_of(KDF9.syllable_address'(end_point, 5))
   335.                 & " (" & dec_of(KDF9.syllable_address'(end_point, 5))
   336.                 & ")",
   337.                   iff => the_log_is_wanted
   338.                  );
   339.          set_breakpoints(start, end_point);
   340.       exception
   341.          when others =>
   342.             log_line("***** Error setting breakpoints; ignored.");
   343.       end set_breakpoints;
   344.
   345.       procedure set_store_points is
   346.          start, end_point : KDF9.address;
   347.       begin
   348.          begin
   349.             get_word(settings_file, KDF9.word(start));
   350.          exception
   351.             when others =>
   352.                log_new_line;
   353.                log_line("***** Error in lower address; no storepoint set.");
   354.                return;
   355.          end;
   356.          log_new_line;
   357.          log_line(
   358.                   "Lower storepoint: #"
   359.                 & oct_of(start)
   360.                 & " ("
   361.                 & dec_of(start)
   362.                 & ")",
   363.                   iff => the_log_is_wanted
   364.                  );
   365.          begin
   366.             get_word(settings_file, KDF9.word(end_point));
   367.          exception
   368.             when Data_Error =>
   369.                log_line("      No upper address: one storepoint set.", iff => the_log_is_wanted);
   370.                set_store_points(start, start);
   371.                return;
   372.          end;
   373.          log_line(
   374.                   "Upper storepoint: #"
   375.                 & oct_of(end_point)
   376.                 & " ("
   377.                 & dec_of(end_point)
   378.                 & ")",
   379.                   iff => the_log_is_wanted
   380.                  );
   381.          set_store_points(start, end_point);
   382.       exception
   383.          when others =>
   384.             log_line("***** Error setting storepoints; ignored.");
   385.       end set_store_points;
   386.
   387.       procedure set_watchpoints is
   388.          start, end_point : KDF9.address;
   389.       begin
   390.          begin
   391.             get_word(settings_file, KDF9.word(start));
   392.          exception
   393.             when others =>
   394.                log_new_line;
   395.                log_line("***** Error in lower address; no watchpoint set.");
   396.                return;
   397.          end;
   398.          log_new_line;
   399.          log_line(
   400.                   "Lower watchpoint: #"
   401.                 & oct_of(start)
   402.                 & " ("
   403.                 & dec_of(start)
   404.                 & ")",
   405.                   iff => the_log_is_wanted
   406.                  );
   407.          begin
   408.             get_word(settings_file, KDF9.word(end_point));
   409.          exception
   410.             when Data_Error =>
   411.                log_line("      No upper address: one watchpoint set.", iff => the_log_is_wanted);
   412.                set_store_points(start, start);
   413.                set_fetch_points(start, start);
   414.                return;
   415.          end;
   416.          log_line("Upper watchpoint: #" & oct_of(end_point) & " (" & dec_of(end_point) & ")",
   417.                   iff => the_log_is_wanted);
   418.          set_fetch_points(start, end_point);
   419.          set_store_points(start, end_point);
   420.       exception
   421.          when others =>
   422.             log_line("***** Error setting watchpoints; ignored.");
   423.       end set_watchpoints;
   424.
   425.       procedure set_specified_dumping_ranges (epoch : in dumping.flag) is
   426.          use dumping.flag_support;
   427.          epoch_flag   : constant Character := (if epoch = initial_flag then 'I' else 'F');
   428.          format       : dumping.format_set := no_dumping_flags or epoch;
   429.          first_address,
   430.          last_address : KDF9.address := 0;
   431.          bad_range    : Boolean := False;
   432.          data         : KDF9.word;
   433.          c            : Character;
   434.          OK           : Boolean;
   435.       begin
   436.          log("Dump: format " & epoch_flag, iff => the_log_is_wanted);
   437.          while not End_Of_Line(settings_file) loop
   438.             get(settings_file, c);
   439.             log(c, iff => the_log_is_wanted);
   440.          exit when c = ' ';
   441.             if is_parameter_flag/dumping_flag(to_upper(c)) then
   442.                format := format or dumping_flag(to_upper(c));
   443.             else
   444.                if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   445.                log_new_line;
   446.                log_line("***** Error: '" & c & "' is not a valid dump type.");
   447.                return;
   448.             end if;
   449.          end loop;
   450.          log_new_line;
   451.          if (format and is_parameter_flag) /= no_dumping_flags then
   452.             get_word(settings_file, data);
   453.             if data > max_address                     or else
   454.                   (format/Usercode_flag and data > 8191) then
   455.                log_line(
   456.                         "***** Error: Lower dump address  = #"
   457.                       & oct_of(data)
   458.                       & " =" & data'Image
   459.                       & " is too large for this option."
   460.                        );
   461.                bad_range := True;
   462.             else
   463.                first_address := KDF9.address(data);
   464.                last_address  := KDF9.address(data);
   465.                log_line(
   466.                         "      Lower dump address: #"
   467.                       & oct_of(first_address)
   468.                       & " (" & dec_of(first_address)
   469.                       & ")",
   470.                         iff => the_log_is_wanted
   471.                        );
   472.             end if;
   473.
   474.            skip_to_next_non_blank (settings_file);
   475.
   476.             if not end_of_line(settings_file) then
   477.                get_word(settings_file, data);
   478.                if data > max_address                     or else
   479.                   (format/Usercode_flag and data > 8191) then
   480.                   log_line(
   481.                            "***** Error: Upper dump address: #"
   482.                          & oct_of(data)
   483.                          & " =" & data'Image
   484.                          & " is too large for this option."
   485.                           );
   486.                   bad_range := True;
   487.                else
   488.                   last_address := KDF9.address(data);
   489.                   log_line(
   490.                            "      Upper dump address: #"
   491.                          & oct_of(last_address)
   492.                          & " ("
   493.                          & dec_of(last_address)
   494.                          & ")",
   495.                            iff => the_log_is_wanted
   496.                           );
   497.                end if;
   498.             end if;
   499.
   500.             if first_address > last_address then
   501.                log_line(
   502.                         "***** Error: Upper dump address: #"
   503.                       & oct_of(last_address)
   504.                       & " =" & last_address'Image
   505.                       & " is less than lower dump address: #"
   506.                       & oct_of(first_address)
   507.                       & " =" & first_address'Image
   508.                       & "."
   509.                        );
   510.                bad_range := True;
   511.             end if;
   512.
   513.             if format/Usercode_flag then
   514.               if not end_of_line(settings_file) then
   515.                   get_word(settings_file, data);
   516.                   if data > 8190 then
   517.                      log_line(
   518.                               "***** Error: Scan start address: #"
   519.                             & oct_of(data)
   520.                             & " ="
   521.                             & data'Image
   522.                             & " > 8190, ignored."
   523.                              );
   524.                   else
   525.                      nominated_address := KDF9.order_word_number(data);
   526.                      log_line(
   527.                               "      Scan start address: #"
   528.                             & oct_of(nominated_address)
   529.                             & " ("
   530.                             & dec_of(nominated_address)
   531.                             & ")",
   532.                               iff => the_log_is_wanted
   533.                              );
   534.                   end if;
   535.                end if;
   536.             end if;
   537.
   538.          end if;
   539.
   540.          if not bad_range then
   541.             request_a_dumping_area(format, first_address, last_address, OK);
   542.             if not OK then
   543.                log_line("***** Error: Too many dump specifications (ignored).");
   544.             end if;
   545.          end if;
   546.
   547.          if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   548.       exception
   549.          when others =>
   550.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   551.             log_new_line;
   552.             log_line("***** Error in a dump area specification (ignored)." );
   553.       end set_specified_dumping_ranges;
   554.
   555.       procedure set_initial_dumping_ranges is
   556.       begin
   557.          set_specified_dumping_ranges(initial_flag);
   558.       end set_initial_dumping_ranges;
   559.
   560.       procedure set_final_dumping_ranges is
   561.       begin
   562.          set_specified_dumping_ranges(final_flag);
   563.       end set_final_dumping_ranges;
   564.
   565.       procedure set_histogram_options is
   566.          c : Character;
   567.       begin
   568.          while not End_Of_Line(settings_file) loop
   569.             get(settings_file, c);
   570.          exit when c = ' ';
   571.             if c not in 'P' | 'p' | 'T' | 't' then
   572.                raise Data_Error;
   573.             end if;
   574.             if c in 'P' | 'p' then
   575.                the_profile_is_wanted  := True;
   576.                clear_the_profile;
   577.             elsif c in  'T' | 't' then
   578.                the_INS_plot_is_wanted := True;
   579.                clear_the_histogram;
   580.             end if;
   581.          end loop;
   582.          ensure_not_at_end_of_line(settings_file);
   583.          get(settings_file, histogram_cutoff);
   584.          if histogram_cutoff >= 100.0 or histogram_cutoff < 0.0 then
   585.             raise Data_Error;
   586.          end if;
   587.          get(settings_file, c);
   588.          if c /= '%' then
   589.             raise Data_Error;
   590.          end if;
   591.       exception
   592.          when others =>
   593.             histogram_cutoff := cutoff_default;
   594.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   595.             log_new_line;
   596.             log_line("***** Error in the histogram option; default used.");
   597.       end set_histogram_options;
   598.
   599.       procedure set_time_limit is
   600.          begin
   601.             begin
   602.             get_decimal(settings_file, KDF9.word(time_limit));
   603.          exception
   604.             when others =>
   605.                if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   606.                time_limit := offline_time_limit;
   607.          end;
   608.
   609.          if not counts_are_set then
   610.             high_count := time_limit;
   611.          end if;
   612.
   613.          log_new_line;
   614.          log_line("Time limit (in instructions) =" & time_limit'Image,
   615.                   iff => the_log_is_wanted);
   616.       end set_time_limit;
   617.
   618.       procedure set_tracing_counts is
   619.
   620.          procedure show_counts is
   621.          begin
   622.             if not the_log_is_wanted then return; end if;
   623.             log_new_line;
   624.             log_line("Lower tracing count:" & low_count'Image);
   625.             log_line("Upper tracing count:" & high_count'Image);
   626.          end show_counts;
   627.
   628.       begin
   629.          get_decimal(settings_file, KDF9.word(low_count));
   630.          get_decimal(settings_file, KDF9.word(high_count));
   631.          show_counts;
   632.          if low_count > high_count then
   633.             log_new_line;
   634.             log_line("***** Error: Low count > high count.");
   635.             raise Data_Error;
   636.          end if;
   637.          counts_are_set := True;
   638.       exception
   639.          when others =>
   640.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   641.             low_count  := low_count_default;
   642.             high_count := high_count_default;
   643.             log_new_line;
   644.             log_line("***** Error in a tracing count; defaults used.");
   645.             show_counts;
   646.       end set_tracing_counts;
   647.
   648.       procedure set_tracing_range is
   649.
   650.          procedure show_range is
   651.          begin
   652.             if not the_log_is_wanted then return; end if;
   653.             log_new_line;
   654.             log_line(
   655.                      "Lower trace address: #"
   656.                    & oct_of(KDF9.syllable_address'(low_bound, 0))
   657.                    & " ("
   658.                    & dec_of(KDF9.syllable_address'(low_bound, 0))
   659.                    & ")"
   660.                     );
   661.             log_line(
   662.                      "Upper trace address: #"
   663.                    & oct_of(KDF9.syllable_address'(high_bound, 5))
   664.                    & " ("
   665.                    & dec_of(KDF9.syllable_address'(high_bound, 5))
   666.                    & ")"
   667.                     );
   668.          end show_range;
   669.
   670.       begin
   671.          get_word(settings_file, KDF9.word(low_bound));
   672.          get_word(settings_file, KDF9.word(high_bound));
   673.          if low_bound > high_bound then
   674.             log_new_line;
   675.             log_line("***** Error: Low bound > high bound.");
   676.             raise Data_Error;
   677.          end if;
   678.          show_range;
   679.       exception
   680.          when others =>
   681.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   682.             low_bound  := low_bound_default;
   683.             high_bound := high_bound_default;
   684.             log_new_line;
   685.             log_line("***** Error in a tracing address; defaults used.");
   686.             show_range;
   687.       end set_tracing_range;
   688.
   689.       procedure set_diagnostic_mode is
   690.          use diagnostic_mode_IO;
   691.          the_diagnostic_mode : settings.diagnostic_mode;
   692.       begin
   693.          ensure_not_at_end_of_line(settings_file);
   694.          get(settings_file, the_diagnostic_mode);
   695.          set_diagnostic_mode(the_diagnostic_mode);
   696.       exception
   697.          when others =>
   698.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   699.             set_diagnostic_mode(the_diagnostics_default);
   700.             log_new_line;
   701.             log_line("***** Error in the diagnostic mode; default used.");
   702.       end set_diagnostic_mode;
   703.
   704.       procedure set_execution_mode is
   705.          use execution_mode_IO;
   706.       begin
   707.          ensure_not_at_end_of_line(settings_file);
   708.          get(settings_file, the_execution_mode);
   709.       exception
   710.          when others =>
   711.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   712.             the_execution_mode := the_execution_default;
   713.             log_new_line;
   714.             log_line("***** Error in the testing mode; default used.");
   715.       end set_execution_mode;
   716.
   717.       procedure set_authenticity is
   718.          use authenticity_mode_IO;
   719.       begin
   720.          ensure_not_at_end_of_line(settings_file);
   721.          get(settings_file, the_authenticity_mode);
   722.          if the_authenticity_mode = authentic_time_mode then
   723.             authentic_timing_is_enabled := True;
   724.          end if;
   725.       exception
   726.          when others =>
   727.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   728.             the_authenticity_mode := the_authenticity_default;
   729.             log_new_line;
   730.             log_line("***** Error in the authenticity mode; default used.");
   731.       end set_authenticity;
   732.
   733.       procedure set_graph_plotting_pen is
   734.          use postscript;
   735.          use colour_IO;
   736.          use  width_IO;
   737.          the_colour   : pen_colour   := the_default_colour;
   738.          the_pen_size : pen_tip_size := the_default_tip_size;
   739.
   740.          procedure show_pen_options is
   741.          begin
   742.             if not the_log_is_wanted then return; end if;
   743.             log_new_line;
   744.             if the_colour /= the_default_colour then
   745.                log_line("The graph plotter pen colour is " & the_colour'Image & ".");
   746.             end if;
   747.             if the_pen_size /= the_default_tip_size then
   748.                log_line("The graph plotter pen tip is " & the_pen_size'Image & ".");
   749.             end if;
   750.          end show_pen_options;
   751.
   752.          procedure configure_the_plotter is
   753.          begin
   754.             if the_colour /= the_default_colour or the_pen_size /= the_default_tip_size then
   755.                set_the_pen_properties(the_colour, the_pen_size);
   756.                show_pen_options;
   757.             end if;
   758.          end configure_the_plotter;
   759.
   760.       begin  -- set_graph_plotting_pen
   761.          ensure_not_at_end_of_line(settings_file);
   762.          begin
   763.             Get(settings_file, the_colour);
   764.          exception
   765.             when others =>
   766.                log_new_line;
   767.                log_line("***** Error in the plotter pen the_colour; default used.");
   768.          end;
   769.          ensure_not_at_end_of_line(settings_file);
   770.          begin
   771.             Get(settings_file, the_pen_size);
   772.          exception
   773.             when others =>
   774.                log_new_line;
   775.                log_line("***** Error in the plotter pen tip; default used.");
   776.          end;
   777.          configure_the_plotter;
   778.       exception
   779.          when Data_Error =>
   780.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   781.             configure_the_plotter;
   782.       end set_graph_plotting_pen;
   783.
   784.       procedure set_non_interactivity is
   785.       begin
   786.          noninteractive_usage_is_enabled := True;
   787.          set_time_limit;
   788.       end set_non_interactivity;
   789.
   790.       procedure save_poke_value is
   791.          -- W: full Word, U: Upper halfword, L: Lower halfword, S: Syllable, C: Character
   792.          address  : KDF9.address;
   793.          sub_word : Character;
   794.          position : KDF9.address;
   795.          value    : KDF9.word;
   796.          OK       : Boolean;
   797.       begin
   798.          begin
   799.             get_word(settings_file, KDF9.word(address));
   800.          exception
   801.             when others =>
   802.                log_line("***** Error in poke word address.");
   803.                Skip_Line(settings_file);
   804.                return;
   805.          end;
   806.
   807.          get_char(settings_file, sub_word);
   808.          if sub_word not in 'S' | 's' | 'C' | 'c' | 'L' | 'l' | 'U' | 'u' | 'W' | 'w' then
   809.             log_line(
   810.                      "***** Error in (sub)word indicator; "
   811.                    & sub_word
   812.                    & " should be W, L, U, S, or C."
   813.                     );
   814.             Skip_Line(settings_file);
   815.             return;
   816.          end if;
   817.
   818.          if sub_word in 'S' | 's' | 'C' | 'c' then
   819.             begin
   820.                get_word(settings_file, KDF9.word(position));
   821.                if (sub_word in 'S' | 's' and position > 5) or else
   822.                   (sub_word in 'C' | 'c' and position > 7)    then
   823.                   log_line(
   824.                            "***** Error in position given for a "
   825.                          & (if sub_word in 'S' | 's' then "syllable:" else "character:")
   826.                          & position'Image
   827.                          & " is too large, poke request ignored."
   828.                           );
   829.                   Skip_Line(settings_file);
   830.                   return;
   831.                end if;
   832.             exception
   833.                when others =>
   834.                   log_line(
   835.                            "***** Error in position given for a "
   836.                          & (if sub_word in 'S' | 's' then "syllable" else "character")
   837.                          & ", poke request ignored."
   838.                           );
   839.                   Skip_Line(settings_file);
   840.                   return;
   841.             end;
   842.          else
   843.             position := 0;
   844.          end if;
   845.
   846.          begin
   847.             get_word(settings_file, value);
   848.          exception
   849.             when others =>
   850.                log_line("***** Error in poked value.");
   851.                Skip_Line(settings_file);
   852.                return;
   853.          end;
   854.
   855.          if (sub_word in 'L' | 'l' | 'U' | 'u' and value > 2**24-1) or else
   856.                (sub_word in 'S' | 's'          and value > 255)     or else
   857.                   (sub_word in 'C' | 'c'       and value > 63)      then
   858.             log_line(
   859.                      "***** Error in poked value #"
   860.                    & oct_of(value)
   861.                    & ": out of range for a "
   862.                    & (case sub_word is
   863.                          when 'L' | 'l' | 'U' | 'u' => "halfword",
   864.                          when 'S' | 's'             => "syllable",
   865.                          when 'C' | 'c'             => "character",
   866.                          when others                => "word")
   867.                    & ", poke request ignored."
   868.                     );
   869.             Skip_Line(settings_file);
   870.             return;
   871.          end if;
   872.
   873.          add_to_poke_list(address, sub_word, position, value, OK);
   874.
   875.          if not OK then
   876.             log_line("***** Error setting up a poke: poke list full; request ignored.");
   877.          end if;
   878.
   879.       exception
   880.
   881.          when others =>
   882.             null;  -- to skip line at end of input loop
   883.
   884.       end save_poke_value;
   885.
   886.       procedure set_KDF9_configuration is
   887.          use equipment_IO;
   888.          use IOC.equipment;
   889.          d : IOC.equipment.kind := AD;
   890.          b : KDF9.buffer_number;
   891.       begin
   892.          if version = "1" then
   893.             for i in IOC.equipment.setup'Range loop
   894.             exit when end_of_line(settings_file);
   895.                get_word(settings_file, KDF9.word(b));
   896.                ensure_not_at_end_of_line(settings_file);
   897.                get(settings_file, d);
   898.                IOC.equipment.choice(b) := d;
   899.             end loop;
   900.          else
   901.             log_new_line;
   902.             log_line("The previous KDF9 configuration is still being used.");
   903.          end if;
   904.          if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   905.       exception
   906.          when others =>
   907.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   908.             IOC.equipment.choice := IOC.equipment.default;
   909.             log_new_line;
   910.             log_line("***** Error in the device configuration; defaults used.");
   911.       end set_KDF9_configuration;
   912.
   913.    begin -- get_settings_from_file
   914.
   915.       do_not_execute := False;
   916.       high_count := time_limit;
   917.       open_options_file(settings_file, the_settings_file_name);
   918.       if End_of_File(settings_file) then
   919.          raise End_Error;
   920.       end if;
   921.
   922.       loop
   923.          skip_to_next_nonempty_line(settings_file);
   924.          get(settings_file, flag);
   925.          case flag is
   926.             when 'A' | 'a' =>
   927.                set_authenticity;
   928.             when 'B' | 'b' =>
   929.                set_breakpoints;
   930.             when 'C' | 'c' =>
   931.                set_tracing_counts;
   932.             when 'D' | 'd' =>
   933.                set_diagnostic_mode;
   934.             when 'F' | 'f' =>
   935.                set_final_dumping_ranges;
   936.             when 'G' | 'g' =>
   937.                set_graph_plotting_pen;
   938.             when 'H' | 'h' =>
   939.                set_histogram_options;
   940.             when 'I' | 'i' =>
   941.                set_initial_dumping_ranges;
   942.             when 'K' | 'k' =>
   943.                set_KDF9_configuration;
   944.             when 'L' | 'l' =>
   945.                set_time_limit;
   946.             when 'N' | 'n' =>
   947.                set_non_interactivity;
   948.                time_limit := offline_time_limit;
   949.             when 'O' |'o' =>
   950.                set_this_miscellany_flag(flag);
   951.             when 'P' | 'p' =>
   952.                save_poke_value;
   953.             when 'Q' | 'q' =>
   954.                do_not_execute := True;
   955.                raise End_Error;
   956.             when 'R' | 'r' =>
   957.                set_tracing_range;
   958.             when 'S' | 's' =>
   959.                set_store_points;
   960.             when 'T' | 't' =>
   961.                set_execution_mode;
   962.             when 'V' | 'v' =>
   963.                set_the_miscellany_flags;
   964.             when 'W' | 'w' =>
   965.                set_watchpoints;
   966.             when 'X' | 'x' =>
   967.                only_signature_tracing := True;
   968.             when '-' | '/' =>
   969.                Skip_Line(settings_file);
   970.             when others =>
   971.                log_new_line;
   972.                log_line(
   973.                         "Invalid flag: """
   974.                       & flag
   975.                       & """ at line/column "
   976.                       & line_number'Image
   977.                       & "/"
   978.                       & Ada.Text_IO.Count'Image(Col(settings_file))
   979.                       & " of the settings file!"
   980.                        );
   981.                log_line(" ...  the valid flags are A,B,C,D,F,G,I,K,L,N,O,P,Q,R,S,T,V,W,X, -, and /");
   982.                Skip_Line(settings_file);
   983.          end case;
   984.       end loop;
   985.
   986.    exception
   987.
   988.       when Status_Error =>
   989.          log_line("***** Error: " & the_settings_file_name & " was not found; defaults used.");
   990.          log_new_line;
   991.
   992.       when End_Error =>
   993.          close_options_file(settings_file, the_settings_file_name);
   994.
   995.       when Data_Error =>
   996.          close_options_file(settings_file, the_settings_file_name);
   997.          log_new_line;
   998.          log_line("***** Error: invalid data in the settings file.");
   999.          log_line(
  1000.                   "Reading of settings abandoned at line "
  1001.                 & line_number'Image
  1002.                 & " of "
  1003.                 & the_settings_file_name
  1004.                 & "."
  1005.                  );
  1006.
  1007.       when quit_request =>
  1008.          close_options_file(settings_file, the_settings_file_name);
  1009.          log_new_line;
  1010.          log_line(
  1011.                   "Quit requested at line "
  1012.                 & line_number'Image
  1013.                 & " of "
  1014.                 & the_settings_file_name
  1015.                 & "."
  1016.                  );
  1017.          log_rule;
  1018.          raise;
  1019.
  1020.       when error : others =>
  1021.          close_options_file(settings_file, the_settings_file_name);
  1022.          log_new_line;
  1023.          log_line(
  1024.                   "Failure in ee9; unexpected exception: "
  1025.                 & Exception_Information(error)
  1026.                 & " in get_settings_from_file!"
  1027.                  );
  1028.          log_line(
  1029.                   "Reading of settings abandoned at line "
  1030.                 & line_number'Image
  1031.                 & " of "
  1032.                 & the_settings_file_name
  1033.                 & "!"
  1034.                  );
  1035.          log_rule;
  1036.          raise;
  1037.
  1038.    end get_settings_from_file;
  1039.
  1040. end settings;

Compiling: ../Source/settings.ads
Source file time stamp: 2021-02-21 00:19:08
Compiled at: 2021-02-21 15:54:05

     1. -- execution mode, diagnostic mode, and other emulation-control settings
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18. with logging.file;
    19.
    20. use  KDF9;
    21. use  logging.file;
    22.
    23. package settings is
    24.
    25. --
    26.    -- In fast mode: code runs as efficiently as possible, without diagnostics.
    27.
    28.    -- In trace mode: breakpoints, watchpoints, tracing address bounds and
    29.    --    tracing instruction count bounds are all honoured;
    30.    --       entries may be made in all the retrospective trace logs;
    31.    --          a digital execution signature may be computed,
    32.    --             and an instruction-frequency histogram may be generated.
    33.
    34.    -- In pause mode: execution proceeds as in trace mode;
    35.    --    additionally, breakpoints occur on every order executed within trace bounds.
    36.
    37.    -- The external mode is a user-interface value only. It requests the trace mode,
    38.    --    combined with the logging of a running trace to an external file.
    39. --
    40.
    41.    type diagnostic_mode is (fast_mode,
    42.                             trace_mode,
    43.                             pause_mode,
    44.                             external_mode);
    45.
    46.    procedure set_diagnostic_mode (a_diagnostic_mode : in settings.diagnostic_mode);
    47.
    48.    procedure change_diagnostic_mode_if_requested;
    49.
    50.    the_diagnostics_default  : constant settings.diagnostic_mode := fast_mode;
    51.    the_diagnostic_mode      : settings.diagnostic_mode := the_diagnostics_default;
    52.
    53.    the_external_trace_file_name : constant String := "trace.txt";
    54.    only_signature_tracing       : Boolean := False;
    55.    the_external_trace_file      : logging.file.output;
    56.
    57.    -- The diagnostic generation and display controls, inter alia.
    58.    -- The *_trace_is_wanted flags are set to True iff
    59.    --    they are both requested, and offered by the_diagnostic_mode.
    60.    -- These requests may be set by the miscellany and visibilty options.
    61.
    62.    miscellany_flags  : constant String := "abdefghikmnopqrstwxz.0123456789ABDEFGHIKMNOPQRSTWXZ";
    63.    miscellany_prompt : constant String := "{a|b|d|e|f|g|h|i|k|m|n|o|p|q|r|s|t|w|x|z|.|0..9}";
    64.
    65.    the_log_is_wanted,
    66.    API_logging_is_wanted,
    67.    the_signature_is_wanted,
    68.    any_histogram_is_wanted,
    69.    the_final_state_is_wanted,
    70.    interrupt_tracing_is_wanted,
    71.    peripheral_tracing_is_wanted,
    72.    flexowriter_output_is_wanted,
    73.    realistic_FW_output_is_wanted,
    74.    the_terminal_is_ANSI_compatible,
    75.    retrospective_tracing_is_wanted    : Boolean := True;
    76.
    77.    do_not_execute,
    78.    debugging_is_enabled,
    79.    the_signature_is_enabled,
    80.    the_histogram_is_enabled,
    81.    pre_overlay_state_is_enabled,
    82.    the_external_trace_is_enabled,
    83.    the_interrupt_trace_is_enabled,
    84.    noninteractive_usage_is_enabled,
    85.    the_peripheral_trace_is_enabled,
    86.    the_retrospective_trace_is_enabled : Boolean := False;
    87.
    88.    -- This option may also be set by an authenticity option (see KDF9).
    89.    authentic_timing_is_enabled : Boolean := False;
    90.
    91.    -- In boot_mode: a Director program is read from TR0 and executed
    92.    --    in Director state, with full use of the emulated hardware.
    93.    -- In program_mode: a user program is read from TR0 and executed
    94.    --    in program state, with basic OUTs implemented by the emulator.
    95.    -- In test_program_mode: a user program is read from TR0 and executed
    96.    --    in Director state, with basic OUTs implemented by the emulator,
    97.    --    this being useful for executing "hardware test" programs.
    98.
    99.    type execution_mode is (boot_mode, program_mode, test_program_mode);
   100.
   101.    procedure set_execution_mode (an_execution_mode : in settings.execution_mode);
   102.
   103.    the_execution_default : constant settings.execution_mode := program_mode;
   104.    the_execution_mode    :          settings.execution_mode := the_execution_default;
   105.
   106.    --
   107.    -- Tracing bound settings.
   108.    --
   109.
   110.    -- time_limit bounds the number of KDF9 instructions executed.
   111.
   112.    time_limit_default : constant KDF9.order_counter := KDF9.order_counter'Last;
   113.    time_slice         : constant KDF9.order_counter := 10_000;
   114.    offline_time_limit : constant KDF9.order_counter := 10_000 * time_slice;
   115.    time_limit         :          KDF9.order_counter := time_limit_default;
   116.
   117.
   118.    -- low_bound and high_bound bound the static scope of tracing.
   119.
   120.    low_bound_default  : constant KDF9.order_word_number := 0;
   121.    high_bound_default : constant KDF9.order_word_number := KDF9.order_word_number'Last;
   122.    low_bound          :          KDF9.order_word_number := low_bound_default;
   123.    high_bound         :          KDF9.order_word_number := high_bound_default;
   124.
   125.    -- nominated_address sets a flow analysis starting point for Usercode format dumps.
   126.    invalid_address    :          KDF9.order_word_number := 8191;
   127.    nominated_address  :          KDF9.order_word_number := invalid_address;
   128.
   129.    -- low_count and high_count bound the dynamic scope of tracing.
   130.
   131.    low_count_default  : constant KDF9.order_counter := 0;
   132.    high_count_default : constant KDF9.order_counter := time_limit_default;
   133.    low_count          :          KDF9.order_counter := low_count_default;
   134.    high_count         :          KDF9.order_counter := high_count_default;
   135.
   136.    -- Histogram bin frequencies less than histogram_cutoff are not logged.
   137.    the_profile_is_wanted  :          Boolean := False;
   138.    the_INS_plot_is_wanted :          Boolean := False;
   139.    cutoff_default         : constant Long_Float := 0.0;
   140.    histogram_cutoff       :          Long_Float := cutoff_default;
   141.
   142.    function is_invalid_miscellany_flag (option : in Character)
   143.    return Boolean;
   144.
   145.    procedure set_this_miscellany_flag (option : in Character);
   146.
   147.    -- do_not_execute is set if a quit is requested in the settings file.
   148.    -- The K option is not actioned unless version = "1".
   149.    procedure get_settings_from_file (version : in String);
   150.
   151.    procedure display_execution_modes (for_this_run : in String := "");
   152.
   153.    procedure quit_if_requested;
   154.
   155.    quit_was_requested          : Boolean := False;
   156.
   157.    the_diagnostic_mode_changed : Boolean := False;
   158.
   159.    loading_was_successful      : Boolean := False;
   160.
   161.    mode_change_request         : exception;
   162.
   163. end settings;

 1040 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/break_in.adb
Source file time stamp: 2021-02-20 23:33:33
Compiled at: 2021-02-21 15:54:05

     1. -- This communicates a break-in to the microcode.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with exceptions;
    18. with HCI;
    19. with KDF9;
    20. with POSIX;
    21. with finalize_ee9;
    22. with settings;
    23. with state_display;
    24.
    25. use  exceptions;
    26. use  HCI;
    27. use  KDF9;
    28. use  settings;
    29. use  state_display;
    30.
    31. package body break_in is
    32.
    33.    requested : Boolean := False
    34.       with Atomic, Volatile;
    35.
    36.    procedure note_user_interrupt is
    37.    begin
    38.       requested := True;
    39.    end note_user_interrupt;
    40.
    41.    function has_been_requested
    42.    return Boolean is
    43.    begin
    44.       return requested;
    45.    end has_been_requested;
    46.
    47.    procedure handler is
    48.    begin
    49.       requested := False;
    50.       interact("Break-in");
    51.       quit_if_requested;
    52.       if the_execution_mode = boot_mode then
    53.          effect_interrupt(caused_by_FLEX, "the operator interrupts");
    54.       else
    55.          show_current_state;
    56.       end if;
    57.       flush;
    58.    exception
    59.       when quit_request =>
    60.          finalize_ee9("Quit requested by the user");
    61.          POSIX.exit_program(0);
    62.    end handler;
    63.
    64. end break_in;

Compiling: ../Source/break_in.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:05

     1. -- This conveys a break-in to the microcode.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package break_in is
    18.
    19.    function has_been_requested
    20.    return Boolean
    21.       with Inline;
    22.
    23.    procedure note_user_interrupt;
    24.
    25.    procedure handler;
    26.
    27. end break_in;

 64 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/dumping.adb
Source file time stamp: 2021-02-21 00:14:12
Compiled at: 2021-02-21 15:54:05

     1. -- Provide support for diagnostic core-dumping area descriptions.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with formatting;
    18. with state_display;
    19.
    20. use  formatting;
    21. use  state_display;
    22.
    23. package body dumping is
    24.
    25.    type poke_list_entry is
    26.       record
    27.          address  : KDF9.address;
    28.          sub_word : sub_word_flag;
    29.          position : KDF9.address;
    30.          value    : KDF9.word;
    31.       end record;
    32.
    33.    length_of_poke_list : constant := 100;
    34.    poke_list_count     : Natural range 0 .. length_of_poke_list := 0;
    35.    poke_list           : array (Positive range 1 .. length_of_poke_list) of poke_list_entry;
    36.
    37.    use dumping.flag_support;
    38.
    39.    function dumping_flag (c : Character)
    40.    return dumping.flag
    41.    is (dumping.flag(to_upper(c)));
    42.
    43.    type area is
    44.       record
    45.          format_set  : dumping.format_set := no_dumping_flags;
    46.          first, last : KDF9.address;
    47.       end record;
    48.
    49.    no_dumping_area : constant dumping.area := (no_dumping_flags, 0, 0);
    50.
    51.    dumping_areas : array (dumping.area_number) of dumping.area := (others => no_dumping_area);
    52.
    53.    pre_dumping_area_count  : area_count := 0;
    54.    post_dumping_area_count : area_count := 0;
    55.
    56.    function nr_of_pre_dumping_areas
    57.    return dumping.area_count
    58.    is (pre_dumping_area_count);
    59.
    60.    function nr_of_post_dumping_areas
    61.    return dumping.area_count
    62.    is (post_dumping_area_count);
    63.
    64.    procedure request_a_dumping_area (format_set  : in dumping.format_set;
    65.                                      first, last : in KDF9.address;
    66.                                      was_stored  : out Boolean) is
    67.    begin
    68.       was_stored := False;
    69.       if pre_dumping_area_count+post_dumping_area_count = nr_of_dumping_areas then
    70.          return;
    71.       end if;
    72.       for d of dumping_areas loop
    73.          if d = (format_set, first, last) then
    74.             was_stored := True;
    75.             return;
    76.          end if;
    77.       end loop;
    78.       for d of dumping_areas loop
    79.          if d.format_set = no_dumping_flags then
    80.             d := (format_set, first, last);
    81.             was_stored := True;
    82.             if format_set/initial_flag then
    83.                pre_dumping_area_count := pre_dumping_area_count + 1;
    84.             end if;
    85.             if format_set/final_flag then
    86.                post_dumping_area_count := post_dumping_area_count + 1;
    87.             end if;
    88.             return;
    89.          end if;
    90.       end loop;
    91.    end request_a_dumping_area;
    92.
    93.    procedure print_formatted_area (d : in dumping.area) is
    94.       format_set  : constant dumping.format_set := d.format_set;
    95.       first       : constant KDF9.address := d.first;
    96.       last        : constant KDF9.address := d.last;
    97.    begin
    98.       if format_set/tape_code_flag then
    99.          show_core_in_tape_code(first, last);
   100.       end if;
   101.       if format_set/normal_flag then
   102.          show_core_in_case_normal(first, last);
   103.       end if;
   104.       if format_set/shift_flag then
   105.          show_core_in_case_shift(first, last);
   106.       end if;
   107.       if format_set/ card_code_flag then
   108.          show_core_in_card_code(first, last);
   109.       end if;
   110.       if format_set/printer_flag then
   111.          show_core_in_print_code(first, last);
   112.       end if;
   113.       if format_set/ASCII_flag then
   114.          show_core_in_Latin_1(first, last);
   115.       end if;
   116.       if format_set/word_flag then
   117.          show_core_as_word_forms(first, last);
   118.       end if;
   119.       if format_set/Usercode_flag then
   120.          show_core_as_Usercode((KDF9.order_word_number(first), 0),
   121.                                (KDF9.order_word_number(last), 0),
   122.                                 octal_option => not format_set/decimal_flag);
   123.       end if;
   124.       if format_set/orders_flag then
   125.          show_core_as_syllables((KDF9.order_word_number(first), 0),
   126.                                 (KDF9.order_word_number( last), 0));
   127.       end if;
   128.    end print_formatted_area;
   129.
   130.    procedure print_dump_areas (flag : in dumping.flag; count : in dumping.area_count) is
   131.       Usercode_wanted : Boolean := False;
   132.    begin
   133.       if count = 0 then
   134.          return;
   135.       end if;
   136.       for d of dumping_areas loop
   137.          Usercode_wanted := Usercode_wanted or d.format_set/Usercode_flag;
   138.       end loop;
   139.       if Usercode_wanted then
   140.          mark_all_code_blocks_and_data_blocks;
   141.       end if;
   142.       for d of dumping_areas loop
   143.          if d.format_set/flag then
   144.             print_formatted_area(d);
   145.          end if;
   146.       end loop;
   147.    end print_dump_areas;
   148.
   149.    procedure print_prerun_dump_areas is
   150.    begin
   151.       print_dump_areas(initial_flag, pre_dumping_area_count);
   152.    end print_prerun_dump_areas;
   153.
   154.    procedure print_postrun_dump_areas is
   155.    begin
   156.       print_dump_areas(final_flag, post_dumping_area_count);
   157.    end print_postrun_dump_areas;
   158.
   159.    procedure remove_dump_areas (flag : in dumping.flag; count : in out dumping.area_count) is
   160.    begin
   161.       if count = 0 then
   162.          return;
   163.       end if;
   164.       for d of dumping_areas loop
   165.          if d.format_set/flag then
   166.             d := no_dumping_area;
   167.          end if;
   168.       end loop;
   169.       count := 0;
   170.    end remove_dump_areas;
   171.
   172.    procedure remove_prerun_dump_areas is
   173.    begin
   174.       remove_dump_areas(initial_flag, pre_dumping_area_count);
   175.    end remove_prerun_dump_areas;
   176.
   177.    procedure remove_postrun_dump_areas is
   178.    begin
   179.       remove_dump_areas(final_flag, post_dumping_area_count);
   180.    end remove_postrun_dump_areas;
   181.
   182.    procedure add_to_poke_list (address    : in KDF9.address;
   183.                                sub_word   : in sub_word_flag;
   184.                                position   : in KDF9.address;
   185.                                value      : in KDF9.word;
   186.                                was_stored : out Boolean) is
   187.    begin
   188.       if poke_list_count < length_of_poke_list then
   189.          poke_list_count := poke_list_count + 1;
   190.          poke_list(poke_list_count) := (address, sub_word, position, value);
   191.          was_stored := True;
   192.       else
   193.          was_stored := False;
   194.       end if;
   195.    end add_to_poke_list;
   196.
   197.    procedure poke_all_amendments is
   198.    begin
   199.       for p in 1..poke_list_count loop
   200.          poke(poke_list(p).address, poke_list(p).sub_word, poke_list(p).position, poke_list(p).value);
   201.       end loop;
   202.       poke_list_count := 0;
   203.    end poke_all_amendments;
   204.
   205. end dumping;

Compiling: ../Source/dumping.ads
Source file time stamp: 2021-02-21 00:13:42
Compiled at: 2021-02-21 15:54:05

     1. -- Provide support for diagnostic core-dumping area descriptions.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with generic_sets;
    18. with KDF9;
    19.
    20. use  KDF9;
    21.
    22. package dumping is
    23.
    24.    type flag is new Character range '@' .. 'Z';
    25.
    26.    no_flag        : constant dumping.flag := '@';
    27.    ASCII_flag     : constant dumping.flag := 'A';
    28.    card_code_flag : constant dumping.flag := 'C';
    29.    decimal_flag   : constant dumping.flag := 'D';
    30.    single_flag    : constant dumping.flag := 'E';
    31.    final_flag     : constant dumping.flag := 'F';
    32.    half_flag      : constant dumping.flag := 'H';
    33.    initial_flag   : constant dumping.flag := 'I';
    34.    normal_flag    : constant dumping.flag := 'N';
    35.    orders_flag    : constant dumping.flag := 'O';
    36.    printer_flag   : constant dumping.flag := 'L';
    37.    shift_flag     : constant dumping.flag := 'S';
    38.    tape_code_flag : constant dumping.flag := 'T';
    39.    Usercode_flag  : constant dumping.flag := 'U';
    40.    word_flag      : constant dumping.flag := 'W';
    41.
    42.    function dumping_flag (c : Character)
    43.    return dumping.flag;
    44.
    45.    package flag_support is new generic_sets(member => dumping.flag);
    46.
    47.    subtype format_set is flag_support.set;
    48.    use type format_set;
    49.
    50.    is_parameter_flag : constant dumping.format_set
    51.                      := (  decimal_flag
    52.                          | single_flag
    53.                          | half_flag
    54.                          | ASCII_flag
    55.                          | orders_flag
    56.                          | printer_flag
    57.                          | tape_code_flag
    58.                          | Usercode_flag
    59.                          | card_code_flag
    60.                          | normal_flag
    61.                          | shift_flag
    62.                          | word_flag     => True,
    63.                            others        => False
    64.                         );
    65.
    66.
    67.    is_epoch_flag : constant dumping.format_set
    68.                  := (  initial_flag
    69.                      | final_flag => True,
    70.                        others     => False
    71.                     );
    72.
    73.    is_dumping_flag  : constant dumping.format_set
    74.                     := is_parameter_flag or is_epoch_flag;
    75.
    76.    no_dumping_flags : constant dumping.format_set
    77.                     := flag_support.empty_set;
    78.
    79.    nr_of_dumping_areas : constant := 100;
    80.    subtype area_count  is Natural  range 0 .. nr_of_dumping_areas;
    81.    subtype area_number is Positive range 1 .. nr_of_dumping_areas;
    82.
    83.    procedure request_a_dumping_area (format_set  : in dumping.format_set;
    84.                                      first, last : in KDF9.address;
    85.                                      was_stored  : out Boolean);
    86.
    87.    procedure print_prerun_dump_areas;
    88.
    89.    procedure remove_prerun_dump_areas;
    90.
    91.    procedure print_postrun_dump_areas;
    92.
    93.    procedure remove_postrun_dump_areas;
    94.
    95.    function nr_of_pre_dumping_areas
    96.    return dumping.area_count;
    97.
    98.    function nr_of_post_dumping_areas
    99.    return dumping.area_count;
   100.
   101.    no_specification : constant String := "";
   102.
   103.    subtype sub_word_flag is Character
   104.       with Static_Predicate =>
   105.          sub_word_flag in 'S' | 's' | 'C' | 'c' | 'L' | 'l' | 'U' | 'u' | 'W' | 'w';
   106.
   107.    -- poke support is in dumping because it is needed at the same time during initialization.
   108.    procedure add_to_poke_list (address    : in KDF9.address;
   109.                                sub_word   : in sub_word_flag;
   110.                                position   : in KDF9.address;
   111.                                value      : in KDF9.word;
   112.                                was_stored : out Boolean);
   113.
   114.    -- poke_all_amendments effects all stored pokes and then clears the poke list for reuse.
   115.    procedure poke_all_amendments;
   116.
   117. end dumping;

 205 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9.adb
Source file time stamp: 2021-02-21 13:17:23
Compiled at: 2021-02-21 15:54:05

     1. -- The machine-state manipulations used by the CPU microcode.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Unchecked_Conversion;
    18. --
    19. with exceptions;
    20. with KDF9.CPU;
    21. with KDF9.decoding;
    22. with KDF9.PHU_store;
    23. with KDF9.store;
    24. with settings;
    25. with tracing;
    26.
    27. use  exceptions;
    28. use  KDF9.CPU;
    29. use  KDF9.decoding;
    30. use  KDF9.PHU_store;
    31. use  KDF9.store;
    32. use  settings;
    33. use  tracing;
    34.
    35. package body KDF9 is
    36.
    37.    C_part_scale : constant := 2**32;
    38.    I_part_scale : constant := 2**16;
    39.
    40.    function as_Q (the_word : KDF9.word)
    41.    return KDF9.Q_register
    42.    is (
    43.        (C => KDF9.Q_part(KDF9.word'(the_word / C_part_scale)),
    44.         I => KDF9.Q_part(KDF9.word'(the_word / I_part_scale) and Q_part_mask),
    45.         M => KDF9.Q_part(the_word and Q_part_mask)
    46.        )
    47.       );
    48.
    49.    function as_word (the_Q : KDF9.Q_register)
    50.    return KDF9.word
    51.    is (KDF9.word(the_Q.C)*C_part_scale + KDF9.word(the_Q.I)*I_part_scale + KDF9.word(the_Q.M));
    52.
    53.    function sign_extended (Q : KDF9.Q_part)
    54.    return KDF9.word
    55.    is (unsign(CPU.signed(resign(Q))));
    56.
    57.    function as_word (the_link : KDF9.SJNS_link)
    58.    return KDF9.word is
    59.       function link_Q_part is new Ada.Unchecked_Conversion(KDF9.SJNS_link, KDF9.Q_part);
    60.    begin
    61.       return KDF9.word(link_Q_part(the_link));
    62.    end as_word;
    63.
    64.    function as_link (the_word : KDF9.word)
    65.    return KDF9.SJNS_link is
    66.       function Q_part_link is new Ada.Unchecked_Conversion(KDF9.Q_part, KDF9.SJNS_link);
    67.    begin
    68.       return Q_part_link(KDF9.Q_part(the_word and Q_part_mask));
    69.    end as_link;
    70.
    71.    procedure ensure_that_the_SJNS_is_not_empty is
    72.    begin
    73.       if the_SJNS_depth > 0             or else
    74.             the_CPU_state = Director_state then
    75.          return;
    76.       end if;
    77.       effect_interrupt(caused_by_NOUV, "empty SJNS");
    78.    end ensure_that_the_SJNS_is_not_empty;
    79.
    80.    procedure ensure_that_the_SJNS_is_not_full is
    81.    begin
    82.       if the_SJNS_depth < 16             or else
    83.             the_CPU_state = Director_state  then
    84.          return;
    85.       end if;
    86.       effect_interrupt(caused_by_NOUV, "full SJNS");
    87.    end ensure_that_the_SJNS_is_not_full;
    88.
    89.    procedure push (the_link : in KDF9.syllable_address) is
    90.    begin
    91.       the_SJNS(the_SJNS_depth) := KDF9.SJNS_link(the_link);
    92.       the_SJNS_depth := the_SJNS_depth + 1;
    93.    end push;
    94.
    95.    function pop
    96.    return KDF9.syllable_address is
    97.    begin
    98.       the_SJNS_depth := the_SJNS_depth - 1;
    99.       return KDF9.syllable_address(the_SJNS(the_SJNS_depth));
   100.    end pop;
   101.
   102.    function SJNS_top
   103.    return KDF9.SJNS_link
   104.    is (the_SJNS(the_SJNS_depth-1));
   105.
   106.    function operand_words_needed (need : KDF9.NEST_depth)
   107.    return String
   108.    is ("NEST lacks" & need'Image & " operand" & (if need > 1 then "s" else ""));
   109.
   110.    procedure ensure_that_the_NEST_holds (at_least : in KDF9.NEST_depth) is
   111.    begin
   112.       if the_NEST_depth >= at_least          or else
   113.             the_CPU_state = Director_state      then
   114.          return;
   115.       end if;
   116.       effect_interrupt(caused_by_NOUV, operand_words_needed(need => at_least-the_NEST_depth));
   117.    end ensure_that_the_NEST_holds;
   118.
   119.    procedure ensure_that_the_NEST_holds_an_operand is
   120.    begin
   121.       ensure_that_the_NEST_holds (at_least => 1);
   122.    end ensure_that_the_NEST_holds_an_operand;
   123.
   124.    procedure ensure_that_the_NEST_holds_2_operands is
   125.    begin
   126.       ensure_that_the_NEST_holds (at_least => 2);
   127.    end ensure_that_the_NEST_holds_2_operands;
   128.
   129.    function result_space_needed (need : KDF9.NEST_depth)
   130.    return String
   131.       with Inline => False;
   132.
   133.    function result_space_needed (need : KDF9.NEST_depth)
   134.    return String
   135.    is (if need = 1 then "full NEST" else "NEST too full for" & need'Image & " operands");
   136.
   137.    procedure ensure_that_the_NEST_has_room_for (at_least : in KDF9.NEST_depth) is
   138.    begin
   139.       if the_NEST_depth <= 16-at_least     or else
   140.             the_CPU_state = Director_state    then
   141.          return;
   142.       end if;
   143.       effect_interrupt(caused_by_NOUV, result_space_needed(need => at_least - (16-the_NEST_depth)));
   144.    end ensure_that_the_NEST_has_room_for;
   145.
   146.    procedure ensure_that_the_NEST_has_room_for_a_result is
   147.    begin
   148.       ensure_that_the_NEST_has_room_for (at_least => 1);
   149.    end ensure_that_the_NEST_has_room_for_a_result;
   150.
   151.    procedure ensure_that_the_NEST_has_room_for_2_results is
   152.    begin
   153.       ensure_that_the_NEST_has_room_for (at_least => 2);
   154.    end ensure_that_the_NEST_has_room_for_2_results;
   155.
   156.    procedure push (the_word : in KDF9.word) is
   157.    begin
   158.       the_NEST(the_NEST_depth) := the_word;
   159.       the_NEST_depth := the_NEST_depth + 1;
   160.    end push;
   161.
   162.    function pop
   163.    return KDF9.word is
   164.    begin
   165.       return result : constant KDF9.word := the_NEST(the_NEST_depth - 1) do
   166.          the_NEST(the_NEST_depth - 1) := 0;
   167.          the_NEST_depth := the_NEST_depth - 1;
   168.       end return;
   169.    end pop;
   170.
   171.    procedure pop is
   172.    begin
   173.       the_NEST(the_NEST_depth - 1) := 0;
   174.       the_NEST_depth := the_NEST_depth - 1;
   175.    end pop;
   176.
   177.    function read_top
   178.    return KDF9.word
   179.    is (the_NEST(the_NEST_depth-1));
   180.
   181.    procedure write_top (the_word : in KDF9.word) is
   182.    begin
   183.       the_NEST(the_NEST_depth-1) := the_word;
   184.    end write_top;
   185.
   186.    procedure push (the_pair : in KDF9.pair) is
   187.    begin
   188.       the_NEST(the_NEST_depth+0) := the_pair.lsw;
   189.       the_NEST(the_NEST_depth+1) := the_pair.msw;
   190.       the_NEST_depth := the_NEST_depth + 2;
   191.    end push;
   192.
   193.    function pop
   194.    return KDF9.pair is
   195.    begin
   196.       return result : constant KDF9.pair := (msw => the_NEST(the_NEST_depth-1),
   197.                                              lsw => the_NEST(the_NEST_depth-2)) do
   198.          the_NEST(the_NEST_depth-1) := 0;
   199.          the_NEST(the_NEST_depth-2) := 0;
   200.          the_NEST_depth := the_NEST_depth - 2;
   201.       end return;
   202.    end pop;
   203.
   204.    procedure pop_pair is
   205.    begin
   206.       the_NEST(the_NEST_depth-1) := 0;
   207.       the_NEST(the_NEST_depth-2) := 0;
   208.       the_NEST_depth := the_NEST_depth - 2;
   209.    end pop_pair;
   210.
   211.    function read_top
   212.    return KDF9.pair
   213.    is ((msw => the_NEST(the_NEST_depth-1), lsw => the_NEST(the_NEST_depth-2)));
   214.
   215.    procedure write_top (the_pair : in KDF9.pair) is
   216.    begin
   217.       the_NEST(the_NEST_depth-1) := the_pair.msw;
   218.       the_NEST(the_NEST_depth-2) := the_pair.lsw;
   219.    end write_top;
   220.
   221.
   222. --
   223.    -- Support for Director-only operations.
   224. --
   225.
   226.    -- Set BA (bits D38:47), CPL (D34:35) and NOL (D24:33).
   227.
   228.    procedure set_K1_register (setting : in KDF9.word) is
   229.    begin
   230.       BA  := KDF9.address(setting mod 2**10) * 2**5;
   231.       CPL := KDF9.priority((setting / 2**12) and 2#11#);
   232.       NOL := KDF9.address((setting / 2**14) mod 2**10) * 2**5 + 31;
   233.    end set_K1_register;
   234.
   235.    -- Set CPDAR (bits D32:47).
   236.
   237.    procedure set_K2_register (setting : in KDF9.word) is
   238.       CPDAR_Q : KDF9.Q_part := as_Q(setting).M;
   239.    begin
   240.       for i in KDF9.buffer_number loop
   241.          the_CPDAR(i) := (CPDAR_Q mod 2) = 1;
   242.          CPDAR_Q := CPDAR_Q / 2;
   243.       end loop;
   244.    end set_K2_register;
   245.
   246.    -- Set context (bits D0:1), NEST_depth (D2:6) and SJNS_depth (D7:11).
   247.
   248.    procedure set_K3_register (setting : in KDF9.word) is
   249.    begin
   250.       -- Save the current register values in the register bank.
   251.       register_bank(the_context).NEST := the_NEST;
   252.       register_bank(the_context).SJNS := the_SJNS;
   253.       register_bank(the_context).Q_store := the_Q_store;
   254.       -- Set the new context.
   255.       the_context := KDF9.context(KDF9.word'(setting / 2**46));
   256.       the_NEST_depth := KDF9.NEST_depth(setting / 2**41 mod 2**5);
   257.       the_SJNS_depth := KDF9.SJNS_depth(setting / 2**36 mod 2**5);
   258.       -- Restore the register values for the new context.
   259.       the_NEST := register_bank(the_context).NEST;
   260.       the_SJNS := register_bank(the_context).SJNS;
   261.       the_Q_store := register_bank(the_context).Q_store;
   262.    end set_K3_register;
   263.
   264.    a_microsecond : constant := 1.0 / 2.0**20;
   265.
   266.    type seconds is delta a_microsecond range 0.0 .. 1000.0*365.2425*24.0*3600.0;  -- 1000 years!
   267.
   268.    procedure update_the_elapsed_time;
   269.
   270.    -- Let the real elapsed time catch up with the_real_time virtual seconds.
   271.
   272.    procedure delay_until (the_real_time : in KDF9.us) is
   273.       a_jiffy : constant seconds := seconds(2**10) * a_microsecond;  -- ca. TR character-read time of 1ms
   274.       the_lag : seconds;
   275.    begin
   276.        if the_real_time < the_last_delay_time then
   277.           the_last_delay_time := the_real_time;
   278.        end if;
   279.       the_lag := seconds(the_real_time - the_last_delay_time) * a_microsecond;
   280.       if the_lag >= a_jiffy then  -- More than a a_jiffy of virtual elapsed time has passed.
   281.          delay Duration(the_lag);
   282.          the_last_delay_time := the_real_time;
   283.       end if;
   284.      -- the_elapsed_time := the_real_time;
   285.       update_the_elapsed_time;
   286.    end delay_until;
   287.
   288.    procedure delay_by (the_delay_time : in KDF9.us) is
   289.    begin
   290.       if authentic_timing_is_enabled then
   291.          delay_until(the_clock_time + the_delay_time);
   292.       end if;
   293.    end delay_by;
   294.
   295.    -- Advance to the larger of the_CPU_time, the_elapsed_time, and the_last_delay_time.
   296.    -- Cap the increase to prevent a spurious double-clock (RESET) interrupt in Director.
   297.
   298.    procedure update_the_elapsed_time is
   299.       max_elapsed_time : constant KDF9.us := the_last_K4_time + 2**20 - 1;
   300.    begin
   301.       the_elapsed_time := KDF9.us'Max(the_elapsed_time, the_last_delay_time);
   302.       the_elapsed_time := KDF9.us'Max(the_elapsed_time, the_CPU_time);
   303.       if the_execution_mode = boot_mode and the_CPU_state = Director_state then
   304.          the_elapsed_time := KDF9.us'Min(the_elapsed_time, max_elapsed_time);
   305.       end if;
   306.    end update_the_elapsed_time;
   307.
   308.    -- The virtual elapsed time.
   309.
   310.    function the_clock_time
   311.    return KDF9.us is
   312.    begin
   313.       update_the_elapsed_time;
   314.       return the_elapsed_time;
   315.    end the_clock_time;
   316.
   317.    procedure advance_the_clock (past : in KDF9.us) is
   318.    begin
   319.       the_elapsed_time := KDF9.us'Max(the_elapsed_time, past);
   320.       update_the_elapsed_time;
   321.       if authentic_timing_is_enabled then
   322.          delay_until(the_elapsed_time);
   323.       end if;
   324.    end advance_the_clock;
   325.
   326.    procedure synchronize_the_real_and_virtual_times is
   327.    begin
   328.       if authentic_timing_is_enabled then
   329.          update_the_elapsed_time;
   330.          delay_until(the_elapsed_time);
   331.       end if;
   332.    end synchronize_the_real_and_virtual_times;
   333.
   334.    -- Get clock (bits D0:15) and RFIR (D16:31).
   335.
   336.    function get_K4_operand
   337.    return KDF9.word is
   338.
   339.       function RFIR_in_a_word
   340.       return KDF9.word is
   341.          result : KDF9.word := 0;
   342.       begin
   343.          for r of the_RFIR loop
   344.             result := result*2;
   345.             if r then
   346.                result := result or 1;
   347.             end if;
   348.          end loop;
   349.          return result;
   350.       end RFIR_in_a_word;
   351.
   352.       -- The KDF9's interval timing clock ticks once per 32 s;
   353.       --    the emulator virtual time has a resolution of 1 s.
   354.
   355.       time_now : constant KDF9.us := the_clock_time;
   356.       interval : constant KDF9.us := (time_now - the_last_K4_time);
   357.
   358.    begin
   359.       the_last_K4_time := time_now;
   360.       if interval / 32 >= 2**16 then
   361.          effect_interrupt(caused_by_RESET, "double clock");
   362.          the_RFIR(caused_by_RESET ) := True;
   363.       elsif interval / 32 >= 2**15 then
   364.          effect_interrupt(caused_by_CLOCK, "time since a K4" & interval'Image & "us");
   365.          the_RFIR(caused_by_CLOCK ) := True;  --?? why is this needed?
   366.       end if;
   367.       return (KDF9.word(interval / 32) * 2**32) or (RFIR_in_a_word * 2**16);
   368.    end get_K4_operand;
   369.
   370.    -- Get PHUi (bits D6i:6i+5, i = 0 .. 3).
   371.
   372.    function get_K5_operand
   373.    return KDF9.word
   374.    is (K5_operand);
   375.
   376.    -- Get context (bits D0:1), NEST_depth (D2:6) and SJNS_depth (D7:11).
   377.
   378.    function get_K7_operand
   379.    return KDF9.word
   380.    is (
   381.        (KDF9.word(the_context)    * 2**46) or
   382.        (KDF9.word(the_NEST_depth) * 2**41) or
   383.        (KDF9.word(the_SJNS_depth) * 2**36)
   384.       );
   385.
   386.    procedure reset_V_and_T is
   387.    begin
   388.       the_V_bit_is_set := False;
   389.       the_T_bit_is_set := False;
   390.    end reset_V_and_T;
   391.
   392.    procedure reset_the_internal_registers (the_new_state : in CPU_state) is
   393.    begin
   394.       -- Set the state of a newly bootstrapped CPU.
   395.       reset_V_and_T;
   396.       CIA := (0, 0);
   397.       CPL := 0;
   398.       BA  := 0;
   399.       NOL := max_address;
   400.       the_RFIR := (others => False);
   401.       ICR := 0;
   402.       the_CPU_time := 0;
   403.       the_elapsed_time := 0;
   404.       the_last_delay_time := 0;
   405.       the_last_K4_time := 0;
   406.       the_CPU_state := the_new_state;
   407.       the_CPDAR := (0 => True, others => False);  -- FW0 is always allocated.
   408.    end reset_the_internal_registers;
   409.
   410.    empty_NEST : constant NEST := (others => 0);
   411.    empty_SJNS : constant SJNS := (others => (0, 0));
   412.    empty_Q_s  : constant Q_store := (others => (0, 0, 0));
   413.
   414.    procedure reset_the_CPU_state is
   415.    begin
   416.       the_context := 0;
   417.       for bank of register_bank loop
   418.          bank := (NEST => empty_NEST, SJNS => empty_SJNS, Q_store => empty_Q_s);
   419.       end loop;
   420.       the_NEST_depth := 0;
   421.       the_NEST       := empty_NEST;
   422.       the_SJNS_depth := 0;
   423.       the_SJNS       := empty_SJNS;
   424.       the_Q_store    := empty_Q_s;
   425.       if the_execution_mode = program_mode then
   426.          reset_the_internal_registers(program_state);
   427.       else
   428.          reset_the_internal_registers(Director_state);
   429.       end if;
   430.       -- Setting NIA must follow program loading, as it fetches E0 into the IWBs.
   431.       set_NIA_to((0, 0));
   432.    end reset_the_CPU_state;
   433.
   434.    procedure reset_the_program_state is
   435.    begin
   436.       the_NEST_depth := 0;
   437.       the_NEST       := empty_NEST;
   438.       the_SJNS_depth := 0;
   439.       the_SJNS       := empty_SJNS;
   440.       reset_V_and_T;
   441.       the_CPDAR := (0 => True, others => False);  -- FW0 is always allocated.
   442.       -- Setting NIA must follow program loading, as it fetches E0 into the IWBs.
   443.       set_NIA_to((0, 0));
   444.    end reset_the_program_state;
   445.
   446.    procedure effect_interrupt (caused_by_this : in KDF9.interrupt_number; message : in String) is
   447.       return_address : KDF9.syllable_address;
   448.    begin
   449.       take_note_of_interrupt(caused_by_this, message);
   450.       the_RFIR(caused_by_this) := True;
   451.       case the_execution_mode is
   452.          when boot_mode =>
   453.             -- Interrupts are either actioned or deferred to Director.
   454.             if the_CPU_state = program_state or else caused_by_this = caused_by_RESET  then
   455.                -- Action an actual interrupt into Director.
   456.                if caused_by_this in caused_by_LOV  | caused_by_OUT then
   457.                   return_address := CIA;  -- Restart the interrupted instruction.
   458.                else
   459.                   return_address := NIA;  -- Proceed after the interrupted instruction.
   460.                end if;
   461.                if the_SJNS_depth < 16 then
   462.                   push(return_address);                  -- The program link fits into the SJNS.
   463.                else
   464.                   JB := KDF9.SJNS_link(return_address);  -- The program link overwrites JB.
   465.                end if;
   466.                BA := 0;
   467.                fetching_normally := True;
   468.                set_NIA_to((0, 0));
   469.                the_CPU_state := Director_state;
   470.                raise abandon_this_order;
   471.             else
   472.                -- Defer: Director will eventually find any request left in the_RFIR.
   473.                -- NOUV is completely suppressed in Director state.
   474.                the_RFIR(caused_by_NOUV) := False;
   475.             end if;
   476.
   477.          when test_program_mode =>
   478.             -- Interrupts other than LOV and RESET are ignored.
   479.             -- There is no need to accurately emulate the address placed by the hardware in JB.
   480.             case caused_by_this is
   481.                when caused_by_LOV  =>
   482.                   raise LOV_exception with message;
   483.                when caused_by_RESET  =>
   484.                   raise RESET_exception with message;
   485.                when others =>
   486.                   null;
   487.             end case;
   488.
   489.          when program_mode =>
   490.             -- Interrupts other than LOV are treated as failures.
   491.             -- There is no need to accurately emulate the address placed by the hardware in JB.
   492.             case caused_by_this is
   493.                when caused_by_PR =>
   494.                   raise PR_exception with message;
   495.                when caused_by_FLEX =>
   496.                   raise FLEX_exception with message;
   497.                when caused_by_LIV =>
   498.                   raise LIV_exception with message;
   499.                when caused_by_NOUV =>
   500.                   raise NOUV_exception with message;
   501.                when caused_by_EDT =>
   502.                   raise EDT_exception with message;
   503.                when caused_by_OUT =>
   504.                   raise OUT_exception with message;
   505.                when caused_by_LOV  =>
   506.                   raise LOV_exception with message;
   507.                when caused_by_RESET  =>
   508.                   raise RESET_exception with message;
   509.                when others =>
   510.                   raise emulation_failure with "invalid RFI in effect_interrupt";
   511.             end case;
   512.       end case;
   513.    end effect_interrupt;
   514.
   515.    procedure effect_clock_interrupt (interval : in KDF9.us)
   516.       with Inline => False;
   517.
   518.    procedure effect_clock_interrupt (interval : in KDF9.us) is
   519.    begin
   520.       effect_interrupt(caused_by_CLOCK, interval'Image & " KDF9 us");
   521.    end effect_clock_interrupt;
   522.
   523.    procedure check_for_a_clock_interrupt is
   524.       interval : KDF9.us;
   525.    begin
   526.       -- Clock ticks are ignored in program_mode and test_program_mode.
   527.       -- In boot_mode:
   528.       --    they are actioned in program_state;
   529.       --    they are deferred in Director_state: Director will eventually find the time for itself.
   530.       if the_execution_mode = boot_mode and then
   531.             the_CPU_state = program_state   then
   532.          interval := (the_clock_time - the_last_K4_time);
   533.          if interval >= 2**20 then
   534.             effect_clock_interrupt(interval);
   535.          end if;
   536.       end if;
   537.    end check_for_a_clock_interrupt;
   538.
   539.    procedure fail_in_problem_program_state is
   540.    begin
   541.       case the_execution_mode is
   542.          when program_mode =>
   543.             -- The unprivileged program has attempted a privileged operation.
   544.             raise LIV_exception with "%Director-only instruction";
   545.          when test_program_mode =>
   546.             -- The privileged program is allowed to use privileged instructions.
   547.             return;
   548.          when boot_mode =>
   549.             if the_CPU_state = program_state then
   550.                -- Punt the error to Director.
   551.                effect_interrupt(caused_by_LIV, "Director-only instruction");
   552.             else
   553.                -- All privileged operations are permitted to Director.
   554.                return;
   555.             end if;
   556.       end case;
   557.    end fail_in_problem_program_state;
   558.
   559.    procedure LOV_if_user_mode (cause : in String) is
   560.    begin
   561.       -- LOV was TOTALLY suppressed in Director state.
   562.       if the_CPU_state /= Director_state then
   563.          set_NIA_to(CIA);
   564.          effect_interrupt(caused_by_LOV, cause);
   565.       end if;
   566.    end LOV_if_user_mode;
   567.
   568.    -- The %  prepended to the_message aids parsing of exception error messages in failure shutdown.
   569.
   570.    procedure trap_illegal_instruction (the_message : in String := "invalid opcode") is
   571.    begin
   572.       -- The program has failed in a manner that could cause a LIV interrupt.
   573.       case the_execution_mode is
   574.          when program_mode
   575.             | test_program_mode =>
   576.             raise LIV_exception with "%" & the_message;
   577.          when boot_mode =>
   578.             if the_CPU_state = program_state then
   579.                -- Punt the problem to Director.
   580.                effect_interrupt(caused_by_LIV, the_message);
   581.             else
   582.                -- The Director itself has gone seriously wrong.
   583.                -- LIV is impossible in Director, so ee9 takes responsibility for stopping the run
   584.                --    to avert consequential emulation failure.
   585.                raise Director_failure with "%" & the_message;
   586.             end if;
   587.       end case;
   588.    end trap_illegal_instruction;
   589.
   590.    procedure trap_operator_error (the_message : in String) is
   591.    begin
   592.       -- The program has failed for a reason, such as a misconfigured environment,
   593.       --    that is beyond its control and prevents further execution.
   594.       raise operator_error with "%" & the_message;
   595.    end trap_operator_error;
   596.
   597.    procedure trap_unimplemented_feature (the_message : in String) is
   598.    begin
   599.       -- The program has attempted to use something that ee9 does not (yet) support.
   600.       raise not_yet_implemented with "%" & the_message;
   601.    end trap_unimplemented_feature;
   602.
   603.    procedure trap_failing_OUT (OUT_number : in KDF9.word; the_message : in String) is
   604.       OUT_name : constant String := OUT_number'Image;
   605.    begin
   606.       -- The program has issued an invalid OUT.
   607.       raise OUT_error with "%" & OUT_name(2..OUT_name'Last) & ": " & the_message;
   608.    end trap_failing_OUT;
   609.
   610.    procedure trap_invalid_paper_tape (the_message : in String) is
   611.    begin
   612.       -- The paper tape file given to load or boot has defects.
   613.       raise invalid_paper_tape_file with "%" & the_message;
   614.    end trap_invalid_paper_tape;
   615.
   616.    procedure return_from_Director_to (new_IAR : in KDF9.syllable_address) is
   617.    begin
   618.       the_CPU_state := program_state;
   619.       set_NIA_to(new_IAR);
   620.    end return_from_Director_to;
   621.
   622.    procedure increment_by_1 (the_link : in out KDF9.syllable_address) is
   623.    begin
   624.       if the_link.syllable_index < 5 then
   625.          the_link.syllable_index := the_link.syllable_index + 1;
   626.       else
   627.          the_link.syllable_index := 0;
   628.          the_link.order_word_number     := the_link.order_word_number + 1;
   629.       end if;
   630.    end increment_by_1;
   631.
   632.    procedure increment_by_2 (the_link : in out KDF9.syllable_address) is
   633.    begin
   634.       if the_link.syllable_index < 4 then
   635.          the_link.syllable_index := the_link.syllable_index + 2;
   636.       else
   637.          the_link.syllable_index := the_link.syllable_index - 4;
   638.          the_link.order_word_number     := the_link.order_word_number + 1;
   639.       end if;
   640.    end increment_by_2;
   641.
   642.    procedure increment_by_3 (the_link : in out KDF9.syllable_address) is
   643.    begin
   644.       if the_link.syllable_index < 3 then
   645.          the_link.syllable_index := the_link.syllable_index + 3;
   646.       else
   647.          the_link.syllable_index := the_link.syllable_index - 3;
   648.          the_link.order_word_number     := the_link.order_word_number + 1;
   649.       end if;
   650.    end increment_by_3;
   651.
   652.    -- the_syllable_cache holds two instruction words, pre-split into syllables.
   653.    -- They would have been held in IWB0 and IWB1 by Main Control in the KDF9.
   654.
   655.    subtype syllable_cache_range is Natural range 0 .. 11;
   656.
   657.    the_syllable_cache  : array (syllable_cache_range) of KDF9.syllable;
   658.    the_cache_index     : syllable_cache_range   := 0;
   659.    the_cached_location : KDF9.order_word_number := 0;
   660.
   661.    function NIA
   662.    return KDF9.syllable_address
   663.    is (
   664.        if the_cache_index > 5 then
   665.           (the_cached_location, KDF9.syllable_index(the_cache_index-6))
   666.        else
   667.           (the_cached_location-1, KDF9.syllable_index(the_cache_index))
   668.       );
   669.
   670.    function NIA_word_number
   671.    return KDF9.order_word_number
   672.    is (the_cached_location - (if the_cache_index > 5 then 0 else 1));
   673.
   674.    procedure trap_an_invalid_order_address (new_NIA : in KDF9.syllable_address)
   675.       with Inline => False;
   676.
   677.    procedure trap_an_invalid_order_address (new_NIA : in KDF9.syllable_address) is
   678.    begin
   679.       if new_NIA.syllable_index = 6 then
   680.          effect_interrupt(caused_by_RESET, "syllable number = 6");
   681.       elsif new_NIA.syllable_index = 7 then
   682.          effect_interrupt(caused_by_RESET, "syllable number = 7");
   683.       else
   684.          effect_interrupt(caused_by_LIV, "jump to 8191");  -- See EE Report K/GD y 82.
   685.       end if;
   686.    end trap_an_invalid_order_address;
   687.
   688.    procedure set_NIA_to (new_NIA : in KDF9.syllable_address) is
   689.       mask        : constant := 8#377#;
   690.       shift       : constant := 8#400#;
   691.       IWB0, IWB1  : KDF9.word;
   692.    begin
   693.       if new_NIA.order_word_number = 8191 or else
   694.             new_NIA.syllable_index > 5       then
   695.          trap_an_invalid_order_address(new_NIA);
   696.       end if;
   697.
   698.       IWB0 := fetch_word(KDF9.address(new_NIA.order_word_number) + 0);
   699.       IWB1 := fetch_word(KDF9.address(new_NIA.order_word_number) + 1);
   700.
   701.       the_cache_index := syllable_cache_range(new_NIA.syllable_index);
   702.       the_cached_location := new_NIA.order_word_number + 1;
   703.
   704.       the_syllable_cache(5+0) := KDF9.syllable(IWB0 and mask);
   705.       IWB0 := IWB0 / shift;
   706.       the_syllable_cache(4+0) := KDF9.syllable(IWB0 and mask);
   707.       IWB0 := IWB0 / shift;
   708.       the_syllable_cache(3+0) := KDF9.syllable(IWB0 and mask);
   709.       IWB0 := IWB0 / shift;
   710.       the_syllable_cache(2+0) := KDF9.syllable(IWB0 and mask);
   711.       IWB0 := IWB0 / shift;
   712.       the_syllable_cache(1+0) := KDF9.syllable(IWB0 and mask);
   713.       IWB0 := IWB0 / shift;
   714.       the_syllable_cache(0+0) := KDF9.syllable(IWB0);
   715.
   716.       the_syllable_cache(5+6) := KDF9.syllable(IWB1 and mask);
   717.       IWB1 := IWB1 / shift;
   718.       the_syllable_cache(4+6) := KDF9.syllable(IWB1 and mask);
   719.       IWB1 := IWB1 / shift;
   720.       the_syllable_cache(3+6) := KDF9.syllable(IWB1 and mask);
   721.       IWB1 := IWB1 / shift;
   722.       the_syllable_cache(2+6) := KDF9.syllable(IWB1 and mask);
   723.       IWB1 := IWB1 / shift;
   724.       the_syllable_cache(1+6) := KDF9.syllable(IWB1 and mask);
   725.       IWB1 := IWB1 / shift;
   726.       the_syllable_cache(0+6) := KDF9.syllable(IWB1);
   727.    end set_NIA_to;
   728.
   729.    procedure set_NIA_to_the_INS_target_address is
   730.    begin
   731.       set_NIA_to(INS.target);
   732.    end set_NIA_to_the_INS_target_address;
   733.
   734.    procedure set_IWB0_and_IWB1_for_a_JCqNZS_loop is
   735.    begin
   736.       set_NIA_to((order_word_number => CIA.order_word_number-1, syllable_index => 0));
   737.       fetching_normally := False;
   738.    end set_IWB0_and_IWB1_for_a_JCqNZS_loop;
   739.
   740.    procedure go_back_to_the_start_of_IWB0 is
   741.    begin
   742.       the_cache_index := 0;
   743.    end go_back_to_the_start_of_IWB0;
   744.
   745.    procedure continue_after_JCqNZS is
   746.    begin
   747.       if CIA.syllable_index = 4 and the_cached_location = CIA.order_word_number then
   748.          set_NIA_to((order_word_number => CIA.order_word_number+1, syllable_index => 0));
   749.       end if;
   750.       fetching_normally := True;
   751.    end continue_after_JCqNZS;
   752.
   753.    function next_order_syllable
   754.    return KDF9.syllable
   755.       with Inline;
   756.
   757.    -- The amount by which the_CPU_time is increased, for a refill of both Instruction Word Buffers.
   758.
   759.    the_IWB01_reload_time : constant KDF9.us := 7;  -- microseconds
   760.
   761.    function next_order_syllable
   762.    return KDF9.syllable is
   763.       the_next_syllable : KDF9.syllable;
   764.    begin
   765.       the_next_syllable := the_syllable_cache(the_cache_index);
   766.       if the_cache_index < 11 then
   767.          the_cache_index := the_cache_index + 1;
   768.       elsif fetching_normally then
   769.          set_NIA_to((order_word_number => CIA.order_word_number+1, syllable_index => 0));
   770.          -- Part-overlapped order-word fetch: can happen only once per instruction,
   771.          --    and only before the instruction is executed, so no need to ADD to the_CPU_delta.
   772.          if (CIA.order_word_number and 15) < 10 then
   773.             -- The fudge factor applied here gives the Whetstone Benchmark its historical run time.
   774.             the_CPU_delta := the_IWB01_reload_time + 1;
   775.          else
   776.             the_CPU_delta := the_IWB01_reload_time;
   777.          end if;
   778.       else
   779.          go_back_to_the_start_of_IWB0;
   780.       end if;
   781.       return the_next_syllable;
   782.    end next_order_syllable;
   783.
   784.    procedure decode_syllable_0 (decoded : in out KDF9.decoded_order)
   785.       with Inline;
   786.
   787.    procedure decode_syllable_1 (decoded : in out KDF9.decoded_order)
   788.       with Inline;
   789.
   790.    procedure decode_a_jump_order (decoded : in out KDF9.decoded_order)
   791.       with Inline;
   792.
   793.    procedure decode_a_store_access_order (decoded : in out KDF9.decoded_order)
   794.       with Inline;
   795.
   796.    procedure decode_a_set_literal_order (decoded : in out KDF9.decoded_order)
   797.       with Inline;
   798.
   799.    procedure decode_syllable_0 (decoded : in out KDF9.decoded_order) is
   800.    begin
   801.       decoded.compressed_opcode := decoded.order.syllable_0 and 8#77#;
   802.       decoded.kind := KDF9.INS_kind(decoded.order.syllable_0 / 2**6);
   803.    end decode_syllable_0;
   804.
   805.    procedure process_syllable_0_of_INS is
   806.    begin
   807.       if the_cache_index > 5 then
   808.          CIA.order_word_number := the_cached_location;
   809.          CIA.syllable_index   := KDF9.syllable_index(the_cache_index-6);
   810.       else
   811.          CIA.order_word_number := the_cached_location - 1;
   812.          CIA.syllable_index   := KDF9.syllable_index(the_cache_index);
   813.       end if;
   814.       INS.order.syllable_0 := next_order_syllable;
   815.       INS.compressed_opcode := INS.order.syllable_0 and 8#77#;
   816.       INS.kind := KDF9.INS_kind(INS.order.syllable_0 / 2**6);
   817.    end process_syllable_0_of_INS;
   818.
   819.    procedure decode_syllable_1 (decoded : in out KDF9.decoded_order) is
   820.    begin
   821.       decoded.Qq := KDF9.Q_number(decoded.order.syllable_1 / 2**4);
   822.       decoded.Qk := KDF9.Q_number(decoded.order.syllable_1 and 8#17#);
   823.    end decode_syllable_1;
   824.
   825.    procedure process_syllable_1_of_INS is
   826.    begin
   827.       INS.order.syllable_1 := next_order_syllable;
   828.       INS.Qq := KDF9.Q_number(INS.order.syllable_1 / 2**4);
   829.       INS.Qk := KDF9.Q_number(INS.order.syllable_1 and 8#17#);
   830.    end process_syllable_1_of_INS;
   831.
   832.    syllable_nr_mask : constant := 2#111#;
   833.    D4_mask          : constant := 2#1000#;
   834.    D2_mask          : constant := 2#00_100_000#;
   835.    D0_thru_3_mask   : constant := 2#11_110_000#;
   836.
   837.    procedure decode_a_jump_order (decoded : in out KDF9.decoded_order) is
   838.    begin
   839.       decoded.target.syllable_index
   840.          := KDF9.syllable_index(decoded.order.syllable_0 and syllable_nr_mask);
   841.       decoded.target.order_word_number
   842.          := KDF9.order_word_number(decoded.order.syllable_2)
   843.           + KDF9.order_word_number(decoded.Qk) * 2**8
   844.           + KDF9.order_word_number(decoded.order.syllable_0 and D4_mask) * 2**9;
   845.       if (decoded.compressed_opcode and D2_mask) /= 0 then -- not JrCq ...
   846.          decoded.compressed_opcode := decoded.compressed_opcode and D0_thru_3_mask;
   847.       else
   848.          decoded.compressed_opcode := (decoded.compressed_opcode and D0_thru_3_mask) or KDF9.syllable(decoded.Qq);
   849.       end if;
   850.       if decoded.compressed_opcode = EXIT_n then
   851.          -- The syllable part of EXIT is actually a halfword offset,
   852.          --    so convert it to an actual syllable number.
   853.          if decoded.target.syllable_index = 2 then
   854.             decoded.target.syllable_index := 0;
   855.          else
   856.             decoded.target.syllable_index := 3;
   857.          end if;
   858.       end if;
   859.    end decode_a_jump_order;
   860.
   861.    procedure process_syllables_1_and_2_of_a_jump_order is
   862.    begin
   863.       process_syllable_1_of_INS;
   864.       INS.order.syllable_2 := next_order_syllable;
   865.       decode_a_jump_order(INS);
   866.    end process_syllables_1_and_2_of_a_jump_order;
   867.
   868.    D5_thru_7_mask : constant := 2#111#;
   869.    D5_and_7_mask  : constant := 2#101#;
   870.    D2_thru_4_mask : constant := 2#111000#;
   871.
   872.    procedure decode_a_store_access_order (decoded : in out KDF9.decoded_order) is
   873.    begin
   874.       decoded.operand := KDF9.Q_part(decoded.order.syllable_2) + KDF9.Q_part(decoded.Qk)*2**8
   875.                        + KDF9.Q_part((decoded.order.syllable_0 and D2_thru_4_mask)) * 2**9;
   876.       decoded.compressed_opcode := decoded.compressed_opcode and D5_thru_7_mask;
   877.    end decode_a_store_access_order;
   878.
   879.    procedure decode_a_set_literal_order (decoded : in out KDF9.decoded_order) is
   880.    begin
   881.       decoded.operand := KDF9.Q_part(decoded.order.syllable_2)
   882.                        + KDF9.Q_part(decoded.order.syllable_1)*2**8;
   883.       decoded.compressed_opcode := 2#100#;
   884.    end decode_a_set_literal_order;
   885.
   886.    procedure process_syllables_1_and_2_of_a_data_access_order is
   887.    begin
   888.       if (INS.compressed_opcode and D5_thru_7_mask) < SET then
   889.          process_syllable_1_of_INS;
   890.          INS.order.syllable_2 := next_order_syllable;
   891.          decode_a_store_access_order(INS);
   892.       elsif (INS.compressed_opcode and D5_and_7_mask) = SET then
   893.          -- SET n
   894.          INS.order.syllable_1 := next_order_syllable;
   895.          INS.order.syllable_2 := next_order_syllable;
   896.          decode_a_set_literal_order(INS);
   897.       else
   898.          INS.order.syllable_1 := next_order_syllable;
   899.          INS.order.syllable_2 := next_order_syllable;
   900.          decode_a_set_literal_order(INS);
   901.          INS.compressed_opcode := 7;  -- an invalid compression.
   902.       end if;
   903.    end process_syllables_1_and_2_of_a_data_access_order;
   904.
   905.    procedure decode_the_next_order is
   906.    begin
   907.       -- The CPU time is adjusted by a fudge factor to account for
   908.       --    the instruction-fetch time being partly overlapped.
   909.       process_syllable_0_of_INS;
   910.       case INS.kind is
   911.          when one_syllable_order =>
   912.             return;
   913.          when two_syllable_order =>
   914.             process_syllable_1_of_INS;
   915.          when normal_jump_order =>
   916.             process_syllables_1_and_2_of_a_jump_order;
   917.          when data_access_order =>
   918.             process_syllables_1_and_2_of_a_data_access_order;
   919.       end case;
   920.    end decode_the_next_order;
   921.
   922.    procedure decode (the_order : in out KDF9.decoded_order) is
   923.    begin
   924.       decode_syllable_0(the_order);
   925.       case the_order.kind is
   926.          when one_syllable_order =>
   927.             null;
   928.          when two_syllable_order =>
   929.             decode_syllable_1(the_order);
   930.          when normal_jump_order =>
   931.             decode_syllable_1(the_order);
   932.             decode_a_jump_order(the_order);
   933.          when data_access_order =>
   934.             if (the_order.compressed_opcode and D5_thru_7_mask) < SET then
   935.                decode_syllable_1(the_order);
   936.                decode_a_store_access_order(the_order);
   937.             elsif (INS.compressed_opcode and D5_and_7_mask) = SET then
   938.                -- SET n
   939.                decode_a_set_literal_order(the_order);
   940.             else
   941.                decode_a_set_literal_order(the_order);
   942.                INS.compressed_opcode := 7;  -- an invalid compression.
   943.             end if;
   944.       end case;
   945.    end decode;
   946.
   947.    -- the_order_at_NIA gets three syllables starting at [NIA].  It is FOR DIAGNOSTIC USE ONLY!
   948.    -- It does NOT update the CPU time properly and MUST NOT be used inside an instruction cycle.
   949.
   950.    function the_order_at_NIA
   951.    return KDF9.syllable_group is
   952.       saved_NIA : constant KDF9.syllable_address := NIA;
   953.       result    : KDF9.syllable_group;
   954.    begin
   955.       result.syllable_0 := next_order_syllable;
   956.       result.syllable_1 := next_order_syllable;
   957.       result.syllable_2 := next_order_syllable;
   958.       set_NIA_to(saved_NIA);
   959.       return result;
   960.    end the_order_at_NIA;
   961.
   962.    -- This is the initial jump from the top halfword of E0 just after loading.
   963.
   964.    E0U : KDF9.word := 0;  -- N.B. the lower halfword is used for option flags.
   965.
   966.    procedure save_the_initial_jump is
   967.    begin
   968.       E0U := fetch_halfword(0, 0);
   969.    end save_the_initial_jump;
   970.
   971.    procedure restore_the_initial_jump is
   972.    begin
   973.        store_halfword(E0U, 0, 0);
   974.    end restore_the_initial_jump;
   975.
   976.    function the_initial_jump_was_corrupted
   977.    return Boolean
   978.    is (E0U /= fetch_halfword(0, 0));
   979.
   980.    function is_an_invalid_order (decoded : KDF9.decoded_order)
   981.    return Boolean
   982.    is (
   983.        (decoded.kind = data_access_order and then (decoded.order.syllable_0 and 2#101#) > 2#100#)
   984.          or else (decoded.kind = normal_jump_order and decoded.target.syllable_index > 5)
   985.             -- 0 is now treated as a valid DUMMY0 order for KAlgol
   986.                or else decoded.order.syllable_0 = 8#006#
   987.                   or else decoded.order.syllable_0 = 8#040#
   988.                      or else decoded.order.syllable_0 = 8#046#
   989.                         or else decoded.order.syllable_0 = 8#055#
   990.                            or else decoded.order.syllable_0 = 8#073#
   991.                               or else decoded.order.syllable_0 = 8#076#
   992.                                  or else decoded.order.syllable_0 = 8#150#
   993.       );
   994.
   995.    the_signature_hash : KDF9.word := 0;
   996.
   997.    function the_digital_signature
   998.    return KDF9.word
   999.    is (the_signature_hash);
  1000.
  1001.    function visible_state_hash
  1002.    return KDF9.word
  1003.       with Inline;
  1004.
  1005.    function visible_state_hash
  1006.    return KDF9.word is
  1007.       hash : KDF9.word;
  1008.    begin
  1009.       hash := rotate_word_right(the_signature_hash, 1) xor KDF9.word(ICR);
  1010.       hash := rotate_word_right(hash, 1) xor as_word(the_Q_store(INS.Qq));
  1011.       hash := rotate_word_right(hash, 1) xor as_word(the_Q_store(INS.Qk));
  1012.       if the_SJNS_depth > 0 then
  1013.          for s in reverse KDF9.SJNS_depth range 0 .. the_SJNS_depth-1 loop
  1014.                hash := rotate_word_right(hash, 1) xor as_word(the_SJNS(s));
  1015.          end loop;
  1016.       end if;
  1017.       if the_NEST_depth > 0 then
  1018.          for n in reverse KDF9.NEST_depth range 0 .. the_NEST_depth-1 loop
  1019.                hash := rotate_word_right(hash, 1) xor the_NEST(n);
  1020.          end loop;
  1021.       end if;
  1022.       return hash;
  1023.    end visible_state_hash;
  1024.
  1025.    procedure update_the_digital_signature is
  1026.    begin
  1027.       the_signature_hash := visible_state_hash;
  1028.    end update_the_digital_signature;
  1029.
  1030. end KDF9;

Compiling: ../Source/kdf9.ads
Source file time stamp: 2021-02-20 23:56:00
Compiled at: 2021-02-21 15:54:05

     1. -- The architecturally-defined data and register formats of the KDF9 computer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with System;
    18.
    19. package KDF9 is
    20.
    21.    --
    22.    --
    23.    -- The fundamental storage unit is the 48-bit word.
    24.    --
    25.    --
    26.
    27.    --
    28.    -- The 48-bit word, considered as an unsigned integer.
    29.    --
    30.
    31.    type word is mod 2**48;  -- Let the compiler choose the best Size for this.
    32.
    33.    word_mask : constant := 8#7777777777777777#;
    34.    min_word  : constant := 8#4000000000000000#;
    35.    max_word  : constant := 8#3777777777777777#;
    36.
    37.    all_zero_bits : constant KDF9.word := 0;
    38.    sign_bit      : constant KDF9.word := KDF9.min_word;
    39.    not_sign_bit  : constant KDF9.word := KDF9.max_word;
    40.    all_one_bits  : constant KDF9.word := KDF9.word_mask;
    41.
    42.
    43.    --
    44.    -- The 96-bit double word, considered as a pair of words.
    45.    --
    46.
    47.    type pair is
    48.       record
    49.          msw, lsw : KDF9.word;
    50.       end record;
    51.
    52.
    53.    --
    54.    -- The basic 16-bit operand.
    55.    --
    56.
    57.    type field_of_16_bits is mod 2**16;
    58.
    59.    --
    60.    -- The 16-bit word, considered as a field of a Q register.
    61.    --
    62.
    63.    type Q_part is new KDF9.field_of_16_bits;
    64.
    65.    Q_part_mask : constant := KDF9.Q_part'Last;
    66.
    67.    function sign_extended (Q : KDF9.Q_part)
    68.    return KDF9.word
    69.       with Inline;
    70.
    71.    --
    72.    -- The 16-bit word, considered as a buffer (DMA channel) number.
    73.    --
    74.
    75.    subtype buffer_number is KDF9.Q_part range 0 .. 15;
    76.
    77.    buffer_number_mask : constant := buffer_number'Last;
    78.
    79.    --
    80.    -- The 16-bit word, considered as a core-store address.
    81.    --
    82.
    83.    subtype address is KDF9.Q_part range 0 .. 8#77777#;
    84.
    85.    --
    86.    -- The Q-store element.
    87.    --
    88.
    89.    type Q_register is
    90.       record
    91.          C, I, M : KDF9.Q_part;
    92.       end record;
    93.
    94.    function as_Q (the_word : KDF9.word)
    95.    return KDF9.Q_register
    96.       with Inline;
    97.
    98.    function as_word (the_Q : KDF9.Q_register)
    99.    return KDF9.word
   100.       with Inline;
   101.
   102.
   103.    --
   104.    -- The 8-bit instruction syllable and its components.
   105.    --
   106.
   107.    type syllable is mod 2**8;
   108.
   109.    subtype compressed_opcode is KDF9.syllable range 0 .. 63;
   110.    subtype Q_number          is KDF9.syllable range 0 .. 15;
   111.
   112.    type syllable_group is
   113.       record
   114.          syllable_0, syllable_1, syllable_2 : KDF9.syllable := 0;
   115.       end record;
   116.
   117.
   118.    --
   119.    -- An instruction address.
   120.    --
   121.    -- N.B. 5 is the hardware's largest valid syllable address.
   122.    -- The values 6 and 7 are used as diagnostic flags by ee9.
   123.    -- They cause a RESET trap if encountered during execution.
   124.    --
   125.
   126.    type syllable_index    is mod 2**3;
   127.    type order_word_number is mod 2**13;
   128.
   129.    type syllable_address is
   130.       record
   131.          order_word_number : KDF9.order_word_number;
   132.          syllable_index    : KDF9.syllable_index;
   133.       end record;
   134.
   135.    --
   136.    -- An instruction address, in the packed format of a hardware (SJNS) link.
   137.    --
   138.
   139.    type SJNS_link is new KDF9.syllable_address
   140.       with Size => 16;
   141.    for SJNS_link'Bit_Order use System.Low_Order_First;
   142.    for SJNS_link use
   143.       record
   144.          order_word_number at 0 range  0 .. 12;
   145.          syllable_index    at 0 range 13 .. 15;
   146.       end record;
   147.
   148.    function as_word (the_link : KDF9.SJNS_link)
   149.    return KDF9.word;
   150.
   151.    function as_link (the_word : KDF9.word)
   152.    return KDF9.SJNS_link;
   153.
   154.    procedure increment_by_1 (the_link : in out KDF9.syllable_address)
   155.       with Inline;
   156.
   157.    procedure increment_by_2 (the_link : in out KDF9.syllable_address)
   158.       with Inline;
   159.
   160.    procedure increment_by_3 (the_link : in out KDF9.syllable_address)
   161.       with Inline;
   162.
   163.
   164.    --
   165.    -- The KDF9 halfword. Each occupies 24 bits, packed 2 per word.
   166.    --
   167.
   168.    type halfword is mod 2**24;
   169.    halfword_mask : constant := 8#77_77_77_77#;
   170.
   171.    subtype halfword_number is KDF9.address range 0 .. 1;
   172.
   173.
   174.    --
   175.    -- The KDF9 character occupies six bits, and they are packed 8 per word.
   176.    -- The various character sets, and the symbol type, are defined in the package KDF9_char_sets.
   177.    --
   178.
   179.
   180.    --
   181.    --
   182.    --
   183.    -- The following types define the structure of the KDF9's programmable registers.
   184.    --
   185.    --
   186.    --
   187.
   188.
   189.    --
   190.    -- authenticity_mode is declared here instead of in settings, to avoid a cyclic dependency.
   191.    --
   192.
   193.    type authenticity_mode is (modern_times_mode, authentic_time_mode);
   194.
   195.    the_authenticity_default : constant KDF9.authenticity_mode := modern_times_mode;
   196.    the_authenticity_mode    :          KDF9.authenticity_mode := the_authenticity_default;
   197.
   198.
   199.    --
   200.    --
   201.    --
   202.    -- The following variables (the_NEST, the_SJNS and the_Q_store) constitute
   203.    --    the emulation microcode's fixed working set of registers.
   204.    -- ee9 (unlike the real KDF9) swaps them with register_bank(the_context)
   205.    --    when a context switch is made by the =K3 instruction.
   206.    -- The real KDF9 used register_bank(the_context) directly for operands.
   207.    -- ee9's approach improves host cache locality and avoids indexing overheads,
   208.    --    the trade off being microscopically increased context-switching time.
   209.    --
   210.    --
   211.    --
   212.
   213.    --
   214.    -- The NEST.
   215.    --
   216.
   217.    type NEST_depth is mod 19;
   218.
   219.    type NEST is array (KDF9.NEST_depth) of KDF9.word;
   220.
   221.    the_NEST       : KDF9.NEST;
   222.    the_NEST_depth : KDF9.NEST_depth  := 0;
   223.
   224.    -- The ensure_that_the_NEST_holds* procedures trap NOUV.
   225.    -- They are used to validate operations that reduce the NEST depth.
   226.
   227.    procedure ensure_that_the_NEST_holds (at_least : in KDF9.NEST_depth)
   228.       with Inline;
   229.
   230.    procedure ensure_that_the_NEST_holds_an_operand
   231.       with Inline;
   232.
   233.    procedure ensure_that_the_NEST_holds_2_operands
   234.       with Inline;
   235.
   236.    function operand_words_needed (need : KDF9.NEST_depth)
   237.    return String
   238.       with Inline => False;
   239.
   240.    function pop
   241.    return KDF9.word
   242.       with Inline;
   243.
   244.    procedure pop
   245.       with Inline;
   246.
   247.    procedure write_top (the_word : in KDF9.word)
   248.       with Inline;
   249.
   250.    function read_top
   251.    return KDF9.word
   252.       with Inline;
   253.
   254.    function pop
   255.    return KDF9.pair
   256.       with Inline;
   257.
   258.    procedure pop_pair
   259.       with Inline;
   260.
   261.    procedure write_top (the_pair : in KDF9.pair)
   262.       with Inline;
   263.
   264.    function read_top
   265.    return KDF9.pair
   266.       with Inline;
   267.
   268.    -- The ensure_that_the_NEST_has_room_for* procedures trap NOUV.
   269.    -- They are used to validate operations that increase the NEST depth.
   270.
   271.    procedure ensure_that_the_NEST_has_room_for (at_least : in KDF9.NEST_depth)
   272.       with Inline;
   273.
   274.    procedure ensure_that_the_NEST_has_room_for_a_result
   275.       with Inline;
   276.
   277.    procedure push (the_word : in KDF9.word)
   278.       with Inline;
   279.
   280.    procedure ensure_that_the_NEST_has_room_for_2_results
   281.       with Inline;
   282.
   283.    procedure push (the_pair : in KDF9.pair)
   284.       with Inline;
   285.
   286.
   287.    --
   288.    -- The SJNS.
   289.    --
   290.
   291.    type SJNS_depth is mod 17;
   292.
   293.    type SJNS is array (KDF9.SJNS_depth) of KDF9.SJNS_link;
   294.
   295.    the_SJNS       : KDF9.SJNS;
   296.    JB             : KDF9.SJNS_link renames the_SJNS(16);
   297.    the_SJNS_depth : KDF9.SJNS_depth := 0;
   298.
   299.    procedure ensure_that_the_SJNS_is_not_empty
   300.       with Inline;
   301.
   302.    function pop
   303.    return KDF9.syllable_address
   304.       with Inline;
   305.
   306.    function SJNS_top
   307.    return KDF9.SJNS_link
   308.       with Inline;
   309.
   310.    procedure ensure_that_the_SJNS_is_not_full
   311.       with Inline;
   312.
   313.    procedure push (the_link : in KDF9.syllable_address)
   314.       with Inline;
   315.
   316.
   317.    --
   318.    -- The Q Store.
   319.    -- Q0 is kept permanently zeroised.
   320.    --
   321.
   322.    type Q_store is array (KDF9.Q_number) of KDF9.Q_register;
   323.
   324.    the_Q_store : KDF9.Q_store;
   325.
   326.
   327.    --
   328.    -- The Boolean registers.
   329.    --
   330.
   331.    the_V_bit_is_set : Boolean := False;
   332.    the_T_bit_is_set : Boolean := False;
   333.
   334.
   335.    --
   336.    --
   337.    -- The following are to do with maintaining the virtual time.
   338.    --
   339.    --
   340.
   341.    type us is mod 2**64;  -- The emulation clocks tick in microseconds (unlike KDF9's clock).
   342.
   343.    -- The virtual processor time.
   344.
   345.    the_CPU_time  : KDF9.us := 0;
   346.
   347.    -- The amount by which the_CPU_time is increased by an instruction execution.
   348.
   349.    the_CPU_delta : KDF9.us := 0;
   350.
   351.    -- The virtual elapsed time, capped to prevent a spurious double-clock (RESET) interrupt.
   352.
   353.    function the_clock_time
   354.    return KDF9.us
   355.       with Inline;
   356.
   357.    -- Advance to the largest of the_CPU_time, the_elapsed_time, the_last_delay_time, and past.
   358.    -- Cap the increase to prevent a spurious double-clock (RESET) interrupt in Director.
   359.    -- If necessary, pause execution until the real time equals the virtual elapsed time.
   360.
   361.    procedure advance_the_clock (past : in KDF9.us);
   362.
   363.    -- The virtual clock time at which the next IO interrupt is expected.
   364.
   365.    the_next_interrupt_time : KDF9.us := KDF9.us'Last;
   366.
   367.    -- Pause execution for the_delay_time in virtual microseconds.
   368.
   369.    procedure delay_by (the_delay_time : in KDF9.us);
   370.
   371.    -- If necessary, pause execution until the real time equals the virtual elapsed time.
   372.
   373.    procedure synchronize_the_real_and_virtual_times;
   374.
   375. ------------------------------------------------------------------------------------------------
   376.
   377.    --
   378.    --
   379.    -- The following registers are used only in Director state.
   380.    --
   381.    --
   382.
   383.
   384.    --
   385.    -- The following are to do with the K1 order.
   386.    --
   387.
   388.    type priority is mod 2**2;
   389.
   390.    -- CPL = priority level of the currently-executing problem program.
   391.
   392.    CPL : KDF9.priority;
   393.
   394.    -- BA = word address of first allocated word (NOT group number as in the KDF9).
   395.
   396.    BA  : KDF9.address;
   397.
   398.    -- NOL = word address of last allocated word (NOT group number as in the KDF9).
   399.
   400.    NOL : KDF9.address;
   401.
   402.    -- Set BA (setting bits D38:47), CPL (D34:35) and NOL (D24:33).
   403.
   404.    procedure set_K1_register (setting : in KDF9.word);
   405.
   406.
   407.    --
   408.    -- The following are to do with the =K2 order.
   409.    --
   410.
   411.    -- The Current Peripheral Device Allocation Register.
   412.
   413.    type CPDAR is array (KDF9.buffer_number) of Boolean
   414.       with Component_Size => 8, Convention => C;
   415.
   416.    the_CPDAR : KDF9.CPDAR;
   417.
   418.    -- Set CPDAR (setting bits D32 .. D47).
   419.
   420.    procedure set_K2_register (setting : in KDF9.word);
   421.
   422.
   423.    --
   424.    -- The following are to do with the =K3 and K7 orders.
   425.    --
   426.
   427.    type user_register_set is
   428.       record
   429.          NEST     : KDF9.NEST;
   430.          SJNS     : KDF9.SJNS;
   431.          Q_store  : KDF9.Q_store;
   432.       end record;
   433.
   434.
   435.    -- There are 4 sets of user registers.
   436.    -- The execution context is the number of the register set in active use.
   437.
   438.    type context is mod 2**2;
   439.
   440.    -- register_bank holds the currently inactive register sets.
   441.
   442.    register_bank : array(KDF9.context) of KDF9.user_register_set;
   443.
   444.    -- KDF9 actually indexed the register bank with the value of the_context,
   445.    --   but the emulator swaps register sets between register_bank and
   446.    --      the_NEST, the_SJNS, and the_Q_store (q.v.).
   447.
   448.    the_context : KDF9.context := 0;
   449.
   450.    -- Set context (bits D46:47), NEST_depth (D41:45) and SJNS_depth (D36:41).
   451.
   452.    procedure set_K3_register (setting : in KDF9.word);
   453.
   454.    -- Get BA (bits D0 .. D9), CPL (D12 .. D13) and NOL (D14 .. D23).
   455.
   456.    function get_K7_operand
   457.    return KDF9.word;
   458.
   459.
   460.    --
   461.    -- The following are to do with the K4 order.
   462.    --
   463.
   464.    type interrupt_number is range 22 .. 31;
   465.
   466.    -- higher PRiority PRogram unblocked by end of I/O, or INTQq on busy device
   467.    caused_by_PR    : constant KDF9.interrupt_number := 22;
   468.    PR_exception    : exception;
   469.
   470.    -- FLEXowriter interrupt from operator
   471.    caused_by_FLEX  : constant KDF9.interrupt_number := 23;
   472.    FLEX_exception  : exception;
   473.
   474.    -- Lock-In Violation (attempt at a disallowed operation)
   475.    caused_by_LIV   : constant KDF9.interrupt_number := 24;
   476.    LIV_exception   : exception;
   477.
   478.    -- Nest (or SJNS) Over/Underflow Violation
   479.    caused_by_NOUV  : constant KDF9.interrupt_number := 25;
   480.    NOUV_exception  : exception;
   481.
   482.    -- End of Director Transfer, or I/O priority inversion
   483.    caused_by_EDT   : constant KDF9.interrupt_number := 26;
   484.    EDT_exception   : exception;
   485.
   486.    -- OUT system call
   487.    caused_by_OUT   : constant KDF9.interrupt_number := 27;
   488.    OUT_exception   : exception;
   489.
   490.    -- Lock-Out Violation
   491.    caused_by_LOV   : constant KDF9.interrupt_number := 28;
   492.    LOV_exception   : exception;
   493.
   494.    -- invalid syllable number or 'double-clock'
   495.    caused_by_RESET : constant KDF9.interrupt_number := 29;
   496.    RESET_exception : exception;
   497.
   498.    type RFIR is array (KDF9.interrupt_number) of Boolean;
   499.
   500.    the_RFIR : KDF9.RFIR := (others => False);
   501.
   502.    -- The time at which the last K4 order was executed.
   503.    the_last_K4_time : KDF9.us := 0;
   504.
   505.    -- Get clock (bits D0:15) and RFIR (D16:31), clearing both.
   506.    function get_K4_operand
   507.    return KDF9.word
   508.       with Inline => False;
   509.
   510.    -- An interrupt is raised when 1 second expires outside Director;
   511.    --    the flag does not correspond to any RFIR bit.
   512.    caused_by_CLOCK : constant KDF9.interrupt_number := 31;
   513.    CLOCK_exception : exception;
   514.
   515.    -- This is for tracing a return from Director;
   516.    --    the flag does not correspond to any RFIR bit.
   517.    EXITD_flag : constant KDF9.interrupt_number := 30;
   518.
   519.    -- abandon_this_order is raised
   520.    -- 1. when an interrupt is punted to Director
   521.    -- OR
   522.    -- 2. when an operation is attempted, in a program running under Director,
   523.    --    that is invalid but is not defined to cause a LIV interrupt.
   524.    abandon_this_order : exception;
   525.
   526.    --
   527.    -- The following are to do with the K5 order.
   528.    --
   529.
   530.    -- The Program Hold-Up register is internal to I/O Control.
   531.    -- Get PHUi (bits D6i .. 6i+5), i = 0 .. 3.
   532.
   533.    function get_K5_operand
   534.    return KDF9.word;
   535.
   536.
   537.    --
   538.    -- The following are to do with management of the CPU's internal state.
   539.    --
   540.
   541.    type CPU_state is (Director_state, program_state);
   542.
   543.    the_CPU_state : KDF9.CPU_state;
   544.
   545.    procedure reset_V_and_T;
   546.
   547.    procedure reset_the_CPU_state;
   548.
   549.    procedure reset_the_internal_registers (the_new_state : in CPU_state);
   550.
   551.    procedure fail_in_problem_program_state;
   552.
   553.    procedure LOV_if_user_mode (cause : in String);
   554.
   555.    procedure return_from_Director_to (new_IAR : in KDF9.syllable_address);
   556.
   557.    procedure effect_interrupt (caused_by_this : in KDF9.interrupt_number; message : in String)
   558.       with Inline => False;
   559.
   560.    procedure check_for_a_clock_interrupt
   561.       with Inline;
   562.
   563.    procedure trap_illegal_instruction (the_message : in String := "invalid opcode")
   564.       with Inline => False;
   565.
   566.    procedure trap_operator_error (the_message : in String)
   567.       with Inline => False, No_Return;
   568.
   569.    procedure trap_unimplemented_feature (the_message : in String)
   570.       with Inline => False, No_Return;
   571.
   572.    procedure trap_failing_OUT (OUT_number : in KDF9.word; the_message : in String)
   573.       with Inline => False, No_Return;
   574.
   575.    procedure trap_invalid_paper_tape (the_message : in String)
   576.       with Inline => False, No_Return;
   577.
   578.    procedure reset_the_program_state;
   579.
   580.
   581.    --
   582.    --
   583.    -- Instruction fetch and decode.
   584.    --
   585.    --
   586.
   587.    -- These Instruction Address Registers are the nearest KDF9 has
   588.    --    to a conventional 'Program Counter' register.
   589.    -- NIA is significant only after an instruction has been decoded.
   590.
   591.    function NIA
   592.    return KDF9.syllable_address  -- the Next Instruction Address
   593.       with Inline;
   594.
   595.    function NIA_word_number
   596.    return KDF9.order_word_number
   597.       with Inline;
   598.
   599.    CIA : KDF9.syllable_address;  -- the Current Instruction Address
   600.
   601.    -- IWB0 and IWB1 in KDF9 contained the current 2 instruction words.
   602.    -- A 'short' loop, initiated by the JCqNZS instruction, ran entirely
   603.    --    inside the IWBs, obviating repeated instruction-fetch overhead.
   604.    -- Director exploits this in a loop that zeroizes the whole of core,
   605.    --    including that loop, which runs, immune to overwriting, in the IWBs.
   606.
   607.    procedure set_NIA_to (new_NIA : in KDF9.syllable_address)
   608.       with Inline;
   609.
   610.    procedure set_NIA_to_the_INS_target_address
   611.       with Inline;
   612.
   613.    procedure set_IWB0_and_IWB1_for_a_JCqNZS_loop
   614.       with Inline;
   615.
   616.    procedure go_back_to_the_start_of_IWB0
   617.       with Inline;
   618.
   619.    procedure continue_after_JCqNZS
   620.       with Inline;
   621.
   622.    -- Bits 0-1 of every order indicate its type as follows.
   623.
   624.    type INS_kind is mod 2**2;
   625.
   626.    one_syllable_order : constant := 0;
   627.    two_syllable_order : constant := 1;
   628.    normal_jump_order  : constant := 2;
   629.    data_access_order  : constant := 3;
   630.
   631.    type decoded_order is
   632.       record
   633.          order : KDF9.syllable_group := (0, 0, 0);
   634.          kind  : KDF9.INS_kind := 0;
   635.
   636.          -- The compressed_opcode is:
   637.          --    bits 2-7 of 1- and 2-syllable orders
   638.          --    bits 2-3|8-11 of normal jumps
   639.          --    bits 5-7 of SET and directly-addressed store access orders.
   640.          -- See the KDF9.decoding package.
   641.          compressed_opcode : KDF9.compressed_opcode := 0;
   642.
   643.           -- Qq is bits 8-11, Qk is bits 12-15.
   644.          Qq, Qk : KDF9.Q_number := 0;
   645.
   646.          -- For an jump instruction, syllable_index is bits 5-7.
   647.          target : KDF9.syllable_address;
   648.
   649.          -- For a data address or value (SET), operand is bits 2-4|12-23.
   650.          operand : KDF9.Q_part := 0;
   651.       end record;
   652.
   653.    INS : KDF9.decoded_order;  -- analogous to the INS register in Main Control
   654.
   655.    -- After decode_the_next_order:
   656.    --    INS contains the whole instruction at the address given by CIA,
   657.    --       with its components unpacked (not all are significant in every case).
   658.
   659.    procedure decode_the_next_order
   660.       with Inline;
   661.
   662.    procedure decode (the_order : in out KDF9.decoded_order)
   663.       with Inline;
   664.
   665.    procedure process_syllable_0_of_INS
   666.       with Inline;
   667.
   668.    procedure process_syllable_1_of_INS
   669.       with Inline;
   670.
   671.    procedure process_syllables_1_and_2_of_a_jump_order
   672.       with Inline;
   673.
   674.    procedure process_syllables_1_and_2_of_a_data_access_order
   675.       with Inline;
   676.
   677.    -- the_order_at_NIA gets three syllables starting at [NIA].
   678.    -- It is FOR DIAGNOSTIC USE ONLY!
   679.    -- It does NOT update the CPU time properly and must not be used inside an instruction cycle!
   680.
   681.    function the_order_at_NIA
   682.    return KDF9.syllable_group
   683.       with Inline;
   684.
   685.    -- Save E0U, lest the initial jump in E0 be corrupted during the run.
   686.    procedure save_the_initial_jump;
   687.
   688.    -- Restore E0U to its saved value.
   689.    procedure restore_the_initial_jump;
   690.
   691.    -- Check whether E0U has changed.
   692.    function the_initial_jump_was_corrupted
   693.    return Boolean;
   694.
   695.    -- True if the parameter is not a valid KDF9 instruction.
   696.
   697.    function is_an_invalid_order (decoded : KDF9.decoded_order)
   698.    return Boolean;
   699.
   700.
   701.    --
   702.    -- The Instruction Counter Register, ICR, (N.B. NOT a 'PROGRAM counter')
   703.    --   indicates the number of instructions executed by the KDF9.
   704.    --
   705.
   706.    type order_counter is mod 2**64;
   707.
   708.    ICR : KDF9.order_counter := 0;
   709.
   710.
   711.    --
   712.    -- The following support hashed execution-signature checking,
   713.    --    mainly for self-checking of new versions and ports.
   714.    --
   715.
   716.    function the_digital_signature
   717.    return KDF9.word;
   718.
   719.    procedure update_the_digital_signature
   720.       with Inline;
   721.
   722. private
   723.
   724.    the_elapsed_time    : KDF9.us := 0;
   725.    the_last_delay_time : KDF9.us := 0;
   726.
   727.    fetching_normally   : Boolean := True;
   728.
   729. end KDF9;

 1030 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-microcode.adb
Source file time stamp: 2021-02-20 23:56:00
Compiled at: 2021-02-21 15:54:06

     1. -- KDF9 ISP emulation - CPU microcode routines.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with break_in;
    18. with exceptions;
    19. with IOC;
    20. with IOC.dispatcher;
    21. with KDF9.CPU;
    22. with KDF9.decoding;
    23. with KDF9.EGDON;
    24. with KDF9.store;
    25. with KDF9.TSD;
    26. with KDF9.TSD.processes;
    27. with POSIX;
    28. with settings;
    29. with state_display;
    30. with tracing;
    31.
    32. use  exceptions;
    33. use  IOC;
    34. use  IOC.dispatcher;
    35. use  KDF9.CPU;
    36. use  KDF9.decoding;
    37. use  KDF9.EGDON;
    38. use  KDF9.store;
    39. use  KDF9.TSD;
    40. use  KDF9.TSD.processes;
    41. use  settings;
    42. use  state_display;
    43. use  tracing;
    44.
    45. package body KDF9.microcode is
    46.
    47.    procedure do_a_one_syllable_order is
    48.       A, B, C, E : KDF9.word;
    49.       bit_count  : KDF9.word;
    50.       AB, CD     : KDF9.pair;
    51.       X, Y       : CPU.f48;
    52.       XY, ZT     : CPU.f96;
    53.    begin
    54.       case INS.compressed_opcode is
    55.
    56.          when 0 =>
    57.             -- The DUMMY order originally had code 0, before being changed to #17.
    58.             -- The Kidsgrove compiler continued to use code 0, so we must assume that,
    59.             --    despite the Manual, 0 continued to be a valid no-op order.
    60.             the_CPU_delta := the_CPU_delta + 1;
    61.
    62.          when VR =>
    63.             the_V_bit_is_set := False;
    64.             the_CPU_delta := the_CPU_delta + 1;
    65.
    66.          when TO_TR =>
    67.             ensure_that_the_NEST_holds_an_operand;
    68.             if resign(pop) < 0 then
    69.                the_T_bit_is_set := True;
    70.             end if;
    71.             the_CPU_delta := the_CPU_delta + 2;
    72.
    73.          when BITS =>
    74.             write_top(cardinality(read_top));
    75.             the_CPU_delta := the_CPU_delta + 27;
    76.
    77.          when XF =>
    78.             ensure_that_the_NEST_holds_2_operands;
    79.             X := pop;
    80.             Y := read_top;
    81.             write_top(CPU.f48'(Y * X));
    82.             the_CPU_delta := the_CPU_delta + 15;
    83.
    84.          when XDF =>
    85.             ensure_that_the_NEST_holds_2_operands;
    86.             XY := read_top;
    87.             ZT := XY.lsw * XY.msw;
    88.             write_top(ZT);
    89.             the_CPU_delta := the_CPU_delta + 16;
    90.
    91.          when XPLUSF =>
    92.             ensure_that_the_NEST_holds(at_least => 4);
    93.             XY := pop;
    94.             ZT := XY.lsw * XY.msw;
    95.             XY := read_top;
    96.             write_top(XY + ZT);
    97.             the_CPU_delta := the_CPU_delta + 18;
    98.
    99.          when NEGD =>
   100.             AB := read_top;
   101.             write_top( - AB);
   102.             the_CPU_delta := the_CPU_delta + 2;
   103.
   104.          when OR_9 =>
   105.             ensure_that_the_NEST_holds_2_operands;
   106.             A := pop;
   107.             write_top(read_top or A);
   108.             the_CPU_delta := the_CPU_delta + 1;
   109.
   110.          when PERM =>
   111.             A := pop;
   112.             CD := pop;
   113.             push(A);
   114.             push(CD);
   115.             the_CPU_delta := the_CPU_delta + 2;
   116.
   117.          when TOB =>
   118.             ensure_that_the_NEST_holds_2_operands;
   119.             A := pop;      -- the value
   120.             bit_count := cardinality(A);
   121.             B := read_top; -- the radixes
   122.             C := 0;
   123.
   124.             for i in 1 .. 8 loop
   125.                A := rotate_word_left(A, 6);
   126.                B := rotate_word_left(B, 6);
   127.                E := B and 8#77#; -- this radix
   128.                C := C*E + (A and 8#77#);
   129.             end loop;
   130.
   131.             write_top(C);
   132.             the_CPU_delta := the_CPU_delta + 2 + 4*KDF9.us(bit_count);
   133.
   134.          when ROUNDH =>
   135.             A := read_top;
   136.             write_top(resign(A) + 2**23);
   137.             the_CPU_delta := the_CPU_delta + 22;
   138.
   139.          when NEV =>
   140.             ensure_that_the_NEST_holds_2_operands;
   141.             A := pop;
   142.             write_top(read_top xor A);
   143.             the_CPU_delta := the_CPU_delta + 2;
   144.
   145.          when ROUND =>
   146.             ensure_that_the_NEST_holds_2_operands;
   147.             A := pop;
   148.             write_top(resign(A) + resign(shift_word_right(read_top, 46) and 1));
   149.             the_CPU_delta := the_CPU_delta + 1;
   150.
   151.          when DUMMY =>
   152.             the_CPU_delta := the_CPU_delta + 1;
   153.
   154.          when ROUNDF =>
   155.             ensure_that_the_NEST_holds_2_operands;
   156.             XY := pop;
   157.             ZT := XY;
   158.             push(narrowed(XY));
   159.             the_CPU_delta := the_CPU_delta + 3;
   160.
   161.          when ROUNDHF =>
   162.             X := pop;
   163.             push(narrowed(X));
   164.             the_CPU_delta := the_CPU_delta + 3;
   165.
   166.          when MINUSDF =>
   167.             ensure_that_the_NEST_holds(at_least => 4);
   168.             XY := pop;
   169.             ZT := read_top;
   170.             write_top(ZT - XY);
   171.             the_CPU_delta := the_CPU_delta + 12;
   172.
   173.          when PLUSDF =>
   174.             ensure_that_the_NEST_holds(at_least => 4);
   175.             XY := pop;
   176.             ZT := read_top;
   177.             write_top(ZT + XY);
   178.             the_CPU_delta := the_CPU_delta + 12;
   179.
   180.          when FLOAT_9 =>
   181.             ensure_that_the_NEST_holds_2_operands;
   182.             -- There is great uncertainty as to how the FLOAT/FLOATD orders handled scale factors
   183.             --   in N1 that lie outside the range allowed by the Manual, namely -128 <= N1 <= +127.
   184.             -- ee9 here takes a safety-first approach which is consistent with the
   185.             --    behaviour of the Kidsgrove sqrt function with arguments < 0.50.
   186.             A := shift_arithmetic(shift_logical(pop, +40), -40);
   187.             B := read_top;
   188.             write_top(KDF9.word(normalized(full_fraction => B, scaler => A)));
   189.
   190.          when FLOATD =>
   191.             ensure_that_the_NEST_holds(at_least => 3);
   192.             A := shift_arithmetic(shift_logical(pop, +40), -40);
   193.             CD := read_top;
   194.             -- See 3.4 of Report K/GD.y.83, dated 6/12/1962.  It would seem to require this:
   195.             -- CD.lsw := CD.lsw and not 8#77#;  -- The 6 l.s.b. are lost.
   196.             -- The above is commented out because it gives the wrong answer with KAA01.
   197.             -- A post-document hardware modification is suspected.
   198.             reconstruct(CD, scaler => A);
   199.             write_top(CD);
   200.             the_CPU_delta := the_CPU_delta + 8;
   201.
   202.          when ABS_9 =>
   203.             write_top( abs resign(read_top));
   204.             the_CPU_delta := the_CPU_delta + 1;
   205.
   206.          when NEG =>
   207.             write_top( - resign(read_top));
   208.             the_CPU_delta := the_CPU_delta + 1;
   209.
   210.          when ABSF =>
   211.             X := read_top;
   212.             if resign(KDF9.word(X)) < 0 then
   213.                write_top( - X);
   214.                the_CPU_delta := the_CPU_delta + 4;
   215.             else
   216.                the_CPU_delta := the_CPU_delta + 1;
   217.             end if;
   218.
   219.          when NEGF =>
   220.             X := read_top;
   221.             write_top( - X);
   222.             the_CPU_delta := the_CPU_delta + 3;
   223.
   224.          when MAX =>
   225.             AB := read_top;
   226.             if resign(AB.lsw) >= resign(AB.msw) then
   227.                write_top(KDF9.pair'(msw => AB.lsw, lsw =>AB.msw));
   228.                the_V_bit_is_set := True;
   229.             end if;
   230.             the_CPU_delta := the_CPU_delta + 4;
   231.
   232.          when NOT_9 =>
   233.             A := read_top;
   234.             write_top(not A);
   235.             the_CPU_delta := the_CPU_delta + 1;
   236.
   237.          when XD =>
   238.             AB := read_top;
   239.             CD := AB.msw * AB.lsw;
   240.             write_top(CD);
   241.             the_CPU_delta := the_CPU_delta + 14;
   242.
   243.          when X_frac =>
   244.             ensure_that_the_NEST_holds_2_operands;
   245.             A := pop;
   246.             write_top(as_word(CPU.fraction'(read_top * A)));
   247.             the_CPU_delta := the_CPU_delta + 15;
   248.
   249.          when MINUS =>
   250.             ensure_that_the_NEST_holds_2_operands;
   251.             A := pop;
   252.             B := read_top;
   253.             write_top(resign(B) - resign(A));
   254.             the_CPU_delta := the_CPU_delta + 1;
   255.
   256.          when SIGN =>
   257.             ensure_that_the_NEST_holds_2_operands;
   258.             A := pop;
   259.             B := read_top;
   260.             if B = A then
   261.                write_top(KDF9.word'(0));
   262.             elsif resign(B) > resign(A) then
   263.                write_top(KDF9.word'(1));
   264.             else
   265.                write_top(all_one_bits);
   266.             end if;
   267.             the_CPU_delta := the_CPU_delta + 3;
   268.
   269.          when ZERO =>
   270.             ensure_that_the_NEST_has_room_for_a_result;
   271.             push(all_zero_bits);
   272.             the_CPU_delta := the_CPU_delta + 2;
   273.
   274.          when DUP =>
   275.             ensure_that_the_NEST_has_room_for_a_result;
   276.             A := read_top;
   277.             push(A);
   278.             the_CPU_delta := the_CPU_delta + 2;
   279.
   280.          when DUPD =>
   281.             ensure_that_the_NEST_has_room_for_2_results;
   282.             AB := read_top;
   283.             push(AB);
   284.             the_CPU_delta := the_CPU_delta + 4;
   285.
   286.          when DIVI =>
   287.             AB := read_top;
   288.             do_DIVI(L => AB.lsw,
   289.                     R => AB.msw,
   290.                     Quotient  => CD.lsw,
   291.                     Remainder => CD.msw);
   292.             write_top(CD);
   293.             the_CPU_delta := the_CPU_delta + 36;
   294.
   295.          when FIX =>
   296.             ensure_that_the_NEST_holds_an_operand;
   297.             ensure_that_the_NEST_has_room_for_a_result;
   298.             X := read_top;
   299.             write_top(fraction_word(X));
   300.             push(scaler(X));
   301.             the_CPU_delta := the_CPU_delta + 6;
   302.
   303.          when STR =>
   304.             ensure_that_the_NEST_has_room_for_a_result;
   305.             A := read_top;
   306.             if resign(A) < 0 then
   307.                write_top(A and not_sign_bit);
   308.                push(all_one_bits);
   309.             else
   310.                push(all_zero_bits);
   311.             end if;
   312.             the_CPU_delta := the_CPU_delta + 3;
   313.
   314.          when CONT =>
   315.             ensure_that_the_NEST_holds_2_operands;
   316.             A := pop;
   317.             B := read_top;
   318.             write_top(contracted(msw => A, lsw => B));
   319.             the_CPU_delta := the_CPU_delta + 2;
   320.
   321.          when REVD =>
   322.             AB := pop;
   323.             CD := pop;
   324.             push(AB);
   325.             push(CD);
   326.             the_CPU_delta := the_CPU_delta + 4;
   327.
   328.          when ERASE =>
   329.             ensure_that_the_NEST_holds_an_operand;
   330.             pop;
   331.             the_CPU_delta := the_CPU_delta + 1;
   332.
   333.          when MINUSD =>
   334.             ensure_that_the_NEST_holds(at_least => 4);
   335.             AB := pop;
   336.             CD := read_top;
   337.             write_top(CD - AB);
   338.             the_CPU_delta := the_CPU_delta + 3;
   339.
   340.          when AND_9 =>
   341.             ensure_that_the_NEST_holds_2_operands;
   342.             A := pop;
   343.             write_top(read_top and A);
   344.             the_CPU_delta := the_CPU_delta + 1;
   345.
   346.          when PLUS =>
   347.             ensure_that_the_NEST_holds_2_operands;
   348.             A := pop;
   349.             B := read_top;
   350.             write_top(resign(B) + resign(A));
   351.             the_CPU_delta := the_CPU_delta + 1;
   352.
   353.          when PLUSD =>
   354.             ensure_that_the_NEST_holds(at_least => 4);
   355.             AB := pop;
   356.             CD := read_top;
   357.             write_top(CD + AB);
   358.             the_CPU_delta := the_CPU_delta + 3;
   359.
   360.          when DIV =>
   361.             ensure_that_the_NEST_holds_2_operands;
   362.             AB := pop;
   363.             push(as_word(CPU.fraction'(AB.lsw / AB.msw)));
   364.             the_CPU_delta := the_CPU_delta + 36;
   365.
   366.          when DIVD =>
   367.             ensure_that_the_NEST_holds(at_least => 3);
   368.             A := pop;
   369.             CD := pop;
   370.             do_DIVD(L => CD,
   371.                     R => A,
   372.                     Q => E);
   373.             push(E);
   374.             the_CPU_delta := the_CPU_delta + 36;
   375.
   376.          when DIVF =>
   377.             X := pop;
   378.             Y := read_top;
   379.             write_top(Y / X);
   380.             the_CPU_delta := the_CPU_delta + 36;
   381.
   382.          when DIVDF =>
   383.             ensure_that_the_NEST_holds(at_least => 3);
   384.             Y := pop;
   385.             XY := pop;
   386.             push(XY / Y);
   387.             the_CPU_delta := the_CPU_delta + 35;
   388.
   389.          when DIVR =>
   390.             ensure_that_the_NEST_holds(at_least => 3);
   391.             A := pop;
   392.             CD := read_top;
   393.             do_DIVR(L => CD,
   394.                     R => A,
   395.                     Quotient  => AB.msw,
   396.                     Remainder => AB.lsw);
   397.             write_top(AB);
   398.             the_CPU_delta := the_CPU_delta + 36;
   399.
   400.          when REV =>
   401.             AB := read_top;
   402.             write_top(KDF9.pair'(msw => AB.lsw, lsw =>AB.msw));
   403.             the_CPU_delta := the_CPU_delta + 1;
   404.
   405.          when CAB =>
   406.             AB := pop;
   407.             C := pop;
   408.             push(AB);
   409.             push(C);
   410.             the_CPU_delta := the_CPU_delta + 2;
   411.
   412.          when FRB =>
   413.             ensure_that_the_NEST_holds_2_operands;
   414.             A := pop;      -- the value
   415.             bit_count := cardinality(A);
   416.             B := read_top; -- the radixes
   417.             C := 0;
   418.
   419.             for i in 1 .. 8 loop
   420.                E := B and 8#77#;
   421.                if E /= 0 then
   422.                   C := C or (A mod E);
   423.                   A := A / E;
   424.                else
   425.                   if A /= 0 then the_V_bit_is_set := True; end if;
   426.                end if;
   427.                B := shift_word_right(B, 6);
   428.                C := rotate_word_right(C, 6);
   429.             end loop;
   430.
   431.             if A /= 0 then
   432.                -- The value was too big for the representation; see Manual.
   433.                the_V_bit_is_set := True;
   434.             end if;
   435.             write_top(C);
   436.             the_CPU_delta := the_CPU_delta + 8 + 3*KDF9.us(bit_count);
   437.
   438.          when STAND =>
   439.             X := read_top;
   440.             write_top(normalized(X));
   441.             the_CPU_delta := the_CPU_delta + 5;
   442.
   443.          when NEGDF =>
   444.             XY := read_top;
   445.             write_top( - XY);
   446.             the_CPU_delta := the_CPU_delta + 9;
   447.
   448.          when MAXF =>
   449.             XY := read_top;
   450.             if XY.lsw >= XY.msw then
   451.                write_top(CPU.f96'(msw => XY.lsw, lsw =>XY.msw));
   452.                the_V_bit_is_set := True;
   453.             end if;
   454.             the_CPU_delta := the_CPU_delta + 6;
   455.
   456.          when PLUSF =>
   457.             ensure_that_the_NEST_holds_2_operands;
   458.             X := pop;
   459.             Y := read_top;
   460.             write_top(Y + X);
   461.             the_CPU_delta := the_CPU_delta + 7;
   462.
   463.          when MINUSF =>
   464.             ensure_that_the_NEST_holds_2_operands;
   465.             X := pop;
   466.             Y := read_top;
   467.             write_top(Y - X);
   468.             the_CPU_delta := the_CPU_delta + 7;
   469.
   470.          when SIGNF =>
   471.             ensure_that_the_NEST_holds_2_operands;
   472.             XY := pop;
   473.             if KDF9.word(XY.lsw) = KDF9.word(XY.msw) then
   474.                push(all_zero_bits);
   475.             elsif XY.lsw < XY.msw then
   476.                push(all_one_bits);
   477.             else
   478.                push(KDF9.word(1));
   479.             end if;
   480.             the_CPU_delta := the_CPU_delta + 5;
   481.
   482.          when others =>
   483.             trap_illegal_instruction;
   484.
   485.       end case;
   486.    end do_a_one_syllable_order;
   487.
   488.
   489.    procedure do_an_IO_order is
   490.       IO_opcode   : constant KDF9.compressed_opcode := (INS.Qk and not manual_bit);
   491.       IO_operand  : constant KDF9.Q_register := the_Q_store(INS.Qq);
   492.       set_offline : constant Boolean         := (INS.Qk and manual_bit) /= 0;
   493.    begin
   494.       case INS.compressed_opcode is
   495.
   496.          when PAR_Qq =>
   497.             the_CPU_delta := the_CPU_delta + 11;
   498.             PAR(IO_operand, set_offline, the_T_bit_is_set);
   499.             the_CPU_delta := the_CPU_delta + 3;
   500.
   501.          when PIA_PIC_CLO_TLO_Qq =>
   502.             the_CPU_delta := the_CPU_delta + 15;
   503.             case IO_opcode is
   504.                when PIA_bits =>
   505.                   PIA(IO_operand, set_offline);
   506.                   the_CPU_delta := the_CPU_delta + 7;
   507.                when PIC_bits =>
   508.                   PIC(IO_operand, set_offline);
   509.                   the_CPU_delta := the_CPU_delta + 7;
   510.                when CLO_bits =>
   511.                   fail_in_problem_program_state;
   512.                   CLO(IO_operand, set_offline);
   513.                   the_CPU_delta := the_CPU_delta + 1;
   514.                when TLO_bits =>
   515.                   TLO(IO_operand, the_T_bit_is_set);
   516.                when others =>
   517.                   trap_illegal_instruction;
   518.             end case;
   519.
   520.          when PIB_PID_Qq =>
   521.             the_CPU_delta := the_CPU_delta + 15;
   522.             case IO_opcode is
   523.                when PIB_bits =>
   524.                   PIB(IO_operand, set_offline);
   525.                   the_CPU_delta := the_CPU_delta + 7;
   526.                when PID_bits =>
   527.                   PID(IO_operand, set_offline);
   528.                   the_CPU_delta := the_CPU_delta + 7;
   529.                when others =>
   530.                   trap_illegal_instruction;
   531.             end case;
   532.
   533.          when PIE_PIG_Qq =>
   534.             the_CPU_delta := the_CPU_delta + 15;
   535.             case IO_opcode is
   536.                when PIE_bits =>
   537.                   PIE(IO_operand, set_offline);
   538.                   the_CPU_delta := the_CPU_delta + 7;
   539.                when PIG_bits =>
   540.                   PIG(IO_operand, set_offline);
   541.                   the_CPU_delta := the_CPU_delta + 7;
   542.                when others =>
   543.                   trap_illegal_instruction;
   544.             end case;
   545.
   546.          when PIF_PIH_Qq =>
   547.             the_CPU_delta := the_CPU_delta + 15;
   548.             case IO_opcode is
   549.                when PIF_bits =>
   550.                   PIF(IO_operand, set_offline);
   551.                   the_CPU_delta := the_CPU_delta + 7;
   552.                when PIH_bits =>
   553.                   PIH(IO_operand, set_offline);
   554.                   the_CPU_delta := the_CPU_delta + 7;
   555.                when others =>
   556.                   trap_illegal_instruction;
   557.             end case;
   558.
   559.          when PMA_PMK_INT_Qq =>
   560.             the_CPU_delta := the_CPU_delta + 11;
   561.             case IO_opcode is
   562.                when PMA_bits =>
   563.                   PMA(IO_operand, set_offline);
   564.                when PMK_bits =>
   565.                   PMK(IO_operand, set_offline);
   566.                when INT_bits =>
   567.                   INT(IO_operand, set_offline);
   568.                when others =>
   569.                   trap_illegal_instruction;
   570.             end case;
   571.
   572.          when CT_PMB_PMC_BUSY_Qq =>
   573.             the_CPU_delta := the_CPU_delta + 11;
   574.             case IO_opcode is
   575.                when CTQ_bits =>
   576.                   -- if set_offline then MANUALQq else CTQq
   577.                   if set_offline                      or else
   578.                         the_CPU_state = Director_state   then
   579.                      MANUAL_CT(IO_operand, set_offline);
   580.                      the_CPU_delta := the_CPU_delta + 2;
   581.                   else
   582.                      trap_illegal_instruction; -- This will always LIV, as we are not in Director.
   583.                   end if;
   584.                when PMB_bits =>
   585.                   PMB(IO_operand, set_offline);
   586.                   the_CPU_delta := the_CPU_delta + 3;
   587.                when PMC_bits =>
   588.                   PMC(IO_operand, set_offline);
   589.                   the_CPU_delta := the_CPU_delta + 3;
   590.                when BUSY_bits =>
   591.                   BUSY(IO_operand, set_offline, the_T_bit_is_set);
   592.                   the_CPU_delta := the_CPU_delta + 2;
   593.                when others =>
   594.                   trap_illegal_instruction;
   595.             end case;
   596.
   597.          when PMD_PME_PML_Qq =>
   598.             the_CPU_delta := the_CPU_delta + 14;
   599.             case IO_opcode is
   600.                when PMD_bits =>
   601.                   PMD(IO_operand, set_offline);
   602.                   the_CPU_delta := the_CPU_delta + 5;
   603.                when PME_bits =>
   604.                   PME(IO_operand, set_offline);
   605.                   the_CPU_delta := the_CPU_delta + 5;
   606.                when PML_bits =>
   607.                   PML(IO_operand, set_offline);
   608.                   the_CPU_delta := the_CPU_delta + 5;
   609.                when others =>
   610.                   trap_illegal_instruction;
   611.             end case;
   612.
   613.          when PMF_PMG_Qq =>
   614.             the_CPU_delta := the_CPU_delta + 11;
   615.             case IO_opcode is
   616.                when PMF_bits =>
   617.                   PMF(IO_operand, set_offline);
   618.                   the_CPU_delta := the_CPU_delta + 3;
   619.                when PMG_bits =>
   620.                   fail_in_problem_program_state;
   621.                   the_CPU_delta := the_CPU_delta + 14;  -- ??
   622.                   PMG(IO_operand, set_offline);
   623.                 when others =>
   624.                   trap_illegal_instruction;
   625.             end case;
   626.
   627.          when POA_POC_POE_POF_PMH_Qq =>
   628.             the_CPU_delta := the_CPU_delta + 15;
   629.             case IO_opcode is
   630.                when POA_bits =>
   631.                   POA(IO_operand, set_offline);
   632.                   the_CPU_delta := the_CPU_delta + 7;
   633.                when POC_bits =>
   634.                   POC(IO_operand, set_offline);
   635.                   the_CPU_delta := the_CPU_delta + 7;
   636.                when POE_bits =>
   637.                   POE(IO_operand, set_offline);
   638.                   the_CPU_delta := the_CPU_delta + 4;
   639.                when POF_bits =>
   640.                   POF(IO_operand, set_offline);
   641.                   the_CPU_delta := the_CPU_delta + 4;
   642.                when PMH_bits =>
   643.                   fail_in_problem_program_state;
   644.                   SLO(IO_operand, set_offline);
   645.                   the_CPU_delta := the_CPU_delta + 1;
   646.                when others =>
   647.                   trap_illegal_instruction;
   648.             end case;
   649.
   650.          when POB_POD_Qq =>
   651.             the_CPU_delta := the_CPU_delta + 15;
   652.             case IO_opcode is
   653.                when POB_bits =>
   654.                   POB(IO_operand, set_offline);
   655.                   the_CPU_delta := the_CPU_delta + 7;
   656.                when POD_bits =>
   657.                   POD(IO_operand, set_offline);
   658.                   the_CPU_delta := the_CPU_delta + 7;
   659.                when others =>
   660.                   trap_illegal_instruction;
   661.             end case;
   662.
   663.          when POG_POL_Qq =>
   664.             the_CPU_delta := the_CPU_delta + 15;
   665.             case IO_opcode is
   666.                when POG_bits =>
   667.                   POG(IO_operand, set_offline);
   668.                   the_CPU_delta := the_CPU_delta + 7;
   669.                when POL_bits =>
   670.                   POL(IO_operand, set_offline);
   671.                   the_CPU_delta := the_CPU_delta + 7;
   672.                when others =>
   673.                   trap_illegal_instruction;
   674.             end case;
   675.
   676.          when POH_POK_Qq =>
   677.             the_CPU_delta := the_CPU_delta + 15;
   678.             case IO_opcode is
   679.                when POH_bits =>
   680.                   POH(IO_operand, set_offline);
   681.                   the_CPU_delta := the_CPU_delta + 7;
   682.                when POK_bits =>
   683.                   POK(IO_operand, set_offline);
   684.                   the_CPU_delta := the_CPU_delta + 7;
   685.                when others =>
   686.                   trap_illegal_instruction;
   687.             end case;
   688.
   689.          when others =>
   690.             trap_illegal_instruction;
   691.
   692.       end case;
   693.    end do_an_IO_order;
   694.
   695.
   696.    all_zero_Q_store : constant KDF9.Q_register := (C | I | M => 0);
   697.
   698.    procedure ensure_that_Q0_contains_zero (suspect : KDF9.Q_number)
   699.       with Inline;
   700.
   701.    procedure ensure_that_Q0_contains_zero (suspect : KDF9.Q_number) is
   702.    begin
   703.       if suspect = 0 then
   704.          the_Q_store(0) := all_zero_Q_store;  -- Override any assignment to Q0.
   705.       end if;
   706.    end ensure_that_Q0_contains_zero;
   707.
   708.    procedure auto_increment
   709.       with Inline;
   710.
   711.    procedure auto_increment is
   712.    begin
   713.       if INS.Qq /= 0 then
   714.          the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M + the_Q_store(INS.Qq).I;
   715.          the_Q_store(INS.Qq).C := the_Q_store(INS.Qq).C - 1;
   716.       end if;
   717.    end auto_increment;
   718.
   719.    function shift_count
   720.    return CPU.signed_Q_part
   721.       with Inline;
   722.
   723.    function shift_count
   724.    return CPU.signed_Q_part
   725.    is (
   726.        if (INS.order.syllable_1 and constant_bit) /= 0  then
   727.           resign(KDF9.Q_part(INS.order.syllable_1/2 xor 64)) - 64
   728.        else
   729.           resign((the_Q_store(INS.Qq).C and 255) xor 128) - 128
   730.       );
   731.
   732.
   733.    procedure do_a_two_syllable_order is
   734.       A  : KDF9.word;
   735.       AB : KDF9.pair;
   736.       CD : KDF9.pair;
   737.    begin
   738.       case INS.compressed_opcode is
   739.
   740.          when JCqNZS =>
   741.             if CIA.syllable_index = 5 then
   742.                -- KDF9 did not actually detect this error, and the JCqNZS instruction often worked,
   743.                --    unless broken-into by an interrupt, which returned to the word following that
   744.                --       containing the first syllable of the JCqNZS instruction.
   745.                -- I see no case for reproducing this behaviour.
   746.                trap_illegal_instruction ("JCqNZS instruction at syllable 5");
   747.             end if;
   748.             if the_Q_store(INS.Qq).C /= 0 then
   749.                if fetching_normally then
   750.                   set_IWB0_and_IWB1_for_a_JCqNZS_loop;
   751.                   the_CPU_delta := the_CPU_delta + 7;  -- Takes 11s the first time it jumps.
   752.                end if;
   753.                -- The IWBs now contain the loop, so go to syllable 0 of IWB0.
   754.                go_back_to_the_start_of_IWB0;
   755.             else
   756.                continue_after_JCqNZS;
   757.             end if;
   758.             the_CPU_delta := the_CPU_delta + 4;
   759.
   760.          when MkMq =>
   761.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   762.             check_address_and_lockout(the_trace_address);
   763.             ensure_that_the_NEST_has_room_for_a_result;
   764.             the_trace_operand := fetch_word(the_trace_address);
   765.             push(the_trace_operand);
   766.             the_CPU_delta := the_CPU_delta + 7;
   767.
   768.          when MkMqQ =>
   769.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   770.             check_address_and_lockout(the_trace_address);
   771.             ensure_that_the_NEST_has_room_for_a_result;
   772.             the_trace_operand := fetch_word(the_trace_address);
   773.             push(the_trace_operand);
   774.             auto_increment;
   775.             the_CPU_delta := the_CPU_delta + 8;
   776.
   777.          when MkMqH =>
   778.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   779.             check_address_and_lockout(the_trace_address);
   780.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   781.             ensure_that_the_NEST_has_room_for_a_result;
   782.             push(the_trace_operand);
   783.             the_CPU_delta := the_CPU_delta + 7;
   784.
   785.          when MkMqQH =>
   786.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   787.             check_address_and_lockout(the_trace_address);
   788.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   789.             ensure_that_the_NEST_has_room_for_a_result;
   790.             push(the_trace_operand);
   791.             auto_increment;
   792.             the_CPU_delta := the_CPU_delta + 8;
   793.
   794.          when MkMqN =>
   795.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   796.             check_address_and_lockout(the_trace_address);
   797.             ensure_that_the_NEST_has_room_for_a_result;
   798.             the_trace_operand := fetch_word(the_trace_address);
   799.             push(the_trace_operand);
   800.             the_CPU_delta := the_CPU_delta + 7;
   801.
   802.          when MkMqQN =>
   803.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   804.             check_address_and_lockout(the_trace_address);
   805.             ensure_that_the_NEST_has_room_for_a_result;
   806.             the_trace_operand := fetch_word(the_trace_address);
   807.             push(the_trace_operand);
   808.             auto_increment;
   809.             the_CPU_delta := the_CPU_delta + 8;
   810.
   811.          when MkMqHN =>
   812.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   813.             check_address_and_lockout(the_trace_address);
   814.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   815.             ensure_that_the_NEST_has_room_for_a_result;
   816.             push(the_trace_operand);
   817.             the_CPU_delta := the_CPU_delta + 7;
   818.
   819.          when MkMqQHN =>
   820.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   821.             check_address_and_lockout(the_trace_address);
   822.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   823.             ensure_that_the_NEST_has_room_for_a_result;
   824.             push(the_trace_operand);
   825.             auto_increment;
   826.             the_CPU_delta := the_CPU_delta + 8;
   827.
   828.          when TO_MkMq =>
   829.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   830.             check_address_and_lockout(the_trace_address);
   831.             ensure_that_the_NEST_holds_an_operand;
   832.             the_trace_operand := pop;
   833.             store_word(the_trace_operand, the_trace_address);
   834.             the_CPU_delta := the_CPU_delta + 7;
   835.
   836.          when TO_MkMqQ =>
   837.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   838.             check_address_and_lockout(the_trace_address);
   839.             ensure_that_the_NEST_holds_an_operand;
   840.             the_trace_operand := pop;
   841.             store_word(the_trace_operand, the_trace_address);
   842.             auto_increment;
   843.             the_CPU_delta := the_CPU_delta + 8;
   844.
   845.          when TO_MkMqH =>
   846.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   847.             check_address_and_lockout(the_trace_address);
   848.             ensure_that_the_NEST_holds_an_operand;
   849.             the_trace_operand := pop;
   850.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   851.             the_CPU_delta := the_CPU_delta + 7;
   852.
   853.          when TO_MkMqQH =>
   854.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   855.             check_address_and_lockout(the_trace_address);
   856.             ensure_that_the_NEST_holds_an_operand;
   857.             the_trace_operand := pop;
   858.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   859.             auto_increment;
   860.             the_CPU_delta := the_CPU_delta + 8;
   861.
   862.          when TO_MkMqN =>
   863.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   864.             check_address_and_lockout(the_trace_address);
   865.             ensure_that_the_NEST_holds_an_operand;
   866.             the_trace_operand := pop;
   867.             store_word(the_trace_operand, the_trace_address);
   868.             the_CPU_delta := the_CPU_delta + 7;
   869.
   870.          when TO_MkMqQN =>
   871.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   872.             check_address_and_lockout(the_trace_address);
   873.             ensure_that_the_NEST_holds_an_operand;
   874.             the_trace_operand := pop;
   875.             store_word(the_trace_operand, the_trace_address);
   876.             auto_increment;
   877.             the_CPU_delta := the_CPU_delta + 8;
   878.
   879.          when TO_MkMqHN =>
   880.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   881.             check_address_and_lockout(the_trace_address);
   882.             ensure_that_the_NEST_holds_an_operand;
   883.             the_trace_operand := pop;
   884.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   885.             the_CPU_delta := the_CPU_delta + 7;
   886.
   887.          when TO_MkMqQHN =>
   888.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   889.             check_address_and_lockout(the_trace_address);
   890.             ensure_that_the_NEST_holds_an_operand;
   891.             the_trace_operand := pop;
   892.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   893.             auto_increment;
   894.             the_CPU_delta := the_CPU_delta + 8;
   895.
   896.          when M_PLUS_Iq =>
   897.             the_CPU_delta := the_CPU_delta + 4;
   898.             the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M + the_Q_store(INS.Qq).I;
   899.
   900.          when M_MINUS_Iq =>
   901.             the_CPU_delta := the_CPU_delta + 5;
   902.             the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M - the_Q_store(INS.Qq).I;
   903.
   904.          when NCq =>
   905.             the_CPU_delta := the_CPU_delta + 5;
   906.             the_Q_store(INS.Qq).C := - the_Q_store(INS.Qq).C;
   907.
   908.          when DCq =>
   909.             the_CPU_delta := the_CPU_delta + 3;
   910.             if INS.Qq /= 0 then
   911.                the_Q_store(INS.Qq).C := the_Q_store(INS.Qq).C - 1;
   912.             end if;
   913.
   914.          when POS1_TO_Iq =>
   915.             the_CPU_delta := the_CPU_delta + 3;
   916.             if INS.Qq /= 0 then
   917.                the_Q_store(INS.Qq).I := + 1;
   918.             end if;
   919.
   920.          when NEG1_TO_Iq =>
   921.             the_CPU_delta := the_CPU_delta + 3;
   922.             if INS.Qq /= 0 then
   923.                the_Q_store(INS.Qq).I := - 1;
   924.             end if;
   925.
   926.          when POS2_TO_Iq =>
   927.             the_CPU_delta := the_CPU_delta + 3;
   928.             if INS.Qq /= 0 then
   929.                the_Q_store(INS.Qq).I := + 2;
   930.             end if;
   931.
   932.          when NEG2_TO_Iq =>
   933.             the_CPU_delta := the_CPU_delta + 3;
   934.             if INS.Qq /= 0 then
   935.                the_Q_store(INS.Qq).I := - 2;
   936.             end if;
   937.
   938.          when CqTOQk =>
   939.             the_CPU_delta := the_CPU_delta + 4;
   940.             if INS.Qk /= 0 then
   941.                the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   942.             end if;
   943.
   944.          when IqTOQk =>
   945.             the_CPU_delta := the_CPU_delta + 4;
   946.             if INS.Qk /= 0 then
   947.                the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   948.             end if;
   949.
   950.          when MqTOQk =>
   951.             the_CPU_delta := the_CPU_delta + 4;
   952.             if INS.Qk /= 0 then
   953.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   954.             end if;
   955.
   956.          when QqTOQk =>
   957.             the_CPU_delta := the_CPU_delta + 4;
   958.             if INS.Qk /= 0 then
   959.                the_Q_store(INS.Qk) := the_Q_store(INS.Qq);
   960.             end if;
   961.
   962.          when CIqTOQk =>
   963.            the_CPU_delta := the_CPU_delta + 4;
   964.            if INS.Qk /= 0 then
   965.               the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   966.               the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   967.            end if;
   968.
   969.          when IMqTOQk =>
   970.             the_CPU_delta := the_CPU_delta + 4;
   971.             if INS.Qk /= 0 then
   972.                the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   973.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   974.             end if;
   975.
   976.          when CMqTOQk =>
   977.             the_CPU_delta := the_CPU_delta + 4;
   978.             if INS.Qk /= 0 then
   979.                the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   980.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   981.             end if;
   982.
   983.          when QCIMq =>
   984.             ensure_that_the_NEST_has_room_for_a_result;
   985.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- Qq
   986.                push(as_word(the_Q_store(INS.Qq)));
   987.                the_CPU_delta := the_CPU_delta + 4;
   988.             elsif (INS.Qk and M_part_choice) /= 0 then       -- Mq
   989.                push(sign_extended(the_Q_store(INS.Qq).M));
   990.                the_CPU_delta := the_CPU_delta + 4;
   991.             elsif (INS.Qk and C_part_choice) /= 0 then       -- Cq
   992.                push(sign_extended(the_Q_store(INS.Qq).C));
   993.                the_CPU_delta := the_CPU_delta + 5;
   994.             elsif (INS.Qk and I_part_choice) /= 0 then       -- Iq
   995.                push(sign_extended(the_Q_store(INS.Qq).I));
   996.                the_CPU_delta := the_CPU_delta + 6;
   997.             else
   998.                trap_illegal_instruction;
   999.             end if;
  1000.
  1001.          when TO_RCIMq =>
  1002.             ensure_that_the_NEST_holds_an_operand;
  1003.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- =Qq
  1004.                the_Q_store(INS.Qq) := as_Q(pop);
  1005.                the_CPU_delta := the_CPU_delta + 2;
  1006.             elsif (INS.Qk and M_part_choice) /= 0 then       -- =[R]Mq
  1007.                the_Q_store(INS.Qq).M := KDF9.Q_part(pop and Q_part_mask);
  1008.                if (INS.Qk and reset_choice) /= 0 then
  1009.                   the_Q_store(INS.Qq).C := 0;
  1010.                   the_Q_store(INS.Qq).I := 1;
  1011.                   the_CPU_delta := the_CPU_delta + 3;
  1012.                else
  1013.                   the_CPU_delta := the_CPU_delta + 2;
  1014.                end if;
  1015.             elsif (INS.Qk and C_part_choice) /= 0 then       -- =[R]Cq
  1016.                the_Q_store(INS.Qq).C := KDF9.Q_part(pop and Q_part_mask);
  1017.                if (INS.Qk and reset_choice) /= 0 then
  1018.                   the_Q_store(INS.Qq).I := 1;
  1019.                   the_Q_store(INS.Qq).M := 0;
  1020.                   the_CPU_delta := the_CPU_delta + 3;
  1021.                else
  1022.                   the_CPU_delta := the_CPU_delta + 2;
  1023.                end if;
  1024.             elsif (INS.Qk and I_part_choice) /= 0 then       -- =[R]Iq
  1025.                the_Q_store(INS.Qq).I := KDF9.Q_part(pop and Q_part_mask);
  1026.                if (INS.Qk and reset_choice) /= 0 then
  1027.                   the_Q_store(INS.Qq).C := 0;
  1028.                   the_Q_store(INS.Qq).M := 0;
  1029.                   the_CPU_delta := the_CPU_delta + 3;
  1030.                else
  1031.                   the_CPU_delta := the_CPU_delta + 2;
  1032.                end if;
  1033.             else
  1034.                trap_illegal_instruction;
  1035.             end if;
  1036.             ensure_that_Q0_contains_zero(suspect => INS.Qq);
  1037.
  1038.          when ADD_TO_QCIMq =>
  1039.             ensure_that_the_NEST_has_room_for_a_result;
  1040.             ensure_that_the_NEST_holds_an_operand;
  1041.
  1042.             -- Because the following does not push the Q operand on to the NEST,
  1043.             --   it will not leave an authentic bit pattern in the NEST core stack,
  1044.             --      in the event of a subsequent NOUV.
  1045.             -- I take this to be of no importance.
  1046.
  1047.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- =+Qq
  1048.                the_Q_store(INS.Qq) := as_Q(as_word(the_Q_store(INS.Qq)) + pop);
  1049.                the_CPU_delta := the_CPU_delta + 5;
  1050.             elsif (INS.Qk and M_part_choice) /= 0 then       -- =+Mq
  1051.                the_Q_store(INS.Qq).M := KDF9.Q_part(Q_part_mask and
  1052.                                              (sign_extended(the_Q_store(INS.Qq).M) + pop));
  1053.                the_CPU_delta := the_CPU_delta + 5;
  1054.             elsif (INS.Qk and C_part_choice) /= 0 then       -- =+Cq
  1055.                the_Q_store(INS.Qq).C := KDF9.Q_part(Q_part_mask and
  1056.                                              (sign_extended(the_Q_store(INS.Qq).C) + pop));
  1057.                the_CPU_delta := the_CPU_delta + 6;
  1058.             elsif (INS.Qk and I_part_choice) /= 0 then       -- =+Iq
  1059.                the_Q_store(INS.Qq).I := KDF9.Q_part(Q_part_mask and
  1060.                                              (sign_extended(the_Q_store(INS.Qq).I) + pop));
  1061.                the_CPU_delta := the_CPU_delta + 7;
  1062.             else
  1063.                trap_illegal_instruction;
  1064.             end if;
  1065.             ensure_that_Q0_contains_zero(suspect => INS.Qq);
  1066.
  1067.          when SHA =>
  1068.             A := read_top;
  1069.             write_top(KDF9.word'(shift_arithmetic(A, shift_count)));
  1070.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1071.
  1072.          when SHAD =>
  1073.             AB := read_top;
  1074.             write_top(KDF9.pair'(shift_arithmetic(AB, shift_count)));
  1075.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1076.
  1077.          when MACC =>
  1078.             ensure_that_the_NEST_holds(at_least => 4);
  1079.             AB := pop;
  1080.             AB := AB.msw * AB.lsw;
  1081.             CD := read_top;
  1082.             write_top(CD + shift_arithmetic(AB, shift_count));
  1083.             the_CPU_delta := the_CPU_delta + 15 + shift_time(Natural(abs shift_count));
  1084.
  1085.          when SHL =>
  1086.             write_top(KDF9.word'(shift_logical(read_top, shift_count)));
  1087.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1088.
  1089.          when SHLD =>
  1090.             write_top(KDF9.pair'(shift_logical(read_top, shift_count)));
  1091.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1092.
  1093.          when SHC =>
  1094.             write_top(shift_circular(read_top, shift_count));
  1095.             the_CPU_delta := the_CPU_delta + 3 + shift_time(Natural(abs shift_count));
  1096.
  1097.          when TO_Kq =>
  1098.             fail_in_problem_program_state;
  1099.             case INS.Qq is
  1100.                when K0 =>
  1101.                   if read_top /= all_zero_bits then
  1102.                      for w in all_zero_bits .. read_top mod 8 loop
  1103.                         POSIX.output_line("BLEEP!");
  1104.                      end loop;
  1105.                      delay 10.0;
  1106.                   end if;
  1107.                when K1 =>
  1108.                   set_K1_register(read_top);
  1109.                when K2 =>
  1110.                   set_K2_register(read_top);
  1111.                when K3 =>
  1112.                   set_K3_register(read_top);
  1113.                when others =>
  1114.                   trap_illegal_instruction;
  1115.             end case;
  1116.             the_CPU_delta := the_CPU_delta + 3;
  1117.
  1118.          when Kk =>
  1119.             fail_in_problem_program_state;
  1120.             ensure_that_the_NEST_has_room_for_a_result;
  1121.             case INS.Qk is
  1122.                when K4 =>
  1123.                   push(get_K4_operand);
  1124.                   the_RFIR := (others => False);
  1125.                when K5 =>
  1126.                   push(get_K5_operand);
  1127.                when K7 =>
  1128.                   push(get_K7_operand);
  1129.                when others =>
  1130.                   trap_illegal_instruction;
  1131.             end case;
  1132.             the_CPU_delta := the_CPU_delta + 3;
  1133.
  1134.          when LINK =>
  1135.             if the_CPU_state = Director_state and the_SJNS_depth = 0 then -- clear out JB
  1136.                push(all_zero_bits);
  1137.                the_SJNS_depth := 0 - 1;
  1138.             else
  1139.                ensure_that_the_NEST_has_room_for_a_result;
  1140.                ensure_that_the_SJNS_is_not_empty;
  1141.                push(as_word(KDF9.SJNS_link(KDF9.syllable_address'(pop))));
  1142.             end if;
  1143.             the_CPU_delta := the_CPU_delta + 4;
  1144.
  1145.          when TO_LINK =>
  1146.             ensure_that_the_SJNS_is_not_full;
  1147.             ensure_that_the_NEST_holds_an_operand;
  1148.             push(KDF9.syllable_address(as_link(pop)));
  1149.             the_CPU_delta := the_CPU_delta + 3;
  1150.
  1151.          when others =>
  1152.             do_an_IO_order;
  1153.
  1154.       end case;
  1155.    end do_a_two_syllable_order;
  1156.
  1157.    procedure do_a_jump_order is
  1158.       RA        : KDF9.syllable_address;
  1159.       A         : KDF9.word;
  1160.    begin
  1161.       fetching_normally := True;
  1162.
  1163.       case INS.compressed_opcode is
  1164.
  1165.          when Jr =>
  1166.             set_NIA_to_the_INS_target_address;
  1167.             the_CPU_delta := the_CPU_delta + 8;
  1168.
  1169.          when JSr =>
  1170.             ensure_that_the_SJNS_is_not_full;
  1171.             push(CIA);
  1172.             set_NIA_to_the_INS_target_address;
  1173.             the_CPU_delta := the_CPU_delta + 11;
  1174.
  1175.          when JrEQ =>
  1176.             ensure_that_the_NEST_holds_2_operands;
  1177.             A := pop;
  1178.             if A = read_top then
  1179.                set_NIA_to_the_INS_target_address;
  1180.                the_CPU_delta := the_CPU_delta + 12;
  1181.             else
  1182.                the_CPU_delta := the_CPU_delta + 5;
  1183.             end if;
  1184.
  1185.          when JrNE =>
  1186.             ensure_that_the_NEST_holds_2_operands;
  1187.             A := pop;
  1188.             if A /= read_top then
  1189.                set_NIA_to_the_INS_target_address;
  1190.                the_CPU_delta := the_CPU_delta + 12;
  1191.             else
  1192.                the_CPU_delta := the_CPU_delta + 5;
  1193.             end if;
  1194.
  1195.          when JrGTZ =>
  1196.             ensure_that_the_NEST_holds_an_operand;
  1197.             if resign(pop) > 0 then
  1198.                set_NIA_to_the_INS_target_address;
  1199.                the_CPU_delta := the_CPU_delta + 11;
  1200.             else
  1201.                the_CPU_delta := the_CPU_delta + 4;
  1202.             end if;
  1203.
  1204.          when JrLTZ =>
  1205.             ensure_that_the_NEST_holds_an_operand;
  1206.             A := pop;
  1207.             if resign(A) < 0 then
  1208.                set_NIA_to_the_INS_target_address;
  1209.                the_CPU_delta := the_CPU_delta + 11;
  1210.             else
  1211.                the_CPU_delta := the_CPU_delta + 4;
  1212.             end if;
  1213.
  1214.          when JrEQZ =>
  1215.             ensure_that_the_NEST_holds_an_operand;
  1216.              if pop = all_zero_bits then
  1217.                set_NIA_to_the_INS_target_address;
  1218.                the_CPU_delta := the_CPU_delta + 11;
  1219.             else
  1220.                the_CPU_delta := the_CPU_delta + 4;
  1221.             end if;
  1222.
  1223.          when JrLEZ =>
  1224.             ensure_that_the_NEST_holds_an_operand;
  1225.             if resign(pop) <= 0 then
  1226.                set_NIA_to_the_INS_target_address;
  1227.                the_CPU_delta := the_CPU_delta + 11;
  1228.             else
  1229.                the_CPU_delta := the_CPU_delta + 4;
  1230.             end if;
  1231.
  1232.          when JrGEZ =>
  1233.             ensure_that_the_NEST_holds_an_operand;
  1234.             if resign(pop) >= 0 then
  1235.                set_NIA_to_the_INS_target_address;
  1236.                the_CPU_delta := the_CPU_delta + 11;
  1237.             else
  1238.                the_CPU_delta := the_CPU_delta + 4;
  1239.             end if;
  1240.
  1241.          when JrNEZ =>
  1242.             ensure_that_the_NEST_holds_an_operand;
  1243.             if pop /= all_zero_bits then
  1244.                set_NIA_to_the_INS_target_address;
  1245.                the_CPU_delta := the_CPU_delta + 11;
  1246.             else
  1247.                the_CPU_delta := the_CPU_delta + 4;
  1248.             end if;
  1249.
  1250.          when JrV =>
  1251.             if the_V_bit_is_set then
  1252.                the_V_bit_is_set := False;
  1253.                set_NIA_to_the_INS_target_address;
  1254.                the_CPU_delta := the_CPU_delta + 10;
  1255.             else
  1256.                the_CPU_delta := the_CPU_delta + 3;
  1257.             end if;
  1258.
  1259.          when JrNV =>
  1260.             if the_V_bit_is_set then
  1261.                the_V_bit_is_set := False;
  1262.                the_CPU_delta := the_CPU_delta + 3;
  1263.             else
  1264.                set_NIA_to_the_INS_target_address;
  1265.                the_CPU_delta := the_CPU_delta + 10;
  1266.             end if;
  1267.
  1268.          when JrEN =>
  1269.             the_trace_operand := KDF9.word(the_NEST_depth);
  1270.             if the_NEST_depth = 0 then
  1271.                set_NIA_to_the_INS_target_address;
  1272.                the_CPU_delta := the_CPU_delta + 10;
  1273.             else
  1274.                the_CPU_delta := the_CPU_delta + 3;
  1275.             end if;
  1276.
  1277.          when JrNEN =>
  1278.             the_trace_operand := KDF9.word(the_NEST_depth);
  1279.             if the_NEST_depth /= 0 then
  1280.                set_NIA_to_the_INS_target_address;
  1281.                the_CPU_delta := the_CPU_delta + 10;
  1282.             else
  1283.                the_CPU_delta := the_CPU_delta + 3;
  1284.             end if;
  1285.
  1286.          when JrEJ =>
  1287.             the_trace_operand := KDF9.word(the_SJNS_depth);
  1288.             if the_SJNS_depth = 0 then
  1289.                set_NIA_to_the_INS_target_address;
  1290.                the_CPU_delta := the_CPU_delta + 10;
  1291.             end if;
  1292.             the_CPU_delta := the_CPU_delta + 3;
  1293.
  1294.          when JrNEJ =>
  1295.             the_trace_operand := KDF9.word(the_SJNS_depth);
  1296.             if the_SJNS_depth /= 0 then
  1297.                set_NIA_to_the_INS_target_address;
  1298.                the_CPU_delta := the_CPU_delta + 10;
  1299.             end if;
  1300.             the_CPU_delta := the_CPU_delta + 3;
  1301.
  1302.          when JrTR =>
  1303.             if the_T_bit_is_set then
  1304.                the_T_bit_is_set := False;
  1305.                set_NIA_to_the_INS_target_address;
  1306.                the_CPU_delta := the_CPU_delta + 10;
  1307.             else
  1308.                the_CPU_delta := the_CPU_delta + 3;
  1309.             end if;
  1310.
  1311.          when JrNTR =>
  1312.             if the_T_bit_is_set then
  1313.                the_T_bit_is_set := False;
  1314.                the_CPU_delta := the_CPU_delta + 3;
  1315.             else
  1316.                set_NIA_to_the_INS_target_address;
  1317.                the_CPU_delta := the_CPU_delta + 10;
  1318.             end if;
  1319.
  1320.          when EXIT_n =>
  1321.             ensure_that_the_SJNS_is_not_empty;
  1322.             RA := pop;
  1323.             if INS.target.syllable_index = 3 then  -- c.f. decode_a_jump_order.
  1324.                increment_by_3(RA);
  1325.             end if;
  1326.             RA.order_word_number := RA.order_word_number+INS.target.order_word_number;
  1327.             set_NIA_to(RA);
  1328.             the_CPU_delta := the_CPU_delta + 12 + KDF9.us(INS.target.syllable_index mod 2);
  1329.
  1330.          when EXITD =>
  1331.             fail_in_problem_program_state;
  1332.             if the_SJNS_depth = 0 then
  1333.                -- This indicates a serious failure in Director; best to abandon it at once.
  1334.                trap_illegal_instruction("empty SJNS in Director");
  1335.             end if;
  1336.             RA := pop;
  1337.             the_CPU_delta := the_CPU_delta + 11;
  1338.             return_from_Director_to(RA);
  1339.
  1340.          when JrCqZ =>
  1341.             if the_Q_store(INS.Qq).C = 0 then
  1342.                set_NIA_to_the_INS_target_address;
  1343.                the_CPU_delta := the_CPU_delta + 11;
  1344.             else
  1345.                the_CPU_delta := the_CPU_delta + 4;
  1346.             end if;
  1347.
  1348.          when JrCqNZ =>
  1349.             if the_Q_store(INS.Qq).C /= 0 then
  1350.                set_NIA_to_the_INS_target_address;
  1351.                the_CPU_delta := the_CPU_delta + 11;
  1352.             else
  1353.                the_CPU_delta := the_CPU_delta + 4;
  1354.             end if;
  1355.
  1356.          when OS_OUT =>
  1357.             the_CPU_delta := the_CPU_delta + 13;
  1358.             ensure_that_the_SJNS_is_not_full;
  1359.             A := (if the_NEST_depth = 0 then 0 else read_top);
  1360.             if the_execution_mode = boot_mode then
  1361.                effect_interrupt(caused_by_OUT, A'Image);
  1362.                -- We get here only in Director state, when the OUT does not interrupt.
  1363.                -- Arguably, this should be notified as an error.
  1364.                return; -- OUT has the effect of a no-op in Director state.
  1365.             end if;
  1366.             -- Emulate a subset of the appropriate Director's API.
  1367.             if A < 100 then
  1368.                do_a_TSD_OUT(OUT_number => A);
  1369.             elsif A < 200 then
  1370.                do_an_EGDON_OUT(OUT_number => A);
  1371.             else
  1372.                trap_failing_OUT(A, "is unknown, or not yet implemented");
  1373.             end if;
  1374.
  1375.          when others =>
  1376.             trap_illegal_instruction;
  1377.
  1378.       end case;
  1379.    end do_a_jump_order;
  1380.
  1381.    procedure do_a_data_access_order is
  1382.    begin
  1383.       case INS.compressed_opcode is
  1384.
  1385.          when EaMq =>
  1386.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1387.             check_address_and_lockout(the_trace_address);
  1388.             ensure_that_the_NEST_has_room_for_a_result;
  1389.             the_trace_operand := fetch_word(the_trace_address);
  1390.             push(the_trace_operand);
  1391.             the_CPU_delta := the_CPU_delta + 6;
  1392.
  1393.          when TO_EaMq =>
  1394.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1395.             check_address_and_lockout(the_trace_address);
  1396.             ensure_that_the_NEST_holds_an_operand;
  1397.             the_trace_operand := pop;
  1398.             store_word(the_trace_operand, the_trace_address);
  1399.             the_CPU_delta := the_CPU_delta + 6;
  1400.
  1401.          when EaMqQ =>
  1402.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1403.             check_address_and_lockout(the_trace_address);
  1404.             ensure_that_the_NEST_has_room_for_a_result;
  1405.             the_trace_operand := fetch_word(the_trace_address);
  1406.             push(the_trace_operand);
  1407.             auto_increment;
  1408.             the_CPU_delta := the_CPU_delta + 7;
  1409.
  1410.          when TO_EaMqQ =>
  1411.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1412.             check_address_and_lockout(the_trace_address);
  1413.             ensure_that_the_NEST_holds_an_operand;
  1414.             the_trace_operand := pop;
  1415.             store_word(the_trace_operand, the_trace_address);
  1416.             auto_increment;
  1417.             the_CPU_delta := the_CPU_delta + 7;
  1418.
  1419.          when SET =>
  1420.             ensure_that_the_NEST_has_room_for_a_result;
  1421.             the_trace_operand := sign_extended(INS.operand);
  1422.             push(the_trace_operand);
  1423.             the_CPU_delta := the_CPU_delta + 4;
  1424.
  1425.          when others =>
  1426.             trap_illegal_instruction;
  1427.
  1428.       end case;
  1429.    end do_a_data_access_order;
  1430.
  1431.    procedure update_the_virtual_clocks
  1432.       with Inline;
  1433.
  1434.    procedure update_the_virtual_clocks is
  1435.    begin
  1436.       the_CPU_time := the_CPU_time + the_CPU_delta;
  1437.       the_elapsed_time := the_elapsed_time + the_CPU_delta;
  1438.       if the_CPU_time > the_elapsed_time then
  1439.          the_elapsed_time := the_CPU_time;
  1440.       end if;
  1441.       ICR := ICR + 1;
  1442.    end update_the_virtual_clocks;
  1443.
  1444.    procedure do_a_fast_time_slice is
  1445.    begin
  1446.
  1447.       if break_in.has_been_requested then
  1448.          break_in.handler;
  1449.       end if;
  1450.
  1451.       for i in 1 .. time_slice loop
  1452.
  1453.          the_CPU_delta := 0;
  1454.
  1455.          process_syllable_0_of_INS;
  1456.          case INS.kind is
  1457.             when one_syllable_order =>
  1458.                do_a_one_syllable_order;
  1459.             when two_syllable_order =>
  1460.                process_syllable_1_of_INS;
  1461.                do_a_two_syllable_order;
  1462.             when normal_jump_order =>
  1463.                process_syllables_1_and_2_of_a_jump_order;
  1464.                do_a_jump_order;
  1465.             when data_access_order =>
  1466.                process_syllables_1_and_2_of_a_data_access_order;
  1467.                do_a_data_access_order;
  1468.          end case;
  1469.
  1470.          update_the_virtual_clocks;
  1471.          check_for_a_clock_interrupt;
  1472.          if the_elapsed_time > the_next_interrupt_time then
  1473.             act_on_pending_interrupts;
  1474.          end if;
  1475.
  1476.       end loop;
  1477.
  1478.    exception
  1479.
  1480.       when program_exit =>
  1481.          complete_all_extant_transfers;
  1482.          update_the_virtual_clocks;
  1483.          synchronize_the_real_and_virtual_times;
  1484.          raise;
  1485.
  1486.       when OUT_2_restart =>
  1487.          complete_all_extant_transfers;
  1488.          update_the_virtual_clocks;
  1489.          synchronize_the_real_and_virtual_times;
  1490.          complete_TSD_OUT_2;
  1491.
  1492.    end do_a_fast_time_slice;
  1493.
  1494.    procedure do_a_traced_instruction_cycle is
  1495.       use tracing.order_flags;
  1496.
  1497.       procedure finalize_the_traced_instruction_execution is
  1498.       begin
  1499.          update_the_virtual_clocks;
  1500.          synchronize_the_real_and_virtual_times;
  1501.
  1502.          if ICR in low_count .. high_count            and then
  1503.                NIA_word_number in low_bound .. high_bound then
  1504.             take_note_of(the_trace_operand);
  1505.             if the_signature_is_enabled then
  1506.                update_the_digital_signature;
  1507.             end if;
  1508.             if the_histogram_is_enabled then
  1509.                add_INS_to_the_histogram;
  1510.                add_CIA_to_the_profile;
  1511.             end if;
  1512.             if the_external_trace_is_enabled then
  1513.                log_to_external_trace;
  1514.             end if;
  1515.             case INS.kind is
  1516.                when two_syllable_order =>
  1517.                   act_on_any_two_syllable_order_watchpoints;
  1518.                when data_access_order =>
  1519.                   act_on_any_data_access_order_watchpoints;
  1520.                when others =>
  1521.                   null;
  1522.             end case;
  1523.          end if;
  1524.       end finalize_the_traced_instruction_execution;
  1525.
  1526.    begin  -- do_a_traced_instruction_cycle
  1527.
  1528.       if break_in.has_been_requested then
  1529.          break_in.handler;
  1530.       end if;
  1531.
  1532.       the_trace_operand := 0;
  1533.       the_trace_address := 0;
  1534.       the_CPU_delta := 0;
  1535.
  1536.       process_syllable_0_of_INS;
  1537.
  1538.       case INS.kind is
  1539.          when one_syllable_order =>
  1540.             preview_a_one_syllable_order;
  1541.                do_a_one_syllable_order;
  1542.             look_back_at_a_one_syllable_order;
  1543.          when two_syllable_order =>
  1544.             process_syllable_1_of_INS;
  1545.             preview_a_two_syllable_order;
  1546.                do_a_two_syllable_order;
  1547.             look_back_at_a_two_syllable_order;
  1548.          when normal_jump_order =>
  1549.             process_syllables_1_and_2_of_a_jump_order;
  1550.             preview_a_jump_order;
  1551.                do_a_jump_order;
  1552.             look_back_at_a_jump_order;
  1553.          when data_access_order =>
  1554.             process_syllables_1_and_2_of_a_data_access_order;
  1555.             preview_a_data_access_order;
  1556.                do_a_data_access_order;
  1557.             look_back_at_a_data_access_order;
  1558.       end case;
  1559.
  1560.       finalize_the_traced_instruction_execution;
  1561.
  1562.       if ICR >= time_limit then
  1563.          raise time_expired;
  1564.       end if;
  1565.
  1566.       if (breakpoints/NIA_word_number        and then
  1567.              ICR in low_count .. high_count)  or else
  1568.                 the_diagnostic_mode = pause_mode then
  1569.          handle_breakpoint;
  1570.       end if;
  1571.
  1572.       check_for_a_clock_interrupt;
  1573.       if the_elapsed_time > the_next_interrupt_time then
  1574.          act_on_pending_interrupts;
  1575.       end if;
  1576.
  1577.    exception
  1578.
  1579.       when program_exit =>
  1580.          case INS.kind is
  1581.             when one_syllable_order =>
  1582.                look_back_at_a_one_syllable_order;
  1583.             when two_syllable_order =>
  1584.                look_back_at_a_two_syllable_order;
  1585.             when normal_jump_order =>
  1586.                look_back_at_a_jump_order;
  1587.             when data_access_order =>
  1588.                look_back_at_a_data_access_order;
  1589.          end case;
  1590.          complete_all_extant_transfers;
  1591.          finalize_the_traced_instruction_execution;
  1592.          raise;
  1593.
  1594.       when OUT_2_restart =>
  1595.          complete_all_extant_transfers;
  1596.          finalize_the_traced_instruction_execution;
  1597.          complete_TSD_OUT_2;
  1598.
  1599.    end do_a_traced_instruction_cycle;
  1600.
  1601. end KDF9.microcode;

Compiling: ../Source/kdf9-microcode.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:06

     1. -- KDF9 ISP emulation - CPU microcode routines.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.microcode is
    18.
    19.    procedure do_a_fast_time_slice;
    20.
    21.    procedure do_a_traced_instruction_cycle;
    22.
    23. end KDF9.microcode;

 1601 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/state_display.adb
Source file time stamp: 2021-02-21 13:23:30
Compiled at: 2021-02-21 15:54:06

     1. -- Provide the comprehensive machine-state display panel KDF9 never had.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Latin_1;
    18. with Ada.Exceptions;
    19. with Ada.Long_Float_Text_IO;
    20. --
    21. with disassembly;
    22. with exceptions;
    23. with formatting;
    24. with generic_sets;
    25. with HCI;
    26. with IOC;
    27. with IOC.fast.DR;
    28. with IOC.fast.FD;
    29. with KDF9_char_sets;
    30. with KDF9.CPU;
    31. with KDF9.decoding;
    32. with KDF9.PHU_store;
    33. with KDF9.store;
    34. with logging.file;
    35. with settings;
    36. with tracing;
    37.
    38. with IOC.diagnostics;
    39.
    40. use  Ada.Characters.Latin_1;
    41. use  Ada.Exceptions;
    42. use  Ada.Long_Float_Text_IO;
    43. --
    44. use  disassembly;
    45. use  exceptions;
    46. use  formatting;
    47. use  HCI;
    48. use  IOC;
    49. use  IOC.fast.DR;
    50. use  IOC.fast.FD;
    51. use  KDF9_char_sets;
    52. use  KDF9.CPU;
    53. use  KDF9.decoding;
    54. use  KDF9.PHU_store;
    55. use  KDF9.store;
    56. use  logging.file;
    57. use  settings;
    58. use  tracing;
    59.
    60. package body state_display is
    61.
    62.    procedure show_IM_parts (the_Q_register : in KDF9.Q_register;
    63.                             width          : in Positive := 8) is
    64.    begin
    65.       log(
    66.           "/"
    67.         & just_right("#" & oct_of(the_Q_register.I, width-2), width)
    68.         & "/"
    69.         & just_right("#" & oct_of(the_Q_register.M, width-2), width)
    70.          );
    71.    end show_IM_parts;
    72.
    73.    procedure show_IO_register (the_Q_register : in KDF9.Q_register;
    74.                                width          : in Positive := 8;
    75.                                for_DR,
    76.                                for_FD,
    77.                                for_FH,
    78.                                for_seek,
    79.                                for_OUT         : in Boolean  := False) is
    80.    begin
    81.       log('Q');
    82.       if for_FD then
    83.          log(just_right(as_FD_command(the_Q_register, for_FD and for_seek, for_FD and for_FH), width));
    84.       elsif for_DR then
    85.          log(just_right(as_DR_command(the_Q_register, for_OUT), width));
    86.       else
    87.          log(just_right("#" & oct_of(the_Q_register.C, width-2), width));
    88.       end if;
    89.       show_IM_parts(the_Q_register, width);
    90.    end show_IO_register;
    91.
    92.    procedure show_Q_register (the_Q_register : in KDF9.Q_register;
    93.                               width          : in Positive := 8) is
    94.    begin
    95.       log('Q' & just_right("#" & oct_of(the_Q_register.C, width-2), width));
    96.       show_IM_parts(the_Q_register, width);
    97.    end show_Q_register;
    98.
    99.    procedure show_Q_in_decimal (the_Q_register : in KDF9.Q_register;
   100.                                 width          : in Positive := 7) is
   101.    begin
   102.       log(
   103.           'Q'
   104.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.C)), width)
   105.         & "/"
   106.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.I)), width)
   107.         & "/"
   108.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.M)), width)
   109.          );
   110.    end show_Q_in_decimal;
   111.
   112.    procedure show_in_syllables_form (the_word : in KDF9.word) is
   113.       word : KDF9.word := the_word;
   114.       syllable : KDF9.syllable;
   115.    begin
   116.       for b in 0 .. 5 loop
   117.          word := rotate_word_left(word, 8);
   118.          syllable := KDF9.syllable(word and 8#377#);
   119.          log("#" & just_right(oct_of(syllable), 3) & " ");
   120.       end loop;
   121.    end show_in_syllables_form;
   122.
   123.    procedure show_as_characters (the_word : in KDF9.word) is
   124.       word : KDF9.word := the_word;
   125.       data : String(1 .. 8);
   126.    begin
   127.       for b of reverse data loop
   128.          b := glyph_for(to_CP(KDF9_char_sets.symbol(word and 8#77#)));
   129.          word := shift_logical(word, -6);
   130.       end loop;
   131.       log(data);
   132.    end show_as_characters;
   133.
   134.    procedure log_padded_string (text  : in String;
   135.                                 width : in Positive := 1) is
   136.       pad_width   : constant Natural := Integer'Max (0, width - text'Length);
   137.       padding     : constant String (1 .. pad_width) := (others => ' ');
   138.       padded_text : constant String := padding & text;
   139.    begin
   140.       log(padded_text);
   141.    end log_padded_string;
   142.
   143.    procedure log_octal (number : in KDF9.field_of_16_bits;
   144.                         width  : in Positive := 1) is
   145.    begin
   146.       log_padded_string("#" & oct_of(number), width);
   147.    end log_octal;
   148.
   149.    procedure log_octal (number : in KDF9.word;
   150.                         width  : in Positive := 1) is
   151.    begin
   152.       log_padded_string("#" & oct_of(number), width);
   153.    end log_octal;
   154.
   155.   procedure show_in_various_formats (the_word : in KDF9.word;
   156.                                      column   : in Positive := 5) is
   157.       image : String(1 .. 21);
   158.    begin
   159.       log_octal(the_word);
   160.       log(" = " & just_right(trimmed(CPU.signed'Image(resign(the_word))), 16) & " = ");
   161.       Put(image, host_float(CPU.f48(the_word)), Aft => 12, Exp => 2);
   162.       log(trimmed(image) & " = ");
   163.       log(as_fraction(the_word)'Image);
   164.       log_new_line;
   165.       tab_log_to(column);
   166.       log(" = ");
   167.       show_Q_register(as_Q(the_word));
   168.       log("   = ");
   169.       show_Q_in_decimal(as_Q(the_word));
   170.       log_new_line;
   171.       tab_log_to(column);
   172.       log(" = ");
   173.       show_in_syllables_form(the_word);
   174.       log("= """);
   175.       show_as_characters(the_word);
   176.       log("""");
   177.    end show_in_various_formats;
   178.
   179.    procedure show_progress is
   180.
   181.       function readable (t : KDF9.us)
   182.       return String is
   183.          t_plus_5E2 : constant KDF9.us := (t + 5E2)/ 1E3;
   184.          t_plus_5E5 : constant KDF9.us := (t + 5E5)/ 1E6;
   185.       begin
   186.          return (if t < 1E3 then
   187.                     ""
   188.               elsif t < 1E6 then
   189.                     " about" & t_plus_5E2'Image & " ms"
   190.               else  " about" & t_plus_5E5'Image & " sec" );
   191.       end readable;
   192.
   193.       CPU : constant String := " KDF9 us  (RAN)" & readable(the_CPU_time);
   194.       EL  : constant String := " KDF9 us  (EL) " & readable(the_clock_time);
   195.
   196.    begin
   197.       log_line("ORDERS:     " & just_right(ICR'Image, 10) & " executed (ICR)");
   198.       log_line("CPU TIME:   " & just_right(the_CPU_time'Image, 10) & CPU);
   199.       log_line("CLOCK TIME: " & just_right(KDF9.us'Image(the_clock_time), 10) & EL);
   200.    end show_progress;
   201.
   202.    slot_name : constant array (KDF9.context) of String(1..1)  := ("P", "Q", "R", "S");
   203.
   204.    procedure show_Director_registers is
   205.       interval : constant KDF9.us := the_clock_time - the_last_K4_time;
   206.    begin
   207.       log_line("The CPU is in " & the_CPU_state'Image);
   208.       log_line("CONTEXT:  " & slot_name(the_context));
   209.       log_line("PRIORITY: " & just_right(CPL'Image, 1));
   210.       log_line("BA:       " & just_right("#" & oct_of(BA), 6));
   211.       log_line("NOL:      " & just_right("#" & oct_of(NOL), 6));
   212.       log("CPDAR:    ");
   213.       for i in KDF9.buffer_number loop
   214.          log(if the_CPDAR(i) then device_name_of(buffer(i).all) & " " else "");
   215.       end loop;
   216.       log_new_line;
   217.       log_new_line;
   218.       log_line("PHU stores:");
   219.       for p in KDF9.priority loop
   220.          log("PHU" & p'Image & " is ");
   221.          if PHU(p).is_held_up then
   222.             if PHU(p).blockage.reason = buffer_busy then
   223.                log("waiting for " & device_name_of(IOC.device_number(PHU(p).blockage.buffer_nr)));
   224.                log(" on buffer #" & oct_of(PHU(p).blockage.buffer_nr, 2));
   225.                if PHU(p).blockage.by_INTQq then
   226.                   log(", because of INTQq");
   227.                end if;
   228.             else
   229.                log("locked out of group" & KDF9.store.group_address'Image(PHU(p).blockage.group_nr));
   230.             end if;
   231.          else
   232.             log("idle");
   233.          end if;
   234.          log_new_line;
   235.       end loop;
   236.       log_new_line;
   237.       log("RFIR: ");
   238.       if the_RFIR(caused_by_PR)     then log("PR, ");    end if;
   239.       if the_RFIR(caused_by_FLEX)   then log("FLEX, ");  end if;
   240.       if the_RFIR(caused_by_LIV)    then log("LIV, ");   end if;
   241.       if the_RFIR(caused_by_NOUV)   then log("NOUV, ");  end if;
   242.       if the_RFIR(caused_by_EDT)    then log("EDT, ");   end if;
   243.       if the_RFIR(caused_by_OUT)    then log("OUT, ");   end if;
   244.       if the_RFIR(caused_by_LOV)    then log("LOV, ");   end if;
   245.       if the_RFIR(caused_by_RESET)  then log("RESET, "); end if;
   246.       if interval >= 2**20          then log("CLOCK, "); end if;
   247.       log_line(trimmed(KDF9.us'Image(interval/32*32)) & " KDF9 us since last CLOCK");
   248.    end show_Director_registers;
   249.
   250.    procedure show_V_and_T is
   251.    begin
   252.       if the_V_bit_is_set or the_T_bit_is_set then
   253.          log_new_line;
   254.          if the_V_bit_is_set then
   255.             log("V is set. ");
   256.          else
   257.             log("V is clear. ");
   258.          end if;
   259.          if the_T_bit_is_set then
   260.             log("T is set. ");
   261.          else
   262.             log("T is clear. ");
   263.          end if;
   264.          log_new_line;
   265.       end if;
   266.    end show_V_and_T;
   267.
   268.    procedure show_NEST (when_empty : Boolean := True) is
   269.    begin
   270.       if the_NEST_depth = 0 then
   271.          if when_empty then
   272.             log_line("The NEST is empty.");
   273.          end if;
   274.       else
   275.          log_line("NEST:");
   276.          for i in reverse KDF9.NEST_depth loop
   277.             if i < the_NEST_depth then
   278.                log(just_right("N" & trimmed(KDF9.NEST_depth'Image(the_NEST_depth-i)), 3) & ": ");
   279.                log_new_line;
   280.                show_in_various_formats(the_NEST(i));
   281.                log_new_line;
   282.             end if;
   283.          end loop;
   284.       end if;
   285.    end show_NEST;
   286.
   287.    procedure show_SJNS (when_empty : Boolean := True) is
   288.    begin
   289.       if the_SJNS_depth = 0 then
   290.          if when_empty then
   291.             log_line("The SJNS is empty.");
   292.          end if;
   293.       else
   294.          log_line("SJNS:");
   295.       end if;
   296.       for i in reverse KDF9.SJNS_depth loop
   297.          if i < the_SJNS_depth then
   298.             log(just_right("S" & trimmed(KDF9.SJNS_depth'Image(the_SJNS_depth-i)), 3) & ": ");
   299.             log_line(oct_of(the_SJNS(i)) & " (" & dec_of(KDF9.syllable_address(the_SJNS(i))) & ")");
   300.          end if;
   301.       end loop;
   302.    end show_SJNS;
   303.
   304.    procedure show_Q_store is
   305.       Q_bits  : KDF9.word := 0;
   306.    begin
   307.       for Qq of the_Q_store loop
   308.          Q_bits := Q_bits or as_word(Qq);
   309.       end loop;
   310.       if Q_bits = 0 then
   311.          log_line("Q store: all zero.");
   312.          return;
   313.       else
   314.          log_line("Q store:");
   315.       end if;
   316.       for q in KDF9.Q_store'Range loop
   317.          if as_word(the_Q_store(q)) /= KDF9.word'(0) then
   318.             log(just_right("Q" & trimmed(q'Image), 3) & ": ");
   319.             show_Q_register(the_Q_store(q));
   320.             log("  = ");
   321.             show_Q_in_decimal(the_Q_store(q));
   322.             log_new_line;
   323.          end if;
   324.       end loop;
   325.    end show_Q_store;
   326.
   327.    procedure show_registers is
   328.    begin
   329.       show_progress;
   330.       log_new_line;
   331.       if the_execution_mode = boot_mode then
   332.          show_Director_registers;
   333.          log_new_line;
   334.       end if;
   335.       show_SJNS;
   336.       log_new_line;
   337.       show_Q_store;
   338.       show_V_and_T;
   339.       log_new_line;
   340.       show_NEST;
   341.    end show_registers;
   342.
   343.    procedure show_order is
   344.    begin
   345.       log(the_code_and_name_of_INS);
   346.    end show_order;
   347.
   348.    procedure show_execution_context is
   349.    begin
   350.       log("At "
   351.         & oct_of(CIA)
   352.         & " ("
   353.         & dec_of(CIA)
   354.         & ")"
   355.         & "; ICR ="
   356.         & ICR'Image
   357.         & "; EL ="
   358.         & the_clock_time'Image
   359.         & "; the instruction was ");
   360.       show_order;
   361.       log_new_line;
   362.    end show_execution_context;
   363.
   364.    procedure log_to_external_trace is
   365.    begin
   366.       log(the_external_trace_file, oct_of(CIA));
   367.       tab_log_to(the_external_trace_file, 10);
   368.       log(the_external_trace_file, ICR'Image);
   369.       tab_log_to(the_external_trace_file, 20);
   370.       if only_signature_tracing then
   371.          log(
   372.              the_external_trace_file,
   373.              "#"
   374.            & oct_of(the_digital_signature)
   375.            & (if the_V_bit_is_set then "V" else " ")
   376.            & (if the_T_bit_is_set then "T" else " ")
   377.             );
   378.          tab_log_to(the_external_trace_file, 40);
   379.          if the_NEST_depth > 0 then
   380.             log(the_external_trace_file, "#" & oct_of(read_top));
   381.          end if;
   382.          tab_log_to(the_external_trace_file, 58);
   383.       else
   384.          log(the_external_trace_file, the_CPU_time'Image);
   385.          tab_log_to(the_external_trace_file, 40);
   386.          log(the_external_trace_file, the_NEST_depth'Image);
   387.          tab_log_to(the_external_trace_file, 43);
   388.          log(the_external_trace_file, the_SJNS_depth'Image);
   389.          tab_log_to(the_external_trace_file, 46);
   390.          log(the_external_trace_file, (if the_V_bit_is_set then "V" else " "));
   391.          log(the_external_trace_file, (if the_T_bit_is_set then "T" else " "));
   392.          tab_log_to(the_external_trace_file, 50);
   393.          if the_NEST_depth > 0 then
   394.             log(the_external_trace_file, "#" & oct_of(read_top));
   395.          end if;
   396.          tab_log_to(the_external_trace_file, 68);
   397.       end if;
   398.       log(the_external_trace_file, " |" & the_full_name_of(INS));
   399.       tab_log_to(the_external_trace_file, 90);
   400.       log(the_external_trace_file, KDF9.us'Image(the_clock_time));
   401.       log_new_line(the_external_trace_file);
   402.    end log_to_external_trace;
   403.
   404.    procedure log_an_external_trace_header (caption : in String := "") is
   405.    begin
   406.       if caption /= "" then
   407.          log_new_line(the_external_trace_file);
   408.          log(the_external_trace_file, caption);
   409.          log_new_line(the_external_trace_file);
   410.       end if;
   411.       log(the_external_trace_file, "LOCATION");
   412.       tab_log_to(the_external_trace_file, 11);
   413.       log(the_external_trace_file, "ICR");
   414.       tab_log_to(the_external_trace_file, 20);
   415.       if only_signature_tracing then
   416.          log(the_external_trace_file, "DIGITAL SIGNATURE");
   417.          tab_log_to(the_external_trace_file, 40);
   418.          log(the_external_trace_file, "[N1]");
   419.          tab_log_to(the_external_trace_file, 58);
   420.       else
   421.          log(the_external_trace_file, " CPU");
   422.          tab_log_to(the_external_trace_file, 40);
   423.          log(the_external_trace_file, "ND");
   424.          tab_log_to(the_external_trace_file, 43);
   425.          log(the_external_trace_file, "SD");
   426.          tab_log_to(the_external_trace_file, 46);
   427.          log(the_external_trace_file, "VT");
   428.          tab_log_to(the_external_trace_file, 50);
   429.          log(the_external_trace_file, "[N1]");
   430.          tab_log_to(the_external_trace_file, 68);
   431.       end if;
   432.       log(the_external_trace_file, " |INSTRUCTION");
   433.       log_new_line(the_external_trace_file);
   434.    end log_an_external_trace_header;
   435.
   436.    procedure show_CIA_and_NIA is
   437.    begin
   438.       log_line("CIA:        " & just_right(oct_of(CIA), 10) & " (" & just_right(dec_of(CIA) & ")"));
   439.       log_line("NIA:        " & just_right(oct_of(NIA), 10) & " (" & just_right(dec_of(NIA) & ")"));
   440.    end show_CIA_and_NIA;
   441.
   442.    procedure long_witness is
   443.    begin
   444.       log_new_line;
   445.       log("At " & oct_of(CIA) & " (" & dec_of(CIA) & ") the instruction was ");
   446.       show_order;
   447.       log_new_line;
   448.       show_registers;
   449.    end long_witness;
   450.
   451.    procedure short_witness is
   452.
   453.       type register_usage is array (KDF9.compressed_opcode) of Boolean
   454.          with Size => 64, Component_Size => 1;
   455.
   456.       it_uses_JB : constant register_usage
   457.                  := (
   458.                       LINK
   459.                     | TO_LINK
   460.                     | OS_OUT
   461.                     | JrNEJ
   462.                     | JSr
   463.                     | EXIT_n
   464.                     | JrEJ
   465.                     | EXITD     => True,
   466.                       others    => False
   467.                     );
   468.
   469.       it_uses_Qq : constant register_usage
   470.                  := (
   471.                       MkMq
   472.                     | MkMqQ
   473.                     | MkMqH
   474.                     | MkMqQH
   475.                     | MkMqN
   476.                     | MkMqQN
   477.                     | MkMqHN
   478.                     | MkMqQHN
   479.                     | TO_MkMq
   480.                     | TO_MkMqQ
   481.                     | TO_MkMqH
   482.                     | TO_MkMqQH
   483.                     | TO_MkMqN
   484.                     | TO_MkMqQN
   485.                     | TO_MkMqHN
   486.                     | TO_MkMqQHN
   487.                     | MqTOQk
   488.                     | IqTOQk
   489.                     | IMqTOQk
   490.                     | CqTOQk
   491.                     | CMqTOQk
   492.                     | CIqTOQk
   493.                     | QqTOQk
   494.                     | M_PLUS_Iq
   495.                     | M_MINUS_Iq
   496.                     | NCq
   497.                     | DCq
   498.                     | POS1_TO_Iq
   499.                     | NEG1_TO_Iq
   500.                     | POS2_TO_Iq
   501.                     | NEG2_TO_Iq
   502.                     | SHA
   503.                     | SHAD
   504.                     | MACC
   505.                     | SHL
   506.                     | SHLD
   507.                     | SHC
   508.                     | TO_RCIMq
   509.                     | QCIMq
   510.                     | ADD_TO_QCIMq
   511.                     | JCqNZS
   512.                     | PAR_Qq
   513.                     | PIA_PIC_CLO_TLO_Qq
   514.                     | PIB_PID_Qq
   515.                     | PIE_PIG_Qq
   516.                     | PIF_PIH_Qq
   517.                     | PMA_PMK_INT_Qq
   518.                     | CT_PMB_PMC_BUSY_Qq
   519.                     | PMD_PME_PML_Qq
   520.                     | PMF_PMG_Qq
   521.                     | POA_POC_POE_POF_PMH_Qq
   522.                     | POB_POD_Qq
   523.                     | POG_POL_Qq
   524.                     | POH_POK_Qq
   525.                     | JrCqNZ    => True,
   526.                       others    => False
   527.                     );
   528.
   529.       is_modified : constant register_usage
   530.                   := (
   531.                        EaMq
   532.                      | TO_EaMq
   533.                      | EaMqQ
   534.                      | TO_EaMqQ  => True,
   535.                        others    => False
   536.                      );
   537.
   538.       it_uses_Qk : constant register_usage
   539.                  := (
   540.                       MkMq
   541.                     | MkMqQ
   542.                     | MkMqH
   543.                     | MkMqQH
   544.                     | MkMqN
   545.                     | MkMqQN
   546.                     | MkMqHN
   547.                     | MkMqQHN
   548.                     | TO_MkMq
   549.                     | TO_MkMqQ
   550.                     | TO_MkMqH
   551.                     | TO_MkMqQH
   552.                     | TO_MkMqN
   553.                     | TO_MkMqQN
   554.                     | TO_MkMqHN
   555.                     | TO_MkMqQHN
   556.                     | MqTOQk
   557.                     | IqTOQk
   558.                     | IMqTOQk
   559.                     | CqTOQk
   560.                     | CMqTOQk
   561.                     | CIqTOQk
   562.                     | QqTOQk    => True,
   563.                       others    => False
   564.                     );
   565.
   566.       function INS_uses_Qq
   567.       return Boolean is
   568.          (
   569.           -- A compressed_opcode may be ambiguous: to know which opcode it represents,
   570.           --   further attributes of the order may need to be considered.
   571.           case INS.kind is
   572.              when two_syllable_order =>
   573.                 it_uses_Qq(INS.compressed_opcode)
   574.                   and
   575.                 -- If a shift, exclude fixed-amount shifts.
   576.                 ((INS.order.syllable_1 and 1) = 0 or else INS.compressed_opcode not in SHA..SHC),
   577.              when normal_jump_order =>
   578.                 INS.compressed_opcode in JrCqZ | JrCqNZ,
   579.              when data_access_order =>
   580.                 is_modified(INS.compressed_opcode),
   581.              when others =>
   582.                 False
   583.          );
   584.
   585.    begin  -- short_witness
   586.       log_new_line;
   587.       show_execution_context;
   588.       if the_CPU_state = Director_state then
   589.          show_Director_registers;
   590.       end if;
   591.       if it_uses_JB(INS.compressed_opcode)                     and then
   592.             INS.kind in two_syllable_order | normal_jump_order and then
   593.                the_SJNS_depth > 0                                  then
   594.          log_line(
   595.                   " JB: "
   596.                 & oct_of(the_SJNS(the_SJNS_depth-1))
   597.                 & "; SJNS depth: " & just_right(the_SJNS_depth'Image, 3)
   598.                  );
   599.       end if;
   600.       if INS.Qq /= 0 and then
   601.             INS_uses_Qq  then
   602.          log(just_right("Q" & trimmed(INS.Qq'Image), 3) & ": ");
   603.          show_Q_register(the_Q_store(INS.Qq));
   604.          log("  = ");
   605.          show_Q_in_decimal(the_Q_store(INS.Qq));
   606.          log_new_line;
   607.       end if;
   608.       if INS.Qk /= 0                       and then
   609.             INS.kind in two_syllable_order and then
   610.                it_uses_Qk(INS.compressed_opcode)    and then
   611.                   INS.Qq /= INS.Qk             then
   612.          log(just_right("Q" & trimmed(INS.Qk'Image), 3) & ": ");
   613.          show_Q_register(the_Q_store(INS.Qk));
   614.          log("  = ");
   615.          show_Q_in_decimal(the_Q_store(INS.Qk));
   616.          log_new_line;
   617.          log_new_line;
   618.       end if;
   619.       show_V_and_T;
   620.       show_NEST(when_empty => False);
   621.       log_rule;
   622.    end short_witness;
   623.
   624.    procedure show_frequency_plots is
   625.
   626.       function summed_counts (from, to : KDF9.syllable)
   627.       return KDF9.order_counter is
   628.          sum : KDF9.order_counter := 0;
   629.       begin
   630.          for i in from .. to loop
   631.             sum := sum + the_histogram(i);
   632.          end loop;
   633.          return sum;
   634.       end summed_counts;
   635.
   636.       procedure log_opcode_bin (bin    : in KDF9.syllable;
   637.                                 sum    : in KDF9.order_counter;
   638.                                 bound  : in Long_Float) is
   639.          percent : Long_Float;
   640.          image   : String(1 .. 6);
   641.       begin
   642.          if sum /= 0 then
   643.             percent := Long_Float(sum)/Long_Float(ICR)*100.0;
   644.             if percent < bound then
   645.                return;
   646.             end if;
   647.             log(oct_of(bin) & ": " & the_short_name_of(bin));
   648.             tab_log_to(32);
   649.             log(sum'Image);
   650.             tab_log_to(42);
   651.             Put(image, percent, Aft => 2, Exp => 0);
   652.             log(image & "% :");
   653.             for i in 1 .. Integer(percent) loop
   654.                log("|");
   655.             end loop;
   656.             log_new_line;
   657.          end if;
   658.       end log_opcode_bin;
   659.
   660.       procedure log_opcode_usage (bound : in Long_Float) is
   661.       begin
   662.          for i in KDF9.syllable'(0) .. 8#167# loop
   663.             log_opcode_bin(i, the_histogram(i), bound);
   664.          end loop;
   665.          for i in KDF9.syllable'(8#170#) .. 8#237# loop
   666.             log_opcode_bin(i, the_histogram(i), bound);
   667.          end loop;
   668.          log_opcode_bin(8#240#, summed_counts(from => 8#240#, to => 8#257#), bound);
   669.          log_opcode_bin(8#260#, summed_counts(from => 8#240#, to => 8#277#), bound);
   670.          for i in KDF9.syllable'(8#300#) .. 8#377# loop
   671.             log_opcode_bin(i, the_histogram(i), bound);
   672.          end loop;
   673.       end log_opcode_usage;
   674.
   675.       accounted_for : Long_Float;
   676.       cutoff_image  : String(1 .. 7) := "      %";
   677.       percent_image : String(1 .. 7) := "      %";
   678.
   679.       procedure log_order_word_bin (bin    : in KDF9.order_word_number;
   680.                                     sum    : in KDF9.order_counter;
   681.                                     bound  : in Long_Float) is
   682.          percent : Long_Float;
   683.       begin
   684.          if sum /= 0 then
   685.             percent := Long_Float(sum)/Long_Float(ICR)*100.0;
   686.             if percent < bound then
   687.                return;
   688.             end if;
   689.             accounted_for := accounted_for + percent;
   690.             log("#" & oct_of(bin) & ": ");
   691.             tab_log_to(32);
   692.             log(sum'Image);
   693.             tab_log_to(42);
   694.             Put(percent_image, percent, Aft => 2, Exp => 0);
   695.             percent_image(7) := '%';
   696.             log(percent_image);
   697.             log(" :");
   698.             for i in 1 .. Integer(percent) loop
   699.                log("|");
   700.             end loop;
   701.             log_new_line;
   702.          end if;
   703.       end log_order_word_bin;
   704.
   705.       procedure log_profile (bound : in Long_Float) is
   706.       begin
   707.          accounted_for := 0.0;
   708.          for w in KDF9.order_word_number loop
   709.             if the_profile(w) /= 0 then
   710.                log_order_word_bin(w, the_profile(w), bound);
   711.             end if;
   712.          end loop;
   713.       end log_profile;
   714.
   715.       procedure sum_logged_frequencies (bound  : in Long_Float) is
   716.          percent : Long_Float;
   717.       begin
   718.          accounted_for := 0.0;
   719.          for w in KDF9.order_word_number loop
   720.             percent := Long_Float(the_profile(w))/Long_Float(ICR)*100.0;
   721.             if percent >= bound then
   722.                accounted_for := accounted_for + percent;
   723.             end if;
   724.          end loop;
   725.       end sum_logged_frequencies;
   726.
   727.    begin -- show_frequency_plots
   728.       Put(cutoff_image(1..6), histogram_cutoff, Aft => 2, Exp => 0);
   729.       cutoff_image(7) := '%';
   730.       if the_INS_plot_is_wanted and ICR /= 0 and the_diagnostic_mode /= fast_mode then
   731.          -- Print the instruction execution-frequency histogram.
   732.          log_title(
   733.                    "Histogram of the opcodes of"
   734.                  & ICR'Image
   735.                  & " executed instructions with frequency >="
   736.                  & cutoff_image
   737.                   );
   738.          log_opcode_usage(bound => histogram_cutoff);
   739.          log_new_line;
   740.       end if;
   741.       if the_profile_is_wanted and ICR /= 0 and the_diagnostic_mode /= fast_mode then
   742.          log_title(
   743.                    "Histogram of the loci of"
   744.                  & ICR'Image
   745.                  & " executed instructions with frequency >="
   746.                  & cutoff_image
   747.                   );
   748.          log_profile(bound => histogram_cutoff);
   749.          log_new_line;
   750.       end if;
   751.       sum_logged_frequencies(bound => histogram_cutoff);
   752.       Put(percent_image(1..6), accounted_for, Aft =>1, Exp => 0);
   753.       log_line("Executions accounted for in the profile:" & percent_image);
   754.       log_rule;
   755.    end show_frequency_plots;
   756.
   757.    function as_RFIR (K4_word : KDF9.word)
   758.    return KDF9.RFIR is
   759.       mask : KDF9.word := 2**16;
   760.       RFIR : KDF9.RFIR := (others => False);
   761.    begin
   762.       for r in reverse KDF9.interrupt_number loop
   763.          if (K4_word and mask) /= 0 then
   764.             RFIR(r) := True;
   765.          end if;
   766.          mask := 2 * mask;
   767.       end loop;
   768.       return RFIR;
   769.    end as_RFIR;
   770.
   771.    function for_FH_disc (compressed_opcode : KDF9.compressed_opcode; Pxy_bits : KDF9.Q_number)
   772.    return Boolean
   773.    is (case compressed_opcode is
   774.           when PIA_PIC_CLO_TLO_Qq     => Pxy_bits = PIC_bits,
   775.           when PIB_PID_Qq             => Pxy_bits = PID_bits,
   776.           when PIE_PIG_Qq             => Pxy_bits = PIG_bits,
   777.           when PIF_PIH_Qq             => Pxy_bits = PIH_bits,
   778.           when POA_POC_POE_POF_PMH_Qq => Pxy_bits = POC_bits,
   779.           when POB_POD_Qq             => Pxy_bits = POD_bits,
   780.           when POG_POL_Qq             => Pxy_bits = POL_bits,
   781.           when POH_POK_Qq             => Pxy_bits = POK_bits,
   782.           when others                 => False
   783.       );
   784.
   785.
   786.    first_col   : constant := 17;
   787.    device_col  : constant := first_col + 20;
   788.    operand_col : constant := device_col;
   789.    event_col   : constant := operand_col + 4;
   790.    is_D_col    : constant := event_col + 29;
   791.    depth_col   : constant := operand_col + 29;
   792.    time_col    : constant := depth_col + 11;
   793.    ICR_col     : constant := time_col + 13;
   794.
   795.    procedure show_retro_FIFO is
   796.
   797.       RFIR_id : constant array (KDF9.interrupt_number) of Character
   798.               := ('P', 'F', 'I', 'N', 'E', 'S', 'O', 'R', 'Y', 'Z');
   799.       image   : String(1 .. 21);
   800.       RFIR    : KDF9.RFIR;
   801.    begin
   802.       if retro_FIFO_count = 0 then
   803.          return;
   804.       end if;
   805.       log_title("Retrospective trace of all instructions.");
   806.       tab_log_to(depth_col);
   807.       log_line("ND SD VTD   CPU TIME     ICR");
   808.       for i in 1 .. retro_FIFO_count loop
   809.          if i = 1 then
   810.             log("Ended ");
   811.          else
   812.             log("After ");
   813.          end if;
   814.          declare
   815.             this      : tracing.retro_FIFO_entry renames retro_FIFO(retro_FIFO_index);
   816.             Q         : constant KDF9.Q_register := as_Q(this.parameter);
   817.             decoded   : KDF9.decoded_order;
   818.          begin
   819.             log(oct_of(this.location) & ":");
   820.             tab_log_to(first_col);
   821.             decoded.order := this.order;
   822.             decode(decoded);
   823.             log(the_full_name_of(decoded,
   824.                                  octal_option => decoded.kind = normal_jump_order,
   825.                                  both_bases   => False));
   826.             tab_log_to(operand_col);
   827.             case decoded.kind is
   828.                when one_syllable_order =>
   829.                   if this.nested > 0 then
   830.                      case decoded.compressed_opcode is
   831.                         when DIV
   832.                            | DIVD
   833.                            | X_frac =>
   834.                            log(CPU.fraction'Image(as_fraction(this.parameter)));
   835.                         when DIVI =>
   836.                            log(CPU.signed'Image(resign(this.parameter)));
   837.                         when STAND
   838.                            | ABSF
   839.                            | DIVDF
   840.                            | DIVF
   841.                            | FLOAT_9
   842.                            | FLOATD
   843.                            | MINUSDF
   844.                            | MINUSF
   845.                            | NEGDF
   846.                            | NEGF
   847.                            | PLUSDF
   848.                            | PLUSF
   849.                            | ROUNDF
   850.                            | ROUNDHF
   851.                            | XDF
   852.                            | XF
   853.                            | XPLUSF
   854.                            | MAXF =>
   855.                            Put(image, host_float(CPU.f48(this.parameter)), Aft => 12, Exp => 2);
   856.                            log(trimmed(image));
   857.                         when others =>
   858.                            if this.nested > 0 then
   859.                               log_octal(this.parameter);
   860.                            end if;
   861.                      end case;
   862.                   end if;
   863.                when two_syllable_order =>
   864.                   case decoded.compressed_opcode is
   865.                      when PAR_Qq =>
   866.                         show_IO_register(Q, for_DR => False, for_FD => False);
   867.                      when CT_PMB_PMC_BUSY_Qq
   868.                         | PMA_PMK_INT_Qq
   869.                         | PMD_PME_PML_Qq
   870.                         | PMF_PMG_Qq =>
   871.                         show_IO_register(
   872.                                          Q,
   873.                                          for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
   874.                                          for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
   875.                                          for_seek => decoded.Qk = PMA_bits
   876.                                         );
   877.                      when PIA_PIC_CLO_TLO_Qq
   878.                         | PIB_PID_Qq
   879.                         | PIE_PIG_Qq
   880.                         | PIF_PIH_Qq
   881.                         | POA_POC_POE_POF_PMH_Qq
   882.                         | POB_POD_Qq
   883.                         | POG_POL_Qq
   884.                         | POH_POK_Qq =>
   885.                         show_IO_register(
   886.                                          Q,
   887.                                          for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
   888.                                          for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
   889.                                          for_FH   => for_FH_disc(decoded.compressed_opcode, decoded.Qk)
   890.                                         );
   891.                      when M_PLUS_Iq
   892.                         | M_MINUS_Iq
   893.                         | NCq
   894.                         | DCq
   895.                         | POS1_TO_Iq
   896.                         | NEG1_TO_Iq
   897.                         | POS2_TO_Iq
   898.                         | NEG2_TO_Iq
   899.                         | CqTOQk
   900.                         | IqTOQk
   901.                         | MqTOQk
   902.                         | QqTOQk
   903.                         | CIqTOQk
   904.                         | IMqTOQk
   905.                         | CMqTOQk
   906.                         | TO_RCIMq
   907.                         | ADD_TO_QCIMq
   908.                         | JCqNZS =>
   909.                         show_Q_register(Q);
   910.                      when Kk =>
   911.                         case decoded.Qk is
   912.                            when K4 =>
   913.                               log(KDF9.word'Image(32*KDF9.word(Q.C)));
   914.                               log("us");
   915.                               if Q.I /= 0 then
   916.                                  log("; RFIR: ");
   917.                                  RFIR := as_RFIR(this.parameter);
   918.                                  for r in KDF9.interrupt_number loop
   919.                                     if RFIR(r) then
   920.                                        log(RFIR_id(r)&"");
   921.                                     end if;
   922.                                  end loop;
   923.                               end if;
   924.                               if resign(this.parameter) < 0 then
   925.                                  log("C");
   926.                               end if;
   927.                            when K5 | K7 =>
   928.                               log_octal(this.parameter);
   929.                            when others =>
   930.                               log("invalid K order: #" & oct_of(decoded.compressed_opcode));
   931.                         end case;
   932.                      when TO_LINK =>
   933.                         log(oct_of(as_link(this.parameter)));
   934.                      when LINK =>
   935.                         log(oct_of(as_link(this.parameter)));
   936.                      when TO_MkMq
   937.                         | TO_MkMqQ
   938.                         | TO_MkMqH
   939.                         | TO_MkMqQH
   940.                         | TO_MkMqN
   941.                         | TO_MkMqQN
   942.                         | TO_MkMqHN
   943.                         | TO_MkMqQHN =>
   944.                         log_octal(this.parameter);
   945.                      when others =>
   946.                         if this.nested > 0 then
   947.                            log_octal(this.parameter);
   948.                         end if;
   949.                   end case;
   950.                when normal_jump_order =>
   951.                   case decoded.compressed_opcode is
   952.                      when Jr
   953.                         | JSr =>
   954.                         log(oct_of(as_link(this.parameter)));
   955.                      when EXIT_n =>
   956.                         if this.parameter < 8 then
   957.                            log(this.parameter'Image);
   958.                         else
   959.                            log(oct_of(as_link(this.parameter)));
   960.                         end if;
   961.                      when EXITD =>
   962.                         log(oct_of(as_link(this.parameter)));
   963.                      when JrCqZ
   964.                         | JrCqNZ =>
   965.                         show_Q_register(Q);
   966.                      when OS_OUT =>
   967.                         if this.parameter < 16 then
   968.                            log_octal(this.parameter);
   969.                         elsif this.parameter < 64 then
   970.                            log(this.parameter'Image);
   971.                         elsif this.parameter > 2**47 then
   972.                            log_octal(this.parameter);
   973.                         else
   974.                            show_Q_register(Q);
   975.                         end if;
   976.                      when JrEJ
   977.                         | JrNEJ
   978.                         | JrEN
   979.                         | JrNEN =>
   980.                            log(this.parameter'Image);
   981.                      when JrTR
   982.                         | JrV =>
   983.                            log(Boolean'Image(Boolean'Val(this.parameter)));
   984.                      when JrNTR
   985.                         | JrNV =>
   986.                            log(Boolean'Image(not Boolean'Val(this.parameter)));
   987.                      when others =>
   988.                         if this.nested > 0 then
   989.                            log_octal(this.parameter);
   990.                         end if;
   991.                      end case;
   992.                when others =>
   993.                   if this.nested > 0 then
   994.                      log_octal(this.parameter);
   995.                   end if;
   996.             end case;
   997.             tab_log_to(depth_col);
   998.             log(just_right(this.nested'Image,2));
   999.             log(" ");
  1000.             log(just_right(this.called'Image,2));
  1001.             log(" ");
  1002.             log(if this.V then "V" else " ");
  1003.             log(if this.T then "T" else " ");
  1004.             log(if this.D then "D" else " ");
  1005.             tab_log_to(time_col);
  1006.             log(this.CPU_time'Image);
  1007.             tab_log_to(ICR_col);
  1008.             log(this.ICR_value'Image);
  1009.             log_new_line;
  1010.          end;
  1011.          retro_FIFO_index := retro_FIFO_index - 1;
  1012.       end loop;
  1013.       if retro_FIFO_count = FIFO_size then
  1014.          log("After earlier instructions, whose tracing is now lost.");
  1015.       else
  1016.          log("After the start of traced execution.");
  1017.       end if;
  1018.       log_new_line;
  1019.       log_rule;
  1020.    end show_retro_FIFO;
  1021.
  1022.    the_final_ICR : KDF9.order_counter := 0;
  1023.
  1024.    procedure notify_state_display_of_final_ICR is
  1025.    begin
  1026.       the_final_ICR := ICR;
  1027.    end notify_state_display_of_final_ICR;
  1028.
  1029.    procedure show_IOC_FIFO is
  1030.    begin
  1031.       if IOC_FIFO_count = 0 then return; end if;
  1032.       log_title("Retrospective trace of peripheral I/O events.");
  1033.       tab_log_to(is_D_col);
  1034.       log_line("CPL T   EL. TIME     ICR");
  1035.       for i in 1 .. IOC_FIFO_count loop
  1036.          if i = 1 then
  1037.             log("Ended ");
  1038.          else
  1039.             log("After ");
  1040.          end if;
  1041.
  1042.          declare
  1043.             this    : tracing.IOC_FIFO_entry renames IOC_FIFO(IOC_FIFO_index);
  1044.             decoded : constant KDF9.decoded_order := this.decoded_order;
  1045.
  1046.             procedure show_transfer (
  1047.                                      Q                 : in KDF9.Q_register;
  1048.                                      for_OUT, for_seek : in Boolean := False
  1049.                                     ) is
  1050.             begin
  1051.                case decoded.compressed_opcode is
  1052.                   when PAR_Qq =>
  1053.                      show_IO_register(Q, for_DR => False, for_FD => False);
  1054.                   when CT_PMB_PMC_BUSY_Qq
  1055.                      | PMA_PMK_INT_Qq
  1056.                      | PMD_PME_PML_Qq
  1057.                      | PMF_PMG_Qq =>
  1058.                      show_IO_register(
  1059.                                       Q,
  1060.                                       for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
  1061.                                       for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
  1062.                                       for_seek => (decoded.Qk in PMA_bits) or show_transfer.for_seek,
  1063.                                       for_OUT  => show_transfer.for_OUT
  1064.                                      );
  1065.                   when PIA_PIC_CLO_TLO_Qq
  1066.                      | PIB_PID_Qq
  1067.                      | PIE_PIG_Qq
  1068.                      | PIF_PIH_Qq
  1069.                      | POA_POC_POE_POF_PMH_Qq
  1070.                      | POB_POD_Qq
  1071.                      | POG_POL_Qq
  1072.                      | POH_POK_Qq
  1073.                      | OS_OUT =>
  1074.                      show_IO_register(
  1075.                                       Q,
  1076.                                       for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
  1077.                                       for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
  1078.                                       for_FH   => for_FH_disc(decoded.compressed_opcode, decoded.Qk),
  1079.                                       for_OUT  => show_transfer.for_OUT
  1080.                                      );
  1081.                   when others =>
  1082.                      log("invalid IO order: #" & oct_of(decoded.compressed_opcode));
  1083.                end case;
  1084.             end show_transfer;
  1085.
  1086.             shown_ICR : KDF9.order_counter := this.ICR_value;
  1087.             FD_seek   : Boolean := False;
  1088.             FD_xfer   : Boolean := False;
  1089.
  1090.          begin -- show_IOC_FIFO
  1091.             log(oct_of(this.order_address) & ":");
  1092.             tab_log_to(first_col);
  1093.             if the_full_name_of(this.decoded_order) = "OUT"  then
  1094.                 if this.device_name(1..2) in "MT" | "ST" and then
  1095.                       this.ICR_value >= the_final_ICR        then
  1096.                   log("OUT 0/2 rewind");
  1097.                   shown_ICR := the_final_ICR + 1;
  1098.                elsif this.device_name(1..2) in "MT" | "ST" then
  1099.                   log("OUT 6/7 rewind");
  1100.                elsif this.device_name(1..2) in "LP" | "TP" then
  1101.                   log("OUT 8");
  1102.                elsif this.device_name(1..2) = "DR" then
  1103.                   if this.kind in start_transfer | finis_transfer | buffer_lockout | store_lockout then
  1104.                      log(if this.operation = output_operation then "OUT 11" else "OUT 12");
  1105.                   else
  1106.                      log("OUT 11/12");
  1107.                   end if;
  1108.                elsif this.device_name(1..2) = "FD" then
  1109.                   if this.kind in start_transfer | finis_transfer | buffer_lockout | store_lockout then
  1110.                      log(if this.operation = output_operation then "OUT 41" else "OUT 42");
  1111.                   else
  1112.                      log("OUT 41/42 seek"); FD_seek := True;
  1113.                   end if;
  1114.                elsif this.device_name(1..2) = "FW" then
  1115.                   log("OUT 8/16");
  1116.                else
  1117.                   log("OUT ?");
  1118.                end if;
  1119.             else
  1120.                log(mnemonic(the_full_name_of(this.decoded_order), this.device_name));
  1121.             end if;
  1122.             tab_log_to(device_col);
  1123.             log(this.device_name);
  1124.             case this.kind is
  1125.                when store_lockout =>
  1126.                   tab_log_to(event_col);
  1127.                   log("locks out #");
  1128.                   log(oct_of(this.data_address));
  1129.                   log(" = E");
  1130.                   log(dec_of(this.data_address));
  1131.                   tab_log_to(is_D_col);
  1132.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1133.                   log(this.priority_level'Image);
  1134.                   tab_log_to(time_col);
  1135.                   log(this.initiation_time'Image);
  1136.                   tab_log_to(ICR_col);
  1137.                   log(shown_ICR'Image);
  1138.                 when buffer_lockout =>
  1139.                   tab_log_to(event_col);
  1140.                   log("buffer lockout");
  1141.                   tab_log_to(is_D_col);
  1142.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1143.                   log(this.priority_level'Image);
  1144.                   tab_log_to(time_col);
  1145.                   log(this.initiation_time'Image);
  1146.                   tab_log_to(ICR_col);
  1147.                   log(shown_ICR'Image);
  1148.                when start_transfer =>
  1149.                   tab_log_to(event_col);
  1150.                   show_transfer(this.control_word);
  1151.                   tab_log_to(is_D_col);
  1152.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1153.                   log(this.priority_level'Image);
  1154.                   tab_log_to(time_col-2);
  1155.                   log(" S" & this.initiation_time'Image);
  1156.                   tab_log_to(ICR_col);
  1157.                   log(shown_ICR'Image);
  1158.                when finis_transfer =>
  1159.                   tab_log_to(event_col);
  1160.                   show_transfer(this.control_word);
  1161.                   tab_log_to(is_D_col);
  1162.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1163.                   log(this.priority_level'Image);
  1164.                   tab_log_to(time_col-2);
  1165.                   log(" E" & this.completion_time'Image);
  1166.                   tab_log_to(ICR_col);
  1167.                   log(shown_ICR'Image);
  1168.                when buffer_status =>
  1169.                   tab_log_to(event_col);
  1170.                   FD_xfer := this.device_name(1..2) = "FD";
  1171.                   -- PMFQq entails no data transfer or seek, but has a sector address parameter.
  1172.                   FD_seek := (FD_seek or (decoded.Qk in PMA_bits)) and FD_xfer;
  1173.                   FD_seek := FD_seek and decoded.compressed_opcode /= PMF_PMG_Qq;
  1174.                   show_IO_register(this.Q_register, for_FD => FD_xfer, for_seek => FD_seek);
  1175.                   tab_log_to(is_D_col);
  1176.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1177.                   log(this.priority_level'Image);
  1178.                   log(if this.status then " Y" else " N");
  1179.                   tab_log_to(time_col);
  1180.                   log(this.initiation_time'Image);
  1181.                   tab_log_to(ICR_col);
  1182.                   log(shown_ICR'Image);
  1183.             end case;
  1184.             log_new_line;
  1185.          end;
  1186.          IOC_FIFO_index := IOC_FIFO_index - 1;
  1187.       end loop;
  1188.       if IOC_FIFO_count = FIFO_size then
  1189.          log_line("After earlier instructions, whose tracing is now lost.");
  1190.       else
  1191.          log_line("After the start of traced execution.");
  1192.       end if;
  1193.       log_line("Total time waiting for unoverlapped I/O to finish ="
  1194.              & KDF9.us'Image((the_clock_time-the_CPU_time+500) / 1000)
  1195.              & " ms.");
  1196.       log_rule;
  1197.    end show_IOC_FIFO;
  1198.
  1199.    procedure show_interrupt_FIFO is
  1200.    begin
  1201.       if interrupt_FIFO_count = 0 then return; end if;
  1202.       log_title("Retrospective trace of interrupt requests.");
  1203.       tab_log_to(is_D_col);
  1204.       log_line("CPL     EL. TIME     ICR");
  1205.       for i in 1 .. interrupt_FIFO_count loop
  1206.          log(if i = 1 then "Ended " else "After ");
  1207.          declare
  1208.             this : tracing.interrupt_FIFO_entry renames interrupt_FIFO(interrupt_FIFO_index);
  1209.          begin
  1210.             log(oct_of(this.order_address) & ": ");
  1211.             tab_log_to(first_col);
  1212.             log(case this.interrupt_code is
  1213.                    when caused_by_PR     => "PR   ",
  1214.                    when caused_by_FLEX   => "FLEX ",
  1215.                    when caused_by_LIV    => "LIV  ",
  1216.                    when caused_by_NOUV   => "NOUV ",
  1217.                    when caused_by_EDT    => "EDT  ",
  1218.                    when caused_by_OUT    => "OUT  ",
  1219.                    when caused_by_LOV     => "LOV  ",
  1220.                    when caused_by_RESET   => "RESET",
  1221.                    when caused_by_CLOCK   => "CLOCK",
  1222.                    when EXITD_flag       => "EXITD"
  1223.                );
  1224.             tab_log_to(event_col-4);
  1225.             log(trimmed(this.message));
  1226.             tab_log_to(is_D_col);
  1227.             log(slot_name(this.context));
  1228.             log(this.priority_level'Image);
  1229.             tab_log_to(time_col);
  1230.             log(this.busy_time'Image);
  1231.             tab_log_to(ICR_col);
  1232.             log(this.ICR_value'Image);
  1233.             log_new_line;
  1234.          end;
  1235.          interrupt_FIFO_index := interrupt_FIFO_index - 1;
  1236.       end loop;
  1237.       log(
  1238.           if interrupt_FIFO_count = FIFO_size then
  1239.              "After earlier interrupts, whose tracing is now lost."
  1240.           else
  1241.             "After the start of traced execution."
  1242.          );
  1243.       log_new_line;
  1244.       log_new_line;
  1245.    end show_interrupt_FIFO;
  1246.
  1247.    procedure show_retrospective_traces is
  1248.    begin
  1249.       if the_peripheral_trace_is_enabled then
  1250.          pragma Debug(IOC.diagnostics);
  1251.       end if;
  1252.       if the_interrupt_trace_is_enabled then
  1253.          show_interrupt_FIFO;
  1254.       end if;
  1255.       if the_peripheral_trace_is_enabled then
  1256.          show_IOC_FIFO;
  1257.       end if;
  1258.       if the_retrospective_trace_is_enabled then
  1259.          show_retro_FIFO;
  1260.       end if;
  1261.    end show_retrospective_traces;
  1262.
  1263.    procedure show_current_state is
  1264.    begin
  1265.       show_execution_context;
  1266.       log_rule;
  1267.       show_registers;
  1268.       log_rule;
  1269.    end show_current_state;
  1270.
  1271.    procedure show_final_state (because : in String) is
  1272.    begin
  1273.       if the_final_state_is_wanted then
  1274.          if loading_was_successful then
  1275.             -- make sure there is at least one NL after any FW output.
  1276.             if the_log_is_wanted then
  1277.                log_new_line;
  1278.                log_rule;
  1279.             else
  1280.                log_new_line;
  1281.             end if;
  1282.             log_line("Final State: " & because & ".");
  1283.             if not the_log_is_wanted then return; end if;
  1284.             long_witness;
  1285.             log_rule;
  1286.
  1287.             if nr_of_post_dumping_areas /= 0 then
  1288.                log_title("Post-run Dump:");
  1289.                print_postrun_dump_areas;
  1290.             end if;
  1291.
  1292.             if the_INS_plot_is_wanted or the_profile_is_wanted then
  1293.                if the_histogram_is_enabled then
  1294.                   show_frequency_plots;
  1295.                end if;
  1296.             end if;
  1297.
  1298.             show_retrospective_traces;
  1299.
  1300.             if the_signature_is_enabled then
  1301.                log_title("Digital signature of traced orders = #"
  1302.                        & oct_of(the_digital_signature)
  1303.                        & ".");
  1304.             end if;
  1305.          else
  1306.             log_line("ee9: " & because & ".");
  1307.             show_all_prerun_dump_areas;
  1308.             return;
  1309.          end if;
  1310.       end if;
  1311.    end show_final_state;
  1312.
  1313.    procedure show_all_prerun_dump_areas is
  1314.    begin
  1315.       if the_log_is_wanted and nr_of_pre_dumping_areas /= 0 then
  1316.          log_title("Pre-run Dump:");
  1317.          print_prerun_dump_areas;
  1318.          remove_prerun_dump_areas;
  1319.       end if;
  1320.    end show_all_prerun_dump_areas;
  1321.
  1322.    increment   : constant := 8;
  1323.    jump_tab    : constant := 12;
  1324.    first_tab   : constant := 16;
  1325.    last_column : constant := 80;
  1326.
  1327.    function is_non_blank (first : in KDF9.address)
  1328.    return Boolean is
  1329.       result : Boolean := False;
  1330.    begin
  1331.       for address in first .. first+increment-1 loop
  1332.          result := result or (fetch_word(address) /= 0);
  1333.       end loop;
  1334.       return result;
  1335.    end is_non_blank;
  1336.
  1337.    subtype converted_word is String(1..8);
  1338.
  1339.    type convertor is
  1340.       not null access function (address : KDF9.address) return converted_word;
  1341.
  1342.    procedure show_core (first, last : in KDF9.address;
  1343.                         head, side  : in String;
  1344.                         converted   : in convertor) is
  1345.
  1346.       procedure show_group (first : in KDF9.address) is
  1347.          address : KDF9.address := first;
  1348.       begin
  1349.          while address <= first+increment-1 loop
  1350.             log(converted(address));
  1351.             address := address + 1;
  1352.             exit when address < first;
  1353.          end loop;
  1354.       end show_group;
  1355.
  1356.       address : KDF9.address := first;
  1357.
  1358.    begin
  1359.       if (last-first+1) < 1 then
  1360.          return;
  1361.       end if;
  1362.       BA := 0; -- Ensure that physical store is examined when running in boot mode.
  1363.       log_title("Core store [#" & oct_of(first) & " .. #" & oct_of(last) & "] interpreted as " & head & ":");
  1364.       while address <= last loop
  1365.          if is_non_blank(address) then
  1366.             log_octal(KDF9.field_of_16_bits(address));
  1367.             log(":");
  1368.             tab_log_to(jump_tab);
  1369.             log(side);
  1370.             log(" """);
  1371.             show_group(address);
  1372.             log("""");
  1373.             log_new_line;
  1374.          else
  1375.             log_line("========  blank  ========");
  1376.          end if;
  1377.       exit when address >= KDF9.address'Last - increment;
  1378.          address := address + increment;
  1379.       end loop;
  1380.       log_new_line;
  1381.    end show_core;
  1382.
  1383.    function encoding_of (address : KDF9.address; code_table : output_code_table)
  1384.    return converted_word is
  1385.       result : converted_word;
  1386.    begin
  1387.       for b in KDF9_char_sets.symbol_index loop
  1388.          result(Natural(b)+1) := glyph_for(code_table(fetch_symbol(address, b)));
  1389.       end loop;
  1390.       return result;
  1391.    end encoding_of;
  1392.
  1393.    current_case : KDF9_char_sets.symbol := KDF9_char_sets.Case_Normal;
  1394.
  1395.    function interpretation_of (address : KDF9.address)
  1396.    return converted_word is
  1397.       result : converted_word;
  1398.       symbol : KDF9_char_sets.symbol;
  1399.       char   : Character;
  1400.    begin
  1401.       for b in KDF9_char_sets.symbol_index loop
  1402.          symbol := fetch_symbol(address, b);
  1403.          if current_case = KDF9_char_sets.Case_Normal then
  1404.             char := TP_CN(symbol);
  1405.          else
  1406.             char := TP_CS(symbol);
  1407.          end if;
  1408.          if symbol = KDF9_char_sets.Case_Normal then
  1409.             current_case := KDF9_char_sets.Case_Normal;
  1410.          elsif symbol = KDF9_char_sets.Case_Shift then
  1411.             current_case := KDF9_char_sets.Case_Shift;
  1412.          end if;
  1413.          result(Natural(b)+1) := glyph_for(char);
  1414.       end loop;
  1415.       return result;
  1416.    end interpretation_of;
  1417.
  1418.    function case_visible (address : KDF9.address)
  1419.    return converted_word
  1420.    is (interpretation_of(address));
  1421.
  1422.    function case_normal (address : KDF9.address)
  1423.    return converted_word
  1424.    is (encoding_of(address, code_table => TP_CN));
  1425.
  1426.    function case_shift (address : KDF9.address)
  1427.    return converted_word
  1428.    is (encoding_of(address, code_table => TP_CS));
  1429.
  1430.    function printer_code (address : KDF9.address)
  1431.    return converted_word
  1432.    is (encoding_of(address, code_table => to_LP));
  1433.
  1434.    function card_code (address : KDF9.address)
  1435.    return converted_word
  1436.    is (encoding_of(address, code_table => to_CP));
  1437.
  1438.    function Latin_1_code (address : KDF9.address)
  1439.    return converted_word
  1440.    is (converted_word'(1..7 => Space,
  1441.                        8    => glyph_for(Character'Val(fetch_word(address) and 8#377#))));
  1442.
  1443.    procedure show_core_in_case_visible (first, last : in KDF9.address) is
  1444.    begin
  1445.       show_core(first, last,
  1446.                 head => "characters in TR/TP code with case shifting",
  1447.                 side => "  ",
  1448.                 converted => case_visible'Access);
  1449.    end show_core_in_case_visible;
  1450.
  1451.    procedure show_core_in_case_normal (first, last : in KDF9.address) is
  1452.    begin
  1453.       show_core(first, last,
  1454.                 head => "characters in TR/TP Normal Case code",
  1455.                 side => "NC",
  1456.                 converted => case_normal'Access);
  1457.    end show_core_in_case_normal;
  1458.
  1459.    procedure show_core_in_case_shift (first, last : in KDF9.address) is
  1460.    begin
  1461.       show_core(first, last,
  1462.                 head => "characters in TR/TP Shift Case code",
  1463.                 side => "SC",
  1464.                 converted => case_shift'Access);
  1465.    end show_core_in_case_shift;
  1466.
  1467.    procedure show_core_in_print_code (first, last : in KDF9.address) is
  1468.    begin
  1469.       show_core(first, last,
  1470.                 head => "characters in LP code",
  1471.                 side => "LP",
  1472.                 converted => printer_code'Access);
  1473.    end show_core_in_print_code;
  1474.
  1475.    procedure show_core_in_card_code (first, last : in KDF9.address) is
  1476.    begin
  1477.       show_core(first, last,head => "characters in CR/CP code",
  1478.                 side => "CP",
  1479.                 converted => card_code'Access);
  1480.    end show_core_in_card_code;
  1481.
  1482.    procedure show_core_in_Latin_1 (first, last : in KDF9.address) is
  1483.    begin
  1484.       show_core(first, last,
  1485.                 head => "words with bits 40-47 of each in Latin-1 code",
  1486.                 side => "L1",
  1487.                 converted => Latin_1_code'Access);
  1488.    end show_core_in_Latin_1;
  1489.
  1490.    procedure show_core_in_tape_code (first, last : in KDF9.address) is
  1491.    begin
  1492.       show_core_in_case_visible(first, last);
  1493.    end show_core_in_tape_code;
  1494.
  1495.    procedure show_core_as_word_forms (first, last  : KDF9.address) is
  1496.
  1497.       procedure show_word (address : KDF9.address) is
  1498.          word : constant KDF9.word := fetch_word(address);
  1499.       begin
  1500.          log_octal(KDF9.field_of_16_bits(address));
  1501.          log(":");
  1502.          tab_log_to(jump_tab);
  1503.          show_in_various_formats(word, column => jump_tab);
  1504.          log_new_line;
  1505.       end show_word;
  1506.
  1507.       procedure show_word_group (first, last  : KDF9.address) is
  1508.          last_address : KDF9.address := first;
  1509.          this_word, last_word : KDF9.word;
  1510.       begin
  1511.          if last = first or last = 0 then
  1512.             show_word(last);
  1513.             return;
  1514.          end if;
  1515.          this_word := fetch_word(first);
  1516.          last_word := this_word;
  1517.          show_word(first);
  1518.          for address in first+1 .. last-1 loop
  1519.             this_word := fetch_word(address);
  1520.             if this_word = last_word and address = last_address+1 then
  1521.                log_line("==========  ditto  ========");
  1522.             elsif this_word /= last_word then
  1523.                show_word(address);
  1524.                last_word := this_word;
  1525.                last_address := address;
  1526.             end if;
  1527.          end loop;
  1528.          if last > first then
  1529.             show_word(last);
  1530.          end if;
  1531.       end show_word_group;
  1532.
  1533.    begin
  1534.       if first > last then
  1535.          return;
  1536.       end if;
  1537.       BA := 0; -- Ensure that physical store is examined when running in boot mode.
  1538.       log_title("Core store interpreted as 48-bit words:");
  1539.       show_word_group(first, last);
  1540.       log_new_line;
  1541.    end show_core_as_word_forms;
  1542.
  1543.    -- Each word of code space is described by a set of flags.
  1544.    -- Flags 0 .. 5 are set iff a jump order has that syllable as target.
  1545.    -- Flag 6 is set if the word is thought to be code, but not a target.
  1546.    -- Flag 7 is set if the word is thought to be addressed as data.
  1547.
  1548.    is_a_code_word : constant KDF9.syllable_index := 6;
  1549.    is_a_data_word : constant KDF9.syllable_index := 7;
  1550.
  1551.    package word_flags is new generic_sets(member => KDF9.syllable_index);
  1552.    use word_flags;
  1553.
  1554.    all_jump_targets : constant word_flags.set := (0 .. 5 => True, 6|7 => False);
  1555.
  1556.    analysis_flags : array (KDF9.order_word_number) of word_flags.set;
  1557.
  1558.    function "/" (word : KDF9.order_word_number; flag : KDF9.syllable_index)
  1559.    return Boolean
  1560.    is (analysis_flags(word)(flag));
  1561.
  1562.    function is_a_jump_target (the_point : in KDF9.syllable_address)
  1563.    return Boolean
  1564.    is (analysis_flags(the_point.order_word_number)(the_point.syllable_index));
  1565.
  1566.    function is_a_jump_target (the_operand : in KDF9.order_word_number)
  1567.    return Boolean
  1568.    is ((analysis_flags(the_operand) and all_jump_targets) /= empty_set);
  1569.
  1570.    procedure clear_all_analysis_flags is
  1571.    begin
  1572.       analysis_flags := (others => empty_set);
  1573.    end clear_all_analysis_flags;
  1574.
  1575.    procedure unmark_as_a_data_word (the_operand : in KDF9.order_word_number) is
  1576.    begin
  1577.       analysis_flags(the_operand)(is_a_data_word) := False;
  1578.    end unmark_as_a_data_word;
  1579.
  1580.    procedure unmark_as_a_code_word (the_operand : in KDF9.order_word_number) is
  1581.    begin
  1582.       analysis_flags(the_operand)(is_a_code_word) := False;
  1583.    end unmark_as_a_code_word;
  1584.
  1585.    procedure mark_as_a_code_word (the_operand : in KDF9.order_word_number) is
  1586.    begin
  1587.       analysis_flags(the_operand)(is_a_code_word) := True;
  1588.       unmark_as_a_data_word(the_operand);
  1589.    end mark_as_a_code_word;
  1590.
  1591.    procedure mark_as_a_jump_target (the_point : in KDF9.syllable_address) is
  1592.    begin
  1593.       analysis_flags(the_point.order_word_number)(the_point.syllable_index) := True;
  1594.       mark_as_a_code_word(the_point.order_word_number);
  1595.    end mark_as_a_jump_target;
  1596.
  1597.    procedure mark_as_a_data_word (the_operand : in KDF9.order_word_number) is
  1598.    begin
  1599.       analysis_flags(the_operand)(is_a_data_word) := True;
  1600.       unmark_as_a_code_word(the_operand);
  1601.    end mark_as_a_data_word;
  1602.
  1603.    procedure mark_all_code_blocks_and_data_blocks is
  1604.
  1605.       procedure mark_all_code_blocks (the_beginning : in KDF9.syllable_address) is
  1606.          address : KDF9.syllable_address := the_beginning;
  1607.       begin
  1608.          if address.syllable_index > 5 then
  1609.             return;  -- We have blundered into non-code words.
  1610.          end if;
  1611.          -- Mark the first syllable of the block.
  1612.          mark_as_a_jump_target(the_beginning);
  1613.          -- Mark the destinations of all jumps in the block as code.
  1614.          loop
  1615.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1616.          exit when address.order_word_number = 8191;
  1617.             set_NIA_to(address);
  1618.             decode_the_next_order;
  1619.             if is_an_invalid_order(INS)                                                  or else
  1620.                   (address.order_word_number/is_a_data_word and address.syllable_index = 0) then
  1621.                return;
  1622.             else
  1623.                -- Assuming a valid code word, act on it.
  1624.                mark_as_a_code_word(address.order_word_number);
  1625.                case INS.kind is
  1626.                   when normal_jump_order =>
  1627.                      if not is_a_jump_target((INS.target.order_word_number, INS.target.syllable_index)) then
  1628.                         -- Mark the jump's destination recursively.
  1629.                         -- N.B. EXIT is actioned only if it is of EXIT ARr type.
  1630.                         mark_all_code_blocks((INS.target.order_word_number, INS.target.syllable_index));
  1631.                      end if;
  1632.                      increment_by_3(address);
  1633.                      if INS.compressed_opcode = JSr  then
  1634.                         -- Mark its return point.
  1635.                         mark_as_a_jump_target(address);
  1636.                      end if;
  1637.                   when one_syllable_order =>
  1638.                      increment_by_1(address);
  1639.                   when two_syllable_order =>
  1640.                      if INS.compressed_opcode = JCqNZS then
  1641.                         -- Mark the preceding word.
  1642.                         mark_as_a_jump_target((address.order_word_number-1, 0));
  1643.                      end if;
  1644.                      increment_by_2(address);
  1645.                   when data_access_order =>
  1646.                      increment_by_3(address);
  1647.                end case;
  1648.             end if;
  1649.          end loop;
  1650.       end mark_all_code_blocks;
  1651.
  1652.       procedure mark_all_data_blocks (the_beginning : in KDF9.syllable_address) is
  1653.          address : KDF9.syllable_address := the_beginning;
  1654.       begin
  1655.          if address.syllable_index > 5 then
  1656.             return;  -- We have blundered into non-code words.
  1657.          end if;
  1658.          the_code_block_handler: loop
  1659.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1660.          exit when address.order_word_number = 8191;
  1661.             -- Process orders, starting at an established code word.
  1662.             set_NIA_to(address); -- **
  1663.             decode_the_next_order;
  1664.             if (is_an_invalid_order(INS)                         or else
  1665.                   address.order_word_number/is_a_data_word)     and then
  1666.                      not (address.order_word_number/is_a_code_word) then
  1667.                -- This word is data: make sure it is not designated as code;
  1668.                --    and find the start of the next code block.
  1669.                for a in address.order_word_number .. 8190 loop
  1670.                   address := (a, 0);
  1671.                   exit when is_a_jump_target(a);
  1672.                   unmark_as_a_code_word(a);
  1673.                   mark_as_a_data_word(a);
  1674.                end loop;
  1675.
  1676.                exit the_code_block_handler
  1677.                   when address.order_word_number = 8190;
  1678.
  1679.                -- Find the syllable at which the block starts.
  1680.                for s in KDF9.syllable_index'(0) .. 5 loop
  1681.                   address.syllable_index := s;
  1682.                   exit when is_a_jump_target(address);
  1683.                end loop;
  1684.
  1685.             else
  1686.
  1687.                -- Assuming a valid code word, act on it.
  1688.                case INS.kind is
  1689.                   when data_access_order =>
  1690.                      if INS.operand < 8192 then
  1691.                         declare
  1692.                            operand : constant KDF9.order_word_number
  1693.                                    := KDF9.order_word_number(INS.operand);
  1694.                         begin
  1695.                            if INS.compressed_opcode /= KDF9.decoding.SET and then
  1696.                                  not is_a_jump_target(operand)               then
  1697.                               mark_as_a_data_word(operand);
  1698.                            end if;
  1699.                         end;
  1700.                      end if;
  1701.                      increment_by_3(address);
  1702.                   when one_syllable_order =>
  1703.                      increment_by_1(address);
  1704.                   when two_syllable_order =>
  1705.                      increment_by_2(address);
  1706.                   when normal_jump_order =>
  1707.                      increment_by_3(address);
  1708.                end case;
  1709.             end if;
  1710.
  1711.             exit the_code_block_handler
  1712.                when address.order_word_number = KDF9.order_word_number'Last;
  1713.
  1714.          end loop the_code_block_handler;
  1715.       end mark_all_data_blocks;
  1716.
  1717.       procedure reset_wrong_data_marks (the_beginning : in KDF9.syllable_address) is
  1718.          address : KDF9.syllable_address := the_beginning;
  1719.          locus   : KDF9.order_word_number;
  1720.       begin
  1721.          if address.syllable_index > 5 then
  1722.             return;  -- We have blundered into non-code words.
  1723.          end if;
  1724.          -- Unmark the first instruction of the block.
  1725.          unmark_as_a_data_word(address.order_word_number);
  1726.
  1727.          -- Unmark data marks on destinations of jumps.
  1728.          loop
  1729.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1730.          exit when address.order_word_number = 8191;
  1731.             set_NIA_to(address);
  1732.             decode_the_next_order;
  1733.             if is_an_invalid_order(INS)                          or else
  1734.                   address.order_word_number/is_a_data_word       or else
  1735.                      not (address.order_word_number/is_a_code_word) then
  1736.                -- We have reached the end of the code block.
  1737.                return;
  1738.             else
  1739.                -- Assuming a valid code word, act on it.
  1740.                case INS.kind is
  1741.                   when normal_jump_order =>
  1742.                      locus := address.order_word_number;
  1743.                      increment_by_3(address);
  1744.                      if INS.target.order_word_number/is_a_data_word    then
  1745.                         -- UNmark the jump's destination recursively.
  1746.                         reset_wrong_data_marks((INS.target.order_word_number, INS.target.syllable_index));
  1747.                      end if;
  1748.                      if INS.compressed_opcode /= Jr          and then
  1749.                            INS.compressed_opcode /= EXIT_n   and then
  1750.                               locus /= address.order_word_number then
  1751.                         -- It flows on, so the next word cannot be data.
  1752.                         unmark_as_a_data_word(address.order_word_number);
  1753.                      elsif not (address.order_word_number/is_a_data_word) then
  1754.                         -- The next syllable starts a block, iff it is not the end of a block.
  1755.                         set_NIA_to(address);
  1756.                         decode_the_next_order;
  1757.                         if not is_an_invalid_order(INS) then
  1758.                            mark_as_a_jump_target(address);
  1759.                         end if;
  1760.                      end if;
  1761.                   when one_syllable_order =>
  1762.                      increment_by_1(address);
  1763.                   when two_syllable_order =>
  1764.                      increment_by_2(address);
  1765.                   when data_access_order =>
  1766.                      increment_by_3(address);
  1767.                end case;
  1768.             end if;
  1769.             exit when address.order_word_number = KDF9.order_word_number'Last;
  1770.          end loop;
  1771.       end reset_wrong_data_marks;
  1772.
  1773.       procedure mark_the_words_reachable_from (address : in KDF9.syllable_address) is
  1774.          start_point : KDF9.syllable_address;
  1775.       begin
  1776.          mark_as_a_jump_target(address);
  1777.          set_NIA_to(address);
  1778.          decode_the_next_order;
  1779.          if INS.kind =normal_jump_order then
  1780.          start_point := (INS.target.order_word_number, INS.target.syllable_index);
  1781.          mark_all_code_blocks(start_point);
  1782.          mark_all_data_blocks(start_point);
  1783.          reset_wrong_data_marks(start_point);
  1784.          end if;
  1785.       end mark_the_words_reachable_from;
  1786.
  1787.       procedure markup_a_problem_program is
  1788.       begin
  1789.          if the_initial_jump_was_corrupted then
  1790.             -- We cannot sensibly locate the order words using E0  ...
  1791.             log_new_line;
  1792.             log_line("The initial jump, in E0U, has been corrupted!");
  1793.             log_new_line;
  1794.             show_core_as_syllables((0, 0), (5, 0));
  1795.             --  ... so restore it to the value it had on loading.
  1796.             restore_the_initial_jump;
  1797.             log_line("E0U has been restored to the value it had on loading.");
  1798.             log_new_line;
  1799.          end if;
  1800.
  1801.          -- Mark all orders reachable from the initial jump in E0 and the restart jumps in E4.
  1802.
  1803.          mark_the_words_reachable_from((0, 0));
  1804.          mark_the_words_reachable_from((0, 4));
  1805.          mark_the_words_reachable_from((1, 4));
  1806.
  1807.          -- Mark the words between E0 and P0 as data, skipping E4.
  1808.          mark_as_a_data_word(1);
  1809.          mark_as_a_data_word(2);
  1810.          mark_as_a_data_word(3);
  1811.          set_NIA_to((0, 0));
  1812.          decode_the_next_order;
  1813.          for d in 5 .. INS.target.order_word_number-1 loop
  1814.             mark_as_a_data_word(d);
  1815.          end loop;
  1816.
  1817.          the_program_has_been_analysed := True;
  1818.       end markup_a_problem_program;
  1819.
  1820.       -- This analysis assumes that the Director has much the same structure as KKT40E007UPU.
  1821.       procedure markup_a_Director is
  1822.
  1823.       begin
  1824.          BA := 0;  -- Director starts at physical word 0.
  1825.
  1826.          mark_as_a_code_word(0);
  1827.          mark_as_a_code_word(1);
  1828.          mark_as_a_code_word(2);
  1829.          mark_as_a_data_word(3);
  1830.          mark_as_a_code_word(4);
  1831.
  1832.          for a in nominated_address .. 3200 loop  -- 3200 was the size of the Eldon 2 Director.
  1833.             -- mark_as_a_code_word(a);
  1834.             -- mark_as_a_jump_target((a, 0));
  1835.             set_NIA_to((a, 0));
  1836.             decode_the_next_order;
  1837.             if INS.kind = normal_jump_order then
  1838.                mark_the_words_reachable_from((a, 0));
  1839.             elsif INS.kind = data_access_order then
  1840.                if INS.operand < 8192 then
  1841.                   declare
  1842.                      operand : constant KDF9.order_word_number
  1843.                              := KDF9.order_word_number(INS.operand);
  1844.                   begin
  1845.                      if INS.compressed_opcode /= KDF9.decoding.SET and then
  1846.                            not is_a_jump_target(operand)               then
  1847.                         mark_as_a_data_word(operand);
  1848.                      end if;
  1849.                   end;
  1850.                end if;
  1851.              else
  1852.                 mark_as_a_jump_target((a, 0));
  1853.             end if;
  1854.             set_NIA_to((a, 3));
  1855.             decode_the_next_order;
  1856.             if INS.kind = normal_jump_order then
  1857.                mark_the_words_reachable_from((a, 3));
  1858.             elsif INS.kind = data_access_order then
  1859.                if INS.operand < 8192 then
  1860.                   declare
  1861.                      operand : constant KDF9.order_word_number
  1862.                              := KDF9.order_word_number(INS.operand);
  1863.                   begin
  1864.                      if INS.compressed_opcode /= KDF9.decoding.SET and then
  1865.                            not is_a_jump_target(operand)               then
  1866.                         mark_as_a_data_word(operand);
  1867.                      end if;
  1868.                   end;
  1869.                end if;
  1870.              else
  1871.                 mark_as_a_jump_target((a, 3));
  1872.             end if;
  1873.          end loop;
  1874.
  1875.          -- Mark all orders reachable from the initial jump(s).
  1876.
  1877.          set_NIA_to((order_word_number => 2, syllable_index => 0));
  1878.          decode_the_next_order;
  1879.          if INS.kind /= normal_jump_order then
  1880.             log_line("An initial jump, in E2U, has not been found!");
  1881.          else
  1882.             mark_the_words_reachable_from((0, 2));
  1883.             -- Mark the words between E4 and P0 as data.
  1884.             set_NIA_to((0, 2));
  1885.             decode_the_next_order;
  1886.             for d in 5 .. INS.target.order_word_number-1 loop
  1887.                mark_as_a_data_word(d);
  1888.             end loop;
  1889.             the_program_has_been_analysed := True;
  1890.          end if;
  1891.
  1892.          set_NIA_to((0, 4));
  1893.          decode_the_next_order;
  1894.          if INS.kind /= normal_jump_order then
  1895.             log_line("An expected jump, in E4U, has not been found!");
  1896.             return;
  1897.          else
  1898.             mark_the_words_reachable_from((0, 4));
  1899.             the_program_has_been_analysed := True;
  1900.          end if;
  1901.
  1902.          set_NIA_to((1, 4));
  1903.          decode_the_next_order;
  1904.          if INS.kind /= normal_jump_order then
  1905.             log_line("An expected jump, in E4L, has not been found!");
  1906.             return;
  1907.          else
  1908.             mark_the_words_reachable_from((1, 4));
  1909.             the_program_has_been_analysed := True;
  1910.          end if;
  1911.       end markup_a_Director;
  1912.
  1913.    begin -- mark_all_code_blocks_and_data_blocks
  1914.       if the_program_has_been_analysed then
  1915.          return;
  1916.       end if;
  1917.
  1918.       clear_all_analysis_flags;
  1919.
  1920.       if the_execution_mode = boot_mode  then
  1921.          markup_a_Director;
  1922.       else
  1923.          markup_a_problem_program;
  1924.       end if;
  1925.
  1926.       if nominated_address < invalid_address then
  1927.          mark_the_words_reachable_from((nominated_address, 0));
  1928.       end if;
  1929.
  1930.    end mark_all_code_blocks_and_data_blocks;
  1931.
  1932.    procedure show_core_as_Usercode (first, last  : in KDF9.syllable_address;
  1933.                                     octal_option : in Boolean) is
  1934.
  1935.       six_DUMMIES : constant KDF9.word := 8#0360741703607417#;
  1936.       saved_CIA   : constant KDF9.syllable_address := CIA;
  1937.       last_word   : KDF9.word := 8#0706050403020100#; -- invalid opcodes
  1938.       comparator  : KDF9.word := last_word;
  1939.       this_word   : KDF9.word;
  1940.       address     : KDF9.syllable_address;
  1941.
  1942.       procedure show_a_block_of_orders is
  1943.
  1944.          function is_a_store_order (decoded : KDF9.decoded_order)
  1945.          return Boolean
  1946.          is (
  1947.              if decoded.kind = one_syllable_order then
  1948.                 False
  1949.              elsif decoded.kind = two_syllable_order then
  1950.                 (
  1951.                  case decoded.compressed_opcode is
  1952.                    when TO_MkMq   | TO_MkMqQ
  1953.                       | TO_MkMqH  | TO_MkMqQH
  1954.                       | TO_MkMqN  | TO_MkMqQN
  1955.                       | TO_MkMqHN | TO_MkMqQHN => True,
  1956.                    when others                 => False
  1957.                 )
  1958.              elsif decoded.kind = data_access_order then
  1959.                 (
  1960.                  case decoded.compressed_opcode is
  1961.                     when TO_EaMq | TO_EaMqQ => True,
  1962.                     when others             => False
  1963.                 )
  1964.              else
  1965.                 False
  1966.             );
  1967.
  1968.          procedure set_line_at_minimum (tab : in Natural) is
  1969.          begin
  1970.             if panel_logger.column < tab then
  1971.                tab_log_to(tab);
  1972.             end if;
  1973.          end set_line_at_minimum;
  1974.
  1975.          procedure set_line_at (tab : in Natural) is
  1976.          begin
  1977.             if panel_logger.column > tab then
  1978.                log_new_line;
  1979.             end if;
  1980.             if panel_logger.column < tab then
  1981.                tab_log_to(tab);
  1982.             end if;
  1983.          end set_line_at;
  1984.
  1985.          procedure set_at_new_line is
  1986.          begin
  1987.             if panel_logger.column > 1 then
  1988.                log_new_line;
  1989.             end if;
  1990.          end set_at_new_line;
  1991.
  1992.       last_nz_location : KDF9.syllable_address;
  1993.
  1994.       begin -- show_a_block_of_orders
  1995.          this_word := fetch_word(KDF9.address(address.order_word_number));
  1996.
  1997.          if this_word+1 < 2 or this_word = six_DUMMIES then
  1998.             -- The word is not worth logging.
  1999.             address := (address.order_word_number+1, 0);
  2000.             return;
  2001.          end if;
  2002.
  2003.          -- Log useful information about data words.
  2004.          if address.order_word_number/is_a_data_word then
  2005.             set_at_new_line;
  2006.          end if;
  2007.          loop
  2008.             if address.order_word_number/is_a_data_word then
  2009.                last_nz_location := address;
  2010.                -- Display a line of data.
  2011.                log(oct_or_dec_of(address, octal_option) & ": ");
  2012.                set_line_at(jump_tab);
  2013.                show_in_various_formats(fetch_word(KDF9.address(address.order_word_number)),
  2014.                                        column => jump_tab);
  2015.                log_new_line;
  2016.                loop
  2017.                   if address.order_word_number = last.order_word_number then
  2018.                      return;
  2019.                   end if;
  2020.                   address := (address.order_word_number+1, 0);
  2021.                exit when fetch_word(KDF9.address(address.order_word_number)) /= 0;
  2022.                end loop;
  2023.                if address.order_word_number > last_nz_location.order_word_number+1 then
  2024.                   log("========  zeros  ========");
  2025.                   log_new_line;
  2026.                end if;
  2027.             else
  2028.                log_new_line;
  2029.                exit;
  2030.             end if;
  2031.          end loop;
  2032.
  2033.          loop
  2034.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  2035.          exit when address.order_word_number = 8191;
  2036.             this_word := fetch_word(KDF9.address(address.order_word_number));
  2037.             if this_word = comparator and this_word = last_word then
  2038.                -- The word is not worth logging.
  2039.                address := (address.order_word_number+1, 0);
  2040.                return;
  2041.             end if;
  2042.
  2043.             if this_word+1 < 2 or this_word = six_DUMMIES then
  2044.                comparator := this_word;
  2045.             end if;
  2046.
  2047.             set_NIA_to(address);
  2048.             decode_the_next_order;
  2049.             if is_an_invalid_order(INS) then
  2050.                -- The word is not worth logging.
  2051.                address := (address.order_word_number+1, 0);
  2052.                return;
  2053.             end if;
  2054.
  2055.             if is_a_jump_target(address) then
  2056.                -- Start a code paragraph, with its address for easy reference.
  2057.                set_at_new_line;
  2058.                log(oct_or_dec_of(address, octal_option) & ": ");
  2059.                log_new_line;
  2060.             end if;
  2061.
  2062.             -- Set the tab position appropriately for the order type.
  2063.             case INS.kind is
  2064.                when one_syllable_order | data_access_order =>
  2065.                   set_line_at_minimum(first_tab);
  2066.                when two_syllable_order =>
  2067.                   case INS.compressed_opcode is
  2068.                      when JCqNZS =>
  2069.                         set_line_at(jump_tab);
  2070.                      when  CT_PMB_PMC_BUSY_Qq
  2071.                         |  PAR_Qq
  2072.                         |  PMF_PMG_Qq
  2073.                         |  PIA_PIC_CLO_TLO_Qq
  2074.                         |  PIB_PID_Qq
  2075.                         |  PIE_PIG_Qq
  2076.                         |  PIF_PIH_Qq
  2077.                         |  POA_POC_POE_POF_PMH_Qq
  2078.                         |  POB_POD_Qq
  2079.                         |  POG_POL_Qq
  2080.                         |  POH_POK_Qq
  2081.                         |  PMA_PMK_INT_Qq
  2082.                         |  PMA_PMK_INT_Qq+1
  2083.                         |  PMD_PME_PML_Qq
  2084.                         |  PMD_PME_PML_Qq+1 =>
  2085.                         set_line_at(first_tab);
  2086.                      when others =>
  2087.                         if panel_logger.column < first_tab then
  2088.                            set_line_at_minimum(first_tab);
  2089.                         end if;
  2090.                   end case;
  2091.                when normal_jump_order =>
  2092.                   set_line_at(jump_tab);
  2093.             end case;
  2094.
  2095.             -- Show the order in pseudo-Usercode format.
  2096.             log(the_full_name_of(INS, octal_option) &  "; ");
  2097.
  2098.             case INS.kind is
  2099.                when one_syllable_order =>
  2100.                   increment_by_1(address);
  2101.                when two_syllable_order =>
  2102.                   increment_by_2(address);
  2103.                when normal_jump_order | data_access_order =>
  2104.                   increment_by_3(address);
  2105.             end case;
  2106.
  2107.             if address.order_word_number = last.order_word_number then
  2108.                log_new_line;
  2109.                return;
  2110.             end if;
  2111.
  2112.             if (address.order_word_number+1)/is_a_data_word or
  2113.                   address.order_word_number > last.order_word_number then
  2114.                return;
  2115.             end if;
  2116.
  2117.             if is_a_store_order(INS)                   or else
  2118.                   INS.compressed_opcode = JCqNZS                or else
  2119.                      INS.kind = normal_jump_order      or else
  2120.                         panel_logger.column > last_column then
  2121.                log_new_line;
  2122.             elsif this_word = comparator and this_word /= last_word then
  2123.                log_new_line;
  2124.                log_line("==========  #"
  2125.                       & oct_of(KDF9.syllable(this_word and 255))
  2126.                       & "  ==========");
  2127.                address := (address.order_word_number+1, 0);
  2128.                if address.order_word_number > last.order_word_number or
  2129.                      address.order_word_number/is_a_data_word then
  2130.                   return;
  2131.                end if;
  2132.             end if;
  2133.
  2134.             last_word := this_word;
  2135.
  2136.          end loop;
  2137.
  2138.       end show_a_block_of_orders;
  2139.
  2140.    begin
  2141.       if the_program_has_been_analysed then
  2142.          log_line("Core store interpreted as instructions.");
  2143.          BA := 0; -- Ensure that physical store is examined when running in boot mode.
  2144.          address := first;
  2145.          loop
  2146.             show_a_block_of_orders;
  2147.             exit when address.order_word_number >= last.order_word_number;
  2148.          end loop;
  2149.          log_new_line;
  2150.          log_rule;
  2151.          CIA := saved_CIA;
  2152.          decode_the_next_order;
  2153.       else
  2154.          log_line(" ... Core store cannot be interpreted as instructions!");
  2155.          log_new_line;
  2156.       end if;
  2157.    end show_core_as_Usercode;
  2158.
  2159.    procedure show_core_as_syllables (first, last  : KDF9.syllable_address) is
  2160.
  2161.       address     :   KDF9.syllable_address;
  2162.
  2163.       procedure show_a_block is
  2164.
  2165.          procedure set_line_at (tab : Natural) is
  2166.          begin  -- set_line_at
  2167.             if panel_logger.column > tab then
  2168.                log_new_line;
  2169.             end if;
  2170.             if panel_logger.column < tab then
  2171.                tab_log_to(tab);
  2172.             end if;
  2173.          end set_line_at;
  2174.
  2175.       begin  -- show_a_block
  2176.          loop
  2177.             if address.syllable_index = 0 then
  2178.                log_new_line;
  2179.                log(oct_of(address) & ": ");
  2180.                set_line_at(jump_tab);
  2181.             end if;
  2182.             log(oct_of(fetch_syllable(address)) &  "; ");
  2183.             increment_by_1(address);
  2184.          exit when address.order_word_number > last.order_word_number;
  2185.          end loop;
  2186.          log_new_line;
  2187.       end show_a_block;
  2188.
  2189.     begin  -- show_core_as_syllables
  2190.        BA := 0; -- Ensure that physical store is examined when running in boot mode.
  2191.       log_line("Core store interpreted as order syllables.");
  2192.       address := first;
  2193.       loop
  2194.          show_a_block;
  2195.          exit when address.order_word_number > last.order_word_number;
  2196.       end loop;
  2197.       log_new_line;
  2198.       log_rule;
  2199.    end show_core_as_syllables;
  2200.
  2201.    procedure poke (address    : in KDF9.address;
  2202.                    sub_word   : in sub_word_flag;
  2203.                    position   : in KDF9.address;
  2204.                    value      : in KDF9.word) is
  2205.    begin
  2206.       case sub_word is
  2207.          when 'W' | 'w' =>
  2208.             store_word(value, address);
  2209.          when 'U' | 'u' =>
  2210.             store_halfword(value*2**24, address, 0);
  2211.          when 'L' | 'l' =>
  2212.             store_halfword(value*2**24, address, 1);
  2213.          when 'S' | 's' =>
  2214.             store_syllable(KDF9.syllable(value), address, KDF9.syllable_index(position));
  2215.          when 'C' | 'c' =>
  2216.             store_symbol(KDF9_char_sets.symbol(value), address, KDF9_char_sets.symbol_index(position));
  2217.       end case;
  2218.    end poke;
  2219.
  2220. end state_display;

Compiling: ../Source/state_display.ads
Source file time stamp: 2021-02-21 00:17:50
Compiled at: 2021-02-21 15:54:06

     1. -- Provide the comprehensive machine-state display panel KDF9 never had.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with dumping;
    18. with KDF9;
    19.
    20. use  dumping;
    21. use  KDF9;
    22.
    23. package state_display is
    24.
    25.    procedure show_all_prerun_dump_areas;
    26.
    27.    procedure show_CIA_and_NIA;
    28.
    29.    procedure show_V_and_T;
    30.
    31.    procedure show_NEST (when_empty : Boolean := True);
    32.
    33.    procedure show_SJNS (when_empty : Boolean := True);
    34.
    35.    procedure show_IO_register (the_Q_register : in KDF9.Q_register;
    36.                                width          : in Positive := 8;
    37.                                for_DR,
    38.                                for_FD,
    39.                                for_FH,
    40.                                for_seek,
    41.                                for_OUT         : in Boolean  := False);
    42.
    43.    procedure show_Q_register (the_Q_register : in KDF9.Q_register;
    44.                               width          : in Positive := 8);
    45.
    46.    procedure show_Q_store;
    47.
    48.    procedure show_registers;
    49.
    50.    procedure show_execution_context;
    51.
    52.    procedure long_witness;
    53.
    54.    procedure short_witness;
    55.
    56.    procedure log_an_external_trace_header (caption : in String := "");
    57.
    58.    procedure log_to_external_trace
    59.       with Inline => False;
    60.
    61.    procedure show_progress;
    62.
    63.    procedure show_Director_registers;
    64.
    65.    procedure show_retrospective_traces;
    66.
    67.    procedure show_current_state;
    68.
    69.    procedure show_final_state (because : String);
    70.
    71.    procedure mark_all_code_blocks_and_data_blocks;
    72.
    73.    the_program_has_been_analysed : Boolean := False;
    74.
    75.    procedure show_core_as_word_forms (first, last : in KDF9.address);
    76.
    77.    procedure show_core_as_syllables (first, last : in KDF9.syllable_address);
    78.
    79.    procedure show_core_as_Usercode (first, last  : in KDF9.syllable_address;
    80.                                     octal_option : in Boolean);
    81.
    82.    procedure show_core_in_print_code (first, last : in KDF9.address);
    83.
    84.    procedure show_core_in_card_code (first, last : in KDF9.address);
    85.
    86.    procedure show_core_in_tape_code (first, last : in KDF9.address);
    87.
    88.    procedure show_core_in_case_normal (first, last : in KDF9.address);
    89.
    90.    procedure show_core_in_case_shift (first, last : in KDF9.address);
    91.
    92.    procedure show_core_in_Latin_1 (first, last : in KDF9.address);
    93.
    94.    -- poke is included here as it has the same relationship to dumping as show_core_*.
    95.    procedure poke (address    : in KDF9.address;
    96.                    sub_word   : in sub_word_flag;
    97.                    position   : in KDF9.address;
    98.                    value      : in KDF9.word);
    99.
   100.    -- Take note that an OUT 2 or OUT 0 has been obeyed.
   101.    procedure notify_state_display_of_final_ICR;
   102.
   103. end state_display;

 2220 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/generic_logger.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:06

     1. -- Provide operations supporting replicated output to a list of logging interfaces.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. -- generic
    18. --    max_logger_list_size : in Positive;
    19. package body generic_logger is
    20.
    21.    not overriding
    22.    procedure set_logger_list (logger : in out replicator; list : in distribution_list) is
    23.    begin
    24.       logger.data := (list'Length, list);
    25.    end set_logger_list;
    26.
    27.    overriding
    28.    procedure tab_log (logger   : in out replicator;
    29.                       at_least : in Natural;
    30.                       spacing  : in Positive;
    31.                       iff      : in Boolean := True) is
    32.    begin
    33.       for l in logger.data.list'Range loop
    34.          logger.data.list(l).tab_log(at_least, spacing, iff);
    35.       end loop;
    36.    end tab_log;
    37.
    38.    overriding
    39.    procedure tab_log_to (logger : in out replicator;
    40.                          column : in Positive;
    41.                          iff    : in Boolean := True) is
    42.    begin
    43.       for l in logger.data.list'Range loop
    44.          logger.data.list(l).tab_log_to(column, iff);
    45.       end loop;
    46.    end tab_log_to;
    47.
    48.    overriding
    49.    procedure log (logger : in out replicator;
    50.                   char   : in Character;
    51.                   iff    : in Boolean := True) is
    52.    begin
    53.       for l in logger.data.list'Range loop
    54.          logger.data.list(l).log(char, iff);
    55.       end loop;
    56.    end log;
    57.
    58.    overriding
    59.    procedure log (logger : in out replicator;
    60.                   text   : in String;
    61.                   iff    : in Boolean := True) is
    62.    begin
    63.       for l in logger.data.list'Range loop
    64.          logger.data.list(l).log(text, iff);
    65.       end loop;
    66.    end log;
    67.
    68.    overriding
    69.    procedure log_new_line (logger : in out replicator;
    70.                            iff    : in Boolean := True) is
    71.    begin
    72.       for l in logger.data.list'Range loop
    73.          logger.data.list(l).log_new_line(iff);
    74.       end loop;
    75.    end log_new_line;
    76.
    77.    overriding
    78.    procedure open (logger : in out replicator; log_name : in String) is
    79.    begin
    80.       for l in logger.data.list'Range loop
    81.          logger.data.list(l).open(log_name);
    82.       end loop;
    83.    end open;
    84.
    85.    overriding
    86.    procedure close (logger : in out replicator; log_name : in String) is
    87.    begin
    88.       for l in logger.data.list'Range loop
    89.          logger.data.list(l).close(log_name);
    90.       end loop;
    91.    end close;
    92.
    93.    overriding
    94.    procedure flush (logger : in out replicator; iff : in Boolean := True) is
    95.    begin
    96.       for l in logger.data.list'Range loop
    97.          logger.data.list(l).flush(iff);
    98.       end loop;
    99.    end flush;
   100.
   101. end generic_logger;

Compiling: ../Source/generic_logger.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:06

     1. -- Provide operations supporting replicated output to a list of logging interfaces.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with logging;
    18.
    19. generic
    20.    max_logger_list_size : in Positive;
    21. package generic_logger is
    22.
    23.    type distribution_list is array (Positive range <>) of access logging.output'Class;
    24.
    25.    type replicator is new logging.output with private;
    26.
    27.    not overriding
    28.    procedure set_logger_list (logger : in out replicator; list : in distribution_list);
    29.
    30.    overriding
    31.    procedure tab_log (logger   : in out replicator;
    32.                       at_least : in Natural;
    33.                       spacing  : in Positive;
    34.                       iff      : in Boolean := True);
    35.
    36.    overriding
    37.    procedure tab_log_to (logger : in out replicator;
    38.                          column : in Positive;
    39.                          iff    : in Boolean := True);
    40.
    41.    overriding
    42.    procedure log (logger : in out replicator;
    43.                   char   : in Character;
    44.                   iff    : in Boolean := True);
    45.
    46.    overriding
    47.    procedure log (logger : in out replicator;
    48.                   text   : in String;
    49.                   iff    : in Boolean := True);
    50.
    51.    overriding
    52.    procedure log_new_line (logger : in out replicator;
    53.                            iff    : in Boolean := True);
    54.
    55.    overriding
    56.    procedure open  (logger : in out replicator; log_name : in String);
    57.
    58.    overriding
    59.    procedure close (logger : in out replicator; log_name : in String);
    60.
    61.    overriding
    62.    procedure flush (logger : in out replicator; iff : in Boolean := True);
    63.
    64. private
    65.
    66.    subtype logger_list_size is Natural range 0 .. max_logger_list_size;
    67.
    68.    -- This type is needed because tagged types cannot have discriminants.
    69.    type replica_list (length : logger_list_size := 0) is
    70.       record
    71.          list : distribution_list(1 .. length);
    72.       end record;
    73.
    74.    type replicator is new logging.output with
    75.       record
    76.          data : replica_list;
    77.       end record;
    78.
    79. end generic_logger;

 101 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/logging.ads
Source file time stamp: 2021-02-11 00:34:42
Compiled at: 2021-02-21 15:54:06

     1. -- Define an abstract log output device.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package logging is
    18.
    19.    type output is interface;
    20.
    21.    procedure tab_log (logger   : in out logging.output;
    22.                       at_least : in Natural;
    23.                       spacing  : in Positive;
    24.                       iff      : in Boolean := True) is abstract;
    25.
    26.    procedure tab_log_to (logger : in out logging.output;
    27.                          column : in Positive;
    28.                          iff    : in Boolean := True) is abstract;
    29.
    30.    procedure log (logger : in out logging.output;
    31.                   char   : in Character;
    32.                   iff    : in Boolean := True) is abstract;
    33.
    34.    procedure log (logger : in out logging.output;
    35.                   text   : in String;
    36.                   iff    : in Boolean := True) is abstract;
    37.
    38.    procedure log_new_line (logger : in out logging.output;
    39.                            iff    : in Boolean := True) is abstract;
    40.
    41.    procedure open  (logger : in out logging.output; log_name : in String) is abstract;
    42.
    43.    procedure close (logger : in out logging.output; log_name : in String) is abstract;
    44.
    45.    procedure flush (logger : in out logging.output; iff : in Boolean := True) is abstract;
    46.
    47. end logging;

 47 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/logging-file.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:06

     1. -- Provide logging output to a named text file.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18. with Ada.Unchecked_Deallocation;
    19. --
    20. with file_interfacing;
    21.
    22. use  Ada.Text_IO;
    23. --
    24. use  file_interfacing;
    25.
    26. package body logging.file is
    27.
    28.    overriding
    29.    procedure tab_log (logger   : in out file.output;
    30.                       at_least : in Natural;
    31.                       spacing  : in Positive;
    32.                       iff      : in Boolean := True) is
    33.       column_nr : constant Positive_Count := Col(logger.the_log.all) + Count(at_least);
    34.       excess    : constant Count          := column_nr mod Count(spacing);
    35.    begin
    36.       if not iff or logger.log_file_is_shut then return; end if;
    37.       Set_Col(logger.the_log.all, column_nr);
    38.       if excess /= 0 then
    39.          Set_Col(logger.the_log.all, column_nr + Count(spacing) - excess);
    40.       end if;
    41.    end tab_log;
    42.
    43.    overriding
    44.    procedure tab_log_to (logger : in out file.output;
    45.                          column : in Positive;
    46.                          iff    : in Boolean := True) is
    47.    begin
    48.       if not iff or logger.log_file_is_shut then return; end if;
    49.       Set_Col(logger.the_log.all, Positive_Count(column));
    50.    end tab_log_to;
    51.
    52.    overriding
    53.    procedure log_new_line (logger : in out file.output;
    54.                            iff    : in Boolean := True) is
    55.    begin
    56.       if not iff or logger.log_file_is_shut then return; end if;
    57.       New_Line(logger.the_log.all);
    58.    end log_new_line;
    59.
    60.    overriding
    61.    procedure log (logger : in out file.output;
    62.                   char   : in Character;
    63.                   iff    : in Boolean := True) is
    64.    begin
    65.       if not iff or logger.log_file_is_shut then return; end if;
    66.       Put(logger.the_log.all, char);
    67.    end log;
    68.
    69.    overriding
    70.    procedure log (logger : in out file.output;
    71.                   text   : in String;
    72.                   iff    : in Boolean := True) is
    73.    begin
    74.       if not iff or logger.log_file_is_shut then return; end if;
    75.       Put(logger.the_log.all, text);
    76.    end log;
    77.
    78.    overriding
    79.    procedure open (logger : in out file.output; logfile_name : in String) is
    80.    begin
    81.       if logger.log_file_is_shut then
    82.          logger.the_log := new Ada.Text_IO.File_Type;
    83.          file_interfacing.initialize(logger.the_log.all, out_file, logfile_name);
    84.          logger.log_file_is_shut := False;
    85.       end if;
    86.    end open;
    87.
    88.    overriding
    89.    procedure close (logger : in out file.output; logfile_name : in String) is
    90.
    91.       procedure free_log_file is
    92.          new Ada.Unchecked_Deallocation(Ada.Text_IO.File_Type, File_Type_access);
    93.
    94.    begin
    95.       if logger.log_file_is_shut then return; end if;
    96.       file_interfacing.finalize(logger.the_log.all, logfile_name);
    97.       free_log_file(logger.the_log);
    98.       logger.log_file_is_shut := True;
    99.    end close;
   100.
   101.    overriding
   102.    procedure flush (logger : in out file.output; iff : in Boolean := True) is
   103.    begin
   104.       if not iff or logger.log_file_is_shut then return; end if;
   105.       Flush(logger.the_log.all);
   106.    end flush;
   107.
   108. end logging.file;

Compiling: ../Source/logging-file.ads
Source file time stamp: 2021-02-11 00:34:42
Compiled at: 2021-02-21 15:54:06

     1. -- Provide logging output to a named text file.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. private with Ada.Text_IO;
    18.
    19. package logging.file is
    20.
    21.    type output is new logging.output with private;
    22.
    23.    overriding
    24.    procedure tab_log (logger   : in out file.output;
    25.                       at_least : in Natural;
    26.                       spacing  : in Positive;
    27.                       iff      : in Boolean := True);
    28.
    29.    overriding
    30.    procedure tab_log_to (logger : in out file.output;
    31.                          column : in Positive;
    32.                          iff    : in Boolean := True);
    33.
    34.    overriding
    35.    procedure log (logger : in out file.output;
    36.                   char   : in Character;
    37.                   iff    : in Boolean := True);
    38.
    39.    overriding
    40.    procedure log (logger : in out file.output;
    41.                   text   : in String;
    42.                   iff    : in Boolean := True);
    43.
    44.    overriding
    45.    procedure log_new_line (logger : in out file.output;
    46.                            iff    : in Boolean := True);
    47.
    48.    overriding
    49.    procedure open  (logger : in out file.output; logfile_name : in String);
    50.
    51.    overriding
    52.    procedure close (logger : in out file.output; logfile_name : in String);
    53.
    54.    overriding
    55.    procedure flush (logger : in out file.output; iff    : in Boolean := True);
    56.
    57. private
    58.
    59.    type File_Type_access is access Ada.Text_IO.File_Type;
    60.
    61.    type output is new logging.output with
    62.       record
    63.          log_file_is_shut : Boolean := True;
    64.          the_log          : file.File_Type_access;
    65.       end record;
    66.
    67. end logging.file;

 108 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/logging-panel.adb
Source file time stamp: 2021-02-11 00:34:42
Compiled at: 2021-02-21 15:54:06

     1. -- Provide logging output to an interactive terminal/control panel.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with POSIX;
    18. with settings;
    19.
    20. use  POSIX;
    21. use  settings;
    22.
    23. package body logging.panel is
    24.
    25.    not overriding
    26.    function column (logger : panel.display)
    27.    return Positive
    28.    is (logger.column_number);
    29.
    30.    overriding
    31.    procedure tab_log (logger   : in out panel.display;
    32.                       at_least : in Natural;
    33.                       spacing  : in Positive;
    34.                       iff      : in Boolean := True) is
    35.       new_col : constant Natural := logger.column_number + at_least;
    36.       deficit : constant Natural := (spacing - new_col mod spacing) mod spacing;
    37.    begin
    38.       if not iff then return; end if;
    39.       for i in logger.column_number .. (new_col + deficit) loop
    40.          POSIX.output(' ');
    41.       end loop;
    42.       logger.column_number := new_col + deficit;
    43.    end tab_log;
    44.
    45.    overriding
    46.    procedure tab_log_to (logger : in out panel.display;
    47.                          column : in Positive;
    48.                          iff    : in Boolean := True) is
    49.    begin
    50.       if not iff then return; end if;
    51.       if column < logger.column_number then
    52.          logger.log_new_line;
    53.       end if;
    54.       for i in logger.column_number .. column-1 loop
    55.          POSIX.output(' ');
    56.       end loop;
    57.       logger.column_number := column;
    58.    end tab_log_to;
    59.
    60.    overriding
    61.    procedure log (logger : in out panel.display;
    62.                   char   : in Character;
    63.                   iff    : in Boolean := True) is
    64.    begin
    65.       if not iff then return; end if;
    66.       POSIX.output(char);
    67.       logger.column_number := logger.column_number + 1;
    68.    end log;
    69.
    70.    overriding
    71.    procedure log (logger : in out panel.display;
    72.                   text   : in String;
    73.                   iff    : in Boolean := True) is
    74.    begin
    75.       if not iff then return; end if;
    76.       if text /= "" then
    77.          POSIX.output(text);
    78.       end if;
    79.       logger.column_number := logger.column_number + text'Length;
    80.    end log;
    81.
    82.    overriding
    83.    procedure log_new_line (logger : in out panel.display;
    84.                            iff    : in Boolean := True) is
    85.    begin
    86.       if not iff then return; end if;
    87.       POSIX.output_line;
    88.       logger.column_number := 1;
    89.    end log_new_line;
    90.
    91.    not overriding
    92.    procedure show (logger : in out panel.display; message : in String := "") is
    93.    begin
    94.       if message /= "" then
    95.          logger.log(message);
    96.       end if;
    97.    end show;
    98.
    99.    not overriding
   100.    procedure show_line (logger : in out panel.display; message : in String := "") is
   101.    begin
   102.       if message /= "" then
   103.          logger.log(message);
   104.       end if;
   105.       logger.log_new_line;
   106.    end show_line;
   107.
   108.    not overriding
   109.    procedure interact (logger : in out panel.display; reason : in String := "Mode") is
   110.       old_mode : constant settings.diagnostic_mode := the_diagnostic_mode;
   111.       response : response_kind;
   112.       choice   : Character;
   113.    begin
   114.    interaction_loop:
   115.       loop
   116.          logger.column_number := 1;
   117.          POSIX.debug_prompt(noninteractive_usage_is_enabled, reason, response, choice);
   118.          if response = name_response then
   119.             case choice is
   120.                when 'q' | 'Q' =>
   121.                   quit_was_requested := True;
   122.                   exit interaction_loop;
   123.                when 'd' | 'D' =>
   124.                   debugging_is_enabled := not debugging_is_enabled;
   125.                   exit interaction_loop;
   126.                when 'f' | 'F' =>
   127.                   set_diagnostic_mode(fast_mode);
   128.                   exit interaction_loop;
   129.                when 'p' | 'P' =>
   130.                   set_diagnostic_mode(pause_mode);
   131.                   exit interaction_loop;
   132.                when 't' | 'T' =>
   133.                   set_diagnostic_mode(trace_mode);
   134.                   exit interaction_loop;
   135.                when others =>
   136.                   null; -- An invalid choice, try again.
   137.             end case;
   138.          elsif response = EOF_response then
   139.             exit;
   140.          end if;
   141.       end loop interaction_loop;
   142.       the_diagnostic_mode_changed := (the_diagnostic_mode /= old_mode) or quit_was_requested;
   143.    end interact;
   144.
   145. end logging.panel;

Compiling: ../Source/logging-panel.ads
Source file time stamp: 2021-02-11 00:34:42
Compiled at: 2021-02-21 15:54:06

     1. -- Provide logging output to an interactive terminal/control panel.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package logging.panel is
    18.
    19.    type display is new logging.output with private;
    20.
    21.    not overriding
    22.    function column (logger : panel.display)
    23.    return Positive;
    24.
    25.    overriding
    26.    procedure tab_log (logger   : in out panel.display;
    27.                       at_least : in Natural;
    28.                       spacing  : in Positive;
    29.                       iff      : in Boolean := True);
    30.
    31.    overriding
    32.    procedure tab_log_to (logger : in out panel.display;
    33.                          column : in Positive;
    34.                          iff    : in Boolean := True);
    35.
    36.    overriding
    37.    procedure log (logger : in out panel.display;
    38.                   char   : in Character;
    39.                   iff    : in Boolean := True);
    40.
    41.    overriding
    42.    procedure log (logger : in out panel.display;
    43.                   text   : in String;
    44.                   iff    : in Boolean := True);
    45.
    46.    overriding
    47.    procedure log_new_line (logger : in out panel.display;
    48.                            iff    : in Boolean := True);
    49.
    50.    not overriding
    51.    procedure show (logger : in out panel.display; message : in String := "");
    52.
    53.    not overriding
    54.    procedure show_line (logger : in out panel.display; message : in String := "");
    55.
    56.    not overriding
    57.    procedure interact (logger : in out panel.display; reason : in String := "Mode");
    58.
    59.    overriding
    60.    procedure open (logger : in out panel.display; logfile_name : in String) is null;
    61.
    62.    overriding
    63.    procedure close (logger : in out panel.display; logfile_name : in String) is null;
    64.
    65.    overriding
    66.    procedure flush (logger : in out panel.display; iff : in Boolean := True) is null;
    67.
    68. private
    69.
    70.    type display is new logging.output with
    71.       record
    72.          column_number : Positive := 1;
    73.       end record;
    74.
    75. end logging.panel;

 145 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-the_locker_of.adb
Source file time stamp: 2021-02-20 00:00:34
Compiled at: 2021-02-21 15:54:06

     1. -- Identify the buffer that caused a store lockout.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. function IOC.the_locker_of (address : KDF9.Q_part; found : out Boolean)
    18. return KDF9.Q_part is
    19.    candidate_time   : KDF9.us     := KDF9.us'Last;
    20.    candidate_number : KDF9.Q_part := 0;
    21. begin
    22.    -- Select the buffer actively doing DMA in the_group;
    23.    --    if there is more than one, choose the buffer with the earliest completion time.
    24.    -- The latter case should not arise in practice, but is allowed by the hardware.
    25.    found := False;
    26.    for b in buffer'Range loop
    27.       if buffer(b) /= null                                               and then
    28.             buffer(b).is_busy                                            and then
    29.                buffer(b).operation in input_operation | output_operation and then
    30.                   buffer(b).completion_time < candidate_time             and then
    31.                      group(address) in group(buffer(b).control_word.I)
    32.                                     .. group(buffer(b).control_word.M)       then
    33.          found := True;
    34.          candidate_number := b;
    35.          candidate_time   := buffer(b).completion_time;
    36.       end if;
    37.    end loop;
    38.    return candidate_number;
    39. end IOC.the_locker_of;

 39 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-cpu.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:06

     1. -- Support for KDF9 CPU/ALU operations that are not automatically inherited from
     2. --   Ada types; and for types used in the internal functioning of the microcode.
     3. --
     4. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17. --
    18.
    19. with exceptions;
    20.
    21. use  exceptions;
    22.
    23. package body KDF9.CPU is
    24.
    25. --
    26. --
    27.    --
    28.    -- KDF9 Arithmetic Control (AC) primitives representing Shift Control and associated units.
    29.    -- These units implement shifting, multiplication, division, and floating-point arithmetic.
    30.    --
    31. --
    32. --
    33.
    34.    -- Count the leading zeros of the absolute value of y, omitting the sign bit.
    35.    -- If y is 0, return 47.
    36.    function nr_leading_zeros (y : KDF9.word)
    37.    return Natural is
    38.       x : CPU.u_64;
    39.       r : Natural;
    40.    begin
    41.       if y = 0 then return 47; end if;
    42.       if resign(y) < 0 then
    43.          x := CPU.u_64(16#FFFF_FFFF_FFFF# and not y);
    44.       else
    45.          x := CPU.u_64(y);
    46.       end if;
    47.       -- Only 48 bits of x need be tested.
    48.       if (x and 16#FFFF_0000_0000#) /= 0 then
    49.          r := 32; x := shift_right(x, 32);
    50.       elsif (x and 16#FFFF_0000#) /= 0 then
    51.          r := 16; x := shift_right(x, 16);
    52.       else
    53.          r := 0;
    54.       end if;
    55.       if (x and 16#FF00#) /= 0 then
    56.          r := r + 8; x := shift_right(x, 8);
    57.       end if;
    58.       if (x and 16#F0#) /= 0 then
    59.          r := r + 4; x := shift_right(x, 4);
    60.       end if;
    61.       if (x and 16#C#) /= 0 then
    62.          r := r + 2; x := shift_right(x, 2);
    63.       end if;
    64.       if (x and 16#2#) /= 0 then
    65.          r := r + 1;
    66.       end if;
    67.       r := 47 - r - 1;  -- -1 discounts the sign bit.
    68.       return r;
    69.    end nr_leading_zeros;
    70.
    71.    function nr_one_bits (u : CPU.u_64)
    72.    return CPU.u_64 is
    73.       n : CPU.u_64 := shift_right(u, 1) and 16#77_77_77_77_77_77_77_77#;
    74.       x : CPU.u_64 := u - n;
    75.    begin
    76.       n := shift_right(n, 1) and 16#77_77_77_77_77_77_77_77#;
    77.       x := x - n;
    78.       n := shift_right(n, 1) and 16#77_77_77_77_77_77_77_77#;
    79.       x := x - n;
    80.       x := (x + shift_right(x, 4)) and 16#0F_0F_0F_0F_0F_0F_0F_0F#;
    81.       x := x * 16#01_01_01_01_01_01_01_01#;
    82.       return shift_right(x, CPU.u_64'Size-8);
    83.    end nr_one_bits;
    84.
    85.    KDF9_max_signed : constant CPU.s_64 := CPU.s_64(CPU.signed'Last);
    86.    KDF9_min_signed : constant CPU.s_64 := CPU.s_64(CPU.signed'First);
    87.
    88.    function as_word (u : CPU.u_64)
    89.    return KDF9.word
    90.    is (KDF9.word(u and KDF9.word_mask));
    91.
    92.    function as_word (s : CPU.s_64)
    93.    return KDF9.word is
    94.    begin
    95.       if s > KDF9_max_signed or s < KDF9_min_signed then
    96.          the_V_bit_is_set := True;
    97.       end if;
    98.       return as_word(unsign(s));
    99.    end as_word;
   100.
   101.    function contracted (msw, lsw : KDF9.word)
   102.    return KDF9.word is
   103.    begin
   104.       if resign(lsw) < 0 or (msw+1) > 1 then
   105.          the_V_bit_is_set := True;
   106.       end if;
   107.       return (lsw and not_sign_bit) or (msw and sign_bit);
   108.    end contracted;
   109.
   110.    function contracted (P : KDF9.pair)
   111.    return KDF9.word
   112.    is (contracted(msw => P.msw, lsw => P.lsw));
   113.
   114.    function shift_time (amount : Natural)
   115.    return KDF9.us
   116.    is (KDF9.us(amount/16 + amount/8 mod 2 + (if amount mod 8 > 0 then 1 else 0)));
   117.
   118.    function normalize_time (amount : Natural)
   119.    return KDF9.us
   120.    is (KDF9.us(amount/8 + (if amount mod 8 > 0 then 1 else 0)));
   121.
   122.    function shift_word_left (W : KDF9.word; amount : word_shift_length)
   123.    return KDF9.word
   124.    is (as_word(shift_left(CPU.u_64(W), amount)));
   125.
   126.    function shift_word_right (W : KDF9.word; amount : word_shift_length)
   127.    return KDF9.word
   128.    is (KDF9.word(shift_right(CPU.u_64(W), amount)));  -- This cannot be out of range.
   129.
   130.    function rotate_word_left (W : KDF9.word; amount : word_shift_length)
   131.    return KDF9.word
   132.    is (shift_word_left(W, amount) or shift_word_right(W, 48-amount));
   133.
   134.    function rotate_word_right (W : KDF9.word; amount : word_shift_length)
   135.    return KDF9.word
   136.    is (shift_word_right(W, amount) or shift_word_left(W, 48-amount));
   137.
   138.    function shift_circular (W : KDF9.word; L : CPU.signed_Q_part)
   139.    return KDF9.word
   140.       -- The logic here conforms to 1.1 of EE Report K/GD.y.80, entitled
   141.       --    "KDF 9: SHIFTING AND SHIFT CONTROL".
   142.       -- Circular shifts were implemented by duplicating the operand, doing a double-length
   143.       --    shift of the two words, and selecting the appropriate word from the result.
   144.    is (
   145.        if abs L > 95 then 0
   146.        elsif L < -48 then shift_word_right(W, Natural(-L-48))
   147.        elsif L > +48 then shift_word_left(W, Natural(+L-48))
   148.        elsif L < 0   then rotate_word_right(W, Natural(-L))
   149.        else               rotate_word_left(W, Natural(L))
   150.       );
   151.
   152.    function shift_logical (W : KDF9.word; L : CPU.signed_Q_part)
   153.    return KDF9.word
   154.    is
   155.       (
   156.        if abs L > 47 then 0
   157.        elsif  L < 0  then shift_word_right(W, Natural(-L))
   158.        else               shift_word_left(W, Natural(L))
   159.       );
   160.
   161.    function shift_pair_left (P : KDF9.pair; L : Natural)
   162.    return KDF9.pair
   163.       with Inline;
   164.
   165.    function shift_pair_left (P : KDF9.pair; L : Natural)
   166.    return KDF9.pair is
   167.       result    : KDF9.pair;
   168.       crossover : KDF9.word;
   169.    begin
   170.       -- The logic here conforms to 3.2 of EE Report K/GD.y.80.
   171.       if L < 48 then
   172.          result.lsw := shift_word_left(P.lsw, L);
   173.          crossover  := shift_word_right(P.lsw, 48-L);
   174.          result.msw := shift_word_left(P.msw, L) or crossover;
   175.       else
   176.          result.lsw := 0;
   177.          result.msw := shift_word_left(P.lsw, L-48);
   178.       end if;
   179.       return result;
   180.    end shift_pair_left;
   181.
   182.    function shift_pair_right (P : KDF9.pair; L : Natural)
   183.    return KDF9.pair
   184.       with Inline;
   185.
   186.    function shift_pair_right (P : KDF9.pair; L : Natural)
   187.    return KDF9.pair is
   188.       result    : KDF9.pair;
   189.       crossover : KDF9.word;
   190.    begin
   191.       -- The logic here conforms to 3.2 of EE Report K/GD.y.80.
   192.       if L < 48 then
   193.          result.msw := shift_word_right(P.msw, L);
   194.          crossover  := shift_word_left(P.msw, 48-L);
   195.          result.lsw := shift_word_right(P.lsw, L) or crossover;
   196.       else
   197.          result.msw := 0;
   198.          result.lsw := shift_word_right(P.msw, L-48);
   199.       end if;
   200.       return result;
   201.    end shift_pair_right;
   202.
   203.    function shift_logical (P : KDF9.pair; L : CPU.signed_Q_part)
   204.    return KDF9.pair
   205.    is (
   206.        if    L > 0 then shift_pair_left(P, Natural(L))
   207.        elsif L < 0 then shift_pair_right(P, Natural(-L))
   208.        else        P
   209.       );
   210.
   211.    function scale_down (W : KDF9.word; amount : Natural)
   212.    return KDF9.word is
   213.       unrounded, clearing : CPU.u_64;
   214.    begin
   215.       if amount = 0 then
   216.          return W;
   217.       elsif amount > 46 then
   218.          if resign(W) < 0 then
   219.             return KDF9.all_one_bits;
   220.          else
   221.             return 0;
   222.          end if;
   223.       else
   224.          -- It is undefined whether the intrinsic shift_right_arithmetic function,
   225.          --    operating on CPU.u_64, yields a rounded result.
   226.          -- So, any rounding it might do is completely suppressed.
   227.          unrounded := shift_right_arithmetic(shift_left(CPU.u_64(W),16), 16);
   228.          clearing  := - shift_left(1, amount);
   229.          return as_word(shift_right_arithmetic(unrounded and clearing, amount));
   230.       end if;
   231.    end scale_down;
   232.
   233.    function scale_down_and_round (W : KDF9.word; amount : Natural)
   234.    return KDF9.word is
   235.       unrounded, clearing, rounding : CPU.u_64;
   236.    begin
   237.       if amount = 0 then
   238.          return W;
   239.       elsif amount > 46 then
   240.          if resign(W) < 0 then
   241.             return KDF9.all_one_bits;
   242.          else
   243.             return 0;
   244.          end if;
   245.       else
   246.          -- It is undefined whether the intrinsic shift_right_arithmetic,
   247.          --    operating on CPU.u_64, yields a rounded result.
   248.          -- So, any rounding it might do is suppressed,
   249.          --    and correct rounding is explicitly computed.
   250.          unrounded := shift_right_arithmetic(shift_left(CPU.u_64(W),16), 16);
   251.          rounding  := shift_right(unrounded, amount-1) and 1;
   252.          clearing  := - shift_left(1, amount);
   253.          unrounded := unrounded and clearing;
   254.          return as_word(shift_right_arithmetic(unrounded, amount) + rounding);
   255.       end if;
   256.    end scale_down_and_round;
   257.
   258.    function scale_up (W : KDF9.word; amount : Natural)
   259.    return KDF9.word is
   260.       M : constant Natural := Natural'Min(amount, 47);
   261.    begin
   262.       if resign(W) < 0 then
   263.          if scale_down(W, 47-M) /= all_one_bits or
   264.                resign(shift_word_left(W, M)) >= 0 then
   265.             -- See EE Report K/GD.y.80.,  1.1.
   266.             the_V_bit_is_set := True;
   267.          end if;
   268.          return shift_word_left(W, M);
   269.       else
   270.          if shift_word_right(W, 47-M) /= all_zero_bits or
   271.                resign(shift_word_left(W, M)) < 0 then
   272.             -- See EE Report K/GD.y.80.,  1.1.
   273.             the_V_bit_is_set := True;
   274.          end if;
   275.          return shift_word_left(W, M);
   276.       end if;
   277.    end scale_up;
   278.
   279.    function shift_arithmetic (I : KDF9.word; L : CPU.signed_Q_part)
   280.    return KDF9.word
   281.    is (
   282.        if L < 0 then scale_down_and_round(I, Natural(-L))
   283.        else          scale_up(I, Natural(L))
   284.       );
   285.
   286.    function scale_up (P : KDF9.pair; L : Natural)
   287.    return KDF9.pair is
   288.       result    : KDF9.pair;
   289.       crossover : KDF9.word;
   290.    begin
   291.       -- The logic here conforms to 3.2 of EE Report K/GD.y.80.
   292.       if L < 48 then
   293.          result.lsw := shift_word_left(P.lsw, L) and KDF9.max_word;
   294.          crossover  := shift_word_right(P.lsw and KDF9.max_word, 47-L);
   295.          result.msw := scale_up(P.msw, L) or crossover;
   296.       else
   297.          result.lsw := 0;
   298.          result.msw := scale_up(P.msw, 47) or P.lsw;
   299.          result.msw := scale_up(result.msw, Natural'Min(L, 94)-47);
   300.      end if;
   301.       return result;
   302.    end scale_up;
   303.
   304.    function scale_down (P : KDF9.pair; L : Natural)
   305.    return KDF9.pair is
   306.       result    : KDF9.pair;
   307.       crossover : KDF9.word;
   308.    begin
   309.       -- The logic here conforms to 3.2 of EE Report K/GD.y.80.
   310.       -- SHAD-n does NOT round, according to the Manual.
   311.       if L < 48 then
   312.          result.msw := scale_down(P.msw, L);
   313.          crossover  := shift_word_left(P.msw, 47-L) and KDF9.max_word;
   314.          -- It is not clear whether D0 of the lsw should be cleared before or after shifting.
   315.          -- I now clear it before shifting for compatibility with D. Holdsworth's "kdf9".
   316.          result.lsw := shift_word_right(P.lsw and KDF9.max_word, L) or crossover;
   317.       else
   318.          result.msw := scale_down(P.msw, 47);
   319.          result.lsw := shift_word_right(P.msw, Natural'Min(L, +94)-47) and KDF9.max_word;
   320.       end if;
   321.       return result;
   322.    end scale_down;
   323.
   324.    function shift_arithmetic (P : KDF9.pair; L : CPU.signed_Q_part)
   325.    return KDF9.pair
   326.    is (
   327.        if    L < 0 then scale_down(P, Natural(-L))
   328.        elsif L > 0 then scale_up(P, Natural(L))
   329.        else             P -- See 1.1 of EE Report K/GD.y.80: this avoids clearing D0 of P.lsw.
   330.       );
   331.
   332.    procedure normalize (fraction, exponent : in out KDF9.word) is
   333.       sign_flag  : constant KDF9.word := shift_word_right(fraction and sign_bit, 1);
   334.       normalizer : Natural;
   335.    begin
   336.       if fraction = 0 then
   337.          exponent := 2#10_000_000#;  -- This yields 0 when biased positive.
   338.          return;
   339.       end if;
   340.
   341.       normalizer := nr_leading_zeros(fraction);
   342.       exponent := exponent - KDF9.word(normalizer);
   343.
   344.       -- shift_word_left is used, not _arithmetic, as D[1..normalizer] = D0
   345.       fraction := shift_word_left(fraction, normalizer);
   346.
   347.       the_CPU_delta := the_CPU_delta + normalize_time(normalizer);
   348.
   349.       -- scale_down_and_round may round up and overflow the fraction bits ...
   350.       fraction := scale_down_and_round(fraction, 8);
   351.       if (fraction and overflow_mask) /= shift_word_right(sign_flag, 7) then
   352.           -- ... so re-normalize; scale_down cannot round here.
   353.          fraction := scale_down(fraction, 1);
   354.          the_CPU_delta := the_CPU_delta + normalize_time(1);
   355.          exponent := exponent + 1;
   356.          the_CPU_delta := the_CPU_delta + 1;
   357.       end if;
   358.       fraction := fraction and mantissa_mask;
   359.
   360.       if resign(exponent) < -128 then
   361.          -- Deal with underflow.
   362.          fraction := 0;
   363.          exponent := 2#10_000_000#;  -- This yields 0 when biased positive.
   364.       elsif resign(exponent) > +127 then
   365.          -- Deal with overflow.
   366.          the_V_bit_is_set := True;
   367.          exponent := 2#01_111_111#;
   368.       end if;
   369.    end normalize;
   370.
   371.    function fraction_word (mantissa : CPU.f48)
   372.    return KDF9.word
   373.     -- shift_word_left must be used instead of scale_up to avoid a spurious overflow.
   374.    is (
   375.        (shift_word_left(as_word(mantissa), 8) and KDF9.max_word)
   376.           or
   377.        (as_word(mantissa) and sign_bit)
   378.       );
   379.
   380.    function masked_mantissa (F : CPU.f48)
   381.    return CPU.f48
   382.    is (as_f48(as_word(F) and mantissa_mask));
   383.
   384.    function scaler (F : CPU.f48)
   385.    return KDF9.word
   386.    is ((shift_word_right(as_word(F), 39) and 2#11_111_111#) - 128);
   387.
   388.    function normalized (full_fraction, scaler : KDF9.word)
   389.    return CPU.f48 is
   390.       E : KDF9.word := scaler;
   391.       F : KDF9.word := full_fraction;
   392.    begin
   393.       normalize(fraction => F, exponent => E);
   394.       return CPU.f48(shift_word_left((E + 128) and 2#11_111_111#, 39) or F);
   395.    end normalized;
   396.
   397.    function normalized  (R : CPU.f48)
   398.    return CPU.f48
   399.    is (normalized(full_fraction => fraction_word(R), scaler => scaler(R)));
   400.
   401.    function cardinality (W : KDF9.word)
   402.    return KDF9.word
   403.    is (KDF9.word(nr_one_bits(CPU.u_64(W))));
   404.
   405.    function "-" (I : CPU.signed)
   406.    return KDF9.word
   407.    is (as_word(-CPU.s_64(I)));
   408.
   409.    function "abs" (I : CPU.signed)
   410.    return KDF9.word
   411.    is (as_word(abs CPU.s_64(I)));
   412.
   413.    function "+" (L, R : CPU.signed)
   414.    return KDF9.word
   415.    is (as_word(CPU.s_64(L) + CPU.s_64(R)));
   416.
   417.    function "-" (L, R : CPU.signed)
   418.    return KDF9.word
   419.    is (as_word(CPU.s_64(L) - CPU.s_64(R)));
   420.
   421.    function "*" (L, R : CPU.signed)
   422.    return KDF9.word
   423.    is (contracted(KDF9.pair'(unsign(L) * unsign(R))));
   424.
   425.    procedure do_DIVI (L : in KDF9.word;
   426.                       R : in KDF9.word;
   427.                       Quotient, Remainder : out KDF9.word) is
   428.    begin
   429.       if R /= 0 then
   430.          Remainder := as_word(CPU.s_64(resign(L)) mod CPU.s_64(resign(R)));
   431.          Quotient  :=
   432.             as_word((CPU.s_64(resign(L)) - CPU.s_64(resign(Remainder))) / CPU.s_64(resign(R)));
   433.       else
   434.          the_V_bit_is_set := True;
   435.          Quotient  := L;  -- ??
   436.          Remainder := R;  -- ??
   437.       end if;
   438.    end do_DIVI;
   439.
   440.    function "*" (L, R : KDF9.word)
   441.    return CPU.fraction is
   442.    begin
   443.       if L = sign_bit and R = sign_bit then
   444.          the_V_bit_is_set := True;
   445.          return as_fraction(sign_bit);  -- The only case is L = R = -1.0 = L*R.
   446.       else
   447.          return as_fraction(L) * as_fraction(R);
   448.       end if;
   449.    end "*";
   450.
   451.    function "/" (L, R : KDF9.word)
   452.    return CPU.fraction is
   453.    begin
   454.       if R = 0 or L = sign_bit then
   455.          the_V_bit_is_set := True;
   456.          return as_fraction(L); -- ??
   457.       elsif R = sign_bit then
   458.          return -as_fraction(L);
   459.       elsif abs as_fraction(L) < abs as_fraction(R) then  -- abs is safe now.
   460.          return as_fraction(L) / as_fraction(R);
   461.       else
   462.          the_V_bit_is_set := True;
   463.          return as_fraction(L); -- ??
   464.       end if;
   465.    end "/";
   466.
   467.    function "+" (L, R : KDF9.pair)
   468.    return KDF9.pair is
   469.       carry, sum : CPU.s_64;
   470.       result     : KDF9.pair;
   471.    begin
   472.       sum := CPU.s_64(L.lsw) + CPU.s_64(R.lsw);
   473.       if unsign(sum) > KDF9.max_word then -- carry into msw
   474.          carry := 1;
   475.          result.lsw := KDF9.word(unsign(sum) and KDF9.max_word);
   476.       else
   477.          carry := 0;
   478.          result.lsw := KDF9.word(sum);
   479.       end if;
   480.       sum := CPU.s_64(resign(L.msw)) + CPU.s_64(resign(R.msw)) + carry;
   481.       result.msw := as_word(sum);
   482.       return result;
   483.    end "+";
   484.
   485.    function "-" (J : KDF9.pair)
   486.    return KDF9.pair is
   487.       borrow,
   488.       negative : CPU.s_64;
   489.       result   : KDF9.pair;
   490.    begin
   491.       negative := - CPU.s_64(J.lsw);
   492.       if unsign(negative) > KDF9.max_word then -- borrow from msw
   493.          borrow := 1;
   494.          result.lsw := KDF9.word(unsign(negative) and KDF9.max_word);
   495.       else
   496.          borrow := 0;
   497.          result.lsw := KDF9.word(negative);
   498.       end if;
   499.       negative := - CPU.s_64(resign(J.msw)) - borrow;
   500.       result.msw := as_word(negative);
   501.       return result;
   502.    end "-";
   503.
   504.    function "-" (L, R : KDF9.pair)
   505.    return KDF9.pair is
   506.       borrow,
   507.       difference : CPU.s_64;
   508.       result     : KDF9.pair;
   509.    begin
   510.       difference := CPU.s_64(L.lsw) - CPU.s_64(R.lsw);
   511.       if unsign(difference) > KDF9.max_word then -- borrow from msw
   512.          borrow := 1;
   513.          result.lsw := KDF9.word(unsign(difference) and KDF9.max_word);
   514.       else
   515.          borrow := 0;
   516.          result.lsw := KDF9.word(difference);
   517.       end if;
   518.       difference := CPU.s_64(resign(L.msw)) - CPU.s_64(resign(R.msw)) - borrow;
   519.       result.msw := as_word(difference);
   520.       return result;
   521.    end "-";
   522.
   523.    function "*" (L, R : KDF9.word)
   524.    return KDF9.pair is
   525.       S, T, U, V, W : KDF9.word;
   526.       H, M, B       : KDF9.pair;
   527.    begin
   528.       if L = sign_bit then
   529.          if R = L then
   530.             -- L*R = (+1.0), which is not a valid fraction, so deal with overflow.
   531.             the_V_bit_is_set := True;
   532.             return (L, 0);
   533.          else
   534.             -- L*R = -R.
   535.             return - (R, 0);
   536.          end if;
   537.       end if;
   538.       if R = sign_bit then
   539.          -- L*R = -L.
   540.          return - (L, 0);
   541.       end if;
   542.       -- Now it is safe to take absolute values, as they cannot overflow.
   543.       S := scale_down(abs resign(L), 24);
   544.       T := abs resign(L) and halfword_mask;
   545.       U := scale_down(abs resign(R), 24);
   546.       V := abs resign(R) and halfword_mask;
   547.       H := ((S*U)*2, 0);
   548.       M := scale_down((KDF9.word'(S*V), 0), 1) + scale_down((KDF9.word'(T*U), 0), 1);
   549.       M := scale_down(M, 22);
   550.       W := rotate_word_left(KDF9.word'(T*V), 1);
   551.       B := (W and 1, shift_word_right(W, 1));
   552.       if resign(L xor R) < 0 then
   553.          return - (H + M + B);
   554.       else
   555.          return    H + M + B;
   556.       end if;
   557.    end "*";
   558.
   559.    f_64_small : constant := 2.0**(-63);
   560.    type f_64 is delta f_64_small range -1.0 .. +1.0 - f_64_small with Size => 64;
   561.
   562.    function scale_down (f : CPU.f_64; N : Natural)
   563.    return f_64
   564.    is (if N > 62 then 0.0 else f / 2**N);
   565.
   566.    function to_f_64 (w : KDF9.word)
   567.    return CPU.f_64
   568.    is (CPU.f_64(as_fraction(w)));
   569.
   570.    function to_word (f : CPU.f_64)
   571.    return KDF9.word
   572.    is (as_word(CPU.fraction(f)));
   573.
   574.    procedure do_DIVD (L : in KDF9.pair;
   575.                       R : in KDF9.word;
   576.                       Q : out KDF9.word
   577.                      ) is
   578.       to_normalize_L : Natural;
   579.       to_normalize_R : Natural;
   580.       to_normalize_Q : Integer;
   581.       N              : KDF9.pair;
   582.       D              : KDF9.word;
   583.       Ls, Rs, Qs     : CPU.f_64;
   584.    begin
   585.       -- Deal very quickly with a zero result.
   586.       if (L.msw or L.lsw) = 0 then
   587.          Q := 0;
   588.          return;
   589.       end if;
   590.
   591.       -- Deal with division by 0.
   592.       if R = 0 then
   593.          the_V_bit_is_set := True;
   594.          Q := L.msw;  -- This is a guess at the result for division by zero ?? !!
   595.          return;
   596.       end if;
   597.
   598.       -- Check for an invalid numerator; D0 of L.lsw must be 0.
   599.       if resign(L.lsw) < 0 then -- L is not a valid double-length number.
   600.          the_V_bit_is_set := True;
   601.          Q := L.msw;  -- This is a guess at the result for an invalid numerator ?? !!
   602.          return;
   603.       end if;
   604.
   605.       to_normalize_L := nr_leading_zeros(L.msw);
   606.       if to_normalize_L > 46 then -- insignificant top half
   607.          N := scale_up(L, 47);
   608.          to_normalize_L := nr_leading_zeros(N.msw);
   609.          N := scale_up(N, to_normalize_L);
   610.          to_normalize_L := to_normalize_L + 47;
   611.       else
   612.          N := scale_up(L, to_normalize_L);
   613.       end if;
   614.
   615.       to_normalize_R := nr_leading_zeros(R);
   616.       D := scale_up(R, to_normalize_R);
   617.
   618.       -- Scale Ls and Rs so that the Ada fractional division cannot overflow.
   619.       Ls := scale_down(to_f_64(N.msw), 2);
   620.       Rs := scale_down(to_f_64(D), 1);
   621.
   622.       Qs := Ls / Rs;  -- "/" cannot overflow here.
   623.
   624.       to_normalize_Q := 1 + to_normalize_R - to_normalize_L;
   625.
   626.       if to_normalize_Q <= 0 then
   627.          -- Overflow is impossible.
   628.          Qs := scale_down(Qs, -to_normalize_Q);
   629.          Q := to_word(Qs);
   630.       else
   631.          -- If Qs >= 0.5, then L/R >= 1.0 is not a representable result fraction.
   632.          -- If Qs < -0.5, then L/R < -1.0 is not a representable result fraction.
   633.          if Qs >= 0.5 or Qs < -0.5 then
   634.             the_V_bit_is_set := True;
   635.             Q := L.msw / R;  -- This is a guess at the result when it overflows ?? !!
   636.             return;
   637.          end if;
   638.          Q := scale_up(to_word(Qs), to_normalize_Q);
   639.       end if;
   640.    end do_DIVD;
   641.
   642.    procedure do_DIVR (L : in KDF9.pair;
   643.                       R : in KDF9.word;
   644.                       Quotient, Remainder : out KDF9.word
   645.                      ) is
   646.       correction_count_limit : constant := 3;
   647.       correction_count       : Natural  := 0;
   648.       V  : constant Boolean := the_V_bit_is_set;
   649.       N  : KDF9.pair := L;
   650.       D  : KDF9.word := R;
   651.       S  : KDF9.word := +1;
   652.       P,
   653.       T  : KDF9.pair;
   654.    begin
   655.       if (N.msw or N.lsw) = 0 then
   656.          Quotient  := 0;
   657.          Remainder := 0;
   658.          return;
   659.       end if;
   660.
   661.       if D = 0 then
   662.          the_V_bit_is_set := True;
   663.          Quotient  := L.msw;  -- This is a guess at the result for division by zero ?? !!
   664.          Remainder := L.lsw;  -- This is a guess at the result for division by zero ?? !!
   665.          return;
   666.       end if;
   667.
   668.       -- Check for an invalid numerator; D0 of N1 must be 0.
   669.       if resign(L.lsw) < 0 then -- L is not a valid double-length number.
   670.          the_V_bit_is_set := True;
   671.          Quotient  := L.msw;  -- This is a guess at the result for invalid numerator ?? !!
   672.          Remainder := L.lsw;  -- This is a guess at the result for invalid numerator ?? !!
   673.          return;
   674.       end if;
   675.
   676.       -- Convert to an unsigned division problem, and note whether it needs to be be converted back.
   677.       if resign(N.msw) < 0 then -- L is negative.
   678.          N := - N;
   679.          S := - S;
   680.       end if;
   681.
   682.       if resign(D) < 0 then  -- R is negative.
   683.          D := - D;
   684.          S := - S;
   685.       end if;
   686.
   687.       -- Check for inevitable overflow, and deal with it separately.
   688.       if N.msw > D then
   689.          Quotient := N.msw / D * S;  -- This is a guess at the result when it overflows ?? !!
   690.          T := L - (msw => Quotient*R, lsw => 0);
   691.          Remainder := T.msw;         -- This is a guess at the result when it overflows ?? !!
   692.          the_V_bit_is_set := True;
   693.          return;
   694.       end if;
   695.
   696.       -- Overflow should not now be possible.
   697.       -- Ensure that an overflow in DIVD is trapped as a failure
   698.       the_V_bit_is_set := False;
   699.       do_DIVD(N, D, Quotient);
   700.       if the_V_bit_is_set then
   701.          raise emulation_failure with "DIVR overflows in DIVD";
   702.       end if;
   703.       -- Restore the input value of the overflow register.
   704.       the_V_bit_is_set := V;
   705.
   706.       -- Adjust Quotient until the difference between N and Quotient*D fits in one word.
   707.       correction_count := 0;
   708.       loop
   709.          P := Quotient * D;
   710.          T := N - P;
   711.       exit when T.msw = 0;
   712.          correction_count := correction_count + 1;
   713.          if correction_count > correction_count_limit then
   714.              raise emulation_failure with "DIVR exceeds correction_count_limit A";
   715.          end if;
   716.          Quotient := Quotient + 1;
   717.       end loop;
   718.
   719.       Remainder := T.lsw;
   720.
   721.       -- Adjust Quotient and Remainder until Remainder is less than the divisor in absolute value.
   722.       correction_count := 0;
   723.       while Remainder >= D loop
   724.          correction_count := correction_count + 1;
   725.          if resign(Remainder) > 0 then
   726.             Remainder := Remainder - D;
   727.             Quotient := Quotient + 1;
   728.          else
   729.             Remainder := Remainder + D;
   730.             Quotient := Quotient - 1;
   731.          end if;
   732.          if correction_count > correction_count_limit then
   733.              raise emulation_failure with "DIVR exceeds correction_count_limit B";
   734.          end if;
   735.       end loop;
   736.
   737.       Quotient  := Quotient * S;
   738.       Remainder := contracted(L - Quotient*R);
   739.    end do_DIVR;
   740.
   741.    function host_float (X : CPU.f48)
   742.    return Long_Float is
   743.       -- Warn if Long_Float does not have at least the range of a KDF9 floating point number.
   744.       pragma Compile_Time_Warning(Long_Float'Last < 2.0**127,
   745.                                   "Long_Float does not have enough range for KDF9 f.p.");
   746.       -- Warn if Long_Float does not have at least the precision of a KDF9 floating point number.
   747.       pragma Compile_Time_Warning(Long_Float'Small > 1.0/2.0**39,
   748.                                   "Long_Float does not have enough precision for KDF9 f.p.");
   749.       W : constant KDF9.word  := fraction_word(masked_mantissa(X));
   750.       S : constant Long_Float := 2.0**Integer(resign(scaler(X)));
   751.    begin
   752.       return Long_Float(as_fraction(W)) * S;  -- Cannot overflow if warnings are absent.
   753.    end host_float;
   754.
   755.    -- Round a 48-bit floating-point number to 24-bit format.
   756.    function narrowed (R : CPU.f48)
   757.    return CPU.f48
   758.    is (normalized(fraction_word(R) + 2**23, scaler(R)));
   759.
   760.    overriding
   761.    function "-" (R : CPU.f48)
   762.    return CPU.f48 is
   763.       -- F is made half of a true fraction to prevent overflow when negating:
   764.       --    the result exponent is offset by 1, accordingly.
   765.       E : constant KDF9.word := scaler(R) + 1;
   766.       F : KDF9.word := scale_down_and_round(fraction_word(R), 1);
   767.    begin
   768.       F := as_word(CPU.u_64(-F));  -- "-" cannot overflow here.
   769.       return normalized(full_fraction => F, scaler => E);
   770.    end "-";
   771.
   772.    overriding
   773.    function "abs" (R : CPU.f48)
   774.    return CPU.f48
   775.    is (if resign(KDF9.word(R)) < 0 then - R else + R);
   776.
   777.    overriding
   778.    function "+" (L, R : CPU.f48)
   779.    return CPU.f48 is
   780.       -- B and D are made half of a true fraction to prevent overflow when
   781.       --    adding; the result exponent is offset by 1, accordingly.
   782.       A : constant KDF9.word := scaler(R);
   783.       B : KDF9.word := scale_down(fraction_word(R), 1);
   784.       C : constant KDF9.word := scaler(L);
   785.       D : KDF9.word := scale_down(fraction_word(L), 1);
   786.       E : KDF9.word;
   787.       F : KDF9.word;
   788.       N : Natural;
   789.    begin
   790.       if resign(A) >= resign(C) then
   791.          N := Natural'Min(Natural(resign(A-C)), 48);
   792.          D := scale_down_and_round(D, N);
   793.          E := A + 1;
   794.       else
   795.          N := Natural'Min(Natural(resign(C-A)), 48);
   796.          B := scale_down_and_round(B, N);
   797.          E := C + 1;
   798.       end if;
   799.       the_CPU_delta := the_CPU_delta + shift_time(N);
   800.       F := as_word(CPU.u_64(D + B));  -- "+" cannot overflow here.
   801.       return normalized(full_fraction => F, scaler => E);
   802.    end "+";
   803.
   804.    overriding
   805.    function "-" (L, R : CPU.f48)
   806.    return CPU.f48 is
   807.       -- See "+".
   808.       A : constant KDF9.word := scaler(R);
   809.       B : KDF9.word := scale_down(fraction_word(R), 1);
   810.       C : constant KDF9.word := scaler(L);
   811.       D : KDF9.word := scale_down(fraction_word(L), 1);
   812.       E : KDF9.word;
   813.       F : KDF9.word;
   814.       N : Natural;
   815.    begin
   816.       if resign(A) >= resign(C) then
   817.          N := Natural'Min(Natural(resign(A-C)), 48);
   818.          D := scale_down_and_round(D, N);
   819.          E := A + 1;
   820.       else
   821.          N := Natural'Min(Natural(resign(C-A)), 48);
   822.          B := scale_down_and_round(B, N);
   823.          E := C + 1;
   824.       end if;
   825.       the_CPU_delta := the_CPU_delta + shift_time(N);
   826.       F := as_word(CPU.u_64(D - B));  -- "-" cannot overflow here.
   827.       return normalized(full_fraction => F, scaler => E);
   828.    end "-";
   829.
   830.    overriding
   831.    function "*" (L, R : CPU.f48)
   832.    return CPU.f48 is
   833.       B, D, E, F : KDF9.word;
   834.    begin
   835.       if (KDF9.word(L) or KDF9.word(R)) = 0 then
   836.          return 0;
   837.       end if;
   838.       B := fraction_word(R);
   839.       D := fraction_word(L);
   840.       E := scaler(L) + scaler(R);
   841.       if (B = sign_bit) and (B = D) then
   842.           -- D*B = (+1), which is not a valid fraction, so treat specially.
   843.           B := B / 2;
   844.           D := D / 2;
   845.           E := E + 2;
   846.        end if;
   847.       F := as_word(as_fraction(D) * as_fraction(B));  -- "*" cannot overflow here.
   848.       return normalized(full_fraction => F, scaler => E);
   849.    end "*";
   850.
   851.    overriding
   852.    function "/" (L, R : CPU.f48)
   853.    return CPU.f48 is
   854.       D, N   : CPU.fraction;
   855.       Ls, Rs : KDF9.word;
   856.       E, F   : KDF9.word;
   857.    begin
   858.       if R = 0 then
   859.          the_V_bit_is_set := True;
   860.          return L;  -- ?? This result is not well defined in the Manual.
   861.       end if;
   862.       -- If L>=R, L/R>= 1, which is not a valid fraction; so Ls and Rs are
   863.       --    scaled so that the division cannot overflow.
   864.       Ls := scale_down(fraction_word(L), 3);
   865.       Rs := scale_down(fraction_word(R), 1);
   866.       N := abs as_fraction(Ls);  -- Ls is scaled down by 1/8, so "abs" cannot overflow.
   867.       D := abs as_fraction(Rs);  -- Rs is scaled down by 1/2, so "abs" cannot overflow.
   868.       -- E is increased by 2 to compensate the quotient's scaling by 1/4.
   869.       E := scaler(L) - scaler(R) + 2;
   870.       F := as_word(N / D);  -- "/" cannot overflow here.
   871.       if resign(KDF9.word(L) xor KDF9.word(R)) < 0 then
   872.          -- The result is negative.
   873.          F := -F;
   874.       end if;
   875.       return normalized(full_fraction => F, scaler => E);
   876.    end "/";
   877.
   878.    overriding
   879.    function "<" (L, R : CPU.f48)
   880.    return Boolean is
   881.       s : constant KDF9.word := KDF9.word(L) xor KDF9.word(R);
   882.    begin
   883.       if resign(s) < 0 then
   884.          -- The signs differ: L<R iff L is negative.
   885.          return resign(KDF9.word(L)) < 0;
   886.       elsif resign(KDF9.word(L)) < 0 then
   887.          -- L and R are both negative, so invert lexicographical order.
   888.          return not (KDF9.word(L) < KDF9.word(R));
   889.       else
   890.          -- L and R are both non-negative: so use lexicographical order.
   891.          return KDF9.word(L) < KDF9.word(R);
   892.       end if;
   893.    end "<";
   894.
   895.    function fraction_pair (DF : CPU.f96)
   896.    return KDF9.pair
   897.    is (scale_up((msw => scale_down(fraction_word(DF.msw), 8), lsw => fraction_word(DF.lsw)), 8));
   898.
   899.    function scaler (DF : CPU.f96)
   900.    return KDF9.word
   901.    is (scaler(DF.msw));
   902.
   903.    function narrowed (DF : CPU.f96)
   904.    return CPU.f48 is
   905.       fraction : KDF9.pair := fraction_pair(DF) + (0, 2**46);
   906.    begin
   907.       reconstruct(fraction, scaler(DF));
   908.       return CPU.f48(fraction.msw);
   909.    end narrowed;
   910.
   911.    procedure reconstruct (frac   : in out KDF9.pair;
   912.                           scaler : in KDF9.word) is
   913.       KDF9_exponent :  KDF9.word := scaler + 128;
   914.       normalizer    : Natural;
   915.    begin
   916.       if (frac.msw or frac.lsw) = 0 then
   917.          return; -- frac is already normalized.
   918.       end if;
   919.
   920.       normalizer := nr_leading_zeros(frac.msw);
   921.
   922.       if normalizer = 47 then  -- frac.msw is zero, so frac.lsw is non-zero.
   923.          normalizer := 47 + nr_leading_zeros(frac.lsw);
   924.       end if;
   925.
   926.       KDF9_exponent := KDF9_exponent - KDF9.word(normalizer);
   927.
   928.       frac := scale_up(frac, normalizer);
   929.       the_CPU_delta := the_CPU_delta + shift_time(normalizer);
   930.
   931.       -- 96-bit shift_arithmetic does not round and so cannot overflow here.
   932.       frac := scale_down(frac, 8);
   933.       frac.lsw := scale_down(frac.lsw, 8);
   934.       -- Clear both scaler fields.
   935.       frac.msw := frac.msw and mantissa_mask;
   936.       frac.lsw := frac.lsw and mantissa_mask;
   937.       if resign(KDF9_exponent) < 0 then
   938.          -- Deal with underflow.
   939.          frac := (0, 0);
   940.          return;
   941.       elsif KDF9_exponent > 255 then
   942.          -- Deal with overflow.
   943.          the_V_bit_is_set := True;
   944.          KDF9_exponent := 255;
   945.       end if;
   946.
   947.       frac.msw := frac.msw or shift_word_left(KDF9_exponent and 8#377#, 39);
   948.       if KDF9_exponent < 39 then
   949.          frac.lsw := 0;
   950.       else
   951.          frac.lsw := frac.lsw or shift_word_left((KDF9_exponent-39) and 8#377#, 39);
   952.       end if;
   953.    end reconstruct;
   954.
   955.    function "-" (R : CPU.f96)
   956.    return CPU.f96
   957.    is (CPU.f96'(0, 0) - R);
   958.
   959.    function "+" (L, R : CPU.f96)
   960.    return CPU.f96 is
   961.       -- Scale fractions to prevent overflow; must adjust exponent accordingly.
   962.       L_exponent : constant KDF9.word := scaler(L);
   963.       R_exponent : constant KDF9.word := scaler(R);
   964.       L_fraction : KDF9.pair := scale_down(fraction_pair(L), 1);
   965.       R_fraction : KDF9.pair := scale_down(fraction_pair(R), 1);
   966.       exponent   : KDF9.word;
   967.       the_result : KDF9.pair;
   968.       aligner    : Natural;
   969.    begin
   970.       if resign(R_exponent) >= resign(L_exponent) then
   971.          aligner := Natural(resign(R_exponent-L_exponent));
   972.          aligner := Natural'Min(95, aligner);
   973.          L_fraction := scale_down(L_fraction, aligner);
   974.          exponent := R_exponent + 1;
   975.       else
   976.          aligner := Natural(resign(L_exponent-R_exponent));
   977.          aligner := Natural'Min(95, aligner);
   978.          R_fraction := scale_down(R_fraction, aligner);
   979.          exponent := L_exponent + 1;
   980.       end if;
   981.       the_CPU_delta := the_CPU_delta + shift_time(aligner);
   982.       the_result := L_fraction + R_fraction;  -- "+" cannot overflow here.
   983.       reconstruct(the_result, scaler => exponent);
   984.       return as_f96(the_result);
   985.    end "+";
   986.
   987.    function "-" (L, R : CPU.f96)
   988.    return CPU.f96 is
   989.       -- See "+".
   990.       L_exponent : constant KDF9.word := scaler(L);
   991.       R_exponent : constant KDF9.word := scaler(R);
   992.       L_fraction : KDF9.pair := scale_down(fraction_pair(L), 1);
   993.       R_fraction : KDF9.pair := scale_down(fraction_pair(R), 1);
   994.       exponent   : KDF9.word;
   995.       the_result : KDF9.pair;
   996.       aligner    : Natural;
   997.    begin
   998.       if resign(R_exponent) >= resign(L_exponent) then
   999.          aligner := Natural(resign(R_exponent-L_exponent));
  1000.          aligner := Natural'Min(95, aligner);
  1001.          L_fraction := scale_down(L_fraction, aligner);
  1002.          exponent := R_exponent + 1;
  1003.       else
  1004.          aligner := Natural(resign(L_exponent-R_exponent));
  1005.          aligner := Natural'Min(95, aligner);
  1006.          R_fraction := scale_down(R_fraction, aligner);
  1007.          exponent := L_exponent + 1;
  1008.       end if;
  1009.       the_CPU_delta := the_CPU_delta + shift_time(aligner);
  1010.       the_result := L_fraction - R_fraction;  -- "-" cannot overflow here.
  1011.       reconstruct(the_result, scaler => exponent);
  1012.       return as_f96(the_result);
  1013.    end "-";
  1014.
  1015.    function "*" (L, R : CPU.f48)
  1016.    return CPU.f96 is
  1017.       V_was_set : constant Boolean := the_V_bit_is_set;
  1018.       LR        : KDF9.pair;
  1019.    begin
  1020.       the_V_bit_is_set := False;
  1021.       LR := fraction_word(L) * fraction_word(R);
  1022.       if the_V_bit_is_set then
  1023.          -- The product is not a valid fixed-point fraction, but is actually OK,
  1024.          --    so restore the orginal overflow state, and  ...
  1025.          the_V_bit_is_set := V_was_set;
  1026.          --  ... construct +1.0 in double-precision floating-point.
  1027.          return as_f96((shift_word_left(2#0_10_000_001_1#, 38), 0));
  1028.       end if;
  1029.       reconstruct(LR, scaler => scaler(L) + scaler(R));
  1030.       return as_f96(LR);
  1031.    end "*";
  1032.
  1033.    function "/" (L : CPU.f96;
  1034.                  R : CPU.f48)
  1035.    return CPU.f48 is  -- aka DIVDF
  1036.       -- If L>=R, L/R>= 1, which is not a valid fraction; so Ls and Rs are
  1037.       --    scaled so that the division cannot overflow.
  1038.       Ls     : constant KDF9.pair := scale_down(fraction_pair(L), 3);
  1039.       Rs     : constant KDF9.word := scale_down(fraction_word(R), 1);
  1040.       -- E is increased by 2 to compensate the quotient's scaling by 1/4.
  1041.       E      : constant KDF9.word := scaler(L) - scaler(R) + 2;
  1042.       F      : KDF9.word;
  1043.    begin
  1044.       if R = 0 then
  1045.          the_V_bit_is_set := True;
  1046.          return L.msw;  -- ?? This result is not well defined in the Manual.
  1047.       end if;
  1048.       do_DIVD(Ls, Rs, F);  -- Division cannot overflow here.
  1049.       return normalized(full_fraction => F, scaler => E);
  1050.    end "/";
  1051.
  1052.    procedure push (F : in CPU.f48) is
  1053.    begin
  1054.       push(KDF9.word(F));
  1055.    end push;
  1056.
  1057.    function pop
  1058.    return CPU.f48
  1059.    is (CPU.f48(KDF9.word'(pop)));
  1060.
  1061.    function read_top
  1062.    return CPU.f48
  1063.    is (CPU.f48(KDF9.word'(read_top)));
  1064.
  1065.    procedure write_top (F : in CPU.f48) is
  1066.    begin
  1067.       write_top(KDF9.word(F));
  1068.    end write_top;
  1069.
  1070.    procedure push (DF : in CPU.f96) is
  1071.       AB : constant KDF9.pair := as_pair(DF);
  1072.    begin
  1073.       push(AB);
  1074.    end push;
  1075.
  1076.    function pop
  1077.    return CPU.f96
  1078.    is (as_f96(pop));
  1079.
  1080.    function read_top
  1081.    return CPU.f96
  1082.    is (as_f96(read_top));
  1083.
  1084.    procedure write_top (DF : in CPU.f96) is
  1085.       AB : constant KDF9.pair := as_pair(DF);
  1086.    begin
  1087.       write_top(AB);
  1088.    end write_top;
  1089.
  1090. end KDF9.CPU;

Compiling: ../Source/kdf9-cpu.ads
Source file time stamp: 2021-02-20 23:52:36
Compiled at: 2021-02-21 15:54:06

     1. -- Support for KDF9 CPU/ALU operations that are not automatically inherited from
     2. --   Ada types; and for types used in the internal functioning of the microcode.
     3. --
     4. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with Ada.Unchecked_Conversion;
    19.
    20. package KDF9.CPU is
    21.
    22. --
    23. --
    24.    --
    25.    -- 48-bit integer and fractional ALU types and operations
    26.    --
    27. --
    28. --
    29.
    30.    type signed is range -2**47 .. +2**47 - 1 with Size => KDF9.word'Size;
    31.
    32.    function unsign is new Ada.Unchecked_Conversion (CPU.signed, KDF9.word);
    33.
    34.    function resign is new Ada.Unchecked_Conversion (KDF9.word, CPU.signed);
    35.
    36.    function "-" (I : CPU.signed)
    37.    return KDF9.word
    38.       with Inline;
    39.
    40.    function "abs" (I : CPU.signed)
    41.    return KDF9.word
    42.       with Inline;
    43.
    44.    function "+" (L, R : CPU.signed)
    45.    return KDF9.word
    46.       with Inline;
    47.
    48.    function "-" (L, R : CPU.signed)
    49.    return KDF9.word
    50.       with Inline;
    51.
    52.    function "*" (L, R : CPU.signed)
    53.    return KDF9.word;
    54.
    55.    -- Determine the Quotient and Remainder of L/R, where:
    56.    --    sign(Remainder) = sign(R) and |Remainder| < |R|, i.e. Remainder = L mod R;
    57.    --    Quotient = (L - Remainder) / R.
    58.
    59.    procedure do_DIVI (L : in KDF9.word;
    60.                       R : in KDF9.word;
    61.                       Quotient, Remainder : out KDF9.word);
    62.
    63.    -- Signed single-length integer substrate division is removed from consideration.
    64.
    65.    function "/" (L, R : CPU.signed)
    66.    return KDF9.word is abstract;
    67.
    68.    function "mod" (L, R : CPU.signed)
    69.    return KDF9.word is abstract;
    70.
    71.    -- Contract a double-word, setting the V bit if necessary.
    72.
    73.    function contracted (P : KDF9.pair)
    74.    return KDF9.word
    75.       with Inline;
    76.
    77.    -- Contract a double-word, represented by its components, setting the V bit if necessary.
    78.
    79.    function contracted (msw, lsw : KDF9.word)
    80.    return KDF9.word
    81.       with Inline;
    82.
    83. --
    84. --
    85.    -- Shifting operations with KDF9 semantics.
    86. --
    87. --
    88.
    89.    type signed_Q_part is range  -2**15 .. +2**15 - 1 with Size => KDF9.Q_part'Size;
    90.
    91.    function resign is new Ada.Unchecked_Conversion (KDF9.Q_part, CPU.signed_Q_part);
    92.
    93.    -- L>0 for left-shift, L<0 for right-shift.
    94.
    95.    function shift_logical (W : KDF9.word; L : CPU.signed_Q_part)
    96.    return KDF9.word
    97.       with Inline;
    98.
    99.    function shift_circular (W : KDF9.word; L : CPU.signed_Q_part)
   100.    return KDF9.word
   101.       with Inline;
   102.
   103.    -- shift_arithmetic rounds the result correctly.
   104.    function shift_arithmetic (I : KDF9.word; L : CPU.signed_Q_part)
   105.    return KDF9.word
   106.       with Inline;
   107.
   108.    -- cardinality yields the number of 1-bits in W.
   109.    function cardinality (W : KDF9.word)
   110.    return KDF9.word
   111.       with Inline;
   112.
   113. --
   114. --
   115.    -- A fraction is a word W interpreted as the value W / 2**47;
   116. --
   117. --
   118.
   119.    KDF9_small : constant := 2.0**(-47);
   120.
   121.    type fraction is delta KDF9_small range -1.0 .. +1.0 - KDF9_small with Size => KDF9.word'Size;
   122.
   123.    function as_fraction is new Ada.Unchecked_Conversion (KDF9.word, CPU.fraction);
   124.
   125.    function as_word     is new Ada.Unchecked_Conversion (CPU.fraction, KDF9.word);
   126.
   127.    -- These operations treat the KDF9.word operands as full-word fractions,
   128.
   129.    function "*" (L, R : KDF9.word)
   130.    return CPU.fraction;
   131.
   132.    function "/" (L, R : KDF9.word)
   133.    return CPU.fraction;
   134.
   135.
   136. --
   137. --
   138.    --
   139.    -- 48-bit integer and fractional ALU operations
   140.    --
   141. --
   142. --
   143.
   144.    function "+" (L, R : KDF9.pair)
   145.    return KDF9.pair
   146.       with Inline;
   147.
   148.    function "-" (J : KDF9.pair)
   149.    return KDF9.pair
   150.       with Inline;
   151.
   152.    function "-" (L, R : KDF9.pair)
   153.    return KDF9.pair
   154.       with Inline;
   155.
   156.    -- 48 * 48 -> 96-bit, for XD, etc.
   157.
   158.    function "*" (L, R : KDF9.word)
   159.    return KDF9.pair;
   160.
   161.    -- 96 / 48 -> 48-bit, for DIVD, DIVR and DIVDF.
   162.
   163.    procedure do_DIVD (L : in KDF9.pair;
   164.                       R : in KDF9.word;
   165.                       Q : out KDF9.word
   166.                      );
   167.
   168.    procedure do_DIVR (L : in KDF9.pair;
   169.                       R : in KDF9.word;
   170.                       Quotient,
   171.                       Remainder : out KDF9.word
   172.                      );
   173.
   174.    function shift_logical (P : KDF9.pair; L : CPU.signed_Q_part)
   175.    return KDF9.pair
   176.       with Inline;
   177.
   178.    function shift_arithmetic (P : KDF9.pair; L : CPU.signed_Q_part)
   179.    return KDF9.pair
   180.       with Inline;
   181.
   182.
   183. --
   184. --
   185.    --
   186.    -- 48-bit floating point ALU types and operations
   187.    --
   188. --
   189. --
   190.
   191.    -- This is a substrate for KDF9 floating point, not an Ada f.p. type.
   192.
   193.    type f48 is mod 2**48 with Size => KDF9.word'Size;
   194.
   195.    -- Remove useless substrate modular operations not, and, or, xor and mod.
   196.
   197.    overriding
   198.    function "not" (R : CPU.f48)
   199.    return CPU.f48 is abstract;
   200.
   201.    overriding
   202.    function "and" (L, R : CPU.f48)
   203.    return CPU.f48 is abstract;
   204.
   205.    overriding
   206.    function "or" (L, R : CPU.f48)
   207.    return CPU.f48 is abstract;
   208.
   209.    overriding
   210.    function "xor" (L, R : CPU.f48)
   211.    return CPU.f48 is abstract;
   212.
   213.    overriding
   214.    function "mod" (L, R : CPU.f48)
   215.    return CPU.f48 is abstract;
   216.
   217.    function as_word is new Ada.Unchecked_Conversion (CPU.f48, KDF9.word);
   218.
   219.    function as_f48  is new Ada.Unchecked_Conversion (KDF9.word, CPU.f48);
   220.
   221.    procedure push (F : in CPU.f48);
   222.
   223.    function pop
   224.    return CPU.f48
   225.       with Inline;
   226.
   227.    procedure write_top (F : in CPU.f48)
   228.       with Inline;
   229.
   230.    function read_top
   231.    return CPU.f48
   232.       with Inline;
   233.
   234.     -- Standardize a (possibly) non-normalized floating-point number.
   235.
   236.    function normalized  (R : CPU.f48)
   237.    return CPU.f48;
   238.
   239.    -- Convert a 47-bit fraction to a rounded, standardized 39-bit mantissa,
   240.    --    and adjust its exponent accordingly, setting overflow when necessary.
   241.
   242.    procedure normalize (fraction, exponent : in out KDF9.word)
   243.       with Inline;
   244.
   245.    -- Convert a 39-bit mantissa to a 47-bit fraction, preserving the sign.
   246.
   247.    function fraction_word (mantissa : CPU.f48)
   248.    return KDF9.word
   249.       with Inline;
   250.
   251.    -- The floating-point number with the exponent field set to 0.
   252.
   253.    function masked_mantissa (F : CPU.f48)
   254.    return CPU.f48
   255.       with Inline;
   256.
   257.    -- The algebraic scale-factor, not the hardware exponent, -128 <= scaler < +128.
   258.
   259.    function scaler (F : CPU.f48)
   260.    return KDF9.word
   261.       with Inline;
   262.
   263.     -- Synthesize a normalized floating-point number from its components.
   264.
   265.    function normalized (full_fraction, scaler : KDF9.word)
   266.    return CPU.f48
   267.       with Inline;
   268.
   269.    -- Round a 48-bit floating-point number to 24-bit format.
   270.
   271.    function narrowed (R : CPU.f48)
   272.    return CPU.f48;
   273.
   274.    overriding
   275.    function "-" (R : CPU.f48)
   276.    return CPU.f48;
   277.
   278.    overriding
   279.    function "abs" (R : CPU.f48)
   280.    return CPU.f48;
   281.
   282.    overriding
   283.    function "+" (L, R : CPU.f48)
   284.    return CPU.f48;
   285.
   286.    overriding
   287.    function "-" (L, R : CPU.f48)
   288.    return CPU.f48;
   289.
   290.    overriding
   291.    function "*" (L, R : CPU.f48)
   292.    return CPU.f48;
   293.
   294.    overriding
   295.    function "/" (L, R : CPU.f48)
   296.    return CPU.f48;
   297.
   298.    overriding
   299.    function "<" (L, R : CPU.f48)
   300.    return Boolean;
   301.
   302.    function host_float (X : CPU.f48)
   303.    return Long_Float;
   304.
   305.    exponent_mask : constant KDF9.word := KDF9.word'(2#11_111_111#) * 2**39;
   306.    mantissa_mask : constant KDF9.word := not exponent_mask;
   307.    frac_msb_mask : constant KDF9.word := 2**46;  -- M.S.B. of a 47-bit fraction
   308.    mant_msb_mask : constant KDF9.word := 2**38;  -- M.S.B. of a 39-bit mantissa
   309.    overflow_mask : constant KDF9.word := 2**39;  -- bit set on rounding overflow
   310.
   311.
   312. --
   313. --
   314.    --
   315.    -- 96-bit floating point ALU types and operations
   316.    --
   317. --
   318. --
   319.
   320.    type f96 is
   321.       record
   322.          msw, lsw : CPU.f48;
   323.       end record;
   324.
   325.    function as_pair is new Ada.Unchecked_Conversion (CPU.f96, KDF9.pair);
   326.
   327.    function as_f96  is new Ada.Unchecked_Conversion (KDF9.pair, CPU.f96);
   328.
   329.    procedure push (DF : in CPU.f96)
   330.       with Inline,
   331.            Pre => the_NEST_depth < 15
   332.                or else the_CPU_state = Director_state;
   333.
   334.    function pop
   335.    return CPU.f96
   336.       with Inline;
   337.
   338.    procedure write_top (DF : in CPU.f96)
   339.       with Inline;
   340.
   341.    function read_top
   342.    return CPU.f96
   343.       with Inline;
   344.
   345.    -- The algebraic scale-factor, not the hardware exponent, -128 <= scaler < +128.
   346.
   347.    function scaler (DF : CPU.f96)
   348.    return KDF9.word
   349.       with Inline;
   350.
   351.    -- Round a 96-bit double-precision floating-point number to 48 bit format.
   352.
   353.    function narrowed (DF : CPU.f96)
   354.    return CPU.f48
   355.       with Inline;
   356.
   357.    -- Derive a 96-bit fraction from the double-precision floating-point number,
   358.    --    with the mantissa bits in D9-D47 and D49-D87,
   359.    --       and with D1-D8 copies of the sign, D48 zero, and D87-D95 zero.
   360.
   361.    function fraction_pair (DF : CPU.f96)
   362.    return KDF9.pair
   363.       with Inline;
   364.
   365.    -- Convert 96-bit fraction, and an algebraic scale-factor exponent,
   366.    --    into a 96-bit floating point number, setting overflow when necessary.
   367.
   368.    procedure reconstruct (frac   : in out KDF9.pair;
   369.                           scaler : in KDF9.word);
   370.
   371.    function "-" (R : CPU.f96)
   372.    return CPU.f96;
   373.
   374.    function "+" (L, R : CPU.f96)
   375.    return CPU.f96;
   376.
   377.    function "-" (L, R : CPU.f96)
   378.    return CPU.f96;
   379.
   380.    function "*" (L, R : CPU.f48)
   381.    return CPU.f96;
   382.
   383.    function "/" (L : CPU.f96;
   384.                  R : CPU.f48)
   385.    return CPU.f48;
   386.
   387. ------------------------------------------------------------------------------------------------
   388.
   389. --
   390. --
   391.    --
   392.    -- These are the emulation host's register types and their operations.
   393.    --
   394. --
   395. --
   396.
   397.    type u_64 is mod 2**64 with Size => 64;
   398.
   399.    pragma Provide_Shift_Operators (u_64);
   400.
   401.    function as_word (u : CPU.u_64)
   402.    return KDF9.word
   403.       with Inline;
   404.
   405.    type s_64 is range -2**63 .. +2**63-1 with Size => 64;
   406.
   407.    -- The signed as_word sets the V bit if necessary.
   408.
   409.    function as_word (s : CPU.s_64)
   410.    return KDF9.word
   411.       with Inline;
   412.
   413.    function unsign is new Ada.Unchecked_Conversion(CPU.s_64, CPU.u_64);
   414.
   415.    function resign is new Ada.Unchecked_Conversion(CPU.u_64, CPU.s_64);
   416.
   417. --
   418. --
   419.    --
   420.    -- These are the 48-bit primitive, fixed-direction, shift operations.
   421.    --
   422. --
   423. --
   424.
   425.    function shift_time (amount : Natural)
   426.    return KDF9.us
   427.       with Inline;
   428.
   429.    subtype word_shift_length is Natural range 0..48;
   430.
   431.    function shift_word_left (W : KDF9.word; amount : word_shift_length)
   432.    return KDF9.word
   433.       with Inline;
   434.
   435.    function shift_word_right (W : KDF9.word; amount : word_shift_length)
   436.    return KDF9.word
   437.       with Inline;
   438.
   439.    function rotate_word_left (W : KDF9.word; amount : word_shift_length)
   440.    return KDF9.word
   441.       with Inline;
   442.
   443.    function rotate_word_right (W : KDF9.word; amount : word_shift_length)
   444.    return KDF9.word
   445.       with Inline;
   446.
   447.    -- scale_up may set the V bit.
   448.
   449.    function scale_up (W : KDF9.word; amount : Natural)
   450.    return KDF9.word
   451.       with Inline;
   452.
   453.    -- scale_down_and_round rounds correctly.
   454.
   455.    function scale_down_and_round (W : KDF9.word; amount : Natural)
   456.    return KDF9.word
   457.       with Inline;
   458.
   459.    -- scale_down never rounds.
   460.
   461.    function scale_down (W : KDF9.word; amount : Natural)
   462.    return KDF9.word
   463.       with Inline;
   464.
   465. end KDF9.CPU;

 1090 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-phu_store.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:07

     1. -- The K5 operation data formats.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Unchecked_Conversion;
    18. --
    19. with KDF9.CPU;
    20.
    21. package body KDF9.PHU_store is
    22.
    23.    function short_PHU (p : KDF9.priority)
    24.    return KDF9.word is
    25.
    26.       use type KDF9.store.group_address;
    27.
    28.       type PHU_as_6_bits is mod 2**6
    29.          with Size => 6;
    30.
    31.       function as_6_bits is new Ada.Unchecked_Conversion(Source => PHU_store.PHU_subset,
    32.                                                          Target => short_PHU.PHU_as_6_bits);
    33.
    34.       the_reason    : PHU_store.blockage_kind;
    35.       the_parameter : KDF9.buffer_number;
    36.
    37.    begin
    38.       if not PHU(p).is_held_up then
    39.          return 0;  -- All fields are non-significant.
    40.       end if;
    41.
    42.       -- PHU(p).is_held_up, so other fields are valid.
    43.       the_reason := PHU(p).blockage.reason;
    44.       if the_reason = buffer_busy then
    45.          the_parameter := PHU(p).blockage.buffer_nr;
    46.       else
    47.          -- This is next to useless, but is what the K5 order actually did.
    48.          the_parameter := KDF9.buffer_number(PHU(p).blockage.group_nr mod 2**4);
    49.       end if;
    50.
    51.       return KDF9.word(as_6_bits((the_parameter, the_reason, True)));
    52.    end short_PHU;
    53.
    54.    function K5_operand
    55.    return KDF9.word
    56.    is (
    57.        KDF9.CPU.shift_word_left(short_PHU(0), 48-06) or
    58.        KDF9.CPU.shift_word_left(short_PHU(1), 48-12) or
    59.        KDF9.CPU.shift_word_left(short_PHU(2), 48-18) or
    60.        KDF9.CPU.shift_word_left(short_PHU(3), 48-24)
    61.       );
    62.
    63. end KDF9.PHU_store;

Compiling: ../Source/kdf9-phu_store.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:07

     1. -- The K5 operation data formats.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with System;
    18. --
    19. with KDF9.store;
    20.
    21. package KDF9.PHU_store is
    22.
    23.    -- PHU, the Program Hold-Up register is internal to I/O Control.
    24.    -- It has one element for each of the 4 program priority levels, 0..3.
    25.    -- A subset of its content is exposed to Director by means of the K5 order.
    26.
    27.    type blockage_kind is (buffer_busy, locked_core) with Size => 1;
    28.
    29.    type PHU_reason (reason : PHU_store.blockage_kind := buffer_busy) is
    30.       record
    31.          case reason is
    32.             when buffer_busy =>
    33.                buffer_nr : KDF9.buffer_number;
    34.                by_INTQq  : Boolean;
    35.             when locked_core =>
    36.                group_nr  : KDF9.store.group_address;
    37.          end case;
    38.       end record;
    39.
    40.    type PHU_register (is_held_up : Boolean := False) is
    41.       record
    42.          case is_held_up is
    43.             when False =>
    44.                null;
    45.             when True =>
    46.                blockage : PHU_reason;
    47.          end case;
    48.       end record;
    49.
    50.    idle_PHU : constant PHU_register := (is_held_up => False);
    51.
    52.    PHU : array (KDF9.priority) of PHU_store.PHU_register := (others => idle_PHU);
    53.
    54.    type PHU_subset is
    55.       record
    56.          parameter  : KDF9.buffer_number;
    57.          reason     : PHU_store.blockage_kind;
    58.          is_held_up : Boolean;
    59.       end record
    60.    with Size => 6, Bit_Order => System.Low_Order_First;
    61.
    62.    for  PHU_subset use
    63.       record
    64.          parameter  at 0 range 0 .. 3;
    65.          reason     at 0 range 4 .. 4;
    66.          is_held_up at 0 range 5 .. 5;
    67.       end record;
    68.
    69.    -- A K5_operand is a KDF9 word, D00-D47, with the content:
    70.    --    PHU_subset(0) in D00 .. D05
    71.    --    PHU_subset(1) in D06 .. D11
    72.    --    PHU_subset(2) in D12 .. D17
    73.    --    PHU_subset(3) in D18 .. D23
    74.    --    zeros         in D24 .. D47
    75.
    76.    function K5_operand
    77.    return KDF9.word;
    78.
    79. end KDF9.PHU_store;

 63 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/tracing.adb
Source file time stamp: 2021-02-20 23:56:00
Compiled at: 2021-02-21 15:54:07

     1. -- Provide diagnostic trace, breakpoint, and watchpoint support.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with exceptions;
    18. with formatting;
    19. with HCI;
    20. with KDF9.decoding;
    21. with KDF9.store;
    22. with state_display;
    23.
    24. use exceptions;
    25. use formatting;
    26. use HCI;
    27. use KDF9;
    28. use KDF9.decoding;
    29. use KDF9.store;
    30. use state_display;
    31.
    32. package body tracing is
    33.
    34.    procedure clear_the_histogram is
    35.    begin
    36.       the_histogram := (others => 0);
    37.    end clear_the_histogram;
    38.
    39.    procedure clear_the_profile is
    40.    begin
    41.       the_profile := (others => 0);
    42.    end clear_the_profile;
    43.
    44.    procedure set_breakpoints (first, last : in KDF9.order_word_number) is
    45.    begin
    46.       for p in first .. last loop
    47.          breakpoints(p) := True;
    48.       end loop;
    49.    end set_breakpoints;
    50.
    51.    procedure handle_breakpoint is
    52.    begin
    53.       short_witness;
    54.       interact;
    55.       quit_if_requested;
    56.       change_diagnostic_mode_if_requested;
    57.    end handle_breakpoint;
    58.
    59.    procedure clear_all_watchpoints is
    60.    begin
    61.       fetchpoints := (others => False);
    62.       storepoints := (others => False);
    63.    end clear_all_watchpoints;
    64.
    65.    procedure set_fetch_points (first, last : in KDF9.address) is
    66.    begin
    67.       for p in first .. last loop
    68.          fetchpoints(p) := True;
    69.       end loop;
    70.    end set_fetch_points;
    71.
    72.    procedure set_store_points (first, last : in KDF9.address) is
    73.    begin
    74.       for p in first .. last loop
    75.          storepoints(p) := True;
    76.       end loop;
    77.    end set_store_points;
    78.
    79.    procedure clear_retro_FIFO is
    80.    begin
    81.       retro_FIFO_count := 0; retro_FIFO_index := 0;
    82.    end clear_retro_FIFO;
    83.
    84.    procedure take_note_of (the_IAR   : in KDF9.syllable_address;
    85.                            the_value : in KDF9.word) is
    86.    begin
    87.       if the_retrospective_trace_is_enabled           and then
    88.             ICR in low_count .. high_count            and then
    89.                NIA_word_number in low_bound .. high_bound then
    90.          declare
    91.             the_note : constant retro_FIFO_entry
    92.                      := (
    93.                          location   => the_IAR,
    94.                          order      => INS.order,
    95.                          parameter  => the_value,
    96.                          ICR_value  => ICR,
    97.                          CPU_time   => the_CPU_time,
    98.                          nested     => the_NEST_depth,
    99.                          called     => the_SJNS_depth,
   100.                          V          => the_V_bit_is_set,
   101.                          T          => the_T_bit_is_set,
   102.                          D          => the_CPU_state = Director_state,
   103.                          level      => CPL
   104.                         );
   105.          begin
   106.             if retro_FIFO_count = 0 then
   107.                retro_FIFO(0) := the_note;
   108.                retro_FIFO_count := 1;
   109.             else
   110.                retro_FIFO_index := retro_FIFO_index + 1;
   111.                retro_FIFO(retro_FIFO_index) := the_note;
   112.                if retro_FIFO_count < FIFO_size then
   113.                   retro_FIFO_count := retro_FIFO_count + 1;
   114.                end if;
   115.             end if;
   116.          end;
   117.       end if;
   118.    end take_note_of;
   119.
   120.    procedure take_note_of (the_value : in KDF9.word) is
   121.    begin
   122.       take_note_of(CIA, the_value);
   123.    end take_note_of;
   124.
   125.    procedure clear_IOC_FIFO is
   126.    begin
   127.       IOC_FIFO_count := 0; IOC_FIFO_index := 0;
   128.    end clear_IOC_FIFO;
   129.
   130.    procedure register_IO_event (the_note : in IOC_FIFO_entry) is
   131.    begin
   132.       if the_peripheral_trace_is_enabled              and then
   133.             ICR in low_count .. high_count            and then
   134.                NIA_word_number in low_bound .. high_bound then
   135.          if IOC_FIFO_count = 0 then
   136.             IOC_FIFO(0) := the_note;
   137.             IOC_FIFO_count := 1;
   138.          else
   139.             IOC_FIFO_index := IOC_FIFO_index + 1;
   140.             IOC_FIFO(IOC_FIFO_index) := the_note;
   141.             if IOC_FIFO_count < FIFO_size then
   142.                IOC_FIFO_count := IOC_FIFO_count + 1;
   143.             end if;
   144.          end if;
   145.       end if;
   146.    end register_IO_event;
   147.
   148.    procedure take_note_of_IO_start (
   149.                                     device_name     : in IOC.device_name;
   150.                                     completion_time : in KDF9.us;
   151.                                     control_word    : in KDF9.Q_register;
   152.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   153.                                    )
   154.    is
   155.       the_note : constant  IOC_FIFO_entry
   156.                :=
   157.                 (
   158.                  kind            => start_transfer,
   159.                  ICR_value       => ICR,
   160.                  order_address   => CIA,
   161.                  decoded_order   => INS,
   162.                  initiation_time => the_clock_time,
   163.                  device_name     => take_note_of_IO_start.device_name,
   164.                  completion_time => take_note_of_IO_start.completion_time,
   165.                  is_for_Director => (the_CPU_state = Director_state),
   166.                  priority_level  => CPL,
   167.                  context         => the_context,
   168.                  control_word    => take_note_of_IO_start.control_word,
   169.                  operation       => take_note_of_IO_start.operation
   170.                 );
   171.    begin
   172.       register_IO_event(the_note);
   173.    end take_note_of_IO_start;
   174.
   175.    procedure take_note_of_IO_finis (
   176.                                     ICR_value       : in KDF9.order_counter;
   177.                                     order_address   : in KDF9.syllable_address;
   178.                                     decoded_order   : in KDF9.decoded_order;
   179.                                     initiation_time : in KDF9.us;
   180.                                     device_name     : in IOC.device_name;
   181.                                     is_for_Director : Boolean;
   182.                                     priority_level  : in KDF9.priority;
   183.                                     completion_time : in KDF9.us;
   184.                                     control_word    : in KDF9.Q_register;
   185.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   186.                                    )
   187.    is
   188.       the_note : constant  IOC_FIFO_entry
   189.                :=
   190.                 (
   191.                  kind            => finis_transfer,
   192.                  ICR_value       => take_note_of_IO_finis.ICR_value,
   193.                  order_address   => take_note_of_IO_finis.order_address,
   194.                  decoded_order   => take_note_of_IO_finis.decoded_order,
   195.                  initiation_time => take_note_of_IO_finis.initiation_time,
   196.                  device_name     => take_note_of_IO_finis.device_name,
   197.                  is_for_Director => take_note_of_IO_finis.is_for_Director,
   198.                  priority_level  => take_note_of_IO_finis.priority_level,
   199.                  context         => the_context,
   200.                  completion_time => take_note_of_IO_finis.completion_time,
   201.                  control_word    => take_note_of_IO_finis.control_word,
   202.                  operation       => take_note_of_IO_finis.operation
   203.                 );
   204.
   205.    begin
   206.       register_IO_event(the_note);
   207.    end take_note_of_IO_finis;
   208.
   209.    procedure take_note_of_store_lockout (device_name : in IOC.device_name) is
   210.       the_note : constant  IOC_FIFO_entry
   211.                :=
   212.                 (
   213.                  kind            => store_lockout,
   214.                  ICR_value       => ICR,
   215.                  order_address   => CIA,
   216.                  decoded_order   => INS,
   217.                  initiation_time => the_clock_time,
   218.                  device_name     => take_note_of_store_lockout.device_name,
   219.                  is_for_Director => False,
   220.                  priority_level  => CPL,
   221.                  context         => the_context,
   222.                  data_address    => the_locked_out_address,
   223.                  operation       => IOC.some_other_operation
   224.                 );
   225.    begin
   226.       register_IO_event(the_note);
   227.    end take_note_of_store_lockout;
   228.
   229.    procedure take_note_of_buffer_lockout (device_name : in IOC.device_name;
   230.                                           operation   : in IOC.transfer_kind := IOC.some_other_operation) is
   231.       the_note : constant  IOC_FIFO_entry
   232.                :=
   233.                 (
   234.                  kind            => buffer_lockout,
   235.                  ICR_value       => ICR,
   236.                  order_address   => CIA,
   237.                  decoded_order   => INS,
   238.                  initiation_time => the_clock_time,
   239.                  device_name     => take_note_of_buffer_lockout.device_name,
   240.                  is_for_Director => False,
   241.                  priority_level  => CPL,
   242.                  context         => the_context,
   243.                  operation       => take_note_of_buffer_lockout.operation
   244.                 );
   245.    begin
   246.       register_IO_event(the_note);
   247.    end take_note_of_buffer_lockout;
   248.
   249.    procedure take_note_of_test (
   250.                                 device_name : in IOC.device_name;
   251.                                 Q_register  : in KDF9.Q_register;
   252.                                 status      : in Boolean
   253.                                )
   254.    is
   255.       the_note : constant  IOC_FIFO_entry
   256.                :=
   257.                 (
   258.                  kind            => buffer_status,
   259.                  ICR_value       => ICR+1,  -- ICR is not incremented until the end of an order.
   260.                  order_address   => CIA,
   261.                  decoded_order   => INS,
   262.                  initiation_time => the_clock_time,
   263.                  device_name     => take_note_of_test.device_name,
   264.                  is_for_Director => (the_CPU_state = Director_state),
   265.                  priority_level  => CPL,
   266.                  context         => the_context,
   267.                  Q_register      => take_note_of_test.Q_register,
   268.                  status          => take_note_of_test.status,
   269.                  operation       => IOC.some_other_operation
   270.                 );
   271.    begin
   272.       register_IO_event(the_note);
   273.    end take_note_of_test;
   274.
   275.    procedure clear_interrupt_FIFO is
   276.    begin
   277.       interrupt_FIFO_count := 0; interrupt_FIFO_index := 0;
   278.    end clear_interrupt_FIFO;
   279.
   280.    procedure take_note_of_interrupt (interrupt_code : in KDF9.interrupt_number; message : in String)
   281.    is
   282.       length  : constant Natural  := Natural'Min(message'Length, max_interrupt_message_length);
   283.       content : constant String   := message(message'First .. message'First+length-1);
   284.       padding : constant String   := (1 .. max_interrupt_message_length-length => ' ');
   285.    begin
   286.       declare
   287.          the_note : constant interrupt_FIFO_entry
   288.                   :=
   289.                    (
   290.                     interrupt_code => take_note_of_interrupt.interrupt_code,
   291.                     ICR_value      => ICR,
   292.                     order_address  => CIA,
   293.                     busy_time      => the_clock_time,
   294.                     priority_level => CPL,
   295.                     context        => the_context,
   296.                     message        => content & padding
   297.                    );
   298.       begin
   299.          if the_interrupt_trace_is_enabled               and then
   300.                ICR in low_count .. high_count            and then
   301.                   NIA_word_number in low_bound .. high_bound then
   302.             if interrupt_FIFO_count = 0 then
   303.                interrupt_FIFO(0) := the_note;
   304.                interrupt_FIFO_count := 1;
   305.             else
   306.                interrupt_FIFO_index := interrupt_FIFO_index + 1;
   307.                interrupt_FIFO(interrupt_FIFO_index) := the_note;
   308.                if interrupt_FIFO_count < FIFO_size then
   309.                   interrupt_FIFO_count := interrupt_FIFO_count + 1;
   310.                end if;
   311.             end if;
   312.          end if;
   313.       end;
   314.    end take_note_of_interrupt;
   315.
   316.    procedure add_INS_to_the_histogram is
   317.       syllable_0 : KDF9.syllable := INS.order.syllable_0;
   318.    begin
   319.       if INS.kind = normal_jump_order then
   320.          syllable_0 := (syllable_0 and 2#1111_0000#) or INS.Qq;
   321.       elsif INS.kind = data_access_order then
   322.          syllable_0 := (syllable_0 and 2#11_000_111#);
   323.       end if;
   324.       the_histogram(syllable_0) := the_histogram(syllable_0) + 1;
   325.    end add_INS_to_the_histogram;
   326.
   327.    procedure add_CIA_to_the_profile is
   328.    begin
   329.       the_profile(CIA.order_word_number) := the_profile(CIA.order_word_number) + 1;
   330.    end add_CIA_to_the_profile;
   331.
   332.    procedure preview_a_one_syllable_order is null;
   333.
   334.    procedure preview_a_two_syllable_order is
   335.    begin
   336.       case INS.compressed_opcode is
   337.          when TO_MkMq
   338.             | TO_MkMqQ
   339.             | TO_MkMqH
   340.             | TO_MkMqQH
   341.             | TO_MkMqN
   342.             | TO_MkMqQN
   343.             | TO_MkMqHN
   344.             | TO_MkMqQHN =>
   345.             the_trace_operand := read_top;
   346.          when others =>
   347.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   348.       end case;
   349.    end preview_a_two_syllable_order;
   350.
   351.    procedure preview_a_jump_order is
   352.    begin
   353.       case INS.compressed_opcode is
   354.          when JrEQ
   355.             | JrNE
   356.             | JrGTZ
   357.             | JrLTZ
   358.             | JrEQZ
   359.             | JrLEZ
   360.             | JrGEZ
   361.             | JrNEZ
   362.             | OS_OUT =>
   363.             if the_NEST_depth > 0 then
   364.                the_trace_operand := read_top;
   365.             end if;
   366.          when JrEN
   367.             | JrNEN =>
   368.             the_trace_operand := KDF9.word(the_NEST_depth);
   369.          when JrEJ
   370.             | JrNEJ =>
   371.             the_trace_operand := KDF9.word(the_SJNS_depth);
   372.          when EXIT_n
   373.             | EXITD =>
   374.             if the_SJNS_depth > 0 then
   375.                the_trace_operand := as_word(SJNS_top);
   376.             else
   377.                the_trace_operand := -1;
   378.             end if;
   379.          when JrCqZ
   380.             | JrCqNZ =>
   381.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   382.          when JrV
   383.             | JrNV =>
   384.             the_trace_operand := (if the_V_bit_is_set then 1 else 0);
   385.          when JrTR
   386.             | JrNTR =>
   387.             the_trace_operand := (if the_T_bit_is_set then 1 else 0);
   388.          when others =>
   389.             null;
   390.       end case;
   391.    end preview_a_jump_order;
   392.
   393.    procedure preview_a_data_access_order is
   394.    begin
   395.       case INS.compressed_opcode is
   396.          when TO_EaMq
   397.             | TO_EaMqQ =>
   398.             the_trace_operand := read_top;
   399.          when others =>
   400.             null;
   401.       end case;
   402.    end preview_a_data_access_order;
   403.
   404.    procedure look_back_at_a_one_syllable_order is
   405.       AB : KDF9.pair;
   406.    begin
   407.       case INS.compressed_opcode is
   408.          when XDF
   409.             | XPLUSF
   410.             | MINUSDF
   411.             | PLUSDF
   412.             | FLOATD
   413.             | NEGDF
   414.             | MAXF
   415.             | PERM
   416.             | CAB
   417.             | MAX
   418.             | XD
   419.             | NEGD
   420.             | DUPD
   421.             | DIVI
   422.             | STR
   423.             | REVD
   424.             | MINUSD
   425.             | PLUSD
   426.             | DIVR =>
   427.             AB := read_top;
   428.             the_trace_operand := AB.msw;
   429.          when others =>
   430.             if the_NEST_depth > 0 then
   431.                the_trace_operand := read_top;
   432.             end if;
   433.       end case;
   434.    end look_back_at_a_one_syllable_order;
   435.
   436.    procedure look_back_at_an_IO_order is null;
   437.
   438.    procedure look_back_at_a_two_syllable_order is
   439.       AB : KDF9.pair;
   440.    begin
   441.       case INS.compressed_opcode is
   442.          when MkMq
   443.             | MkMqQ
   444.             | MkMqH
   445.             | MkMqQH
   446.             | MkMqQN
   447.             | MkMqHN
   448.             | MkMqQHN
   449.             | QCIMq
   450.             | SHA
   451.             | SHL
   452.             | SHC
   453.             | TO_Kq
   454.             | Kk
   455.             | LINK =>
   456.             the_trace_operand := read_top;
   457.          when TO_MkMq
   458.             | TO_MkMqQ
   459.             | TO_MkMqH
   460.             | TO_MkMqQH
   461.             | TO_MkMqN
   462.             | TO_MkMqQN
   463.             | TO_MkMqHN
   464.             | TO_MkMqQHN =>
   465.             null;
   466.          when M_PLUS_Iq
   467.             | M_MINUS_Iq
   468.             | NCq
   469.             | DCq
   470.             | POS1_TO_Iq
   471.             | NEG1_TO_Iq
   472.             | POS2_TO_Iq
   473.             | NEG2_TO_Iq
   474.             | TO_RCIMq
   475.             | ADD_TO_QCIMq
   476.             | JCqNZS =>
   477.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   478.          when CqTOQk
   479.             | IqTOQk
   480.             | MqTOQk
   481.             | QqTOQk
   482.             | CIqTOQk
   483.             | IMqTOQk
   484.             | CMqTOQk =>
   485.             the_trace_operand := as_word(the_Q_store(INS.Qk));
   486.          when SHLD
   487.             | SHAD
   488.             | MACC =>
   489.             AB := read_top;
   490.             the_trace_operand := AB.msw;
   491.          when TO_LINK =>
   492.             the_trace_operand := as_word(SJNS_top);
   493.          when others =>
   494.             look_back_at_an_IO_order;
   495.       end case;
   496.    end look_back_at_a_two_syllable_order;
   497.
   498.    procedure look_back_at_a_jump_order is
   499.       BA_image  : constant String := "BA #" & oct_of(BA);
   500.       NOL_image : constant String := "NOL"  & NOL'Image;
   501.    begin
   502.       case INS.compressed_opcode is
   503.          when Jr =>
   504.             the_trace_operand := as_word(SJNS_link(NIA));
   505.          when JSr =>
   506.             the_trace_operand := as_word(SJNS_top);
   507.          when EXITD =>
   508.             take_note_of_interrupt(EXITD_flag, BA_image & " " & NOL_image & " @ " & oct_of(NIA));
   509.          when others =>
   510.             null;
   511.       end case;
   512.    end look_back_at_a_jump_order;
   513.
   514.    procedure look_back_at_a_data_access_order is
   515.    begin
   516.       case INS.compressed_opcode is
   517.          when EaMq
   518.             | EaMqQ
   519.             | SET =>
   520.             the_trace_operand := read_top;
   521.          when others =>
   522.             null;
   523.       end case;
   524.    end look_back_at_a_data_access_order;
   525.
   526.    procedure act_on_any_fetchpoint is
   527.       use type watch_flags.set;
   528.    begin
   529.       if fetchpoints/the_trace_address then
   530.          log_new_line;
   531.          log("Fetch watchhpoint: N1 := [#" & oct_of(the_trace_address) & "]");
   532.          short_witness;
   533.          interact;
   534.          quit_if_requested;
   535.          change_diagnostic_mode_if_requested;
   536.       end if;
   537.    end act_on_any_fetchpoint;
   538.
   539.    procedure act_on_any_storepoint is
   540.       use type watch_flags.set;
   541.    begin
   542.       if storepoints/the_trace_address then
   543.          log_new_line;
   544.          log(
   545.              "Store watchpoint: #"
   546.            & oct_of(the_trace_address)
   547.            & " := [N1] = #"
   548.            & oct_of(the_trace_operand)
   549.             );
   550.          short_witness;
   551.          interact;
   552.          quit_if_requested;
   553.          change_diagnostic_mode_if_requested;
   554.       end if;
   555.    end act_on_any_storepoint;
   556.
   557.    procedure act_on_any_two_syllable_order_watchpoints is
   558.    begin
   559.       case INS.compressed_opcode is
   560.          when MkMq
   561.             | MkMqQ
   562.             | MkMqH
   563.             | MkMqQH
   564.             | MkMqQN
   565.             | MkMqHN
   566.             | MkMqQHN =>
   567.             act_on_any_fetchpoint;
   568.          when TO_MkMq
   569.             | TO_MkMqQ
   570.             | TO_MkMqH
   571.             | TO_MkMqQH
   572.             | TO_MkMqN
   573.             | TO_MkMqQN
   574.             | TO_MkMqHN
   575.             | TO_MkMqQHN =>
   576.             act_on_any_storepoint;
   577.          when others =>
   578.             null;
   579.       end case;
   580.    end act_on_any_two_syllable_order_watchpoints;
   581.
   582.    procedure act_on_any_data_access_order_watchpoints is
   583.    begin
   584.       case INS.compressed_opcode is
   585.          when EaMq
   586.             | EaMqQ =>
   587.             act_on_any_fetchpoint;
   588.          when TO_EaMq
   589.             | TO_EaMqQ =>
   590.             act_on_any_storepoint;
   591.          when others =>
   592.             null;
   593.       end case;
   594.    end act_on_any_data_access_order_watchpoints;
   595.
   596. end tracing;

Compiling: ../Source/tracing.ads
Source file time stamp: 2021-02-20 23:56:00
Compiled at: 2021-02-21 15:54:07

     1. -- Provide diagnostic trace, breakpoint, and watchpoint support.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with generic_sets;
    18. with IOC;
    19. with KDF9;
    20. with settings;
    21.
    22. use  settings;
    23.
    24. package tracing is
    25.
    26.    -- Support for significant-operand evaluation and tracing.
    27.
    28.    the_trace_operand : KDF9.word;
    29.    the_trace_address : KDF9.address;
    30.
    31.    procedure preview_a_one_syllable_order;
    32.
    33.    procedure preview_a_two_syllable_order;
    34.
    35.    procedure preview_a_jump_order;
    36.
    37.    procedure preview_a_data_access_order;
    38.
    39.    procedure look_back_at_a_one_syllable_order;
    40.
    41.    procedure look_back_at_a_two_syllable_order;
    42.
    43.    procedure look_back_at_a_jump_order
    44.       with Inline => False;
    45.
    46.    procedure look_back_at_a_data_access_order;
    47.
    48.    -- Support for breakpoints.
    49.
    50.    package order_flags is new generic_sets(member => KDF9.order_word_number);
    51.
    52.    breakpoints : order_flags.set := order_flags.empty_set;
    53.
    54.    procedure set_breakpoints (first, last : in KDF9.order_word_number);
    55.
    56.    procedure handle_breakpoint;
    57.
    58.    -- Support for watchpoints.
    59.
    60.    package watch_flags is new generic_sets(member => KDF9.address);
    61.
    62.    fetchpoints : watch_flags.set := watch_flags.empty_set;
    63.    storepoints : watch_flags.set := watch_flags.empty_set;
    64.
    65.    procedure clear_all_watchpoints;
    66.
    67.    procedure set_fetch_points (first, last : in KDF9.address);
    68.
    69.    procedure set_store_points (first, last : in KDF9.address);
    70.
    71.    procedure act_on_any_two_syllable_order_watchpoints
    72.       with Inline => False;
    73.
    74.    procedure act_on_any_data_access_order_watchpoints
    75.       with Inline => False;
    76.
    77.
    78.    --
    79.    -- Retrospective tracing.
    80.    --
    81.
    82.    FIFO_size : constant := 256;
    83.
    84.    type FIFO_index is mod FIFO_size;
    85.
    86.    -- Support for all-instruction retrospective tracing.
    87.
    88.    type retro_FIFO_entry is
    89.       record
    90.          location  : KDF9.syllable_address;
    91.          order     : KDF9.syllable_group;
    92.          parameter : KDF9.word;
    93.          ICR_value : KDF9.order_counter;
    94.          CPU_time  : KDF9.us;
    95.          nested    : KDF9.NEST_depth;
    96.          called    : KDF9.SJNS_depth;
    97.          V, T, D   : Boolean;
    98.          level     : KDF9.priority;
    99.       end record;
   100.
   101.    retro_FIFO  : array (tracing.FIFO_index) of tracing.retro_FIFO_entry;
   102.
   103.    retro_FIFO_index : tracing.FIFO_index := 0;
   104.
   105.    retro_FIFO_count : Natural range 0 .. FIFO_size := 0;
   106.
   107.    procedure clear_retro_FIFO;
   108.
   109.    procedure take_note_of (the_value : in KDF9.word);
   110.
   111.    -- Support for retrospective peripheral I/O tracing.
   112.
   113.    type IOC_event_kind is (start_transfer,
   114.                            finis_transfer,
   115.                            buffer_lockout,
   116.                            store_lockout,
   117.                            buffer_status);
   118.
   119.
   120.    type IOC_FIFO_entry (kind : IOC_event_kind := start_transfer) is
   121.       record
   122.          ICR_value       : KDF9.order_counter;
   123.          order_address   : KDF9.syllable_address;
   124.          decoded_order   : KDF9.decoded_order;
   125.          initiation_time : KDF9.us;
   126.          device_name     : IOC.device_name;
   127.          is_for_Director : Boolean;
   128.          priority_level  : KDF9.priority;
   129.          context         : KDF9.context;
   130.          operation       : IOC.transfer_kind := IOC.some_other_operation;
   131.          case kind is
   132.             when start_transfer | finis_transfer =>
   133.                completion_time : KDF9.us;
   134.                control_word    : KDF9.Q_register;
   135.             when store_lockout =>
   136.                data_address : KDF9.Q_part;
   137.             when buffer_lockout =>
   138.                null;
   139.             when buffer_status =>
   140.                Q_register : KDF9.Q_register;
   141.                status     : Boolean;
   142.          end case;
   143.       end record;
   144.
   145.    IOC_FIFO  : array (tracing.FIFO_index) of tracing.IOC_FIFO_entry;
   146.
   147.    IOC_FIFO_index : tracing.FIFO_index := 0;
   148.
   149.    IOC_FIFO_count : Natural range 0 .. FIFO_size := 0;
   150.
   151.    procedure clear_IOC_FIFO;
   152.
   153.    procedure take_note_of_IO_start (
   154.                                     device_name     : in IOC.device_name;
   155.                                     completion_time : in KDF9.us;
   156.                                     control_word    : in KDF9.Q_register;
   157.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   158.                                    );
   159.
   160.    procedure take_note_of_IO_finis (
   161.                                     ICR_value       : in KDF9.order_counter;
   162.                                     order_address   : in KDF9.syllable_address;
   163.                                     decoded_order   : in KDF9.decoded_order;
   164.                                     initiation_time : in KDF9.us;
   165.                                     device_name     : in IOC.device_name;
   166.                                     is_for_Director : Boolean;
   167.                                     priority_level  : in KDF9.priority;
   168.                                     completion_time : in KDF9.us;
   169.                                     control_word    : in KDF9.Q_register;
   170.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   171.                                    );
   172.
   173.    procedure take_note_of_store_lockout  (device_name : in IOC.device_name);
   174.
   175.    procedure take_note_of_buffer_lockout (device_name : in IOC.device_name;
   176.                                           operation   : in IOC.transfer_kind := IOC.some_other_operation);
   177.
   178.    procedure take_note_of_test (
   179.                                 device_name : in IOC.device_name;
   180.                                 Q_register  : in KDF9.Q_register;
   181.                                 status      : in Boolean
   182.                                 );
   183.
   184.
   185.    -- Support for retrospective interrupt-request tracing.
   186.
   187.    max_interrupt_message_length : constant := 100;
   188.    type interrupt_FIFO_entry is
   189.       record
   190.          interrupt_code : KDF9.interrupt_number;
   191.          ICR_value      : KDF9.order_counter;
   192.          order_address  : KDF9.syllable_address;
   193.          busy_time      : KDF9.us;
   194.          priority_level : KDF9.priority;
   195.          context        : KDF9.context;
   196.          message        : String (1..max_interrupt_message_length);
   197.       end record;
   198.
   199.    interrupt_FIFO  : array (tracing.FIFO_index) of tracing.interrupt_FIFO_entry;
   200.
   201.    interrupt_FIFO_index : tracing.FIFO_index := 0;
   202.
   203.    interrupt_FIFO_count : Natural range 0 .. FIFO_size := 0;
   204.
   205.    procedure clear_interrupt_FIFO;
   206.
   207.    procedure take_note_of_interrupt (interrupt_code : in KDF9.interrupt_number; message : in String)
   208.       with Inline => False;
   209.
   210.
   211.    -- Support for the instruction-type and instruction-word frequency histograms.
   212.
   213.    the_histogram : array (KDF9.syllable) of KDF9.order_counter;
   214.
   215.    procedure clear_the_histogram;
   216.
   217.    procedure add_INS_to_the_histogram
   218.       with Inline;
   219.
   220.    the_profile   : array (KDF9.order_word_number) of KDF9.order_counter;
   221.
   222.    procedure clear_the_profile;
   223.
   224.    procedure add_CIA_to_the_profile
   225.       with Inline;
   226.
   227. end tracing;

 596 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/formatting.adb
Source file time stamp: 2021-02-20 23:56:00
Compiled at: 2021-02-21 15:54:07

     1. -- Provide basic data-formatting operations for KDF9 data types.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Handling;
    18. with Ada.Strings;
    19. with Ada.Strings.Fixed;
    20. --
    21. with KDF9_char_sets;
    22. with KDF9.CPU;
    23.
    24. use  Ada.Characters.Handling;
    25. use  Ada.Strings;
    26. use  Ada.Strings.Fixed;
    27. --
    28. use  KDF9_char_sets;
    29. use  KDF9.CPU;
    30.
    31. package body formatting is
    32.
    33.    digit_map : constant array (KDF9.halfword range 0 .. 15) of Character := "0123456789ABCDEF";
    34.
    35.    -- Return N as 3 octal digits.
    36.    function oct_of (N : KDF9.syllable)
    37.    return String
    38.    is (oct_of(KDF9.halfword(N))(6 .. 8));
    39.
    40.    -- Return N as 6 octal digits.
    41.    function oct_of (N : KDF9.field_of_16_bits)
    42.    return String is
    43.       value : KDF9.field_of_16_bits := N;
    44.       oct   : String(1 .. 6);
    45.    begin
    46.       for i in reverse oct'Range loop
    47.          oct(i) := digit_map(KDF9.halfword(value mod 8));
    48.          value := value / 8;
    49.       end loop;
    50.       return oct;
    51.    end oct_of;
    52.
    53.    -- Return N as 1 .. min_digits octal digits, with (partial) zero suppression.
    54.    function oct_of (N : KDF9.Q_part; min_digits : octal_width := 6)
    55.    return String is
    56.       oct : constant String(octal_width) := oct_of(KDF9.field_of_16_bits(N));
    57.    begin
    58.      if N = 0 then return (1..min_digits => '0'); end if;
    59.      for i in 1 .. 6-min_digits loop
    60.         if oct(i) /= '0' then
    61.            return oct(i .. 6);
    62.         end if;
    63.       end loop;
    64.       return oct(7-min_digits .. 6);
    65.    end oct_of;
    66.
    67.    -- Return N as 1 .. 5 decimal digits, with zero suppression and sign when neagtive.
    68.    function signed_dec_of (N : KDF9.Q_part)
    69.    return String is
    70.       dec : constant String := resign(N)'Image;
    71.    begin
    72.       return trimmed(dec);
    73.    end signed_dec_of;
    74.
    75.    -- Return N as decimal digits, with zero suppression.
    76.    function dec_of (N : KDF9.Q_part)
    77.    return String is
    78.       dec : constant String := N'Image;
    79.    begin
    80.       return trimmed(dec);
    81.    end dec_of;
    82.
    83.    -- Return N as up to 5 octal digits.
    84.    function oct_of (N : KDF9.order_word_number)
    85.    return String is
    86.       value : KDF9.order_word_number := N;
    87.       j     : Positive := 5;
    88.       oct   : String(1 .. 5);
    89.    begin
    90.       for i in reverse oct'Range loop
    91.          oct(i) := digit_map(KDF9.halfword(value mod 8));
    92.          value := value / 8;
    93.       end loop;
    94.       for i in oct'Range loop
    95.          if oct(i) /= '0' then j := i; exit; end if;
    96.       end loop;
    97.       return oct(j..5);
    98.    end oct_of;
    99.
   100.    -- Return N as decimal digits, with zero suppression.
   101.    function dec_of (N : KDF9.order_word_number)
   102.    return String
   103.    is (trimmed(N'Image));
   104.
   105.    -- Return N as 8 octal digits.
   106.    function oct_of (N : KDF9.halfword)
   107.    return String is
   108.       value : KDF9.halfword := N;
   109.       oct   : String(1 .. 8);
   110.    begin
   111.       for i in reverse oct'Range loop
   112.          oct(i) := digit_map(value mod 8);
   113.          value := value / 8;
   114.       end loop;
   115.       return oct;
   116.    end oct_of;
   117.
   118.    -- Return N as #wwwww/s, where w and s are octal digits.
   119.    function oct_of (N : KDF9.SJNS_link)
   120.    return String
   121.    is (
   122.        "#"
   123.       &  oct_of(N.order_word_number)
   124.       & '/'
   125.       & digit_map(KDF9.halfword(N.syllable_index))
   126.       );
   127.
   128.    -- Return N as #wwwww/s, where w and s are octal digits.
   129.    function oct_of (N : KDF9.syllable_address)
   130.    return String
   131.    is (oct_of(KDF9.SJNS_link(N)));
   132.
   133.    -- Return N as dddd/d, where d is a decimal digit.
   134.    function dec_of (N : KDF9.syllable_address)
   135.    return String
   136.    is (
   137.        trimmed(N.order_word_number'Image)
   138.             & '/'
   139.             & digit_map(KDF9.halfword(N.syllable_index))
   140.       );
   141.
   142.    -- Return N as #wwwww/s, where w and s are octal digits;
   143.    --    or as dddd/s, where d is a decimal digit, according to octal_option.
   144.    function oct_or_dec_of (N : KDF9.syllable_address; octal_option : Boolean)
   145.    return String
   146.    is (if octal_option then oct_of(N) else dec_of(N));
   147.
   148.    -- Return N as 16 octal digits
   149.    function oct_of (N : KDF9.word)
   150.    return String is
   151.       value : KDF9.word := N;
   152.       oct   : String(1 .. 16);
   153.    begin
   154.       for i in reverse oct'Range loop
   155.          oct(i) := digit_map(KDF9.halfword(value mod 8));
   156.          value := value / 8;
   157.       end loop;
   158.       return oct;
   159.    end oct_of;
   160.
   161.    -- Return "L', R'", or "L'" if R' is empty; "'" indicates removal of trailing blanks.
   162.    function "-" (L, R : String)
   163.    return String is
   164.       trim_R : constant String := trim(R, right);
   165.    begin
   166.       if trim_R /= "" then
   167.          return trim(L, right) & ", " & trim_R;
   168.       else
   169.          return trim(L, right);
   170.       end if;
   171.    end "-";
   172.
   173.    -- Return S with all leading an trailing blanks removed.
   174.    function trimmed (S : String)
   175.    return String
   176.    is (Trim(S, Ada.Strings.Both));
   177.
   178.    -- Return trimmed(S), right-just_right in a field of width at least W.
   179.    function just_right (S : String; W : Positive := 3)
   180.    return String is
   181.      image   : constant String   := Trim(S, Ada.Strings.Both);
   182.      columns : constant Positive := Positive'Max(W, image'Length);
   183.    begin
   184.      return Ada.Strings.Fixed.Tail(image, columns, ' ');
   185.    end just_right;
   186.
   187.    -- Return trimmed(S), left-justified in a field of width at least W.
   188.    function just_left (S : String; W : Positive := 3)
   189.    return String is
   190.      image   : constant String   := Trim(S, Ada.Strings.Both);
   191.      columns : constant Positive := Positive'Max(W, image'Length);
   192.    begin
   193.      return Ada.Strings.Fixed.Head(image, columns, ' ');
   194.    end just_left;
   195.
   196.    function plurality (count : KDF9.word; for_1 : String := ""; for_more : String := "s")
   197.    return String
   198.    is (if count /= 1 then for_more else for_1);
   199.
   200.    -- Return C converted to a 1-character string.
   201.    function "+" (C : Character)
   202.    return unit_string
   203.    is ((1 => C));
   204.
   205.    -- Return C with all Latin-1 lower-case letters converted to upper-case.
   206.    function to_upper (C : Character)
   207.    return Character
   208.    renames Ada.Characters.Handling.to_upper;
   209.
   210.    -- Return S with all Latin-1 lower-case letters converted to upper-case.
   211.    function to_upper (S : String)
   212.    return String
   213.    renames Ada.Characters.Handling.to_upper;
   214.
   215.    -- Return C with all Latin-1 upper-case letters converted to lower-case.
   216.    function to_lower (C : Character)
   217.    return Character
   218.    renames Ada.Characters.Handling.to_lower;
   219.
   220.    -- Return S with all Latin-1 upper-case letters converted to lower-case.
   221.    function to_lower (S : String)
   222.    return String
   223.    renames Ada.Characters.Handling.to_lower;
   224.
   225.    -- Return the 8-character Latin-1 string representing the 8 Case Normal characters in N.
   226.    function to_string (N : KDF9.word)
   227.    return word_as_byte_string is
   228.       word   : KDF9.word := N;
   229.       result : word_as_byte_string;
   230.    begin
   231.       for i in reverse 1 .. 8 loop
   232.          result(i) := KDF9_char_sets.TP_CN(KDF9_char_sets.symbol(word and 8#77#));
   233.          word := word / 64;
   234.       end loop;
   235.       return result;
   236.    end to_string;
   237.
   238.    -- Return the result of applying to_string to each word of a double-word.
   239.    function to_string (P : KDF9.pair)
   240.    return pair_as_byte_string is
   241.       result : pair_as_byte_string;
   242.    begin
   243.       result(1 ..  8) := to_string(P.msw);
   244.       result(9 .. 16) := to_string(P.lsw);
   245.       return result;
   246.    end to_string;
   247.
   248.    -- Take a string and ignore it.
   249.    procedure discard (S : String) is null;
   250.
   251. end formatting;

Compiling: ../Source/formatting.ads
Source file time stamp: 2021-02-20 23:56:00
Compiled at: 2021-02-21 15:54:07

     1. -- Provide basic data-formatting operations for KDF9 data types.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18.
    19. use  KDF9;
    20.
    21. package formatting is
    22.
    23.    subtype unit_string         is String(1 .. 1);
    24.    subtype word_as_byte_string is String(1 .. 8);
    25.    subtype pair_as_byte_string is String(1 .. 16);
    26.
    27.    -- Return N as 3 octal digits.
    28.    function oct_of (N : KDF9.syllable)
    29.    return String;
    30.
    31.    -- Return N as 6 octal digits.
    32.    function oct_of (N : KDF9.field_of_16_bits)
    33.    return String;
    34.
    35.    subtype octal_width is Positive range 1 .. 6;
    36.
    37.    -- Return N as octal digits, with (partial) zero suppression.
    38.    -- The first (6-min_digits) are elided if '0'; all remaining digits are returned.
    39.    -- Up to 6 digits can be returned if the result is longer than min_digits.
    40.    -- If N is 0, the String (1..min_digits => '0') is returned.
    41.    function oct_of (N : KDF9.Q_part; min_digits : octal_width := 6)
    42.    return String;
    43.
    44.    -- Return N as 1 .. 5 decimal digits, with zero suppression and sign when neagtive.
    45.    function signed_dec_of (N : KDF9.Q_part)
    46.    return String;
    47.
    48.    -- Return N as 1 .. 6 decimal digits, with zero suppression.
    49.    function dec_of (N : KDF9.Q_part)
    50.    return String;
    51.
    52.    -- Return N as up to 5 octal digits.
    53.    function oct_of (N : KDF9.order_word_number)
    54.    return String;
    55.
    56.    -- Return N as decimal digits, with zero suppression.
    57.    function dec_of (N : KDF9.order_word_number)
    58.    return String ;
    59.
    60.    -- Return N as 8 octal digits.
    61.    function oct_of (N : KDF9.halfword)
    62.    return String;
    63.
    64.    -- Return N as #wwwww/s, where w and s are octal digits.
    65.    function oct_of (N : KDF9.SJNS_link)
    66.    return String;
    67.
    68.    -- Return N as #wwwww/s, where w and s are octal digits.
    69.    function oct_of (N : KDF9.syllable_address)
    70.    return String;
    71.
    72.    -- Return N as dddd/d, where d is a decimal digit.
    73.    function dec_of (N : KDF9.syllable_address)
    74.    return String;
    75.
    76.    -- Return N as #wwwww/s, where w and s are octal digits;
    77.    --    or as dddd/s, where d is a decimal digit, according to octal_option.
    78.    function oct_or_dec_of (N : KDF9.syllable_address; octal_option : Boolean)
    79.    return String;
    80.
    81.    -- Return N as 16 octal digits.
    82.    function oct_of (N : KDF9.word)
    83.    return String;
    84.
    85.    -- Return "L', R'", or "L'" if R' is empty: "'" indicates removal of trailing blanks.
    86.    function "-" (L, R : String)
    87.    return String;
    88.
    89.    -- Return S with all leading and trailing blanks removed.
    90.    function trimmed (S : String)
    91.    return String;
    92.
    93.    -- Return trimmed(S), right-justified in a field of width at least W.
    94.    function just_right (S : String; W : Positive := 3)
    95.    return String;
    96.
    97.    -- Return trimmed(S), left-justified in a field of width at least W.
    98.    function just_left (S : String; W : Positive := 3)
    99.    return String;
   100.
   101.    -- Return the (pluralizing) suffix if count /= 1.
   102.    function plurality (count : KDF9.word; for_1 : String := ""; for_more : String := "s")
   103.    return String;
   104.
   105.    -- Return C converted to a 1-character string.
   106.    function "+" (C : Character)
   107.    return unit_string;
   108.
   109.    -- Return C with all Latin-1 lower-case letters converted to upper-case.
   110.    function to_upper (C : Character)
   111.    return Character;
   112.
   113.    -- Return S with all Latin-1 lower-case letters converted to upper-case.
   114.    function to_upper (S : String)
   115.    return String;
   116.
   117.    -- Return C with all Latin-1 upper-case letters converted to lower-case.
   118.    function to_lower (C : Character)
   119.    return Character;
   120.
   121.    -- Return S with all Latin-1 upper-case letters converted to lower-case.
   122.    function to_lower (S : String)
   123.    return String;
   124.
   125.    -- Return the 8-character Latin-1 string representing the 8 Case Normal characters in N.
   126.    function to_string (N : KDF9.word)
   127.    return word_as_byte_string;
   128.
   129.    -- Return the result of applying to_string to each word of a double-word.
   130.    function to_string (P : KDF9.pair)
   131.    return pair_as_byte_string;
   132.
   133.    -- Take a string and ignore it.
   134.    procedure discard (S : String);
   135.
   136. end formatting;

 251 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/host_io.adb
Source file time stamp: 2021-02-19 17:03:38
Compiled at: 2021-02-21 15:54:07

     1. -- Buffered I/O streams to support KDF9 device I/O.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Latin_1;
    18. --
    19. with OS_specifics;
    20.
    21. use  Ada.Characters.Latin_1;
    22. --
    23. use  OS_specifics;
    24.
    25. package body host_IO is
    26.
    27.    function fd_of (the_stream : host_IO.stream)
    28.    return Natural
    29.    is (the_stream.fd);
    30.
    31.    procedure open (the_stream : in out host_IO.stream;
    32.                    file_name  : in String;
    33.                    mode       : in POSIX.access_mode;
    34.                    fd         : in Integer) is
    35.    begin
    36.       if fd >= 0 then
    37.          make_transparent(fd);
    38.          the_stream.base_name := file_name(file_name'First .. file_name'First+2);
    39.          the_stream.IO_mode := mode;
    40.          the_stream.last_IO := read_mode;
    41.          the_stream.fd := fd;
    42.          the_stream.is_open := True;
    43.       else
    44.          the_stream.is_open := False;
    45.       end if;
    46.    end open;
    47.
    48.    procedure open (the_stream : in out host_IO.stream;
    49.                    file_name  : in String;
    50.                    mode       : in POSIX.access_mode) is
    51.       fd : Integer;
    52.    begin -- open
    53.       fd := POSIX.open(file_name, mode);
    54.       open(the_stream, file_name, mode, fd);
    55.    exception
    56.       when POSIX_IO_error =>
    57.          trap_operator_error("'" & file_name & "' cannot be opened");
    58.    end open;
    59.
    60.    procedure truncate (the_stream : in out host_IO.stream) is
    61.    begin
    62.       truncate(the_stream.fd);
    63.    end truncate;
    64.
    65.    procedure close (the_stream : in out host_IO.stream) is
    66.       response : Integer;
    67.    begin
    68.       if the_stream.is_open then
    69.          flush(the_stream);
    70.          response := close(the_stream.fd);
    71.          pragma Unreferenced(response);
    72.          the_stream.is_open := False;
    73.       end if;
    74.    end close;
    75.
    76.    procedure flush (the_stream  : in out host_IO.stream;
    77.                     a_byte_time : in KDF9.us := 0) is
    78.       response : Integer with Unreferenced;
    79.    begin
    80.       if the_stream.is_open      and then
    81.             the_stream.next_byte > 0 then
    82.          if the_stream.IO_mode > read_mode and the_stream.last_IO = write_mode then
    83.             if a_byte_time = 0 then
    84.                response := write(the_stream.fd, the_stream.buffer, the_stream.next_byte);
    85.             else
    86.                for p in 1 .. the_stream.next_byte loop
    87.                   response := write(the_stream.fd, the_stream.buffer(p..p), 1);
    88.                   KDF9.delay_by(a_byte_time);
    89.                end loop;
    90.             end if;
    91.          end if;
    92.          the_stream.next_byte := 0;
    93.          the_stream.block_size := 0;
    94.       end if;
    95.    end flush;
    96.
    97.    function a_LF_was_just_read (the_stream : host_IO.stream)
    98.    return Boolean
    99.    is (
   100.        the_stream.is_open                   and then
   101.           the_stream.bytes_moved > 0        and then
   102.              the_stream.last_IO = read_mode and then
   103.                 the_stream.next_byte = 0    and then
   104.                    the_stream.block_size = 0
   105.       );
   106.
   107.    function a_LF_was_just_written (the_stream : host_IO.stream)
   108.    return Boolean
   109.    is (
   110.        the_stream.is_open                    and then
   111.           the_stream.bytes_moved > 0         and then
   112.              the_stream.last_IO /= read_mode and then
   113.                 the_stream.column = 0
   114.       );
   115.
   116.    procedure reattach (the_stream : in out host_IO.stream;
   117.                        file_name  : in String;
   118.                        mode       : in POSIX.access_mode) is
   119.    begin
   120.       close(the_stream);
   121.       open(the_stream, file_name, (if the_stream.IO_mode = rd_wr_mode then rd_wr_mode else mode));
   122.       if the_stream.is_open then
   123.          the_stream.last_char := ' ';
   124.          the_stream.block_size := 0;
   125.          the_stream.next_byte := 0;
   126.          the_stream.position := 0;
   127.       end if;
   128.    end reattach;
   129.
   130.    function is_open (the_stream : host_IO.stream)
   131.    return Boolean
   132.    is (the_stream.is_open);
   133.
   134.    function bytes_moved (the_stream : host_IO.stream)
   135.    return KDF9.word
   136.    is (the_stream.bytes_moved);
   137.
   138.    function column (the_stream : host_IO.stream)
   139.    return Natural
   140.    is (the_stream.column);
   141.
   142.    procedure get_position (position   : out Natural;
   143.                            the_stream : in out host_IO.stream) is
   144.    begin
   145.       flush(the_stream);
   146.       position := the_stream.position;
   147.    end get_position;
   148.
   149.    function buffer_is_empty (the_stream : host_IO.stream)
   150.    return Boolean
   151.    is (not the_stream.is_open or else the_stream.next_byte >= the_stream.block_size);
   152.
   153.    function buffer_is_full (the_stream : host_IO.stream)
   154.    return Boolean
   155.    is (the_stream.is_open and then the_stream.next_byte = the_stream.buffer'Last);
   156.
   157.    procedure set_position (position   : in Natural;
   158.                            the_stream : in out host_IO.stream;
   159.                            whence     : in POSIX.seek_origin := from_start) is
   160.       response : POSIX.file_position with Warnings => Off;
   161.    begin
   162.       flush(the_stream);
   163.       response := seek(the_stream.fd, POSIX.file_position(position), whence);
   164.       the_stream.position := position;
   165.    end set_position;
   166.
   167.    procedure clear (the_stream : in out host_IO.stream) is
   168.    begin
   169.       the_stream.next_byte := 0;
   170.       the_stream.block_size := 0;
   171.    end clear;
   172.
   173.    procedure reset (the_stream : in out host_IO.stream) is
   174.    begin
   175.       flush(the_stream);
   176.       if the_stream.is_open then
   177.          the_stream.last_IO := read_mode;
   178.          the_stream.position := 0;
   179.          the_stream.next_byte := 0;
   180.          the_stream.block_size := 0;
   181.       end if;
   182.    end reset;
   183.
   184.    procedure back_off (the_stream : in out host_IO.stream) is
   185.    begin
   186.       if the_stream.is_open                   and then
   187.             the_stream.next_byte > 0          and then
   188.                the_stream.last_IO = read_mode     then
   189.          the_stream.next_byte := the_stream.next_byte - 1;
   190.          the_stream.position := the_stream.position - 1;
   191.       else
   192.          trap_operator_error(the_stream.base_name & "cannot back_off");
   193.       end if;
   194.    end back_off;
   195.
   196.    procedure get_byte (char       : out Character;
   197.                        the_stream : in out host_IO.stream) is
   198.       response : Integer;
   199.    begin
   200.       if buffer_is_empty(the_stream) then
   201.          response := read(the_stream.fd, the_stream.buffer, the_stream.buffer'Size);
   202.          the_stream.block_size := response;
   203.          the_stream.next_byte := 0;
   204.          if response <= 0 then
   205.             raise end_of_stream;
   206.          end if;
   207.       end if;
   208.       the_stream.next_byte := the_stream.next_byte + 1;
   209.       the_stream.position := the_stream.position + 1;
   210.       the_stream.bytes_moved := the_stream.bytes_moved + 1;
   211.       the_stream.last_IO := read_mode;
   212.       char := the_stream.buffer(the_stream.next_byte);
   213.       if char = LF then
   214.          the_stream.column := 0;
   215.       else
   216.          the_stream.column := the_stream.column + 1;
   217.       end if;
   218.    end get_byte;
   219.
   220.    procedure get_bytes (the_string : out String;
   221.                         the_stream : in out host_IO.stream;
   222.                         uncounted  : in Boolean := True) is
   223.       old_bytes_moved : constant KDF9.word := the_stream.bytes_moved;
   224.    begin
   225.       for b of the_string loop
   226.          get_byte(b, the_stream);
   227.       end loop;
   228.       if uncounted then
   229.          the_stream.bytes_moved := old_bytes_moved;
   230.       end if;
   231.    end get_bytes;
   232.
   233.    procedure get_char (char       : out Character;
   234.                        the_stream : in out host_IO.stream) is
   235.    begin
   236.       get_byte(char, the_stream);
   237.       if char = CR then
   238.          char := LF;
   239.          the_stream.last_char := CR;
   240.       elsif char = LF and the_stream.last_char = CR then
   241.          the_stream.last_char := LF;
   242.          get_byte(char, the_stream);
   243.       else
   244.          the_stream.last_char := char;
   245.       end if;
   246.    end get_char;
   247.
   248.    procedure peek_at_char (char       : out Character;
   249.                            the_stream : in out host_IO.stream) is
   250.    begin
   251.       get_char(char, the_stream);
   252.       back_off(the_stream);
   253.    end peek_at_char;
   254.
   255.    -- put_escape_code writes directly to the stream's device, avoiding the stream's buffers.
   256.    procedure put_escape_code (the_string : in String;
   257.                               the_stream : in out host_IO.stream) is
   258.       response : Integer with Warnings => Off;
   259.    begin
   260.       if not the_stream.is_open then
   261.          raise end_of_stream;
   262.       end if;
   263.       response := write(the_stream.fd,
   264.                         the_string,
   265.                         the_string'Length);
   266.    end put_escape_code;
   267.
   268.    procedure put_byte (char       : in Character;
   269.                        the_stream : in out host_IO.stream) is
   270.       response : Integer with Warnings => Off;
   271.    begin
   272.       if the_stream.buffer_is_full then
   273.          response := write(the_stream.fd,
   274.                            the_stream.buffer,
   275.                            the_stream.buffer'Size);
   276.          the_stream.next_byte := 0;
   277.       end if;
   278.       the_stream.next_byte := the_stream.next_byte + 1;
   279.       the_stream.position := the_stream.position + 1;
   280.       the_stream.bytes_moved := the_stream.bytes_moved + 1;
   281.       the_stream.buffer(the_stream.next_byte) := char;
   282.       the_stream.last_IO := write_mode;
   283.       if char = LF then
   284.          the_stream.column := 0;
   285.       else
   286.          the_stream.column := the_stream.column + 1;
   287.       end if;
   288.    end put_byte;
   289.
   290.    procedure do_not_put_byte (char       : in Character;
   291.                               the_stream : in out host_IO.stream) is
   292.    begin
   293.       the_stream.bytes_moved := the_stream.bytes_moved + 1;
   294.       the_stream.last_IO := write_mode;
   295.       if char = LF then
   296.          the_stream.column := 0;
   297.       else
   298.          the_stream.column := the_stream.column + 1;
   299.       end if;
   300.    end do_not_put_byte;
   301.
   302.    procedure put_bytes (the_string : in String;
   303.                         the_stream : in out host_IO.stream;
   304.                         uncounted  : in Boolean := True) is
   305.       old_bytes_moved : constant KDF9.word := the_stream.bytes_moved;
   306.    begin
   307.       for c of the_string loop
   308.          put_byte(c, the_stream);
   309.       end loop;
   310.       if uncounted then
   311.          the_stream.bytes_moved := old_bytes_moved;
   312.       end if;
   313.    end put_bytes;
   314.
   315.    procedure put_EOL (the_stream : in out host_IO.stream;
   316.                       uncounted  : in Boolean := True) is
   317.    begin
   318.       put_bytes(NL, the_stream, uncounted);
   319.    end put_EOL;
   320.
   321.    procedure put_char (char       : in Character;
   322.                        the_stream : in out host_IO.stream) is
   323.    begin
   324.       if char = LF then
   325.          put_EOL(the_stream, uncounted => False);
   326.       else
   327.          put_byte(char, the_stream);
   328.       end if;
   329.    end put_char;
   330.
   331.    procedure put_chars (the_string : in String;
   332.                         the_stream : in out host_IO.stream) is
   333.    begin
   334.       for c of the_string loop
   335.          put_char(c, the_stream);
   336.       end loop;
   337.    end put_chars;
   338.
   339.    function contents (the_stream : host_IO.stream)
   340.    return String is
   341.    begin
   342.       return the_stream.buffer(1..the_stream.next_byte);
   343.    end contents;
   344.
   345.    procedure inject (the_string : in String;
   346.                      the_stream : in out host_IO.stream) is
   347.       the_length : constant Natural := the_string'Length;
   348.    begin
   349.       if the_length > 0 and the_length < the_stream.buffer'Length then
   350.          the_stream.block_size := the_length + 1;
   351.          the_stream.buffer(1 .. the_length) := the_string;
   352.          the_stream.buffer(the_length + 1)  := LF;
   353.       end if;
   354.    end inject;
   355.
   356. end host_IO;

Compiling: ../Source/host_io.ads
Source file time stamp: 2021-02-19 02:26:51
Compiled at: 2021-02-21 15:54:07

     1. -- Buffered I/O streams to support KDF9 device I/O.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18. with POSIX;
    19.
    20. use  KDF9;
    21. use  POSIX;
    22.
    23. package host_IO is
    24.
    25.    end_of_stream : exception;
    26.
    27.    type stream is tagged limited private;
    28.
    29.    function fd_of (the_stream : host_IO.stream)
    30.    return Natural;
    31.
    32.    -- Open a stream with an established fd.
    33.    procedure open (the_stream : in out host_IO.stream;
    34.                    file_name  : in String;
    35.                    mode       : in POSIX.access_mode;
    36.                    fd         : in Integer);
    37.
    38.    -- Open a base file then use its fd to open a stream.
    39.    procedure open (the_stream : in out host_IO.stream;
    40.                    file_name  : in String;
    41.                    mode       : in POSIX.access_mode)
    42.       with Inline => False;
    43.
    44.    procedure truncate (the_stream : in out host_IO.stream);
    45.
    46.    procedure close (the_stream : in out host_IO.stream);
    47.
    48.    procedure flush (the_stream  : in out host_IO.stream;
    49.                     a_byte_time : in KDF9.us := 0);
    50.
    51.    -- Reassign an open stream to another file.
    52.    procedure reattach (the_stream : in out host_IO.stream;
    53.                        file_name  : in String;
    54.                        mode       : in POSIX.access_mode);
    55.
    56.    function is_open (the_stream : host_IO.stream)
    57.    return Boolean;
    58.
    59.    function bytes_moved (the_stream : host_IO.stream)
    60.    return KDF9.word;
    61.
    62.    function column (the_stream : host_IO.stream)
    63.    return Natural;
    64.
    65.    procedure get_position (position   : out Natural;
    66.                            the_stream : in out host_IO.stream);
    67.
    68.    procedure set_position (position   : in Natural;
    69.                            the_stream : in out host_IO.stream;
    70.                            whence     : in POSIX.seek_origin := from_start);
    71.
    72.    procedure clear (the_stream : in out host_IO.stream);
    73.
    74.    procedure reset (the_stream : in out host_IO.stream);
    75.
    76.    -- Arrange for the last-read byte to be read again.
    77.    procedure back_off (the_stream : in out host_IO.stream)
    78.       with Inline;
    79.
    80.    procedure get_byte (char       : out Character;
    81.                        the_stream : in out host_IO.stream);
    82.
    83.    -- get_bytes iterates get_byte over the_string, for convenience.
    84.    -- If uncounted then the output is not included in the_stream.bytes_moved.
    85.    procedure get_bytes (the_string : out String;
    86.                         the_stream : in out host_IO.stream;
    87.                         uncounted  : in Boolean := True);
    88.
    89.    -- True iff the last get_byte obtained a LF.
    90.    function a_LF_was_just_read (the_stream : host_IO.stream)
    91.    return Boolean;
    92.
    93.    -- get_char differs from get_byte in the treatment of line terminators.
    94.    -- CR, LF, and CRLF are all returned as a single LF character, so catering
    95.    --    for old MacOS, MSDOS, and macOS/UNIX/Linux external text-file formats.
    96.    procedure get_char (char       : out Character;
    97.                        the_stream : in out host_IO.stream);
    98.
    99.    -- peek_at_char uses get_char to inspect the next char to be delivered,
   100.    --    then invokes back_off so that it is left in the input stream.
   101.    procedure peek_at_char (char       : out Character;
   102.                            the_stream : in out host_IO.stream);
   103.
   104.    -- do_not_put_byte does the same as put_byte, except for actually writing it to the_stream.
   105.    procedure do_not_put_byte (char       : in Character;
   106.                               the_stream : in out host_IO.stream);
   107.
   108.    procedure put_byte (char       : in Character;
   109.                        the_stream : in out host_IO.stream);
   110.
   111.    -- put_escape_code writes directly to the stream's device, avoiding the stream's buffers.
   112.    procedure put_escape_code (the_string : in String;
   113.                               the_stream : in out host_IO.stream);
   114.
   115.    -- put_bytes iterates put_byte over the_string, for convenience.
   116.    -- If uncounted then the output is not included in the_stream.bytes_moved.
   117.    procedure put_bytes (the_string : in String;
   118.                         the_stream : in out host_IO.stream;
   119.                         uncounted  : in Boolean := True);
   120.
   121.    -- put_EOL writes the host-appropriate line terminator (CRLF, or just LF)
   122.    procedure put_EOL (the_stream : in out host_IO.stream;
   123.                       uncounted  : in Boolean := True);
   124.
   125.    -- put_char differs from put_byte only in the treatment of line terminators.
   126.    -- If char is LF, then put_EOL is used to output a host-appropriate line terminator.
   127.    procedure put_char (char       : in Character;
   128.                        the_stream : in out host_IO.stream);
   129.
   130.    -- put_chars iterates put_bytes over the_string, for convenience.
   131.    procedure put_chars (the_string : in String;
   132.                         the_stream : in out host_IO.stream);
   133.
   134.    -- True iff the last put_byte wrote out a LF.
   135.    function a_LF_was_just_written (the_stream : host_IO.stream)
   136.    return Boolean;
   137.
   138.    function buffer_is_empty (the_stream : host_IO.stream)
   139.    return Boolean
   140.       with Inline;
   141.
   142.    function buffer_is_full (the_stream : host_IO.stream)
   143.    return Boolean
   144.       with Inline;
   145.
   146.    -- Return the currently buffered output as a single string.
   147.    function contents (the_stream : host_IO.stream)
   148.    return String;
   149.
   150.    -- Make the_string appear to be input for the_stream (which must be empty).
   151.    procedure inject (the_string : in String;
   152.                      the_stream : in out host_IO.stream);
   153.
   154. private
   155.
   156.    -- N.B. in host_IO the term 'buffer' is used conventionally.
   157.    -- It does NOT refer to a KDF9 DMA channel.
   158.
   159.    -- IO_buffer_size is enough for a full LP line, lacking any better criterion.
   160.    IO_buffer_size : constant Positive := 161;
   161.
   162.    type stream is tagged limited
   163.       record
   164.          base_name   : String (1 .. 3) := "???";
   165.          is_open     : Boolean := False;
   166.          last_char   : Character := ' ';
   167.          block_size,
   168.          next_byte,
   169.          saved_size,
   170.          position,
   171.          column      : Natural := 0;
   172.          bytes_moved : KDF9.word := 0;
   173.          fd          : Natural := Natural'Last;
   174.          IO_mode     : POSIX.access_mode range read_mode .. rd_wr_mode;
   175.          last_IO     : POSIX.access_mode range read_mode .. write_mode;
   176.          buffer,
   177.          look_behind : String(1 .. IO_buffer_size);
   178.       end record;
   179.
   180. end host_IO;

 356 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-store.adb
Source file time stamp: 2021-02-19 21:08:16
Compiled at: 2021-02-21 15:54:07

     1. -- KDF9 core store operations.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Unchecked_Conversion;
    18. --
    19. with formatting;
    20. with KDF9.CPU;
    21.
    22. use formatting;
    23. use  KDF9.CPU;
    24.
    25. package body KDF9.store is
    26.
    27.    -- diagnose_invalid_address avoids secondary stack usage in the address validation procedures.
    28.    procedure diagnose_invalid_address (message : in String; address : in KDF9.word)
    29.       with Inline => False;
    30.
    31.    procedure diagnose_invalid_address (message : in String; address : in KDF9.word) is
    32.    begin
    33.       trap_illegal_instruction(message & " =" & address'Image);
    34.    end diagnose_invalid_address;
    35.
    36.    -- Check that EA, EA+BA are valid; LIV if invalid.
    37.    procedure validate_virtual_and_real_addresses (EA : in KDF9.Q_part)
    38.       with Inline => True;
    39.
    40.    procedure validate_virtual_and_real_addresses (EA : in KDF9.Q_part) is
    41.       PA : constant KDF9.word := (KDF9.word(EA) + KDF9.word(BA)) and Q_part_mask;
    42.    begin
    43.       if EA > NOL and then the_CPU_state = program_state then
    44.          diagnose_invalid_address("NOL < virtual address", KDF9.word(EA));
    45.       end if;
    46.       if PA > max_address and then the_CPU_state = program_state then
    47.          diagnose_invalid_address("32K-1 < physical address", PA);
    48.       end if;
    49.    end validate_virtual_and_real_addresses;
    50.
    51.    procedure if_user_mode_then_LOV (address_1 : KDF9.Q_part;
    52.                                     address_2 : KDF9.Q_part := 0;
    53.                                     solo      : Boolean     := True) is
    54.    begin
    55.       LOV_if_user_mode(
    56.                        if solo
    57.                        then "at #" & oct_of(address_1) & " (E" & dec_of(address_1) & ")"
    58.                        else "in #" & oct_of(address_1) & "..#" & oct_of(address_2)
    59.                       );
    60.    end if_user_mode_then_LOV;
    61.
    62.    function group (PA : KDF9.Q_part)
    63.    return KDF9.Q_part
    64.    is (PA / group_size);
    65.
    66.    procedure check_address_and_lockout (EA : in KDF9.Q_part) is
    67.       PA : constant KDF9.Q_part := EA + BA;
    68.    begin
    69.       validate_virtual_and_real_addresses(EA);
    70.       if locked_out(group(PA)) then
    71.          the_locked_out_address := PA;
    72.          if the_CPU_state /= Director_state then
    73.             if_user_mode_then_LOV(PA);
    74.          end if;
    75.       end if;
    76.    end check_address_and_lockout;
    77.
    78.    procedure validate_address_range (EA1, EA2 : in KDF9.Q_part) is
    79.    begin
    80.       if EA1 > EA2 then
    81.          diagnose_invalid_address("initial address > final address", KDF9.word(EA2));
    82.       end if;
    83.       validate_virtual_and_real_addresses(EA1);
    84.       validate_virtual_and_real_addresses(EA2);
    85.    end validate_address_range;
    86.
    87.    procedure check_addresses_and_lockouts (EA1, EA2 : in KDF9.Q_part) is
    88.        PA1 : constant KDF9.Q_part := EA1 + BA;
    89.        PA2 : constant KDF9.Q_part := EA2 + BA;
    90.    begin
    91.       validate_address_range (EA1, EA2);
    92.       if there_are_locks_in_physical_addresses(KDF9.Q_register'(C => 0, I => PA1, M => PA2)) then
    93.          if the_CPU_state /= Director_state then
    94.             if_user_mode_then_LOV(PA1, PA2, solo => False);
    95.          end if;
    96.       end if;
    97.    end check_addresses_and_lockouts;
    98.
    99.    -- Check that A1+A2 is valid; trap if it is invalid.
   100.    function valid_word_address (A1, A2 : in KDF9.Q_part)
   101.    return KDF9.address is
   102.       V : constant KDF9.word := (KDF9.word(A1) + KDF9.word(A2)) and Q_part_mask;
   103.    begin
   104.       if V > max_address then
   105.          diagnose_invalid_address("32K-1 < virtual address", V);
   106.       end if;
   107.       return KDF9.address(V);
   108.    end valid_word_address;
   109.
   110.    function signed is new Ada.Unchecked_Conversion (KDF9.Q_part, CPU.signed_Q_part);
   111.    function design is new Ada.Unchecked_Conversion (CPU.signed_Q_part, KDF9.Q_part);
   112.
   113.    -- Check that A1+A2/2 is valid; trap if it is invalid.  A2 must be treated as a signed number.
   114.    function valid_halfword_address (A1, A2 : in KDF9.Q_part)
   115.    return KDF9.address is
   116.       V : constant KDF9.word := (KDF9.word(A1) + KDF9.word(design(signed(A2)/2))) and Q_part_mask;
   117.    begin
   118.       if V > max_address then
   119.          diagnose_invalid_address("32K-1 < virtual address", V);
   120.       end if;
   121.       return KDF9.address(V);
   122.    end valid_halfword_address;
   123.
   124.    function fetch_symbol (EA : KDF9.address; index : KDF9_char_sets.symbol_index)
   125.    return KDF9_char_sets.symbol
   126.    is (KDF9_char_sets.symbol(shift_word_right(core(EA+BA), 42 - 6*Natural(index)) and 8#77#));
   127.
   128.    procedure store_symbol (value : in KDF9_char_sets.symbol;
   129.                            EA    : in KDF9.address;
   130.                            index : in KDF9_char_sets.symbol_index) is
   131.       place  : constant Natural   := 42 - 6*Natural(index);
   132.       mask   : constant KDF9.word := not shift_word_left(8#77#, place);
   133.       symbol : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   134.    begin
   135.       core(EA+BA) := (core(EA+BA) and mask) or symbol;
   136.    end store_symbol;
   137.
   138.    function fetch_octet (EA : KDF9.address; index : KDF9_char_sets.octet_index)
   139.    return KDF9_char_sets.octet is
   140.       place : constant Natural := 40 - 8*Natural(index);
   141.    begin
   142.       return KDF9_char_sets.octet(shift_word_right(core(EA+BA), place) and 8#377#);
   143.    end fetch_octet;
   144.
   145.    procedure store_octet  (value : in KDF9_char_sets.octet;
   146.                            EA    : in KDF9.address;
   147.                            index : in KDF9_char_sets.octet_index) is
   148.       place : constant Natural   := 40 - 8*Natural(index);
   149.       octet : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   150.       mask  : constant KDF9.word := not shift_word_left(8#377#, place);
   151.    begin
   152.       core(EA+BA) := (core(EA+BA) and mask) or octet;
   153.    end store_octet;
   154.
   155.    function fetch_syllable (EA : KDF9.syllable_address)
   156.    return KDF9.syllable is
   157.       address : constant KDF9.address := Q_part(EA.order_word_number) + BA;
   158.       place   : constant Natural      := 40 - 8*Natural(EA.syllable_index);
   159.    begin
   160.       return KDF9.syllable(shift_word_right(core(address), place) and 8#377#);
   161.    end fetch_syllable;
   162.
   163.    procedure store_syllable (value : in KDF9.syllable;
   164.                              EA    : in KDF9.address;
   165.                              index : in KDF9.syllable_index) is
   166.       place    : constant Natural   := 40 - 8*Natural(index);
   167.       syllable : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   168.       mask     : constant KDF9.word := not shift_word_left(8#377#, place);
   169.    begin
   170.       core(EA+BA) := (core(EA+BA) and mask) or syllable;
   171.    end store_syllable;
   172.
   173.    function fetch_halfword (EA : KDF9.address; index : KDF9.halfword_number)
   174.    return KDF9.word
   175.    is (shift_word_left(shift_word_right(core(EA+BA), 24 - 24*Natural(index)), 24));
   176.
   177.    procedure store_halfword (value : in KDF9.word;
   178.                              EA    : in KDF9.address;
   179.                              index : in KDF9.halfword_number) is
   180.       place   : constant Natural   := 24 - 24*Natural(index);
   181.       half    : constant KDF9.word := shift_word_left(shift_word_right(value, 24), place);
   182.       mask    : constant KDF9.word := not shift_word_left(halfword_mask, place);
   183.    begin
   184.       core(EA+BA) := (core(EA+BA) and mask) or half;
   185.    end store_halfword;
   186.
   187.    function fetch_word (EA : KDF9.address)
   188.    return KDF9.word
   189.    is (core(EA+BA));
   190.
   191.    procedure store_word (value : in KDF9.word; EA : in KDF9.address) is
   192.    begin
   193.       core(EA+BA) := value;
   194.    end store_word;
   195.
   196.    function there_are_locks_in_relative_addresses (Q : KDF9.Q_register)
   197.    return Boolean is
   198.    begin
   199.       validate_address_range (Q.I, Q.M);
   200.       return there_are_locks_in_physical_addresses((0, Q.I+BA, Q.M+BA));
   201.    end there_are_locks_in_relative_addresses;
   202.
   203.    function there_are_locks_in_physical_addresses (Q : KDF9.Q_register)
   204.    return Boolean is
   205.    begin
   206.       for g in group(Q.I) .. group(Q.M) loop
   207.          if locked_out(g) then
   208.             the_locked_out_address := g * group_size;
   209.             return True;
   210.          end if;
   211.       end loop;
   212.       return False;
   213.    end there_are_locks_in_physical_addresses;
   214.
   215.    function is_unlocked (G : KDF9.store.group_address)
   216.    return Boolean is
   217.    begin
   218.       return not locked_out(KDF9.Q_part(G));
   219.    end is_unlocked;
   220.
   221.    procedure lock_out_relative_addresses (Q : in KDF9.Q_register) is
   222.    begin
   223.       validate_address_range (Q.I, Q.M);
   224.       lock_out_absolute_addresses((0, Q.I+BA, Q.M+BA));
   225.    end lock_out_relative_addresses;
   226.
   227.    procedure lock_out_absolute_addresses (Q : in KDF9.Q_register) is
   228.    begin
   229.       for g in group(Q.I) .. group(Q.M) loop
   230.          locked_out(g) := True;
   231.       end loop;
   232.    end lock_out_absolute_addresses;
   233.
   234.    procedure unlock_absolute_addresses (Q : in KDF9.Q_register) is
   235.    begin
   236.       for g in group(Q.I) .. group(Q.M) loop
   237.          locked_out(g) := False;
   238.       end loop;
   239.    end unlock_absolute_addresses;
   240.
   241. end KDF9.store;

Compiling: ../Source/kdf9-store.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:07

     1. -- KDF9 core store operations.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18.
    19. use  KDF9_char_sets;
    20.
    21. package KDF9.store is
    22.
    23.    --
    24.    -- Relative addresses may be either virtual or physical.
    25.    -- Virtual addresses are generated by problem programs and must be relativized by adding BA.
    26.    -- These addresses must also be validated to ensure they do not breach store limits.
    27.    -- Physical "relative" addresses are generated by Director, when BA is guaranteed to be 0,
    28.    --   so it has no effect, thus allowing the relative address routines to be used.
    29.    --
    30.    -- Absolute addresses are generated by I/O Control, which may be doing a transfer for either
    31.    --   a Director or a problem program, and must therefore ensure that BA is not added.
    32.    --
    33.
    34.    --
    35.    -- Parameters named EA are Effective "relative" Addresses.
    36.    --
    37.
    38.    function fetch_symbol (EA : KDF9.address; index : KDF9_char_sets.symbol_index)
    39.    return KDF9_char_sets.symbol;
    40.
    41.    function fetch_octet (EA : KDF9.address; index : KDF9_char_sets.octet_index)
    42.    return KDF9_char_sets.octet
    43.       with Inline;
    44.
    45.    function fetch_syllable (EA : KDF9.syllable_address)
    46.    return KDF9.syllable
    47.       with Inline;
    48.
    49.    function fetch_halfword (EA : KDF9.address; index : KDF9.halfword_number)
    50.    return KDF9.word
    51.       with Inline;
    52.
    53.    function fetch_word (EA : KDF9.address)
    54.    return KDF9.word
    55.       with Inline;
    56.
    57.    procedure store_symbol (value : in KDF9_char_sets.symbol;
    58.                            EA    : in KDF9.address;
    59.                            index : in KDF9_char_sets.symbol_index)
    60.       with Inline;
    61.
    62.    procedure store_octet  (value : in KDF9_char_sets.octet;
    63.                            EA    : in KDF9.address;
    64.                            index : in KDF9_char_sets.octet_index)
    65.       with Inline;
    66.
    67.    procedure store_syllable (value : in KDF9.syllable;
    68.                              EA    : in KDF9.address;
    69.                              index : in KDF9.syllable_index)
    70.       with Inline;
    71.
    72.    procedure store_halfword (value : in KDF9.word;
    73.                              EA    : in KDF9.address;
    74.                              index : in KDF9.halfword_number)
    75.       with Inline;
    76.
    77.    procedure store_word (value : in KDF9.word; EA : in KDF9.address)
    78.       with Inline;
    79.
    80.    -- Check that A1+A2 is a valid word address; LIV if it is invalid.
    81.    function valid_word_address (A1, A2 : in KDF9.Q_part)
    82.    return KDF9.address
    83.       with Inline;
    84.
    85.    -- Check that A1+A2/2 is valid; LIV if it is invalid.  A2 is treated as a signed number.
    86.    function valid_halfword_address (A1, A2 : in KDF9.Q_part)
    87.    return KDF9.address
    88.       with Inline;
    89.
    90.    -- If a store access is locked out, its physical address is left here.
    91.    the_locked_out_address : KDF9.Q_part;
    92.
    93.    procedure if_user_mode_then_LOV (address_1 : KDF9.Q_part;
    94.                                     address_2 : KDF9.Q_part := 0;
    95.                                     solo      : Boolean     := True)
    96.       with Inline => False;
    97.
    98.    -- Check EA and lockout for EA.
    99.    procedure check_address_and_lockout (EA : in KDF9.Q_part)
   100.       with Inline;
   101.
   102.    -- Check that EA1, EA2, EA1+BA, EA2+BA are valid, and EA1 <= EA2.
   103.    --    LIV in any invalid case.
   104.    procedure validate_address_range (EA1, EA2 : in KDF9.Q_part);
   105.
   106.    -- Check EA1, EA2, and lockouts for EA1+BA .. EA2+BA.
   107.    procedure check_addresses_and_lockouts (EA1, EA2 : in KDF9.Q_part);
   108.
   109.    function there_are_locks_in_relative_addresses (Q : KDF9.Q_register)
   110.    return Boolean;
   111.
   112.    function there_are_locks_in_physical_addresses (Q : KDF9.Q_register)
   113.    return Boolean;
   114.
   115.    procedure lock_out_relative_addresses (Q : in KDF9.Q_register);
   116.
   117.    procedure lock_out_absolute_addresses (Q : in KDF9.Q_register);
   118.
   119.    procedure unlock_absolute_addresses (Q : in KDF9.Q_register);
   120.
   121.    -- The maximum size KDF9 core store has 32Kibiwords.
   122.    max_address   : constant := 2**15 - 1;
   123.
   124.    -- The group size of 32 words is 1 physical core allocation unit and physical lockout unit.
   125.    group_size : constant := 32;
   126.
   127.    type group_address is mod 1024;
   128.
   129.     -- is_unlocked yields True if the designated group is NOT locked out.
   130.    function is_unlocked (G : KDF9.store.group_address)
   131.    return Boolean;
   132.
   133.    function group (PA : KDF9.Q_part)
   134.    return KDF9.Q_part
   135.       with Inline;
   136.
   137. private
   138.
   139.    type word_array is array (KDF9.Q_part range <>) of KDF9.word
   140.       with Component_Size => 64, Convention => C;
   141.
   142.    -- The core store of KDF9.  Must be zeroized before loading any software.
   143.    core : word_array (KDF9.Q_part range 0 .. max_address) := (others => 0);
   144.
   145.    -- The lockout store has one bit for every group_size words.
   146.    last_lockout : constant := max_address / group_size;
   147.    locked_out   : array (KDF9.Q_part range 0 .. last_lockout) of Boolean := (others => False);
   148.
   149. end KDF9.store;

 241 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-absent.adb
Source file time stamp: 2021-02-16 23:23:54
Compiled at: 2021-02-21 15:54:07

     1. -- Handle attempted usage of a buffer with No Device attached.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.absent is
    18.
    19.    procedure disavow (the_device  : in out absent.device;
    20.                       Q_operand   : in KDF9.Q_register;
    21.                       set_offline : in Boolean) is
    22.       pragma Unreferenced(Q_operand);
    23.       pragma Unreferenced(set_offline);
    24.    begin
    25.       trap_operator_error("there is no device on buffer #" & oct_of(the_device.number, 2));
    26.    end disavow;
    27.
    28.    overriding
    29.    procedure PIA (the_device  : in out absent.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean) is
    32.    begin disavow(the_device, Q_operand, set_offline); end PIA;
    33.
    34.    overriding
    35.    procedure PIB (the_device  : in out absent.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean) is
    38.    begin disavow(the_device, Q_operand, set_offline); end PIB;
    39.
    40.    overriding
    41.    procedure PIC (the_device  : in out absent.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean) is
    44.    begin disavow(the_device, Q_operand, set_offline); end PIC;
    45.
    46.    overriding
    47.    procedure PID (the_device  : in out absent.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean) is
    50.    begin disavow(the_device, Q_operand, set_offline); end PID;
    51.
    52.    overriding
    53.    procedure PIE (the_device  : in out absent.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean) is
    56.    begin disavow(the_device, Q_operand, set_offline); end PIE;
    57.
    58.    overriding
    59.    procedure PIF (the_device  : in out absent.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean) is
    62.    begin disavow(the_device, Q_operand, set_offline); end PIF;
    63.
    64.    overriding
    65.    procedure PIG (the_device  : in out absent.device;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean) is
    68.    begin disavow(the_device, Q_operand, set_offline); end PIG;
    69.
    70.    overriding
    71.    procedure PIH (the_device  : in out absent.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean) is
    74.    begin disavow(the_device, Q_operand, set_offline); end PIH;
    75.
    76.    overriding
    77.    procedure PMA (the_device  : in out absent.device;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean) is
    80.    begin disavow(the_device, Q_operand, set_offline); end PMA;
    81.
    82.    overriding
    83.    procedure PMB (the_device  : in out absent.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean) is
    86.    begin disavow(the_device, Q_operand, set_offline); end PMB;
    87.
    88.    overriding
    89.    procedure PMC (the_device  : in out absent.device;
    90.                   Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean) is
    92.    begin disavow(the_device, Q_operand, set_offline); end PMC;
    93.    overriding
    94.    procedure PMD (the_device  : in out absent.device;
    95.                   Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean) is
    97.    begin disavow(the_device, Q_operand, set_offline); end PMD;
    98.
    99.    overriding
   100.    procedure PME (the_device  : in out absent.device;
   101.                   Q_operand   : in KDF9.Q_register;
   102.                   set_offline : in Boolean) is
   103.    begin disavow(the_device, Q_operand, set_offline); end PME;
   104.
   105.    overriding
   106.    procedure PMF (the_device  : in out absent.device;
   107.                   Q_operand   : in KDF9.Q_register;
   108.                   set_offline : in Boolean) is
   109.    begin disavow(the_device, Q_operand, set_offline); end PMF;
   110.
   111.
   112.    overriding
   113.    procedure PMG (the_device  : in out absent.device;
   114.                   Q_operand   : in KDF9.Q_register;
   115.                   set_offline : in Boolean) is
   116.    begin disavow(the_device, Q_operand, set_offline); end PMG;
   117.
   118.    overriding
   119.    procedure PMK (the_device  : in out absent.device;
   120.                   Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean) is
   122.    begin disavow(the_device, Q_operand, set_offline); end PMK;
   123.
   124.    overriding
   125.    procedure PML (the_device  : in out absent.device;
   126.                   Q_operand   : in KDF9.Q_register;
   127.                   set_offline : in Boolean) is
   128.    begin disavow(the_device, Q_operand, set_offline); end PML;
   129.
   130.    overriding
   131.    procedure POA (the_device  : in out absent.device;
   132.                   Q_operand   : in KDF9.Q_register;
   133.                   set_offline : in Boolean) is
   134.    begin disavow(the_device, Q_operand, set_offline); end POA;
   135.
   136.    overriding
   137.    procedure POB (the_device  : in out absent.device;
   138.                   Q_operand   : in KDF9.Q_register;
   139.                   set_offline : in Boolean) is
   140.    begin disavow(the_device, Q_operand, set_offline); end POB;
   141.
   142.    overriding
   143.    procedure POC (the_device  : in out absent.device;
   144.                   Q_operand   : in KDF9.Q_register;
   145.                   set_offline : in Boolean) is
   146.    begin disavow(the_device, Q_operand, set_offline); end POC;
   147.
   148.    overriding
   149.    procedure POD (the_device  : in out absent.device;
   150.                   Q_operand   : in KDF9.Q_register;
   151.                   set_offline : in Boolean) is
   152.    begin disavow(the_device, Q_operand, set_offline); end POD;
   153.
   154.    overriding
   155.    procedure POE (the_device  : in out absent.device;
   156.                   Q_operand   : in KDF9.Q_register;
   157.                   set_offline : in Boolean) is
   158.    begin disavow(the_device, Q_operand, set_offline); end POE;
   159.
   160.    overriding
   161.    procedure POF (the_device  : in out absent.device;
   162.                   Q_operand   : in KDF9.Q_register;
   163.                   set_offline : in Boolean) is
   164.    begin disavow(the_device, Q_operand, set_offline); end POF;
   165.
   166.    overriding
   167.    procedure POG (the_device  : in out absent.device;
   168.                   Q_operand   : in KDF9.Q_register;
   169.                   set_offline : in Boolean) is
   170.    begin disavow(the_device, Q_operand, set_offline); end POG;
   171.
   172.    overriding
   173.    procedure POH (the_device  : in out absent.device;
   174.                   Q_operand   : in KDF9.Q_register;
   175.                   set_offline : in Boolean) is
   176.    begin disavow(the_device, Q_operand, set_offline); end POH;
   177.
   178.    overriding
   179.    procedure POK (the_device  : in out absent.device;
   180.                   Q_operand   : in KDF9.Q_register;
   181.                   set_offline : in Boolean) is
   182.    begin disavow(the_device, Q_operand, set_offline); end POK;
   183.
   184.    overriding
   185.    procedure POL (the_device  : in out absent.device;
   186.                   Q_operand   : in KDF9.Q_register;
   187.                   set_offline : in Boolean) is
   188.    begin disavow(the_device, Q_operand, set_offline); end POL;
   189.
   190.    overriding
   191.    procedure Initialize (the_device : in out absent.device) is
   192.    begin
   193.       install(the_device);
   194.    end Initialize;
   195.
   196.    type AD_access is access absent.device;
   197.    AD_list : array (IOC.unit_number range 0..14) of AD_access with Warnings => Off;
   198.
   199.     -- This cannot overflow, because there must be at least 2 non-AD buffers: FW0 and TR0.
   200.    unit : IOC.unit_number := 0;
   201.
   202.    procedure enable (b : in KDF9.buffer_number) is
   203.    begin
   204.       AD_list(unit) := new absent.device(number => b, unit => unit);
   205.        unit := unit + 1;
   206.    end enable;
   207.
   208. end IOC.absent;
   209.

Compiling: ../Source/ioc-absent.ads
Source file time stamp: 2021-02-16 23:12:16
Compiled at: 2021-02-21 15:54:07

     1. -- Handle attempted usage of a buffer with No Device attached.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.absent is
    18.
    19.    type device is new IOC.device with null record;
    20.
    21.    -- All the operations of an absent device terminate the run.
    22.
    23.    overriding
    24.    procedure PIA (the_device  : in out absent.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    overriding
    29.    procedure PIB (the_device  : in out absent.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    overriding
    34.    procedure PIC (the_device  : in out absent.device;
    35.                   Q_operand   : in KDF9.Q_register;
    36.                   set_offline : in Boolean);
    37.
    38.    overriding
    39.    procedure PID (the_device  : in out absent.device;
    40.                   Q_operand   : in KDF9.Q_register;
    41.                   set_offline : in Boolean);
    42.
    43.    overriding
    44.    procedure PIE (the_device  : in out absent.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    overriding
    49.    procedure PIF (the_device  : in out absent.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    overriding
    54.    procedure PIG (the_device  : in out absent.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    overriding
    59.    procedure PIH (the_device  : in out absent.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    overriding
    64.    procedure PMA (the_device  : in out absent.device;
    65.                   Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    overriding
    69.    procedure PMB (the_device  : in out absent.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean);
    72.
    73.    overriding
    74.    procedure PMC (the_device  : in out absent.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.    overriding
    78.    procedure PMD (the_device  : in out absent.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean);
    81.
    82.    overriding
    83.    procedure PME (the_device  : in out absent.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    overriding
    88.    procedure PMF (the_device  : in out absent.device;
    89.                   Q_operand   : in KDF9.Q_register;
    90.                   set_offline : in Boolean);
    91.
    92.    overriding
    93.    procedure PMG (the_device  : in out absent.device;
    94.                   Q_operand   : in KDF9.Q_register;
    95.                   set_offline : in Boolean);
    96.
    97.    overriding
    98.    procedure PMK (the_device  : in out absent.device;
    99.                   Q_operand   : in KDF9.Q_register;
   100.                   set_offline : in Boolean);
   101.
   102.    overriding
   103.    procedure PML (the_device  : in out absent.device;
   104.                   Q_operand   : in KDF9.Q_register;
   105.                   set_offline : in Boolean);
   106.
   107.    overriding
   108.    procedure POA (the_device  : in out absent.device;
   109.                   Q_operand   : in KDF9.Q_register;
   110.                   set_offline : in Boolean);
   111.
   112.    overriding
   113.    procedure POB (the_device  : in out absent.device;
   114.                   Q_operand   : in KDF9.Q_register;
   115.                   set_offline : in Boolean);
   116.
   117.    overriding
   118.    procedure POC (the_device  : in out absent.device;
   119.                   Q_operand   : in KDF9.Q_register;
   120.                   set_offline : in Boolean);
   121.
   122.    overriding
   123.    procedure POD (the_device  : in out absent.device;
   124.                   Q_operand   : in KDF9.Q_register;
   125.                   set_offline : in Boolean);
   126.
   127.    overriding
   128.    procedure POE (the_device  : in out absent.device;
   129.                   Q_operand   : in KDF9.Q_register;
   130.                   set_offline : in Boolean);
   131.
   132.    overriding
   133.    procedure POF (the_device  : in out absent.device;
   134.                   Q_operand   : in KDF9.Q_register;
   135.                   set_offline : in Boolean);
   136.
   137.    overriding
   138.    procedure POG (the_device  : in out absent.device;
   139.                   Q_operand   : in KDF9.Q_register;
   140.                   set_offline : in Boolean);
   141.
   142.    overriding
   143.    procedure POH (the_device  : in out absent.device;
   144.                   Q_operand   : in KDF9.Q_register;
   145.                   set_offline : in Boolean);
   146.
   147.    overriding
   148.    procedure POK (the_device  : in out absent.device;
   149.                   Q_operand   : in KDF9.Q_register;
   150.                   set_offline : in Boolean);
   151.
   152.    overriding
   153.    procedure POL (the_device  : in out absent.device;
   154.                   Q_operand   : in KDF9.Q_register;
   155.                   set_offline : in Boolean);
   156.
   157.    -- Register the absence of a device in case of future attempted access to buffer b.
   158.    procedure enable (b : in KDF9.buffer_number);
   159.
   160. private
   161.
   162.    overriding
   163.    procedure Initialize (the_device : in out absent.device);
   164.
   165.    overriding
   166.    function is_open (the_device : absent.device)
   167.    return Boolean
   168.    is (False);
   169.
   170.    overriding
   171.    function kind (the_device : absent.device)
   172.    return IOC.device_kind
   173.    is (AD_kind);
   174.
   175.    overriding
   176.    function quantum (the_device : absent.device)
   177.    return KDF9.us
   178.    is (0);
   179.
   180.    overriding
   181.    procedure add_in_the_IO_CPU_time (the_device  : in absent.device;
   182.                                      bytes_moved : in KDF9.word)
   183.    is null;
   184.
   185. end IOC.absent;

 209 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast.adb
Source file time stamp: 2021-02-18 00:56:14
Compiled at: 2021-02-21 15:54:07

     1. -- Emulation of the common functionality of a KDF9 "fast", i.e. word-by-word, devices.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.fast is
    18.
    19.    overriding
    20.    function is_open (the_buffer : fast.device)
    21.    return Boolean
    22.    is (the_buffer.stream.is_open);
    23.
    24.    overriding
    25.    procedure add_in_the_IO_CPU_time (the_buffer  : in fast.device;
    26.                                      bytes_moved : in KDF9.word) is
    27.       pragma Unreferenced(the_buffer);
    28.    begin
    29.       the_CPU_delta := the_CPU_delta + KDF9.us(bytes_moved + 7) / 8 * 6; -- 6s/word
    30.    end add_in_the_IO_CPU_time;
    31.
    32. end IOC.fast;

Compiling: ../Source/ioc-fast.ads
Source file time stamp: 2021-02-13 13:50:50
Compiled at: 2021-02-21 15:54:07

     1. -- Emulation of the common functionality of a KDF9 "fast", i.e. word-by-word, devices.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. private with tracing;
    18.
    19. package IOC.fast is
    20.
    21.    --
    22.    -- This is the root type for all fast I/O device types.
    23.    --
    24.
    25.    type device is abstract new IOC.device with private;
    26.
    27. private
    28.
    29.    use tracing; pragma Warnings(Off, tracing);
    30.
    31.    type device is abstract new IOC.device with
    32.       record
    33.          switch_time,
    34.          latency_time,
    35.          elapsed_time  : KDF9.us := 0;
    36.          word_count,
    37.          switch_count,
    38.          latency_count : KDF9.word := 0;
    39.       end record;
    40.
    41.    overriding
    42.    function is_open (the_buffer : fast.device)
    43.    return Boolean;
    44.
    45.    overriding
    46.    procedure add_in_the_IO_CPU_time (the_buffer  : in fast.device;
    47.                                      bytes_moved : in KDF9.word);
    48.
    49. end IOC.fast;

 32 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-dr.adb
Source file time stamp: 2021-02-19 15:58:28
Compiled at: 2021-02-21 15:54:07

     1. -- Emulation of a drum store.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.fast.DR is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    function as_DR_command (Q_operand : KDF9.Q_register; for_OUT : Boolean := False)
    22.    return String is
    23.       C, sector, track, drive :KDF9.Q_part;
    24.    begin
    25.       if for_OUT then
    26.          -- There is no buffer number.
    27.          C := Q_operand.C;
    28.       else
    29.          -- Get rid of the buffer number.
    30.          C := Q_operand.C / 16;
    31.       end if;
    32.       drive := C mod drums_per_system;
    33.       C := C  /  drums_per_system;
    34.       sector := C mod sectors_per_track;
    35.       track  := C mod sectors_per_drum / sectors_per_track;
    36.       return "D"
    37.            & dec_of(drive)
    38.            & "T"
    39.            & dec_of(track)
    40.            & "S"
    41.            & dec_of(sector);
    42.    end as_DR_command;
    43.
    44.    -- The host_IO stream for DR0 is used only to open and close the file.
    45.    -- I/O operations for the DR0 file are done with unmediated POSIX system calls.
    46.
    47.    function file_offset (sector_number : DR.drum_index)
    48.    return POSIX.file_position
    49.    is (bytes_per_sector * POSIX.file_position(sector_number));
    50.
    51.    procedure get (the_DR : in out DR.device; s : out sector; the_index : in KDF9.word) is
    52.       result : POSIX.file_position with Unreferenced;
    53.    begin
    54.       result := seek(fd_of(the_DR.stream), file_offset(the_index));
    55.       result := POSIX.file_position(read(fd_of(the_DR.stream), s, bytes_per_sector));
    56.    end get;
    57.
    58.    procedure put (the_DR : in out DR.device; s : in sector; the_index : in KDF9.word) is
    59.       result : POSIX.file_position with Unreferenced;
    60.    begin
    61.       result := seek(fd_of(the_DR.stream), file_offset(the_index));
    62.       result := POSIX.file_position(write(fd_of(the_DR.stream), s, bytes_per_sector));
    63.    end put;
    64.
    65.    overriding
    66.    procedure Initialize (the_DR : in out DR.device) is
    67.    begin
    68.       open(IOC.device(the_DR), rd_wr_mode);
    69.    exception
    70.       when others =>
    71.          trap_operator_error(the_DR.device_name & " cannot be opened for reading and writing");
    72.    end Initialize;
    73.
    74.    procedure keep_house (the_DR        : in out DR.device;
    75.                          transfer_size : in KDF9.word;
    76.                          busy_time     : out KDF9.us;
    77.                          from_core     : Boolean := True) is
    78.       full_sectors  : constant KDF9.word := transfer_size / bytes_per_sector;
    79.       residue       : constant KDF9.word := transfer_size mod bytes_per_sector;
    80.       total_sectors : constant KDF9.word := (if residue /= 0 then 1 else 0) + full_sectors;
    81.       gapping_time  : constant KDF9.us   := short_gap_time * KDF9.us(total_sectors-1)
    82.                                           + long_gap_time  * KDF9.us(total_sectors/sectors_per_track);
    83.    begin
    84.       the_DR.latency_count := the_DR.latency_count + 1;
    85.       the_DR.word_count := the_DR.word_count + transfer_size / 8;
    86.       if from_core then
    87.          add_in_the_IO_CPU_time(the_DR, bytes_moved => transfer_size);
    88.       end if;
    89.       busy_time :=  gapping_time + KDF9.us(transfer_size) * the_DR.quantum;
    90.    end keep_house;
    91.
    92.    procedure update_statistics (the_DR       : in out DR.device;
    93.                                 latency_time : in KDF9.us) is
    94.    begin
    95.       the_DR.latency_time := the_DR.latency_time + latency_time;
    96.    end update_statistics;
    97.
    98.    function angular_position (sector_number : sector_range)
    99.    return KDF9.us
   100.    is (KDF9.us(sector_number mod sectors_per_track * sector_time));
   101.
   102.    function latent_time (index : drum_index)
   103.    return KDF9.us is
   104.       sector_number : constant sector_range := sector_range(index mod sectors_per_track);
   105.       new_angle     : constant KDF9.us      := angular_position(sector_number);
   106.       old_angle     : constant KDF9.us      := the_clock_time mod track_time;
   107.       gap_time      : constant KDF9.us
   108.                     := (if old_angle > critical_time then short_gap_time else long_gap_time);
   109.       offset        : constant KDF9.us
   110.                     := (if   new_angle > old_angle
   111.                         then new_angle - old_angle
   112.                         else new_angle + track_time - old_angle);
   113.    begin
   114.       -- Hypothesis: we can pick up the next complete sector without a full latency delay,
   115.       --    if we are no closer to it than the start of its preceding inter-block gap.
   116.       return (if offset > gap_time then offset else track_time - offset);
   117.    end latent_time;
   118.
   119.    procedure validate_the_sector_number (the_DR : in out DR.device; sector_number : in KDF9.word) is
   120.    begin
   121.       if sector_number > sectors_per_system then
   122.          trap_failing_IO_operation(the_DR, "sector number too big =" & sector_number'Image);
   123.       end if;
   124.    end validate_the_sector_number;
   125.
   126.    function validated_drum_address (the_DR : in out DR.device; C_operand : KDF9.Q_part)
   127.    return KDF9.word is
   128.       result : constant KDF9.word := KDF9.word(C_operand / 16);
   129.    begin
   130.       -- We assume that the least significant 4 bits of the C operand are the buffer number,
   131.       --    that the next 2 bits specify one of 4 drums that can be fitted to the buffer,
   132.       --       and that the rest of the C operand is the sector number.
   133.       -- See the Drum Director KKT02E003UPU listing, routine P143 at label 1 et seq.
   134.       -- Returning C_operand / 16 treats the drums as consecutive sectors.
   135.       validate_the_sector_number(the_DR, result);
   136.       return result;
   137.    end validated_drum_address;
   138.
   139.    procedure increment (word_address : in out KDF9.address;
   140.                         symbol_nr    : in out KDF9_char_sets.symbol_index)
   141.       with Inline => True;
   142.
   143.    procedure increment (word_address : in out KDF9.address;
   144.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   145.    begin
   146.       if symbol_nr < 7 then
   147.          symbol_nr := symbol_nr + 1;
   148.       else
   149.          symbol_nr := 0;
   150.          word_address := word_address + 1;
   151.       end if;
   152.    end increment;
   153.
   154.    procedure read_drum (the_DR    : in out DR.device;
   155.                         Q_operand : in KDF9.Q_register) is
   156.       end_address  : constant KDF9.address := Q_operand.M;
   157.       next_address : KDF9.address := Q_operand.I;
   158.       the_sector   : DR.sector := (others => Character'Val(0));
   159.       symbol_nr    : KDF9_char_sets.symbol_index;
   160.       size         : KDF9.word := 0;
   161.       the_index    : KDF9.word;
   162.       latency,
   163.       busy_time    : KDF9.us;
   164.    begin
   165.       check_addresses_and_lockouts(next_address, end_address);
   166.       the_index := validated_drum_address(the_DR, Q_operand.C);
   167.       latency := latent_time(the_index);
   168.       get(the_DR, the_sector, the_index);
   169.    sector_loop:
   170.       loop
   171.          if the_index > DR.drum_index'Last then
   172.             trap_failing_IO_operation(the_DR, "reading more would exceed the storage available");
   173.          end if;
   174.          symbol_nr := 0;
   175.       byte_loop:
   176.          for i in 1 .. bytes_per_sector loop
   177.             if symbol_nr = 0 then
   178.                store_word(0, next_address);
   179.             end if;
   180.             store_symbol(CN_TR(the_sector(i)), next_address, symbol_nr);
   181.             size := size + 1;
   182.          exit byte_loop when next_address = end_address and symbol_nr = 7;
   183.             increment(next_address, symbol_nr);
   184.          end loop byte_loop;
   185.       exit sector_loop when next_address = end_address and symbol_nr = 7;
   186.          validate_the_sector_number(the_DR, the_index);
   187.          get(the_DR, the_sector, the_index);
   188.          the_index := the_index + 1;
   189.       end loop sector_loop;
   190.       keep_house(the_DR, size, busy_time);
   191.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, input_operation);
   192.       update_statistics(the_DR, latency);
   193.       lock_out_relative_addresses(Q_operand);
   194.    end read_drum;
   195.
   196.    overriding
   197.    procedure PIA (the_DR      : in out DR.device;
   198.                   Q_operand   : in KDF9.Q_register;
   199.                   set_offline : in Boolean) is
   200.       pragma Unreferenced(set_offline);
   201.    begin
   202.       validate_transfer(the_DR, Q_operand);
   203.       validate_parity(the_DR);
   204.       read_drum(the_DR, Q_operand);
   205.    end PIA;
   206.
   207.    procedure read_drum_to_EM (the_DR    : in out DR.device;
   208.                               Q_operand : in KDF9.Q_register) is
   209.       end_address  : constant KDF9.address := Q_operand.M;
   210.       next_address : KDF9.address := Q_operand.I;
   211.       the_sector   : DR.sector := (others => Character'Val(0));
   212.       at_EM     : Boolean := False;
   213.       symbol_nr : KDF9_char_sets.symbol_index;
   214.       size      : KDF9.word := 0;
   215.       the_index : KDF9.word;
   216.       latency,
   217.       busy_time : KDF9.us;
   218.    begin
   219.       check_addresses_and_lockouts(next_address, end_address);
   220.       the_index := validated_drum_address(the_DR, Q_operand.C);
   221.       latency := latent_time(the_index);
   222.       get(the_DR, the_sector, the_index);
   223.    sector_loop:
   224.       loop
   225.          if the_index > DR.drum_index'Last then
   226.             trap_failing_IO_operation(the_DR, "reading more would exceed the storage available");
   227.          end if;
   228.          symbol_nr := 0;
   229.       byte_loop:
   230.          for i in 1 .. bytes_per_sector loop
   231.             if symbol_nr = 0 then
   232.                store_word(0, next_address);
   233.             end if;
   234.             store_symbol(CN_TR(the_sector(i)), next_address, symbol_nr);
   235.             size := size + 1;
   236.          at_EM := the_sector(i) = KDF9_char_sets.E_M;
   237.          exit byte_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   238.             increment(next_address, symbol_nr);
   239.          end loop byte_loop;
   240.          exit sector_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   241.          validate_the_sector_number(the_DR, the_index);
   242.          get(the_DR, the_sector, the_index);
   243.          the_index := the_index + 1;
   244.       end loop sector_loop;
   245.       keep_house(the_DR, size, busy_time);
   246.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, input_operation);
   247.       lock_out_relative_addresses(Q_operand);
   248.       update_statistics(the_DR, latency);
   249.    end read_drum_to_EM;
   250.
   251.    overriding
   252.    procedure PIB (the_DR      : in out DR.device;
   253.                   Q_operand   : in KDF9.Q_register;
   254.                   set_offline : in Boolean) is
   255.        pragma Unreferenced(set_offline);
   256.   begin
   257.       validate_transfer(the_DR, Q_operand);
   258.       validate_parity(the_DR);
   259.       read_drum_to_EM(the_DR, Q_operand);
   260.    end PIB;
   261.
   262.    overriding
   263.    procedure PIC (the_DR      : in out DR.device;
   264.                   Q_operand   : in KDF9.Q_register;
   265.                   set_offline : in Boolean) is
   266.    begin
   267.       PIA(the_DR, Q_operand, set_offline);
   268.    end PIC;
   269.
   270.    overriding
   271.    procedure PID (the_DR      : in out DR.device;
   272.                   Q_operand   : in KDF9.Q_register;
   273.                   set_offline : in Boolean) is
   274.    begin
   275.       PIB(the_DR, Q_operand, set_offline);
   276.    end PID;
   277.
   278.    overriding
   279.    procedure PIE (the_DR      : in out DR.device;
   280.                   Q_operand   : in KDF9.Q_register;
   281.                   set_offline : in Boolean) is
   282.    begin
   283.       PIA(the_DR, Q_operand, set_offline);
   284.    end PIE;
   285.
   286.    overriding
   287.    procedure PIF (the_DR      : in out DR.device;
   288.                   Q_operand   : in KDF9.Q_register;
   289.                   set_offline : in Boolean) is
   290.    begin
   291.       PIB(the_DR, Q_operand, set_offline);
   292.    end PIF;
   293.
   294.    overriding
   295.    procedure PIG (the_DR      : in out DR.device;
   296.                   Q_operand   : in KDF9.Q_register;
   297.                   set_offline : in Boolean) is
   298.    begin
   299.       PIA(the_DR, Q_operand, set_offline);
   300.    end PIG;
   301.
   302.    overriding
   303.    procedure PIH (the_DR      : in out DR.device;
   304.                   Q_operand   : in KDF9.Q_register;
   305.                   set_offline : in Boolean) is
   306.    begin
   307.       PIB(the_DR, Q_operand, set_offline);
   308.    end PIH;
   309.
   310.    procedure write_drum (the_DR    : in out DR.device;
   311.                          Q_operand : in KDF9.Q_register) is
   312.       end_address  : constant KDF9.address := Q_operand.M;
   313.       next_address : KDF9.address := Q_operand.I;
   314.       the_sector   : DR.sector := (others => Character'Val(0));
   315.       symbol_nr : KDF9_char_sets.symbol_index;
   316.       size      : KDF9.word := 0;
   317.       the_index : KDF9.word;
   318.       latency,
   319.       busy_time : KDF9.us;
   320.    begin
   321.       check_addresses_and_lockouts(next_address, end_address);
   322.       the_index := validated_drum_address(the_DR, Q_operand.C);
   323.       latency := latent_time(the_index);
   324.    sector_loop:
   325.       loop
   326.          symbol_nr := 0;
   327.       byte_loop:
   328.          for i in 1 .. bytes_per_sector loop
   329.             the_sector(i) := TP_CN(fetch_symbol(next_address, symbol_nr));
   330.             size := size + 1;
   331.          exit byte_loop when next_address = end_address and symbol_nr = 7;
   332.             increment(next_address, symbol_nr);
   333.          end loop byte_loop;
   334.          validate_the_sector_number(the_DR, the_index);
   335.          put(the_DR, the_sector, the_index);
   336.       exit sector_loop when next_address = end_address and symbol_nr = 7;
   337.          if the_index = DR.drum_index'Last then
   338.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   339.          else
   340.             the_index := the_index + 1;
   341.          end if;
   342.       end loop sector_loop;
   343.       keep_house(the_DR, size, busy_time);
   344.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   345.       lock_out_relative_addresses(Q_operand);
   346.       update_statistics(the_DR, latency);
   347.    end write_drum;
   348.
   349.    overriding
   350.    procedure POA (the_DR      : in out DR.device;
   351.                   Q_operand   : in KDF9.Q_register;
   352.                   set_offline : in Boolean) is
   353.       pragma Unreferenced(set_offline);
   354.    begin
   355.       validate_transfer(the_DR, Q_operand);
   356.       validate_parity(the_DR);
   357.       write_drum(the_DR, Q_operand);
   358.    end POA;
   359.
   360.    procedure write_drum_to_EM (the_DR    : in out DR.device;
   361.                                Q_operand : in KDF9.Q_register) is
   362.       end_address  : constant KDF9.address := Q_operand.M;
   363.       next_address : KDF9.address := Q_operand.I;
   364.       the_sector   : DR.sector := (others => Character'Val(0));
   365.       at_EM     : Boolean := False;
   366.       size      : KDF9.word := 0;
   367.       symbol_nr : KDF9_char_sets.symbol_index;
   368.       the_index : KDF9.word;
   369.       latency,
   370.       busy_time : KDF9.us;
   371.    begin
   372.       check_addresses_and_lockouts(next_address, end_address);
   373.       the_index := validated_drum_address(the_DR, Q_operand.C);
   374.       latency := latent_time(the_index);
   375.    sector_loop:
   376.       loop
   377.          if the_index > DR.drum_index'Last then
   378.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   379.          end if;
   380.          symbol_nr := 0;
   381.       byte_loop:
   382.          for i in 1 .. bytes_per_sector loop
   383.             the_sector(i) := TP_CN(fetch_symbol(next_address, symbol_nr));
   384.             size := size + 1;
   385.          at_EM := the_sector(i) = KDF9_char_sets.E_M;
   386.          exit byte_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   387.             increment(next_address, symbol_nr);
   388.          end loop byte_loop;
   389.          validate_the_sector_number(the_DR, the_index);
   390.          put(the_DR, the_sector, the_index);
   391.          exit sector_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   392.          the_index := the_index + 1;
   393.       end loop sector_loop;
   394.       keep_house(the_DR, size, busy_time);
   395.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   396.       lock_out_relative_addresses(Q_operand);
   397.       update_statistics(the_DR, latency);
   398.    end write_drum_to_EM;
   399.
   400.    overriding
   401.    procedure POB (the_DR      : in out DR.device;
   402.                   Q_operand   : in KDF9.Q_register;
   403.                   set_offline : in Boolean) is
   404.       pragma Unreferenced(set_offline);
   405.    begin
   406.       validate_transfer(the_DR, Q_operand);
   407.       validate_parity(the_DR);
   408.       write_drum_to_EM(the_DR, Q_operand);
   409.    end POB;
   410.
   411.    overriding
   412.    procedure POC (the_DR      : in out DR.device;
   413.                   Q_operand   : in KDF9.Q_register;
   414.                   set_offline : in Boolean) is
   415.    begin
   416.       POA(the_DR, Q_operand, Set_offline);
   417.    end POC;
   418.
   419.    overriding
   420.    procedure POD (the_DR      : in out DR.device;
   421.                   Q_operand   : in KDF9.Q_register;
   422.                   set_offline : in Boolean) is
   423.    begin
   424.       POB(the_DR, Q_operand, Set_offline);
   425.    end POD;
   426.
   427.    procedure write_zeroes (the_DR      : in out DR.device;
   428.                            Q_operand   : in KDF9.Q_register;
   429.                            set_offline : in Boolean) is
   430.       pragma Unreferenced(set_offline);
   431.       start_address : constant KDF9.address := Q_operand.I;
   432.       end_address   : constant KDF9.address := Q_operand.M;
   433.       the_sector    : constant DR.sector := (others => Character'Val(0));
   434.       size      : KDF9.word := 0;
   435.       the_index : KDF9.word;
   436.       latency,
   437.       busy_time : KDF9.us;
   438.    begin
   439.       check_addresses_and_lockouts(start_address, end_address);
   440.       the_index := validated_drum_address(the_DR, Q_operand.C);
   441.       latency := latent_time(the_index);
   442.       for s in 1 .. (KDF9.word(end_address) - KDF9.word(start_address) + 128) / 128 loop
   443.          if the_index > DR.drum_index'Last then
   444.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   445.          end if;
   446.          validate_the_sector_number(the_DR, the_index);
   447.          put(the_DR, the_sector, the_index);
   448.          size := size + bytes_per_sector;
   449.          the_index := the_index + 1;
   450.       end loop;
   451.       keep_house(the_DR, size, busy_time, from_core => False);
   452.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   453.       lock_out_relative_addresses(Q_operand);
   454.       update_statistics(the_DR, latency);
   455.    end write_zeroes;
   456.
   457.    overriding
   458.    procedure POE (the_DR      : in out DR.device;
   459.                   Q_operand   : in KDF9.Q_register;
   460.                   set_offline : in Boolean) is
   461.    begin
   462.       validate_transfer(the_DR, Q_operand);
   463.       write_zeroes(the_DR, Q_operand, set_offline);
   464.    end POE;
   465.
   466.    overriding
   467.    procedure POF (the_DR      : in out DR.device;
   468.                   Q_operand   : in KDF9.Q_register;
   469.                   set_offline : in Boolean) is
   470.    begin
   471.       POE(the_DR, Q_operand, Set_offline);
   472.    end POF;
   473.
   474.    overriding
   475.    procedure Finalize (the_DR : in out DR.device) is
   476.       transfer_time : constant KDF9.us := KDF9.us(the_DR.word_count) * 8 * the_DR.quantum;
   477.    begin
   478.       if the_DR.is_open then
   479.
   480.          if (the_final_state_is_wanted and the_log_is_wanted)    and then
   481.                (the_DR.word_count /= 0 or the_DR.latency_count /= 0) then
   482.             log_line
   483.                 (
   484.                  the_DR.device_name
   485.                & " on buffer #"
   486.                & oct_of(KDF9.Q_part(the_DR.number), 2)
   487.                & " spent:"
   488.                 );
   489.             log_line
   490.                 (
   491.                  "    "
   492.                & just_right(KDF9.us'Image(transfer_time / 1_000), 6)
   493.                & " ms in"
   494.                & the_DR.latency_count'Image
   495.                & " data transfer" & plurality(the_DR.latency_count)
   496.                & " totalling"
   497.                & KDF9.word'Image(the_DR.word_count)
   498.                & " word" & plurality(the_DR.word_count)
   499.                & ", and"
   500.                 );
   501.             log_line
   502.                 (
   503.                  "    "
   504.                & just_right(KDF9.us'Image(the_DR.latency_time / 1_000), 6)
   505.                & " ms in"
   506.                & the_DR.latency_count'Image
   507.                & " rotational latenc" & plurality(the_DR.latency_count, "y.", "ies.")
   508.                 );
   509.          end if;
   510.
   511.          close(IOC.device(the_DR));
   512.       end if;
   513.    end Finalize;
   514.
   515.    type DR_access is access DR.device;
   516.
   517.    DR0 : DR_access with Warnings => Off;
   518.
   519.    procedure enable (b : in KDF9.buffer_number) is
   520.    begin
   521.       if DR0_is_enabled then
   522.          trap_operator_error("more than one DR control unit has been configured");
   523.       end if;
   524.       DR0 := new DR.device (number => b, unit => 0);
   525.       DR0_is_enabled := True;
   526.       DR0_number := b;
   527.    end enable;
   528.
   529.    procedure replace_on_buffer (b : in KDF9.buffer_number) is
   530.    begin
   531.       if DR0_is_enabled and then
   532.             b = DR0.number  then
   533.          return;
   534.       end if;
   535.       buffer(b) := null;
   536.       enable(b);
   537.    end replace_on_buffer;
   538.
   539.    procedure remove_from_buffer (b : in KDF9.buffer_number) is
   540.    begin
   541.       if DR0_is_enabled and DR0_number = b then
   542.          buffer(b) := null;
   543.          DR0_is_enabled := False;
   544.       end if;
   545.    end remove_from_buffer;
   546.
   547. end IOC.fast.DR;

Compiling: ../Source/ioc-fast-dr.ads
Source file time stamp: 2021-02-15 01:20:43
Compiled at: 2021-02-21 15:54:07

     1. -- Emulation of a drum store buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.DR is
    18.
    19.    type device is new fast.device with private;
    20.
    21.    overriding
    22.    procedure PIA (the_DR      : in out DR.device;
    23.                   Q_operand   : in KDF9.Q_register;
    24.                   set_offline : in Boolean);
    25.
    26.    overriding
    27.    procedure PIB (the_DR      : in out DR.device;
    28.                   Q_operand   : in KDF9.Q_register;
    29.                   set_offline : in Boolean);
    30.
    31.    overriding
    32.    procedure PIC (the_DR      : in out DR.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    overriding
    37.    procedure PID (the_DR      : in out DR.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    overriding
    42.    procedure PIE (the_DR      : in out DR.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    overriding
    47.    procedure PIF (the_DR      : in out DR.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    overriding
    52.    procedure PIG (the_DR      : in out DR.device;
    53.                   Q_operand   : in KDF9.Q_register;
    54.                   set_offline : in Boolean);
    55.
    56.    overriding
    57.    procedure PIH (the_DR      : in out DR.device;
    58.                   Q_operand   : in KDF9.Q_register;
    59.                   set_offline : in Boolean);
    60.
    61. -- PMA-PML, and POG-POL are inherited, as they have no new semantics for the drum.
    62.
    63.    overriding
    64.    procedure POA (the_DR      : in out DR.device;
    65.                   Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    overriding
    69.    procedure POB (the_DR      : in out DR.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean);
    72.
    73.    overriding
    74.    procedure POC (the_DR      : in out DR.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.    overriding
    78.    procedure POD (the_DR      : in out DR.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean);
    81.
    82.    overriding
    83.    procedure POE (the_DR      : in out DR.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    overriding
    88.    procedure POF (the_DR      : in out DR.device;
    89.                   Q_operand   : in KDF9.Q_register;
    90.                   set_offline : in Boolean);
    91.
    92.    procedure enable (b : in KDF9.buffer_number);
    93.
    94.    procedure replace_on_buffer (b : in KDF9.buffer_number);
    95.
    96.    procedure remove_from_buffer (b : in KDF9.buffer_number);
    97.
    98.    DR0_is_enabled : Boolean := False;
    99.
   100.    function as_DR_command (Q_operand : KDF9.Q_register; for_OUT : Boolean := False)
   101.    return String;
   102.
   103. private
   104.
   105.    -- For what little we know from EE of the drum geometry, see the Manual, App. 6, 4.
   106.    -- An additional and more helpful source is the SRLM, 103, Appendix 2, p.10-59-0,
   107.    --   which describes the drum used with the non-Time Sharing Director.
   108.    -- It says:
   109.    --   Drum revolution time     = 20.4   ms
   110.    --   Transfer time per sector =  2.15  ms
   111.    --   Short gap time           =  0.034 ms between successive sectors
   112.    --   Long gap time            =  2.97  ms after every 8th sector
   113.    -- Hence: Mean time per sector = revolution time/8 - short gap time - long gap time/8
   114.    --                             = 20.4 ms / 8       - 0.034          - 2.970 / 8
   115.    --                             = 2.145 ms, rounding correctly to 2.15 ms
   116.    -- This confirms 8 sectors per track, or 8192 characters per track, for 40 tracks per drum.
   117.
   118.    bytes_per_sector   : constant := 1024;
   119.    subtype byte_range is KDF9.word range 0 .. bytes_per_sector - 1;
   120.    subtype sector     is String(1..bytes_per_sector);
   121.
   122.    sectors_per_track  : constant := 8;
   123.    subtype sector_range is KDF9.word range 0 .. sectors_per_track - 1;
   124.
   125.    sectors_per_drum   : constant := 320;
   126.    drums_per_system   : constant := 4;
   127.    sectors_per_system : constant := sectors_per_drum * drums_per_system;
   128.    subtype drum_index is KDF9.word range 0 .. sectors_per_system - 1;
   129.
   130.    tracks_per_system   : constant := sectors_per_system / sectors_per_track;
   131.    subtype track_range is KDF9.word range 0 .. tracks_per_system - 1;
   132.
   133.    data_rate      : constant := 477_445;         -- chars/s
   134.    us_per_char    : constant := 1E6 / data_rate; -- ~2.1 s/char
   135.
   136.    -- The following times are in microseconds.
   137.    short_gap_time : constant := 34;
   138.    sector_time    : constant := bytes_per_sector * us_per_char + short_gap_time;
   139.    long_gap_time  : constant := 2_970;
   140.    track_time     : constant := sector_time * sectors_per_track + long_gap_time;
   141.    critical_time  : constant := sector_time * (sectors_per_track-1) - short_gap_time;
   142.
   143.    type drum is array (drum_index) of DR.sector;
   144.
   145.    type device is new fast.device with null record;
   146.
   147.    overriding
   148.    procedure Initialize (the_DR : in out DR.device);
   149.
   150.    overriding
   151.    procedure Finalize (the_DR : in out DR.device);
   152.
   153.    overriding
   154.    function kind (the_DR : DR.device)
   155.    return IOC.device_kind
   156.    is (DR_kind);
   157.
   158.    overriding
   159.    function quantum (the_DR : DR.device)
   160.    return KDF9.us
   161.    is (us_per_char);
   162.
   163.    DR0_number : KDF9.buffer_number := 0;
   164.
   165. end IOC.fast.DR;

 547 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-fd.adb
Source file time stamp: 2021-02-21 19:17:16
Compiled at: 2021-02-21 15:54:07

     1. -- Emulation of a fixed disc drive.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.fast.FD is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    function as_FD_command (Q_operand : KDF9.Q_register; for_seek, for_FH : Boolean := False)
    22.    return String is
    23.       parameter : constant KDF9.Q_part := Q_operand.C / 16;
    24.       cylinder  : constant KDF9.Q_part := parameter mod seek_areas_per_platter;
    25.       residue   : constant KDF9.Q_part := parameter  /  seek_areas_per_platter;
    26.       platter   : constant KDF9.Q_part := residue mod main_discs_per_drive;
    27.       drive     : constant KDF9.Q_part := residue  /  main_discs_per_drive;
    28.    begin
    29.       -- The disc geometry and I/O command bits are as defined in the FD package.
    30.       if for_seek then
    31.          return "D" & dec_of(drive)
    32.               & "P" & dec_of(if for_FH then KDF9.Q_part'(the_fixed_head_platter) else platter)
    33.               & "C" & dec_of(cylinder);
    34.       else -- for data transfer, parameter is sector #, with maximum 96 sectors per track.
    35.          return " S" & (if parameter < 10 then "0" else "") & dec_of(parameter);
    36.       end if;
    37.    end as_FD_command;
    38.
    39.    overriding
    40.    procedure Initialize (the_FD : in out FD.device) is
    41.    begin
    42.       open(the_FD, rd_wr_mode);
    43.    exception
    44.       when others =>
    45.          trap_operator_error(the_FD.device_name & " cannot be opened for reading and writing");
    46.    end Initialize;
    47.
    48.    -- Hypothesis:
    49.    -- Where a specification of the Fixed Disc subsystem cannot be inferred from extant software,
    50.    -- such as the Eldon 2 Director, or the EE KDF9 Programming Manual,
    51.    -- then it is reasonable to extrapolate from the Data Products Corporation documents:
    52.    --    "SPECIFICATION FOR MODEL 5022 DISCfILE STORAGE SYSTEM", of December 1964, and
    53.    --    "GENERAL INFORMATION MANUAL dp/f-5022 DISCfILE STORAGE SYSTEM", of March 1965,
    54.    -- which describe an (at least) very similar model.
    55.    -- These document are referred to herein as "GIM".
    56.    -- Confirmation of much of this material has been gained from the ICT document:
    57.    --    "Data Disc Store 1956", of September 1964",
    58.    -- which describes the same device, offered as a fixed disc drive for the 1900 Series.
    59.    -- All three depict the drive as having a different division of tracks into sectors.
    60.
    61.    -- Hypothesis:
    62.    -- The locus is set by a PMA or PMD operation; the sector number is updated by a transfer.
    63.
    64.    -- Hypothesis:
    65.    -- A PMA or PMD command sets the sector number to 0.
    66.
    67.    -- Hypothesis:
    68.    -- If a transfer would increase the sector number past 95, the end-of-area flag is set,
    69.    --    and the sector number is set to 95.
    70.
    71.    function locus_from (Q_operand : KDF9.Q_register)
    72.    return FD.locus is
    73.       parameter : constant KDF9.Q_part := Q_operand.C / 16; -- remove the buffer number
    74.       seek_area : constant KDF9.Q_part := parameter mod seek_areas_per_platter;
    75.       platter   : constant KDF9.Q_part
    76.                 := parameter / seek_areas_per_platter mod platters_per_drive;
    77.       drive     : constant KDF9.Q_part
    78.                 := parameter / seek_areas_per_platter / platters_per_drive;
    79.    begin
    80.       -- Hypothesis:
    81.       -- Seeking to a new locus zeroizes the sector number and clears the end-of-area flag.
    82.       return (
    83.               drive_number      => drive,
    84.               platter_number    => platter,
    85.               seek_area_number  => seek_area,
    86.               sector_number     => 0,
    87.               has_fixed_heads   => False,
    88.               is_at_end_of_area => False
    89.              );
    90.    end locus_from;
    91.
    92.    function sector_span (Q_operand : KDF9.Q_register)
    93.    return KDF9.Q_part
    94.    is ((Q_operand.M - Q_operand.I + words_per_sector - 1) / words_per_sector);
    95.
    96.    procedure advance_the_sector_number (the_FD : in out FD.device) is
    97.    begin
    98.       if the_FD.locus.sector_number = FD.sector_range'Last then
    99.          the_FD.locus.is_at_end_of_area := True;
   100.       else
   101.          the_FD.locus.is_at_end_of_area := False;
   102.          the_FD.locus.sector_number := the_FD.locus.sector_number + 1;
   103.       end if;
   104.    end advance_the_sector_number;
   105.
   106.    procedure set_the_new_sector_number (the_FD    : in out FD.device;
   107.                                     Q_operand : in KDF9.Q_register) is
   108.       the_sector_number : constant KDF9.Q_part := (Q_operand.C / 16) and 8#177#;
   109.    begin
   110.       if the_sector_number in FD.sector_range then
   111.          the_FD.locus.is_at_end_of_area := False;
   112.          the_FD.locus.sector_number := the_sector_number;
   113.       else
   114.          the_FD.locus.is_at_end_of_area := True;
   115.          the_FD.locus.sector_number := FD.sector_range'Last;
   116.       end if;
   117.    end set_the_new_sector_number;
   118.
   119.    sectors_per_platter : constant := sectors_per_seek_area * seek_areas_per_platter;
   120.    sectors_per_drive   : constant := platters_per_drive  * sectors_per_platter;
   121.
   122.    function file_offset (locus : FD.locus)
   123.    return POSIX.file_position
   124.    is (
   125.        bytes_per_sector *
   126.                         ( POSIX.file_position(locus.drive_number)     * sectors_per_drive
   127.                         + POSIX.file_position(locus.platter_number)   * sectors_per_platter
   128.                         + POSIX.file_position(locus.seek_area_number) * sectors_per_seek_area
   129.                         + POSIX.file_position(locus.sector_number)    * 1
   130.                         )
   131.       );
   132.
   133.    function disc_busy_time (first : FD.sector_range; size : KDF9.word)
   134.    return KDF9.us is
   135.
   136.       function ceiling (first : FD.sector_range; size : KDF9.word)
   137.       return FD.sector_range is
   138.          length : constant KDF9.Q_part := sector_span((0, 1, KDF9.Q_part(size)));
   139.       begin
   140.          return FD.sector_range'Min(first + length - 1, FD.sector_range'Last);
   141.       end ceiling;
   142.
   143.       function time_for (bytes : KDF9.word; in_outer_zone : Boolean)
   144.       return KDF9.word
   145.       is (1E6 * bytes / (if in_outer_zone then outer_rate else inner_rate));
   146.
   147.       boundary   : constant := sectors_per_seek_area / 3 * 2;
   148.       last       : constant FD.sector_range := ceiling(first, size);
   149.       bytes_left : KDF9.word := size * 8;
   150.       total_time : KDF9.word := 0;
   151.
   152.    begin
   153.       for s in first .. last loop
   154.       exit when bytes_left < bytes_per_sector;
   155.          total_time := total_time + time_for(bytes_per_sector, in_outer_zone => s < boundary);
   156.          bytes_left := bytes_left - bytes_per_sector;
   157.       end loop;
   158.       if bytes_left /= 0 then
   159.          total_time := total_time + time_for(bytes_left, in_outer_zone => last < boundary);
   160.       end if;
   161.       return KDF9.us(total_time);
   162.    end disc_busy_time;
   163.
   164.    -- The rotational position of the disc is measured in term of the time,
   165.    --    in microseconds, taken to get to that position from sector 0.
   166.
   167.    rotation_time : constant := 60E3;  -- 1000 RPM => 60 ms = 60_000 KDF9.us
   168.    track_size    : constant := 16;    -- There are only 8 sectors per track in the inner zone.
   169.    sector_time   : constant := rotation_time / track_size;
   170.
   171.    function angular_position (sector_number : FD.sector_range)
   172.    return KDF9.us
   173.    is (-- This is <= rotation_time.
   174.        if sector_number < sectors_in_outer_zone then
   175.           KDF9.us(sector_number * sector_time)
   176.        else
   177.           -- Inner zone sectors are twice as long as in the outer zone.
   178.           -- Assumes (without evidence) that the inner zone is offset 1/2 sector from the outer.
   179.           KDF9.us((sector_number - sectors_in_outer_zone) * sector_time * 2 - sector_time/2)
   180.       );
   181.
   182.    function latent_time (the_FD : FD.device; latency_start_time : in KDF9.us)
   183.    return KDF9.us is
   184.       new_angle  : constant KDF9.us := angular_position(the_FD.locus.sector_number);
   185.       old_angle  : constant KDF9.us := latency_start_time mod rotation_time;
   186.       offset     : constant KDF9.us
   187.                  := (if   new_angle > old_angle
   188.                      then new_angle - old_angle
   189.                      else new_angle + rotation_time - old_angle);
   190.    begin
   191.       -- According to GIM, the minimum latency is one sector;
   192.       --    if less we have to go all the way around.
   193.       return (if offset > sector_time then offset else rotation_time - offset );
   194.    end latent_time;
   195.
   196.    -- These times come from the Manual, 6.1, and from GIM.
   197.    checking_time  : constant :=   47E3;
   198.    min_seek_time  : constant :=  109E3;
   199.    max_seek_time  : constant :=  321E3;
   200.    per_track_time : constant KDF9.us
   201.                   := KDF9.us(max_seek_time - min_seek_time) / seek_areas_per_platter;
   202.
   203.    -- A seek distance of 1 takes the minimum seek time: zero_seek_time + per_track_time.
   204.    zero_seek_time : constant KDF9.us := min_seek_time - per_track_time;
   205.
   206.    subtype seek_time_range is KDF9.us range 0 .. max_seek_time + checking_time;
   207.
   208.    function arm_seek_time (the_FD : FD.device)
   209.    return seek_time_range is
   210.       next   : FD.locus renames the_FD.target;
   211.       drive  : FD.drive_range renames next.drive_number;
   212.       here   : constant FD.seek_area_range := the_FD.comb(drive, next.platter_number);
   213.       there  : constant FD.seek_area_range := next.seek_area_number;
   214.       span   : constant FD.seek_area_range := (if here > there then here - there else there - here);
   215.       cost   : constant KDF9.us := KDF9.us(span) * per_track_time;
   216.    begin
   217.       if cost > 0 and next.platter_number /= the_fixed_head_platter then
   218.          -- Hypothesis:
   219.          return KDF9.us'Min(zero_seek_time + cost, max_seek_time) + checking_time;
   220.       else
   221.          -- Hypothesis:
   222.          -- A seek to the present position takes no time.
   223.          return 0;
   224.       end if;
   225.    end arm_seek_time;
   226.
   227.    -- These times come from GIM.
   228.    -- A switch to a different platter takes 26 ms on average, as specified in GIM.
   229.    -- This time is needed to power-down then power-up the arm actuators for the R/W heads.
   230.    drive_switch_time : constant :=  5_000;
   231.    arm_switch_time   : constant := 26_000;
   232.
   233.    function platter_switch_time (the_FD : FD.device)
   234.    return KDF9.us is
   235.       the_drive_time : KDF9.us;
   236.    begin
   237.       if the_FD.target.drive_number /= the_FD.locus.drive_number then
   238.          the_drive_time := drive_switch_time;
   239.       else
   240.          the_drive_time := 0;
   241.       end if;
   242.       -- Hypothesis:
   243.       -- Operating successively on the current platter, or working on the fixed-head platter,
   244.       --    incurs no arm switch time.
   245.       if the_FD.target.platter_number = the_FD.locus.platter_number or else
   246.             the_FD.target.platter_number = the_fixed_head_platter      then
   247.           return the_drive_time;
   248.        else
   249.           return the_drive_time + arm_switch_time;
   250.       end if;
   251.    end platter_switch_time;
   252.
   253.    procedure set_seek_target (the_FD       : in out FD.device;
   254.                               Q_operand    : in KDF9.Q_register;
   255.                               it_will_seek : out Boolean) is
   256.       here : FD.locus renames the_FD.locus;
   257.       next : FD.locus renames the_FD.target;
   258.    begin
   259.       it_will_seek := False;
   260.       next := locus_from(Q_operand);
   261.       next.has_fixed_heads := False;
   262.       if next.platter_number /= here.platter_number then
   263.          the_FD.switch_count := the_FD.switch_count +1;
   264.       end if;
   265.       if the_FD.comb(next.drive_number, here.platter_number) /= next.seek_area_number then
   266.          the_FD.seek_count := the_FD.seek_count + 1;
   267.          it_will_seek := True;
   268.       end if;
   269.     end set_seek_target;
   270.
   271.    procedure seek_to_the_target_area (the_FD      : in out FD.device;
   272.                                       seek_time,
   273.                                       switch_time : out seek_time_range) is
   274.       here : FD.locus renames the_FD.locus;
   275.       next : FD.locus renames the_FD.target;
   276.    begin
   277.       seek_time := arm_seek_time(the_FD);
   278.       switch_time := platter_switch_time(the_FD);
   279.       here := the_FD.target;
   280.       the_FD.comb(here.drive_number, here.platter_number) := next.seek_area_number;
   281.     end seek_to_the_target_area;
   282.
   283.    subtype sector_image is String(1 .. bytes_per_sector);
   284.
   285.    empty_sector : constant sector_image := (others => ' ');
   286.    this_sector  : sector_image;
   287.
   288.    procedure get_next_sector (the_FD : in out FD.device) is
   289.       result : POSIX.file_position with Unreferenced;
   290.    begin
   291.       result := seek(fd_of(the_FD.stream), file_offset(the_FD.locus));
   292.       result := POSIX.file_position(read(fd_of(the_FD.stream), this_sector, bytes_per_sector));
   293.       the_FD.sector_count := the_FD.sector_count + 1;
   294.       advance_the_sector_number(the_FD);
   295.    end get_next_sector;
   296.
   297.    procedure keep_house (the_FD        : in out FD.device;
   298.                          transfer_size : in KDF9.word;
   299.                          busy_time     : out KDF9.us) is
   300.    begin
   301.       the_FD.latency_count := the_FD.latency_count + 1;
   302.       the_FD.word_count := the_FD.word_count + transfer_size;
   303.       add_in_the_IO_CPU_time(the_FD, bytes_moved => transfer_size*8);
   304.       busy_time := disc_busy_time(the_FD.locus.sector_number, transfer_size);
   305.    end keep_house;
   306.
   307.    procedure update_statistics (the_FD        : in out FD.device;
   308.                                 switch_time,
   309.                                 seek_time,
   310.                                 latency_time,
   311.                                 data_time     : in KDF9.us := 0) is
   312.    begin
   313.       the_FD.switch_time := the_FD.switch_time + switch_time;
   314.       the_FD.seek_time := the_FD.seek_time + seek_time;
   315.       the_FD.latency_time := the_FD.latency_time + latency_time;
   316.       the_FD.data_time := the_FD.data_time + data_time;
   317.       the_FD.elapsed_time := the_FD.elapsed_time
   318.                                  + switch_time
   319.                                  + seek_time
   320.                                  + latency_time
   321.                                  + data_time;
   322.     end update_statistics;
   323.
   324.    procedure read (the_FD        : in out FD.device;
   325.                    start_address,
   326.                    end_address   : in  KDF9.address;
   327.                    busy_time     : out KDF9.us;
   328.                    reading_to_EM : in  Boolean := False) is
   329.       size : KDF9.word := 0;
   330.       next : Natural := 0;
   331.       char : Character;
   332.    begin
   333.       check_addresses_and_lockouts(start_address, end_address);
   334.    word_loop:
   335.       for w in start_address .. end_address loop
   336.          if size mod bytes_per_sector = 0 then
   337.             this_sector := empty_sector;
   338.             get_next_sector(the_FD);
   339.          exit word_loop when the_FD.locus.is_at_end_of_area;
   340.             next := 0;
   341.          end if;
   342.          for c in KDF9_char_sets.symbol_index'Range loop
   343.             next := next + 1;
   344.             char := this_sector(next);
   345.             store_symbol(CN_TR(char), w, c);
   346.             size := size + 1;
   347.          exit word_loop when reading_to_EM and char = E_M;
   348.          end loop;
   349.       end loop word_loop;
   350.       keep_house(the_FD, (size+7)/8, busy_time);
   351.    end read;
   352.
   353.    procedure PI_all (the_FD         : in out FD.device;
   354.                      Q_operand      : in KDF9.Q_register;
   355.                      transfer_to_EM : in Boolean := False) is
   356.       the_present_time   : constant KDF9.us := the_clock_time;
   357.       latency_start_time : KDF9.us;
   358.       seek_duration,
   359.       switch_duration,
   360.       latency_duration,
   361.       data_duration,
   362.       total_duration     : KDF9.us;
   363.    begin
   364.       validate_device(the_FD);
   365.       validate_parity(the_FD);
   366.       seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   367.       set_the_new_sector_number(the_FD, Q_operand);
   368.       latency_start_time := the_present_time + seek_duration + switch_duration;
   369.       latency_duration := latent_time(the_FD, latency_start_time);
   370.
   371.       if the_FD.locus.is_at_end_of_area then
   372.          -- Cannot transfer past the last sector in a seek area.
   373.          trap_failing_IO_operation(the_FD, "attempt to read FD at the end of a seek area");
   374.       end if;
   375.
   376.       -- Read from the newly established position.
   377.       read(
   378.            the_FD,
   379.            Q_operand.I, Q_operand.M,
   380.            data_duration,
   381.            reading_to_EM => transfer_to_EM
   382.           );
   383.
   384.       total_duration := seek_duration + switch_duration + latency_duration + data_duration;
   385.       start_data_transfer(the_FD, Q_operand, False, total_duration, input_operation);
   386.       lock_out_relative_addresses(Q_operand);
   387.       update_statistics(
   388.                         the_FD,
   389.                         switch_time  => switch_duration,
   390.                         seek_time    => seek_duration,
   391.                         latency_time => latency_duration,
   392.                         data_time    => data_duration
   393.                        );
   394.    end PI_all;
   395.
   396.    overriding
   397.    procedure PIA (the_FD      : in out FD.device;
   398.                   Q_operand   : in KDF9.Q_register;
   399.                   set_offline : in Boolean) is
   400.       pragma Unreferenced(set_offline);
   401.    begin
   402.       PI_all(the_FD, Q_operand);
   403.    end PIA;
   404.
   405.    overriding
   406.    procedure PIB (the_FD      : in out FD.device;
   407.                   Q_operand   : in KDF9.Q_register;
   408.                   set_offline : in Boolean) is
   409.       pragma Unreferenced(set_offline);
   410.    begin
   411.       PI_all(the_FD, Q_operand, transfer_to_EM => True);
   412.    end PIB;
   413.
   414.    -- Set up FD parameters for a transfer in the fixed-head platter.
   415.    procedure prepare_fixed_head_transfer (the_FD      : in out FD.device;
   416.                                           Q_operand   : in KDF9.Q_register) is
   417.    begin
   418.       the_FD.target := locus_from(Q_operand);
   419.       the_FD.target.has_fixed_heads := True;
   420.       the_FD.target.platter_number := 16;
   421.       the_FD.switch_time := platter_switch_time(the_FD);
   422.       the_FD.locus := the_FD.target;
   423.       the_FD.switch_count := the_FD.switch_count + (if the_FD.switch_time = 0 then 0 else 1);
   424.    end prepare_fixed_head_transfer;
   425.
   426.    overriding
   427.    procedure PIC (the_FD      : in out FD.device;
   428.                   Q_operand   : in KDF9.Q_register;
   429.                   set_offline : in Boolean) is
   430.       pragma Unreferenced(set_offline);
   431.    begin
   432.       prepare_fixed_head_transfer(the_FD, Q_operand);
   433.       PI_all(the_FD, Q_operand);
   434.    end PIC;
   435.
   436.    overriding
   437.    procedure PID (the_FD      : in out FD.device;
   438.                   Q_operand   : in KDF9.Q_register;
   439.                   set_offline : in Boolean) is
   440.       pragma Unreferenced(set_offline);
   441.    begin
   442.       prepare_fixed_head_transfer(the_FD, Q_operand);
   443.       PI_all(the_FD, Q_operand, transfer_to_EM => True);
   444.    end PID;
   445.
   446.    -- Find the number of the next (first) sector to rotate into an accessible position.
   447.    function next_sector_number (the_FD : FD.device)
   448.    return FD.sector_range is
   449.       now        : constant KDF9.us := the_clock_time;
   450.       best_time  : KDF9.us          := KDF9.us'Last;
   451.       the_sector : FD.sector_range  := FD.sector_range'Last;
   452.    begin
   453.       for s in FD.sector_range loop
   454.          if latent_time(the_FD, now) in sector_time+1 .. 2*sector_time then
   455.             if latent_time(the_FD, now) <= best_time then
   456.                the_sector := s;
   457.                best_time := latent_time(the_FD, now);
   458.             end if;
   459.          end if;
   460.       end loop;
   461.       return the_sector;
   462.    end next_sector_number;
   463.
   464.    -- Modify the given command to apply to the next sector to come under the heads.
   465.    function for_next_sector (the_FD : FD.device; Q : KDF9.Q_register)
   466.    return KDF9.Q_register
   467.    is (
   468.        C => (Q.C and 8#174000#) or (Q.C and 8#17#) or (next_sector_number(the_FD)*16),
   469.        I => Q.I,
   470.        M => Q.M
   471.       );
   472.
   473.    overriding
   474.    procedure PIE (the_FD      : in out FD.device;
   475.                   Q_operand   : in KDF9.Q_register;
   476.                   set_offline : in Boolean) is
   477.       pragma Unreferenced(set_offline);
   478.    begin
   479.       validate_transfer(the_FD, Q_operand);
   480.       PI_all(the_FD, for_next_sector(the_FD, Q_operand));
   481.    end PIE;
   482.
   483.    overriding
   484.    procedure PIF (the_FD      : in out FD.device;
   485.                   Q_operand   : in KDF9.Q_register;
   486.                   set_offline : in Boolean) is
   487.       pragma Unreferenced(set_offline);
   488.    begin
   489.       validate_transfer(the_FD, Q_operand);
   490.       PI_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   491.    end PIF;
   492.
   493.    overriding
   494.    procedure PIG (the_FD      : in out FD.device;
   495.                   Q_operand   : in KDF9.Q_register;
   496.                   set_offline : in Boolean) is
   497.       pragma Unreferenced(set_offline);
   498.    begin
   499.       validate_transfer(the_FD, Q_operand);
   500.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   501.       PI_all(the_FD, for_next_sector(the_FD, Q_operand));
   502.    end PIG;
   503.
   504.    overriding
   505.    procedure PIH (the_FD      : in out FD.device;
   506.                   Q_operand   : in KDF9.Q_register;
   507.                   set_offline : in Boolean) is
   508.       pragma Unreferenced(set_offline);
   509.    begin
   510.       validate_transfer(the_FD, Q_operand);
   511.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   512.       PI_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   513.    end PIH;
   514.
   515.    -- Set up, but do not yet effect, a seek to the locus specified by the Q_operand.
   516.    -- This follows advice from David Holdsworth that seeks were not effected
   517.    --    until a data transfer operation was obeyed.
   518.    -- PMA does not lockout for a busy device.  This may not be authentic.
   519.    overriding
   520.    procedure PMA (the_FD      : in out FD.device;
   521.                   Q_operand   : in KDF9.Q_register;
   522.                   set_offline : in Boolean) is
   523.       a_seek_is_needed : Boolean := False;
   524.    begin
   525.       validate_device(the_FD);
   526.       validate_parity(the_FD);
   527.       set_seek_target(the_FD, Q_operand, a_seek_is_needed);
   528.       deal_with_a_busy_device(the_FD, 19, set_offline);
   529.       take_note_of_test(the_FD.device_name, Q_operand, a_seek_is_needed);
   530.    end PMA;
   531.
   532.    overriding
   533.    procedure PMB (the_FD      : in out FD.device;
   534.                   Q_operand   : in KDF9.Q_register;
   535.                   set_offline : in Boolean) is
   536.       pragma Unreferenced(Q_operand);
   537.       pragma Unreferenced(set_offline);
   538.    begin
   539.       validate_device(the_FD);
   540.       validate_parity(the_FD);
   541.       null;
   542.    end PMB;
   543.
   544.    overriding
   545.    procedure PMC (the_FD      : in out FD.device;
   546.                   Q_operand   : in KDF9.Q_register;
   547.                   set_offline : in Boolean) is
   548.       pragma Unreferenced(Q_operand);
   549.       pragma Unreferenced(set_offline);
   550.    begin
   551.       validate_device(the_FD);
   552.       validate_parity(the_FD);
   553.       null;
   554.    end PMC;
   555.
   556.    overriding
   557.    procedure PMD (the_FD      : in out FD.device;
   558.                   Q_operand   : in KDF9.Q_register;
   559.                   set_offline : in Boolean) is
   560.       -- clear out seek area # and platter#, leaving buffer # and drive #
   561.       platter_0        : constant KDF9.Q_part := Q_operand.C and 16#C00F#;
   562.       control_word     : KDF9.Q_register;
   563.       a_seek_is_needed : Boolean;
   564.       seek_duration,
   565.       switch_duration  : KDF9.us;
   566.    begin
   567.       validate_device(the_FD);
   568.       -- Hypothesis: drive reset clears the parity flag.
   569.       the_FD.is_abnormal := False;
   570.       -- In effect, do 16 PMA operations, but treat them as a single operation.
   571.       for p in KDF9.Q_part range 0..15 loop -- p is platter #
   572.          control_word := (platter_0 + p*16#400#, Q_operand.I, Q_operand.M);
   573.          set_seek_target(the_FD, control_word, a_seek_is_needed);
   574.          seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   575.          update_statistics(
   576.                            the_FD,
   577.                            switch_time  => switch_duration,
   578.                            seek_time    => seek_duration
   579.                           );
   580.       end loop;
   581.       deal_with_a_busy_device(the_FD, 16, set_offline);
   582.    end PMD;
   583.
   584.    overriding
   585.    procedure PMF (the_FD      : in out FD.device;
   586.                   Q_operand   : in KDF9.Q_register;
   587.                   set_offline : in Boolean) is
   588.    begin
   589.       validate_device(the_FD);
   590.       validate_parity(the_FD);
   591.       deal_with_a_busy_device(the_FD, 13, set_offline);
   592.       the_T_bit_is_set := the_FD.locus.is_at_end_of_area;
   593.       take_note_of_test(the_FD.device_name, Q_operand, the_T_bit_is_set);
   594.    end PMF;
   595.
   596.    procedure put_next_sector (the_FD : in out FD.device) is
   597.       result : POSIX.file_position with Unreferenced;
   598.    begin
   599.       result := seek(fd_of(the_FD.stream), file_offset(the_FD.locus));
   600.       result := POSIX.file_position(write(fd_of(the_FD.stream), this_sector, bytes_per_sector));
   601.       the_FD.sector_count := the_FD.sector_count + 1;
   602.       advance_the_sector_number(the_FD);
   603.       this_sector := empty_sector;
   604.    end put_next_sector;
   605.
   606.    procedure write (the_FD       : in out FD.device;
   607.                    start_address,
   608.                    end_address   : in KDF9.address;
   609.                    busy_time     : out KDF9.us;
   610.                    writing_to_EM : in  Boolean := False) is
   611.       size   : KDF9.word := 0;
   612.       next   : Natural := 0;
   613.       symbol : KDF9_char_sets.symbol;
   614.       char   : Character;
   615.    begin
   616.       check_addresses_and_lockouts(start_address, end_address);
   617.       this_sector := empty_sector;
   618.    word_loop:
   619.       for w in start_address .. end_address loop
   620.          for c in KDF9_char_sets.symbol_index'Range loop
   621.             symbol := fetch_symbol(w, c);
   622.             char := TP_CN(symbol);
   623.             next := next + 1;
   624.             this_sector(next) := char;
   625.             size := size + 1;
   626.             exit when writing_to_EM and char = E_M;
   627.          end loop;
   628.          if writing_to_EM and char = E_M then
   629.             put_next_sector(the_FD);
   630.             next := 0;
   631.             exit word_loop;
   632.          elsif size mod bytes_per_sector = 0 then
   633.             put_next_sector(the_FD);
   634.             next := 0;
   635.             exit word_loop when the_FD.locus.is_at_end_of_area;
   636.          end if;
   637.       end loop word_loop;
   638.       if next > 0 then
   639.          -- Write out any untransferred residue of less than a full sector.
   640.          put_next_sector(the_FD);
   641.       end if;
   642.       keep_house(the_FD, (size+7)/8, busy_time);
   643.    end write;
   644.
   645.    procedure PO_all (the_FD         : in out FD.device;
   646.                      Q_operand      : in KDF9.Q_register;
   647.                      transfer_to_EM : in Boolean := False) is
   648.       the_present_time   : constant KDF9.us := the_clock_time;
   649.       seek_duration,
   650.       switch_duration,
   651.       latency_duration,
   652.       data_duration,
   653.       total_duration     : KDF9.us;
   654.       latency_start_time : KDF9.us;
   655.    begin
   656.       validate_device(the_FD);
   657.       validate_parity(the_FD);
   658.       seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   659.       set_the_new_sector_number(the_FD, Q_operand);
   660.       latency_start_time := the_present_time + seek_duration + switch_duration;
   661.       latency_duration := latent_time(the_FD, latency_start_time);
   662.
   663.       if the_FD.locus.is_at_end_of_area then
   664.          -- Cannot transfer past the last sector in a seek area.
   665.          trap_failing_IO_operation(the_FD, "attempt to write FD at the end of a seek area");
   666.       end if;
   667.
   668.       -- Write to the newly established position.
   669.       write(
   670.             the_FD,
   671.             Q_operand.I, Q_operand.M,
   672.             data_duration,
   673.             writing_to_EM => transfer_to_EM
   674.            );
   675.
   676.       total_duration := seek_duration + switch_duration + latency_duration + data_duration;
   677.       start_data_transfer(the_FD, Q_operand, False, total_duration, output_operation);
   678.       lock_out_relative_addresses(Q_operand);
   679.       update_statistics(
   680.                         the_FD,
   681.                         seek_time    => seek_duration,
   682.                         switch_time  => switch_duration,
   683.                         latency_time => latency_duration,
   684.                         data_time    => data_duration
   685.                        );
   686.    end PO_all;
   687.
   688.    overriding
   689.    procedure POA (the_FD      : in out FD.device;
   690.                   Q_operand   : in KDF9.Q_register;
   691.                   set_offline : in Boolean) is
   692.       pragma Unreferenced(set_offline);
   693.    begin
   694.       PO_all(the_FD, Q_operand);
   695.    end POA;
   696.
   697.    overriding
   698.    procedure POB (the_FD      : in out FD.device;
   699.                   Q_operand   : in KDF9.Q_register;
   700.                   set_offline : in Boolean) is
   701.       pragma Unreferenced(set_offline);
   702.    begin
   703.       PO_all(the_FD, Q_operand, transfer_to_EM => True);
   704.    end POB;
   705.
   706.    overriding
   707.    procedure POC (the_FD      : in out FD.device;
   708.                   Q_operand   : in KDF9.Q_register;
   709.                   set_offline : in Boolean) is
   710.       pragma Unreferenced(set_offline);
   711.    begin
   712.       prepare_fixed_head_transfer(the_FD, Q_operand);
   713.       PO_all(the_FD, Q_operand);
   714.    end POC;
   715.
   716.    overriding
   717.    procedure POD (the_FD      : in out FD.device;
   718.                   Q_operand   : in KDF9.Q_register;
   719.                   set_offline : in Boolean) is
   720.       pragma Unreferenced(set_offline);
   721.    begin
   722.       prepare_fixed_head_transfer(the_FD, Q_operand);
   723.       PO_all(the_FD, Q_operand, transfer_to_EM => True);
   724.    end POD;
   725.
   726.    overriding
   727.    procedure POE (the_FD      : in out FD.device;
   728.                   Q_operand   : in KDF9.Q_register;
   729.                   set_offline : in Boolean) is
   730.    begin
   731.       POC(the_FD, Q_operand, set_offline);
   732.    end POE;
   733.
   734.    overriding
   735.    procedure POF (the_FD      : in out FD.device;
   736.                   Q_operand   : in KDF9.Q_register;
   737.                   set_offline : in Boolean) is
   738.    begin
   739.       POA(the_FD, Q_operand, set_offline);
   740.    end POF;
   741.
   742.    overriding
   743.    procedure POG (the_FD      : in out FD.device;
   744.                   Q_operand   : in KDF9.Q_register;
   745.                   set_offline : in Boolean) is
   746.       pragma Unreferenced(set_offline);
   747.    begin
   748.       validate_transfer(the_FD, Q_operand);
   749.       PO_all(the_FD, for_next_sector(the_FD, Q_operand));
   750.    end POG;
   751.
   752.    overriding
   753.    procedure POH (the_FD      : in out FD.device;
   754.                   Q_operand   : in KDF9.Q_register;
   755.                   set_offline : in Boolean) is
   756.       pragma Unreferenced(set_offline);
   757.    begin
   758.       validate_transfer(the_FD, Q_operand);
   759.       PO_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   760.    end POH;
   761.
   762.    overriding
   763.    procedure POK (the_FD      : in out FD.device;
   764.                   Q_operand   : in KDF9.Q_register;
   765.                   set_offline : in Boolean) is
   766.       pragma Unreferenced(set_offline);
   767.    begin
   768.       validate_transfer(the_FD, Q_operand);
   769.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   770.       PO_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   771.    end POK;
   772.
   773.    overriding
   774.    procedure POL (the_FD      : in out FD.device;
   775.                   Q_operand   : in KDF9.Q_register;
   776.                   set_offline : in Boolean) is
   777.       pragma Unreferenced(set_offline);
   778.    begin
   779.       validate_transfer(the_FD, Q_operand);
   780.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   781.       PO_all(the_FD, for_next_sector(the_FD, Q_operand));
   782.    end POL;
   783.
   784.    overriding
   785.    procedure Finalize (the_FD : in out FD.device) is
   786.       buffer : constant String := oct_of(KDF9.Q_part(the_FD.number), 2);
   787.    begin
   788.       if the_FD.is_open then
   789.          if (the_final_state_is_wanted and the_log_is_wanted)    and then
   790.                (the_FD.word_count /= 0 or the_FD.latency_count /= 0  or
   791.                 the_FD.seek_count /= 0 or the_FD.switch_time   /= 0) then
   792.             log_line
   793.                    (
   794.                     the_FD.device_name
   795.                   & " on buffer #"
   796.                   & buffer
   797.                   & " spent:"
   798.                    );
   799.             log_line
   800.                    (
   801.                     "    "
   802.                   & just_right(KDF9.us'Image(the_FD.data_time / 1_000), 6)
   803.                   & " ms in"
   804.                   & the_FD.latency_count'Image
   805.                   & " data transfer" & plurality(the_FD.latency_count)
   806.                   & " totalling"
   807.                   & KDF9.word'Image(the_FD.word_count)
   808.                   & " word" & plurality(the_FD.word_count)
   809.                   & ","
   810.                    );
   811.             log_line
   812.                    (
   813.                     "    "
   814.                   & just_right(KDF9.us'Image(the_FD.switch_time / 1_000), 6)
   815.                   & " ms in"
   816.                   & the_FD.switch_count'Image
   817.                   & " platter switch" & plurality(the_FD.switch_count, "", "es")
   818.                   & ","
   819.                    );
   820.             log_line
   821.                    (
   822.                     "    "
   823.                   & just_right(KDF9.us'Image(the_FD.latency_time / 1_000), 6)
   824.                   & " ms in"
   825.                   & the_FD.latency_count'Image
   826.                   & " rotational latenc" & plurality(the_FD.latency_count, "y", "ies")
   827.                   & ", and"
   828.                    );
   829.             log_line
   830.                    (
   831.                     "    "
   832.                   & just_right(KDF9.us'Image(the_FD.seek_time / 1_000), 6)
   833.                   & " ms in"
   834.                   & the_FD.seek_count'Image
   835.                   & " seek" & plurality(the_FD.seek_count) & "."
   836.                    );
   837.          end if;
   838.          IOC.device(the_FD).Finalize;
   839.          close(the_FD);
   840.       end if;
   841.    end Finalize;
   842.
   843.    type FD_access is access FD.device;
   844.
   845.    FD0 : FD_access with Warnings => Off;
   846.
   847.    procedure enable (b : in KDF9.buffer_number) is
   848.    begin
   849.       if FD0_is_enabled then
   850.          trap_operator_error("more than one FD control unit has been configured");
   851.       end if;
   852.       FD0 := new FD.device (number => b, unit => 0);
   853.       FD0_is_enabled := True;
   854.       FD0_number := b;
   855.    end enable;
   856.
   857.    procedure replace_on_buffer (b : in KDF9.buffer_number) is
   858.    begin
   859.       if FD0 /= null    and then
   860.             b = FD0.number  then
   861.          return;
   862.       end if;
   863.       buffer(b) := null;
   864.       FD0 := null;
   865.       FD0_number := 0;
   866.       FD0_is_enabled := False;
   867.       enable(b);
   868.    end replace_on_buffer;
   869.
   870.    procedure remove_from_buffer (b : in KDF9.buffer_number) is
   871.    begin
   872.       if FD0 /= null    and then
   873.             b = FD0.number  then
   874.          buffer(b) := null;
   875.          FD0 := null;
   876.          FD0_number := 0;
   877.          FD0_is_enabled := False;
   878.       end if;
   879.    end remove_from_buffer;
   880.
   881. end IOC.fast.FD;

Compiling: ../Source/ioc-fast-fd.ads
Source file time stamp: 2021-02-15 01:21:51
Compiled at: 2021-02-21 15:54:07

     1. -- Emulation of a fixed disc drive.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.FD is
    18.
    19.    type device is new fast.device with private;
    20.
    21.    overriding
    22.    procedure PIA (the_FD      : in out FD.device;
    23.                   Q_operand   : in KDF9.Q_register;
    24.                   set_offline : in Boolean);
    25.
    26.    overriding
    27.    procedure PIB (the_FD      : in out FD.device;
    28.                   Q_operand   : in KDF9.Q_register;
    29.                   set_offline : in Boolean);
    30.
    31.    overriding
    32.    procedure PIC (the_FD      : in out FD.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    overriding
    37.    procedure PID (the_FD      : in out FD.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    overriding
    42.    procedure PIE (the_FD      : in out FD.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    overriding
    47.    procedure PIF (the_FD      : in out FD.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    overriding
    52.    procedure PIG (the_FD      : in out FD.device;
    53.                   Q_operand   : in KDF9.Q_register;
    54.                   set_offline : in Boolean);
    55.
    56.    overriding
    57.    procedure PIH (the_FD      : in out FD.device;
    58.                   Q_operand   : in KDF9.Q_register;
    59.                   set_offline : in Boolean);
    60.
    61.    overriding
    62.    procedure PMA (the_FD      : in out FD.device;
    63.                   Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean);
    65.
    66.    overriding
    67.    procedure PMB (the_FD      : in out FD.device;
    68.                   Q_operand   : in KDF9.Q_register;
    69.                   set_offline : in Boolean);
    70.
    71.    overriding
    72.    procedure PMC (the_FD      : in out FD.device;
    73.                   Q_operand   : in KDF9.Q_register;
    74.                   set_offline : in Boolean);
    75.
    76.    overriding
    77.    procedure PMD (the_FD      : in out FD.device;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    overriding
    82.    procedure PMF (the_FD      : in out FD.device;
    83.                   Q_operand   : in KDF9.Q_register;
    84.                   set_offline : in Boolean);
    85.
    86.    overriding
    87.    procedure POA (the_FD      : in out FD.device;
    88.                   Q_operand   : in KDF9.Q_register;
    89.                   set_offline : in Boolean);
    90.
    91.    overriding
    92.    procedure POB (the_FD      : in out FD.device;
    93.                   Q_operand   : in KDF9.Q_register;
    94.                   set_offline : in Boolean);
    95.
    96.    overriding
    97.    procedure POC (the_FD      : in out FD.device;
    98.                   Q_operand   : in KDF9.Q_register;
    99.                   set_offline : in Boolean);
   100.
   101.    overriding
   102.    procedure POD (the_FD      : in out FD.device;
   103.                   Q_operand   : in KDF9.Q_register;
   104.                   set_offline : in Boolean);
   105.
   106.    overriding
   107.    procedure POE (the_FD      : in out FD.device;
   108.                   Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean);
   110.
   111.    overriding
   112.    procedure POF (the_FD      : in out FD.device;
   113.                   Q_operand   : in KDF9.Q_register;
   114.                   set_offline : in Boolean);
   115.
   116.    overriding
   117.    procedure POG (the_FD      : in out FD.device;
   118.                   Q_operand   : in KDF9.Q_register;
   119.                   set_offline : in Boolean);
   120.
   121.    overriding
   122.    procedure POH (the_FD      : in out FD.device;
   123.                   Q_operand   : in KDF9.Q_register;
   124.                   set_offline : in Boolean);
   125.
   126.    overriding
   127.    procedure POK (the_FD      : in out FD.device;
   128.                   Q_operand   : in KDF9.Q_register;
   129.                   set_offline : in Boolean);
   130.
   131.    overriding
   132.    procedure POL (the_FD      : in out FD.device;
   133.                   Q_operand   : in KDF9.Q_register;
   134.                   set_offline : in Boolean);
   135.
   136.    FD0_is_enabled : Boolean := False;
   137.
   138.    procedure enable (b : in KDF9.buffer_number);
   139.
   140.    procedure replace_on_buffer (b : in KDF9.buffer_number);
   141.
   142.    procedure remove_from_buffer (b : in KDF9.buffer_number);
   143.
   144.    function as_FD_command (Q_operand : KDF9.Q_register; for_seek, for_FH : Boolean := False)
   145.    return String;
   146.
   147. private
   148.
   149.    words_per_sector      : constant := 40;
   150.    bytes_per_sector      : constant := 8 * words_per_sector;
   151.
   152.    type sector_data      is array (KDF9.address range 0 .. bytes_per_sector-1)
   153.                          of KDF9_char_sets.symbol;
   154.
   155.    sectors_per_seek_area  : constant := 96;
   156.    sectors_in_outer_zone  : constant := 64;
   157.
   158.    subtype sector_range  is KDF9.Q_part range 0 .. sectors_per_seek_area-1;
   159.
   160.    type sector_array     is array (KDF9.Q_part range <>) of FD.sector_data;
   161.
   162.    subtype head_range    is KDF9.Q_part range 0 .. 7;
   163.
   164.    subtype inner_track   is FD.sector_array(FD.sector_range range 0 ..  7);
   165.    subtype outer_track   is FD.sector_array(FD.sector_range range 0 .. 15);
   166.
   167.    last_sector_for_head  : constant array (FD.head_range) of FD.sector_range
   168.                          := (0 .. 3 => FD.outer_track'Last,
   169.                              4 .. 7 => FD.inner_track'Last);
   170.
   171.    type outer_data       is array (FD.head_range range 0 .. 3) of FD.outer_track;
   172.    type inner_data       is array (FD.head_range range 4 .. 7) of FD.inner_track;
   173.
   174.    -- These rates come from the Manual, 6.1.
   175.    outer_rate : constant := 84_800;          -- bytes per second in the outer zone
   176.    inner_rate : constant := outer_rate / 2;  -- bytes per second in the outer zone
   177.
   178.    type track_set is
   179.       record
   180.          outer_zone : FD.outer_data;
   181.          inner_zone : FD.inner_data;
   182.       end record;
   183.
   184.    seek_areas_per_platter  : constant := 64;
   185.    subtype seek_area_range is KDF9.Q_part range 0 .. seek_areas_per_platter-1;
   186.
   187.    main_discs_per_drive    : constant := 16;
   188.    the_fixed_head_platter  : constant := 16;
   189.    platters_per_drive      : constant := main_discs_per_drive + 1;
   190.
   191.    subtype platter_range   is KDF9.Q_part range 0 .. platters_per_drive-1;
   192.
   193.    -- The Eldon 2 KDF9 at Leeds University had a 2-drive disc system.
   194.    -- This allows for the maximum number of drives possible.
   195.    number_of_drives : constant := 4;
   196.
   197.    subtype drive_range is KDF9.Q_part range 0 .. number_of_drives-1;
   198.
   199.    type locus is
   200.       record
   201.          drive_number      : FD.drive_range     := 0;
   202.          platter_number    : FD.platter_range   := 0;
   203.          seek_area_number  : FD.seek_area_range := 0;
   204.          sector_number     : FD.sector_range    := 0;
   205.          has_fixed_heads,
   206.          is_at_end_of_area : Boolean            := False;
   207.       end record;
   208.
   209.    -- The disc storage is actually implemented in an external file.
   210.    -- The comb and locus variables shadow the physical state of the drives.
   211.    -- They are used to derive a file address from the position established
   212.    --    by seek and transfer operations.
   213.
   214.    type comb_data is array (FD.drive_range, FD.platter_range) of FD.seek_area_range;
   215.
   216.    type device is new fast.device with
   217.       record
   218.          comb         : FD.comb_data := (others => (others => 0));
   219.          locus,
   220.          target       : FD.locus;
   221.          data_time,
   222.          seek_time    : KDF9.us := 0;
   223.          seek_count,
   224.          sector_count : KDF9.word := 0;
   225.       end record;
   226.
   227.    overriding
   228.    procedure Initialize (the_FD : in out FD.device);
   229.
   230.    overriding
   231.    procedure Finalize (the_FD : in out FD.device);
   232.
   233.    overriding
   234.    function kind (the_FD : FD.device)
   235.    return IOC.device_kind
   236.    is (FD_kind);
   237.
   238.    overriding
   239.    function quantum (the_FD : FD.device)
   240.    return KDF9.us
   241.    is ((1E6 + outer_rate - 1) / outer_rate);
   242.
   243.    FD0_number : KDF9.buffer_number := 0;
   244.
   245. end IOC.fast.FD;

 881 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-tape.adb
Source file time stamp: 2021-02-20 17:40:24
Compiled at: 2021-02-21 15:54:07

     1. -- Emulation of magnetic tape decks and buffers.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.IO_Exceptions;
    18.
    19. package body IOC.fast.tape is
    20.
    21.    --
    22.    -- Ada direct-access file management.
    23.    --
    24.
    25.    procedure open_RO (the_tape : in out tape.file; name : in String) is
    26.    begin
    27.       MT_slice_IO.Open(the_tape.reel, In_File, name);
    28.       the_tape.has_a_WP_ring := False;
    29.    exception
    30.       when others =>
    31.          trap_operator_error("'" & name & "' cannot be opened, even for reading");
    32.    end open_RO;
    33.
    34.    procedure open_RW (the_tape : in out tape.file; name : in String) is
    35.    begin
    36.       MT_slice_IO.Open(the_tape.reel, Inout_File, name);
    37.       the_tape.has_a_WP_ring := True;
    38.    exception
    39.       when Ada.IO_Exceptions.Use_Error =>
    40.          the_tape.has_a_WP_ring := False;
    41.          open_RO(the_tape, name);
    42.       when Ada.IO_Exceptions.Name_Error =>
    43.          trap_operator_error("'" & name & "' cannot be opened");
    44.    end open_RW;
    45.
    46.    procedure close (the_tape : in out tape.file) is
    47.    begin
    48.       if the_tape.has_a_WP_ring then
    49.          MT_slice_IO.Flush(the_tape.reel);
    50.       end if;
    51.       MT_slice_IO.Close(the_tape.reel);
    52.    end close;
    53.
    54.    overriding
    55.    function is_open (the_deck : tape.deck)
    56.    return Boolean
    57.    is (MT_slice_IO.Is_Open(the_deck.tape_file.reel));
    58.
    59. --
    60. --
    61.    -- Slice management.
    62.
    63.    end_of_tape : exception;
    64. --
    65. --
    66.
    67.    procedure write_slice (the_tape : in out tape.file;
    68.                           slice    : in tape.slice) is
    69.    begin
    70.       the_tape.position := the_tape.position + 1;
    71.       MT_slice_IO.Write(the_tape.reel, slice, to => the_tape.position);
    72.       if slice.kind not in tape_gap_kind then
    73.          the_tape.last_data_index := Count'Max(the_tape.last_data_index, the_tape.position);
    74.       end if;
    75.    end write_slice;
    76.
    77.    procedure read_next_slice (the_tape : in out tape.file;
    78.                               slice    : out tape.slice) is
    79.    begin
    80.       if the_tape.last_data_index > 0 then
    81.          the_tape.position := the_tape.position + 1;
    82.          MT_slice_IO.Read(the_tape.reel, slice, from => the_tape.position);
    83.       else
    84.          raise end_of_tape with "this tape is empty";
    85.       end if;
    86.    end read_next_slice;
    87.
    88.    procedure read_prev_slice (the_tape : in out tape.file;
    89.                               slice    : out tape.slice) is
    90.    begin
    91.       if the_tape.position > 0 then
    92.          MT_slice_IO.Read(the_tape.reel, slice, from => the_tape.position);
    93.          the_tape.position := the_tape.position - 1;
    94.       else
    95.          raise end_of_tape with "read_prev_slice";
    96.       end if;
    97.     exception
    98.        when End_Error =>
    99.           raise end_of_tape with "file size exceeded when reading a tape slice";
   100.    end read_prev_slice;
   101.
   102.    procedure bound_the_written_data (the_tape : in out tape.file) is
   103.       the_slice : tape.slice;
   104.    begin
   105.       the_tape.position := Size(the_tape.reel);
   106.       if the_tape.position = 0 then
   107.          -- There is no data in the file.
   108.          the_tape.last_data_index := 0;
   109.          return;
   110.       end if;
   111.       -- Locate the last data slice (if any).
   112.       while the_tape.position > 0 loop
   113.          read_prev_slice(the_tape, the_slice);
   114.       exit when the_slice.kind not in tape.tape_gap_kind;
   115.       end loop;
   116.       if the_slice.kind in tape.tape_gap_kind then
   117.          the_tape.last_data_index := 0;
   118.       else
   119.          the_tape.last_data_index := the_tape.position + 1;
   120.       end if;
   121.       the_tape.position := 0;
   122.    end bound_the_written_data;
   123.
   124.    procedure reset (the_deck : in out tape.deck) is
   125.     begin
   126.       bound_the_written_data(the_deck.tape_file);
   127.       the_deck.is_LBM_flagged := False;
   128.       the_deck.is_abnormal := False;
   129.       the_deck.unwound_frames := 0;
   130.    exception
   131.       when end_of_tape =>
   132.          the_deck.is_abnormal := True;
   133.          the_deck.is_LBM_flagged := False;
   134.          the_deck.unwound_frames := 0;
   135.    end reset;
   136.
   137. --
   138. --
   139.    -- Tape physical characteristics.
   140. --
   141. --
   142.
   143.    -- The physical end of tape (PET) is signalled one maximum block length before the tape runs out.
   144.    --  So PET is signalled at max_block_size before the absolute maximum position
   145.    --    to avoid running past the end of the tape when a very large block is written.
   146.
   147.    -- There could be as little as 60 inches of tape between the End of Tape Warning (ETW) and PET.
   148.    -- See the Manual, 22.1.3, p.182.
   149.
   150.    overriding
   151.    procedure Initialize (the_deck : in out MT_deck) is
   152.    begin
   153.       the_deck.device_name := device_name_of(the_deck);
   154.       open_RW(the_deck.tape_file, the_deck.device_name);
   155.       Initialize(IOC.device(the_deck));
   156.       the_deck.terminator        := End_Message;
   157.       the_deck.recording_density := max_bits_per_inch;  -- bits / inch
   158.       the_deck.max_reel_length   := max_reel_length;    -- inches
   159.       the_deck.inter_block_gap := the_deck.recording_density / 3;
   160.       the_deck.tape_capacity   := the_deck.max_reel_length * the_deck.recording_density;
   161.       the_deck.PET_position    := the_deck.tape_capacity - max_block_size;
   162.       the_deck.ETW_position    := the_deck.PET_position - 60 * the_deck.recording_density;
   163.       reset(tape.deck(the_deck));
   164.    end Initialize;
   165.
   166.    overriding
   167.    procedure Initialize (the_deck : in out ST_deck) is
   168.    begin
   169.       the_deck.device_name := device_name_of(the_deck);
   170.       open_RW(the_deck.tape_file, the_deck.device_name);
   171.       Initialize(IOC.device(the_deck));
   172.       the_deck.terminator        := Group_Mark;
   173.       the_deck.recording_density := max_bits_per_inch/2;  -- bits / inch
   174.       the_deck.max_reel_length   := max_reel_length;      -- inches
   175.       the_deck.inter_block_gap := the_deck.recording_density / 3;
   176.       the_deck.tape_capacity   := the_deck.max_reel_length * the_deck.recording_density;
   177.       the_deck.PET_position    := the_deck.tape_capacity - max_block_size;
   178.       the_deck.ETW_position    := the_deck.PET_position - 60 * the_deck.recording_density;
   179.       reset(tape.deck(the_deck));
   180.    end Initialize;
   181.
   182.    function is_at_BTW (the_deck : tape.deck)
   183.    return Boolean
   184.    is (the_deck.is_open and then the_deck.tape_file.position = 0);
   185.
   186.    function holds_data (the_deck : tape.deck)
   187.    return Boolean
   188.    is (the_deck.is_open and then the_deck.tape_file.last_data_index > 0);
   189.
   190.    function is_at_ETW (the_deck : tape.deck)
   191.    return Boolean
   192.    is (the_deck.is_open and then the_deck.unwound_frames >= the_deck.ETW_position);
   193.
   194.    function is_at_PET (the_deck : tape.deck)
   195.    return Boolean
   196.    is (the_deck.is_open and then the_deck.unwound_frames >= the_deck.PET_position);
   197.
   198.    procedure deal_with_trying_to_pass_PET (the_deck : in out tape.deck;
   199.                                            do_this  : String) is
   200.    begin
   201.       if is_at_PET (the_deck) then
   202.          trap_failing_IO_operation(the_deck, "an attempt was made to " & do_this & " past PET");
   203.       end if;
   204.    end deal_with_trying_to_pass_PET;
   205.
   206.    -- There are cases that are invalid iff the tape is positioned beyond the last written block.
   207.    function is_at_EOD (the_deck : tape.deck)
   208.    return Boolean
   209.    is (the_deck.is_open and then the_deck.tape_file.position > the_deck.tape_file.last_data_index);
   210.
   211.    function tape_traversal_time (the_deck : tape.deck; tape_crossed : KDF9.word)
   212.    return KDF9.us
   213.    is (the_deck.quantum * KDF9.us(tape_crossed));
   214.
   215.    function data_transfer_time (the_deck   : tape.deck;
   216.                                 byte_count : KDF9.word)
   217.    return KDF9.us
   218.    is (the_deck.quantum * KDF9.us(byte_count));
   219.
   220.    -- This is the time the MT deck is busy traversing the interblock gap and the data block.
   221.    function MT_IO_time (the_deck  : tape.deck;
   222.                         Q_operand : in KDF9.Q_register)
   223.    return KDF9.us
   224.    is (KDF9.us(the_deck.inter_block_gap) + 8*KDF9.us(Q_operand.M-Q_operand.I+1) * the_deck.quantum);
   225.
   226.    overriding
   227.    function usage (the_deck : tape.deck)
   228.    return KDF9.word
   229.    is (the_deck.bytes_moved);
   230.
   231.    overriding
   232.    procedure close (the_deck : in out tape.deck) is
   233.    begin
   234.       the_deck.tape_file.close;
   235.    end close;
   236.
   237.    procedure update_statistics (the_deck    : in out tape.deck;
   238.                                 tape_crossed,
   239.                                 bytes_moved : in length_in_frames) is
   240.       real_time : KDF9.us;
   241.    begin
   242.       the_deck.bytes_moved := the_deck.bytes_moved + KDF9.word(bytes_moved);
   243.       real_time := tape_traversal_time(the_deck, KDF9.word(tape_crossed))
   244.                  + data_transfer_time (the_deck, KDF9.word(bytes_moved));
   245.       the_deck.elapsed_time := the_deck.elapsed_time + real_time;
   246.       add_in_the_IO_CPU_time(the_deck, KDF9.word(bytes_moved));
   247.       correct_transfer_time(the_deck, real_time);
   248.    end update_statistics;
   249.
   250. --
   251. --
   252.    -- Tape manipulations.
   253. --
   254. --
   255.
   256.    type movement is (forwards, backwards);
   257.
   258.    procedure note_tape_position (the_deck    : in out tape.deck;
   259.                                  direction   : in tape.movement;
   260.                                  tape_crossed,
   261.                                  bytes_moved : in length_in_frames) is
   262.    begin
   263.       if direction = forwards then
   264.          the_deck.unwound_frames := the_deck.unwound_frames
   265.                                   + tape.length_in_frames(tape_crossed + bytes_moved);
   266.       elsif tape.length_in_frames(tape_crossed + bytes_moved) > the_deck.unwound_frames then
   267.          the_deck.unwound_frames := 0;
   268.       else
   269.          the_deck.unwound_frames := the_deck.unwound_frames
   270.                                   - tape.length_in_frames(tape_crossed + bytes_moved);
   271.       end if;
   272.    end note_tape_position;
   273.
   274.    -- KDF9 MT operations.
   275.
   276.    -- Skip back over erased tape, leaving the_slice containing the next preceding data.
   277.    -- Postcondition: the_deck.is_at_BTW or else the_slice.kind not in tape_gap_kind
   278.    procedure skip_back_over_erasure (the_deck  : in out tape.deck;
   279.                                      the_slice : in out tape.slice;
   280.                                      crossed   : in out length_in_frames) is
   281.    begin
   282.       if the_deck.is_at_BTW then
   283.          return; -- We are as far back as we can go;
   284.       end if;
   285.       if the_slice.kind in data_kind then
   286.          return;  -- We have already found the preceding data block.
   287.       end if;
   288.       loop
   289.          read_prev_slice(the_deck.tape_file, the_slice);
   290.       exit when the_deck.is_at_BTW or else the_slice.kind not in tape_gap_kind;
   291.          crossed := crossed + the_slice.size;
   292.       end loop;
   293.    end skip_back_over_erasure;
   294.
   295.    -- Skip forward over erased tape, leaving the_slice containing the next following data.
   296.    -- Postcondition: the_deck.is_at_EOD or else the_slice.kind not in tape_gap_kind
   297.    procedure skip_forward_over_erasure (the_deck  : in out tape.deck;
   298.                                         the_slice : in out tape.slice;
   299.                                         crossed   : in out length_in_frames) is
   300.    begin
   301.       if the_slice.kind in data_slice then
   302.          return;
   303.       end if;
   304.       loop
   305.          read_next_slice(the_deck.tape_file, the_slice);
   306.       exit when the_deck.is_at_EOD or else the_slice.kind not in tape.tape_gap_kind;
   307.          crossed := crossed + the_slice.size;
   308.       end loop;
   309.    exception
   310.       when end_of_tape =>
   311.          the_deck.is_abnormal := True;
   312.          raise end_of_tape with "in skip_forward_over_erasure";
   313.    end skip_forward_over_erasure;
   314.
   315. --
   316. --
   317.    -- Tape I/O.
   318. --
   319. --
   320.
   321.    -- Deal with blocks of invalid sizes.
   322.
   323.    -- 1081 buffers always write and read a whole number of words;
   324.    --    see Manual 22.1.5, p184, 2; and Appendix 7 3, p318.
   325.    overriding
   326.    procedure handle_any_abnormality (the_deck : in out MT_deck;
   327.                                      the_size : in length_in_frames) is
   328.    begin
   329.       the_deck.is_abnormal := the_deck.is_abnormal or (the_size mod 8 /= 0);
   330.    end handle_any_abnormality;
   331.
   332.    -- 3.4.7 of the EGDON 3 manual says that the 7-track tape buffer, due to a hardware
   333.    --    limitation, rejects blocks (other than tape marks) of less than 6 characters.
   334.    overriding
   335.    procedure handle_any_abnormality (the_deck : in out ST_deck;
   336.                                      the_size : in length_in_frames) is
   337.    begin
   338.       the_deck.is_abnormal := the_deck.is_abnormal or (the_size < 6);
   339.    end handle_any_abnormality;
   340.
   341.    procedure read_block (the_deck  : in out tape.deck;
   342.                          the_data  : out tape.block_storage;
   343.                          the_size  : out length_in_frames;
   344.                          direction : in movement := forwards) is
   345.
   346.       left,
   347.       right      : length_in_frames := 1;
   348.       block_size,
   349.       crossed    : length_in_frames := 0;
   350.       is_last,
   351.       is_flagged : Boolean := False;
   352.       the_slice  : tape.slice := a_NULL_slice;
   353.    begin
   354.       the_deck.is_LBM_flagged := False;
   355.
   356.       skip_forward_over_erasure(the_deck, the_slice, crossed);
   357.
   358.       -- Ensure that we are not beyond the end of valid data.
   359.       if the_deck.is_at_EOD then
   360.          trap_failing_IO_operation(
   361.                                    the_deck,
   362.                                    "there is no data past slice" & the_deck.tape_file.position'Image
   363.                                   );
   364.       end if;
   365.
   366.       if the_slice.kind in tape.tape_mark_kind then
   367.          -- Deal with a tape mark block; according to the Maual, Appendix 7, 2, p.317,
   368.          --    it reads as a single character with value #17.
   369.          block_size := 8;
   370.          the_data(1)    := KDF9_char_sets.TP_CN(KDF9_char_sets.Tape_Mark);
   371.          the_data(2..8) := (others => KDF9_char_sets.TP_CN(KDF9_char_sets.Blank_Space));
   372.          the_deck.is_LBM_flagged := True;
   373.       else
   374.          -- We have a bona fide data block.
   375.          the_size := 0;
   376.          -- Accumulate a series of slicefuls.
   377.          loop
   378.             right := left + the_slice.size - 1;
   379.             the_data(left .. right) := the_slice.data(1..the_slice.size);
   380.             block_size := block_size + the_slice.size;
   381.             left := left + the_slice.size;
   382.             is_flagged := is_flagged or the_slice.is_LBM_flagged;
   383.             is_last  := the_slice.is_last;
   384.          exit when is_last or block_size = max_block_size;
   385.             read_next_slice(the_deck.tape_file, the_slice);
   386.          end loop;
   387.          the_deck.is_LBM_flagged := is_flagged;
   388.       end if;
   389.       the_size := block_size;
   390.
   391.       note_tape_position(the_deck, direction,
   392.                         crossed + the_deck.inter_block_gap, bytes_moved => the_size);
   393.       update_statistics(the_deck,
   394.                         crossed + the_deck.inter_block_gap, bytes_moved => the_size);
   395.
   396.      if not is_last and block_size = max_block_size then
   397.          trap_failing_IO_operation(the_deck, "a magnetic tape block > 32KW");
   398.       end if;
   399.       handle_any_abnormality(the_deck, block_size);
   400.    end read_block;
   401.
   402.    procedure increment (word_address : in out KDF9.address;
   403.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   404.    begin
   405.       if symbol_nr < 7 then
   406.          symbol_nr := symbol_nr + 1;
   407.       else
   408.          symbol_nr := 0;
   409.          word_address := word_address + 1;
   410.       end if;
   411.    end increment;
   412.
   413.    tape_mark_data_word : constant KDF9.word := 8#17_00_00_00_00_00_00_00#;
   414.
   415.    procedure read (the_deck       : in out tape.deck;
   416.                    Q_operand      : in KDF9.Q_register;
   417.                    to_terminator  : in Boolean := False) is
   418.       start_address : constant KDF9.address := Q_operand.I;
   419.       end_address   : constant KDF9.address := Q_operand.M;
   420.       the_data : tape.block_storage;
   421.       s        : KDF9_char_sets.symbol_index;
   422.       w        : KDF9.address;
   423.       stored   : KDF9.word := 0;
   424.       the_size : length_in_frames;
   425.    begin
   426.       validate_device(the_deck);
   427.       check_addresses_and_lockouts(start_address, end_address);
   428.
   429.       read_block(the_deck, the_data, the_size);
   430.
   431.       if the_size mod 8 /= 0 and the_deck.kind = MT_kind then
   432.          -- Disregard an incomplete final word; see Manual, 22.1.5, p184, 2.
   433.          the_deck.is_abnormal := True;
   434.          the_size := the_size - the_size mod 8;
   435.       end if;
   436.
   437.       -- Store the relevant words.
   438.       w := start_address;
   439.       s := 0;
   440.       for i in 1 .. the_size loop
   441.          if s = 0 then
   442.             store_word(0, w);
   443.          end if;
   444.          store_symbol(CN_TR(the_data(i)), w, s);
   445.          stored := stored + 1;
   446.       exit when (w = end_address) and (s = 7);
   447.       exit when to_terminator and CN_TR(the_data(i)) = the_deck.terminator;
   448.          increment(w, s);
   449.       end loop;
   450.       if to_terminator then
   451.          correct_transfer_time(the_deck, stored);
   452.       end if;
   453.    exception
   454.       when end_of_tape =>
   455.          deal_with_trying_to_pass_PET(the_deck, "reading");
   456.    end read;
   457.
   458.    procedure find_start_of_earlier_block (the_deck : in out tape.deck;
   459.                                           crossed  : in out length_in_frames) is
   460.       the_slice  : tape.slice := a_NULL_slice;
   461.       block_size : length_in_frames;
   462.    begin
   463.       if the_deck.is_at_BTW then
   464.          return; -- We have already gone as far back as possible.
   465.       end if;
   466.
   467.       -- Skip back over any erasures or tape marks.
   468.       skip_back_over_erasure(the_deck, the_slice, crossed);
   469.       crossed := crossed + the_deck.inter_block_gap;
   470.
   471.       if the_deck.is_at_BTW and the_slice.kind in tape_gap_kind then
   472.          the_deck.is_abnormal := True;
   473.          -- This cannot happen if the tape has (at least) a label.
   474.          raise emulation_failure with "no earlier block, at BTW on " & the_deck.device_name;
   475.       end if;
   476.
   477.       if not the_slice.is_last then
   478.          raise emulation_failure with "find_start_of_earlier_block did not find its last slice";
   479.       end if;
   480.
   481.       -- We have reached the last slice of the block.
   482.       if the_deck.kind = ST_kind and the_slice.kind in tape_mark_kind then
   483.          block_size := 1;
   484.       else
   485.          block_size := the_slice.size;
   486.          -- Jump backwards over data slices until we reach the first of the block.
   487.          while not the_slice.is_first and then the_deck.tape_file.position > 0 loop
   488.             read_prev_slice(the_deck.tape_file, the_slice);
   489.             block_size := block_size + the_slice.size;
   490.          end loop;
   491.          handle_any_abnormality(the_deck, block_size);
   492.       end if;
   493.
   494.       crossed := crossed + block_size;
   495.    end find_start_of_earlier_block;
   496.
   497.    procedure decrement (word_address : in out KDF9.address;
   498.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   499.    begin
   500.       if symbol_nr > 0 then
   501.          symbol_nr := symbol_nr - 1;
   502.       else
   503.          symbol_nr := 7;
   504.          word_address := word_address + 1;
   505.       end if;
   506.    end decrement;
   507.
   508.    procedure read_backwards (the_deck       : in out tape.deck;
   509.                              Q_operand      : in KDF9.Q_register;
   510.                              to_terminator  : in Boolean := False) is
   511.       start_address : constant KDF9.address := Q_operand.I;
   512.       end_address   : constant KDF9.address := Q_operand.M;
   513.       terminator    : constant KDF9_char_sets.symbol := the_deck.terminator;
   514.       the_data  : tape.block_storage;
   515.       s         : KDF9_char_sets.symbol_index;
   516.       w         : KDF9.address;
   517.       the_first,
   518.       the_last  : length_in_frames;
   519.       crossed   : length_in_frames := 0 with Warnings => Off;  -- Because its value is never used.
   520.    begin
   521.       validate_device(the_deck);
   522.       check_addresses_and_lockouts(start_address, end_address);
   523.
   524.       -- Locate the start of the previous block.
   525.       find_start_of_earlier_block(the_deck, crossed);
   526.
   527.       -- Read it normally, i.e. forwards.
   528.       read_block(the_deck, the_data, the_last, backwards);
   529.
   530.       -- And retrace our steps, to position the tape as if the block had been read backwards.
   531.       find_start_of_earlier_block(the_deck, crossed);
   532.
   533.       -- Disregard an incomplete first word; see Manual 22.1.5, p184, 2; and Appendix 7 3, p318.
   534.       if the_last mod 8 = 0 or the_deck.kind = ST_kind then
   535.          the_first := the_data'First;
   536.       elsif the_last = 1 and the_deck.kind = ST_kind then
   537.          -- See Manual, Appendix 7 2, p317.
   538.          store_word(tape_mark_data_word, start_address);
   539.       else
   540.          the_deck.is_abnormal := True;
   541.          the_first := the_data'First + the_last mod 8;
   542.       end if;
   543.
   544.       -- Store the relevant words.
   545.       w := start_address;
   546.       s := 7;
   547.       for i in reverse the_first .. the_last loop
   548.          if s = 7 then
   549.             store_word(0, w);
   550.          end if;
   551.          store_symbol(CN_TR(the_data(i)), w, s);
   552.       exit when to_terminator and CN_TR(the_data(i)) = terminator;
   553.          decrement(w, s);
   554.       end loop;
   555.    end read_backwards;
   556.
   557. --
   558. --
   559.    -- KDF9 tape input orders.
   560. --
   561. --
   562.
   563.    -- MFRQq
   564.    overriding
   565.    procedure PIA (the_deck    : in out tape.deck;
   566.                   Q_operand   : in KDF9.Q_register;
   567.                   set_offline : in Boolean) is
   568.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   569.    begin
   570.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   571.       read(the_deck, Q_operand, to_terminator => False);
   572.       lock_out_relative_addresses(Q_operand);
   573.    end PIA;
   574.
   575.    -- MFREQq
   576.    overriding
   577.    procedure PIB (the_deck    : in out tape.deck;
   578.                   Q_operand   : in KDF9.Q_register;
   579.                   set_offline : in Boolean) is
   580.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   581.    begin
   582.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   583.       read(the_deck, Q_operand, to_terminator => True);
   584.       lock_out_relative_addresses(Q_operand);
   585.    end PIB;
   586.
   587.    -- as PIA
   588.    overriding
   589.    procedure PIC (the_deck    : in out tape.deck;
   590.                   Q_operand   : in KDF9.Q_register;
   591.                   set_offline : in Boolean) is
   592.    begin
   593.       the_deck.PIA(Q_operand, set_offline);
   594.    end PIC;
   595.
   596.    -- as PIB
   597.    overriding
   598.    procedure PID (the_deck    : in out tape.deck;
   599.                   Q_operand   : in KDF9.Q_register;
   600.                   set_offline : in Boolean) is
   601.    begin
   602.       the_deck.PIB(Q_operand, set_offline);
   603.    end PID;
   604.
   605.    -- MBRQq
   606.    overriding
   607.    procedure PIE (the_deck    : in out tape.deck;
   608.                   Q_operand   : in KDF9.Q_register;
   609.                   set_offline : in Boolean) is
   610.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   611.    begin
   612.       if the_deck.is_at_BTW then
   613.          trap_illegal_instruction("MBRQq at BTW on " & the_deck.device_name);
   614.       end if;
   615.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   616.       read_backwards(the_deck, Q_operand, to_terminator => False);
   617.       if the_deck.kind = ST_kind then
   618.          the_deck.is_LBM_flagged := False;
   619.       end if;
   620.       lock_out_relative_addresses(Q_operand);
   621.    end PIE;
   622.
   623.    -- MBREQq
   624.    overriding
   625.    procedure PIF (the_deck    : in out tape.deck;
   626.                   Q_operand   : in KDF9.Q_register;
   627.                   set_offline : in Boolean) is
   628.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   629.    begin
   630.       if the_deck.is_at_BTW then
   631.          trap_illegal_instruction("MBREQq at BTW on " & the_deck.device_name);
   632.       end if;
   633.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   634.       read_backwards(the_deck, Q_operand, to_terminator => True);
   635.       if the_deck.kind = ST_kind then
   636.          the_deck.is_LBM_flagged := False;
   637.       end if;
   638.       lock_out_relative_addresses(Q_operand);
   639.    end PIF;
   640.
   641.    -- as PIE
   642.    overriding
   643.    procedure PIG (the_deck    : in out tape.deck;
   644.                   Q_operand   : in KDF9.Q_register;
   645.                   set_offline : in Boolean) is
   646.    begin
   647.       the_deck.PIE(Q_operand, set_offline);
   648.    end PIG;
   649.
   650.    -- as PIF
   651.    overriding
   652.    procedure PIH (the_deck    : in out tape.deck;
   653.                   Q_operand   : in KDF9.Q_register;
   654.                   set_offline : in Boolean) is
   655.    begin
   656.       the_deck.PIF(Q_operand, set_offline);
   657.    end PIH;
   658.
   659. --
   660. --
   661.    -- KDF9 tape movement and test orders.
   662. --
   663. --
   664.
   665.    procedure find_start_of_later_block (the_deck : in out tape.deck;
   666.                                         crossed  : in out length_in_frames) is
   667.       the_slice  : tape.slice := a_NULL_slice;
   668.       block_size : length_in_frames := 0;
   669.    begin
   670.       -- Skip over any erasures or tape marks.
   671.       skip_forward_over_erasure(the_deck, the_slice, crossed);
   672.       crossed := crossed + the_deck.inter_block_gap;
   673.
   674.       if not the_slice.is_first then
   675.          raise emulation_failure with "find_start_of_later_block did not find its first slice";
   676.       end if;
   677.
   678.       -- We have reached the first slice of the block.
   679.       if the_deck.kind = ST_kind and the_slice.kind in tape_mark_kind then
   680.          block_size := 1;
   681.       else
   682.          block_size := the_slice.size;
   683.          -- Ignore data slices until we get to the last slice of the block.
   684.          while not the_slice.is_last loop
   685.             read_next_slice(the_deck.tape_file, the_slice);
   686.             block_size := block_size + the_slice.size;
   687.          end loop;
   688.          handle_any_abnormality(the_deck, block_size);
   689.       end if;
   690.
   691.       the_deck.is_LBM_flagged := the_slice.is_LBM_flagged;
   692.       crossed := crossed + block_size;
   693.    exception
   694.       when end_of_tape =>
   695.          the_deck.is_abnormal := True;
   696.          raise end_of_tape with "find_start_of_later_block";
   697.    end find_start_of_later_block;
   698.
   699.    procedure skip_forwards (the_deck       : in out tape.deck;
   700.                             blocks_skipped : in KDF9.word) is
   701.       crossed : length_in_frames := 0;
   702.    begin
   703.       for i in 1 .. blocks_skipped loop
   704.          find_start_of_later_block(the_deck, crossed);
   705.       -- MFSKQq stops at an LBM-flagged block, or on count expiry.
   706.       -- Unlike MBSKQq it does record having seen an LBM-flagged block during the skipping.
   707.       -- See the Manual, 22.1.3, p.183, 1 and 22.1.9, p.188, -2.
   708.       exit when the_deck.is_LBM_flagged;
   709.       end loop;
   710.       note_tape_position(the_deck, forwards, crossed, bytes_moved => 0);
   711.       update_statistics(the_deck, crossed, bytes_moved => 0);
   712.    end skip_forwards;
   713.
   714.    -- MFSKQq
   715.    overriding
   716.    procedure PMA (the_deck    : in out tape.deck;
   717.                   Q_operand   : in KDF9.Q_register;
   718.                   set_offline : in Boolean) is
   719.    begin
   720.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   721.       if Q_operand.M = 0 then
   722.          skip_forwards(the_deck, 32768);  -- See Manual 22.1.9, p188, 1.
   723.       else
   724.          require_positive_count(Q_operand.M);
   725.          skip_forwards(the_deck, KDF9.word(Q_operand.M));
   726.       end if;
   727.    end PMA;
   728.
   729.    -- MBTQq
   730.    overriding
   731.    procedure PMB (the_deck    : in out tape.deck;
   732.                   Q_operand   : in KDF9.Q_register;
   733.                   set_offline : in Boolean) is
   734.    begin
   735.       validate_device(the_deck);
   736.       validate_parity(the_deck);
   737.       deal_with_a_busy_device(the_deck, 14, set_offline);
   738.       the_T_bit_is_set := the_deck.is_at_BTW and the_deck.holds_data;
   739.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   740.    end PMB;
   741.
   742.    -- MLBQq
   743.    overriding
   744.    procedure PMC (the_deck    : in out tape.deck;
   745.                   Q_operand   : in KDF9.Q_register;
   746.                   set_offline : in Boolean) is
   747.    begin
   748.       validate_device(the_deck);
   749.       validate_parity(the_deck);
   750.       deal_with_a_busy_device(the_deck, 14, set_offline);
   751.       the_T_bit_is_set := the_deck.is_LBM_flagged;
   752.       the_deck.is_LBM_flagged := False;
   753.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   754.    end PMC;
   755.
   756.    procedure skip_backwards (the_deck       : in out tape.deck;
   757.                              blocks_skipped : in KDF9.word) is
   758.       crossed : length_in_frames := 0;
   759.    begin
   760.       for i in 1 .. blocks_skipped loop
   761.       exit when the_deck.is_at_BTW;  -- I.e., the tape is fully rewound.
   762.          find_start_of_earlier_block(the_deck, crossed);
   763.       -- MBSKQq does not stop at an LBM-flagged block, only at BTW or count expiry.
   764.       -- It ignores LBM flags encountered during the skipping.
   765.       -- See the Manual, 22.1.3, p.183, 1 and 22.1.9, p.188, -2.
   766.       end loop;
   767.       note_tape_position(the_deck, backwards, crossed, bytes_moved => 0);
   768.       update_statistics(the_deck, crossed, bytes_moved => 0);
   769.    end skip_backwards;
   770.
   771.    -- MRWDQq
   772.    overriding
   773.    procedure PMD (the_deck    : in out tape.deck;
   774.                   Q_operand   : in KDF9.Q_register;
   775.                   set_offline : in Boolean) is
   776.       byte_count,
   777.       tape_length : length_in_frames := 0;
   778.       the_slice   : tape.slice;
   779.    begin  -- PMD
   780.       the_deck.is_abnormal := False;  -- See Manual 22.1.9, p.189, -2.
   781.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   782.       -- No motion takes place if the tape is at BTW; see Manual 22.1.9, p.190, 1.
   783.       if the_deck.tape_file.position > 0 then
   784.          -- Make sure we dont try to read past the end of data.
   785.          -- Spool back to the BTW, accumulating distances.
   786.          while the_deck.tape_file.position > 0 loop
   787.             read_prev_slice(the_deck.tape_file, the_slice);
   788.             case the_slice.kind is
   789.                when data_slice =>
   790.                   byte_count := byte_count + the_slice.size;
   791.                   if the_slice.is_first then
   792.                      tape_length := tape_length + the_deck.inter_block_gap;
   793.                   end if;
   794.                when GAP_slice
   795.                   | WIPE_slice =>
   796.                   tape_length := tape_length + the_slice.size;
   797.                when others =>
   798.                   null;
   799.             end case;
   800.          end loop;
   801.       else
   802.          -- No motion takes place; see Manual 22.1.9, p.190, 1.
   803.          null;
   804.       end if;
   805.
   806.       update_statistics(the_deck, tape_length + byte_count, bytes_moved => 0);
   807.
   808.       reset(the_deck);
   809.    end PMD;
   810.
   811.    -- MBSKQq
   812.    overriding
   813.    procedure PME (the_deck    : in out tape.deck;
   814.                   Q_operand   : in KDF9.Q_register;
   815.                   set_offline : in Boolean) is
   816.    begin
   817.       if the_deck.is_at_BTW then
   818.          trap_illegal_instruction("MBSKQq at BTW on " & the_deck.device_name);
   819.       end if;
   820.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   821.       if Q_operand.M = 0 then
   822.          skip_backwards(the_deck, 32768);  -- See Manual 22.1.9, p188, 1.
   823.       else
   824.          require_positive_count(Q_operand.M);
   825.          skip_backwards(the_deck, KDF9.word(Q_operand.M));
   826.       end if;
   827.    end PME;
   828.
   829.    -- METQq
   830.    overriding
   831.    procedure PMF (the_deck    : in out tape.deck;
   832.                   Q_operand   : in KDF9.Q_register;
   833.                   set_offline : in Boolean) is
   834.    begin
   835.       validate_device(the_deck);
   836.       validate_parity(the_deck);
   837.       deal_with_a_busy_device(the_deck, 13, set_offline);
   838.       the_T_bit_is_set := the_deck.is_at_ETW;
   839.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   840.    end PMF;
   841.
   842.    -- PMKQq, forward skip, even parity, for character data with "group mark" (8#77#)
   843.    overriding
   844.    procedure PMK (the_deck    : in out tape.deck;
   845.                   Q_operand   : in KDF9.Q_register;
   846.                   set_offline : in Boolean) is
   847.    begin
   848.       if the_deck.kind = MT_kind then
   849.          trap_illegal_instruction("PMKQq on 1081 deck " & the_deck.device_name);
   850.       else
   851.          the_deck.PMA(Q_operand, set_offline);
   852.       end if;
   853.    end PMK;
   854.
   855.    -- PMLQq, backward skip, even parity, for character data with "group mark" (8#77#)
   856.    overriding
   857.    procedure PML (the_deck    : in out tape.deck;
   858.                   Q_operand   : in KDF9.Q_register;
   859.                   set_offline : in Boolean) is
   860.    begin
   861.       if the_deck.kind = MT_kind then
   862.          trap_illegal_instruction("PMLQq on 1081 deck " & the_deck.device_name);
   863.       else
   864.          the_deck.PMB(Q_operand, set_offline);
   865.       end if;
   866.    end PML;
   867.
   868. --
   869. --
   870.    -- KDF9 tape output orders.
   871. --
   872. --
   873.
   874.    procedure put_data_slice (the_deck   : in out tape.deck;
   875.                              data       : in tape.data_storage;
   876.                              size       : in length_in_frames;
   877.                              is_first,
   878.                              is_last,
   879.                              is_flagged : in Boolean) is
   880.       the_slice : tape.slice;
   881.    begin
   882.       the_slice := (
   883.                     data_slice,
   884.                     is_LBM_flagged => is_flagged,
   885.                     is_first => put_data_slice.is_first,
   886.                     is_last  => put_data_slice.is_last,
   887.                     size     => put_data_slice.size,
   888.                     data     => erased_gap_data
   889.                    );
   890.       the_slice.data(1 .. put_data_slice.size) := put_data_slice.data;
   891.       write_slice(the_deck.tape_file, the_slice);
   892.    exception
   893.       when end_of_tape =>
   894.          deal_with_trying_to_pass_PET(the_deck, "write " & the_deck.device_name);
   895.    end put_data_slice;
   896.
   897.    procedure write_block (the_deck       : in out tape.deck;
   898.                           the_data       : in tape.data_storage;
   899.                           is_LBM_flagged : in Boolean) is
   900.       remnant  : length_in_frames := the_data'Length;
   901.       from     : length_in_frames;
   902.       the_size : length_in_frames;
   903.    begin
   904.       if not the_deck.tape_file.has_a_WP_ring then
   905.          trap_operator_error(the_deck.device_name & " does not have a Write Permit Ring");
   906.       end if;
   907.
   908.       deal_with_trying_to_pass_PET(the_deck, "write");
   909.
   910.       the_deck.is_LBM_flagged := False;
   911.
   912.       -- Write the first (and possibly final) slice of the block.
   913.       the_size := (if remnant > slice_size_limit then slice_size_limit else remnant);
   914.       remnant := remnant - the_size;
   915.       from := the_data'First;
   916.       put_data_slice (
   917.                       the_deck,
   918.                       the_data(from .. the_size),
   919.                       the_size,
   920.                       is_first   => True,
   921.                       is_last    => remnant = 0,
   922.                       is_flagged => write_block.is_LBM_flagged
   923.                      );
   924.
   925.       -- Write any full slices, the last of which may be final.
   926.       while remnant >= slice_size_limit loop
   927.          deal_with_trying_to_pass_PET(the_deck, "write");
   928.          remnant := remnant - slice_size_limit;
   929.          from := from + slice_size_limit;
   930.          put_data_slice (
   931.                          the_deck,
   932.                          the_data(from .. from+slice_size_limit-1),
   933.                          slice_size_limit,
   934.                          is_first   => False,
   935.                          is_last    => remnant = 0,
   936.                          is_flagged => write_block.is_LBM_flagged
   937.                         );
   938.       end loop;
   939.
   940.       -- Write the residue as a final slice of the block.
   941.       if remnant > 0 then
   942.          put_data_slice (
   943.                          the_deck,
   944.                          the_data(from+slice_size_limit .. the_data'Last),
   945.                          remnant,
   946.                          is_first   => False,
   947.                          is_last    => True,
   948.                          is_flagged => write_block.is_LBM_flagged
   949.                         );
   950.       end if;
   951.
   952.       note_tape_position(the_deck, forwards,
   953.                         the_deck.inter_block_gap, bytes_moved => the_data'Length);
   954.       update_statistics(the_deck,
   955.                         the_deck.inter_block_gap, bytes_moved => the_data'Length);
   956.
   957.    exception
   958.       when end_of_tape =>
   959.          deal_with_trying_to_pass_PET(the_deck, "write " & the_deck.device_name);
   960.    end write_block;
   961.
   962.    procedure write (the_deck       : in out tape.deck;
   963.                     Q_operand      : in KDF9.Q_register;
   964.                     is_LBM_flagged : in Boolean := False) is
   965.       start_address : constant KDF9.address := Q_operand.I;
   966.       end_address   : constant KDF9.address := Q_operand.M;
   967.    begin
   968.       validate_device(the_deck);
   969.       check_addresses_and_lockouts(start_address, end_address);
   970.       declare
   971.          next_byte : length_in_frames := 1;
   972.          the_data  : tape.data_storage(1 .. length_in_frames(end_address-start_address+1)*8);
   973.       begin
   974.       word_loop:
   975.          for w in start_address .. end_address loop
   976.             for c in KDF9_char_sets.symbol_index'Range loop
   977.                the_data(next_byte) := TP_CN(fetch_symbol(w, c));
   978.                next_byte := next_byte + 1;
   979.             end loop;
   980.          end loop word_loop;
   981.          write_block(the_deck, the_data, is_LBM_flagged);
   982.       end;
   983.    end write;
   984.
   985.    procedure write_to_terminator (the_deck       : in out tape.deck;
   986.                                   Q_operand      : in KDF9.Q_register;
   987.                                   is_LBM_flagged : in Boolean := False) is
   988.       start_address : constant KDF9.address := Q_operand.I;
   989.       end_address   : constant KDF9.address := Q_operand.M;
   990.    begin
   991.       validate_device(the_deck);
   992.       check_addresses_and_lockouts(start_address, end_address);
   993.       declare
   994.          next_byte : length_in_frames := 1;
   995.          the_data  : tape.data_storage(1 .. length_in_frames(end_address-start_address+1)*8);
   996.          symbol    : KDF9_char_sets.symbol;
   997.       begin
   998.       word_loop:
   999.          for w in start_address .. end_address loop
  1000.             for c in KDF9_char_sets.symbol_index'Range loop
  1001.                symbol := fetch_symbol(w, c);
  1002.                the_data(next_byte) := TP_CN(symbol);
  1003.                next_byte := next_byte + 1;
  1004.          exit word_loop when symbol = the_deck.terminator;
  1005.             end loop;
  1006.          end loop word_loop;
  1007.          if the_deck.kind = MT_kind then
  1008.             -- Pad out the last word to a full 8 symbols; 7-track decks do not do this.
  1009.             while next_byte mod 8 /= 1 loop
  1010.                the_data(next_byte) := TP_CN(0);
  1011.                next_byte := next_byte + 1;
  1012.             end loop;
  1013.          end if;
  1014.          write_block(the_deck, the_data(1 .. next_byte-1), is_LBM_flagged);
  1015.          correct_transfer_time(the_deck, KDF9.word(next_byte-1));
  1016.       end;
  1017.    end write_to_terminator;
  1018.
  1019.    -- MWQq
  1020.    overriding
  1021.    procedure POA (the_deck    : in out tape.deck;
  1022.                   Q_operand   : in KDF9.Q_register;
  1023.                   set_offline : in Boolean) is
  1024.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1025.    begin
  1026.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1027.       write(the_deck, Q_operand);
  1028.       lock_out_relative_addresses(Q_operand);
  1029.    end POA;
  1030.
  1031.    -- MWEQq
  1032.    overriding
  1033.    procedure POB (the_deck    : in out tape.deck;
  1034.                   Q_operand   : in KDF9.Q_register;
  1035.                   set_offline : in Boolean) is
  1036.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1037.    begin
  1038.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1039.       write_to_terminator(the_deck, Q_operand);
  1040.       lock_out_relative_addresses(Q_operand);
  1041.    end POB;
  1042.
  1043.    procedure put_ST_tapemark_slice (the_deck    : in out tape.deck;
  1044.                                     Q_operand   : in KDF9.Q_register;
  1045.                                     set_offline : in Boolean;
  1046.                                     the_slice   : in tape.slice) is
  1047.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, (Q_operand.C, 0, 0));
  1048.    begin
  1049.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1050.       write_slice(the_deck.tape_file, the_slice);
  1051.    exception
  1052.       when end_of_tape =>
  1053.          deal_with_trying_to_pass_PET(the_deck, "write " & the_deck.device_name);
  1054.    end put_ST_tapemark_slice;
  1055.
  1056.    -- MLWQq
  1057.    overriding
  1058.    procedure POC (the_deck    : in out tape.deck;
  1059.                   Q_operand   : in KDF9.Q_register;
  1060.                   set_offline : in Boolean) is
  1061.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1062.    begin
  1063.       if the_deck.kind = MT_kind then
  1064.          start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1065.          write(the_deck, Q_operand, is_LBM_flagged => True);
  1066.          lock_out_relative_addresses(Q_operand);
  1067.       else
  1068.          put_ST_tapemark_slice(the_deck, Q_operand, set_offline, odd_parity_tape_mark);
  1069.       end if;
  1070.    end POC;
  1071.
  1072.    -- MLWEQq
  1073.    overriding
  1074.    procedure POD (the_deck    : in out tape.deck;
  1075.                   Q_operand   : in KDF9.Q_register;
  1076.                   set_offline : in Boolean) is
  1077.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1078.    begin
  1079.       if the_deck.kind = MT_kind then
  1080.          start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1081.          write_to_terminator(the_deck, Q_operand, is_LBM_flagged => True);
  1082.          lock_out_relative_addresses(Q_operand);
  1083.       else
  1084.          put_ST_tapemark_slice(the_deck, Q_operand, set_offline, even_parity_tape_mark);
  1085.       end if;
  1086.    end POD;
  1087.
  1088.    procedure erase_tape_gap (the_deck   : in out tape.deck;
  1089.                              the_length : in KDF9.Q_part; -- the_length is a number of words.
  1090.                              gap_kind   : in tape_gap_kind) is
  1091.       crossing  : constant length_in_frames := length_in_frames(the_length) * 8;
  1092.       the_slice : tape.slice := (if gap_kind = GAP_slice then a_GAP_slice else a_WIPE_slice);
  1093.       remnant   : length_in_frames := crossing;
  1094.       old_slice : tape.slice;
  1095.       the_size  : length_in_frames;
  1096.    begin
  1097.       loop
  1098.          deal_with_trying_to_pass_PET(the_deck, "erase");
  1099.          the_size := length_in_frames'Min(remnant, slice_size_limit);
  1100.          remnant  := remnant - the_size;
  1101.
  1102.          the_slice.size := the_size;
  1103.
  1104.          if gap_kind = GAP_slice  and then
  1105.                not the_deck.is_at_EOD then
  1106.             -- Safety rules apply to erasing gaps; see the Manual, Appendix 6.8, p.314.
  1107.             read_next_slice(the_deck.tape_file, old_slice);
  1108.             if old_slice.kind /= WIPE_slice then
  1109.                trap_failing_IO_operation(
  1110.                                          the_deck,
  1111.                                          "a GAP of length"
  1112.                                        & the_length'Image
  1113.                                        & " words would overwrite data at slice"
  1114.                                        & the_deck.tape_file.position'Image
  1115.                                         );
  1116.             end if;
  1117.             -- Restore the writing position.
  1118.             read_prev_slice(the_deck.tape_file, old_slice);
  1119.          end if;
  1120.
  1121.          write_slice(the_deck.tape_file, the_slice);
  1122.       exit when remnant = 0;
  1123.       end loop;
  1124.
  1125.       the_deck.is_LBM_flagged := False;
  1126.       note_tape_position(the_deck, forwards, crossing, bytes_moved => 0);
  1127.       update_statistics(the_deck, crossing, bytes_moved => 0);
  1128.    exception
  1129.       when end_of_tape =>
  1130.          deal_with_trying_to_pass_PET(the_deck, "WIPE/GAP " & the_deck.device_name);
  1131.    end erase_tape_gap;
  1132.
  1133.    -- MGAPQq
  1134.    overriding
  1135.    procedure POE (the_deck    : in out tape.deck;
  1136.                   Q_operand   : in KDF9.Q_register;
  1137.                   set_offline : in Boolean) is
  1138.       time : constant KDF9.us := 19+IO_elapsed_time(the_deck, KDF9.word(Q_operand.M));
  1139.    begin
  1140.       if not the_deck.tape_file.has_a_WP_ring then
  1141.          trap_operator_error(the_deck.device_name & " does not have a Write Permit Ring");
  1142.       end if;
  1143.       require_positive_count(Q_operand.M);
  1144.       start_data_transfer(the_deck, Q_operand, set_offline, time);
  1145.       erase_tape_gap(the_deck, Q_operand.M, gap_kind => GAP_slice);
  1146.    end POE;
  1147.
  1148.    -- MWIPEQq
  1149.    overriding
  1150.    procedure POF (the_deck    : in out tape.deck;
  1151.                   Q_operand   : in KDF9.Q_register;
  1152.                   set_offline : in Boolean) is
  1153.       time : constant KDF9.us := 19+IO_elapsed_time(the_deck, KDF9.word(Q_operand.M));
  1154.    begin
  1155.       if not the_deck.tape_file.has_a_WP_ring then
  1156.          trap_operator_error(the_deck.device_name & " does not have a Write Permit Ring");
  1157.       end if;
  1158.       require_positive_count(Q_operand.M);
  1159.       start_data_transfer(the_deck, Q_operand, set_offline, time);
  1160.       erase_tape_gap(the_deck, Q_operand.M, gap_kind => WIPE_slice);
  1161.    end POF;
  1162.
  1163.    overriding
  1164.    procedure Finalize (the_deck : in out tape.deck) is
  1165.       the_deck_was_used : constant Boolean := the_deck.bytes_moved /= 0 or not the_deck.is_at_BTW;
  1166.       buffer            : constant String  := oct_of(KDF9.Q_part(the_deck.number), 2);
  1167.    begin
  1168.       if the_deck.is_open then
  1169.          if (the_final_state_is_wanted and the_log_is_wanted) and then
  1170.                the_deck_was_used                                  then
  1171.             log_line(
  1172.                      the_deck.device_name
  1173.                    & " on buffer #"
  1174.                    & buffer
  1175.                    & " transferred"
  1176.                    & the_deck.bytes_moved'Image
  1177.                    & " character" & plurality(the_deck.bytes_moved)
  1178.                    & (
  1179.                       if    the_deck.is_at_PET then ", and is now at PET."
  1180.                       elsif the_deck.is_at_ETW then ", and is now at ETW."
  1181.                       else                          "."
  1182.                      )
  1183.                    );
  1184.          end if;
  1185.          close(the_deck.tape_file);
  1186.       end if;
  1187.    end Finalize;
  1188.
  1189.
  1190. --
  1191. --
  1192.    -- KDF9 tape configuration.
  1193. --
  1194. --
  1195.
  1196.    type tape_access is access tape.deck'Class;
  1197.    tape_deck         : array (IOC.unit_number range 0..14) of tape_access with Warnings => Off;
  1198.
  1199.    -- This cannot overflow, because there must be at least 2 non-tape buffers: FW0 and TR0.
  1200.    tape_units, ST_units : IOC.unit_number := 0;
  1201.
  1202.    procedure enable_MT_deck (b : in KDF9.buffer_number) is
  1203.    begin
  1204.       if tape_units > tape_deck'Last then
  1205.          trap_operator_error("too many tape decks specified");
  1206.       end if;
  1207.       tape_deck(tape_units) := new MT_deck (number => b, unit => tape_units-ST_units);
  1208.       tape_units := tape_units + 1;
  1209.    end enable_MT_deck;
  1210.
  1211.    procedure enable_ST_deck (b : in KDF9.buffer_number) is
  1212.    begin
  1213.       if tape_units > tape_deck'Last then
  1214.          trap_operator_error("too many tape decks specified");
  1215.       end if;
  1216.       tape_deck(tape_units) := new ST_deck (number => b, unit => ST_units);
  1217.       tape_units := tape_units + 1;
  1218.       ST_units   := ST_units + 1;
  1219.    end enable_ST_deck;
  1220.
  1221.    -- This is for use by Directors.
  1222.    procedure find_tape (the_label  : in  tape.data_storage;
  1223.                         its_number : out KDF9.buffer_number;
  1224.                         its_serial : out KDF9.word) is
  1225.
  1226.       function as_word (the_serial : tape.data_storage)
  1227.       return KDF9.word is
  1228.          word : KDF9.word := 0;
  1229.       begin
  1230.          for b in the_serial'Range loop
  1231.             word := (word * 2**6) or KDF9.word(CN_TR(the_serial(b)));
  1232.          end loop;
  1233.          return word;
  1234.       end as_word;
  1235.
  1236.       the_block : tape.data_storage(1 .. max_block_size);
  1237.       the_size  : length_in_frames;
  1238.
  1239.    begin -- find_tape
  1240.       for t in KDF9.buffer_number loop
  1241.          if buffer(t) /= null                      and then
  1242.                buffer(t).kind in MT_kind | ST_kind and then
  1243.                    is_unallocated(buffer(t))           then
  1244.             declare
  1245.                the_deck : tape.deck renames tape.deck(buffer(t).all);
  1246.             begin
  1247.                if the_deck.holds_data  and then
  1248.                      the_deck.is_at_BTW    then
  1249.                   -- Read the label.
  1250.                   -- After reading the label the tape must be set back to BTW,
  1251.                   -- as is required to emulate Director; see the Manual, 22.1, Ex. 1.
  1252.                   read_block(the_deck, the_block, the_size);
  1253.                   reset(the_deck);
  1254.                   if the_size >= 8+the_label'Length                and then
  1255.                         the_block(9 .. 8+the_label'Length) = the_label then
  1256.                      its_number := t;
  1257.                      its_serial := as_word(the_block(1 .. 8));
  1258.                      return;
  1259.                   end if;
  1260.                end if;
  1261.             end;
  1262.          end if;
  1263.       end loop;
  1264.       trap_operator_error("'" & String(the_label) & "' has not been mounted");
  1265.    end find_tape;
  1266.
  1267. end IOC.fast.tape;

Compiling: ../Source/ioc-fast-tape.ads
Source file time stamp: 2021-02-21 19:41:36
Compiled at: 2021-02-21 15:54:07

     1. -- Emulation of magnetic tape decks and buffers.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18.
    19. private with Ada.Direct_IO;
    20. --
    21. private with IOC_tape_data;
    22.
    23. use  KDF9_char_sets;
    24.
    25. package IOC.fast.tape is
    26.
    27.    -- Both the EE 1081 (MT) and the Ampex TM-4 7-track (ST) decks are emulated.
    28.    --
    29.    -- EE 1081, 16-track tape deck.
    30.       -- The physical characteristics of the deck are taken from the Manual, 22.1.2, i.e.:
    31.       -- 0.3 inch interblock gap, 400 ch/inch density, 100 inch/s tape speed,
    32.       --    full-reel rewind time ~3 minutes.
    33.    --
    34.    -- Ampex TM-4, 7-track IBM-compatible, tape deck.
    35.       -- The physical characteristics of the deck are taken from the Ampex document:
    36.       --    TECHNICAL MANUAL FOR SDSTM-4 TAPE TRANSPORT of 1963/2/15.
    37.       -- Where alternative characteristics are described, this code uses those considered to be of
    38.       --    greatest data interchange compatibility, as this is how the deck was used on KDF9, i.e.:
    39.       -- 0.3 inch interblock gap, 200 ch/inch density, 75 inch/s tape speed,
    40.       --    full-reel rewind time ~3 minutes.
    41.    --
    42.
    43.    type deck is abstract new fast.device with private;
    44.
    45.    -- MRFQq
    46.    overriding
    47.    procedure PIA (the_deck    : in out tape.deck;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- MFREQq
    52.    overriding
    53.    procedure PIB (the_deck    : in out tape.deck;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- as PIA
    58.    overriding
    59.    procedure PIC (the_deck    : in out tape.deck;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    -- as PID
    64.    overriding
    65.    procedure PID (the_deck    : in out tape.deck;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    -- MBRQq
    70.    overriding
    71.    procedure PIE (the_deck    : in out tape.deck;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    -- MBREQq
    76.    overriding
    77.    procedure PIF (the_deck    : in out tape.deck;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    -- as PIE
    82.    overriding
    83.    procedure PIG (the_deck    : in out tape.deck;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    -- as PIF
    88.    overriding
    89.    procedure PIH (the_deck    : in out tape.deck;
    90.                   Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean);
    92.
    93.    -- MFSKQq, for odd parity on 7-track deck
    94.    overriding
    95.    procedure PMA (the_deck    : in out tape.deck;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean);
    98.
    99.    -- MBTQq
   100.    overriding
   101.    procedure PMB (the_deck    : in out tape.deck;
   102.                   Q_operand   : in KDF9.Q_register;
   103.                   set_offline : in Boolean);
   104.
   105.    -- MLBQq
   106.    overriding
   107.    procedure PMC (the_deck    : in out tape.deck;
   108.                   Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean);
   110.    -- MRWDQq
   111.    overriding
   112.    procedure PMD (the_deck    : in out tape.deck;
   113.                   Q_operand   : in KDF9.Q_register;
   114.                   set_offline : in Boolean);
   115.
   116.    -- MBSKQqMFSKQq, for odd parity on 7-track deck
   117.    overriding
   118.    procedure PME (the_deck    : in out tape.deck;
   119.                   Q_operand   : in KDF9.Q_register;
   120.                   set_offline : in Boolean);
   121.
   122.    -- METQq
   123.    overriding
   124.    procedure PMF (the_deck    : in out tape.deck;
   125.                   Q_operand   : in KDF9.Q_register;
   126.                   set_offline : in Boolean);
   127.
   128.    -- PMKQq, forward skip, even parity, for 7-track deck only
   129.    overriding
   130.    procedure PMK (the_deck    : in out tape.deck;
   131.                   Q_operand   : in KDF9.Q_register;
   132.                   set_offline : in Boolean);
   133.
   134.    -- PMLQq, backward skip, even parity, for 7-track deck only
   135.    overriding
   136.    procedure PML (the_deck    : in out tape.deck;
   137.                   Q_operand   : in KDF9.Q_register;
   138.                   set_offline : in Boolean);
   139.
   140.    -- MWQq
   141.    overriding
   142.    procedure POA (the_deck    : in out tape.deck;
   143.                   Q_operand   : in KDF9.Q_register;
   144.                   set_offline : in Boolean);
   145.
   146.    -- MWEQq
   147.    overriding
   148.    procedure POB (the_deck    : in out tape.deck;
   149.                   Q_operand   : in KDF9.Q_register;
   150.                   set_offline : in Boolean);
   151.
   152.    -- MLWQq
   153.    overriding
   154.    procedure POC (the_deck    : in out tape.deck;
   155.                   Q_operand   : in KDF9.Q_register;
   156.                   set_offline : in Boolean);
   157.
   158.    -- MLWEQq
   159.    overriding
   160.    procedure POD (the_deck    : in out tape.deck;
   161.                   Q_operand   : in KDF9.Q_register;
   162.                   set_offline : in Boolean);
   163.
   164.    -- MGAPQq
   165.    overriding
   166.    procedure POE (the_deck    : in out tape.deck;
   167.                   Q_operand   : in KDF9.Q_register;
   168.                   set_offline : in Boolean);
   169.
   170.    -- MWIPEQq
   171.    overriding
   172.    procedure POF (the_deck    : in out tape.deck;
   173.                   Q_operand   : in KDF9.Q_register;
   174.                   set_offline : in Boolean);
   175.
   176.    procedure enable_MT_deck (b : in KDF9.buffer_number);
   177.
   178.    procedure enable_ST_deck (b : in KDF9.buffer_number);
   179.
   180. private
   181.
   182.    use IOC_tape_data;
   183.
   184.    -- slice_size_limit must be set so that the slice size field fits into 1 byte,
   185.    --    thus avoiding endian-ness and portability issues.
   186.    pragma Compile_Time_Error (slice_size_limit > 255, "IOC_tape_data.slice_size_limit > 255");
   187.
   188.    -- I think that both types of tape for the KDF9 had a maximum reel length of 2400 feet.
   189.    -- I assume that the recording density of the 7-track deck was no greater than that of the 1081.
   190.
   191.    max_bits_per_inch      : constant := 400;
   192.    max_reel_length        : constant := 12 * 2400;
   193.    type length_in_frames is range 0 .. max_reel_length * max_bits_per_inch;
   194.    type data_storage     is array (tape.length_in_frames range <>) of Character;
   195.
   196.    -- Attempts to write a block of more than max_block_size/8 words will be rejected.
   197.    -- The largest recommended size, as stated in the Manual, 22.1.3, is 3000 words.
   198.    -- The present value cannot logically be exceeded, and so allows all possible usages.
   199.
   200.    max_block_size         : constant := 32768 * 8;
   201.    subtype block_range   is tape.length_in_frames range 0 .. max_block_size;
   202.    subtype block_storage is data_storage (tape.block_range range 1 .. max_block_size);
   203.
   204.    -- A data block consists of one or more slices:
   205.    --
   206.    -- 1. a block of data length <= slice_size_limit has 1 slice, with (is_last and is_first) = True;
   207.    --
   208.    -- 2. a longer block has 1 or more prior slices, which all have data length = slice_size_limit,
   209.    --       all of them having is_last = False, and the first of them having is_first = True;
   210.    --    and 1 final slice of data length <= slice_size_limit, with is_last = True.
   211.    --
   212.    -- The total data length of all the slices in a block is <= max_block_size.
   213.    --
   214.    -- GAP and WIPE slices represent erased lengths of tape.
   215.    -- They are implemented, in effect, as data slices with non-significant data.
   216.    --
   217.    -- Parity mark slices represent tape marks on IBM-compatible Ampex TM4 decks.
   218.    -- See Manual, Appendix 7, p.317.
   219.
   220.    type basis_kind is (data_slice,
   221.                        GAP_slice,
   222.                        NULL_slice,
   223.                        WIPE_slice,
   224.                        even_parity_mark,
   225.                        odd_parity_mark);
   226.
   227.    -- These representations make for easy inspection of a MT file (e.g. using the UNIX od command).
   228.    for basis_kind use (data_slice       => Character'Pos('D'),
   229.                        GAP_slice        => Character'Pos('G'),
   230.                        NULL_slice       => Character'Pos('N'),
   231.                        WIPE_slice       => Character'Pos('W'),
   232.                        even_parity_mark => Character'Pos('e'),
   233.                        odd_parity_mark  => Character'Pos('o'));
   234.
   235.    subtype tape_gap_kind is tape.basis_kind
   236.       with Static_Predicate => tape_gap_kind in GAP_slice | WIPE_slice;
   237.
   238.    subtype tape_mark_kind is tape.basis_kind
   239.       with Static_Predicate => tape_mark_kind in odd_parity_mark | even_parity_mark;
   240.
   241.    subtype data_kind is tape.basis_kind
   242.       with Static_Predicate => data_kind = data_slice;
   243.
   244.    subtype slice_range   is tape.block_range range 0 .. IOC_tape_data.slice_size_limit;
   245.    subtype slice_storage is data_storage (1 .. slice_range'Last);
   246.
   247.    tape_mark_data  : constant tape.slice_storage := (1 => tape_mark_sign, others => block_padding);
   248.    erased_gap_data : constant tape.slice_storage := (others => block_padding);
   249.
   250.    type slice is
   251.       record
   252.          kind              : tape.basis_kind;
   253.          is_first, is_last : Boolean;
   254.          is_LBM_flagged    : Boolean;
   255.          size              : tape.slice_range;
   256.          data              : tape.slice_storage; -- Only data(1 .. size) are valid.
   257.       end record
   258.    with Size => 8 * MT_record_length;
   259.
   260.    -- These two representation specifications put the kind and is_* fields at convenient positions
   261.    --    for easy inspection in a legible print of a MT file (e.g. using the UNIX od command).
   262.
   263.    -- The first byte contains the initial letter of the slice type (see basis_kind).
   264.
   265.    -- The second byte takes the following octal/ASCII values for non-tape mark slices:
   266.    --    000 = NUL  => no flags
   267.    --    001 = SOH  => first slice of block
   268.    --    010 = BEL  => last slice of block
   269.    --    011 = HT   => only slice of block (first and last)
   270.    --    100 = @    => LBM flag
   271.    --    101 = A    => first slice of block with LBM flag
   272.    --    110 = H    => last slice of block with LBM flag
   273.    --    111 = I    => only slice of block with LBM flag
   274.
   275.    for slice use
   276.       record
   277.          kind           at 0 range  0..7;
   278.          is_first       at 1 range  0..2;
   279.          is_last        at 1 range  3..5;
   280.          is_LBM_flagged at 1 range  6..7;
   281.          size           at 2 range  0..7;
   282.          data           at 3 range  0..8*slice_size_limit - 1;
   283.       end record;
   284.
   285.    even_parity_tape_mark : constant tape.slice := (even_parity_mark,
   286.                                                  is_first       => True,
   287.                                                  is_last        => True,
   288.                                                  is_LBM_flagged => True,
   289.                                                  size           => 1,
   290.                                                  data           => tape_mark_data);
   291.
   292.    odd_parity_tape_mark  : constant tape.slice := (odd_parity_mark,
   293.                                                  is_first       => True,
   294.                                                  is_last        => True,
   295.                                                  is_LBM_flagged => True,
   296.                                                  size           => 1,
   297.                                                  data           => tape_mark_data);
   298.
   299.    a_NULL_slice          : constant tape.slice := (NULL_slice,
   300.                                                  is_first       => False,
   301.                                                  is_last        => False,
   302.                                                  is_LBM_flagged => False,
   303.                                                  size           => 0,
   304.                                                  data           => erased_gap_data);
   305.
   306.    a_WIPE_slice          : constant tape.slice := (WIPE_slice,
   307.                                                  is_first       => True,
   308.                                                  is_last        => True,
   309.                                                  is_LBM_flagged => False,
   310.                                                  size           => 0,
   311.                                                  data           => erased_gap_data);
   312.
   313.    a_GAP_slice           : constant tape.slice := (GAP_slice,
   314.                                                  is_first       => True,
   315.                                                  is_last        => True,
   316.                                                  is_LBM_flagged => False,
   317.                                                  size           => 0,
   318.                                                  data           => erased_gap_data);
   319.
   320.    package MT_slice_IO is new Ada.Direct_IO(tape.slice);
   321.    use MT_slice_IO;
   322.
   323.    type file is tagged limited
   324.       record
   325.          has_a_WP_ring   : Boolean := True;
   326.          last_data_index : MT_slice_IO.Count := 0;
   327.          position        : MT_slice_IO.Count := 0;
   328.          reel            : MT_slice_IO.File_Type;
   329.       end record;
   330.
   331.    -- The complete deck type with its primitive operations.
   332.
   333.    type deck is new fast.device with
   334.       record
   335.          -- unwound_frames tallies the amount of tape wound from its spool to the takeup spool;
   336.          --    i.e. how much has to be wound back before being able to unload the tape.
   337.          unwound_frames    : tape.length_in_frames := 0;
   338.          bytes_moved       : KDF9.word := 0;
   339.          is_LBM_flagged    : Boolean   := False;
   340.          terminator        : KDF9_char_sets.symbol;
   341.          recording_density : tape.length_in_frames;
   342.          max_reel_length   : tape.length_in_frames;
   343.          inter_block_gap   : tape.length_in_frames;
   344.          tape_capacity     : tape.length_in_frames;
   345.          PET_position      : tape.length_in_frames;
   346.          ETW_position      : tape.length_in_frames;
   347.          model             : IOC.device_kind;
   348.          tape_file         : tape.file;
   349.       end record;
   350.
   351.    overriding
   352.    procedure Finalize (the_deck : in out tape.deck);
   353.
   354.    overriding
   355.    function quantum (the_deck : tape.deck)
   356.    return KDF9.us
   357.    is (tape.deck'Class(the_deck).quantum);
                                        |
        >>> warning: possible infinite recursion, Storage_Error may be raised at run time

   358.    pragma Warnings(Off, quantum);
   359.
   360.    overriding
   361.    function kind (the_deck : tape.deck)
   362.    return IOC.device_kind
   363.    is (tape.deck'Class(the_deck).kind);
                                        |
        >>> warning: possible infinite recursion, Storage_Error may be raised at run time

   364.    pragma Warnings(Off, kind);
   365.
   366.    procedure handle_any_abnormality (the_deck : in out tape.deck;
   367.                                      the_size : in length_in_frames)
   368.    is null;
   369.
   370.    overriding
   371.    function IO_elapsed_time_total (the_deck : tape.deck)
   372.    return KDF9.us
   373.    is (tape.deck'Class(the_deck).elapsed_time);
   374.    pragma Warnings(Off, IO_elapsed_time_total);
   375.
   376.    procedure open (the_deck : in out tape.deck;
   377.                    the_mode : in POSIX.access_mode)
   378.    is null;
   379.
   380.    overriding
   381.    function is_open (the_deck : tape.deck)
   382.    return Boolean;
   383.
   384.    overriding
   385.    function usage (the_deck : tape.deck)
   386.    return KDF9.word;
   387.
   388.    overriding
   389.    procedure close (the_deck : in out tape.deck);
   390.
   391.    overriding
   392.    procedure flush(the_deck : in out tape.deck) is null;
   393.
   394.    type MT_deck is new tape.deck with null record;
   395.
   396.    overriding
   397.    procedure Initialize (the_deck : in out MT_deck);
   398.
   399.    overriding
   400.    function kind (the_deck : MT_deck)
   401.    return IOC.device_kind
   402.    is (MT_kind);
   403.
   404.    overriding
   405.    function quantum (the_deck : MT_deck)
   406.    return KDF9.us
   407.    is (1E6 / 40E3);
   408.
   409.    overriding
   410.    procedure handle_any_abnormality (the_deck : in out MT_deck;
   411.                                      the_size : in length_in_frames);
   412.
   413.    type ST_deck is new tape.deck with null record;
   414.
   415.    overriding
   416.    procedure Initialize (the_deck : in out ST_deck);
   417.
   418.    overriding
   419.    function kind (the_deck : ST_deck)
   420.    return IOC.device_kind
   421.    is (ST_kind);
   422.
   423.    overriding
   424.    function quantum (the_deck : ST_deck)
   425.    return KDF9.us
   426.    is (1E6 / 15E3);
   427.
   428.    overriding
   429.    procedure handle_any_abnormality (the_deck : in out ST_deck;
   430.                                      the_size : in length_in_frames);
   431.
   432.
   433.    procedure find_tape (the_label  : in  tape.data_storage;
   434.                         its_number : out KDF9.buffer_number;
   435.                         its_serial : out KDF9.word);
   436.
   437. end IOC.fast.tape;


GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-fw.adb
Source file time stamp: 2021-02-20 17:44:35
Compiled at: 2021-02-21 15:54:08

     1. -- Emulation of the FlexoWriter buffer: monitor typewriter functionality.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received the copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18. --
    19. with HCI;
    20. with host_IO;
    21.
    22. use  Ada.Text_IO;
    23. --
    24. use  HCI;
    25. use  host_IO;
    26.
    27. package body IOC.slow.shift.FW is
    28.
    29.    use  KDF9_char_sets;
    30.    use  Ada.Characters.Latin_1;
    31.
    32.    function a_LF_was_just_read (the_FW : FW.device)
    33.    return Boolean
    34.    is (the_FW.mode = the_flexowriter_is_reading and then a_LF_was_just_read(the_FW.stream));
    35.
    36.    function a_LF_was_just_written (the_FW : FW.device)
    37.    return Boolean
    38.    is (the_FW.mode = the_flexowriter_is_writing and then a_LF_was_just_written(the_FW.stream));
    39.
    40.    max_text_length : constant Positive := 64;  -- This is arbitrary, but seems reasonable.
    41.    type interaction is
    42.       record
    43.          text           : String(1 .. max_text_length);
    44.          prompt_length,
    45.          total_length   : Positive range 1 .. max_text_length;
    46.       end record;
    47.
    48.    max_interactions : constant Positive := 16; -- This is arbitrary, but seems reasonable.
    49.    interactions     : array (1 .. max_interactions) of IOC.slow.shift.FW.interaction;
    50.    next_interaction : Positive := 1;
    51.    last_interaction : Natural  := 0;
    52.
    53.     -- A '' denotes LF, and the '' denotes FF in an interaction text input.
    54.    LF_surrogate     : constant Character := '';
    55.    FF_surrogate     : constant Character := '';
    56.
    57.    -- These are the ANSI SGR terminal escape codes for styling FW output.
    58.    red_font_code   : constant String := ESC & "[0m" & ESC & "[31m";
    59.    black_font_code : constant String := ESC & "[0m" & ESC & "[30m";
    60.    underline_code  : constant String := ESC & "[4m";
    61.    plain_font_code : constant String := ESC & "[0m";
    62.
    63.    procedure set_text_colour_to_red (the_flexowriter_output : in out host_IO.stream) is
    64.    begin
    65.       if the_terminal_is_ANSI_compatible and realistic_FW_output_is_wanted then
    66.          put_escape_code(red_font_code, the_flexowriter_output);
    67.       end if;
    68.    end set_text_colour_to_red;
    69.
    70.    procedure set_text_colour_to_black (the_flexowriter_output : in out host_IO.stream) is
    71.    begin
    72.       if the_terminal_is_ANSI_compatible then
    73.          put_escape_code(black_font_code, the_flexowriter_output);
    74.       end if;
    75.    end set_text_colour_to_black;
    76.
    77.    procedure set_text_style_to_underline (the_flexowriter_output : in out host_IO.stream) is
    78.    begin
    79.       if the_terminal_is_ANSI_compatible then
    80.          put_escape_code(underline_code, the_flexowriter_output);
    81.       end if;
    82.    end set_text_style_to_underline;
    83.
    84.    procedure set_text_style_to_plain (the_flexowriter_output : in out host_IO.stream) is
    85.    begin
    86.       if the_terminal_is_ANSI_compatible then
    87.          put_escape_code(plain_font_code, the_flexowriter_output);
    88.       end if;
    89.    end set_text_style_to_plain;
    90.
    91.    overriding
    92.    procedure Initialize (the_FW : in out FW.device) is
    93.       interaction_file : Ada.Text_IO.File_Type;
    94.    begin
    95.       ensure_UI_is_open;
    96.       the_FW.mode := the_flexowriter_is_writing;
    97.       the_FW.device_name := device_name_of(the_FW);
    98.       if the_FW.device_name = "FW0" then
    99.          -- Attempt to open the command file for the console the_FW.
   100.          begin
   101.             Open(interaction_file, In_File, "FW0");
   102.          response_list_loop:
   103.             while not End_of_File(interaction_file) loop
   104.                if last_interaction = max_interactions then
   105.                   log_line("The file FW0 contains too many interactions!");
   106.                   raise Ada.Text_IO.Data_Error;
   107.                end if;
   108.                last_interaction := last_interaction + 1;
   109.                declare
   110.                   interaction       : String  := Get_Line(interaction_file);
   111.                   the_prompt_length : Natural := 0;
   112.                begin
   113.                   if interaction'Length > max_text_length then
   114.                      log_line(
   115.                               "The file FW0 contains an overlong string: '"
   116.                             & interaction
   117.                             & "'!"
   118.                              );
   119.                      raise Ada.Text_IO.Data_Error;
   120.                   end if;
   121.
   122.                   exit response_list_loop when interaction'Length = 0;
   123.
   124.                   for p in 1 .. interaction'Length loop
   125.                      if interaction(p) = ';' then
   126.                         the_prompt_length := p;
   127.                      elsif interaction(p) = LF_surrogate then
   128.                         -- Convert '' to LF to allow for multi-line prompts.
   129.                         interaction(p) := LF;
   130.                      elsif interaction(p) = FF_surrogate then
   131.                         -- Convert '' to FF to allow for multi-line prompts.
   132.                         interaction(p) := FF;
   133.                      end if;
   134.                   end loop;
   135.
   136.                   if the_prompt_length = 0 then
   137.                      log_line(
   138.                               "The file FW0 contains the string: '"
   139.                             & interaction
   140.                             & "' without the semicolon!"
   141.                              );
   142.                      raise Ada.Text_IO.Data_Error;
   143.                   end if;
   144.
   145.                   interactions(last_interaction).text(1 .. interaction'Length) := interaction;
   146.                   interactions(last_interaction).prompt_length := the_prompt_length;
   147.                   interactions(last_interaction).total_length := interaction'Length;
   148.                end;
   149.             end loop response_list_loop;
   150.          exception
   151.             when Name_Error =>
   152.                null;
   153.             when Use_Error =>
   154.                log_line("The file FW0 exists, but cannot be read!");
   155.          end;
   156.       end if;
   157.       open(the_FW.stream, the_FW.device_name, read_mode, UI_in_FD);
   158.       open(the_FW.output, the_FW.device_name, write_mode, UI_out_FD);
   159.       IOC.device(the_FW).Initialize;
   160.       the_FW.current_case := KDF9_char_sets.Case_Normal;
   161.    end Initialize;
   162.
   163.    -- If authentic timing, the delay of length the_pause is inserted between characters output
   164.    --    to the Flexowriter, with the aim of approximating the actual speed of its typing.
   165.    the_pause  : KDF9.us := 0;
   166.
   167.    procedure set_the_duration_of_the_pause (the_FW : in FW.device) is
   168.    begin
   169.       if authentic_timing_is_enabled then
   170.          the_pause := the_FW.quantum;
   171.       else
   172.          the_pause := 0;
   173.       end if;
   174.    end set_the_duration_of_the_pause;
   175.
   176.    call_for_manual_input    : constant String (1..2) := (others => BEL);
   177.
   178.    procedure inject_a_response (the_FW     : in out FW.device;
   179.                                 the_prompt : in String;
   180.                                 the_size   : in out KDF9.word) is
   181.    begin
   182.       set_the_duration_of_the_pause(the_FW);
   183.       for t in next_interaction .. last_interaction loop
   184.          declare
   185.             the : interaction renames interactions(t);
   186.          begin
   187.             if the.prompt_length = the.total_length then
   188.                -- A null response, so terminate the program.
   189.                raise exceptions.quit_request with "at the prompt: '" & the_prompt & "'";
   190.             end if;
   191.             next_interaction := next_interaction + 1;
   192.             if the.text(1..the.prompt_length-1) = the_prompt and then
   193.                   the.text(the.prompt_length-0) = ';'            then
   194.                inject(the.text(the.prompt_length+1..the.total_length) & LF, the_FW.stream);
   195.                the_size := the_size + KDF9.word(the.total_length-the.prompt_length);
   196.                put_chars(the.text(the.prompt_length+1..the.total_length) & LF, the_FW.output);
   197.                -- Human operators type much more slowly than KDF9 buffers!
   198.                flush(the_FW.output, the_pause*10);
   199.                the_FW.mode := the_flexowriter_is_reading;
   200.                return;
   201.             end if;
   202.          end;
   203.       end loop;
   204.       -- No canned response is available, so control reverts to the terminal.
   205.       -- Output an audible signal to notify the operator.
   206.       if noninteractive_usage_is_enabled then
   207.          raise input_is_impossible;
   208.       end if;
   209.       put_bytes(call_for_manual_input, the_FW.output);
   210.       flush(the_FW.output, the_pause);
   211.       the_FW.mode := the_flexowriter_is_reading;
   212.    end inject_a_response;
   213.
   214.    -- TRQq
   215.    overriding
   216.    procedure PIA (the_FW      : in out FW.device;
   217.                   Q_operand   : in KDF9.Q_register;
   218.                   set_offline : in Boolean) is
   219.    begin
   220.       if noninteractive_usage_is_enabled then
   221.          raise input_is_impossible;
   222.       end if;
   223.       put_bytes(call_for_manual_input, the_FW.output);
   224.       flush(the_FW.output);
   225.       the_FW.mode := the_flexowriter_is_reading;
   226.       start_slow_transfer(the_FW, Q_operand, set_offline);
   227.       read(the_FW, Q_operand);
   228.       lock_out_relative_addresses(Q_operand);
   229.       reset(the_FW.stream);
   230.    end PIA;
   231.
   232.    -- TREQq
   233.    overriding
   234.    procedure PIB (the_FW      : in out FW.device;
   235.                   Q_operand   : in KDF9.Q_register;
   236.                   set_offline : in Boolean) is
   237.    begin
   238.       if noninteractive_usage_is_enabled then
   239.          raise input_is_impossible;
   240.       end if;
   241.       put_bytes(call_for_manual_input, the_FW.output);
   242.       flush(the_FW.output);
   243.       the_FW.mode := the_flexowriter_is_reading;
   244.       start_slow_transfer(the_FW, Q_operand, set_offline);
   245.       read_to_EM(the_FW, Q_operand);
   246.       lock_out_relative_addresses(Q_operand);
   247.       reset(the_FW.stream);
   248.    end PIB;
   249.
   250.    overriding
   251.    procedure PIC (the_FW      : in out FW.device;
   252.                   Q_operand   : in KDF9.Q_register;
   253.                   set_offline : in Boolean) is
   254.    begin
   255.       if noninteractive_usage_is_enabled then
   256.          raise input_is_impossible;
   257.       end if;
   258.       put_bytes(call_for_manual_input, the_FW.output);
   259.       flush(the_FW.output);
   260.       the_FW.mode := the_flexowriter_is_reading;
   261.       start_slow_transfer(the_FW, Q_operand, set_offline);
   262.       words_read(the_FW, Q_operand);
   263.       lock_out_relative_addresses(Q_operand);
   264.       reset(the_FW.stream);
   265.    end PIC;
   266.
   267.    overriding
   268.    procedure PID (the_FW      : in out FW.device;
   269.                   Q_operand   : in KDF9.Q_register;
   270.                   set_offline : in Boolean) is
   271.    begin
   272.       if noninteractive_usage_is_enabled then
   273.          raise input_is_impossible;
   274.       end if;
   275.       put_bytes(call_for_manual_input, the_FW.output);
   276.       flush(the_FW.output);
   277.       the_FW.mode := the_flexowriter_is_reading;
   278.       start_slow_transfer(the_FW, Q_operand, set_offline);
   279.       words_read_to_EM(the_FW, Q_operand);
   280.       lock_out_relative_addresses(Q_operand);
   281.       reset(the_FW.stream);
   282.    end PID;
   283.
   284.    overriding
   285.    procedure PIE (the_FW      : in out FW.device;
   286.                   Q_operand   : in KDF9.Q_register;
   287.                   set_offline : in Boolean) is
   288.    begin
   289.       PIA(the_FW, Q_operand, set_offline);
   290.    end PIE;
   291.
   292.    overriding
   293.    procedure PIF (the_FW      : in out FW.device;
   294.                   Q_operand   : in KDF9.Q_register;
   295.                   set_offline : in Boolean) is
   296.    begin
   297.       PIB(the_FW, Q_operand, set_offline);
   298.    end PIF;
   299.
   300.    overriding
   301.    procedure PIG (the_FW      : in out FW.device;
   302.                   Q_operand   : in KDF9.Q_register;
   303.                   set_offline : in Boolean) is
   304.    begin
   305.       PIC(the_FW, Q_operand, set_offline);
   306.    end PIG;
   307.
   308.    overriding
   309.    procedure PIH (the_FW      : in out FW.device;
   310.                   Q_operand   : in KDF9.Q_register;
   311.                   set_offline : in Boolean) is
   312.    begin
   313.       PID(the_FW, Q_operand, set_offline);
   314.    end PIH;
   315.
   316.    -- neat strips off any enclosing non-graphic characters from s.
   317.    function neat (s : String)
   318.    return String is
   319.       l : Positive := 1;
   320.       r : Natural  := 0;
   321.    begin
   322.       for i in s'Range loop
   323.          l := i;
   324.       exit when s(i) > ' ' and s(i) /= DEL;
   325.       end loop;
   326.       for i in reverse s'Range loop
   327.          r := i;
   328.       exit when s(i) > ' ' and s(i) /= DEL;
   329.       end loop;
   330.       return s(l..r);  -- s(1..0) yields the null string when s is the null string.
   331.    end neat;
   332.
   333.    overriding
   334.    procedure do_output_housekeeping (the_FW   : in out FW.device;
   335.                                      written,
   336.                                      fetched  : in KDF9.word) is
   337.    begin
   338.       flush(the_FW.stream);
   339.       add_in_the_IO_CPU_time(the_FW, fetched);
   340.       correct_transfer_time(the_FW, written);
   341.       the_FW.byte_count := the_FW.byte_count + fetched;
   342.    end do_output_housekeeping;
   343.
   344.    underlined : Boolean := False;
   345.
   346.    procedure put_symbols (the_FW         : in out FW.device;
   347.                           Q_operand      : in KDF9.Q_register;
   348.                           transfer_to_EM : in Boolean) is
   349.       start_address : constant KDF9.address := Q_operand.I;
   350.       end_address   : constant KDF9.address := Q_operand.M;
   351.       fill   : KDF9.word := 0;
   352.       size   : KDF9.word := 0;
   353.       symbol : KDF9_char_sets.symbol;
   354.       char   : Character;
   355.    begin
   356.       check_addresses_and_lockouts(start_address, end_address);
   357.       set_the_duration_of_the_pause(the_FW);
   358.       the_FW.mode := the_flexowriter_is_writing;
   359.       set_text_style_to_plain(the_FW.output);
   360.       set_text_colour_to_red(the_FW.output);
   361.
   362.       -- Ensure that any prompt occupies the buffer alone.
   363.       flush(the_FW.output);
   364.
   365.    word_loop:
   366.       for w in start_address .. end_address loop
   367.          for c in KDF9_char_sets.symbol_index'Range loop
   368.             case the_FW.mode is
   369.
   370.                when the_flexowriter_is_writing =>
   371.                   symbol := fetch_symbol(w, c);
   372.                   size := size + 1;
   373.
   374.                   if symbol = KDF9_char_sets.Word_Filler then
   375.                      fill := fill + 1;
   376.
   377.                   elsif symbol = KDF9_char_sets.Case_Shift then
   378.                      the_FW.current_case := KDF9_char_sets.Case_Shift;
   379.                      the_FW.shifts := the_FW.shifts + 1;
   380.
   381.                   elsif  symbol = KDF9_char_sets.Case_Normal then
   382.                      the_FW.current_case := KDF9_char_sets.Case_Normal;
   383.                      the_FW.shifts := the_FW.shifts + 1;
   384.
   385.                   else
   386.
   387.                      if the_FW.current_case = KDF9_char_sets.Case_Normal then
   388.                         char := TP_CN(symbol);
   389.                      else
   390.                         char := TP_CS(symbol);
   391.                      end if;
   392.
   393.                      if char = ';' then
   394.
   395.                         declare
   396.                            the_prompt : constant String := contents(the_FW.output);
   397.                         begin
   398.                            -- Must flush AFTER saving the prompt and BEFORE going black.
   399.                            flush(the_FW.output, the_pause);
   400.                            set_text_colour_to_black(the_FW.output);
   401.                            set_text_style_to_plain(the_FW.output);
   402.                            put_byte(';', the_FW.output);
   403.                            flush(the_FW.output, the_pause);
   404.
   405.                            inject_a_response(the_FW, neat(the_prompt), size);
   406.
   407.                            the_FW.mode := the_flexowriter_is_reading;
   408.                            set_text_style_to_plain(the_FW.output);
   409.                         end;
   410.
   411.                      elsif flexowriter_output_is_wanted then
   412.
   413.                         if char = '_' then
   414.                            underlined := True;
   415.                            do_not_put_byte(char, the_FW.output);
   416.                            flush(the_FW.output, the_pause);
   417.                         else
   418.                            if underlined then
   419.                               set_text_style_to_underline(the_FW.output);
   420.                            end if;
   421.                            put_char(char, the_FW.output);
   422.                            if underlined then
   423.                               flush(the_FW.output, the_pause);
   424.                               set_text_style_to_plain(the_FW.output);
   425.                               set_text_colour_to_red(the_FW.output);
   426.                               underlined := False;
   427.                            end if;
   428.                         end if;
   429.
   430.                      else
   431.                         do_not_put_byte(char, the_FW.output);
   432.                      end if;
   433.
   434.                      exit word_loop when transfer_to_EM and symbol = KDF9_char_sets.End_Message;
   435.                   end if;
   436.
   437.                when the_flexowriter_is_reading =>
   438.                   get_char(char, the_FW.stream);
   439.                   if case_of(char) /= both and case_of(char) /= the_FW.current_case then
   440.                      store_symbol(CN_TR(next_case(the_FW.current_case)), w, c);
   441.                      size := size + 1;
   442.                      the_FW.current_case := the_FW.current_case xor 1;
   443.                      back_off(the_FW.stream);
   444.                   else
   445.                      if the_FW.current_case = KDF9_char_sets.Case_Normal then
   446.                         symbol := CN_TR(char);
   447.                      else
   448.                         symbol := CS_TR(char);
   449.                      end if;
   450.                      store_symbol(symbol, w, c);
   451.                      size := size + 1;
   452.                      if transfer_to_EM and symbol = KDF9_char_sets.End_Message then
   453.                         for d in 1 .. 7-c loop
   454.                            store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
   455.                         end loop;
   456.                         exit word_loop;
   457.                      end if;
   458.                   end if;
   459.
   460.             end case;
   461.          end loop;
   462.       end loop word_loop;
   463.
   464.       flush(the_FW.output, the_pause);
   465.       set_text_style_to_plain(the_FW.output);
   466.       set_text_colour_to_black(the_FW.output);
   467.       do_output_housekeeping(the_FW, written => size-fill, fetched => size);
   468.       flush(the_FW.output);
   469.    exception
   470.       when end_of_stream =>
   471.          flush(the_FW.output);
   472.          set_text_colour_to_black(the_FW.output);
   473.          set_text_style_to_plain(the_FW.output);
   474.          do_output_housekeeping(the_FW, written => size-fill, fetched => size);
   475.    end put_symbols;
   476.
   477.    overriding
   478.    procedure write (the_FW    : in out FW.device;
   479.                     Q_operand : in KDF9.Q_register) is
   480.    begin
   481.       put_symbols(the_FW, Q_operand, transfer_to_EM => False);
   482.    end write;
   483.
   484.    overriding
   485.    procedure write_to_EM (the_FW    : in out FW.device;
   486.                           Q_operand : in KDF9.Q_register) is
   487.    begin
   488.       put_symbols(the_FW, Q_operand, transfer_to_EM => True);
   489.    end write_to_EM;
   490.
   491.    -- TWQq
   492.    overriding
   493.    procedure POA (the_FW      : in out FW.device;
   494.                   Q_operand   : in KDF9.Q_register;
   495.                   set_offline : in Boolean) is
   496.    begin
   497.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   498.       write(the_FW, Q_operand);
   499.       lock_out_relative_addresses(Q_operand);
   500.       reset(the_FW.stream);
   501.    end POA;
   502.
   503.    -- TWEQq
   504.    overriding
   505.    procedure POB (the_FW      : in out FW.device;
   506.                   Q_operand   : in KDF9.Q_register;
   507.                   set_offline : in Boolean) is
   508.    begin
   509.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   510.       write_to_EM(the_FW, Q_operand);
   511.       lock_out_relative_addresses(Q_operand);
   512.       -- reset(the_FW.stream);
   513.    end POB;
   514.
   515.    procedure put_words (the_FW         : in out FW.device;
   516.                         Q_operand      : in KDF9.Q_register;
   517.                         transfer_to_EM : in Boolean := False) is
   518.       start_address : constant KDF9.address := Q_operand.I;
   519.       end_address   : constant KDF9.address := Q_operand.M;
   520.       size : KDF9.word := 0;
   521.       word : KDF9.word;
   522.       char : Character;
   523.    begin
   524.       check_addresses_and_lockouts(start_address, end_address);
   525.       set_the_duration_of_the_pause(the_FW);
   526.       the_FW.mode := the_flexowriter_is_writing;
   527.       set_text_style_to_plain(the_FW.output);
   528.       set_text_colour_to_red(the_FW.output);
   529.    word_loop:
   530.       for w in start_address .. end_address loop
   531.          case the_FW.mode is
   532.
   533.             when the_flexowriter_is_writing =>
   534.                word := fetch_word(w) and 8#377#;
   535.                size := size + 1;
   536.                char := Character'Val(word);
   537.
   538.                if word = KDF9_char_sets.Semi_Colon_tape_bits then
   539.                   -- Hypothesis: POC and POD act like POA and POB with respect to prompting;
   540.                   --    and change from writing to reading after the output of any word that has
   541.                   --       the KDF9 FW tape code for a semicolon in its least significant 8 bits.
   542.                   declare
   543.                      the_prompt : constant String := contents(the_FW.output);
   544.                   begin
   545.                      -- Must flush AFTER saving the prompt and BEFORE going black.
   546.                      flush(the_FW.output, the_pause);
   547.                      set_text_colour_to_black(the_FW.output);
   548.                      set_text_style_to_plain(the_FW.output);
   549.                      put_byte(';', the_FW.output);
   550.                      flush(the_FW.output, the_pause);
   551.
   552.                      inject_a_response(the_FW, neat(the_prompt), size);
   553.
   554.                      the_FW.mode := the_flexowriter_is_reading;
   555.                      set_text_style_to_plain(the_FW.output);
   556.                   end;
   557.                elsif flexowriter_output_is_wanted then
   558.
   559.                         if char = '_' then
   560.                            underlined := True;
   561.                            do_not_put_byte(char, the_FW.output);
   562.                            flush(the_FW.output, the_pause);
   563.                         else
   564.                            if underlined then
   565.                               set_text_style_to_underline(the_FW.output);
   566.                            end if;
   567.                            put_char(char, the_FW.output);
   568.                            if underlined then
   569.                               flush(the_FW.output, the_pause);
   570.                               set_text_style_to_plain(the_FW.output);
   571.                               set_text_colour_to_red(the_FW.output);
   572.                               underlined := False;
   573.                            end if;
   574.                         end if;
   575.       exit word_loop when transfer_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   576.                end if;
   577.
   578.             when the_flexowriter_is_reading =>
   579.                get_char(char, the_FW.stream);
   580.                size := size + 1;
   581.                word := KDF9.word(Character'Pos(char));
   582.                store_word(word, w);
   583.       exit word_loop when transfer_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   584.
   585.          end case;
   586.       end loop word_loop;
   587.
   588.       flush(the_FW.output);
   589.       set_text_colour_to_black(the_FW.output);
   590.       set_text_style_to_plain(the_FW.output);
   591.       do_output_housekeeping(the_FW, written => size, fetched => size);
   592.    exception
   593.       when end_of_stream =>
   594.          flush(the_FW.output);
   595.          set_text_colour_to_black(the_FW.output);
   596.          set_text_style_to_plain(the_FW.output);
   597.          do_output_housekeeping(the_FW, written => size, fetched => size);
   598.    end put_words;
   599.
   600.    overriding
   601.    procedure words_write (the_FW    : in out FW.device;
   602.                           Q_operand : in KDF9.Q_register) is
   603.    begin
   604.       put_words(the_FW, Q_operand, transfer_to_EM => False);
   605.    end words_write;
   606.
   607.    overriding
   608.    procedure words_write_to_EM (the_FW    : in out FW.device;
   609.                                 Q_operand : in KDF9.Q_register) is
   610.    begin
   611.       put_words(the_FW, Q_operand, transfer_to_EM => True);
   612.    end words_write_to_EM;
   613.
   614.    -- TWCQq
   615.    overriding
   616.    procedure POC (the_FW      : in out FW.device;
   617.                   Q_operand   : in KDF9.Q_register;
   618.                   set_offline : in Boolean) is
   619.    begin
   620.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   621.       words_write(the_FW, Q_operand);
   622.       lock_out_relative_addresses(Q_operand);
   623.    end POC;
   624.
   625.    -- TWECQq
   626.    overriding
   627.    procedure POD (the_FW      : in out FW.device;
   628.                   Q_operand   : in KDF9.Q_register;
   629.                   set_offline : in Boolean) is
   630.    begin
   631.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   632.       words_write_to_EM(the_FW, Q_operand);
   633.       lock_out_relative_addresses(Q_operand);
   634.    end POD;
   635.
   636.    overriding
   637.    procedure Finalize (the_FW : in out FW.device) is
   638.       total : constant KDF9.word := the_FW.output.bytes_moved+the_FW.stream.bytes_moved + the_FW.shifts;
   639.    begin
   640.       close(
   641.            the_FW,
   642.            "transferred",
   643.            total,
   644.            "character" & plurality(total)
   645.           );
   646.    end Finalize;
   647.
   648.    -- This is the monitor console Flexowriter.
   649.
   650.    type FW_access is access FW.device;
   651.
   652.    FW0 : FW_access with Warnings => Off;
   653.
   654.    already_enabled : Boolean := False;
   655.
   656.    procedure enable (b : in KDF9.buffer_number) is
   657.    begin
   658.       if already_enabled then
   659.          trap_operator_error("more than one FW unit has been configured");
   660.       end if;
   661.       if b /= 0 then
   662.          trap_operator_error("FW0 must be on buffer 0");
   663.       end if;
   664.       FW0 := new FW.device (number => b, unit => 0);
   665.       already_enabled := True;
   666.    end enable;
   667.
   668. end IOC.slow.shift.FW;
   669.

Compiling: ../Source/ioc-slow-shift-fw.ads
Source file time stamp: 2021-02-15 01:22:26
Compiled at: 2021-02-21 15:54:08

     1. -- Emulation of a FlexoWriter buffer: monitor typewriter functionality.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.FW is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    function a_LF_was_just_read (the_FW : FW.device)
    22.    return Boolean;
    23.
    24.    function a_LF_was_just_written (the_FW : FW.device)
    25.    return Boolean;
    26.
    27.    -- TRQq
    28.    overriding
    29.    procedure PIA (the_FW      : in out FW.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    -- TREQq
    34.    overriding
    35.    procedure PIB (the_FW      : in out FW.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    -- TRCQq character read
    40.    overriding
    41.    procedure PIC (the_FW      : in out FW.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    -- TRECQq character read to End_Message
    46.    overriding
    47.    procedure PID (the_FW      : in out FW.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- as PIA
    52.    overriding
    53.    procedure PIE (the_FW      : in out FW.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- as PIB
    58.    overriding
    59.    procedure PIF (the_FW      : in out FW.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    -- as PIC
    64.    overriding
    65.    procedure PIG (the_FW      : in out FW.device;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    -- as PID
    70.    overriding
    71.    procedure PIH (the_FW      : in out FW.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    -- TWQq
    76.    overriding
    77.    procedure POA (the_FW      : in out FW.device;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    -- TWEQq
    82.    overriding
    83.    procedure POB (the_FW      : in out FW.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    -- NB the following assumes that page 285 of the Manual is erroneous,
    88.    -- and that POC and POD for the Flexowriter are analogous to the tape punch,
    89.    -- as other sources, such as the "Usecode Digest", do in fact indicate.
    90.
    91.    -- TWCQq character write
    92.    overriding
    93.    procedure POC (the_FW      : in out FW.device;
    94.                   Q_operand   : in KDF9.Q_register;
    95.                   set_offline : in Boolean);
    96.
    97.    -- TWECQq character write to End_Message
    98.    overriding
    99.    procedure POD (the_FW      : in out FW.device;
   100.                   Q_operand   : in KDF9.Q_register;
   101.                   set_offline : in Boolean);
   102.
   103.    procedure enable (b : in KDF9.buffer_number);
   104.
   105. private
   106.
   107.    type flexowriter_mode is
   108.       (the_flexowriter_is_reading, the_flexowriter_is_writing);
   109.
   110.    -- The Flexowriter has separate input and output streams, to accommodate the console I/O API
   111.    --    of MS Windows, which requires separate pseudo-devices for input and output.
   112.    type device is new IOC.slow.shift.device with
   113.       record
   114.          output : host_IO.stream;
   115.          mode   : FW.flexowriter_mode;
   116.          shifts : KDF9.word := 0;
   117.       end record;
   118.
   119.    overriding
   120.    procedure Initialize (the_FW : in out FW.device);
   121.
   122.    overriding
   123.    procedure Finalize (the_FW : in out FW.device);
   124.
   125.    overriding
   126.    function kind (the_FW : FW.device)
   127.    return IOC.device_kind
   128.    is (FW_kind);
   129.
   130.    overriding
   131.    function quantum (the_FW : FW.device)
   132.    return KDF9.us
   133.    is (1E6 / 10);
   134.
   135.    overriding
   136.    procedure write (the_FW    : in out FW.device;
   137.                     Q_operand : in KDF9.Q_register);
   138.
   139.    overriding
   140.    procedure write_to_EM (the_FW    : in out FW.device;
   141.                           Q_operand : in KDF9.Q_register);
   142.    overriding
   143.    procedure words_write (the_FW    : in out FW.device;
   144.                           Q_operand : in KDF9.Q_register);
   145.
   146.    overriding
   147.    procedure words_write_to_EM (the_FW    : in out FW.device;
   148.                                 Q_operand : in KDF9.Q_register);
   149.
   150.    overriding
   151.    procedure do_output_housekeeping (the_FW   : in out FW.device;
   152.                                      written,
   153.                                      fetched  : in KDF9.word);
   154.
   155. end IOC.slow.shift.FW;

 669 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-gp.adb
Source file time stamp: 2021-02-19 16:40:08
Compiled at: 2021-02-21 15:54:08

     1. -- Emulation of a Calcomp 564 graph plotter, switched to a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16. with plotter;
    17. with postscript;
    18.
    19. use  plotter;
    20. use  postscript;
    21.
    22. package body IOC.slow.shift.GP is
    23.
    24.    overriding
    25.    procedure Initialize (the_GP : in out GP.device) is
    26.    begin
    27.       -- Ready the graph plotter driver and PostScript output file.
    28.       the_GP.device_name := device_name_of(the_GP);
    29.       open(the_GP.stream, the_GP.device_name, write_mode);
    30.       IOC.device(the_GP).Initialize;
    31.       if the_GP.is_open then
    32.          truncate(the_GP.stream);
    33.          initialize_PS_output(the_GP.stream);
    34.          open_the_plot_file(the_GP.stream);
    35.       end if;
    36.    end Initialize;
    37.
    38.    overriding
    39.    procedure Finalize (the_GP : in out GP.device) is
    40.    begin
    41.       if the_GP.is_open           and then
    42.             the_GP.byte_count /= 0    then
    43.          if the_final_state_is_wanted then
    44.             log_line(
    45.                      the_GP.device_name
    46.                    & " on buffer #"
    47.                    & oct_of(KDF9.Q_part(the_GP.number), 2)
    48.                    & " made"
    49.                    & the_GP.byte_count'Image
    50.                    & plurality(the_GP.byte_count, " plotting step.", " plotting steps.")
    51.                     );
    52.          end if;
    53.          the_GP.byte_count := 0;
    54.          close_the_plot_file(the_GP.stream);
    55.          finalize_PS_output(the_GP.stream);
    56.       end if;
    57.    end Finalize;
    58.
    59.    -- the_T_bit_is_set (the buffer has been switched from a tape punch to a graph plotter)
    60.    overriding
    61.    procedure PMB (the_GP      : in out GP.device;
    62.                   Q_operand   : in KDF9.Q_register;
    63.                   set_offline : in Boolean) is
    64.    begin
    65.       validate_device(the_GP);
    66.       validate_parity(the_GP);
    67.       deal_with_a_busy_device(the_GP, 13, set_offline);
    68.       the_T_bit_is_set := True;
    69.       take_note_of_test(the_GP.device_name, Q_operand, the_T_bit_is_set);
    70.    end PMB;
    71.
    72.    GP_lift_time : constant := 1E6 /  10;           -- 10 pen up/down movements per second.
    73.    lift_ratio   : constant := GP_lift_time / 200;  -- the number of steps made in a lift time
    74.
    75.    overriding
    76.    procedure do_output_housekeeping (the_GP      : in out GP.device;
    77.                                      size, lifts : in     KDF9.word) is
    78.    begin
    79.       add_in_the_IO_CPU_time(the_GP, size);
    80.       correct_transfer_time(the_GP, size - lifts + lifts * lift_ratio);
    81.    end do_output_housekeeping;
    82.
    83.    procedure put_symbols (the_GP    : in out GP.device;
    84.                           Q_operand : in KDF9.Q_register) is
    85.       start_address : constant KDF9.address := Q_operand.I;
    86.       end_address   : constant KDF9.address := Q_operand.M;
    87.       size    : KDF9.word := 0;
    88.       lifts   : KDF9.word := 0;
    89.       command : plotter.command;
    90.    begin
    91.       check_addresses_and_lockouts(start_address, end_address);
    92.    word_loop:
    93.       for w in start_address .. end_address loop
    94.          for c in KDF9_char_sets.symbol_index'Range loop
    95.             command := plotter.command(fetch_symbol(w, c));
    96.             perform(command, the_GP.stream);
    97.             size := size + 1;
    98.             the_GP.byte_count := the_GP.byte_count + 1;
    99.             if command in pen_up | pen_down then
   100.                -- These actions are much slower than plotting movements.
   101.                lifts := lifts + 1;
   102.             end if;
   103.          end loop;
   104.       end loop word_loop;
   105.       do_output_housekeeping (the_GP, size, lifts);
   106.    end put_symbols;
   107.
   108.    overriding
   109.    procedure POA (the_GP      : in out GP.device;
   110.                   Q_operand   : in KDF9.Q_register;
   111.                   set_offline : in Boolean) is
   112.    begin
   113.       start_slow_transfer(the_GP, Q_operand, set_offline, output_operation);
   114.       put_symbols(the_GP, Q_operand);
   115.       lock_out_relative_addresses(Q_operand);
   116.    end POA;
   117.
   118.    overriding
   119.    procedure POB (the_GP      : in out GP.device;
   120.                   Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean) is
   122.    begin
   123.       -- See the Manual Appendix 6, 5.2, p.303.
   124.       POA(the_GP, Q_operand, set_offline);
   125.    end POB;
   126.
   127.    procedure put_words (the_GP    : in out GP.device;
   128.                         Q_operand : in KDF9.Q_register) is
   129.       start_address : constant KDF9.address := Q_operand.I;
   130.       end_address   : constant KDF9.address := Q_operand.M;
   131.       size    : KDF9.word := 0;
   132.       lifts   : KDF9.word := 0;
   133.       command : plotter.command;
   134.    begin
   135.       check_addresses_and_lockouts(start_address, end_address);
   136.       for w in start_address .. end_address loop
   137.          -- Ony the last 6 bits (character 7) of each word are used.
   138.          command := plotter.command(fetch_symbol(w, 7));
   139.          perform(command, the_GP.stream);
   140.          size := size + 1;
   141.          the_GP.byte_count := the_GP.byte_count + 1;
   142.          if command in pen_up | pen_down then
   143.             -- These actions are much slower than plotting movements.
   144.             lifts := lifts + 1;
   145.          end if;
   146.       end loop;
   147.       do_output_housekeeping (the_GP, size, lifts);
   148.    end put_words;
   149.
   150.    overriding
   151.    procedure POC (the_GP      : in out GP.device;
   152.                   Q_operand   : in KDF9.Q_register;
   153.                   set_offline : in Boolean) is
   154.    begin
   155.       start_slow_transfer(the_GP, Q_operand, set_offline, output_operation);
   156.       put_words(the_GP, Q_operand);
   157.       lock_out_relative_addresses(Q_operand);
   158.    end POC;
   159.
   160.    overriding
   161.    procedure POD (the_GP      : in out GP.device;
   162.                   Q_operand   : in KDF9.Q_register;
   163.                   set_offline : in Boolean) is
   164.    begin
   165.       -- See the Manual Appendix 6, 5.2, p.303.
   166.       POC(the_GP, Q_operand, set_offline);
   167.    end POD;
   168.
   169.    type GP_access is access GP.device;
   170.
   171.    GP0 : GP_access with Warnings => Off;
   172.
   173.    procedure enable (b : in KDF9.buffer_number) is
   174.    begin
   175.       GP0 := new GP.device (number => b, unit => 0);
   176.       GP0_number := b;
   177.    end enable;
   178.
   179.    procedure replace_on_buffer (b : in KDF9.buffer_number) is
   180.    begin
   181.       if GP0 /= null and then
   182.             b = GP0_number then
   183.          return;
   184.       end if;
   185.       buffer(b) := null;
   186.       enable(b);
   187.    end replace_on_buffer;
   188.
   189.    procedure notify_invalid_movement (from_x, from_y, step_x, step_y : in Integer) is
   190.    begin
   191.       trap_failing_IO_operation(
   192.                                 GP0.all,
   193.                                 "cannot move from <"
   194.                               & trimmed(from_x'Image)
   195.                               & ","
   196.                               & from_y'Image
   197.                               & "> by <"
   198.                               & trimmed(step_x'Image)
   199.                               & ","
   200.                               & step_y'Image
   201.                               & ">"
   202.                                );
   203.    end notify_invalid_movement;
   204.
   205. end IOC.slow.shift.GP;

Compiling: ../Source/ioc-slow-shift-gp.ads
Source file time stamp: 2021-02-15 01:18:52
Compiled at: 2021-02-21 15:54:08

     1. -- Emulation of a Calcomp 564 graph plotter, switched to a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.GP is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    overriding
    22.    procedure POA (the_GP      : in out GP.device;
    23.                   Q_operand   : in KDF9.Q_register;
    24.                   set_offline : in Boolean);
    25.
    26.    overriding
    27.    procedure POB (the_GP      : in out GP.device;
    28.                   Q_operand   : in KDF9.Q_register;
    29.                   set_offline : in Boolean);
    30.
    31.    overriding
    32.    procedure POC (the_GP      : in out GP.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    overriding
    37.    procedure POD (the_GP      : in out GP.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    -- the_T_bit_is_set (buffer is switched to graph plotter)
    42.    overriding
    43.    procedure PMB (the_GP      : in out GP.device;
    44.                   Q_operand   : in KDF9.Q_register;
    45.                   set_offline : in Boolean);
    46.
    47.    procedure enable (b : in KDF9.buffer_number);
    48.
    49.    procedure replace_on_buffer (b : in KDF9.buffer_number);
    50.
    51.    procedure notify_invalid_movement (from_x, from_y, step_x, step_y : in Integer)
    52.       with Inline => False;
    53.
    54. private
    55.
    56.    type device is new IOC.slow.shift.device with null record;
    57.
    58.    overriding
    59.    procedure Initialize (the_GP : in out GP.device);
    60.
    61.    overriding
    62.    procedure Finalize (the_GP : in out GP.device);
    63.
    64.    overriding
    65.    function kind (the_GP : GP.device)
    66.    return IOC.device_kind
    67.    is (GP_kind);
    68.
    69.    overriding
    70.    function quantum (the_GP : GP.device)
    71.    return KDF9.us
    72.    is (1E6 / 200);
    73.
    74.    overriding
    75.    procedure do_output_housekeeping (the_GP      : in out GP.device;
    76.                                      size, lifts : in     KDF9.word);
    77.
    78. end IOC.slow.shift.GP;

 205 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-si.adb
Source file time stamp: 2021-02-19 16:40:08
Compiled at: 2021-02-21 15:54:08

     1. -- Emulation of a standard interface buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.shift.SI is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_SI : in out SI.device) is
    23.    begin
    24.       -- Open the associated file.
    25.       open(IOC.device(the_SI), rd_wr_mode);
    26.    end Initialize;
    27.
    28.    overriding
    29.    procedure PIA (the_SI      : in out SI.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean) is
    32.    begin
    33.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    34.       read(the_SI, Q_operand);
    35.       lock_out_relative_addresses(Q_operand);
    36.    end PIA;
    37.
    38.    overriding
    39.    procedure PIB (the_SI      : in out SI.device;
    40.                   Q_operand   : in KDF9.Q_register;
    41.                   set_offline : in Boolean) is
    42.    begin
    43.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    44.       read_to_EM(the_SI, Q_operand);
    45.       lock_out_relative_addresses(Q_operand);
    46.    end PIB;
    47.
    48.    overriding
    49.    procedure PIC (the_SI      : in out SI.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean) is
    52.    begin
    53.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    54.       words_read(the_SI, Q_operand);
    55.       lock_out_relative_addresses(Q_operand);
    56.    end PIC;
    57.
    58.    overriding
    59.    procedure PID (the_SI      : in out SI.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean) is
    62.    begin
    63.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    64.       words_read_to_EM(the_SI, Q_operand);
    65.       lock_out_relative_addresses(Q_operand);
    66.    end PID;
    67.
    68.    overriding
    69.    procedure PIE (the_SI      : in out SI.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean) is
    72.    begin
    73.       -- as PIA: "parity off" has no effect on the data read in
    74.       PIA(the_SI, Q_operand, set_offline);
    75.    end PIE;
    76.
    77.    overriding
    78.    procedure PIF (the_SI      : in out SI.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean) is
    81.    begin
    82.       -- as PIB: "parity off" has no effect on the data read in
    83.       PIB(the_SI, Q_operand, set_offline);
    84.    end PIF;
    85.
    86.    overriding
    87.    procedure PIG (the_SI      : in out SI.device;
    88.                   Q_operand   : in KDF9.Q_register;
    89.                   set_offline : in Boolean) is
    90.    begin
    91.       PIC(the_SI, Q_operand, set_offline);
    92.    end PIG;
    93.
    94.    overriding
    95.    procedure PIH (the_SI      : in out SI.device;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean) is
    98.    begin
    99.       PID(the_SI, Q_operand, set_offline);
   100.    end PIH;
   101.
   102.    overriding
   103.    procedure PMB (the_SI      : in out SI.device;
   104.                   Q_operand   : in KDF9.Q_register;
   105.                   set_offline : in Boolean) is
   106.    begin
   107.       -- ee9's SI0 always asserts 8 channel mode.
   108.       validate_device(the_SI);
   109.       validate_parity(the_SI);
   110.       deal_with_a_busy_device(the_SI, 13, set_offline);
   111.       the_T_bit_is_set := True;
   112.       take_note_of_test(the_SI.device_name, Q_operand, the_T_bit_is_set);
   113.    end PMB;
   114.
   115.    overriding
   116.    procedure PMC (the_SI      : in out SI.device;
   117.                   Q_operand   : in KDF9.Q_register;
   118.                   set_offline : in Boolean) is
   119.    begin
   120.       PMB(the_SI, Q_operand, set_offline);
   121.    end PMC;
   122.
   123.    overriding
   124.    procedure POA (the_SI      : in out SI.device;
   125.                   Q_operand   : in KDF9.Q_register;
   126.                   set_offline : in Boolean) is
   127.    begin
   128.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   129.       write(the_SI, Q_operand);
   130.       lock_out_relative_addresses(Q_operand);
   131.    end POA;
   132.
   133.    overriding
   134.    procedure POB (the_SI      : in out SI.device;
   135.                   Q_operand   : in KDF9.Q_register;
   136.                   set_offline : in Boolean) is
   137.    begin
   138.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   139.       write_to_EM(the_SI, Q_operand);
   140.       lock_out_relative_addresses(Q_operand);
   141.    end POB;
   142.
   143.    overriding
   144.    procedure POC (the_SI      : in out SI.device;
   145.                   Q_operand   : in KDF9.Q_register;
   146.                   set_offline : in Boolean) is
   147.    begin
   148.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   149.       words_write(the_SI, Q_operand);
   150.       lock_out_relative_addresses(Q_operand);
   151.    end POC;
   152.
   153.    overriding
   154.    procedure POD (the_SI      : in out SI.device;
   155.                   Q_operand   : in KDF9.Q_register;
   156.                   set_offline : in Boolean) is
   157.    begin
   158.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   159.       words_write_to_EM(the_SI, Q_operand);
   160.       lock_out_relative_addresses(Q_operand);
   161.    end POD;
   162.
   163.    overriding
   164.    procedure POE (the_SI      : in out SI.device;
   165.                   Q_operand   : in KDF9.Q_register;
   166.                   set_offline : in Boolean) is
   167.    begin
   168.       require_nonnegative_count(Q_operand.M);
   169.       output_a_gap(the_SI, Q_operand, set_offline, word_mode => False, text_mode => False);
   170.    end POE;
   171.
   172.    overriding
   173.    procedure POF (the_SI      : in out SI.device;
   174.                   Q_operand   : in KDF9.Q_register;
   175.                   set_offline : in Boolean) is
   176.    begin
   177.       require_nonnegative_count(Q_operand.M);
   178.       output_a_gap(the_SI, Q_operand, set_offline, word_mode => True, text_mode => False);
   179.    end POF;
   180.
   181.    overriding
   182.    procedure Finalize (the_SI : in out SI.device) is
   183.    begin
   184.       close(
   185.             the_SI,
   186.             "transferred",
   187.             the_SI.byte_count,
   188.             "character" & plurality(the_SI.byte_count)
   189.            );
   190.    end Finalize;
   191.
   192.    type SI_access is access SI.device;
   193.
   194.    SI0 : SI_access with Warnings => Off;
   195.    SI1 : SI_access with Warnings => Off;
   196.
   197.    unit : IOC.unit_number := 0;
   198.
   199.    procedure enable (b : in KDF9.buffer_number) is
   200.    begin
   201.       case unit is
   202.          when 0 =>
   203.             SI0 := new SI.device (number => b, unit => 0);
   204.             SI0_number := b;
   205.          when 1 =>
   206.             SI1 := new SI.device (number => b, unit => 1);
   207.             SI1_number := b;
   208.          when others =>
   209.             trap_operator_error("more than two SI units have been configured");
   210.       end case;
   211.       unit := unit + 1;
   212.    end enable;
   213.
   214.    procedure replace_on_buffer (b : in KDF9.buffer_number) is
   215.    begin
   216.       if SI0 /= null   and then
   217.             SI0.number = b then
   218.          return;
   219.       end if;
   220.       if SI1 /= null   and then
   221.             SI1.number = b then
   222.          return;
   223.       end if;
   224.       buffer(b) := null;
   225.       enable(b);
   226.    end replace_on_buffer;
   227.
   228.    function SI0_is_enabled
   229.    return Boolean
   230.    is (SI0 /= null or SI1 /= null);
   231.
   232. end IOC.slow.shift.SI;

Compiling: ../Source/ioc-slow-shift-si.ads
Source file time stamp: 2021-02-15 01:22:44
Compiled at: 2021-02-21 15:54:08

     1. -- Emulation of a standard interface buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.SI is
    18.
    19.    -- The Standard Interface Buffer is the KDF9 device about which least is presently known.
    20.    -- Anecdotal evidence suggests it is an implementation of the British Standard Interface (BSIF).
    21.    -- ee9 implements a best guess as to its functionality, based on the following considerations.
    22.
    23.    -- According to the Manual, Appendix 6.1, p.296,
    24.    --    the Standard Interface Buffer has orders that look very like the union of a TR and a TP.
    25.
    26.    -- However:
    27.
    28.    -- (a) PIE and PIF do a read with "parity off".
    29.    --     I think this relates to a feature of the BSIF,
    30.    --        whereby a source device can omit parity if it de-asserts its "parity valid" signal.
    31.    --     With such a device the KDF9 would need a way of ignoring spurious parity errors.
    32.    -- PIE/PIF act in exactly the same way as PIA/PIB as there will be no such error under ee9.
    33.
    34.    -- (b) PMB and PMC set the Test Register "if 8 channel set".  The BSIF is 8 data bits wide.
    35.    --     I think this signals that the KDF9 should use "character" orders to access all 8 bits,
    36.    --        and I think that the other orders access only the low-order 6 bits of the interface.
    37.    -- ee9 always asserts "8 channel set", as it is always capable of providing 8-bit bytes.
    38.
    39.    -- In any case, 6-bit transfers work in the same way as for paper tape readers and punches.
    40.
    41.    type device is new IOC.slow.shift.device with private;
    42.
    43.    overriding
    44.    procedure PIA (the_SI      : in out SI.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    overriding
    49.    procedure PIB (the_SI      : in out SI.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    overriding
    54.    procedure PIC (the_SI      : in out SI.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    overriding
    59.    procedure PID (the_SI      : in out SI.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    overriding
    64.    procedure PIE (the_SI      : in out SI.device;
    65.                   Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    overriding
    69.    procedure PIF (the_SI      : in out SI.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean);
    72.
    73.    overriding
    74.    procedure PIG (the_SI      : in out SI.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.
    78.    overriding
    79.    procedure PIH (the_SI      : in out SI.device;
    80.                   Q_operand   : in KDF9.Q_register;
    81.                   set_offline : in Boolean);
    82.
    83.    overriding
    84.    procedure PMB (the_SI      : in out SI.device;
    85.                   Q_operand   : in KDF9.Q_register;
    86.                   set_offline : in Boolean);
    87.
    88.    overriding
    89.    procedure PMC (the_SI      : in out SI.device;
    90.                   Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean);
    92.
    93.    overriding
    94.    procedure POA (the_SI      : in out SI.device;
    95.                   Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean);
    97.
    98.    overriding
    99.    procedure POB (the_SI      : in out SI.device;
   100.                   Q_operand   : in KDF9.Q_register;
   101.                   set_offline : in Boolean);
   102.
   103.    overriding
   104.    procedure POC (the_SI      : in out SI.device;
   105.                   Q_operand   : in KDF9.Q_register;
   106.                   set_offline : in Boolean);
   107.
   108.    overriding
   109.    procedure POD (the_SI      : in out SI.device;
   110.                   Q_operand   : in KDF9.Q_register;
   111.                   set_offline : in Boolean);
   112.
   113.    overriding
   114.    procedure POE (the_SI      : in out SI.device;
   115.                   Q_operand   : in KDF9.Q_register;
   116.                   set_offline : in Boolean);
   117.
   118.    overriding
   119.    procedure POF (the_SI      : in out SI.device;
   120.                   Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean);
   122.
   123.    procedure enable (b : in KDF9.buffer_number);
   124.
   125.    procedure replace_on_buffer (b : in KDF9.buffer_number);
   126.
   127.    function SI0_is_enabled
   128.    return Boolean;
   129.
   130. private
   131.
   132.    type device is new IOC.slow.shift.device with null record;
   133.
   134.    overriding
   135.    procedure Initialize (the_SI : in out SI.device);
   136.
   137.    overriding
   138.    procedure Finalize (the_SI : in out SI.device);
   139.
   140.    overriding
   141.    function kind (the_SI : SI.device)
   142.    return IOC.device_kind
   143.    is (SI_kind);
   144.
   145.    overriding
   146.    function quantum (the_SI : SI.device)
   147.    return KDF9.us
   148.    is (1E6 / 50E3); -- I am guessing 50_000 characters per second.
   149.
   150. end IOC.slow.shift.SI;

 232 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-unit.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:08

     1. -- Emulation of the common functionality of "unit record" (i.e. LP, CP or CR) devices.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.unit is
    18.
    19.    overriding
    20.    function IO_elapsed_time_total (the_buffer : unit.device)
    21.    return KDF9.us is
    22.    begin
    23.       return IO_elapsed_time(the_buffer, the_buffer.unit_count);
    24.    end IO_elapsed_time_total;
    25.
    26.    overriding
    27.    function atomic_item_count (the_buffer : unit.device;
    28.                                Q_operand  : KDF9.Q_register)
    29.    return KDF9.word is
    30.       pragma Unreferenced(the_buffer);
    31.       pragma Unreferenced(Q_operand);
    32.    begin
    33.       return 1;
    34.    end atomic_item_count;
    35.
    36. end IOC.slow.unit;

Compiling: ../Source/ioc-slow-unit.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:08

     1. -- Emulation of the common functionality of "unit record" (i.e. LP, CP or CR) devices.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.unit is
    18.
    19.    --
    20.    -- This is the root type for all unit-record I/O device types.
    21.    --
    22.
    23.    type device is abstract new IOC.slow.device with private;
    24.
    25. private
    26.
    27.    type device is abstract new IOC.slow.device with
    28.       record
    29.          unit_count : KDF9.word := 0;
    30.       end record;
    31.
    32.    overriding
    33.    function IO_elapsed_time_total (the_buffer : unit.device)
    34.    return KDF9.us;
    35.
    36.    overriding
    37.    function atomic_item_count (the_buffer : unit.device;
    38.                                Q_operand  : KDF9.Q_register)
    39.    return KDF9.word;
    40.
    41. end IOC.slow.unit;

 36 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-unit-cp.adb
Source file time stamp: 2021-02-15 01:11:41
Compiled at: 2021-02-21 15:54:08

     1. -- Emulation of a card punch buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.unit.CP is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_CP : in out CP.device) is
    23.    begin
    24.       open(the_CP, write_mode);
    25.    end Initialize;
    26.
    27.    procedure do_output_housekeeping (the_CP     : in out CP.device;
    28.                                      fetched    : in KDF9.word) is
    29.    begin
    30.       correct_transfer_time(the_CP, actual_length => 1);
    31.       add_in_the_IO_CPU_time(the_CP, fetched);
    32.    end do_output_housekeeping;
    33.
    34.    procedure write_card (the_CP        : in out CP.device;
    35.                          Q_operand     : in KDF9.Q_register;
    36.                          max_words     : in KDF9.address;
    37.                          writing_to_EM : in Boolean := False) is
    38.       start_address : constant KDF9.address := Q_operand.I;
    39.       end_address   : constant KDF9.address := Q_operand.M;
    40.       size : KDF9.word := 0;
    41.       char : Character;
    42.       byte : KDF9_char_sets.symbol;
    43.    begin
    44.       check_addresses_and_lockouts(start_address, end_address);
    45.    word_loop:
    46.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    47.          for c in KDF9_char_sets.symbol_index'Range loop
    48.             byte := fetch_symbol(w, c);
    49.             size := size + 1;
    50.             char := to_CP(byte);
    51.             put_byte(char, the_CP.stream);
    52.             exit word_loop when writing_to_EM and char = KDF9_char_sets.E_M;
    53.          end loop;
    54.       end loop word_loop;
    55.       put_EOL(the_CP.stream);
    56.       the_CP.unit_count := the_CP.unit_count + 1;
    57.       do_output_housekeeping(the_CP, fetched => size);
    58.    end write_card;
    59.
    60.    procedure words_write_card (the_CP        : in out CP.device;
    61.                                Q_operand     : in KDF9.Q_register;
    62.                                max_words     : in KDF9.address;
    63.                                writing_to_EM : in Boolean := False) is
    64.
    65.       start_address : constant KDF9.address := Q_operand.I;
    66.       end_address   : constant KDF9.address := Q_operand.M;
    67.       size : KDF9.word := 0;
    68.       char : Character;
    69.       byte : KDF9_char_sets.symbol;
    70.    begin
    71.       check_addresses_and_lockouts(start_address, end_address);
    72.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    73.          byte := KDF9_char_sets.symbol(fetch_word(w) and 8#77#);
    74.          size := size + 1;
    75.          char := to_CP(byte);
    76.          put_byte(char, the_CP.stream);
    77.       exit when writing_to_EM and char = KDF9_char_sets.E_M;
    78.       end loop;
    79.       put_EOL(the_CP.stream);
    80.       the_CP.unit_count := the_CP.unit_count + 1;
    81.       do_output_housekeeping(the_CP, fetched => size);
    82.    end words_write_card;
    83.
    84.    overriding
    85.    procedure POA (the_CP      : in out CP.device;
    86.                   Q_operand   : in KDF9.Q_register;
    87.                   set_offline : in Boolean) is
    88.    begin
    89.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
    90.       write_card(the_CP, Q_operand, max_words => 20);
    91.       lock_out_relative_addresses(Q_operand);
    92.    end POA;
    93.
    94.    overriding
    95.    procedure POB (the_CP      : in out CP.device;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean) is
    98.    begin
    99.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   100.       write_card(the_CP, Q_operand, max_words => 20, writing_to_EM => True);
   101.       lock_out_relative_addresses(Q_operand);
   102.    end POB;
   103.
   104.    overriding
   105.    procedure POC (the_CP      : in out CP.device;
   106.                   Q_operand   : in KDF9.Q_register;
   107.                   set_offline : in Boolean) is
   108.    begin
   109.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   110.       words_write_card(the_CP, Q_operand, max_words => 160);
   111.       lock_out_relative_addresses(Q_operand);
   112.    end POC;
   113.
   114.    overriding
   115.    procedure POD (the_CP      : in out CP.device;
   116.                   Q_operand   : in KDF9.Q_register;
   117.                   set_offline : in Boolean) is
   118.    begin
   119.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   120.       words_write_card(the_CP, Q_operand, max_words => 160, writing_to_EM => True);
   121.       lock_out_relative_addresses(Q_operand);
   122.    end POD;
   123.
   124.    overriding
   125.    procedure POE (the_CP      : in out CP.device;
   126.                   Q_operand   : in KDF9.Q_register;
   127.                   set_offline : in Boolean) is
   128.    begin
   129.       POC(the_CP, Q_operand, set_offline);
   130.    end POE;
   131.
   132.    overriding
   133.    procedure POF (the_CP      : in out CP.device;
   134.                   Q_operand   : in KDF9.Q_register;
   135.                   set_offline : in Boolean) is
   136.    begin
   137.       POA(the_CP, Q_operand, set_offline);
   138.    end POF;
   139.
   140.    overriding
   141.    procedure POG (the_CP      : in out CP.device;
   142.                   Q_operand   : in KDF9.Q_register;
   143.                   set_offline : in Boolean) is
   144.    begin
   145.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   146.       write_card(the_CP, Q_operand, max_words => 10, writing_to_EM => False);
   147.       lock_out_relative_addresses(Q_operand);
   148.    end POG;
   149.
   150.    overriding
   151.    procedure POH (the_CP      : in out CP.device;
   152.                   Q_operand   : in KDF9.Q_register;
   153.                   set_offline : in Boolean) is
   154.    begin
   155.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   156.       write_card(the_CP, Q_operand, max_words => 10, writing_to_EM => True);
   157.       lock_out_relative_addresses(Q_operand);
   158.    end POH;
   159.
   160.    overriding
   161.    procedure POK (the_CP      : in out CP.device;
   162.                   Q_operand   : in KDF9.Q_register;
   163.                   set_offline : in Boolean) is
   164.    begin
   165.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   166.       -- See the Manual, p289.
   167.       words_write_card(the_CP, Q_operand, max_words => 80, writing_to_EM => True);
   168.       lock_out_relative_addresses(Q_operand);
   169.    end POK;
   170.
   171.    overriding
   172.    procedure POL (the_CP      : in out CP.device;
   173.                   Q_operand   : in KDF9.Q_register;
   174.                   set_offline : in Boolean) is
   175.    begin
   176.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   177.       -- See the Manual, p289.
   178.       words_write_card(the_CP, Q_operand, max_words => 80, writing_to_EM => False);
   179.       lock_out_relative_addresses(Q_operand);
   180.    end POL;
   181.
   182.    overriding
   183.    procedure Finalize (the_CP : in out CP.device) is
   184.    begin
   185.       close(
   186.             the_CP,
   187.             "punched",
   188.             the_CP.unit_count,
   189.             "card" & plurality(the_CP.unit_count)
   190.            );
   191.    end Finalize;
   192.
   193.    type CP_access is access CP.device;
   194.
   195.    CP0 : CP_access with Warnings => Off;
   196.    CP1 : CP_access with Warnings => Off;
   197.
   198.    unit : IOC.unit_number := 0;
   199.
   200.    procedure enable (b : in KDF9.buffer_number) is
   201.    begin
   202.       case unit is
   203.          when 0 =>
   204.             CP0 := new CP.device (number => b, unit => 0);
   205.             CP0_number := b;
   206.          when 1 =>
   207.             CP1 := new CP.device (number => b, unit => 1);
   208.             CP1_number := b;
   209.          when others =>
   210.             trap_operator_error("more than two CP units have been configured");
   211.       end case;
   212.       unit := unit + 1;
   213.    end enable;
   214.
   215. end IOC.slow.unit.CP;

Compiling: ../Source/ioc-slow-unit-cp.ads
Source file time stamp: 2021-02-15 01:23:08
Compiled at: 2021-02-21 15:54:08

     1. -- Emulation of a card punch buffer.
     2. -- Card punches are "unit record" devices: they cannot transfer less than a whole card.
     3. --
     4. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package IOC.slow.unit.CP is
    19.
    20.    type device is new IOC.slow.unit.device with private;
    21.
    22.    -- Punch binary mode.
    23.    overriding
    24.    procedure POA (the_CP      : in out CP.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    -- Punch binary mode to End Message.
    29.    overriding
    30.    procedure POB (the_CP      : in out CP.device;
    31.                   Q_operand   : in KDF9.Q_register;
    32.                   set_offline : in Boolean);
    33.
    34.    -- Punch binary character mode.
    35.    overriding
    36.    procedure POC (the_CP      : in out CP.device;
    37.                   Q_operand   : in KDF9.Q_register;
    38.                   set_offline : in Boolean);
    39.
    40.    -- Punch binary character mode to End Message.
    41.    overriding
    42.    procedure POD (the_CP      : in out CP.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    -- As POC.
    47.    overriding
    48.    procedure POE (the_CP      : in out CP.device;
    49.                   Q_operand   : in KDF9.Q_register;
    50.                   set_offline : in Boolean);
    51.
    52.    -- As POA.
    53.    overriding
    54.    procedure POF (the_CP      : in out CP.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    -- Punch alphanumeric mode.
    59.    overriding
    60.    procedure POG (the_CP      : in out CP.device;
    61.                   Q_operand   : in KDF9.Q_register;
    62.                   set_offline : in Boolean);
    63.
    64.    -- Punch alphanumeric mode to End Message.
    65.    overriding
    66.    procedure POH (the_CP      : in out CP.device;
    67.                   Q_operand   : in KDF9.Q_register;
    68.                   set_offline : in Boolean);
    69.
    70.    -- Punch alphanumeric character mode to End Message.
    71.    overriding
    72.    procedure POK (the_CP      : in out CP.device;
    73.                   Q_operand   : in KDF9.Q_register;
    74.                   set_offline : in Boolean);
    75.
    76.    -- Punch alphanumeric character mode.
    77.    overriding
    78.    procedure POL (the_CP      : in out CP.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean);
    81.
    82.    procedure enable (b : in KDF9.buffer_number);
    83.
    84. private
    85.
    86.    type device is new IOC.slow.unit.device with null record;
    87.
    88.    overriding
    89.    procedure Initialize (the_CP : in out CP.device);
    90.
    91.    overriding
    92.    procedure Finalize (the_CP : in out CP.device);
    93.
    94.    overriding
    95.    function kind (the_CP : CP.device)
    96.    return IOC.device_kind
    97.    is (CP_kind);
    98.
    99.    overriding
   100.    function quantum (the_CP : CP.device)
   101.    return KDF9.us
   102.    is (1E6 / (300 / 60)); -- 300 cards per minute.
   103.
   104. end IOC.slow.unit.CP;

 215 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-unit-cr.adb
Source file time stamp: 2021-02-19 16:40:08
Compiled at: 2021-02-21 15:54:08

     1. -- Emulation of a card reader buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.unit.CR is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_CR : in out CR.device) is
    23.    begin
    24.       open(the_CR, read_mode);
    25.    end Initialize;
    26.
    27.    blank_card : constant String(max_card_columns) := (others => SP);
    28.
    29.    procedure get_card_image (the_CR         : in out CR.device;
    30.                               size          : in out KDF9.word;
    31.                               max_columns   : in KDF9.address;
    32.                               reading_to_EM : in Boolean := False) is
    33.       max  : constant Positive := Positive(max_columns);
    34.       char : Character;
    35.    begin
    36.       -- Clear out the card image field.
    37.       the_CR.card_image(1..max) := blank_card(1..max);
    38.       -- Fill as much of the card image as possible with the next data line, padded out with
    39.       --    blanks, so that it is unnecessary to type all 80 or 160 characters.
    40.       -- For transfers to End Message, a line terminator must follow the E_M.
    41.       for i in 1 .. max loop
    42.          get_char_from_stream (char, the_CR);
    43.          size := size + 1;
    44.       exit when char = LF;
    45.          the_CR.card_image(i) := char;
    46.       exit when reading_to_EM and char = KDF9_char_sets.E_M;
    47.       end loop;
    48.       if char /= KDF9_char_sets.E_M then  -- The whole card was read.
    49.          size := KDF9.word(max);
    50.       end if;
    51.       the_CR.unit_count := the_CR.unit_count + 1;
    52.       -- Discard excess characters in the current data line.
    53.       while char /= LF loop
    54.          get_char_from_stream (char, the_CR);  -- N.B. do not update size for discards.
    55.       end loop;
    56.    exception
    57.       when end_of_stream =>
    58.          flush(the_CR.stream);
    59.          the_CR.is_abnormal := True;
    60.          raise;
    61.    end get_card_image;
    62.
    63.    procedure do_input_housekeeping (the_CR  : in out CR.device;
    64.                                     fetched : in KDF9.word) is
    65.    begin
    66.       add_in_the_IO_CPU_time(the_CR, fetched);
    67.       correct_transfer_time(the_CR, actual_length => 1);
    68.    end do_input_housekeeping;
    69.
    70.    procedure read_card (the_CR        : in out CR.device;
    71.                         Q_operand     : in KDF9.Q_register;
    72.                         max_words     : in KDF9.address;
    73.                         reading_to_EM : in Boolean := False) is
    74.       start_address : constant KDF9.address := Q_operand.I;
    75.       end_address   : constant KDF9.address := Q_operand.M;
    76.       size : KDF9.word := 0;
    77.       next : Natural := 0;
    78.       char : Character;
    79.       byte : KDF9_char_sets.symbol;
    80.    begin
    81.       check_addresses_and_lockouts(start_address, end_address);
    82.       get_card_image(the_CR, size, max_columns => max_words*8);
    83.    word_loop:
    84.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    85.          for c in KDF9_char_sets.symbol_index'Range loop
    86.             next := next + 1;
    87.             char := the_CR.card_image(next);
    88.             byte := CR_in(char);
    89.             store_symbol(byte, w, c);
    90.             if reading_to_EM and byte = KDF9_char_sets.End_Message then
    91.                for d in 1 .. 7-c loop
    92.                   store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
    93.                end loop;
    94.                exit word_loop;
    95.             end if;
    96.          end loop;
    97.       end loop word_loop;
    98.       do_input_housekeeping(the_CR, size);
    99.    exception
   100.       when end_of_stream =>
   101.          do_input_housekeeping(the_CR, size);
   102.    end read_card;
   103.
   104.    procedure words_read_card (the_CR        : in out CR.device;
   105.                               Q_operand     : in KDF9.Q_register;
   106.                               max_words     : in KDF9.address;
   107.                               reading_to_EM : in Boolean := False) is
   108.       start_address : constant KDF9.address := Q_operand.I;
   109.       end_address   : constant KDF9.address := Q_operand.M;
   110.       size : KDF9.word := 0;
   111.       next : Natural := 0;
   112.       char : Character;
   113.       word : KDF9.word;
   114.    begin
   115.       check_addresses_and_lockouts(start_address, end_address);
   116.       get_card_image(the_CR, size, max_columns => max_words);
   117.       if the_CR.is_abnormal then return; end if;
   118.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
   119.          next := next + 1;
   120.          char := the_CR.card_image(next);
   121.          word := KDF9.word(CR_in(char));
   122.          store_word(word, w);
   123.       exit when reading_to_EM and char = KDF9_char_sets.E_M;
   124.       end loop;
   125.       add_in_the_IO_CPU_time(the_CR, size);
   126.       correct_transfer_time(the_CR, actual_length => 1);
   127.    exception
   128.       when end_of_stream =>
   129.          flush(the_CR.stream);
   130.          add_in_the_IO_CPU_time(the_CR, size);
   131.          correct_transfer_time(the_CR, actual_length => 1);
   132.    end words_read_card;
   133.
   134.    overriding
   135.    procedure PIA (the_CR      : in out CR.device;
   136.                   Q_operand   : in KDF9.Q_register;
   137.                   set_offline : in Boolean) is
   138.    begin
   139.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   140.       read_card(the_CR, Q_operand, max_words => 20);
   141.       lock_out_relative_addresses(Q_operand);
   142.    end PIA;
   143.
   144.    overriding
   145.    procedure PIB (the_CR      : in out CR.device;
   146.                   Q_operand   : in KDF9.Q_register;
   147.                   set_offline : in Boolean) is
   148.    begin
   149.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   150.       read_card(the_CR, Q_operand, max_words => 20, reading_to_EM => True);
   151.       lock_out_relative_addresses(Q_operand);
   152.    end PIB;
   153.
   154.    overriding
   155.    procedure PIC (the_CR      : in out CR.device;
   156.                   Q_operand   : in KDF9.Q_register;
   157.                   set_offline : in Boolean) is
   158.    begin
   159.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   160.       words_read_card(the_CR, Q_operand, max_words => 160);
   161.       lock_out_relative_addresses(Q_operand);
   162.    end PIC;
   163.
   164.    overriding
   165.    procedure PID (the_CR      : in out CR.device;
   166.                   Q_operand   : in KDF9.Q_register;
   167.                   set_offline : in Boolean) is
   168.    begin
   169.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   170.       words_read_card(the_CR, Q_operand, max_words => 160, reading_to_EM => True);
   171.       lock_out_relative_addresses(Q_operand);
   172.    end PID;
   173.
   174.    overriding
   175.    procedure PIE (the_CR      : in out CR.device;
   176.                   Q_operand   : in KDF9.Q_register;
   177.                   set_offline : in Boolean) is
   178.    begin
   179.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   180.       read_card(the_CR, Q_operand, max_words => 10);
   181.       lock_out_relative_addresses(Q_operand);
   182.    end PIE;
   183.
   184.    overriding
   185.    procedure PIF (the_CR      : in out CR.device;
   186.                   Q_operand   : in KDF9.Q_register;
   187.                   set_offline : in Boolean) is
   188.    begin
   189.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   190.       read_card(the_CR, Q_operand, max_words => 10, reading_to_EM => True);
   191.       lock_out_relative_addresses(Q_operand);
   192.    end PIF;
   193.
   194.    overriding
   195.    procedure PIG (the_CR      : in out CR.device;
   196.                   Q_operand   : in KDF9.Q_register;
   197.                   set_offline : in Boolean) is
   198.    begin
   199.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   200.       words_read_card(the_CR, Q_operand, max_words => 80);
   201.       lock_out_relative_addresses(Q_operand);
   202.    end PIG;
   203.
   204.    overriding
   205.    procedure PIH (the_CR      : in out CR.device;
   206.                   Q_operand   : in KDF9.Q_register;
   207.                   set_offline : in Boolean) is
   208.    begin
   209.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   210.       words_read_card(the_CR, Q_operand, max_words => 80, reading_to_EM => True);
   211.       lock_out_relative_addresses(Q_operand);
   212.    end PIH;
   213.
   214.    -- the_T_bit_is_set := (RECHECK switch is OFF). {It always is nowadays!}
   215.    overriding
   216.    procedure PMB (the_CR      : in out CR.device;
   217.                   Q_operand   : in KDF9.Q_register;
   218.                   set_offline : in Boolean) is
   219.    begin
   220.       validate_device(the_CR);
   221.       validate_parity(the_CR);
   222.       deal_with_a_busy_device(the_CR, 13, set_offline);
   223.       the_T_bit_is_set := True;
   224.       take_note_of_test(the_CR.device_name, Q_operand, the_T_bit_is_set);
   225.    end PMB;
   226.
   227.    overriding
   228.    procedure Finalize (the_CR : in out CR.device) is
   229.    begin
   230.       close(
   231.             the_CR,
   232.             "read",
   233.             the_CR.unit_count,
   234.             "card" & plurality(the_CR.unit_count)
   235.            );
   236.    end Finalize;
   237.
   238.    type CR_access is access CR.device;
   239.
   240.    CR0 : CR_access with Warnings => Off;
   241.    CR1 : CR_access with Warnings => Off;
   242.
   243.    unit : IOC.unit_number := 0;
   244.
   245.    procedure enable (b : in KDF9.buffer_number) is
   246.    begin
   247.       case unit is
   248.          when 0 =>
   249.             CR0 := new CR.device (number => b, unit => 0);
   250.             CR0_number := b;
   251.          when 1 =>
   252.             CR1 := new CR.device (number => b, unit => 1);
   253.             CR1_number := b;
   254.          when others =>
   255.             trap_operator_error("more than two CR units have been configured");
   256.       end case;
   257.       unit := unit + 1;
   258.    end enable;
   259.
   260. end IOC.slow.unit.CR;

Compiling: ../Source/ioc-slow-unit-cr.ads
Source file time stamp: 2021-02-15 01:23:20
Compiled at: 2021-02-21 15:54:08

     1. -- Emulation of a card reader buffer.
     2. -- Card readers are "unit record" devices: they cannot transfer less than a whole card.
     3. --
     4. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package IOC.slow.unit.CR is
    19.
    20.    type device is new IOC.slow.unit.device with private;
    21.
    22.    -- Binary (undecoded) read
    23.    overriding
    24.    procedure PIA (the_CR      : in out CR.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    -- Binary (undecoded) read to End_Message
    29.    overriding
    30.    procedure PIB (the_CR      : in out CR.device;
    31.                   Q_operand   : in KDF9.Q_register;
    32.                   set_offline : in Boolean);
    33.
    34.    -- Binary (undecoded) character read
    35.    overriding
    36.    procedure PIC (the_CR      : in out CR.device;
    37.                   Q_operand   : in KDF9.Q_register;
    38.                   set_offline : in Boolean);
    39.
    40.    -- Binary (undecoded) character read to End_Message
    41.    overriding
    42.    procedure PID (the_CR      : in out CR.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    -- Alphanumeric (decoded) read
    47.    overriding
    48.    procedure PIE (the_CR      : in out CR.device;
    49.                   Q_operand   : in KDF9.Q_register;
    50.                   set_offline : in Boolean);
    51.
    52.    -- Alphanumeric (decoded) read to End_Message
    53.    overriding
    54.    procedure PIF (the_CR      : in out CR.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    -- Alphanumeric (decoded) character read
    59.    overriding
    60.    procedure PIG (the_CR      : in out CR.device;
    61.                   Q_operand   : in KDF9.Q_register;
    62.                   set_offline : in Boolean);
    63.
    64.    -- Alphanumeric (decoded) character read to End_Message
    65.    overriding
    66.    procedure PIH (the_CR      : in out CR.device;
    67.                   Q_operand   : in KDF9.Q_register;
    68.                   set_offline : in Boolean);
    69.
    70.    -- the_T_bit_is_set := (RECHECK switch is OFF)
    71.    overriding
    72.    procedure PMB (the_CR      : in out CR.device;
    73.                   Q_operand   : in KDF9.Q_register;
    74.                   set_offline : in Boolean);
    75.
    76.    procedure enable (b : in KDF9.buffer_number);
    77.
    78. private
    79.
    80.    subtype max_card_columns is Positive range 1 .. 160;
    81.
    82.    type device is new IOC.slow.unit.device with
    83.       record
    84.          card_image : String(max_card_columns);
    85.       end record;
    86.
    87.    overriding
    88.    procedure Initialize (the_CR : in out CR.device);
    89.
    90.    overriding
    91.    procedure Finalize (the_CR : in out CR.device);
    92.
    93.    overriding
    94.    function kind (the_CR : CR.device)
    95.    return IOC.device_kind
    96.    is (CR_kind);
    97.
    98.    overriding
    99.    function quantum (the_CR : CR.device)
   100.    return KDF9.us
   101.    is (1E6 / (600 / 60)); -- 600 cards per minute.
   102.
   103. end IOC.slow.unit.CR;

 260 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-unit-lp.adb
Source file time stamp: 2021-02-15 01:12:25
Compiled at: 2021-02-21 15:54:09

     1. -- Emulation of a lineprinter buffer.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.unit.LP is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_LP : in out LP.device) is
    23.    begin
    24.       open(the_LP, write_mode);
    25.    end Initialize;
    26.
    27.    max_LP_line_length : constant := 160;  -- This is a hardware limit.
    28.    max_LP_page_length : constant :=  66;  -- This is the length of a page of standard stationery.
    29.
    30.    -- The number of lines traversed by paper motion with a standard control loop.
    31.    function skip_length (the_LP : LP.device; symbol : KDF9_char_sets.symbol)
    32.    return KDF9.word
    33.    is (
    34.        if symbol = KDF9_char_sets.Page_Change
    35.        then max_LP_page_length - the_LP.unit_count mod max_LP_page_length
    36.        else 1
    37.       );
    38.
    39.    procedure do_output_housekeeping (the_LP   : in out LP.device;
    40.                                      old_count,
    41.                                      fetched  : in KDF9.word) is
    42.    begin
    43.       flush(the_LP.stream);
    44.       correct_transfer_time(the_LP, IO_elapsed_time(the_LP, the_LP.unit_count-old_count));
    45.       add_in_the_IO_CPU_time(the_LP, fetched);
    46.    end do_output_housekeeping;
    47.
    48.    next_column : Natural := 0;
    49.
    50.    procedure print (symbol : in KDF9_char_sets.symbol; the_LP : in out LP.device) is
    51.       char : constant Character := to_LP(symbol);
    52.    begin
    53.       if char /= KDF9_char_sets.W_F then
    54.          if symbol in KDF9_char_sets.Line_Shift | KDF9_char_sets.Page_Change then
    55.             the_LP.unit_count := the_LP.unit_count + skip_length(the_LP, symbol);
    56.             put_char(char, the_LP.stream);
    57.             next_column := 0;
    58.          elsif next_column < max_LP_line_length then
    59.             next_column := next_column + 1;
    60.             put_char(char, the_LP.stream);
    61.          end if;
    62.       end if;
    63.    end print;
    64.
    65.    -- It is unclear what should happen if more than max_LP_line_length printable characters
    66.    --    are sent to the printer before a LS or PC character, which empties the print matrix.
    67.    -- ee9 simply ignores the excess.
    68.
    69.    procedure put_symbols (the_LP        : in out LP.device;
    70.                           Q_operand     : in KDF9.Q_register;
    71.                           writing_to_EM : in Boolean) is
    72.       start_address : constant KDF9.address := Q_operand.I;
    73.       end_address   : constant KDF9.address := Q_operand.M;
    74.       count         : constant KDF9.word := the_LP.unit_count;
    75.       size   : KDF9.word := 0;
    76.       symbol : KDF9_char_sets.symbol;
    77.    begin
    78.       check_addresses_and_lockouts(start_address, end_address);
    79.    word_loop:
    80.       for w in start_address .. end_address loop
    81.          for c in KDF9_char_sets.symbol_index'Range loop
    82.             symbol := fetch_symbol(w, c);
    83.             size := size + 1;
    84.       -- Is this what should happen transfers on EM, leaving the print matrix ready for more data ??
    85.       exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
    86.             print(symbol, the_LP);
    87.          end loop;
    88.       end loop word_loop;
    89.       do_output_housekeeping(the_LP, old_count => count, fetched => size);
    90.    end put_symbols;
    91.
    92.    -- LPQq
    93.    overriding
    94.    procedure POA (the_LP      : in out LP.device;
    95.                   Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean) is
    97.    begin
    98.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
    99.       put_symbols(the_LP, Q_operand, writing_to_EM => False);
   100.       lock_out_relative_addresses(Q_operand);
   101.    end POA;
   102.
   103.    -- LPEQq
   104.    overriding
   105.    procedure POB (the_LP      : in out LP.device;
   106.                   Q_operand   : in KDF9.Q_register;
   107.                   set_offline : in Boolean) is
   108.    begin
   109.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   110.       put_symbols(the_LP, Q_operand, writing_to_EM => True);
   111.       lock_out_relative_addresses(Q_operand);
   112.    end POB;
   113.
   114.    procedure put_words (the_LP        : in out LP.device;
   115.                         Q_operand     : in KDF9.Q_register;
   116.                         writing_to_EM : in Boolean) is
   117.       start_address : constant KDF9.address := Q_operand.I;
   118.       end_address   : constant KDF9.address := Q_operand.M;
   119.       count         : constant KDF9.word := the_LP.unit_count;
   120.       size   : KDF9.word := 0;
   121.       symbol : KDF9_char_sets.symbol;
   122.    begin
   123.       check_addresses_and_lockouts(start_address, end_address);
   124.       for w in start_address .. end_address loop
   125.          symbol := KDF9_char_sets.symbol(fetch_word(w) and 8#77#);
   126.          size := size + 1;
   127.       -- Is this what should happen transfers on EM, leaving the print matrix ready for more data ??
   128.       exit when writing_to_EM and symbol = KDF9_char_sets.End_Message;
   129.          print(symbol, the_LP);
   130.       end loop;
   131.       do_output_housekeeping(the_LP, old_count => count, fetched => size);
   132.    end put_words;
   133.
   134.    -- Character write ?? Usercode Digest and Manual conflict!
   135.    overriding
   136.    procedure POC (the_LP      : in out LP.device;
   137.                   Q_operand   : in KDF9.Q_register;
   138.                   set_offline : in Boolean) is
   139.    begin
   140.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   141.       put_words(the_LP, Q_operand, writing_to_EM => False);
   142.       lock_out_relative_addresses(Q_operand);
   143.    end POC;
   144.
   145.    -- Character write to End_Message ?? Usercode Digest and Manual conflict!
   146.    overriding
   147.    procedure POD (the_LP      : in out LP.device;
   148.                   Q_operand   : in KDF9.Q_register;
   149.                   set_offline : in Boolean) is
   150.    begin
   151.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   152.       put_words(the_LP, Q_operand, writing_to_EM => True);
   153.       lock_out_relative_addresses(Q_operand);
   154.    end POD;
   155.
   156.    overriding
   157.    procedure Finalize (the_LP : in out LP.device) is
   158.    begin
   159.       close(
   160.             the_LP,
   161.             "printed",
   162.             the_LP.unit_count,
   163.             "line" & plurality(the_LP.unit_count)
   164.            );
   165.    end Finalize;
   166.
   167.    type LP_access is access LP.device;
   168.
   169.    LP0 : LP_access with Warnings => Off;
   170.    LP1 : LP_access with Warnings => Off;
   171.
   172.    unit : IOC.unit_number := 0;
   173.
   174.    procedure enable (b : in KDF9.buffer_number) is
   175.    begin
   176.       case unit is
   177.          when 0 =>
   178.             LP0 := new LP.device (number => b, unit => 0);
   179.             LP0_number := b;
   180.          when 1 =>
   181.             LP1 := new LP.device (number => b, unit => 1);
   182.             LP1_number := b;
   183.          when others =>
   184.             trap_operator_error("more than two LP units have been configured");
   185.       end case;
   186.       unit := unit + 1;
   187.    end enable;
   188.
   189. end IOC.slow.unit.LP;

Compiling: ../Source/ioc-slow-unit-lp.ads
Source file time stamp: 2021-02-15 01:23:30
Compiled at: 2021-02-21 15:54:09

     1. -- Emulation of a lineprinter buffer.
     2. -- Lineprinters are "unit record" devices: they cannot transfer less than a whole line.
     3. --
     4. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package IOC.slow.unit.LP is
    19.
    20.    type device is new IOC.slow.unit.device with private;
    21.
    22.    -- LPQq
    23.    overriding
    24.    procedure POA (the_LP      : in out LP.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    -- LPEQq
    29.    overriding
    30.    procedure POB (the_LP      : in out LP.device;
    31.                   Q_operand   : in KDF9.Q_register;
    32.                   set_offline : in Boolean);
    33.
    34.    -- Character write ??
    35.    overriding
    36.    procedure POC (the_LP      : in out LP.device;
    37.                   Q_operand   : in KDF9.Q_register;
    38.                   set_offline : in Boolean);
    39.
    40.    -- Character write to End_Message ??
    41.    overriding
    42.    procedure POD (the_LP      : in out LP.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    procedure enable (b : in KDF9.buffer_number);
    47.
    48. private
    49.
    50.    type device is new IOC.slow.unit.device with null record;
    51.
    52.    overriding
    53.    procedure Initialize (the_LP : in out LP.device);
    54.
    55.    overriding
    56.    procedure Finalize (the_LP : in out LP.device);
    57.
    58.    overriding
    59.    function kind (the_LP : LP.device)
    60.    return IOC.device_kind
    61.    is (LP_kind);
    62.
    63.    overriding
    64.    function quantum (the_LP : LP.device)
    65.    return KDF9.us
    66.    is (1E6 / (900 / 60)); -- 900 lines per minute.
    67.
    68. end IOC.slow.unit.LP;

 189 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/environmental_value_of.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:09

     1. -- Get the value of an environment variable.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Environment_Variables;
    18.
    19. function environmental_value_of (name, default : String)
    20. return String is
    21.    value : constant String := Ada.Environment_Variables.Value(name, "");
    22. begin
    23.    return (if value = "" then default else value);
    24. end environmental_value_of;

 24 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tod_clock.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:09

     1. -- functions that implement timing for Director emulation.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Calendar;
    18. with Ada.Calendar.Time_Zones;
    19. with Ada.Calendar.Formatting;
    20.
    21. use  Ada.Calendar;
    22. use  Ada.Calendar.Time_Zones;
    23. use  Ada.Calendar.Formatting;
    24.
    25. package body KDF9.TOD_clock is
    26.
    27.    function todays_date_28n_years_ago
    28.    return KDF9.word is
    29.
    30.       zero  : constant KDF9.word := 8#20#;  -- in KDF9 internal code
    31.       slash : constant KDF9.word := 8#17#;  -- in KDF9 internal code
    32.       today : constant Ada.Calendar.Time := Ada.Calendar.Clock;
    33.
    34.       year, month, day, hour, minute, second, sub_second : KDF9.word;
    35.
    36.       -- For values of i in 0..99, return two 6-bit decimal digits in KDF9 internal code.
    37.       function as_2_digits (i : KDF9.word)
    38.       return KDF9.word
    39.       is ((i/10 + zero)*64 or (i mod 10 + zero));
    40.
    41.    begin  -- todays_date_28n_years_ago
    42.       Split(today,
    43.             Year_Number(year),
    44.             Month_Number(month),
    45.             Day_Number(day),
    46.             Hour_Number(hour),
    47.             Minute_Number(minute),
    48.             Second_Number(second),
    49.             Second_Duration(sub_second),
    50.             Time_Zone => UTC_Time_Offset(today)
    51.            );
    52.       loop  -- Repeat n > 0 times, assuming no time travel into the past!
    53.          year := year - 28;
    54.       exit when year < 2000;
    55.       end loop;
    56.       return (as_2_digits(day)*64   or slash) * 64**5  -- DD/.....
    57.           or (as_2_digits(month)*64 or slash) * 64**2  --    MM/..
    58.           or (as_2_digits((year) mod 100));            --       YY
    59.    end todays_date_28n_years_ago;
    60.
    61.    function the_time_of_day
    62.    return KDF9.us is
    63.       today : constant Ada.Calendar.Time := Ada.Calendar.Clock;
    64.       year, month, day, hour, minute, second, sub_second : KDF9.word;
    65.    begin
    66.       Split(today,
    67.             Year_Number(year),
    68.             Month_Number(month),
    69.             Day_Number(day),
    70.             Hour_Number(hour),
    71.             Minute_Number(minute),
    72.             Second_Number(second),
    73.             Second_Duration(sub_second),
    74.             Time_Zone => UTC_Time_Offset(today)
    75.            );
    76.       return KDF9.us(hour*3600 + minute*60 + second) * 1_000_000;
    77.    end the_time_of_day;
    78.
    79. end KDF9.TOD_clock;

Compiling: ../Source/kdf9-tod_clock.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:09

     1. -- functions that implement timing for Director emulation.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TOD_clock is
    18.
    19.    -- The date a multiple of 28 years ago has the same day/date correspondence as today.
    20.    -- To avoid exposing KDF9's lack of Y2K compliance, ee9 uses such a date before 2000.
    21.    -- 8-)
    22.    -- todays_date_28n_years_ago returns a word of 8 KDF9 characters in the format DD/MM/YY.
    23.
    24.    function todays_date_28n_years_ago
    25.    return KDF9.word;
    26.
    27.    -- The time in microseconds since midnight.
    28.    function the_time_of_day
    29.    return KDF9.us;
    30.
    31. end KDF9.TOD_clock;

 79 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd.adb
Source file time stamp: 2021-02-20 23:52:36
Compiled at: 2021-02-21 15:54:09

     1. -- Implement the API (OUTs) of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.fast.DR.TSD_OUTs;
    18. with IOC.fast.FD.TSD_OUTs;
    19. with IOC.fast.tape.TSD_OUTs;
    20. with KDF9.TSD.peripherals;
    21. with KDF9.TSD.processes;
    22. with KDF9.TSD.spooling;
    23. with KDF9.TSD.timing;
    24. with settings;
    25. with tracing;
    26.
    27. use  IOC.fast.DR.TSD_OUTs;
    28. use  IOC.fast.FD.TSD_OUTs;
    29. use  IOC.fast.tape.TSD_OUTs;
    30. use  KDF9.TSD.peripherals;
    31. use  KDF9.TSD.processes;
    32. use  KDF9.TSD.spooling;
    33. use  KDF9.TSD.timing;
    34. use  settings;
    35. use  tracing;
    36.
    37. package body KDF9.TSD is
    38.
    39.    procedure restore_the_IO_OUT_operands (OUT_number, parameter : KDF9.word) is
    40.    begin
    41.       push(parameter);
    42.       push(OUT_number);
    43.    end restore_the_IO_OUT_operands;
    44.
    45.    procedure remove_the_IO_OUT_operands renames pop_pair;
    46.
    47.    -- Emulate a subset of the Time Sharing Director's OUT API.
    48.    procedure do_a_TSD_OUT (OUT_number : in KDF9.word) is
    49.    begin
    50.       -- Dismiss the OUT number in N1, allowing for an empty NEST, treated as OUT 0.
    51.       if the_NEST_depth > 0 then
    52.          pop;
    53.       end if;
    54.
    55.       case OUT_number is
    56.
    57.          when 0 =>
    58.             do_OUT_0;
    59.
    60.          when 1 =>
    61.             do_OUT_1;
    62.
    63.          when 2 =>
    64.             do_OUT_2;
    65.
    66.          when 3 =>
    67.             do_OUT_3;
    68.
    69.          when 4 =>
    70.             do_OUT_4;
    71.
    72.          when 5 =>
    73.             do_OUT_5;
    74.
    75.          when 6 =>
    76.             do_OUT_6;
    77.
    78.          when 7 =>
    79.             do_OUT_7;
    80.
    81.          when 8 =>
    82.             do_OUT_8;
    83.
    84.          when 9 =>
    85.             do_OUT_9;
    86.
    87.          when 10 =>
    88.             do_OUT_10;
    89.
    90.          when 11 =>
    91.             do_OUT_11;
    92.
    93.          when 12 =>
    94.             do_OUT_12;
    95.
    96.          when 13 =>
    97.             do_OUT_13;
    98.
    99.          when 14 =>
   100.             do_OUT_14;
   101.
   102.          when 16 =>
   103.             do_OUT_16;
   104.
   105.          when 17 =>
   106.             do_OUT_17;
   107.
   108.          when 41 =>
   109.             do_OUT_41;
   110.
   111.          when 42 =>
   112.             do_OUT_42;
   113.
   114.          when 43 =>
   115.             do_OUT_43;
   116.
   117.          when 44 =>
   118.             do_OUT_44;
   119.
   120.          when 45 =>
   121.             do_OUT_45;
   122.
   123.          when 47 =>
   124.             do_OUT_47;
   125.
   126.          when 70 =>
   127.             -- This is not a genuine TSD OUT, it is an expedient for debugging KAlgol,
   128.             --   so ee9 simply erases its parameters from N1 and N2.
   129.             ensure_that_the_NEST_holds_2_operands;
   130.             pop_pair;
   131.
   132.          when 97 =>
   133.             -- This is not a genuine TSD OUT, it gets an integer value from the command line.
   134.             -- The operand is the name of an environment variable.
   135.             -- The result is the numerical value of that variable.
   136.             ensure_that_the_NEST_holds_an_operand;
   137.             do_OUT_97;
   138.
   139.          when 98 =>
   140.             -- This is not a genuine TSD OUT, it is an ee9 'OUT' for setting FW output format.
   141.             ensure_that_the_NEST_holds_an_operand;
   142.             the_trace_operand := pop;
   143.             realistic_FW_output_is_wanted := the_trace_operand /= 0;
   144.
   145.          when 99 =>
   146.             -- This is not a genuine TSD OUT, it is an ee9 'OUT' for program instrumentation.
   147.             -- Get present value of the Instruction Count Register (ICR) from within ee9.
   148.             push(KDF9.word(ICR));
   149.             the_trace_operand := KDF9.word(ICR);
   150.
   151.          when others =>
   152.             push(OUT_number);
   153.             trap_failing_OUT(OUT_number, "is unknown, or not yet implemented");
   154.
   155.       end case;
   156.    end do_a_TSD_OUT;
   157.
   158. end KDF9.TSD;

Compiling: ../Source/kdf9-tsd.ads
Source file time stamp: 2021-02-11 19:57:06
Compiled at: 2021-02-21 15:54:09

     1. -- Implement the API (OUTs) of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. private with exceptions;
    18. private with formatting;
    19. private with HCI;
    20. private with IOC.equipment;
    21. private with settings;
    22. private with state_display;
    23. private with tracing;
    24.
    25. package KDF9.TSD is
    26.
    27.    procedure do_a_TSD_OUT (OUT_number : in KDF9.word);
    28.
    29.    -- Put the parameters of an I/O OUT back into the NEST in case the I/O order causes a lockout.
    30.    procedure restore_the_IO_OUT_operands (OUT_number, parameter : KDF9.word);
    31.
    32.    -- Remove the OUT parameters from the NEST after the I/O order completes without interrupting.
    33.    procedure remove_the_IO_OUT_operands;
    34.
    35. private
    36.
    37.    use exceptions;     pragma Warnings(Off, exceptions);
    38.    use formatting;     pragma Warnings(Off, formatting);
    39.    use HCI;            pragma Warnings(Off, HCI);
    40.    use IOC.equipment;  pragma Warnings(Off, IOC.equipment);
    41.    use settings;       pragma Warnings(Off, settings);
    42.    use state_display;  pragma Warnings(Off, state_display);
    43.    use tracing;        pragma Warnings(Off, tracing);
    44.
    45. end KDF9.TSD;

 158 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd-timing.adb
Source file time stamp: 2021-02-20 23:51:07
Compiled at: 2021-02-21 15:54:09

     1. -- Implement the timing OUTs of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body KDF9.TSD.timing is
    18.
    19.    -- This is the actual wall clock time at which the program was loaded.
    20.    -- If signature hashing is enabled, it stays at zero to get a repeatable hash.
    21.    the_time_of_loading : KDF9.us := 0;
    22.
    23.    -- Set the base for virtual elapsed time reckoning.
    24.    procedure set_the_time_of_loading (the_time : in KDF9.us) is
    25.    begin
    26.       the_time_of_loading := the_time;
    27.    end set_the_time_of_loading;
    28.
    29.    -- Return a time in s as 48-bit seconds to 23 integral places.
    30.    function OUT_time (microseconds : KDF9.us)
    31.    return KDF9.word is
    32.       -- The time was recorded by the hardware in units of 32 us, not 1 us.
    33.       truncated_time : constant KDF9.us := microseconds and not 31;
    34.    begin
    35.       if truncated_time < 2**23 * 1E6 then
    36.          -- 2**18 / 15625 = 2**24 / 1E6, with no risk of overflow in 64 bits.
    37.          return KDF9.word(truncated_time * 2**18 / 15625);
    38.       else
    39.          -- The virtual elapsed time overflows the 23-bit seconds field.
    40.          -- This would never have happened to a real KDF9, as 2**23 seconds is over three months.
    41.          -- No KDF9 could stay up that long!
    42.          -- However 2**23 KDF9 seconds pass in about 5 hours of ee9 real time,
    43.          --    so precautions have to be taken.
    44.          raise program_exit with "the KDF9 has been running too long, time > 2**23 seconds";
    45.       end if;
    46.    end OUT_time;
    47.
    48.    procedure do_OUT_3 is
    49.    begin
    50.       push(OUT_time(the_CPU_time));
    51.       the_trace_operand := read_top;
    52.    end do_OUT_3;
    53.
    54.    procedure do_OUT_9 is
    55.    begin
    56.       -- A TOD clock is simulated using the real TOD at which the program was
    57.       --    loaded, and the virtual time that has elapsed since.
    58.       push(OUT_time(the_time_of_loading + the_clock_time));
    59.       the_trace_operand := read_top;
    60.    end do_OUT_9;
    61.
    62.    procedure do_OUT_17 is
    63.    begin
    64.       ensure_that_the_NEST_has_room_for_2_results;
    65.       -- In program mode, the Elapsed Time is the same thing as the_clock_time.
    66.       push(OUT_time(the_clock_time));
    67.       push(OUT_time(the_CPU_time));
    68.       the_trace_operand := read_top;
    69.    end do_OUT_17;
    70.
    71. end KDF9.TSD.timing;

Compiling: ../Source/kdf9-tsd-timing.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:09

     1. -- Implement the timing OUTs of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.timing is
    18.
    19.    procedure do_OUT_3;
    20.
    21.    procedure do_OUT_9;
    22.
    23.    procedure do_OUT_17;
    24.
    25.    -- Set the base for virtual elapsed time reckoning.
    26.    procedure set_the_time_of_loading (the_time : in KDF9.us);
    27.
    28. end KDF9.TSD.timing;

 71 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/finalize_ee9.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:09

     1. -- Shut down processing in preparation for a dignified exit.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. --
    19. with HCI;
    20. with IOC;
    21. with state_display;
    22.
    23. use  HCI;
    24. use  IOC;
    25. use  state_display;
    26.
    27. procedure finalize_ee9 (because : in String) is
    28. begin
    29.    show_final_state(because);
    30.    finalize_all_KDF9_buffers;
    31. exception
    32.    when error : others =>
    33.       log_line("Failure: " & Ada.Exceptions.Exception_Information(error));
    34. end finalize_ee9;

 34 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/postscript.adb
Source file time stamp: 2021-02-19 21:33:06
Compiled at: 2021-02-21 15:54:09

     1. -- Elementary Encapsulated PostScript (EPS) line drawing.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body postscript is
    18.
    19.    use host_IO;
    20.
    21.    -- A path is a series of vectors v1, v2, ..., vn such that the last point
    22.    --    of vi is the same as the first point of v(i+1),
    23.    --       and v1, ..., vn are all drawn in the same colour.
    24.    -- A new path is started by a jump to a non-contiguous point or by a change of pen colour.
    25.
    26.    there_is_an_open_path      : Boolean := False;
    27.    the_last_point_in_the_path : postscript.point := (0, 0);
    28.
    29.    -- The bounding box limits are set from the value of maximum_offset at the end of the plot.
    30.    maximum_offset             : postscript.point := (0, 0);
    31.
    32.    procedure ensure_separation (stream : in out host_IO.stream) is
    33.    begin
    34.       if column(stream) > 0 then
    35.          put_byte(' ', stream);
    36.       end if;
    37.    end ensure_separation;
    38.
    39.    procedure put (stream : in out host_IO.stream; PS_text : String) is
    40.    begin
    41.       put_bytes(PS_text, stream);
    42.    end put;
    43.
    44.    procedure put_unit (stream : in out host_IO.stream; PS_text : String) is
    45.    begin
    46.       ensure_separation(stream);
    47.       put(stream, PS_text);
    48.    end put_unit;
    49.
    50.    procedure put_line (stream : in out host_IO.stream; PS_text : String) is
    51.    begin
    52.       put(stream, PS_text);
    53.       put_EOL(stream);
    54.    end put_line;
    55.
    56.    procedure put_unit_line (stream : in out host_IO.stream; PS_text : String) is
    57.    begin
    58.       put_unit(stream, PS_text);
    59.       put_EOL(stream);
    60.    end put_unit_line;
    61.
    62.    procedure put_integer (stream : in out host_IO.stream; i : Integer) is
    63.       integer_image  : constant String := i'Image;
    64.    begin
    65.       ensure_separation(stream);
    66.       if integer_image(integer_image'First) /= ' ' then
    67.          put(stream, integer_image);
    68.       else  -- Suppress the nuisance blank character.
    69.          put(stream, integer_image(integer_image'First+1..integer_image'Last));
    70.       end if;
    71.    end put_integer;
    72.
    73.    procedure terminate_any_open_path (stream : in out host_IO.stream) is
    74.    begin
    75.       if there_is_an_open_path then
    76.          -- Draw the accumulated strokes.
    77.          put_unit_line(stream, "s");
    78.       end if;
    79.       there_is_an_open_path := False;
    80.    end terminate_any_open_path;
    81.
    82.    procedure draw_a_PS_vector (stream : in out host_IO.stream;
    83.                                initial,
    84.                                final  : in postscript.point) is
    85.
    86.       function largest_of (a, b, c : Natural)
    87.       return Natural
    88.       is (Natural'Max(a, Natural'Max(b, c)));
    89.
    90.    begin -- draw_a_PS_vector
    91.       if initial /= the_last_point_in_the_path then
    92.          -- This vector is not contiguous with the previous one.
    93.          terminate_any_open_path(stream);
    94.       end if;
    95.       if initial = final then
    96.          -- This vector is of length 0.
    97.          return;
    98.       end if;
    99.       maximum_offset.x := largest_of(maximum_offset.x, initial.x, final.x);
   100.       maximum_offset.y := largest_of(maximum_offset.y, initial.y, final.y);
   101.       if there_is_an_open_path then
   102.          -- Draw a line to the final point, extending the current path.
   103.          put_integer(stream, final.x);
   104.          put_integer(stream, final.y);
   105.          put_unit_line(stream, "l");
   106.       else
   107.          -- Move to the initial point, opening a fresh path, and draw a line to the final point.
   108.          put_integer(stream, final.x);
   109.          put_integer(stream, final.y);
   110.          put_integer(stream, initial.x);
   111.          put_integer(stream, initial.y);
   112.          put_unit_line(stream, "n");
   113.          there_is_an_open_path := True;
   114.       end if;
   115.       the_last_point_in_the_path := final;
   116.    end draw_a_PS_vector;
   117.
   118.    subtype RGB is String(1..11);
   119.    gamut : constant array (pen_colour) of RGB
   120.          := (
   121.                Black          => ".00 .00 .00",
   122.                Blue           => ".00 .00 1.0",
   123.                Brown          => ".60 .20 .00",
   124.                Cyan           => ".00 1.0 1.0",
   125.                Dark_Blue      => ".10 .10 .80",
   126.                Dark_Cyan      => ".20 .80 1.0",
   127.                Dark_Green     => ".00 .60 .40",
   128.                Dark_Grey      => ".50 .50 .50",
   129.                Dark_Magenta   => ".75 .25 .75",
   130.                Dark_Red       => ".75 .00 .00",
   131.                Green          => ".00 1.0 .00",
   132.                Grey           => ".80 .80 .80",
   133.                Magenta        => "1.0 .00 1.0",
   134.                Red            => "1.0 .00 .00",
   135.                White          => "1.0 1.0 1.0",
   136.                Yellow         => "1.0 1.0 .00"
   137.             );
   138.
   139.    subtype tip_breadth is String(1..4);
   140.    breadth : constant array (pen_tip_size) of tip_breadth
   141.            := (
   142.                Extra_Extra_Fine => "1.00",
   143.                Extra_Fine       => "2.00",
   144.                Fine             => "4.00",
   145.                Medium           => "6.00",
   146.                Medium_Broad     => "8.00",
   147.                Broad            => "10.0",
   148.                Extra_Broad      => "12.0"
   149.               );
   150.
   151.    the_colour   : pen_colour   := the_default_colour;
   152.    the_pen_size : pen_tip_size := the_default_tip_size;
   153.
   154.    procedure put_the_pen_settings (stream : in out host_IO.Stream) is
   155.    begin -- put_the_pen_settings
   156.       terminate_any_open_path(stream);
   157.       put_unit(stream, gamut(the_colour));
   158.       put_unit_line(stream, "setrgbcolor");
   159.       put_unit(stream, breadth(the_pen_size));
   160.       put_unit_line(stream, "setlinewidth");
   161.    end put_the_pen_settings;
   162.
   163.    procedure set_the_pen_properties (this_colour   : in pen_colour   := the_default_colour;
   164.                                      this_pen_size : in pen_tip_size := the_default_tip_size) is
   165.    begin -- set_the_pen_properties
   166.       the_colour := this_colour;
   167.       the_pen_size := this_pen_size;
   168.    end set_the_pen_properties;
   169.
   170.    -- We eventually seek back to the bounding box parametsrs using this, their file offset.
   171.    the_position_of_the_placeholders : Natural;
   172.
   173.    procedure initialize_PS_output (stream : in out host_IO.Stream) is
   174.
   175.    begin -- initialize_PS_output
   176.       put_line(stream, "%!PS-Adobe-3.0 EPSF-1.0");
   177.       put_unit(stream, "%%BoundingBox: ");
   178.
   179.       -- Note the file offset of the bounding box placeholders.
   180.       get_position(the_position_of_the_placeholders, stream);
   181.
   182.       -- Write the 12-column placeholders.
   183.       put_line(stream, "xxxxxxxxxxxx|yyyyyyyyyyyy");
   184.
   185.       put_line(stream, "% This graph was plotted by ee9, the GNU Ada KDF9 emulator.");
   186.       put_line(stream, "% For more information, see <http://www.findlayw.plus.com/KDF9>.");
   187.       put_line(stream, "save");
   188.
   189.       put_line(stream, "1 setlinecap");
   190.       put_line(stream, "1 setlinejoin");
   191.
   192.       put_the_pen_settings(stream);
   193.
   194.       put_line(stream, "0 792 translate");  -- Assumes a page of length 11"!
   195.
   196.       -- The plotter step was 0.005", which is the same as 0.36 PostScript points.
   197.       -- The scaling factor is set here to make the wabbit example fit an A4 page.
   198.       put_line(stream, "0.12 -0.12 scale");
   199.
   200.       put_line(stream, "/l { lineto } bind def");
   201.       put_line(stream, "/n { newpath moveto lineto } bind def");
   202.       put_line(stream, "/s { stroke } bind def");
   203.
   204.       put_line(stream, "save");
   205.    end initialize_PS_output;
   206.
   207.    procedure finalize_PS_output (stream : in out host_IO.Stream) is
   208.
   209.       subtype bound_string is String(1..12);
   210.
   211.       function bound_image (n : in Natural)
   212.       return bound_string is
   213.          n_image : constant String := n'Image;
   214.       begin
   215.          return b : bound_string := (others => ' ') do
   216.             b(b'Last-n_image'Length+1 .. b'Last) := n_image;
   217.          end return;
   218.       end bound_image;
   219.
   220.    begin -- finalize_PS_output
   221.       terminate_any_open_path(stream);
   222.       put_line(stream, "showpage");
   223.       put_line(stream, "restore");
   224.       put_line(stream, "restore");
   225.       put_line(stream, "% End of plot");
   226.
   227.       -- Go back to the bounding box placeholders in the output file.
   228.       set_position(the_position_of_the_placeholders, stream);
   229.
   230.       -- Overwrite them with the actual x and y co-ordinate bounds.
   231.       put(stream, bound_image(maximum_offset.x));
   232.       put(stream, " ");
   233.       put(stream, bound_image(maximum_offset.y));
   234.
   235.       close(stream);
   236.    end finalize_PS_output;
   237.
   238. end postscript;
   239.

Compiling: ../Source/postscript.ads
Source file time stamp: 2021-02-11 00:34:42
Compiled at: 2021-02-21 15:54:09

     1. -- Elementary Encapsulated PostScript (EPS) line drawing.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with host_IO;
    18.
    19. package postscript is
    20.
    21.    type pen_colour is (
    22.                        Black,
    23.                        Blue,
    24.                        Brown,
    25.                        Cyan,
    26.                        Dark_Blue,
    27.                        Dark_Cyan,
    28.                        Dark_Green,
    29.                        Dark_Grey,
    30.                        Dark_Magenta,
    31.                        Dark_Red,
    32.                        Green,
    33.                        Grey,
    34.                        Magenta,
    35.                        Red,
    36.                        White,
    37.                        Yellow
    38.                       );
    39.
    40.    the_default_colour : constant pen_colour := Black;
    41.
    42.    type pen_tip_size is (
    43.                          Extra_Extra_Fine,
    44.                          Extra_Fine,
    45.                          Fine,
    46.                          Medium,
    47.                          Medium_Broad,
    48.                          Broad,
    49.                          Extra_Broad
    50.                         );
    51.
    52.    the_default_tip_size : constant pen_tip_size := Extra_Extra_Fine;
    53.
    54.    -- Choose the pen's colour and tip size.
    55.
    56.    procedure set_the_pen_properties (this_colour   : in pen_colour   := the_default_colour;
    57.                                      this_pen_size : in pen_tip_size := the_default_tip_size);
    58.
    59.    -- Drawing is done in terms of the plotter's co-ordinate system.
    60.    -- (0, 0) is the top left point of the drawing,
    61.    -- The x axis increases down the plot (long axis, direction of paper movement),
    62.    --    and the y axis increases across the plot (short axis, direction of pen movement).
    63.
    64.    type point is
    65.      record
    66.         x, y : Natural;  -- All physically possible co-ordinates are non-negative.
    67.      end record;
    68.
    69.    -- Draw a straight line from initial to final.
    70.    procedure draw_a_PS_vector (stream : in out host_IO.stream;
    71.                                initial,
    72.                                final  : in postscript.point);
    73.
    74.    -- Open the PostScript file and write the prelude, with a placeholder for the bounds.
    75.    procedure initialize_PS_output (stream : in out host_IO.Stream);
    76.
    77.    -- Close the PostScript file, having gone back to overwrite the bounding box placeholders.
    78.    procedure finalize_PS_output (stream : in out host_IO.Stream);
    79.
    80. end postscript;

 239 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/settings-io.adb
Source file time stamp: 2021-02-11 00:34:42
Compiled at: 2021-02-21 15:54:09

     1. -- Settings-reader I/O support.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Latin_1;
    18. --
    19. with file_interfacing;
    20. with KDF9;
    21.
    22. use  Ada.Characters.Latin_1;
    23.
    24. package body settings.IO is
    25.
    26.    procedure open_options_file (file : in out File_Type; name : in String) is
    27.    begin
    28.       file_interfacing.initialize(file, in_file, name);
    29.       line_number := 1;
    30.    exception
    31.       when others =>
    32.          raise Status_Error with name;
    33.    end open_options_file;
    34.
    35.    procedure close_options_file (file : in out File_Type; name : in String) is
    36.    begin
    37.       file_interfacing.finalize(file, name);
    38.    end close_options_file;
    39.
    40.    comment_flag_character : constant Character := '|';
    41.
    42.    procedure skip_to_next_non_blank (file : File_Type) is
    43.       next_char : Character := ' ';
    44.       end_line  : Boolean;
    45.    begin
    46.       loop
    47.         look_ahead(file, next_char, end_line);
    48.       exit when end_line or else
    49.                   (next_char /= ' ' and next_char /= HT);
    50.          get(file, next_char);
    51.       end loop;
    52.       if next_char = comment_flag_character then
    53.          while not end_of_line(file) loop
    54.             get(file, next_char);
    55.          end loop;
    56.       end if;
    57.    end skip_to_next_non_blank;
    58.
    59.    procedure ensure_not_at_end_of_line (file : File_Type) is
    60.    begin
    61.       skip_to_next_non_blank (file);
    62.       if end_of_line(file) then
    63.          raise Data_Error;
    64.       end if;
    65.    end ensure_not_at_end_of_line;
    66.
    67.    procedure skip_to_next_nonempty_line (file : in File_Type) is
    68.       flag     : Character;
    69.       end_line : Boolean;
    70.    begin
    71.       loop
    72.          look_ahead(file, flag, end_line);
    73.          if end_line                      or else
    74.                flag = comment_flag_character then
    75.             Skip_Line(file);
    76.             line_number := line_number + 1;
    77.          else
    78.             exit;
    79.          end if;
    80.       end loop;
    81.       if flag = comment_flag_character then
    82.          raise Data_Error;
    83.       end if;
    84.    end skip_to_next_nonempty_line;
    85.
    86.    digit_offset : constant := Character'Pos('0');
    87.
    88.    procedure get_octal (file : in File_Type; value : out KDF9.word) is
    89.       next_char : Character;
    90.       last_char : Character := '_';
    91.       place     : Natural   := 0;
    92.       end_line  : Boolean   := False;
    93.    begin
    94.       value := 0;
    95.       ensure_not_at_end_of_line(file);
    96.       get(file, next_char);
    97.       if next_char = '#' then
    98.          get(file, next_char);
    99.       else
   100.          raise Data_Error;
   101.       end if;
   102.       loop
   103.          if next_char in '0' .. '7' then
   104.             value := value*8 + KDF9.word(Character'Pos(next_char)-digit_offset);
   105.             place := place + 1;
   106.             if place > 16 then
   107.                raise Data_Error;
   108.             end if;
   109.          elsif next_char = '_' then
   110.             if place = 0 then
   111.                raise Data_Error;
   112.             end if;
   113.          else
   114.             if last_char = '_' or place = 0 then
   115.                raise Data_Error;
   116.             end if;
   117.             exit;
   118.          end if;
   119.          last_char := next_char;
   120.          look_ahead(file, next_char, end_line);
   121.       exit when end_line;
   122.          if next_char in '0' .. '7' or next_char = '_' then
   123.             get(file, next_char);
   124.          else
   125.             if last_char = '_' or place = 0 then
   126.                raise Data_Error;
   127.             end if;
   128.             exit;
   129.          end if;
   130.       end loop;
   131.    end get_octal;
   132.
   133.    procedure get_decimal (file : in File_Type; value : out KDF9.word) is
   134.       next_char : Character;
   135.       last_char : Character := '_';
   136.       place     : Natural   := 0;
   137.       end_line  : Boolean   := False;
   138.    begin
   139.       value := 0;
   140.       ensure_not_at_end_of_line(file);
   141.       get(file, next_char);
   142.       if next_char not in '0' .. '9' then
   143.          raise Program_Error with "get_decimal " & next_char;
   144.       end if;
   145.       loop
   146.          if next_char in '0' .. '9' then
   147.             value := value*10 + KDF9.word(Character'Pos(next_char)-digit_offset);
   148.             place := place + 1;
   149.             if place > 15 then
   150.                raise Data_Error;
   151.             end if;
   152.          elsif next_char = '_' then
   153.             if place = 0 then
   154.                raise Data_Error;
   155.             end if;
   156.          else
   157.             if last_char = '_' or place = 0 then
   158.                raise Data_Error;
   159.             end if;
   160.       exit;
   161.          end if;
   162.          last_char := next_char;
   163.          look_ahead(file, next_char, end_line);
   164.       exit when end_line;
   165.          if next_char in '0' .. '9' or next_char = '_' then
   166.             get(file, next_char);
   167.          else
   168.             if last_char = '_' or place = 0 then
   169.                raise Data_Error;
   170.             end if;
   171.       exit;
   172.          end if;
   173.       end loop;
   174.    end get_decimal;
   175.
   176.    procedure get_word (file : in File_Type; value : out KDF9.word) is
   177.       next_char : Character;
   178.       end_line  : Boolean;
   179.    begin
   180.       ensure_not_at_end_of_line(file);
   181.       look_ahead(file, next_char, end_line);
   182.       pragma Unreferenced(end_line);
   183.       if next_char = '#' then
   184.          get_octal(file, value);
   185.       else
   186.          get_decimal(file, value);
   187.       end if;
   188.    end get_word;
   189.
   190.    procedure get_char (file : in File_Type; value : out Character) is
   191.       end_line : Boolean;
   192.       char     : Character;
   193.    begin
   194.       ensure_not_at_end_of_line(file);
   195.       look_ahead(file, char, end_line);
   196.       if end_line then
   197.          raise Data_Error;
   198.       end if;
   199.       if char /= ' ' then
   200.          get(file, value);
   201.       end if;
   202.    end get_char;
   203.
   204. end settings.IO;
   205.

Compiling: ../Source/settings-io.ads
Source file time stamp: 2021-02-11 00:34:42
Compiled at: 2021-02-21 15:54:09

     1. -- Settings-reader I/O support.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18. --
    19. with postscript;
    20.
    21. use  Ada.Text_IO;
    22.
    23. package settings.IO is
    24.
    25.    line_number : Natural := 0;
    26.
    27.    procedure open_options_file (file : in out File_Type; name : in String);
    28.
    29.    procedure close_options_file (file : in out File_Type; name : in String);
    30.
    31.    -- Check that the end of the line has not yet been reached, else raise Data_Error.
    32.    procedure ensure_not_at_end_of_line (file : in File_Type);
    33.
    34.    -- Move the reading position to the next non-blank or EOL, skipping comment.
    35.    procedure skip_to_next_non_blank (file : in File_Type);
    36.
    37.    -- Discard input until a non-empty line is reached,
    38.    --    leaving the reading position at the start of that line,
    39.    --    and incrementing line_number for each line terminator passed.
    40.    procedure skip_to_next_nonempty_line (file : in File_Type);
    41.
    42.    -- Read octal digits string as KDF9.word,
    43.    --    raising Data_Error on overflow or bad syntax.
    44.    procedure get_octal (file : in File_Type; value : out KDF9.word);
    45.
    46.    -- Read decimal digits string as KDF9.word,
    47.    --    raising Data_Error on overflow or bad syntax.
    48.    procedure get_decimal (file  : in File_Type; value : out KDF9.word);
    49.
    50.    -- Read an address as a KDF9.word in either octal or decimal,
    51.    --    using get_octal or get_decimal as indicated by the syntax.
    52.    procedure get_word (file : in File_Type; value : out KDF9.word);
    53.
    54.    -- Read the character value immediately following an octal or decimal number,
    55.    --    if it is not a space character; if it is a space, leave value unchanged.
    56.    procedure get_char (file : in File_Type; value : out Character);
    57.
    58.    package colour_IO is new Ada.Text_IO.Enumeration_IO(postscript.pen_colour);
    59.    package  width_IO is new Ada.Text_IO.Enumeration_IO(postscript.pen_tip_size);
    60.
    61. end settings.IO;

 205 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/generic_sets.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:09

     1. -- Powersets of a discrete member type.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. -- generic
    18. --    type member is (<>);
    19. package body generic_sets is
    20.
    21.    function "/" (set : generic_sets.set; member : generic_sets.member)
    22.    return Boolean
    23.    is (set(member));
    24.
    25.    function "or" (set : generic_sets.set; member : generic_sets.member)
    26.    return generic_sets.set is
    27.    begin
    28.       return result : generic_sets.set := set do
    29.          result(member) := True;
    30.       end return;
    31.    end "or";
    32.
    33.    function "-" (set1, set2 : generic_sets.set)
    34.    return generic_sets.set is
    35.    begin -- Compute (set1 and not set2), avoiding need for a potentially large workspace.
    36.       return result : generic_sets.set := set1 do
    37.          for m in generic_sets.member loop
    38.             if set2(m) then
    39.                result(m) := False;
    40.             end if;
    41.          end loop;
    42.       end return;
    43.    end "-";
    44.
    45. end generic_sets;

Compiling: ../Source/generic_sets.ads
Source file time stamp: 2021-02-17 14:13:06
Compiled at: 2021-02-21 15:54:09

     1. -- Powersets of a discrete member type.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. generic
    18.    type member is (<>);
    19. package generic_sets is
    20.
    21.    pragma Preelaborate;
    22.
    23. --
    24. -- This package implements only those set operations that are needed by ee9.
    25. --
    26.
    27.    type set is array (generic_sets.member) of Boolean
    28.       with Component_Size => 1;
    29.
    30.    empty_set : constant generic_sets.set := (others => False);
    31.
    32.    -- Test for membership of the set.
    33.    function "/" (set : generic_sets.set; member : generic_sets.member)
    34.    return Boolean with Inline;
    35.
    36.    -- Union of a set and a singleton.
    37.    function "or"  (set : generic_sets.set; member : generic_sets.member)
    38.    return generic_sets.set;
    39.
    40.    -- Computes (set1 and not set2).
    41.    function "-" (set1, set2 : generic_sets.set)
    42.    return generic_sets.set;
    43.
    44. end generic_sets;

 45 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-decoding.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:09

     1. -- The "compressed_opcode" values are effective opcodes, partially decoded from the first syllable,
     2. --   and combined with opcode bits of the second syllable, where appropriate (e.g. in jumps).
     3. --
     4. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package KDF9.decoding is
    19.
    20.    -- The compressed_opcode values for 1-syllable orders are equal to their full codes.
    21.
    22.    ALL_0    : constant KDF9.compressed_opcode := 2#000_000#;
    23.    VR       : constant KDF9.compressed_opcode := 2#000_001#;
    24.    TO_TR    : constant KDF9.compressed_opcode := 2#000_010#;
    25.    BITS     : constant KDF9.compressed_opcode := 2#000_011#;
    26.    XF       : constant KDF9.compressed_opcode := 2#000_100#;
    27.    XDF      : constant KDF9.compressed_opcode := 2#000_101#;
    28.    INV006   : constant KDF9.compressed_opcode := 2#000_110#;
    29.    XPLUSF   : constant KDF9.compressed_opcode := 2#000_111#;
    30.    NEGD     : constant KDF9.compressed_opcode := 2#001_000#;
    31.    OR_9     : constant KDF9.compressed_opcode := 2#001_001#;
    32.    PERM     : constant KDF9.compressed_opcode := 2#001_010#;
    33.    TOB      : constant KDF9.compressed_opcode := 2#001_011#;
    34.    ROUNDH   : constant KDF9.compressed_opcode := 2#001_100#;
    35.    NEV      : constant KDF9.compressed_opcode := 2#001_101#;
    36.    ROUND    : constant KDF9.compressed_opcode := 2#001_110#;
    37.    DUMMY    : constant KDF9.compressed_opcode := 2#001_111#;
    38.    ROUNDF   : constant KDF9.compressed_opcode := 2#010_000#;
    39.    ROUNDHF  : constant KDF9.compressed_opcode := 2#010_001#;
    40.    MINUSDF  : constant KDF9.compressed_opcode := 2#010_010#;
    41.    PLUSDF   : constant KDF9.compressed_opcode := 2#010_011#;
    42.    FLOAT_9  : constant KDF9.compressed_opcode := 2#010_100#;
    43.    FLOATD   : constant KDF9.compressed_opcode := 2#010_101#;
    44.    ABS_9    : constant KDF9.compressed_opcode := 2#010_110#;
    45.    NEG      : constant KDF9.compressed_opcode := 2#010_111#;
    46.    ABSF     : constant KDF9.compressed_opcode := 2#011_000#;
    47.    NEGF     : constant KDF9.compressed_opcode := 2#011_001#;
    48.    MAX      : constant KDF9.compressed_opcode := 2#011_010#;
    49.    NOT_9    : constant KDF9.compressed_opcode := 2#011_011#;
    50.    XD       : constant KDF9.compressed_opcode := 2#011_100#;
    51.    X_frac   : constant KDF9.compressed_opcode := 2#011_101#;
    52.    MINUS    : constant KDF9.compressed_opcode := 2#011_110#;
    53.    SIGN     : constant KDF9.compressed_opcode := 2#011_111#;
    54.    INV040   : constant KDF9.compressed_opcode := 2#100_000#;
    55.    ZERO     : constant KDF9.compressed_opcode := 2#100_001#;
    56.    DUP      : constant KDF9.compressed_opcode := 2#100_010#;
    57.    DUPD     : constant KDF9.compressed_opcode := 2#100_011#;
    58.    DIVI     : constant KDF9.compressed_opcode := 2#100_100#;
    59.    FIX      : constant KDF9.compressed_opcode := 2#100_101#;
    60.    INV046   : constant KDF9.compressed_opcode := 2#100_110#;
    61.    STR      : constant KDF9.compressed_opcode := 2#100_111#;
    62.    CONT     : constant KDF9.compressed_opcode := 2#101_000#;
    63.    REVD     : constant KDF9.compressed_opcode := 2#101_001#;
    64.    ERASE    : constant KDF9.compressed_opcode := 2#101_010#;
    65.    MINUSD   : constant KDF9.compressed_opcode := 2#101_011#;
    66.    AND_9    : constant KDF9.compressed_opcode := 2#101_100#;
    67.    INV055   : constant KDF9.compressed_opcode := 2#101_101#;
    68.    PLUS     : constant KDF9.compressed_opcode := 2#101_110#;
    69.    PLUSD    : constant KDF9.compressed_opcode := 2#101_111#;
    70.    DIV      : constant KDF9.compressed_opcode := 2#110_000#;
    71.    DIVD     : constant KDF9.compressed_opcode := 2#110_001#;
    72.    DIVF     : constant KDF9.compressed_opcode := 2#110_010#;
    73.    DIVDF    : constant KDF9.compressed_opcode := 2#110_011#;
    74.    DIVR     : constant KDF9.compressed_opcode := 2#110_100#;
    75.    REV      : constant KDF9.compressed_opcode := 2#110_101#;
    76.    CAB      : constant KDF9.compressed_opcode := 2#110_110#;
    77.    FRB      : constant KDF9.compressed_opcode := 2#110_111#;
    78.    STAND    : constant KDF9.compressed_opcode := 2#111_000#;
    79.    NEGDF    : constant KDF9.compressed_opcode := 2#111_001#;
    80.    MAXF     : constant KDF9.compressed_opcode := 2#111_010#;
    81.    INV073   : constant KDF9.compressed_opcode := 2#111_011#;
    82.    PLUSF    : constant KDF9.compressed_opcode := 2#111_100#;
    83.    MINUSF   : constant KDF9.compressed_opcode := 2#111_101#;
    84.    INV076   : constant KDF9.compressed_opcode := 2#111_110#;
    85.    SIGNF    : constant KDF9.compressed_opcode := 2#111_111#;
    86.
    87.
    88.    -- compressed_opcode values for 2-syllable indirect fetch and store orders
    89.
    90.    MkMq       : constant KDF9.compressed_opcode := 2#000_000#;
    91.    MkMqQ      : constant KDF9.compressed_opcode := 2#000_010#;
    92.    MkMqH      : constant KDF9.compressed_opcode := 2#000_100#;
    93.    MkMqQH     : constant KDF9.compressed_opcode := 2#000_110#;
    94.    MkMqN      : constant KDF9.compressed_opcode := 2#001_000#;
    95.    MkMqQN     : constant KDF9.compressed_opcode := 2#001_010#;
    96.    MkMqHN     : constant KDF9.compressed_opcode := 2#001_100#;
    97.    MkMqQHN    : constant KDF9.compressed_opcode := 2#001_110#;
    98.
    99.    TO_MkMq    : constant KDF9.compressed_opcode := 2#000_001#;
   100.    TO_MkMqQ   : constant KDF9.compressed_opcode := 2#000_011#;
   101.    TO_MkMqH   : constant KDF9.compressed_opcode := 2#000_101#;
   102.    TO_MkMqQH  : constant KDF9.compressed_opcode := 2#000_111#;
   103.    TO_MkMqN   : constant KDF9.compressed_opcode := 2#001_001#;
   104.    TO_MkMqQN  : constant KDF9.compressed_opcode := 2#001_011#;
   105.    TO_MkMqHN  : constant KDF9.compressed_opcode := 2#001_101#;
   106.    TO_MkMqQHN : constant KDF9.compressed_opcode := 2#001_111#;
   107.
   108.
   109.    -- compressed_opcode values for 2-syllable Q store orders
   110.
   111.    M_PLUS_Iq    : constant KDF9.compressed_opcode := 2#100_000#;
   112.    M_MINUS_Iq   : constant KDF9.compressed_opcode := 2#100_001#;
   113.    NCq          : constant KDF9.compressed_opcode := 2#100_010#;
   114.    DCq          : constant KDF9.compressed_opcode := 2#100_011#;
   115.    POS1_TO_Iq   : constant KDF9.compressed_opcode := 2#100_100#;
   116.    NEG1_TO_Iq   : constant KDF9.compressed_opcode := 2#100_101#;
   117.    POS2_TO_Iq   : constant KDF9.compressed_opcode := 2#100_110#;
   118.    NEG2_TO_Iq   : constant KDF9.compressed_opcode := 2#100_111#;
   119.
   120.    MqTOQk       : constant KDF9.compressed_opcode := 2#101_001#;
   121.    IqTOQk       : constant KDF9.compressed_opcode := 2#101_010#;
   122.    IMqTOQk      : constant KDF9.compressed_opcode := 2#101_011#;
   123.    CqTOQk       : constant KDF9.compressed_opcode := 2#101_100#;
   124.    CMqTOQk      : constant KDF9.compressed_opcode := 2#101_101#;
   125.    CIqTOQk      : constant KDF9.compressed_opcode := 2#101_110#;
   126.    QqTOQk       : constant KDF9.compressed_opcode := 2#101_111#;
   127.
   128.    SHA          : constant KDF9.compressed_opcode := 2#110_001#;
   129.    SHAD         : constant KDF9.compressed_opcode := 2#110_010#;
   130.    MACC         : constant KDF9.compressed_opcode := 2#110_011#;
   131.    SHL          : constant KDF9.compressed_opcode := 2#110_100#;
   132.    SHLD         : constant KDF9.compressed_opcode := 2#110_110#;
   133.    SHC          : constant KDF9.compressed_opcode := 2#110_111#;
   134.    constant_bit : constant := 1;
   135.
   136.    TO_RCIMq     : constant KDF9.compressed_opcode := 2#111_000#;
   137.    QCIMq        : constant KDF9.compressed_opcode := 2#111_001#;
   138.    ADD_TO_QCIMq : constant KDF9.compressed_opcode := 2#111_010#;
   139.
   140.    -- masks for Q store Qk bits
   141.
   142.    reset_choice  : constant := 2#0001#;
   143.    C_part_choice : constant := 2#1000#;
   144.    I_part_choice : constant := 2#0100#;
   145.    M_part_choice : constant := 2#0010#;
   146.    all_Q_choice  : constant := C_part_choice + I_part_choice + M_part_choice;
   147.
   148.
   149.    -- compressed_opcode values for 2-syllable SJNS orders
   150.
   151.    LINK    : constant KDF9.compressed_opcode := 2#111_011#;
   152.    TO_LINK : constant KDF9.compressed_opcode := 2#111_100#;
   153.
   154.
   155.    -- compressed_opcode values for 2-syllable Director-only orders
   156.
   157.    TO_Kq : constant KDF9.compressed_opcode := 2#111_101#;
   158.    K0    : constant := 2#1000#;
   159.    K1    : constant := 2#0100#;
   160.    K2    : constant := 2#0010#;
   161.    K3    : constant := 2#0001#;
   162.    Kk    : constant KDF9.compressed_opcode := 2#111_110#;
   163.    K4    : constant := 2#1000#;
   164.    K5    : constant := 2#0100#;
   165.    K7    : constant := 2#0001#;
   166.
   167.
   168.    -- compressed_opcode value for 2-syllable short-loop jump order
   169.
   170.    JCqNZS : constant KDF9.compressed_opcode := 2#111_111#;
   171.
   172.
   173.    -- compressed_opcode values for 2-syllable I/O orders
   174.
   175.    CT_PMB_PMC_BUSY_Qq     : constant KDF9.compressed_opcode := 2#010_000#;
   176.    PAR_Qq                 : constant KDF9.compressed_opcode := 2#010_001#;
   177.    PMF_PMG_Qq             : constant KDF9.compressed_opcode := 2#010_010#;
   178.    PIA_PIC_CLO_TLO_Qq     : constant KDF9.compressed_opcode := 2#010_100#;
   179.    PIB_PID_Qq             : constant KDF9.compressed_opcode := 2#010_101#;
   180.    PIE_PIG_Qq             : constant KDF9.compressed_opcode := 2#010_110#;
   181.    PIF_PIH_Qq             : constant KDF9.compressed_opcode := 2#010_111#;
   182.
   183.    POA_POC_POE_POF_PMH_Qq : constant KDF9.compressed_opcode := 2#011_000#;
   184.    POB_POD_Qq             : constant KDF9.compressed_opcode := 2#011_001#;
   185.    POG_POL_Qq             : constant KDF9.compressed_opcode := 2#011_010#;
   186.    POH_POK_Qq             : constant KDF9.compressed_opcode := 2#011_011#;
   187.    PMA_PMK_INT_Qq         : constant KDF9.compressed_opcode := 2#011_100#;
   188.    PMD_PME_PML_Qq         : constant KDF9.compressed_opcode := 2#011_110#;
   189.
   190.    -- masks for I/O opcode extension bits (Qk field)
   191.
   192.    PAR_bits  : constant := 2#0000#;
   193.
   194.    -- PIA_PIC_CLO_TLO_Qq:
   195.    PIA_bits  : constant := 2#0000#;
   196.    PIC_bits  : constant := 2#1000#;
   197.    CLO_bits  : constant := 2#0010#;
   198.    TLO_bits  : constant := 2#0100#;
   199.
   200.    -- PIB_PID_Qq:
   201.    PIB_bits  : constant := 2#0000#;
   202.    PID_bits  : constant := 2#1000#;
   203.
   204.    -- PIE_PIG_Qq:
   205.    PIE_bits  : constant := 2#0000#;
   206.    PIG_bits  : constant := 2#1000#;
   207.
   208.    -- PIF_PIH_Qq:
   209.    PIF_bits  : constant := 2#0000#;
   210.    PIH_bits  : constant := 2#1000#;
   211.
   212.    -- PMA_PMK_INT_Qq:
   213.    PMA_bits  : constant := 2#0000#;
   214.    PMK_bits  : constant := 2#0100#;
   215.    INT_bits  : constant := 2#0010#;
   216.
   217.    -- CT_PMB_PMC_BUSY_Qq:
   218.    CTQ_bits   : constant := 2#0000#;
   219.    PMB_bits   : constant := 2#1000#;
   220.    PMC_bits   : constant := 2#0100#;
   221.    BUSY_bits  : constant := 2#0010#;
   222.    manual_bit : constant := 2#0001#;
   223.
   224.    -- PMD_PME_PML_Qq:
   225.    PME_bits  : constant := 2#0000#;
   226.    PMD_bits  : constant := 2#1000#;
   227.    PML_bits  : constant := 2#0100#;
   228.
   229.    -- PMF_PMG_Qq:
   230.    PMF_bits  : constant := 2#0000#;
   231.    PMG_bits  : constant := 2#0100#;
   232.
   233.    -- POA_POC_POE_POF_PMH_Qq:
   234.    POA_bits  : constant := 2#0000#;
   235.    POC_bits  : constant := 2#1000#;
   236.    POE_bits  : constant := 2#1100#;
   237.    POF_bits  : constant := 2#0100#;
   238.    PMH_bits  : constant := 2#0010#;
   239.
   240.    -- POB_POD_Qq:
   241.    POB_bits  : constant := 2#0000#;
   242.    POD_bits  : constant := 2#1000#;
   243.
   244.    -- POG_POL_Qq:
   245.    POG_bits  : constant := 2#0000#;
   246.    POL_bits  : constant := 2#1000#;
   247.
   248.    -- POH_POK_Qq:
   249.    POH_bits  : constant := 2#0000#;
   250.    POK_bits  : constant := 2#1000#;
   251.
   252.
   253.    -- compressed_opcode values for normal jump orders
   254.
   255.    JrNE   : constant KDF9.compressed_opcode := 2#000_001#;
   256.    JrGEZ  : constant KDF9.compressed_opcode := 2#000_010#;
   257.    JrLEZ  : constant KDF9.compressed_opcode := 2#000_100#;
   258.    JrNEZ  : constant KDF9.compressed_opcode := 2#000_110#;
   259.    JrNV   : constant KDF9.compressed_opcode := 2#001_000#;
   260.    OS_OUT : constant KDF9.compressed_opcode := 2#001_001#;
   261.    JrNEN  : constant KDF9.compressed_opcode := 2#001_010#;
   262.    Jr     : constant KDF9.compressed_opcode := 2#001_011#;
   263.    JrNEJ  : constant KDF9.compressed_opcode := 2#001_100#;
   264.    JSr    : constant KDF9.compressed_opcode := 2#001_101#;
   265.    JrNTR  : constant KDF9.compressed_opcode := 2#001_110#;
   266.    EXIT_n : constant KDF9.compressed_opcode := 2#001_111#;  -- 0h0 in bits 5-7
   267.    JrEQ   : constant KDF9.compressed_opcode := 2#010_001#;
   268.    JrLTZ  : constant KDF9.compressed_opcode := 2#010_010#;
   269.    JrGTZ  : constant KDF9.compressed_opcode := 2#010_100#;
   270.    JrEQZ  : constant KDF9.compressed_opcode := 2#010_110#;
   271.    JrV    : constant KDF9.compressed_opcode := 2#011_000#;
   272.    JrEN   : constant KDF9.compressed_opcode := 2#011_010#;
   273.    JrEJ   : constant KDF9.compressed_opcode := 2#011_100#;
   274.    JrTR   : constant KDF9.compressed_opcode := 2#011_110#;
   275.    EXITD  : constant KDF9.compressed_opcode := 2#011_111#;  -- 010 in bits 5-7
   276.    JrCqZ  : constant KDF9.compressed_opcode := 2#100_000#;
   277.    JrCqNZ : constant KDF9.compressed_opcode := 2#110_000#;
   278.
   279.    EXIT_1_bit : constant := 2#010#;  -- 0h0 in bits 5-7 of EXIT syllable_0
   280.
   281.
   282.    -- compressed_opcode values for directly-addressed data access orders
   283.
   284.    EaMq     : constant KDF9.compressed_opcode := 2#000_000#;
   285.    TO_EaMq  : constant KDF9.compressed_opcode := 2#000_001#;
   286.    EaMqQ    : constant KDF9.compressed_opcode := 2#000_010#;
   287.    TO_EaMqQ : constant KDF9.compressed_opcode := 2#000_011#;
   288.    SET      : constant KDF9.compressed_opcode := 2#000_100#;
   289.
   290.
   291. end KDF9.decoding;

 291 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-dispatcher.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:09

     1. -- CPU I/O orders are dispatched here to device-specific handlers within the IOC type hierarchy.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9.PHU_store;
    18. with tracing;
    19.
    20. use  tracing;
    21.
    22. package body IOC.dispatcher is
    23.
    24.    --
    25.    --
    26.    -- CLO, SLO and TLO do not operate on a buffer, and so can be fully implemented here.
    27.    --
    28.    --
    29.
    30.    procedure CLO (Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean) is
    32.       pragma Unreferenced(set_offline);
    33.       use  KDF9.PHU_store;
    34.    begin
    35.       -- This is a Director-only instruction.
    36.       take_note_of_test("   ", Q_operand, False);
    37.       unlock_absolute_addresses(Q_operand);
    38.       -- CLO also clears PHU[CPL].
    39.       PHU(CPL) := idle_PHU;
    40.       add_in_the_IO_lockout_CPU_time(Q_operand);
    41.    end CLO;
    42.
    43.    procedure SLO (Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean) is
    45.       pragma Unreferenced(set_offline);
    46.    begin
    47.       -- This is a Director-only instruction.
    48.       take_note_of_test("   ", Q_operand, False);
    49.       lock_out_absolute_addresses(Q_operand);
    50.       add_in_the_IO_lockout_CPU_time(Q_operand);
    51.    end SLO;
    52.
    53.    procedure TLO (Q_operand   : in KDF9.Q_register;
    54.                   result      : out Boolean) is
    55.    begin
    56.       -- This is NOT Director-only.
    57.       result := there_are_locks_in_relative_addresses(Q_operand);
    58.       take_note_of_test("   ", Q_operand, result);
    59.       add_in_the_IO_lockout_CPU_time(Q_operand);
    60.    end TLO;
    61.
    62.    --
    63.    --
    64.    -- All other I/O orders do access a buffer, and so dispatch to the relevant device driver.
    65.    --
    66.    --
    67.
    68.    procedure BUSY (Q_operand   : in KDF9.Q_register;
    69.                    set_offline : in Boolean;
    70.                    result      : out Boolean) is
    71.    begin
    72.       buffer(Q_operand.C and buffer_number_mask).BUSY(Q_operand, set_offline, result);
    73.    end BUSY;
    74.
    75.    procedure PAR (Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean;
    77.                   result      : out Boolean) is
    78.    begin
    79.       buffer(Q_operand.C and buffer_number_mask).PAR(Q_operand, set_offline, result);
    80.    end PAR;
    81.
    82.    procedure MANUAL_CT (Q_operand   : in KDF9.Q_register;
    83.                         set_offline : in Boolean) is
    84.    begin
    85.       buffer(Q_operand.C and buffer_number_mask).MANUAL_CT(Q_operand, set_offline);
    86.    end MANUAL_CT;
    87.
    88.    procedure INT (Q_operand   : in KDF9.Q_register;
    89.                   set_offline : in Boolean) is
    90.    begin
    91.       buffer(Q_operand.C and buffer_number_mask).INT(Q_operand, set_offline);
    92.    end INT;
    93.
    94.    procedure PIA (Q_operand   : in KDF9.Q_register;
    95.                   set_offline : in Boolean) is
    96.    begin
    97.       buffer(Q_operand.C and buffer_number_mask).PIA(Q_operand, set_offline);
    98.       add_in_the_IO_lockout_CPU_time(Q_operand);
    99.    end PIA;
   100.
   101.    procedure PIB (Q_operand   : in KDF9.Q_register;
   102.                   set_offline : in Boolean) is
   103.    begin
   104.       buffer(Q_operand.C and buffer_number_mask).PIB(Q_operand, set_offline);
   105.       add_in_the_IO_lockout_CPU_time(Q_operand);
   106.    end PIB;
   107.
   108.    procedure PIC (Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean) is
   110.    begin
   111.       buffer(Q_operand.C and buffer_number_mask).PIC(Q_operand, set_offline);
   112.       add_in_the_IO_lockout_CPU_time(Q_operand);
   113.    end PIC;
   114.
   115.    procedure PID (Q_operand   : in KDF9.Q_register;
   116.                   set_offline : in Boolean) is
   117.    begin
   118.       buffer(Q_operand.C and buffer_number_mask).PID(Q_operand, set_offline);
   119.       add_in_the_IO_lockout_CPU_time(Q_operand);
   120.    end PID;
   121.
   122.    procedure PIE (Q_operand   : in KDF9.Q_register;
   123.                   set_offline : in Boolean) is
   124.    begin
   125.       buffer(Q_operand.C and buffer_number_mask).PIE(Q_operand, set_offline);
   126.       add_in_the_IO_lockout_CPU_time(Q_operand);
   127.    end PIE;
   128.
   129.    procedure PIF (Q_operand   : in KDF9.Q_register;
   130.                   set_offline : in Boolean) is
   131.    begin
   132.       buffer(Q_operand.C and buffer_number_mask).PIF(Q_operand, set_offline);
   133.       add_in_the_IO_lockout_CPU_time(Q_operand);
   134.    end PIF;
   135.
   136.    procedure PIG (Q_operand   : in KDF9.Q_register;
   137.                   set_offline : in Boolean) is
   138.    begin
   139.       buffer(Q_operand.C and buffer_number_mask).PIG(Q_operand, set_offline);
   140.       add_in_the_IO_lockout_CPU_time(Q_operand);
   141.    end PIG;
   142.
   143.    procedure PIH (Q_operand   : in KDF9.Q_register;
   144.                   set_offline : in Boolean) is
   145.    begin
   146.       buffer(Q_operand.C and buffer_number_mask).PIH(Q_operand, set_offline);
   147.       add_in_the_IO_lockout_CPU_time(Q_operand);
   148.    end PIH;
   149.
   150.    procedure PMA (Q_operand   : in KDF9.Q_register;
   151.                   set_offline : in Boolean) is
   152.    begin
   153.       buffer(Q_operand.C and buffer_number_mask).PMA(Q_operand, set_offline);
   154.    end PMA;
   155.
   156.    procedure PMB (Q_operand   : in KDF9.Q_register;
   157.                   set_offline : in Boolean) is
   158.    begin
   159.       buffer(Q_operand.C and buffer_number_mask).PMB(Q_operand, set_offline);
   160.    end PMB;
   161.
   162.    procedure PMC (Q_operand   : in KDF9.Q_register;
   163.                   set_offline : in Boolean) is
   164.    begin
   165.       buffer(Q_operand.C and buffer_number_mask).PMC(Q_operand, set_offline);
   166.    end PMC;
   167.
   168.    procedure PMD (Q_operand   : in KDF9.Q_register;
   169.                   set_offline : in Boolean) is
   170.    begin
   171.       buffer(Q_operand.C and buffer_number_mask).PMD(Q_operand, set_offline);
   172.    end PMD;
   173.
   174.    procedure PME (Q_operand   : in KDF9.Q_register;
   175.                   set_offline : in Boolean) is
   176.    begin
   177.       buffer(Q_operand.C and buffer_number_mask).PME(Q_operand, set_offline);
   178.    end PME;
   179.
   180.    procedure PMF (Q_operand   : in KDF9.Q_register;
   181.                   set_offline : in Boolean) is
   182.    begin
   183.       buffer(Q_operand.C and buffer_number_mask).PMF(Q_operand, set_offline);
   184.    end PMF;
   185.
   186.    procedure PMG (Q_operand   : in KDF9.Q_register;
   187.                   set_offline : in Boolean) is
   188.    begin
   189.       buffer(Q_operand.C and buffer_number_mask).PMG(Q_operand, set_offline);
   190.    end PMG;
   191.
   192.    procedure PMK (Q_operand   : in KDF9.Q_register;
   193.                   set_offline : in Boolean) is
   194.    begin
   195.       buffer(Q_operand.C and buffer_number_mask).PMK(Q_operand, set_offline);
   196.    end PMK;
   197.
   198.    procedure PML (Q_operand   : in KDF9.Q_register;
   199.                   set_offline : in Boolean) is
   200.    begin
   201.       buffer(Q_operand.C and buffer_number_mask).PML(Q_operand, set_offline);
   202.    end PML;
   203.
   204.    procedure POA (Q_operand   : in KDF9.Q_register;
   205.                   set_offline : in Boolean) is
   206.    begin
   207.       buffer(Q_operand.C and buffer_number_mask).POA(Q_operand, set_offline);
   208.       add_in_the_IO_lockout_CPU_time(Q_operand);
   209.    end POA;
   210.
   211.    procedure POB (Q_operand   : in KDF9.Q_register;
   212.                   set_offline : in Boolean) is
   213.    begin
   214.       buffer(Q_operand.C and buffer_number_mask).POB(Q_operand, set_offline);
   215.       add_in_the_IO_lockout_CPU_time(Q_operand);
   216.    end POB;
   217.
   218.    procedure POC (Q_operand   : in KDF9.Q_register;
   219.                   set_offline : in Boolean) is
   220.    begin
   221.       buffer(Q_operand.C and buffer_number_mask).POC(Q_operand, set_offline);
   222.       add_in_the_IO_lockout_CPU_time(Q_operand);
   223.    end POC;
   224.
   225.    procedure POD (Q_operand   : in KDF9.Q_register;
   226.                   set_offline : in Boolean) is
   227.    begin
   228.       buffer(Q_operand.C and buffer_number_mask).POD(Q_operand, set_offline);
   229.       add_in_the_IO_lockout_CPU_time(Q_operand);
   230.    end POD;
   231.
   232.    procedure POE (Q_operand   : in KDF9.Q_register;
   233.                   set_offline : in Boolean) is
   234.    begin
   235.       buffer(Q_operand.C and buffer_number_mask).POE(Q_operand, set_offline);
   236.    end POE;
   237.
   238.    procedure POF (Q_operand   : in KDF9.Q_register;
   239.                   set_offline : in Boolean) is
   240.    begin
   241.       buffer(Q_operand.C and buffer_number_mask).POF(Q_operand, set_offline);
   242.    end POF;
   243.
   244.    procedure POG (Q_operand   : in KDF9.Q_register;
   245.                   set_offline : in Boolean) is
   246.    begin
   247.       buffer(Q_operand.C and buffer_number_mask).POG(Q_operand, set_offline);
   248.    end POG;
   249.
   250.    procedure POH (Q_operand   : in KDF9.Q_register;
   251.                   set_offline : in Boolean) is
   252.    begin
   253.       buffer(Q_operand.C and buffer_number_mask).POH(Q_operand, set_offline);
   254.    end POH;
   255.
   256.    procedure POK (Q_operand   : in KDF9.Q_register;
   257.                   set_offline : in Boolean) is
   258.    begin
   259.       buffer(Q_operand.C and buffer_number_mask).POK(Q_operand, set_offline);
   260.    end POK;
   261.
   262.    procedure POL (Q_operand   : in KDF9.Q_register;
   263.                   set_offline : in Boolean) is
   264.    begin
   265.       buffer(Q_operand.C and buffer_number_mask).POL(Q_operand, set_offline);
   266.    end POL;
   267.
   268. end IOC.dispatcher;

Compiling: ../Source/ioc-dispatcher.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:09

     1. -- CPU I/O orders are dispatched here to device-specific handlers within the IOC type hierarchy.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.dispatcher is
    18.
    19.    procedure MANUAL_CT (Q_operand   : in KDF9.Q_register;
    20.                         set_offline : in Boolean);
    21.
    22.    procedure BUSY (Q_operand   : in KDF9.Q_register;
    23.                    set_offline : in Boolean;
    24.                    result      : out Boolean);
    25.
    26.    procedure PAR (Q_operand   : in KDF9.Q_register;
    27.                   set_offline : in Boolean;
    28.                   result      : out Boolean);
    29.
    30.    procedure TLO (Q_operand   : in KDF9.Q_register;
    31.                   result      : out Boolean);
    32.
    33.    procedure CLO (Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    procedure SLO (Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    procedure INT (Q_operand   : in KDF9.Q_register;
    40.                   set_offline : in Boolean);
    41.
    42.    procedure PIA (Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    procedure PIB (Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    procedure PIC (Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    procedure PID (Q_operand   : in KDF9.Q_register;
    52.                   set_offline : in Boolean);
    53.
    54.    procedure PIE (Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    procedure PIF (Q_operand   : in KDF9.Q_register;
    58.                   set_offline : in Boolean);
    59.
    60.    procedure PIG (Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    procedure PIH (Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean);
    65.
    66.    procedure PMA (Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    procedure PMB (Q_operand   : in KDF9.Q_register;
    70.                   set_offline : in Boolean);
    71.
    72.    procedure PMC (Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    procedure PMD (Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.
    78.    procedure PME (Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    procedure PMF (Q_operand   : in KDF9.Q_register;
    82.                   set_offline : in Boolean);
    83.
    84.    procedure PMG (Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    procedure PMK (Q_operand   : in KDF9.Q_register;
    88.                   set_offline : in Boolean);
    89.
    90.    procedure PML (Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean);
    92.
    93.    procedure POA (Q_operand   : in KDF9.Q_register;
    94.                   set_offline : in Boolean);
    95.
    96.    procedure POB (Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean);
    98.
    99.    procedure POC (Q_operand   : in KDF9.Q_register;
   100.                   set_offline : in Boolean);
   101.
   102.    procedure POD (Q_operand   : in KDF9.Q_register;
   103.                   set_offline : in Boolean);
   104.
   105.    procedure POE (Q_operand   : in KDF9.Q_register;
   106.                   set_offline : in Boolean);
   107.
   108.    procedure POF (Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean);
   110.
   111.    procedure POG (Q_operand   : in KDF9.Q_register;
   112.                   set_offline : in Boolean);
   113.
   114.    procedure POH (Q_operand   : in KDF9.Q_register;
   115.                   set_offline : in Boolean);
   116.
   117.    procedure POK (Q_operand   : in KDF9.Q_register;
   118.                   set_offline : in Boolean);
   119.
   120.    procedure POL (Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean);
   122.
   123. end IOC.dispatcher;
   124.

 268 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-egdon.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:09

     1. -- Implement the API (OUTs) of the EGDON Director.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body KDF9.EGDON is
    18.
    19.    procedure do_an_EGDON_OUT (OUT_number : in KDF9.word) is
    20.    begin
    21.       trap_failing_OUT(OUT_number, "EGDON OUTs are not yet implemented");
    22.    end do_an_EGDON_OUT;
    23.
    24. end KDF9.EGDON;

Compiling: ../Source/kdf9-egdon.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:09

     1. -- Implement the API (OUTs) of the EGDON Director.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.EGDON is
    18.
    19.    procedure do_an_EGDON_OUT (OUT_number : in KDF9.word);
    20.
    21. end KDF9.EGDON;

 24 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd-processes.adb
Source file time stamp: 2021-02-20 23:51:07
Compiled at: 2021-02-21 15:54:09

     1. -- Implement OUTs 0, 1 and 2 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with dumping;
    18. with IOC;
    19. with IOC.fast.DR.TSD_OUTs;
    20. with IOC.fast.FD.TSD_OUTs;
    21. with IOC.slow.shift.TR;
    22. with KDF9_char_sets;
    23. with KDF9.CPU;
    24. with KDF9.store;
    25. with KDF9.TSD.peripherals;
    26.
    27. with environmental_value_of;
    28.
    29. use  dumping;
    30. use  IOC;
    31. use  IOC.fast.DR.TSD_OUTs;
    32. use  IOC.fast.FD.TSD_OUTs;
    33. use  IOC.slow.shift.TR;
    34. use  KDF9_char_sets;
    35. use  KDF9.store;
    36. use  KDF9.TSD.peripherals;
    37.
    38. package body KDF9.TSD.processes is
    39.
    40. --
    41. -- OUTs 0, 1 and 2 terminate execution in various ways and call for appropriate finalization.
    42. --
    43.
    44.    procedure free_any_allocated_tapes (OUT_number : in KDF9.word) is
    45.    begin
    46.       for b in KDF9.buffer_number loop
    47.          if buffer(b) /= null                      and then
    48.                buffer(b).kind in MT_kind | ST_kind and then
    49.                   is_allocated(buffer(b))              then
    50.             free_the_device_on_buffer(b, OUT_number);
    51.          end if;
    52.       end loop;
    53.    end free_any_allocated_tapes;
    54.
    55.
    56. --
    57. -- OUT 0: terminate the run.
    58. --
    59.
    60.    procedure do_OUT_0 is
    61.    begin
    62.       free_any_allocated_tapes(OUT_number => 0);
    63.       notify_state_display_of_final_ICR;
    64.       log_API_message("OUT 0: end of run");
    65.       raise program_exit;
    66.    end do_OUT_0;
    67.
    68.
    69. --
    70. -- OUT 1: terminate the run and overlay another program in a fresh start.
    71. --
    72.
    73.    procedure finalize_interim_diagnostics (OUT_number : in KDF9.word) is
    74.    begin
    75.       if the_log_is_wanted and pre_overlay_state_is_enabled then
    76.          show_final_state("before overlay by OUT" & OUT_number'Image);
    77.       end if;
    78.
    79.       -- Deal with any dump requests.
    80.       if the_log_is_wanted and nr_of_post_dumping_areas /= 0 then
    81.          log_new_line;
    82.          log_rule;
    83.          log_title("Post-run Dump:");
    84.          print_postrun_dump_areas;
    85.       end if;
    86.       remove_prerun_dump_areas;
    87.       remove_postrun_dump_areas;
    88.
    89.       -- Restart tracing.
    90.       clear_retro_FIFO;
    91.       clear_IOC_FIFO;
    92.       clear_the_histogram;
    93.       clear_the_profile;
    94.       the_profile_is_wanted := False;
    95.       the_INS_plot_is_wanted := False;
    96.       if the_external_trace_is_enabled then
    97.          log_an_external_trace_header("ee9: Restarting the run for OUT" & OUT_number'Image);
    98.       end if;
    99.    end finalize_interim_diagnostics;
   100.
   101.    procedure prepare_successor (new_limits : in KDF9.word; new_program_name : in String := "" ) is
   102.    begin
   103.       -- Set up any new options.
   104.       get_settings_from_file("2");
   105.       display_execution_modes(new_program_name);
   106.
   107.       -- Complete the core image.
   108.       poke_all_amendments;
   109.       save_the_initial_jump;
   110.       store_word(new_limits, 1);
   111.
   112.       -- Display initial dumps.
   113.       the_program_has_been_analysed := False;
   114.       show_all_prerun_dump_areas;
   115.
   116.       -- Establish the new CPU state.
   117.       reset_V_and_T;
   118.       set_NIA_to((0, 0));
   119.    end prepare_successor;
   120.
   121.    procedure do_OUT_1 is
   122.       P : KDF9.pair;
   123.       W : KDF9.word;
   124.    begin
   125.       -- Get the program name.
   126.       ensure_that_the_NEST_holds_2_operands;
   127.       P := pop;
   128.       P := KDF9.CPU.shift_logical(P, 24);
   129.
   130.       declare
   131.          program_name : constant String := trimmed(to_string(P));
   132.          overlay_name : constant String := environmental_value_of("KDF9_BINARY", default => "Binary")
   133.                                          & "/"
   134.                                          & program_name;
   135.       begin
   136.          if program_name = "" then
   137.             trap_failing_OUT(1, "the given program name is an empty string");
   138.          end if;
   139.
   140.          if program_name = "KMW0201--UPU" then
   141.             -- The Whetstone Controller is trying to overlay itself with the Translator.
   142.             -- This is so inconvenient in practice that I simply prevent it.
   143.             notify_state_display_of_final_ICR;
   144.             log_API_message("OUT 1: ee9 will not return to the Whetstone Translator", skip => 2);
   145.             raise program_exit;
   146.          end if;
   147.
   148.          -- Tidy up the running program.
   149.          free_all_devices;
   150.          complete_all_extant_transfers;
   151.          notify_state_display_of_final_ICR;
   152.          finalize_interim_diagnostics(OUT_number => 1);
   153.          log_API_message("OUT 1: ICR ="
   154.                        & ICR'Image
   155.                        & "; RAN/EL ="
   156.                        & the_CPU_time'Image
   157.                        & " /"
   158.                        & KDF9.us'Image(the_clock_time)
   159.                        & " KDF9 us"
   160.                         );
   161.
   162.          -- The overlaid program inherits the predecessor's time and store limits.
   163.          W := fetch_word(1);
   164.          load_a_program(overlay_name);
   165.          prepare_successor(new_limits => W, new_program_name => overlay_name);
   166.
   167.          raise mode_change_request;
   168.       end;
   169.    end do_OUT_1;
   170.
   171.
   172. --
   173. -- OUT 2: terminate the run and then restart it with a program already in core.
   174. -- complete_TSD_OUT_2 is called by KDF9.microcode after it has finalized the OUT instruction.
   175. --
   176.
   177.    time_limit : KDF9.word;
   178.
   179.    procedure do_OUT_2 is
   180.    begin
   181.       ensure_that_the_NEST_holds_an_operand;
   182.       time_limit := pop;
   183.       the_trace_operand := time_limit;
   184.
   185.       -- Tidy up the running program.
   186.       free_any_allocated_tapes(OUT_number => 2);
   187.       free_any_reserved_disc_space;
   188.       free_any_reserved_drum_space;
   189.       notify_state_display_of_final_ICR;
   190.
   191.       raise OUT_2_restart;
   192.    end do_OUT_2;
   193.
   194.    procedure complete_TSD_OUT_2 is
   195.    begin
   196.       finalize_interim_diagnostics(OUT_number => 2);
   197.       if time_limit >= 2**24 then
   198.          trap_failing_OUT(2, "the new time limit =" & time_limit'Image & "s is too big");
   199.       end if;
   200.
   201.       log_API_message("OUT 2: ICR ="
   202.                     & ICR'Image
   203.                     & "; RAN/EL ="
   204.                     & the_CPU_time'Image
   205.                     & " /"
   206.                     & KDF9.us'Image(the_clock_time)
   207.                     & " KDF9 us"
   208.                     & "; new time limit = "
   209.                     & time_limit'Image &"s"
   210.                      );
   211.
   212.       --The successor has a new time limit and inherits the predecessor's store limit.
   213.       prepare_successor(new_limits => time_limit * 2**24 + fetch_halfword(1, 1) / 2**24);
   214.
   215.       reset_the_program_state;
   216.    end complete_TSD_OUT_2;
   217.
   218.
   219. --
   220. -- OUT 97: this not a genuine TSD OUT.
   221. --
   222.
   223.    procedure do_OUT_97 is
   224.       P      : constant KDF9.word := pop;
   225.       name   : constant String    := trimmed(to_string(P));
   226.       value  : constant String    := environmental_value_of(name, "0");
   227.       number : KDF9.word;
   228.    begin
   229.       number := KDF9.word'Value(value);
   230.       the_trace_operand := number;
   231.       push(number);
   232.    exception
   233.       when others =>
   234.          trap_failing_OUT(97, name & " = '" & value & "', not a valid integer");
   235.    end do_OUT_97;
   236.
   237. end KDF9.TSD.processes;

Compiling: ../Source/kdf9-tsd-processes.ads
Source file time stamp: 2021-02-13 00:29:10
Compiled at: 2021-02-21 15:54:09

     1. -- Implement OUTs 0.. 2 and 5..7 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.processes is
    18.
    19.    procedure do_OUT_0
    20.       with No_Return, Inline => False;
    21.
    22.    procedure do_OUT_1
    23.       with No_Return, Inline => False;
    24.
    25.    procedure do_OUT_2
    26.       with No_Return, Inline => False;
    27.
    28.    procedure complete_TSD_OUT_2
    29.       with Inline => False;
    30.
    31.    procedure do_OUT_97
    32.       with Inline => False;
    33.
    34. end KDF9.TSD.processes;

 237 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/disassembly.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:09

     1. -- Produce dis-assembled instructions in an approximation to KDF9 Usercode.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with formatting;
    18. with KDF9.CPU;
    19. with KDF9.decoding;
    20.
    21. use  formatting;
    22. use  KDF9.CPU;
    23. use  KDF9.decoding;
    24.
    25. package body disassembly is
    26.
    27.    function flagged (flag : String; s : KDF9.syllable)
    28.    return String
    29.    is (flag & oct_of(s));
    30.
    31.    function machine_code (decoded : KDF9.decoded_order)
    32.    return String
    33.    is (
    34.        case decoded.kind is
    35.           when one_syllable_order => flagged("#", decoded.order.syllable_0),
    36.
    37.           when two_syllable_order => flagged("#", decoded.order.syllable_0)
    38.                                    & flagged(":", decoded.order.syllable_1),
    39.           when normal_jump_order
    40.              | data_access_order  => flagged("#", decoded.order.syllable_0)
    41.                                    & flagged(":", decoded.order.syllable_1)
    42.                                    & flagged(":", decoded.order.syllable_2)
    43.       );
    44.
    45.    function one_syllable_order_name (decoded : KDF9.decoded_order)
    46.    return String
    47.    is (
    48.        case decoded.compressed_opcode is
    49.           when ABS_9   => "ABS",
    50.           when ABSF    => "ABSF",
    51.           when AND_9   => "AND",
    52.           when BITS    => "BITS",
    53.           when CAB     => "CAB",
    54.           when CONT    => "CONT",
    55.           when DIV     => "/",
    56.           when DIVD    => "/D",
    57.           when DIVDF   => "/DF",
    58.           when DIVF    => "/F",
    59.           when DIVI    => "/I",
    60.           when DIVR    => "/R",
    61.           when DUMMY   => "DUMMY",
    62.           when DUP     => "DUP",
    63.           when DUPD    => "DUPD",
    64.           when ERASE   => "ERASE",
    65.           when FIX     => "FIX",
    66.           when FLOAT_9 => "FLOAT",
    67.           when FLOATD  => "FLOATD",
    68.           when FRB     => "FRB",
    69.           when MAX     => "MAX",
    70.           when MAXF    => "MAXF",
    71.           when MINUS   => "-",
    72.           when MINUSD  => "-D",
    73.           when MINUSDF => "-DF",
    74.           when MINUSF  => "-F",
    75.           when NEG     => "NEG",
    76.           when NEGD    => "NEGD",
    77.           when NEGDF   => "NEGDF",
    78.           when NEGF    => "NEGF",
    79.           when NEV     => "NEV",
    80.           when NOT_9   => "NOT",
    81.           when OR_9    => "OR",
    82.           when PERM    => "PERM",
    83.           when PLUS    => "+",
    84.           when PLUSD   => "+D",
    85.           when PLUSDF  => "+DF",
    86.           when PLUSF   => "+F",
    87.           when REV     => "REV",
    88.           when REVD    => "REVD",
    89.           when ROUND   => "ROUND",
    90.           when ROUNDF  => "ROUNDF",
    91.           when ROUNDH  => "ROUNDH",
    92.           when ROUNDHF => "ROUNDHF",
    93.           when SIGN    => "SIGN",
    94.           when SIGNF   => "SIGNF",
    95.           when STAND   => "STAND",
    96.           when STR     => "STR",
    97.           when TO_TR   => "=TR",
    98.           when TOB     => "TOB",
    99.           when VR      => "VR",
   100.           when X_frac  => "",
   101.           when XD      => "D",
   102.           when XDF     => "DF",
   103.           when XF      => "F",
   104.           when XPLUSF  => "+F",
   105.           when ZERO    => "ZERO",
   106.           when 0       => "DUMMY0",
   107.           when others  =>  machine_code(decoded)
   108.        );
   109.
   110.    function two_syllable_order_name (decoded : KDF9.decoded_order)
   111.    return String is
   112.
   113.       default : constant String := machine_code(decoded);
   114.       invalid : constant String := "";
   115.       k       : constant String := trimmed(decoded.Qk'Image);
   116.       q       : constant String := trimmed(decoded.Qq'Image);
   117.       opcode  : constant KDF9.compressed_opcode := (decoded.Qk and not manual_bit);
   118.       CT      : constant Boolean := (decoded.Qk and manual_bit) = 0;
   119.
   120.       function IO_order (stem : String)
   121.       return String
   122.       is (if stem = invalid then default else stem & "Q" & q);
   123.
   124.       function IO_order_name
   125.       return String
   126.       is (
   127.           case decoded.compressed_opcode is
   128.                when PIA_PIC_CLO_TLO_Qq =>
   129.                                    IO_order(case opcode is
   130.                                                when PIA_bits => "PIA",
   131.                                                when PIC_bits => "PIC",
   132.                                                when CLO_bits => "CLO",
   133.                                                when TLO_bits => "TLO",
   134.                                                when others   => invalid),
   135.                when PIB_PID_Qq =>
   136.                                    IO_order(case opcode is
   137.                                                when PIB_bits => "PIB",
   138.                                                when PID_bits => "PID",
   139.                                                when others   => invalid),
   140.                when PIE_PIG_Qq =>
   141.                                    IO_order(case opcode is
   142.                                                when PIE_bits => "PIE",
   143.                                                when PIG_bits => "PIG",
   144.                                                when others   => invalid),
   145.                when PIF_PIH_Qq =>
   146.                                    IO_order(case opcode is
   147.                                                when PIF_bits => "PIF",
   148.                                                when PIH_bits => "PIH",
   149.                                                when others   => invalid),
   150.                when PMA_PMK_INT_Qq =>
   151.                                    IO_order(case opcode is
   152.                                                when PMA_bits => "PMA",
   153.                                                when PMK_bits => "PMK",
   154.                                                when INT_bits => "INT",
   155.                                                when others   => invalid),
   156.                when CT_PMB_PMC_BUSY_Qq =>
   157.                                    IO_order(case opcode is
   158.                                                when PMB_bits  => "PMB",
   159.                                                when PMC_bits  => "PMC",
   160.                                                when BUSY_bits => "BUSY",
   161.                                                when CTQ_bits => (if CT then "CT" else "MANUAL"),
   162.                                                when others    => invalid),
   163.                when PMD_PME_PML_Qq =>
   164.                                    IO_order(case opcode is
   165.                                                when PMD_bits => "PMD",
   166.                                                when PME_bits => "PME",
   167.                                                when PML_bits => "PML",
   168.                                                when others   => invalid),
   169.                when PMF_PMG_Qq =>
   170.                                    IO_order(case opcode is
   171.                                                when PMF_bits => "PMF",
   172.                                                when PMG_bits => "PMG",
   173.                                                when others   => invalid),
   174.                when POA_POC_POE_POF_PMH_Qq =>
   175.                                    IO_order(case opcode is
   176.                                                when POA_bits => "POA",
   177.                                                when POC_bits => "POC",
   178.                                                when POE_bits => "POE",
   179.                                                when POF_bits => "POF",
   180.                                                when PMH_bits => "PMH",
   181.                                                when others   => invalid),
   182.                when POB_POD_Qq =>
   183.                                    IO_order(case opcode is
   184.                                                when POB_bits => "POB",
   185.                                                when POD_bits => "POD",
   186.                                                when others   => invalid),
   187.                when POG_POL_Qq =>
   188.                                    IO_order(case opcode is
   189.                                                when POG_bits => "POG",
   190.                                                when POL_bits => "POL",
   191.                                                when others   => invalid),
   192.                when POH_POK_Qq =>
   193.                                    IO_order(case opcode is
   194.                                                when POH_bits => "POH",
   195.                                                when POL_bits => "POK",
   196.                                                when others   => invalid),
   197.                when PAR_Qq =>      IO_order("PAR"),
   198.                when others =>      IO_order(invalid)
   199.          );
   200.
   201.       function indirect_store_order_name (suffix : String := "")
   202.       return String
   203.       is ("=M" & k & "M" & q & suffix);
   204.
   205.       function indirect_fetch_order_name (suffix : String := "")
   206.       return String
   207.       is ("M" & k & "M" & q & suffix);
   208.
   209.       function Qq_to_Qk_name (part : String)
   210.       return String
   211.       is (part & q & " TO Q" & k);
   212.
   213.       function Qq_order_name (action : String; suffix : String := "")
   214.       return String
   215.       is (action & q & suffix);
   216.
   217.       function shift_count
   218.       return String is
   219.          constant_flag : constant := 1;
   220.          fixed_shift   : CPU.signed_Q_part;
   221.       begin
   222.          if (decoded.order.syllable_1 and constant_flag) /= 0  then
   223.             fixed_shift := resign(KDF9.Q_part(decoded.order.syllable_1/2));
   224.             if fixed_shift > 63 then
   225.                fixed_shift := fixed_shift - 128;
   226.             end if;
   227.             return (if fixed_shift < 0 then "" else "+") & trimmed(fixed_shift'Image);
   228.          else
   229.             return "C" & q;
   230.          end if;
   231.       end shift_count;
   232.
   233.       function shift_order_name (action : String)
   234.       return String
   235.       is (action & shift_count);
   236.
   237.    begin -- two_syllable_order_name
   238.       return
   239.          (
   240.           case decoded.compressed_opcode is
   241.              when MkMq       => indirect_fetch_order_name,
   242.              when MkMqQ      => indirect_fetch_order_name(suffix => "Q"),
   243.              when MkMqH      => indirect_fetch_order_name(suffix => "H"),
   244.              when MkMqQH     => indirect_fetch_order_name(suffix => "QH"),
   245.              when MkMqN      => indirect_fetch_order_name(suffix => "N"),
   246.              when MkMqQN     => indirect_fetch_order_name(suffix => "QN"),
   247.              when MkMqHN     => indirect_fetch_order_name(suffix => "HN"),
   248.              when MkMqQHN    => indirect_fetch_order_name(suffix => "QHN"),
   249.
   250.              when TO_MkMq    => indirect_store_order_name,
   251.              when TO_MkMqQ   => indirect_store_order_name(suffix => "Q"),
   252.              when TO_MkMqH   => indirect_store_order_name(suffix => "H"),
   253.              when TO_MkMqQH  => indirect_store_order_name(suffix => "QH"),
   254.              when TO_MkMqN   => indirect_store_order_name(suffix => "N"),
   255.              when TO_MkMqQN  => indirect_store_order_name(suffix => "QN"),
   256.              when TO_MkMqHN  => indirect_store_order_name(suffix => "HN"),
   257.              when TO_MkMqQHN => indirect_store_order_name(suffix => "QHN"),
   258.
   259.              when M_PLUS_Iq  => Qq_order_name("M+I"),
   260.              when M_MINUS_Iq => Qq_order_name("M-I"),
   261.              when NCq        => Qq_order_name("NC"),
   262.              when DCq        => Qq_order_name("DC"),
   263.              when POS1_TO_Iq => Qq_order_name("I",  suffix => "=+1"),
   264.              when NEG1_TO_Iq => Qq_order_name("I",  suffix => "=-1"),
   265.              when POS2_TO_Iq => Qq_order_name("I",  suffix => "=+2"),
   266.              when NEG2_TO_Iq => Qq_order_name("I",  suffix => "=+2"),
   267.              when JCqNZS     => Qq_order_name("JC", suffix => "NZS"),
   268.
   269.              when MqTOQk     => Qq_to_Qk_name("M"),
   270.              when IqTOQk     => Qq_to_Qk_name("I"),
   271.              when IMqTOQk    => Qq_to_Qk_name("IM"),
   272.              when CqTOQk     => Qq_to_Qk_name("C"),
   273.              when CMqTOQk    => Qq_to_Qk_name("CM"),
   274.              when CIqTOQk    => Qq_to_Qk_name("CI"),
   275.              when QqTOQk     => Qq_to_Qk_name("Q"),
   276.              when QCIMq =>
   277.                 (
   278.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then  Qq_order_name("Q")
   279.                  elsif (decoded.Qk and M_part_choice) /= 0       then  Qq_order_name("M")
   280.                  elsif (decoded.Qk and C_part_choice) /= 0       then  Qq_order_name("C")
   281.                  elsif (decoded.Qk and I_part_choice) /= 0       then  Qq_order_name("I")
   282.                  else  default
   283.                 ),
   284.              when TO_RCIMq =>
   285.                 (
   286.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then Qq_order_name("=Q")
   287.                  elsif (decoded.Qk and M_part_choice) /= 0 then
   288.                     Qq_order_name(if (decoded.Qk and reset_choice) /= 0 then "=RM" else "=M")
   289.                  elsif (decoded.Qk and C_part_choice) /= 0 then
   290.                     Qq_order_name(if (decoded.Qk and reset_choice) /= 0 then "=RC" else "=C")
   291.                  elsif (decoded.Qk and I_part_choice) /= 0 then
   292.                     Qq_order_name(if (decoded.Qk and reset_choice) /= 0 then "=RI" else "=I")
   293.                  else default
   294.                 ),
   295.              when ADD_TO_QCIMq =>
   296.                 (
   297.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then Qq_order_name("=+Q")
   298.                  elsif (decoded.Qk and M_part_choice) /= 0       then Qq_order_name("=+M")
   299.                  elsif (decoded.Qk and C_part_choice) /= 0       then Qq_order_name("=+C")
   300.                  elsif (decoded.Qk and I_part_choice) /= 0       then Qq_order_name("=+I")
   301.                  else  default
   302.                 ),
   303.
   304.              when SHA   => shift_order_name("SHA"),
   305.              when SHAD  => shift_order_name("SHAD"),
   306.              when MACC  => shift_order_name("+"),
   307.              when SHL   => shift_order_name("SHL"),
   308.              when SHLD  => shift_order_name("SHLD"),
   309.              when SHC   => shift_order_name("SHC"),
   310.
   311.              when TO_Kq =>
   312.                 (
   313.                  case decoded.Qq is
   314.                     when K0 => "=K0",
   315.                     when K1 => "=K1",
   316.                     when K2 => "=K2",
   317.                     when K3 => "=K3",
   318.                     when others => default
   319.                 ),
   320.              when Kk =>
   321.                 (
   322.                  case decoded.Qk is
   323.                    when K4 => "K4",
   324.                    when K5 => "K5",
   325.                    when K7 => "K7",
   326.                    when others => default
   327.                 ),
   328.
   329.              when LINK    => "LINK",
   330.              when TO_LINK => "=LINK",
   331.
   332.              when others  => IO_order_name
   333.           );
   334.    end two_syllable_order_name;
   335.
   336.    function normal_jump_order_name (decoded      : KDF9.decoded_order;
   337.                                     octal_option : Boolean := True;
   338.                                     both_bases   : Boolean := True)
   339.    return String is
   340.
   341.       the_target  : syllable_address renames decoded.target;
   342.       the_address : constant String := oct_or_dec_of(the_target, octal_option);
   343.       remark      : constant String
   344.                   := ";("
   345.                    & (if   octal_option
   346.                       then dec_of(KDF9.Q_part(the_target.order_word_number))
   347.                       else "#" & oct_of(the_target.order_word_number))
   348.                    & ")";
   349.
   350.       function jump (on_condition : String)
   351.       return String
   352.       is ("JE" & the_address & on_condition & (if both_bases then remark else ""));
   353.
   354.       function leave (and_how : String)
   355.       return String
   356.       is ("EXIT" & and_how & remark);
   357.
   358.    begin  -- normal_jump_order_name
   359.       return (
   360.               case decoded.compressed_opcode is
   361.                  when JrEQ   => jump("EQ"),
   362.                  when JrGTZ  => jump("GTZ"),
   363.                  when JrLTZ  => jump("LTZ"),
   364.                  when JrEQZ  => jump("EQZ"),
   365.                  when JrV    => jump("V"),
   366.                  when JrEN   => jump("EN"),
   367.                  when Jr     => jump(""),
   368.                  when JrEJ   => jump("EJ"),
   369.                  when JrTR   => jump("TR"),
   370.                  when JrNE   => jump("NE"),
   371.                  when JrLEZ  => jump("LEZ"),
   372.                  when JrGEZ  => jump("GEZ"),
   373.                  when JrNEZ  => jump("NEZ"),
   374.                  when JrNV   => jump("NV"),
   375.                  when JrNEN  => jump("NEN"),
   376.                  when JrNEJ  => jump("NEJ"),
   377.                  when JrNTR  => jump("NTR"),
   378.
   379.                  when JrCqZ  => jump("C" & trimmed(decoded.Qq'Image) & "Z"),
   380.                  when JrCqNZ => jump("C" & trimmed(decoded.Qq'Image) & "NZ"),
   381.
   382.                  when JSr    => "JSE" & the_address,
   383.                  when OS_OUT => "OUT",
   384.
   385.                  when EXITD  => leave("D"),
   386.                  when EXIT_n =>
   387.                     -- Try to give the most helpful interpretation of the operand.
   388.                     (
   389.                      if the_target.syllable_index = 0 then  -- c.f. decode_a_jump_order.
   390.                         -- No halfword offset applies.
   391.                         (
   392.                          if the_target.order_word_number < 4 then
   393.                            leave(
   394.                                  if the_target.order_word_number = 0
   395.                                  then ""
   396.                                  else oct_of(KDF9.Q_part(2*the_target.order_word_number), 1)
   397.                                 )
   398.                          else
   399.                            leave("AE" & oct_or_dec_of((the_target.order_word_number, 0), octal_option))
   400.                         )
   401.                      elsif the_target.order_word_number < 4 then
   402.                         leave(oct_of(KDF9.Q_part(2*the_target.order_word_number + 1), 1))
   403.                      else
   404.                         leave("AE" & oct_or_dec_of((the_target.order_word_number, 3), octal_option))
   405.                     ),
   406.
   407.                  when others =>  machine_code(decoded)
   408.              );
   409.    end normal_jump_order_name;
   410.
   411.    function data_access_order_name (decoded      : KDF9.decoded_order;
   412.                                     octal_option : Boolean;
   413.                                     both_bases   : Boolean := True)
   414.    return String is
   415.
   416.       operand      : KDF9.Q_part   renames decoded.operand;
   417.       Qq           : KDF9.Q_number renames decoded.Qq;
   418.       the_address  : constant String
   419.                    := (if octal_option then "#" & oct_of(operand, 1) else dec_of(operand));
   420.       remark       : constant String
   421.                    := ";(" & (if octal_option then dec_of(operand) else "#" & oct_of(operand, 1)) & ")";
   422.       any_modifier : constant String
   423.                    := (if Qq /= 0 then "M" & trimmed(Qq'Image) else "");
   424.    begin
   425.       return (
   426.               case decoded.compressed_opcode is
   427.                  when EaMq     => "E"   & the_address & any_modifier & remark,
   428.                  when TO_EaMq  => "=E"  & the_address & any_modifier & remark,
   429.                  when EaMqQ    => "E"   & the_address & any_modifier & "Q" & remark,
   430.                  when TO_EaMqQ => "=E"  & the_address & any_modifier & "Q" & remark,
   431.                  when SET      => "SET" & (
   432.                                            if octal_option
   433.                                            then "B" & oct_of(operand, 2)
   434.                                               & (
   435.                                                  if operand > 7 and both_bases
   436.                                                  then ";(" & signed_dec_of(operand) & ")"
   437.                                                  else ""
   438.                                                 )
   439.                                            else signed_dec_of(operand)
   440.                                               & (
   441.                                                  if operand > 9 and both_bases
   442.                                                  then ";(B" & oct_of(operand, 2) & ")"
   443.                                                  else ""
   444.                                                 )
   445.                                           ),
   446.                  when others   => "?"
   447.              );
   448.    end data_access_order_name;
   449.
   450.    function the_full_name_of (order        : KDF9.decoded_order;
   451.                               octal_option : Boolean := True;
   452.                               both_bases   : Boolean := True)
   453.    return String is
   454.       result : constant String
   455.          := (
   456.              case order.kind is
   457.                 when one_syllable_order => one_syllable_order_name(order),
   458.                 when two_syllable_order => two_syllable_order_name(order),
   459.                 when normal_jump_order  => normal_jump_order_name(order, octal_option, both_bases),
   460.                 when data_access_order  => data_access_order_name(order, octal_option, both_bases)
   461.             );
   462.    begin
   463.       return (if result(1) /= '?' then result else "an INVALID order");
   464.    end the_full_name_of;
   465.
   466.    function the_code_and_name_of_INS
   467.    return String
   468.    is (machine_code(INS) & ", i.e. " & the_full_name_of(INS));
   469.
   470.    function two_syllable_skeleton (encoding : KDF9.syllable)
   471.    return String is
   472.
   473.       function IO_skeleton
   474.       return String
   475.       is (
   476.           case encoding and 8#77# is
   477.              when POA_POC_POE_POF_PMH_Qq => "{POA|POC|POE|POF|PMH}Qq",
   478.              when PIA_PIC_CLO_TLO_Qq     => "{PIA|PIC|CLO|TLO}Qq",
   479.              when CT_PMB_PMC_BUSY_Qq     => "{BUSY|CT|MANUAL|PMB|PMC}Qq",
   480.              when PAR_Qq                 => "PARQq",
   481.              when PIB_PID_Qq             => "{PIB|PID}Qq",
   482.              when PIE_PIG_Qq             => "{PIE|PIG}Qq",
   483.              when PIF_PIH_Qq             => "{PIF|PIH}Qq",
   484.              when PMA_PMK_INT_Qq         => "{INT|PMA|PMK}Qq",
   485.              when PMD_PME_PML_Qq         => "{PMD|PME}Qq",
   486.              when PMF_PMG_Qq             => "{PMF|PMG}Qq",
   487.              when POB_POD_Qq             => "{POB|POD}Qq",
   488.              when POG_POL_Qq             => "{POG|POL}Qq",
   489.              when POH_POK_Qq             => "{POH|POK}Qq",
   490.              when others                 => "invalid IO group syllable #" & oct_of(encoding)
   491.          );
   492.
   493.    begin  -- two_syllable_skeleton
   494.       return
   495.          (
   496.           case encoding and 8#77# is
   497.              when MkMq         => "MkMq",
   498.              when MkMqQ        => "MkMqQ",
   499.              when MkMqH        => "MkMqH",
   500.              when MkMqQH       => "MkMqQH",
   501.              when MkMqN        => "MkMqN",
   502.              when MkMqQN       => "MkMqQN",
   503.              when MkMqHN       => "MkMqHN",
   504.              when MkMqQHN      => "MkMqQHN",
   505.
   506.              when TO_MkMq      => "=MkMq",
   507.              when TO_MkMqQ     => "=MkMqQ",
   508.              when TO_MkMqH     => "=MkMqH",
   509.              when TO_MkMqQH    => "=MkMqQH",
   510.              when TO_MkMqN     => "=MkMqN",
   511.              when TO_MkMqQN    => "=MkMqQN",
   512.              when TO_MkMqHN    => "=MkMqHN",
   513.              when TO_MkMqQHN   => "=MkMqQHN",
   514.
   515.              when JCqNZS       => "JCqNZS",
   516.              when M_PLUS_Iq    => "M+Iq",
   517.              when M_MINUS_Iq   => "M-Iq",
   518.              when NCq          => "NCq",
   519.              when DCq          => "DCq",
   520.              when POS1_TO_Iq   => "Iq=+1",
   521.              when NEG1_TO_Iq   => "Iq=-1",
   522.              when POS2_TO_Iq   => "Iq=+2",
   523.              when NEG2_TO_Iq   => "Iq=-2",
   524.
   525.              when MqTOQk       => "MqTOQk",
   526.              when IqTOQk       => "IqTOQk",
   527.              when IMqTOQk      => "IMqTOQk",
   528.              when CqTOQk       => "CqTOQk",
   529.              when CMqTOQk      => "CMqTOQk",
   530.              when CIqTOQk      => "CIqTOQk",
   531.              when QqTOQk       => "QqTOQk",
   532.
   533.              when QCIMq        => "{Q|C|I|M}q",
   534.              when TO_RCIMq     => "=[R]{Q|C|I|M}q",
   535.              when ADD_TO_QCIMq => "=+{Q|C|I|M}q",
   536.
   537.              when SHA          => "SHA",
   538.              when SHAD         => "SHAD",
   539.              when MACC         => "+",
   540.              when SHL          => "SHL",
   541.              when SHLD         => "SHLD",
   542.              when SHC          => "SHC",
   543.
   544.              when TO_Kq =>
   545.                 (
   546.                  case encoding / 16 mod 16 is
   547.                     when K0 => "=K0",
   548.                     when K1 => "=K1",
   549.                     when K2 => "=K2",
   550.                     when K3 => "=K3",
   551.                     when others => "=K?"
   552.                 ),
   553.              when Kk =>
   554.                 (
   555.                  case encoding mod 16 is
   556.                     when K4 => "K4",
   557.                     when K5 => "K5",
   558.                     when K7 => "K7",
   559.                     when others => "K?"
   560.                 ),
   561.
   562.              when LINK =>    "LINK",
   563.              when TO_LINK => "=LINK",
   564.
   565.              when others =>  IO_skeleton
   566.          );
   567.    end two_syllable_skeleton;
   568.
   569.    function normal_jump_skeleton (encoding : KDF9.syllable)
   570.    return String
   571.    is (
   572.        case encoding and 8#77# is
   573.           when JrCqZ  .. JrCqZ+2#1111#  => "JrCqZ",
   574.           when JrCqNZ .. JrCqNZ+2#1111# => "JrCqNZ",
   575.           when JrEQ   => "JrEQ",
   576.           when JrGTZ  => "JrGTZ",
   577.           when JrLTZ  => "JrLTZ",
   578.           when JrEQZ  => "JrEQZ",
   579.           when JrV    => "JrV",
   580.           when JrEN   => "JrEN",
   581.           when Jr     => "Jr",
   582.           when JrEJ   => "JrEJ",
   583.           when JSr    => "JSr",
   584.           when JrTR   => "JrTR",
   585.           when EXIT_n => "EXIT",
   586.           when JrNE   => "JrNE",
   587.           when JrLEZ  => "JrLEZ",
   588.           when JrGEZ  => "JrGEZ",
   589.           when JrNEZ  => "JrNEZ",
   590.           when JrNV   => "JrNV",
   591.           when JrNEN  => "JrNEN",
   592.           when JrNEJ  => "JrNEJ",
   593.           when JrNTR  => "JrNTR",
   594.           when OS_OUT => "OUT",
   595.           when EXITD  => "EXITD",
   596.           when others => "invalid jump group syllable #" & oct_of(encoding)
   597.       );
   598.
   599.    function data_access_skeleton (compressed_opcode : KDF9.compressed_opcode)
   600.    return String
   601.    is (
   602.        case compressed_opcode is
   603.           when EaMq     => "EeMq",
   604.           when TO_EaMq  => "=EeMq",
   605.           when EaMqQ    => "EeMqQ",
   606.           when TO_EaMqQ => "=EeMqQ",
   607.           when SET      => "SET",
   608.           when others   => "invalid data access compressed opcode #" & oct_of(compressed_opcode)
   609.       );
   610.
   611.    function the_short_name_of (syllable_0 : KDF9.syllable)
   612.    return String is
   613.       its_INS : KDF9.decoded_order := (order => (syllable_0, 0, 0), others => <>);
   614.    begin
   615.       decode(its_INS);
   616.       return
   617.          (
   618.           case KDF9.INS_kind(syllable_0 / 2**6) is
   619.              when one_syllable_order   => one_syllable_order_name(its_INS),
   620.              when two_syllable_order   => two_syllable_skeleton(syllable_0),
   621.              when normal_jump_order    => normal_jump_skeleton(syllable_0),
   622.              when data_access_order    => data_access_skeleton(its_INS.compressed_opcode)
   623.          );
   624.    end the_short_name_of;
   625.
   626. end disassembly;

Compiling: ../Source/disassembly.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:09

     1. -- Produce dis-assembled instructions in an approximation to KDF9 Usercode.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18.
    19. use  KDF9;
    20.
    21. package disassembly is
    22.
    23.    function the_code_and_name_of_INS
    24.    return String;
    25.
    26.    function the_full_name_of (order        : KDF9.decoded_order;
    27.                               octal_option : Boolean := True;
    28.                               both_bases   : Boolean := True)
    29.    return String;
    30.
    31.    function the_short_name_of (syllable_0 : KDF9.syllable)
    32.    return String;
    33.
    34. end disassembly;

 626 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-diagnostics.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:10

     1. -- Provide diagnostic output of the state of all the buffers.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with disassembly;
    18.
    19. with IOC.the_locker_of;
    20.
    21. procedure IOC.diagnostics is
    22.    Q : KDF9.Q_register;
    23.    B : KDF9.Q_part;
    24.    F : Boolean;
    25. begin
    26.    if not debugging_is_enabled then return; end if;
    27.    for g in Q_part'(0) .. 100 loop
    28.       if there_are_locks_in_physical_addresses(KDF9.Q_register'(0, 32*g, 32*g + 31)) then
    29.          output("there are locks in group" & g'Image & " PHY" & Q_part'(32*g)'Image);
    30.          B := the_locker_of(32*g, F);
    31.          output(", locked by" & B'Image & ":");
    32.          if F then output_line(buffer(B).device_name); else output_line(""); end if;
    33.       end if;
    34.    end loop;
    35.    for the_buffer of buffer loop
    36.       if the_buffer /= null                        and then
    37.          the_buffer.initiation_time /= KDF9.us'Last    then
    38.          output_line;
    39.          output_line("Current state of buffer #" & oct_of(the_buffer.number, 2));
    40.          output_line(
    41.                      "   device: " & the_buffer.device_name
    42.                    & "     kind: " & the_buffer.kind'Image
    43.                    & "     unit:"  & the_buffer.unit'Image
    44.                     );
    45.          output_line("  is_busy: " & the_buffer.is_busy'Image);
    46.          output_line("operation: " & the_buffer.operation'Image);
    47.          output_line(" off_line: " & the_buffer.is_offline'Image);
    48.          output_line(" abnormal: " & the_buffer.is_abnormal'Image);
    49.          output_line(" Director: " & the_buffer.is_for_Director'Image);
    50.          output_line(" priority:"  & the_buffer.priority_level'Image);
    51.          output_line("initiated:"  & the_buffer.initiation_time'Image);
    52.          output_line("xfer_time:"  & the_buffer.transfer_time'Image);
    53.          output_line("completes:"  & the_buffer.completion_time'Image);
    54.          Q := the_buffer.control_word;
    55.          output_line(
    56.                      "  control: "
    57.                    & "Q"
    58.                    & Q.C'Image
    59.                    &"/"
    60.                    & Q.I'Image
    61.                    & "/"
    62.                    & Q.M'Image
    63.                     );
    64.          if Q.I <= max_address               and then
    65.              Q.M <= max_address              and then
    66.                 Q.I <= the_buffer.control_word.M then
    67.             output_line(
    68.                         "locked in:"
    69.                       & group(Q.I)'Image
    70.                       & ".."
    71.                       & group(Q.M)'Image
    72.                       & " is "
    73.                       & there_are_locks_in_physical_addresses(Q)'Image
    74.                        );
    75.          end if;
    76.          output_line("order ICR:"  & the_buffer.order_count'Image);
    77.          output_line("    order: " & disassembly.the_full_name_of(the_buffer.decoded_order));
    78.          output_line("@ address: " & oct_of(the_buffer.order_address));
    79.       end if;
    80.    end loop;
    81. end IOC.diagnostics;

 81 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/file_interfacing.adb
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:10

     1. -- Provide an Ada.Text_IO interface to the file system of the real OS.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body file_interfacing is
    18.
    19.    procedure initialize (some_file : in out File_Type;
    20.                          mode      : in File_Mode;
    21.                          file_name : in String) is
    22.    begin
    23.       Open(some_file, mode, file_name);
    24.    exception
    25.       when others =>
    26.          if mode = Out_File then
    27.             Create(some_file, Out_File, file_name);
    28.          else
    29.             raise;
    30.          end if;
    31.    end initialize;
    32.
    33.    procedure finalize (some_file : in out File_Type;
    34.                        file_name : in String) is
    35.       pragma Unreferenced(file_name);
    36.    begin
    37.       Close(some_file);
    38.    end finalize;
    39.
    40. end file_interfacing;

Compiling: ../Source/file_interfacing.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:10

     1. -- Provide an Ada.Text_IO interface to the file system of the real OS.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18.
    19. use  Ada.Text_IO;
    20.
    21. package file_interfacing is
    22.
    23.    procedure initialize (some_file : in out File_Type;
    24.                          mode      : in File_Mode;
    25.                          file_name : in String);
    26.
    27.    procedure finalize (some_file : in out File_Type;
    28.                        file_name : in String);
    29.
    30. end file_interfacing;

 40 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/plotter.adb
Source file time stamp: 2021-02-17 20:27:15
Compiled at: 2021-02-21 15:54:10

     1. -- Emulation of the plotting commands of the Calcomp 564 graph plotter.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.slow.shift.GP;
    18. with postscript;
    19.
    20. use  IOC.slow.shift.GP;
    21. use  postscript;
    22.
    23. package body plotter is
    24.
    25.    -- The plotter made equal movements in the x and y directions, in steps of 0.005 inches.
    26.    -- Each command moves the plotting position by at most 1 step,
    27.    --   in either the positive or negative direction of each axis.
    28.
    29.    type step is
    30.       record
    31.          dx, dy : Integer range -1 .. +1;
    32.       end record;
    33.
    34.    null_step : constant plotter.step := (0, 0);
    35.
    36.    function "+" (p : postscript.point; s : plotter.step)
    37.    return postscript.point
    38.    is ((p.x + s.dx, p.y + s.dy));
    39.
    40.    function "-" (p, q : postscript.point)
    41.    return plotter.step
    42.    is ((p.x - q.x, p.y - q.y));
    43.
    44.    -- The plotter drew on a roll of paper 29.5 inches wide and 120 feet long.
    45.    -- 29.5" is   5900 steps at 200 steps per inch = 59 * 100
    46.    -- 120'  is 288000 steps  = 200 per inch * 12 inches per foot * 120 feet.
    47.    -- This sets the boundaries of the plot.
    48.    -- It was physically impossible to move to a point beyond these limits.
    49.
    50.    plot_limit : constant postscript.point := (120*12*200, 59*100);
    51.
    52.    -- A vector is represented by a series of consecutive colinear plotter movements.
    53.    -- For better efficiency, the steps of a vector are accumulated until there is
    54.    --    a change of direction, a pen lift, or the need to close the plotter file.
    55.    -- On these events, any vector thus defined is drawn via a single PostScript command.
    56.
    57.    the_origin      : constant postscript.point := (0, 0);
    58.
    59.    plot_position,
    60.    start_position  : postscript.point := the_origin;
    61.
    62.    -- last_step retains the direction of the previous plotter step.
    63.    last_step       : plotter.step := null_step;
    64.
    65.    the_pen_is_down : Boolean := False;
    66.
    67.    procedure ensure_the_validity_of (from  : in postscript.point;
    68.                                      step  : in plotter.step) is
    69.    begin
    70.      if from.x + step.dx < 0                     or else
    71.            from.y + step.dy < 0                  or else
    72.               from.x + step.dx > plot_limit.x    or else
    73.                  from.y + step.dy > plot_limit.y    then
    74.         notify_invalid_movement(from.x, from.y, step.dx, step.dy);
    75.      end if;
    76.    end ensure_the_validity_of;
    77.
    78.    procedure jump_to (p : in postscript.point)
    79.      with Inline;
    80.
    81.    procedure jump_to (p : in postscript.point) is
    82.    begin
    83.      -- Posit a new vector starting at p.
    84.      last_step := null_step;
    85.      plot_position := p;
    86.      start_position := p;
    87.    end;
    88.
    89.    procedure jump_by (this_step : in plotter.step)
    90.      with Inline;
    91.
    92.    procedure jump_by (this_step : in plotter.step) is
    93.    begin
    94.      ensure_the_validity_of(from => plot_position, step => this_step);
    95.      jump_to(plot_position + this_step);
    96.    end jump_by;
    97.
    98.    procedure close_any_open_vector (stream : in out host_IO.stream) is
    99.    begin
   100.      if the_pen_is_down                and then
   101.            start_position /= plot_position then
   102.         draw_a_PS_vector(stream, start_position, plot_position);
   103.         start_position := plot_position;
   104.      end if;
   105.    end close_any_open_vector;
   106.
   107.    procedure perform (action : in plotter.command; stream : in out host_IO.stream) is
   108.
   109.      procedure draw_to (p : in postscript.point)
   110.         with Inline;
   111.
   112.      procedure draw_to (p : in postscript.point) is
   113.      begin
   114.         if (plot_position - p) = last_step then
   115.            -- p is colinear with the previous step, so merely extend the vector to p.
   116.            plot_position := p;
   117.         else
   118.            -- Draw the whole vector and start a new one.
   119.            draw_a_PS_vector(stream, start_position, plot_position);
   120.            last_step := plot_position - p;
   121.            start_position := plot_position;
   122.            plot_position := p;
   123.         end if;
   124.      end draw_to;
   125.
   126.      procedure draw_by (this_step : in plotter.step)
   127.         with Inline;
   128.
   129.      procedure draw_by (this_step : in plotter.step) is
   130.      begin
   131.         ensure_the_validity_of(from => plot_position, step => this_step);
   132.         draw_to(plot_position + this_step);
   133.      end draw_by;
   134.
   135.      procedure move_by (this_step : in plotter.step)
   136.         with Inline;
   137.
   138.      procedure move_by (this_step : in plotter.step) is
   139.      begin
   140.         -- Convert from natural orientation of X axis to PostScript direction.
   141.         if the_pen_is_down then
   142.            draw_by((-this_step.dx, +this_step.dy));
   143.         else
   144.            jump_by((-this_step.dx, +this_step.dy));
   145.         end if;
   146.      end move_by;
   147.
   148.    begin -- perform
   149.      case action is
   150.         when dummy =>
   151.            null;
   152.         when pen_up =>
   153.            close_any_open_vector(stream);
   154.            the_pen_is_down := False;
   155.         when pen_down =>
   156.            the_pen_is_down := True;
   157.         when go_pY =>
   158.            move_by((+0, +1));
   159.         when go_nY =>
   160.            move_by((+0, -1));
   161.         when go_pX =>
   162.            move_by((+1, +0));
   163.         when go_nX =>
   164.            move_by((-1, +0));
   165.         when go_pXpY =>
   166.            move_by((+1, +1));
   167.         when go_nXnY =>
   168.            move_by((-1, -1));
   169.         when go_pXnY =>
   170.            move_by((+1, -1));
   171.         when go_nXpY =>
   172.            move_by((-1, +1));
   173.         when others =>
   174.            -- EM causes a 'peculiar' motion, according to the Manual, Appendix 5.2, p.303,
   175.            --    and other codes cause 'unpredictable' effects.
   176.            -- ee9 therefore performs an arbitrary, but safe, operation: moving to the origin.
   177.            close_any_open_vector(stream);
   178.            plot_position := the_origin;
   179.      end case;
   180.    end perform;
   181.
   182.    a_plot_is_open : Boolean := False;
   183.
   184.    procedure open_the_plot_file (stream : in out host_IO.stream) is
   185.    begin
   186.      if a_plot_is_open then
   187.         close_the_plot_file(stream);
   188.      end if;
   189.      plot_position := (0,0);
   190.      a_plot_is_open := True;
   191.    end open_the_plot_file;
   192.
   193.    procedure close_the_plot_file (stream : in out host_IO.stream) is
   194.    begin
   195.      if not a_plot_is_open then
   196.         return;
   197.      end if;
   198.      close_any_open_vector(stream);
   199.      a_plot_is_open := False;
   200.    end close_the_plot_file;
   201.
   202. end plotter;

Compiling: ../Source/plotter.ads
Source file time stamp: 2021-02-11 00:34:42
Compiled at: 2021-02-21 15:54:10

     1. -- Emulation of the plotting commands of the Calcomp 564 graph plotter.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with host_IO;
    18. with KDF9_char_sets;
    19.
    20. use  host_IO;
    21.
    22. package plotter is
    23.
    24.    procedure open_the_plot_file (stream : in out host_IO.stream);
    25.
    26.    procedure close_the_plot_file (stream : in out host_IO.stream);
    27.
    28.    type command is new KDF9_char_sets.symbol;
    29.
    30.    -- The KDF9 plotting commands are defined in the Manual, Appendix 6, 5.3, pp. 303-304.
    31.
    32.    -- BUT there is obviously an error in the Manual, as only 9 of the claimed 11 command
    33.    --    codes are listed, and the last, go_nXnY, is coded inconsistently with the others.
    34.
    35.    -- Hypothesis: the table should read as follows:
    36.
    37.    dummy    : constant plotter.command := 2#000_000#;
    38.
    39.    pen_up   : constant plotter.command := 2#100_000#;
    40.    pen_down : constant plotter.command := 2#010_000#;
    41.
    42.    go_pY    : constant plotter.command := 2#001_000#;
    43.    go_nY    : constant plotter.command := 2#000_100#;
    44.    go_pX    : constant plotter.command := 2#000_010#;
    45.    go_nX    : constant plotter.command := 2#000_001#;
    46.
    47.    go_nXnY  : constant plotter.command := go_nX + go_nY;
    48.    go_pXnY  : constant plotter.command := go_pX + go_nY;
    49.    go_nXpY  : constant plotter.command := go_nX + go_pY;
    50.    go_pXpY  : constant plotter.command := go_pX + go_pY;
    51.
    52.    -- These encodings are consistent with the Calcomp plotter command codes used here:
    53.    --     ub.fnwi.uva.nl/computermuseum//calcomp565.html
    54.    -- which defines a full set of 11 commands, two of which are missing from the KDF9 list.
    55.
    56.    is_valid : constant array (plotter.command) of Boolean
    57.             := (dummy    |
    58.                 pen_up   |
    59.                 pen_down |
    60.                 go_pY    |
    61.                 go_nY    |
    62.                 go_pX    |
    63.                 go_nX    |
    64.                 go_pXnY  |
    65.                 go_nXpY  |
    66.                 go_pXpY  |
    67.                 go_nXnY  => True,
    68.                 others   => False
    69.                );
    70.
    71.    procedure perform (action : in plotter.command; stream : in out host_IO.stream);
    72.
    73. end plotter;

 202 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-dr-tsd_outs.adb
Source file time stamp: 2021-02-20 23:51:07
Compiled at: 2021-02-21 15:54:10

     1. -- Implement the drum API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.dispatcher;
    18. with KDF9.TSD;
    19.
    20. use  IOC.dispatcher;
    21. use  KDF9.TSD;
    22.
    23. package body IOC.fast.DR.TSD_OUTs is
    24.
    25.    OUT13_was_done          : Boolean   := False;
    26.    last_reserved_DR_sector : KDF9.word := -1;
    27.
    28.    procedure free_any_reserved_drum_space is
    29.    begin
    30.       OUT13_was_done := False;
    31.       last_reserved_DR_sector := -1;
    32.    end free_any_reserved_drum_space;
    33.
    34.    Q : KDF9.Q_register;
    35.    W : KDF9.word;
    36.
    37.    procedure access_the_OUT_operand is
    38.    begin
    39.       ensure_that_the_NEST_holds_an_operand;
    40.       W := pop;
    41.       Q := as_Q(W);
    42.       the_trace_operand := W;
    43.     end access_the_OUT_operand;
    44.
    45.    procedure ensure_that_DR0_is_enabled (OUT_number : in KDF9.word) is
    46.    begin
    47.       if not DR0_is_enabled then
    48.          trap_failing_OUT(OUT_number, "there is no drum in this configuration");
    49.       end if;
    50.    end ensure_that_DR0_is_enabled;
    51.
    52.    procedure formulate_the_drum_transfer_operand (OUT_number : in KDF9.word) is
    53.       S : KDF9.word;
    54.    begin
    55.       ensure_that_DR0_is_enabled(OUT_number);
    56.       if not OUT13_was_done then
    57.          trap_failing_OUT(OUT_number, "obeyed before OUT 13");
    58.       end if;
    59.       S := KDF9.word(Q.C + (Q.M - Q.I + bytes_per_sector/2) / bytes_per_sector);
    60.       if S > last_reserved_DR_sector then
    61.          trap_failing_OUT(OUT_number, "too many drum sectors would be transferred");
    62.       end if;
    63.       Q := (Q.C*16 + DR0_number, Q.I, Q.M);
    64.       the_trace_operand := as_word(Q);
    65.    end formulate_the_drum_transfer_operand;
    66.
    67.    procedure do_OUT_11 is
    68.    begin
    69.       access_the_OUT_operand;
    70.       formulate_the_drum_transfer_operand(11);
    71.       restore_the_IO_OUT_operands(11, W);
    72.          POA(Q, False);
    73.       remove_the_IO_OUT_operands;
    74.    end do_OUT_11;
    75.
    76.    procedure do_OUT_12 is
    77.    begin
    78.       access_the_OUT_operand;
    79.       formulate_the_drum_transfer_operand(12);
    80.       restore_the_IO_OUT_operands(12, W);
    81.          PIA(Q, False);
    82.       remove_the_IO_OUT_operands;
    83.    end do_OUT_12;
    84.
    85.    procedure do_OUT_13 is
    86.    begin
    87.       access_the_OUT_operand;
    88.       ensure_that_DR0_is_enabled(13);
    89.       if OUT13_was_done then
    90.          trap_failing_OUT(13, "obeyed a second time");
    91.       end if;
    92.       if W > sectors_per_system or else
    93.             W = 0                  then
    94.          trap_failing_OUT(13, "demands an impossible number of drum sectors");
    95.       end if;
    96.       last_reserved_DR_sector := W - 1;
    97.       OUT13_was_done := True;
    98.       set_state_of(buffer(DR0_number), allocated => True);
    99.       log_API_message("OUT 13: allocated" & W'Image & " drum sectors");
   100.    end do_OUT_13;
   101.
   102.    procedure do_OUT_14 is
   103.    begin
   104.       -- I assume that the drum never experiences a parity error in ee9.
   105.       ensure_that_DR0_is_enabled(14);
   106.       if OUT13_was_done then
   107.          the_trace_operand := (sectors_per_system - last_reserved_DR_sector - 1) or 2**47;
   108.       else
   109.          the_trace_operand := sectors_per_system;
   110.       end if;
   111.       push(the_trace_operand);
   112.    end do_OUT_14;
   113.
   114. end IOC.fast.DR.TSD_OUTs;

Compiling: ../Source/ioc-fast-dr-tsd_outs.ads
Source file time stamp: 2021-02-13 13:53:24
Compiled at: 2021-02-21 15:54:10

     1. -- Implement the drum API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.DR.TSD_OUTs is
    18.
    19.    procedure do_OUT_11;
    20.
    21.    procedure do_OUT_12;
    22.
    23.    procedure do_OUT_13;
    24.
    25.    procedure do_OUT_14;
    26.
    27.    procedure free_any_reserved_drum_space;
    28.
    29. end IOC.fast.DR.TSD_OUTs;

 114 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-fd-tsd_outs.adb
Source file time stamp: 2021-02-20 23:51:07
Compiled at: 2021-02-21 15:54:10

     1. -- Implement the fixed disc API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.dispatcher;
    18. with KDF9.TSD;
    19.
    20. use  IOC.dispatcher;
    21. use  KDF9.TSD;
    22.
    23. package body IOC.fast.FD.TSD_OUTs is
    24.
    25.    -- See the Manual, Appendix 6, 2 for the TSD FD OUTs.
    26.
    27.    claimable_discs              : constant := 8;
    28.    sectors_per_logical_block    : constant := 16;
    29.    logical_blocks_per_seek_area : constant := sectors_per_seek_area / sectors_per_logical_block;
    30.    logical_blocks_per_platter   : constant := seek_areas_per_platter * logical_blocks_per_seek_area;
    31.    sectors_per_platter          : constant := sectors_per_logical_block * logical_blocks_per_platter;
    32.
    33.    type reserved_disc_set is
    34.       record
    35.          claimed : Boolean := False;
    36.          size    : KDF9.Q_part range 0 .. claimable_discs;
    37.          sectors : KDF9.Q_part range 0 .. claimable_discs * sectors_per_platter;
    38.          start   : KDF9.Q_part range 0 .. claimable_discs;
    39.       end record;
    40.
    41.    disc_set             : array (KDF9.Q_part range 1 .. 2) of reserved_disc_set;
    42.    disc_sets_claimed    : KDF9.Q_part range 0 .. 2 := 0;
    43.    current_disc_set     : KDF9.Q_part range 1 .. 2;
    44.    discs_claimed_so_far : KDF9.Q_part := 0;
    45.
    46.    procedure free_any_reserved_disc_space is
    47.    begin
    48.       disc_sets_claimed := 0;
    49.       discs_claimed_so_far := 0;
    50.    end free_any_reserved_disc_space;
    51.
    52.    function FD_seek_parameter (OUT_number: KDF9.word; Q : KDF9.Q_register)
    53.    return KDF9.Q_register is
    54.       current_set : reserved_disc_set renames disc_set(current_disc_set);
    55.       block       : constant KDF9.Q_part := Q.C / sectors_per_logical_block;
    56.       seek_area   : constant KDF9.Q_part := block  /  (6 * current_set.size);
    57.       residue     : constant KDF9.Q_part := block mod (6 * current_set.size);
    58.       disc        : constant KDF9.Q_part := residue / 6 + current_set.start;
    59.       drive       : constant KDF9.Q_part := 0;  -- ee9 will reserve discs on drive 0 only.
    60.       parameter   : constant KDF9.Q_part
    61.                   := drive * seek_areas_per_platter * main_discs_per_drive
    62.                    + disc  * seek_areas_per_platter
    63.                    + seek_area;
    64.    begin
    65.       if Q.C >= disc_set(current_disc_set).sectors then
    66.          trap_failing_OUT(OUT_number, Q.C'Image & " exceeds the sector capacity of the selected set");
    67.       end if;
    68.       return (parameter * 16 + FD0_number,  Q.I, Q.M);
    69.    end FD_seek_parameter;
    70.
    71.    function FD_xfer_parameter (Q : KDF9.Q_register)
    72.    return KDF9.Q_register is
    73.       sector : constant KDF9.Q_part := Q.C mod 96;
    74.    begin
    75.       return (sector * 16 + FD0_number, Q.I, Q.M);
    76.    end FD_xfer_parameter;
    77.
    78.    Q : KDF9.Q_register;
    79.    W : KDF9.word;
    80.
    81.    procedure ensure_that_FD0_is_enabled (OUT_number : in KDF9.word) is
    82.    begin
    83.       if not FD0_is_enabled then
    84.          trap_failing_OUT(OUT_number, "there is no disc in this configuration");
    85.       end if;
    86.    end ensure_that_FD0_is_enabled;
    87.
    88.    procedure access_the_operand is
    89.    begin
    90.       ensure_that_the_NEST_holds_an_operand;
    91.       W := pop;
    92.       Q := as_Q(W);
    93.       the_trace_operand := W;
    94.    end access_the_operand;
    95.
    96.    procedure do_OUT_41 is
    97.       F       : KDF9.Q_part;
    98.       seek_Q,
    99.       write_Q : KDF9.Q_register;
   100.    begin
   101.       access_the_operand;
   102.       ensure_that_FD0_is_enabled(41);
   103.       if disc_sets_claimed = 0 then
   104.          trap_failing_OUT(41, "tries to write to FD0 with no discs reserved");
   105.       end if;
   106.       W := KDF9.word(Q.C) / 16;
   107.       F := Q.C mod 16 + (Q.M - Q.I + words_per_sector - 1)/words_per_sector;
   108.       if F >= sectors_per_logical_block then
   109.          trap_failing_OUT(41, "tries to write past the end of a logical block on FD0");
   110.       end if;
   111.       seek_Q  := FD_seek_parameter(41, Q);
   112.       write_Q := FD_xfer_parameter(Q);
   113.       the_trace_operand := as_word(write_Q);
   114.       restore_the_IO_OUT_operands(42, W);
   115.          PMA(seek_Q, False);
   116.          POA(write_Q, False);
   117.       remove_the_IO_OUT_operands;
   118.    end do_OUT_41;
   119.
   120.    procedure do_OUT_42 is
   121.       F      : KDF9.Q_part;
   122.       seek_Q,
   123.       read_Q : KDF9.Q_register;
   124.    begin
   125.       access_the_operand;
   126.       ensure_that_FD0_is_enabled(42);
   127.       if disc_sets_claimed = 0 then
   128.          trap_failing_OUT(42, "tries to read from FD0 with no discs reserved");
   129.       end if;
   130.       W := KDF9.word(Q.C) / 16;
   131.       F := Q.C mod 16 + (Q.M - Q.I + words_per_sector - 1)/words_per_sector;
   132.       if F >= sectors_per_logical_block then
   133.          trap_failing_OUT(42, "tries to read past the end of a logical block on FD0");
   134.       end if;
   135.       seek_Q := FD_seek_parameter(41, Q);
   136.       read_Q := FD_xfer_parameter(Q);
   137.       the_trace_operand := as_word(read_Q);
   138.       restore_the_IO_OUT_operands(42, W);
   139.          PMA(seek_Q, False);
   140.          PIA(read_Q, False);
   141.       remove_the_IO_OUT_operands;
   142.    end do_OUT_42;
   143.
   144.    procedure do_OUT_43 is
   145.       F : KDF9.Q_part;
   146.    begin
   147.       access_the_operand;
   148.       ensure_that_FD0_is_enabled(43);
   149.       if disc_sets_claimed = 0 then
   150.          trap_failing_OUT(43, "no FD0 discs have been reserved yet");
   151.       end if;
   152.       if W not in 0 | -1 then
   153.          trap_failing_OUT(43, "tries to select an impossible set of discs");
   154.       end if;
   155.       F := as_Q(-W).M + 1;
   156.       if F > disc_sets_claimed then
   157.          trap_failing_OUT(43, "tries to select an unreserved FD0 disc set");
   158.       end if;
   159.       current_disc_set := as_Q(-the_trace_operand).M + 1;
   160.    end do_OUT_43;
   161.
   162.    procedure do_OUT_44 is
   163.       F : KDF9.Q_part;
   164.    begin
   165.       access_the_operand;
   166.       ensure_that_FD0_is_enabled(44);
   167.       if disc_sets_claimed = 2 then
   168.          trap_failing_OUT(44, "tries to reserve more than two sets of FD0 discs");
   169.       end if;
   170.       F := as_Q(W).M;
   171.       if W not in 1..claimable_discs                        or else
   172.             discs_claimed_so_far + F not in 1..claimable_discs then
   173.          trap_failing_OUT(44, "tries to reserve more than 8 FD0 discs");
   174.       end if;
   175.       current_disc_set := disc_sets_claimed + 1;
   176.       disc_set(current_disc_set).claimed := True;
   177.       disc_set(current_disc_set).size := F;
   178.       disc_set(current_disc_set).sectors := F * sectors_per_platter;
   179.       disc_set(current_disc_set).start := discs_claimed_so_far;
   180.       discs_claimed_so_far := discs_claimed_so_far + F;
   181.       disc_sets_claimed := disc_sets_claimed + 1;
   182.       log_API_message(
   183.                       "OUT 44: reserved"
   184.                     & F'Image
   185.                     & " FD0 disc"
   186.                     & plurality(KDF9.word(F))
   187.                     & " in set"
   188.                     & current_disc_set'Image
   189.                      );
   190.       set_state_of(buffer(FD0_number), allocated => True);
   191.    end do_OUT_44;
   192.
   193.    procedure do_OUT_45 is
   194.       F : KDF9.Q_part;
   195.    begin
   196.       access_the_operand;
   197.       ensure_that_FD0_is_enabled(45);
   198.       if disc_sets_claimed = 0 then
   199.          trap_failing_OUT(45, "tries to release an unreserved set of FD0 discs");
   200.       end if;
   201.       if W not in 0 | -1 then
   202.          trap_failing_OUT(45, "tries to release an unknown set of FD0 discs");
   203.       end if;
   204.       F := as_Q(-W).M + 1;
   205.       if F > disc_sets_claimed then
   206.          trap_failing_OUT(45, "tries to release more FD0 disc sets than are reserved");
   207.       end if;
   208.       log_API_message(
   209.                       "OUT 45: released"
   210.                     & disc_set(F).size'Image
   211.                     & " FD0 disc"
   212.                     & plurality(KDF9.word(disc_set(F).size))
   213.                     & " from set"
   214.                     & F'Image
   215.                      );
   216.       discs_claimed_so_far := discs_claimed_so_far - disc_set(F).size;
   217.       current_disc_set := 1;
   218.       disc_sets_claimed := disc_sets_claimed - 1;
   219.       if F = 1 then
   220.          disc_set(1) := disc_set(2);
   221.          disc_set(2).claimed := False;
   222.       end if;
   223.    end do_OUT_45;
   224.
   225.    procedure do_OUT_47 is
   226.    begin
   227.       the_trace_operand := pop;
   228.       -- I assume that disc transfer parity errors never occur under ee9.
   229.       ensure_that_FD0_is_enabled(47);
   230.       if disc_sets_claimed = 0 then
   231.          trap_failing_OUT(47, "tries to check a transfer on unreserved FD0 discs");
   232.       end if;
   233.    end do_OUT_47;
   234.
   235. end IOC.fast.FD.TSD_OUTs;

Compiling: ../Source/ioc-fast-fd-tsd_outs.ads
Source file time stamp: 2021-02-13 13:53:24
Compiled at: 2021-02-21 15:54:10

     1. -- Implement the fixed disc API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.FD.TSD_OUTs is
    18.
    19.    -- See the Manual, Appendix 6, 2 for the TSD FD OUTs.
    20.
    21.    procedure do_OUT_41;
    22.
    23.    procedure do_OUT_42;
    24.
    25.    procedure do_OUT_43;
    26.
    27.    procedure do_OUT_44;
    28.
    29.    procedure do_OUT_45;
    30.
    31.    procedure do_OUT_47;
    32.
    33.    procedure free_any_reserved_disc_space;
    34.
    35. end IOC.fast.FD.TSD_OUTs;

 235 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-tape-tsd_outs.adb
Source file time stamp: 2021-02-20 23:51:07
Compiled at: 2021-02-21 15:54:10

     1. -- Emulation of magnetic tape decks and buffers.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.fast.tape.TSD_OUTs is
    18.
    19.    type short_label is new String(1 .. 8);
    20.    type long_label  is new String(1 .. 16);
    21.
    22.    function needs_rewinding (b : KDF9.buffer_number)
    23.    return Boolean is
    24.       the_deck : tape.deck renames tape.deck(buffer(b).all);
    25.    begin
    26.       return the_deck.is_open and then the_deck.tape_file.position > 0;
    27.    end needs_rewinding;
    28.
    29.    procedure do_OUT_4 is
    30.       B : KDF9.Q_part;
    31.       S : KDF9.word;
    32.       W : KDF9.word;
    33.    begin
    34.       ensure_that_the_NEST_holds_an_operand;
    35.       W := pop;
    36.       declare
    37.          label : constant short_label := short_label(to_string(W));
    38.       begin
    39.          find_tape(tape.data_storage(label), B, S);
    40.          push(KDF9.word(B));
    41.          the_trace_operand := KDF9.word(B);
    42.          if W = 0 then
    43.             log_API_message("OUT 4: requested a ZERO tape  and got "
    44.                           & device_name_of(buffer(B).all)
    45.                           & " with TSN '"
    46.                           & to_string(S)
    47.                           & "'"
    48.                            );
    49.          else
    50.             log_API_message("OUT 4: requested  '" --a tape labelled '"
    51.                           & String(label)
    52.                           & "'  and got "
    53.                           & device_name_of(buffer(B).all)
    54.                           & " with TSN '"
    55.                           & to_string(S)
    56.                           & "'"
    57.                            );
    58.          end if;
    59.       end;
    60.       set_state_of(buffer(B), allocated => True);
    61.    end do_OUT_4;
    62.
    63.    procedure do_OUT_10 is
    64.       B : KDF9.Q_part;
    65.       P : KDF9.pair;
    66.       S : KDF9.word;
    67.    begin
    68.       ensure_that_the_NEST_holds_2_operands;
    69.       P := pop;
    70.       declare
    71.          label : constant long_label := long_label(to_string(P));
    72.       begin
    73.          find_tape(tape.data_storage(label), B, S);
    74.          push(S);
    75.          push(KDF9.word(B));
    76.          the_trace_operand := KDF9.word(B);
    77.          log_API_message("OUT 10: requested '" -- a tape labelled '"
    78.                        & String(label)
    79.                        & "' and got "
    80.                        & device_name_of(buffer(B).all)
    81.                        & " with TSN '"
    82.                        & to_string(S)
    83.                        & "'"
    84.                         );
    85.       end;
    86.       set_state_of(buffer(B), allocated => True);
    87.    end do_OUT_10;
    88.
    89. end IOC.fast.tape.TSD_OUTs;

Compiling: ../Source/ioc-fast-tape-tsd_outs.ads
Source file time stamp: 2021-02-15 17:45:04
Compiled at: 2021-02-21 15:54:10

     1. -- Implement the magnetic tape API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.tape.TSD_OUTs is
    18.
    19.    procedure do_OUT_4;
    20.
    21.    procedure do_OUT_10;
    22.
    23.    function needs_rewinding (b : KDF9.buffer_number)
    24.    return Boolean;
    25.
    26. end IOC.fast.tape.TSD_OUTs;

 89 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd-peripherals.adb
Source file time stamp: 2021-02-20 23:51:07
Compiled at: 2021-02-21 15:54:10

     1. -- Implement OUTs 5, 6 and 7 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC;
    18. with IOC.fast.tape.TSD_OUTs;
    19. with IOC.slow.shift.SI;
    20. with IOC.slow.shift.TR;
    21. with KDF9_char_sets;
    22. with KDF9.store;
    23.
    24. use  IOC;
    25. use  IOC.fast.tape.TSD_OUTs;
    26. use  IOC.slow.shift.SI;
    27. use  IOC.slow.shift.TR;
    28. use  KDF9_char_sets;
    29. use  KDF9.store;
    30.
    31. package body KDF9.TSD.peripherals is
    32.
    33.    -- is_free_for_explicit_allocation keeps a note of explicitly requested allocations by OUT 5.
    34.    -- Implicit allocations by OUT 8 are done to prevent spurious LIVs on the output devices,
    35.    --    but they must not cause explicit reservations by OUT 5 to fail.
    36.
    37.    is_free_for_explicit_allocation : array(KDF9.buffer_number) of Boolean := (others => True);
    38.    is_implicitly_allocated_to_OUT8 : array(KDF9.buffer_number) of Boolean := (others => False);
    39.
    40.    procedure free_all_devices is
    41.    begin
    42.       is_free_for_explicit_allocation := (others => True);
    43.       is_implicitly_allocated_to_OUT8 := (others => False);
    44.       for b in KDF9.buffer_number loop
    45.          set_state_of(buffer(b), allocated => False);
    46.       end loop;
    47.       --  Keep FW0 online.
    48.       set_state_of(buffer(0), allocated => True);
    49.    end free_all_devices;
    50.
    51.    procedure let_OUT_8_use_the_device_on_buffer (B : in KDF9.buffer_number) is
    52.    begin
    53.       is_implicitly_allocated_to_OUT8(B) := True;
    54.       set_state_of(buffer(B), allocated => True);
    55.    end let_OUT_8_use_the_device_on_buffer;
    56.
    57.    -- These are the device-type codes to be given when requesting
    58.    --    the allocation of a peripheral with TSD OUT 5,
    59.    --       according to the Manual and the document:
    60.    --          "Service Routine Library Manual" 22.13, p22-28-0.
    61.
    62.    FW_OUT5_code : constant := 0;
    63.    TP_OUT5_code : constant := 1;
    64.    TR_OUT5_code : constant := 2;
    65.    LP_OUT5_code : constant := 3;
    66.    CR_OUT5_code : constant := 4;
    67.    FP_OUT5_code : constant := 5;      -- Ferranti 5-channel Tape punch
    68.    CP_OUT5_code : constant := 7;
    69.    GP_OUT5_code : constant := 8#20#;
    70.    SI_OUT5_code : constant := 8#21#;  -- Standard Interface, "Data Link, N.P.L. Special Buffer"
    71.    FE_OUT5_code : constant := 8#65#;  -- Tape buffer link for PDP-8 on Eldon2, and perhaps COTAN
    72.    UT_OUT5_code : constant := 8#67#;  -- Unlabelled Tape
    73.
    74.    procedure select_the_next_device_from_among
    75.       (device_A, device_B : in  KDF9.buffer_number;
    76.        chosen_device      : out KDF9.buffer_number;
    77.        wanted_type        : in String) is
    78.    begin
    79.       if device_A /= 0                            and then
    80.             is_free_for_explicit_allocation(device_A) then
    81.          chosen_device := device_A;
    82.       elsif device_B /= 0                         and then
    83.             is_free_for_explicit_allocation(device_B) then
    84.          chosen_device := device_B;
    85.       else
    86.          trap_failing_OUT(5, "there is no available device of type " & wanted_type);
    87.       end if;
    88.    end select_the_next_device_from_among;
    89.
    90.    procedure allocate_a_device is
    91.       B : KDF9.buffer_number;
    92.       W : KDF9.word;
    93.    begin
    94.       ensure_that_the_NEST_holds_an_operand;
    95.       W := read_top;
    96.
    97.       case W is
    98.          -- 8 was added to the code to pre-allocate a device.
    99.          -- I treat pre-allocating and allocating the same way here.
   100.          when FW_OUT5_code
   101.             | FW_OUT5_code+8 =>
   102.             B := 0;  -- Always allowed, no checking performed.
   103.          when TP_OUT5_code
   104.             | TP_OUT5_code+8
   105.             | FP_OUT5_code
   106.             | FP_OUT5_code+8 =>
   107.             select_the_next_device_from_among(TP0_number, TP1_number, B, "TP");
   108.          when TR_OUT5_code
   109.             | TR_OUT5_code+8 =>
   110.             -- TR0 is used for reading the bootstrap/problem program in KDF9 code.
   111.             -- When there is Latin-1 data it therefore needs to go in via TR1.
   112.             -- N.B. the TR devices must appear in this order.
   113.             select_the_next_device_from_among(TR1_number, TR0_number, B, "TR");
   114.             set_case(IOC.slow.shift.TR.device(buffer(B).all));
   115.          when LP_OUT5_code
   116.             | LP_OUT5_code+8 =>
   117.             select_the_next_device_from_among(LP0_number, LP1_number, B, "LP");
   118.          when CR_OUT5_code
   119.             | CR_OUT5_code+8 =>
   120.             select_the_next_device_from_among(CR0_number, CR1_number, B, "CR");
   121.          when CP_OUT5_code
   122.             | CP_OUT5_code+8 =>
   123.             select_the_next_device_from_among(CP0_number, CP1_number, B, "CP");
   124.          when GP_OUT5_code
   125.             | GP_OUT5_code+8 =>
   126.             -- There is only 1 graph plotter.
   127.             select_the_next_device_from_among(GP0_number, GP0_number, B, "GP");
   128.          when SI_OUT5_code =>
   129.             if SI0_is_enabled then
   130.                select_the_next_device_from_among(SI0_number, SI1_number, B, "SI");
   131.             else
   132.                trap_failing_OUT(5, "the SI buffer has not been enabled");
   133.             end if;
   134.          when FE_OUT5_code =>
   135.             trap_unimplemented_feature("PDP-8 Front End Tape buffers");
   136.          when UT_OUT5_code =>
   137.             trap_unimplemented_feature("Unlabelled Tape buffers");
   138.          when others =>
   139.             trap_failing_OUT(5, "unknown device type #" & oct_of(W));
   140.       end case;
   141.
   142.       is_free_for_explicit_allocation(B) := False;
   143.       set_state_of(buffer(B), allocated => True);
   144.
   145.       pop;
   146.       push(KDF9.word(B));
   147.       the_trace_operand := KDF9.word(B);
   148.
   149.       if buffer(B).all in IOC.slow.shift.device'Class and then
   150.             buffer(B).kind /= GP_kind                     then
   151.          log_API_message("OUT 5: requested a #"
   152.                        & oct_of(KDF9.Q_part(W), 2)
   153.                        & " device and got "
   154.                        & device_name_of(buffer(B).all)
   155.                        & (
   156.                           if IOC.slow.shift.device(buffer(B).all).uses_Latin_1 then
   157.                              " in Latin-1 mode"
   158.                           else
   159.                              " in KDF9 mode"
   160.                          )
   161.                         );
   162.       else
   163.          log_API_message("OUT 5: requested a #"
   164.                        & oct_of(KDF9.Q_part(W), 2)
   165.                        & " device and got "
   166.                        & device_name_of(buffer(B).all)
   167.                         );
   168.       end if;
   169.    end allocate_a_device;
   170.
   171.    procedure free_the_device_on_buffer (B : in KDF9.buffer_number; OUT_number : in KDF9.word) is
   172.    begin
   173.       if buffer(B).kind in MT_kind | ST_kind then
   174.          if needs_rewinding(b) then
   175.             PMD(buffer(B).all, KDF9.Q_register'(B, 0, 0), set_offline => (OUT_number = 6));
   176.          end if;
   177.       elsif OUT_number = 7 then
   178.          trap_failing_OUT(7, "device #" & oct_of(B, 2) & ", is not a tape deck");
   179.       end if;
   180.       is_free_for_explicit_allocation(B) := True;
   181.       set_state_of(buffer(B), allocated => is_implicitly_allocated_to_OUT8(B));
   182.       log_API_message("OUT" & OUT_number'Image & ": released " & device_name_of(buffer(B).all));
   183.    end free_the_device_on_buffer;
   184.
   185.    procedure deallocate_a_device (OUT_number : in KDF9.word) is
   186.       B : KDF9.Q_part;
   187.    begin
   188.       ensure_that_the_NEST_holds_an_operand;
   189.       the_trace_operand := pop;
   190.       if the_trace_operand > 15 then
   191.          notify_state_display_of_final_ICR;
   192.          trap_failing_OUT(OUT_number, "#" & oct_of(the_trace_operand) & " is not a valid buffer number");
   193.       end if;
   194.       B := KDF9.buffer_number(the_trace_operand);
   195.       if is_unallocated(buffer(B)) then
   196.          trap_failing_OUT(OUT_number, "device #" & oct_of(B, 2) & " is not allocated to this program");
   197.       end if;
   198.       free_the_device_on_buffer(B, OUT_number);
   199.    end deallocate_a_device;
   200.
   201.    procedure do_OUT_5 is
   202.    begin
   203.       allocate_a_device;
   204.    end do_OUT_5;
   205.
   206.    procedure do_OUT_6 is
   207.    begin
   208.       deallocate_a_device(OUT_number => 6);
   209.    end do_OUT_6;
   210.
   211.    procedure do_OUT_7 is
   212.    begin
   213.       deallocate_a_device(OUT_number => 7);
   214.    end do_OUT_7;
   215.
   216.
   217. end KDF9.TSD.peripherals;

Compiling: ../Source/kdf9-tsd-peripherals.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:10

     1. -- Implement 5, 6 and 7 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.peripherals is
    18.
    19.    procedure do_OUT_5;
    20.
    21.    procedure do_OUT_6;
    22.
    23.    procedure do_OUT_7;
    24.
    25.    procedure let_OUT_8_use_the_device_on_buffer (B : in KDF9.buffer_number);
    26.
    27.    procedure free_all_devices;
    28.
    29.    procedure free_the_device_on_buffer (B : in KDF9.buffer_number; OUT_number : in KDF9.word);
    30.
    31. end KDF9.TSD.peripherals;

 217 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd-spooling.adb
Source file time stamp: 2021-02-20 23:51:07
Compiled at: 2021-02-21 15:54:11

     1. -- Implement a subset of the Time Sharing Director's OUT 8 / OUT 16 spooling API.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC;
    18. with IOC.dispatcher;
    19. with IOC.slow.shift.FW;
    20. with KDF9_char_sets;
    21. with KDF9.store;
    22. with KDF9.TSD.peripherals;
    23.
    24. use  IOC;
    25. use  IOC.dispatcher;
    26. use  IOC.slow.shift.FW;
    27. use  KDF9_char_sets;
    28. use  KDF9.store;
    29. use  KDF9.TSD.peripherals;
    30.
    31. package body KDF9.TSD.spooling is
    32.
    33.    procedure do_IO (this_OUT : in KDF9.word) is
    34.
    35.       function destination_device_for (the_stream : KDF9.word)
    36.       return IOC.device_number is
    37.          data_word  : constant String(1..16) := oct_of(the_stream);
    38.          the_device : IOC.device_number;
    39.          the_type   : String(1..2);
    40.       begin
    41.          case the_stream is
    42.             when 8#00# =>
    43.                return 0;
    44.             when 8#10# |8#12# |8#14# | 8#16# =>
    45.                the_device := TP0_number; the_type := "TP";
    46.             when 8#11# |8#13# |8#15# | 8#17# =>
    47.                the_device := TP1_number; the_type := "TP";
    48.             when 8#30#..8#37# =>
    49.                the_device := LP0_number; the_type := "LP";
    50.             when 8#50#..8#57# =>
    51.                the_device := TP1_number; the_type := "TP";
    52.             when 8#70#..8#77# =>
    53.                the_device := LP0_number; the_type := "LP";
    54.             when others =>
    55.                trap_failing_OUT(8, "invalid stream #" & data_word);
    56.          end case;
    57.          if the_device = 0 then
    58.             trap_operator_error("OUT 8 needs a " & the_type & " for stream #" & data_word(15..16));
    59.          end if;
    60.          return the_device;
    61.       end destination_device_for;
    62.
    63.       W, the_stream : KDF9.word;
    64.       Q, G    : KDF9.Q_register;
    65.
    66.       procedure prepare_output_to_FW0 is
    67.          message_prefix  : constant KDF9.word := 8#02_06_21_55_22_00_07_77#; -- LS CS [ m ] SP CN 
    68.          prompt_prefix   : constant KDF9.word := 8#02_06_21_61_22_00_07_77#; -- LS CS [ q ] SP CN 
    69.          OUT_16_prefix   : constant KDF9.word := 8#02_07_56_33_00_77_77_77#; -- LS CN N  SP    
    70.          filler_in_D0_D5 : constant KDF9.word := 8#77_00_00_00_00_00_00_00#; -- 
    71.          S               : KDF9_char_sets.symbol := KDF9_char_sets.Word_Filler;
    72.          the_prefix      : KDF9.word;
    73.       begin  -- prepare_output_to_FW0
    74.          -- The logic of FW streams is rather complex, to preserve the layout of the typescript.
    75.          -- There are three significant aspects.
    76.
    77.          -- 1. The message is truncated if longer than 8 words.
    78.          if Q.M - Q.I > 8 then
    79.             Q.M := Q.I + 8;
    80.          end if;
    81.
    82.          -- 2. It must not contain LS or HT;
    83.          --       nor ';' in the last word;
    84.          --          nor ';' other than in character position 7;
    85.          --    but anything after an End Message can safely be ignored.
    86.          word_loop: for w in Q.I+1 .. Q.M loop
    87.              for c in KDF9_char_sets.symbol_index'Range loop
    88.                 S := fetch_symbol(w, c);
    89.                 if S = KDF9_char_sets.Line_Shift                                 or else
    90.                       S = KDF9_char_sets.Tabulation                              or else
    91.                          ((S = KDF9_char_sets.Semi_Colon) and (c /= 7 or  w = Q.M)) then
    92.                    trap_failing_OUT(this_OUT, "invalid data for OUT 8 to FW");
    93.                 end if;
    94.          exit word_loop when S = KDF9_char_sets.Semi_Colon or S = KDF9_char_sets.End_Message;
    95.              end loop;
    96.          end loop word_loop;
    97.
    98.          the_prefix := (if S = KDF9_char_sets.Semi_Colon then prompt_prefix else message_prefix);
    99.          the_prefix := (if this_OUT = 16                 then OUT_16_prefix else the_prefix);
   100.
   101.          -- 3. Take a new line for each OUT 8 message to the FW.
   102.          --    Set up the format effector(s) in the first word of the OUT 8 area.
   103.          declare
   104.             package FW renames IOC.slow.shift.FW;
   105.             the_FW : FW.device renames FW.device(buffer(0).all);
   106.          begin
   107.             if a_LF_was_just_read(the_FW) then
   108.                -- Replace the redundant Line Shift with a Word Filler character.
   109.                store_word(the_prefix or filler_in_D0_D5, Q.I);
   110.             else
   111.                -- The initial Line Shift is needed.
   112.                store_word(the_prefix, Q.I);
   113.             end if;
   114.          end;
   115.       end prepare_output_to_FW0;
   116.
   117.       page_change : constant := 8#77_77_77_77_77_77_77_03#;  --  LP Page Change character
   118.
   119.    begin  -- do_IO
   120.       ensure_that_the_NEST_holds_an_operand;
   121.       W := pop;
   122.       Q := as_Q(W);
   123.       the_trace_operand := W;
   124.
   125.       -- A FW query has (only) D0 of the control word set.
   126.       if (Q.C and 8#1_00000#) /= 0 then
   127.          Q.C := 0;
   128.       end if;
   129.
   130.       if Q.C = Q.I and Q.I = Q.M then
   131.          -- The N2 parameter specifies stream closure.
   132.          flush(buffer(destination_device_for(KDF9.word(Q.C))).all);
   133.          return;
   134.       end if;
   135.
   136.       --
   137.       -- This must precede anything that might LOV, e.g. store accesses and I/O orders.
   138.       --
   139.       restore_the_IO_OUT_operands(this_OUT, W);
   140.       --
   141.       --
   142.       --
   143.
   144.       -- The (Q, from N2) parameter specifies a block starting with the stream number.
   145.       check_address_and_lockout(Q.I);
   146.       the_stream := fetch_word(Q.I);
   147.
   148.       Q.C := destination_device_for(the_stream);
   149.       let_OUT_8_use_the_device_on_buffer(Q.C);
   150.
   151.       check_address_and_lockout(Q.I+1);
   152.       G := as_Q(fetch_word(Q.I+1));
   153.
   154.       -- See the Manual, 12.6.1.
   155.       if G.C = 4095 and then G.I = 8#177777# then
   156.          -- The G parameter specifies output of a 'gap' suitable for the device.
   157.          if G.M = 0 then
   158.             -- Do nothing.
   159.             the_trace_operand := as_word(G);
   160.          elsif destination_device_for(the_stream) in TP0_number | TP1_number then
   161.             -- Write runout according to the character set mode of the punch.
   162.             G.M := (if G.M in 1 .. 511 then G.M else 120);
   163.             Q := (Q.C, 0, G.M);
   164.             the_trace_operand := as_word(Q);
   165.             POE(Q, False);
   166.          elsif destination_device_for(the_stream) = LP0_number then
   167.              -- Write a Page Change.
   168.             store_word(page_change, Q.I);
   169.             Q := (Q.C, Q.I, Q.I);
   170.             the_trace_operand := as_word(Q);
   171.             POA(Q, False);
   172.          end if;
   173.
   174.          --
   175.          --
   176.          remove_the_IO_OUT_operands;
   177.          --
   178.          --
   179.
   180.          return;
   181.       end if;
   182.
   183.       if Q.M <= Q.I then
   184.          trap_failing_OUT(8, "invalid end-address #" & oct_of(Q.M));
   185.       end if;
   186.
   187.       if Q.C = 0 then
   188.          -- The logic for FW streams is more complex, to preserve the layout of the typescript.
   189.          prepare_output_to_FW0;
   190.       else
   191.          -- For non-FW streams, the first word of the OUT 8 area is not transferred.
   192.          Q.I := Q.I + 1;
   193.       end if;
   194.       the_trace_operand := as_word(Q);
   195.
   196.       POB(Q, False);
   197.
   198.       --
   199.       --
   200.       remove_the_IO_OUT_operands;
   201.       --
   202.       --
   203.
   204.    end do_IO;
   205.
   206.    procedure do_OUT_8 is
   207.    begin
   208.       do_IO(this_OUT => 8);
   209.    end do_OUT_8;
   210.
   211.    procedure do_OUT_16 is
   212.    begin
   213.       do_IO(this_OUT => 16);
   214.    end do_OUT_16;
   215.
   216. end KDF9.TSD.spooling;

Compiling: ../Source/kdf9-tsd-spooling.ads
Source file time stamp: 2021-02-11 00:34:41
Compiled at: 2021-02-21 15:54:11

     1. -- Implement a subset of the Time Sharing Director's OUT 8 / OUT 16 spooling API.
     2. --
     3. -- This file is part of ee9 (6.1a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.spooling is
    18.
    19.    procedure do_OUT_8;
    20.
    21.    procedure do_OUT_16;
    22.
    23. end KDF9.TSD.spooling;

 216 lines: No errors
