Version V6p0a of ee9 for Linux, built on Mon 08 Feb 2021 05:20:56 PM PST.
mk9 'ee9' build: optimised and with full language checks, using configuration options:

pragma Unsuppress(All_Checks);
pragma Optimize_Alignment(Time);
pragma Assertion_Policy(Ignore);
pragma Check_Policy(Debug, Off);
pragma Validity_Checks(Off);
pragma Restrictions(Max_Asynchronous_Select_Nesting => 0);
pragma Restrictions(Max_Tasks => 0);
pragma Restrictions(No_Abort_Statements);
pragma Restrictions(No_Implementation_Attributes);
pragma Restrictions(No_Obsolescent_Features);

Using the build command:
gnatmake -aI../Source -aO../Build -funwind-tables -gnatl12j96 -gnatw.e -gnatwD -gnatwH -gnatwP -gnatwT -gnatw.W -gnatw.B -gnatwC -gnatw.u -gnatyO -gnatw.Y -gnatw.N -fdata-sections -ffunction-sections -gnatf -mtune=native -O3 -flto -j1 ee9 -bargs -static -largs -Wl,--gc-sections -Wl,--as-needed -flto

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ee9.adb
Source file time stamp: 2021-02-08 00:21:38
Compiled at: 2021-02-08 17:20:56

     1. -- This is the "main program" for the entire emulator.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with GNAT.Source_Info;
    18. --
    19. with Ada.Text_IO;
    20. with Ada.Command_Line;
    21. with Ada.Exceptions;
    22. --
    23. with exceptions;
    24. with HCI;
    25. with IOC.equipment;
    26. with IOC.slow.shift.TP;
    27. with IOC.slow.shift.TR;
    28. with settings;
    29.
    30. with execute;
    31. with say_goodbye;
    32.
    33. use  Ada.Text_IO;
    34. use  Ada.Exceptions;
    35. --
    36. use  exceptions;
    37. use  HCI;
    38. use  settings;
    39.
    40. procedure ee9 is
    41.
    42.    package CLI renames Ada.Command_Line;
    43.
    44.    the_log_file_name : constant String := "KDF9_log.txt";
    45.
    46.    a_command_line_error_is_detected : exception;
    47.
    48.    procedure show_proper_usage (message : in String := "") is
    49.    begin
    50.       if message /= "" then
    51.          log_line(message);
    52.       end if;
    53.       log_line(
    54.                "usage: ee9 { [ -s{b|p|t} ] | [ -d{f|p|t|x|-} ] | [ -m"
    55.              & miscellany_prompt
    56.              & " ] [ -TP{k|l}{k|l} ] [ -TR{k|l}{k|l} ] } +program_file_name"
    57.               );
    58.       CLI.Set_Exit_Status(CLI.Failure);
    59.       raise a_command_line_error_is_detected;
    60.    end show_proper_usage;
    61.
    62.    procedure complain (about : in String; because : in String := "") is
    63.    begin
    64.       show_proper_usage(
    65.                         "Parameter " & about & " is not valid"
    66.                       & (if because = "" then "." else " because " & because & ".")
    67.                        );
    68.    end complain;
    69.
    70.    the_program_name_position : Natural := 0;
    71.
    72.    procedure check_all_flag_settings is
    73.
    74.       procedure check_flag_setting (i : in Positive) is
    75.
    76.          subtype tape_code_flags is Character
    77.             with Predicate => tape_code_flags in 'K' | 'L' | 'k' | 'l';
    78.
    79.          subtype tape_device_flags is Character
    80.             with Predicate => tape_device_flags in 'P' | 'R' |'p' | 'r';
    81.
    82.          argument : constant String   := CLI.Argument(i);
    83.          index    : constant Positive := argument'First;
    84.
    85.       begin
    86.          -- Ignore an empty parameter.
    87.          if argument'Length = 0 then
    88.             return;
    89.          end if;
    90.
    91.          -- Take note of a program name parameter.
    92.          if argument(index) = '+' then
    93.             if the_program_name_position /= 0 then
    94.                complain(about   => argument,
    95.                         because => "more than one program has been specified");
    96.             end if;
    97.             if argument'Length < 3 then
    98.                complain(about   => argument,
    99.                         because => "it is too short for a program file name");
   100.             end if;
   101.             the_program_name_position := i;
   102.             return;
   103.          end if;
   104.
   105.          -- Fail any non-flag parameter.
   106.          if argument(index) /= '-'  then
   107.             complain(about => "'" & argument & "'");
   108.          end if;
   109.
   110.          -- Fail a too-short flag parameter.
   111.          if argument'Length < 2 then
   112.             complain(about   => argument,
   113.                      because => "it is too short");
   114.          end if;
   115.
   116.          -- Check for a miscellany parameter.
   117.          if argument'Length in 2 .. miscellany_flags'Length+2 and then
   118.                argument(index..index+1) = "-m"                    then
   119.             for i in index+2 .. argument'Last loop
   120.                if is_invalid_miscellany_flag(argument(i)) then
   121.                   complain(about => """" & argument & """ at """ & argument(i) & """");
   122.                end if;
   123.             end loop;
   124.             return;
   125.          end if;
   126.
   127.          -- Check for a state or diagnostic parameter.
   128.          if argument in "-sb" | "-sp" | "-st" | "-df" | "-dt" | "-dp" | "-dx" | "-d-" then
   129.             return;
   130.          end if;
   131.
   132.          -- Check for a Tape Punch/Reader parameter.
   133.          if argument'Length in 4 .. 5                    and then
   134.                argument(index+1) in 'T' | 't'            and then
   135.                   argument(index+2) in tape_device_flags and then
   136.                      argument(index+3) in tape_code_flags    then
   137.             if argument'Length = 4                  or else
   138.                   argument(index+4) in tape_code_flags then
   139.                return;
   140.             end if;
   141.          end if;
   142.
   143.          complain(about => argument);
   144.
   145.       end check_flag_setting;
   146.
   147.    begin -- check_all_flag_settings
   148.       if CLI.Argument_Count = 0 then
   149.          return;
   150.       end if;
   151.       for i in 1..CLI.Argument_Count loop
   152.          check_flag_setting(i);
   153.       end loop;
   154.    end check_all_flag_settings;
   155.
   156.    procedure impose_all_flag_settings is
   157.
   158.       procedure impose_flag_setting (i : in Positive) is
   159.
   160.          subtype Latin_1_code_flags is Character
   161.             with Predicate => Latin_1_code_flags in 'L' | 'l';
   162.
   163.          subtype punch_device_flags is Character
   164.             with Predicate => punch_device_flags in 'P' |'p';
   165.
   166.          argument : constant String   := CLI.Argument(i);
   167.          index    : constant Positive := argument'First;
   168.
   169.       begin -- impose_flag_setting
   170.          -- Ignore an empty parameter.
   171.          if argument'Length = 0 then
   172.             return;
   173.          end if;
   174.
   175.          -- Ignore a program_file_name parameter.
   176.          if argument(index) = '+'  then
   177.             return;
   178.          end if;
   179.
   180.          -- Impose a miscellany parameter.
   181.          if argument'Length in 2 .. miscellany_flags'Length+2 and then
   182.                argument(index..index+1) = "-m"  then
   183.             for i in index+2 .. argument'Last loop
   184.                set_this_miscellany_flag(argument(i));
   185.             end loop;
   186.             return;
   187.          end if;
   188.
   189.          -- Impose  a Tape Punch/Reader parameter.
   190.          if argument'Length in 4 .. 5 then
   191.             -- Set the code for the first device.
   192.             if argument(index+2) in punch_device_flags then
   193.                IOC.slow.shift.TP.set_unit_code(0, argument(index+3) in Latin_1_code_flags);
   194.             else
   195.                IOC.slow.shift.TR.set_unit_code(0, argument(index+3) in Latin_1_code_flags);
   196.             end if;
   197.          end if;
   198.          if argument'Length = 5 then
   199.             -- Set the code for the second device.
   200.             if argument(index+2) in punch_device_flags then
   201.                IOC.slow.shift.TP.set_unit_code(1, argument(index+4) in Latin_1_code_flags);
   202.             else
   203.                IOC.slow.shift.TR.set_unit_code(1, argument(index+4) in Latin_1_code_flags);
   204.             end if;
   205.          end if;
   206.
   207.          -- Impose a state or diagnostic parameter; argument is known to be 3 characters long.
   208.          if    argument = "-sb" then
   209.             set_execution_mode(boot_mode);
   210.          elsif argument = "-sp" then
   211.             set_execution_mode(program_mode);
   212.          elsif argument = "-st" then
   213.             set_execution_mode(test_program_mode);
   214.          elsif argument = "-d-" then
   215.             set_diagnostic_mode(fast_mode);
   216.          elsif argument = "-df" then
   217.             set_diagnostic_mode(fast_mode);
   218.          elsif argument = "-dt" then
   219.             set_diagnostic_mode(trace_mode);
   220.          elsif argument = "-dp" then
   221.             set_diagnostic_mode(pause_mode);
   222.          elsif argument = "-dx" then
   223.             set_diagnostic_mode(external_mode);
   224.          end if;
   225.       end impose_flag_setting;
   226.
   227.    begin -- impose_all_flag_settings
   228.       if CLI.Argument_Count = 0 then
   229.          return;
   230.       end if;
   231.       for i in 1..CLI.Argument_Count loop
   232.          impose_flag_setting(i);
   233.       end loop;
   234.    end impose_all_flag_settings;
   235.
   236.    function plain (f : String)
   237.    return String
   238.    is (f(f'First+1 .. f'Last));
   239.
   240.    function the_program_name
   241.    return String
   242.    is (plain(CLI.Argument(the_program_name_position)));
   243.
   244.    procedure tidy_up (reason : in String) is
   245.    begin
   246.       Put_Line(Standard_Error, reason & ".");
   247.       close(the_log_file_name);
   248.       CLI.Set_Exit_Status(CLI.Failure);
   249.    end tidy_up;
   250.
   251. begin -- ee9
   252.
   253.    check_all_flag_settings;
   254.    open(the_log_file_name);
   255.
   256.    if the_program_name_position /= 0 then
   257.       get_settings_from_file("1");
   258.       IOC.equipment.configure;
   259.       impose_all_flag_settings;
   260.       IOC.equipment.re_configure;
   261.       if the_log_is_wanted then
   262.          log_line(
   263.                   "This is ee9 6.0a, compiled by "
   264.                 & Standard'Compiler_Version
   265.                 & " on "
   266.                 & GNAT.Source_Info.Compilation_ISO_Date
   267.                 & "."
   268.                  );
   269.       end if;
   270.       display_execution_modes(the_program_name);
   271.       execute(the_program_name);
   272.    else
   273.       log_line("Cannot run ee9; no program file parameter was supplied.");
   274.    end if;
   275.
   276.    close(the_log_file_name);
   277.
   278. exception
   279.
   280.    when a_command_line_error_is_detected =>
   281.       tidy_up("Invalid command line");
   282.
   283.    when diagnostic : operator_error =>
   284.       say_goodbye("The KDF9 operator has made a mistake", Exception_Message(diagnostic));
   285.
   286.    when error : others =>
   287.       tidy_up("Failure in ee9; unexpected exception: " & Exception_Information(error));
   288.
   289. end ee9;

 289 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/exceptions.ads
Source file time stamp: 2021-01-21 01:45:40
Compiled at: 2021-02-08 17:20:56

     1. -- Declare the exceptions used in emulation-mode control.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package exceptions is
    18.
    19.    -- program_exit is raised when a KDF9 program terminates normally.
    20.    program_exit : exception;
    21.
    22.   -- OUT_2_restart is raised when a KDF9 program terminates by means of OUT 2.
    23.    OUT_2_restart : exception;
    24.
    25.    -- time_expired is raised when a KDF9 program executes too many instructions.
    26.    time_expired : exception;
    27.
    28.    -- quit_request is raised when the user requests a quit at a break-in.
    29.    quit_request : exception;
    30.
    31.    -- input_is_impossible is raised when an attempt is made to read from the terminal in
    32.    --    noninteractive mode.  This prevents absent-user scripted usage from hanging.
    33.    input_is_impossible : exception;
    34.
    35.    -- operator_error is raised when the operating context is invalid; e.g. labelled tape not mounted.
    36.    operator_error : exception;
    37.
    38.    -- OUT_error is raised when an impossible OUT action is requested in problem program state.
    39.    OUT_error : exception;
    40.
    41.    -- IO_error is raised when an impossible I/O operation is attempted in problem program state.
    42.    IO_error : exception;
    43.
    44.    -- Director_IO_error when an impossible I/O operation is attempted in Director state.
    45.    Director_IO_error : exception;
    46.
    47.    -- Director_failure is raised for an instruction that would LIV in problem program state.
    48.    Director_failure : exception;
    49.
    50.    -- invalid_paper_tape_file is raised when given invalid data for a KDF9-code paper tape file.
    51.    invalid_paper_tape_file : exception;
    52.
    53.    -- not_yet_implemented is raised by an incomplete emulation.
    54.    not_yet_implemented : exception;
    55.
    56.    -- emulation_failure is raised when an emulator self-check fails.
    57.    emulation_failure : exception;
    58.
    59.    -- debugging_stop is raised when a debugging run needs to halt at once.
    60.    debugging_stop : exception;
    61.
    62. end exceptions;

 62 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/execute.adb
Source file time stamp: 2021-01-23 01:03:25
Compiled at: 2021-02-08 17:20:56

     1. -- This is the emulation-mode coordinate module.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with GNAT.Ctrl_C;
    18. --
    19. with Ada.Command_Line;
    20. with Ada.Exceptions;
    21. --
    22. with break_in;
    23. with dumping;
    24. with exceptions;
    25. with HCI;
    26. with IOC.slow.shift.TR;
    27. with KDF9;
    28. with KDF9.microcode;
    29. with settings;
    30. with state_display;
    31.
    32. with say_goodbye;
    33.
    34. use  Ada.Command_Line;
    35. use  Ada.Exceptions;
    36.
    37. --
    38. use  dumping;
    39. use  exceptions;
    40. use  HCI;
    41. use  IOC.slow.shift.TR;
    42. use  KDF9;
    43. use  KDF9.microcode;
    44. use  settings;
    45. use  state_display;
    46.
    47. procedure execute (program_name : in String) is
    48.
    49.    procedure check_times_and_modes
    50.       with Inline;
    51.
    52.    pause_count : KDF9.order_counter := 0;
    53.
    54.    procedure check_times_and_modes is
    55.    begin
    56.       if ICR > pause_count then
    57.          if ICR >= time_limit then
    58.             raise time_expired;
    59.          end if;
    60.          pause_count := pause_count + time_slice;
    61.          change_diagnostic_mode_if_requested;
    62.       end if;
    63.    end check_times_and_modes;
    64.
    65. begin  -- execute
    66.    GNAT.Ctrl_C.Install_Handler(break_in.note_user_interrupt'Access);
    67.
    68.    if the_external_trace_is_enabled then
    69.       log_an_external_trace_header;
    70.    end if;
    71.
    72.    case the_execution_mode is
    73.       when boot_mode =>
    74.          reset_the_internal_registers(Director_state);
    75.          boot_the_KDF9(program_name);
    76.       when test_program_mode=>
    77.          reset_the_internal_registers(Director_state);
    78.          load_a_program(program_name);
    79.       when program_mode =>
    80.          reset_the_internal_registers(program_state);
    81.          load_a_program(program_name);
    82.    end case;
    83.
    84.    if not loading_was_successful then
    85.       say_goodbye("Could not load the specified program.");
    86.       return;
    87.    end if;
    88.
    89.    poke_all_amendments;
    90.    show_all_prerun_dump_areas;
    91.
    92.    if do_not_execute then
    93.       log_new_line;
    94.       log_line("Run abandoned as requested.");
    95.       return;
    96.    end if;
    97.
    98.    reset_the_CPU_state;
    99.
   100. execution_loop:
   101.    loop
   102.
   103.       begin
   104.
   105.          check_times_and_modes;
   106.          if the_diagnostic_mode /= fast_mode then
   107.             -- Do a single, traced instruction, breaking-in conditionally.
   108.             do_a_traced_instruction_cycle;
   109.          else
   110.             -- Fast mode is designed for minimal overhead;
   111.             --    it interacts with the user only at the end of a time slice.
   112.             loop
   113.                do_a_fast_time_slice;
   114.                check_times_and_modes;
   115.             end loop;
   116.          end if;
   117.
   118.       exception  -- handler for execution_loop
   119.
   120.          when debugging_stop =>
   121.             null;
   122.
   123.          when mode_change_request =>
   124.             quit_if_requested;
   125.
   126.          when abandon_this_order =>
   127.             null;  -- Just get on with it after an interrupt or nullified order.
   128.
   129.          when LOV_trap =>
   130.             IOC.handle_a_main_store_lockout;
   131.
   132.          when program_exit =>
   133.             say_goodbye("", status => Success);
   134.             exit execution_loop;
   135.
   136.          when quit_request =>
   137.             say_goodbye("Run stopped by the user", status => Success);
   138.             exit execution_loop;
   139.
   140.          when time_expired =>
   141.             say_goodbye("Infinite loop? Run failed by exceeding the time limit");
   142.             exit execution_loop;
   143.
   144.          when diagnostic : NOUV_trap =>
   145.             say_goodbye("NOUV interrupt", Exception_Message(diagnostic));
   146.             exit execution_loop;
   147.
   148.          when input_is_impossible =>
   149.             say_goodbye("Noninteractive mode cannot handle a prompt");
   150.             exit execution_loop;
   151.
   152.          when diagnostic : not_yet_implemented =>
   153.             say_goodbye("Not yet implemented", Exception_Message(diagnostic));
   154.             exit execution_loop;
   155.
   156.          when diagnostic : RESET_trap =>
   157.             say_goodbye("RESET interrupt", Exception_Message(diagnostic));
   158.             exit execution_loop;
   159.
   160.          when diagnostic : LIV_trap =>
   161.             say_goodbye( "LIV interrupt", Exception_Message(diagnostic));
   162.             exit execution_loop;
   163.
   164.          when diagnostic : Director_failure =>
   165.             say_goodbye("Invalid operation in Director", Exception_Message(diagnostic));
   166.             exit execution_loop;
   167.
   168.          when diagnostic : OUT_error =>
   169.             say_goodbye("Failure in OUT", Exception_Message(diagnostic));
   170.             exit execution_loop;
   171.
   172.          when diagnostic : IO_error =>
   173.             say_goodbye("Impossible I/O operation", Exception_Message(diagnostic));
   174.             exit execution_loop;
   175.
   176.          when diagnostic : Director_IO_error =>
   177.             say_goodbye("Impossible I/O operation in Director", Exception_Message(diagnostic));
   178.             exit execution_loop;
   179.
   180.          when diagnostic : operator_error =>
   181.             say_goodbye("The KDF9 operator has made a mistake", Exception_Message(diagnostic));
   182.             exit execution_loop;
   183.
   184.       end;
   185.
   186.    end loop execution_loop;
   187.
   188. exception  -- handler for execute
   189.
   190.    when diagnostic : invalid_paper_tape_file =>
   191.       say_goodbye("Invalid paper tape file supplied", Exception_Message(diagnostic));
   192.
   193.    when diagnostic : operator_error =>
   194.       say_goodbye("The KDF9 operator must have made a mistake", Exception_Message(diagnostic));
   195.
   196.    when diagnostic : others =>
   197.       say_goodbye("Apologies for this dismal failure", Exception_Message(diagnostic));
   198.
   199. end execute;

 199 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/hci.adb
Source file time stamp: 2021-01-10 23:52:35
Compiled at: 2021-02-08 17:20:56

     1. -- Provide operations supporting replicated human-readable output:
     2. --    1: to an interactive user interface for transient display, and
     3. --    2: to a file for persistent storage.
     4. -- If no file has been opened, or if it has been explicitly closed,
     5. --    output is to the interactive interface only.
     6. --
     7. -- Also provide operations allowing synchronization with the user.
     8. --
     9. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
    10. -- Copyright (C) 2021, W. Findlay; all rights reserved.
    11. --
    12. -- The ee9 program is free software; you can redistribute it and/or
    13. -- modify it under terms of the GNU General Public License as published
    14. -- by the Free Software Foundation; either version 3, or (at your option)
    15. -- any later version. This program is distributed in the hope that it
    16. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    17. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    18. -- See the GNU General Public License for more details. You should have
    19. -- received a copy of the GNU General Public License distributed with
    20. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    21. --
    22.
    23. with formatting;
    24. with generic_logger;
    25. with settings;
    26.
    27. use  formatting;
    28. use  settings;
    29.
    30. package body HCI is
    31.
    32.    package log_manager is new generic_logger(max_logger_list_size => 2);
    33.
    34.    cc_list : log_manager.replicator;
    35.
    36.    procedure tab_log (at_least : in Natural;
    37.                       spacing  : in Positive := 6;
    38.                       iff      : in Boolean := True) is
    39.    begin
    40.       cc_list.tab_log(at_least, spacing, iff);
    41.    end tab_log;
    42.
    43.    procedure tab_log_to (column : in Positive;
    44.                          iff    : in Boolean := True) is
    45.    begin
    46.       cc_list.tab_log_to(column, iff);
    47.    end tab_log_to;
    48.
    49.    procedure log (char : in Character;
    50.                   iff  : in Boolean := True) is
    51.    begin
    52.       cc_list.log(char, iff);
    53.    end log;
    54.
    55.    procedure log (text : in String;
    56.                   iff  : in Boolean := True) is
    57.    begin
    58.       cc_list.log(text, iff);
    59.    end log;
    60.
    61.    procedure log_line (text : in String;
    62.                        iff  : in Boolean := True) is
    63.    begin
    64.       if text /= "" then
    65.          cc_list.log(text, iff);
    66.       end if;
    67.       log_new_line(iff);
    68.    end log_line;
    69.
    70.    procedure log_padded_string (text  : in String;
    71.                                 width : in Positive := 1) is
    72.       pad_width   : constant Natural := Integer'Max (0, width - text'Length);
    73.       padding     : constant String (1 .. pad_width) := (others => ' ');
    74.       padded_text : constant String := padding & text;
    75.    begin
    76.       cc_list.log(padded_text);
    77.    end log_padded_string;
    78.
    79.    procedure log_octal (number : in KDF9.field_of_16_bits;
    80.                         width  : in Positive := 1) is
    81.    begin
    82.       log_padded_string("#" & oct_of(number), width);
    83.    end log_octal;
    84.
    85.    procedure log_octal (number : in KDF9.word;
    86.                         width  : in Positive := 1) is
    87.    begin
    88.       log_padded_string("#" & oct_of(number), width);
    89.    end log_octal;
    90.
    91.    procedure log_new_line (iff : in Boolean := True) is
    92.    begin
    93.       cc_list.log_new_line(iff);
    94.    end log_new_line;
    95.
    96.    half_ruler : constant String (1 .. 40) := (others => '_');
    97.    half_blank : constant String (1 .. 40) := (others => ' ');
    98.    full_ruler : constant String (1 .. 80) := half_ruler & half_ruler;
    99.
   100.    procedure log_rule (start_a_new_line : in Boolean := False;
   101.                        iff              : in Boolean := True) is
   102.    begin
   103.       if start_a_new_line then
   104.          cc_list.log_new_line(iff);
   105.       end if;
   106.       log_line(full_ruler, iff);
   107.    end log_rule;
   108.
   109.    procedure log_rule_half (second_half : in Boolean := False) is
   110.    begin
   111.       if second_half then
   112.          log(half_blank);
   113.       end if;
   114.       log_line(half_ruler);
   115.    end log_rule_half;
   116.
   117.    procedure log_message (message : in String) is
   118.    begin
   119.       cc_list.log(message);
   120.       cc_list.log_new_line;
   121.    end log_message;
   122.
   123.    procedure log_title (message : in String) is
   124.    begin
   125.       cc_list.log_new_line;
   126.       cc_list.log(message);
   127.       cc_list.log_new_line;
   128.    end log_title;
   129.
   130.    procedure log_ee9_status (message  : in String;
   131.                              skip     : in Natural := 0;
   132.                              complete : in Boolean := True;
   133.                              iff      : in Boolean := True) is
   134.    begin
   135.       if not iff then return; end if;
   136.       panel_logger.tab_log_to(1);
   137.       for i in 1 .. skip loop
   138.          log_new_line;
   139.       end loop;
   140.       if complete then
   141.          log_line("ee9: " & message & ".");
   142.       else
   143.          log("ee9: " & message);
   144.       end if;
   145.    end log_ee9_status;
   146.
   147.    procedure log_API_message (message  : in String;
   148.                               skip     : in Natural := 1) is
   149.    begin
   150.       if API_logging_is_wanted then
   151.          log_ee9_status(message, skip, True);
   152.       end if;
   153.    end log_API_message;
   154.
   155.    procedure hoot (message : in String := "") is
   156.    begin
   157.       panel_logger.log(message & Character'Val (7));  -- Append a BEL to the message.
   158.    end hoot;
   159.
   160.    procedure show (message : in String) is
   161.    begin
   162.       if debugging_is_enabled then
   163.          panel_logger.show(message);
   164.          flush;
   165.       end if;
   166.    end show;
   167.
   168.    procedure show_line (message : in String) is
   169.    begin
   170.       if debugging_is_enabled then
   171.          panel_logger.show_line(message);
   172.          flush;
   173.       end if;
   174.    end show_line;
   175.
   176.    procedure interact (reason : in String := "Mode") is
   177.    begin
   178.       panel_logger.interact(reason);
   179.    end interact;
   180.
   181.    procedure open (logfile_name : in String) is
   182.    begin
   183.       cc_list.open(logfile_name);
   184.    end open;
   185.
   186.    procedure close (logfile_name : in String) is
   187.    begin
   188.       cc_list.close(logfile_name);
   189.    end close;
   190.
   191.    procedure flush (iff : in Boolean := True) is
   192.    begin
   193.       cc_list.flush(iff);
   194.    end flush;
   195.
   196.    procedure log_to_file (message : in String) is
   197.    begin
   198.       file_logger.log(message);
   199.       file_logger.log_new_line;
   200.    end log_to_file;
   201.
   202. begin
   203.    cc_list.set_logger_list((file_logger'Access, panel_logger'Access));
   204. end HCI;

Compiling: ../Source/hci.ads
Source file time stamp: 2021-01-10 23:52:35
Compiled at: 2021-02-08 17:20:56

     1. -- Provide operations supporting replicated human-readable output:
     2. --    1: to an interactive user interface for transient display, and
     3. --    2: to a file for persistent storage.
     4. -- If no file has been opened, or if it has been explicitly closed,
     5. --    output is to the interactive interface only.
     6. --
     7. -- Also provide operations allowing synchronization with the user.
     8. --
     9. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
    10. -- Copyright (C) 2021, W. Findlay; all rights reserved.
    11. --
    12. -- The ee9 program is free software; you can redistribute it and/or
    13. -- modify it under terms of the GNU General Public License as published
    14. -- by the Free Software Foundation; either version 3, or (at your option)
    15. -- any later version. This program is distributed in the hope that it
    16. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    17. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    18. -- See the GNU General Public License for more details. You should have
    19. -- received a copy of the GNU General Public License distributed with
    20. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    21. --
    22.
    23. with KDF9;
    24. with logging.file;
    25. with logging.panel;
    26.
    27. use  KDF9;
    28. use  logging.file;
    29. use  logging.panel;
    30.
    31. package HCI is
    32.
    33.    file_logger  : aliased logging.file.output;
    34.    panel_logger : aliased logging.panel.display;
    35.
    36.    procedure tab_log (at_least : in Natural;
    37.                       spacing  : in Positive := 6;
    38.                       iff      : in Boolean := True);
    39.
    40.    procedure tab_log_to (column : in Positive;
    41.                          iff    : in Boolean := True);
    42.
    43.    procedure log (char : in Character;
    44.                   iff  : in Boolean := True);
    45.
    46.    procedure log (text : in String;
    47.                   iff  : in Boolean := True);
    48.
    49.    procedure log_line (text : in String;
    50.                        iff  : in Boolean := True);
    51.
    52.    -- Log in octal with initial '#'.
    53.    procedure log_octal (number : in KDF9.word;
    54.                         width  : in Positive := 1);
    55.
    56.    procedure log_octal (number : in KDF9.field_of_16_bits;
    57.                         width  : in Positive := 1);
    58.
    59.    procedure log_new_line (iff : in Boolean := True);
    60.
    61.    procedure log_rule (start_a_new_line : in Boolean := False;
    62.                        iff              : in Boolean := True);
    63.
    64.    procedure log_rule_half (second_half : in Boolean := False);
    65.
    66.    procedure log_message (message : in String);
    67.
    68.    procedure log_title (message : in String);
    69.
    70.    procedure log_ee9_status (message  : in String;
    71.                              skip     : in Natural := 0;
    72.                              complete : in Boolean := True;
    73.                              iff      : in Boolean := True);
    74.
    75.    procedure log_API_message (message  : in String;
    76.                               skip     : in Natural := 1);
    77.
    78.    procedure hoot (message : in String := "");
    79.
    80.    procedure show (message : in String);
    81.
    82.    procedure show_line (message : in String);
    83.
    84.    procedure interact (reason : in String := "Mode");
    85.
    86.    procedure open  (logfile_name : in String);
    87.
    88.    procedure close (logfile_name : in String);
    89.
    90.    procedure flush (iff : in Boolean := True);
    91.
    92.    procedure log_to_file (message : in String);
    93.
    94. end HCI;

 204 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc.adb
Source file time stamp: 2021-02-08 01:13:09
Compiled at: 2021-02-08 17:20:56

     1. -- Emulation of the common functionality of a KDF9 IOC "buffer" (DMA channel),
     2. --    with fail-stop stubs for operations having device-specific behaviour.
     3. --
     4. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with Ada.Exceptions;
    19. --
    20. with exceptions;
    21. with IOC.slow;
    22. with KDF9.CPU;
    23. with KDF9.PHU_store;
    24. with tracing;
    25.
    26. with IOC.the_locker_of;
    27.
    28. use  exceptions;
    29. use  KDF9.CPU;
    30. use  KDF9.PHU_store;
    31. use  tracing;
    32.
    33. package body IOC is
    34.
    35.    procedure set_state_of (the_buffer : in device_class_access;
    36.                            allocated  : in Boolean) is
    37.    begin
    38.       if the_buffer = null then
    39.          raise emulation_failure with "trying to set state of null buffer to " & allocated'Image;
    40.       end if;
    41.       if the_buffer.is_allocated = allocated then
    42.          -- Allocating an already allocated device, or deallocating an unallocated device.
    43.          -- Both are benign, so ignore.
    44.          return;
    45.       else
    46.          the_buffer.is_allocated := allocated;
    47.          the_CPDAR(the_buffer.number) := allocated;
    48.       end if;
    49.     end set_state_of;
    50.
    51.    function is_allocated (the_buffer : device_class_access)
    52.    return Boolean
    53.    is (the_buffer.is_allocated);
    54.
    55.    function is_unallocated (the_buffer : device_class_access)
    56.    return Boolean
    57.    is (not the_buffer.is_allocated);
    58.
    59.    function device_name_of (the_buffer : IOC.device)
    60.    return IOC.device_name
    61.    is (IOC.device_kind'Image(the_buffer.kind)(1 .. 2)
    62.      & trimmed(the_buffer.unit'Image));
    63.
    64.    function device_name_of (the_number : IOC.device_number)
    65.    return IOC.device_name
    66.    is (device_name_of(buffer(the_number).all));
    67.
    68.    function device_kind_of (the_number : IOC.device_number)
    69.    return IOC.device_kind
    70.    is (buffer(the_number).kind);
    71.
    72.    overriding
    73.    procedure Initialize (the_buffer : in out IOC.device) is
    74.    begin
    75.       if not IOC.device'Class(the_buffer).is_open then
    76.          the_buffer.is_abnormal := True;
    77.          the_buffer.is_offline  := True;
    78.       end if;
    79.       install(the_buffer);
    80.    end Initialize;
    81.
    82.    procedure open (the_buffer : in out IOC.device'Class;
    83.                    the_mode   : in POSIX.access_mode) is
    84.    begin
    85.       the_buffer.device_name := device_name_of(the_buffer);
    86.       host_IO.open(the_buffer.stream, the_buffer.device_name, the_mode);
    87.       if the_buffer.is_open then
    88.          if the_mode = write_mode then
    89.             truncate(the_buffer.stream, to_length => 0);
    90.          end if;
    91.       else
    92.          trap_operator_error(the_buffer.device_name & " cannot be found");
    93.       end if;
    94.       IOC.device(the_buffer).Initialize;
    95.    end open;
    96.
    97.    overriding
    98.    procedure Finalize (the_buffer : in out IOC.device) is
    99.       buffer : constant String  := oct_of(KDF9.Q_part(the_buffer.number), 2);
   100.    begin
   101.       if IOC.device'Class(the_buffer).is_open   and then
   102.             IOC.device'Class(the_buffer).usage /= 0 then
   103.          IOC.device'Class(the_buffer).close;
   104.       end if;
   105.    exception
   106.       when error : others =>
   107.          raise emulation_failure
   108.             with "Finalizing buffer #" & buffer & ": " & Ada.Exceptions.Exception_Information(error);
   109.    end Finalize;
   110.
   111.    function is_open (the_buffer : IOC.device)
   112.    return Boolean
   113.    is (the_buffer.stream.is_open);
   114.
   115.    function usage (the_buffer : IOC.device)
   116.    return KDF9.word is
   117.    begin
   118.       return the_buffer.stream.bytes_moved;
   119.    end usage;
   120.
   121.    procedure flush (the_buffer : in out IOC.device) is
   122.    begin
   123.       flush(the_buffer.stream);
   124.    end flush;
   125.
   126.    procedure close (the_buffer : in out IOC.device) is
   127.    begin
   128.       close(the_buffer.stream);
   129.       IOC.buffer(the_buffer.number) := null;
   130.    end close;
   131.
   132.    procedure finalize_all_KDF9_buffers is
   133.    begin
   134.       for b in IOC.buffer'Range loop
   135.          if IOC.buffer(b) /= null then
   136.             Finalize(IOC.buffer(b).all);
   137.          end if;
   138.       end loop;
   139.    end finalize_all_KDF9_buffers;
   140.
   141.    procedure add_in_the_IO_lockout_CPU_time (Q_operand : in KDF9.Q_register) is
   142.       IO_size : constant KDF9.Q_part := Q_operand.M - Q_operand.I;
   143.    begin
   144.       the_CPU_delta := the_CPU_delta + KDF9.us(IO_size + group_size - 1) / group_size;
   145.    end add_in_the_IO_lockout_CPU_time;
   146.
   147.    function IO_elapsed_time (the_buffer   : IOC.device;
   148.                              atomic_items : KDF9.word)
   149.    return KDF9.us
   150.    is (
   151.        if IOC.device'Class(the_buffer).is_open then
   152.           KDF9.us(atomic_items) * the_buffer.quantum
   153.        else
   154.           0
   155.       );
   156.
   157.    procedure add_in_the_IO_CPU_time (IO_CPU_time : in KDF9.us) is
   158.    begin
   159.       the_CPU_delta := the_CPU_delta + IO_CPU_time;
   160.    end add_in_the_IO_CPU_time;
   161.
   162.    procedure add_in_the_IO_CPU_time (the_buffer  : in IOC.device'Class;
   163.                                      bytes_moved : in KDF9.word) is
   164.       the_IO_CPU_time : KDF9.us;
   165.    begin
   166.       if the_buffer.is_open then
   167.          if the_buffer in IOC.slow.device'Class then
   168.             the_IO_CPU_time := KDF9.us(bytes_moved) * 6;          -- 6µs/char
   169.          else
   170.             the_IO_CPU_time := KDF9.us(bytes_moved + 7) / 8 * 6;  -- 6µs/word
   171.          end if;
   172.       else
   173.          the_IO_CPU_time := 0;
   174.       end if;
   175.       add_in_the_IO_CPU_time(the_IO_CPU_time);
   176.    end add_in_the_IO_CPU_time;
   177.
   178.    function IO_elapsed_time_total (the_buffer : IOC.device)
   179.    return KDF9.us
   180.    is (IO_elapsed_time(IOC.device'Class(the_buffer), IOC.device'Class(the_buffer).usage));
   181.
   182.    procedure install (the_device : in out IOC.device'Class) is
   183.    begin
   184.       if buffer(the_device.number) /= null then
   185.          if buffer(the_device.number).kind /= AD_kind                      and then
   186.                buffer(the_device.number).device_name /= the_device.device_name then
   187.             raise emulation_failure
   188.                with "attempt to install a second device, namely "
   189.                   & the_device.device_name
   190.                   & ", on buffer #"
   191.                   & oct_of(the_device.number)
   192.                   & " which already has "
   193.                   & buffer(the_device.number).device_name;
   194.          end if;
   195.       end if;
   196.       buffer(the_device.number) := the_device'Unchecked_Access;
   197.    end install;
   198.
   199.    -- Mask off the buffer number in the Q_operand.C; to remove any disc parameter.
   200.    function canonical (Q_operand : KDF9.Q_register)
   201.    return KDF9.Q_register
   202.    is (C => Q_operand.C and buffer_number_mask, I => Q_operand.I, M => Q_operand.M);
   203.
   204.    procedure validate_device (the_buffer : in IOC.device'Class;
   205.                               Q_operand  : in KDF9.Q_register) is
   206.       Q : constant KDF9.Q_register := canonical(Q_operand);
   207.    begin
   208.       if not the_buffer.is_open then
   209.          trap_operator_error("buffer #" & oct_of(the_buffer.number, 2) & " is not configured");
   210.       end if;
   211.       if KDF9.Q_part(the_buffer.number) /= Q.C then
   212.          raise emulation_failure
   213.             with "wrong C-part: "
   214.                & oct_of(Q_operand.C)
   215.                & " for "
   216.                & the_buffer.device_name
   217.                & " on buffer #"
   218.                & oct_of(KDF9.Q_part(the_buffer.number), 2);
   219.       end if;
   220.       if not the_CPDAR(the_buffer.number) and the_CPU_state /= Director_state then
   221.          trap_illegal_instruction("unallocated I/O device " & the_buffer.device_name);
   222.       end if;
   223.    end validate_device;
   224.
   225.    procedure validate_bounds (Q_operand  : in KDF9.Q_register) is
   226.    begin
   227.       if Q_operand.I > Q_operand.M then
   228.          trap_illegal_instruction("invalid I/O Q operand: I > M");
   229.       end if;
   230.       validate_address_range(Q_operand.I, Q_operand.M);
   231.    end validate_bounds;
   232.
   233.    procedure validate_transfer (the_buffer : in IOC.device'Class;
   234.                                 Q_operand  : in KDF9.Q_register) is
   235.    begin
   236.       validate_device(the_buffer, Q_operand);
   237.       validate_bounds(Q_operand);
   238.    end validate_transfer;
   239.
   240.    procedure validate_parity (the_buffer : in IOC.device'Class) is
   241.    begin
   242.       if the_buffer.is_abnormal then
   243.          trap_illegal_instruction("the buffer for "
   244.                                 & the_buffer.device_name
   245.                                 & " is abnormal (parity error or end-of-data)");
   246.       end if;
   247.    end validate_parity;
   248.
   249.    procedure require_positive_count (count : in KDF9.Q_part) is
   250.    begin
   251.       if resign(count) <= 0 then
   252.          trap_illegal_instruction("nonpositive I/O repetition count");
   253.       end if;
   254.    end require_positive_count;
   255.
   256.    procedure require_nonnegative_count (count : in KDF9.Q_part) is
   257.    begin
   258.       if resign(count) < 0 then
   259.          trap_illegal_instruction("negative I/O repetition count");
   260.       end if;
   261.    end require_nonnegative_count;
   262.
   263.    function image (the_buffer : in IOC.device'Class)
   264.    return String
   265.    is (
   266.        the_buffer.device_name
   267.      & " Q"  & the_buffer.control_word.C'Image
   268.      & "/#"  & oct_of(the_buffer.control_word.I)
   269.      & "/#"  & oct_of(the_buffer.control_word.M)
   270.       );
   271.
   272.    -- In boot mode, effect the LOV interrupt to Director.
   273.    -- In other modes, advance the elapsed time to the next-interrupt time,
   274.    --    and suppress the LOV by simulating an earlier end of transfer.
   275.    procedure handle_a_buffer_lockout (the_buffer : in IOC.device'Class) is
   276.    begin
   277.       PHU(CPL) := (
   278.                    is_held_up => True,
   279.                    blockage   => (buffer_busy, the_buffer.number, by_INTQq => False)
   280.                   );
   281.       take_note_of_buffer_lockout(the_buffer.device_name, the_buffer.operation);
   282.       if the_execution_mode = boot_mode then
   283.          LOV_if_user_mode(the_buffer.device_name & " is busy");
   284.       else
   285.          advance_the_clock(the_buffer.completion_time);
   286.          act_on_pending_interrupts;
   287.       end if;
   288.    end handle_a_buffer_lockout;
   289.
   290.    procedure deal_with_a_busy_device (the_buffer  : in out IOC.device'Class;
   291.                                       order_time  : in KDF9.us;
   292.                                       set_offline : in Boolean) is
   293.    begin
   294.       advance_the_clock(the_clock_time+order_time);
   295.       if the_buffer.is_busy then
   296.          handle_a_buffer_lockout(the_buffer);
   297.       end if;
   298.       the_buffer.is_offline := set_offline;
   299.    end deal_with_a_busy_device;
   300.
   301.    procedure finalize_transfer (the_buffer : in out IOC.device'Class;
   302.                                 need_EDT,
   303.                                 need_PR    : out Boolean);
   304.
   305.    procedure effect_device_interrupt (code : KDF9.interrupt_number; the_buffer : in IOC.device'Class) is
   306.    begin
   307.       effect(code, the_buffer.image);
   308.     end effect_device_interrupt;
   309.
   310.    function is_DMAing (the_buffer : in IOC.device'Class)
   311.    return Boolean
   312.    is (the_buffer.operation in input_operation | output_operation);
   313.
   314.    procedure start_data_transfer (the_buffer   : in out IOC.device'Class;
   315.                                   Q_operand    : in KDF9.Q_register;
   316.                                   set_offline  : in Boolean;
   317.                                   busy_time    : in KDF9.us;
   318.                                   operation    : in IOC.transfer_kind := some_other_operation) is
   319.       pragma Unreferenced(set_offline);
   320.       transferring_data : constant Boolean := operation in input_operation | output_operation;
   321.       time_now          : constant KDF9.us := the_clock_time;
   322.       real_Q            : KDF9.Q_register := Q_operand;
   323.       EDT_needed,
   324.       PR_needed         : Boolean;
   325.    begin
   326.       -- Check the IO parameters and the buffer state, and handle any lockout set by another device.
   327.       validate_device(the_buffer, Q_operand);
   328.
   329.       if transferring_data then
   330.          validate_bounds(real_Q);
   331.          real_Q := (real_Q.C, real_Q.I+BA, real_Q.M+BA);
   332.       else
   333.          require_nonnegative_count(real_Q.M);
   334.       end if;
   335.
   336.       validate_parity(the_buffer);
   337.
   338.       if the_buffer.is_busy then
   339.          handle_a_buffer_lockout(the_buffer);
   340.          if the_execution_mode = boot_mode then
   341.             finalize_transfer (the_buffer, EDT_needed, PR_needed);
   342.             if the_next_interrupt_time > time_now + 1_024_000 then
   343.                the_next_interrupt_time := time_now + 1_024_000;
   344.             end if;
   345.             if EDT_needed then
   346.                effect_device_interrupt(EDT_interrupt, the_buffer);
   347.             elsif PR_needed then
   348.                effect_device_interrupt(PR_interrupt, the_buffer);
   349.             end if;
   350.          end if;
   351.       end if;
   352.
   353.       if transferring_data                            and then
   354.             there_are_locks_in_physical_addresses(real_Q) then
   355.          LOV_if_user_mode(
   356.                           "in "
   357.                        &  "#"   & oct_of(the_buffer.control_word.I)
   358.                        &  "/#"  & oct_of(the_buffer.control_word.M)
   359.                        &  " for "
   360.                        &  the_buffer.device_name
   361.                          );
   362.       end if;
   363.
   364.       -- Set up the transfer parameters.
   365.       the_buffer.is_for_Director := (the_CPU_state = Director_state);
   366.       the_buffer.priority_level  := CPL;
   367.       the_buffer.control_word    := real_Q;
   368.       the_buffer.operation       := operation;
   369.       the_buffer.order_count     := ICR+1;
   370.       the_buffer.order_address   := CIA;
   371.       the_buffer.decoded_order   := INS;
   372.       the_buffer.initiation_time := time_now;
   373.       the_buffer.transfer_time   := busy_time;
   374.       the_buffer.completion_time := the_buffer.initiation_time + busy_time;
   375.
   376.       if busy_time > 0 or transferring_data then
   377.          if the_buffer.completion_time < the_next_interrupt_time then
   378.             the_next_interrupt_time := the_buffer.completion_time;
   379.          end if;
   380.          the_buffer.is_busy := True;
   381.          take_note_of_IO_start(
   382.                                the_buffer.device_name,
   383.                                the_buffer.completion_time,
   384.                                the_buffer.control_word,
   385.                                the_buffer.operation
   386.                               );
   387.       else
   388.          the_buffer.is_busy := False;
   389.          take_note_of_IO_finis (
   390.                                 the_buffer.order_count,
   391.                                 the_buffer.order_address,
   392.                                 the_buffer.decoded_order,
   393.                                 the_buffer.initiation_time,
   394.                                 the_buffer.device_name,
   395.                                 the_buffer.is_for_Director,
   396.                                 the_buffer.priority_level,
   397.                                 the_buffer.completion_time,
   398.                                 the_buffer.control_word,
   399.                                 the_buffer.operation
   400.                                );
   401.       end if;
   402.       PHU(CPL) := idle_PHU;
   403.    end start_data_transfer;
   404.
   405.    -- start_slow_transfer takes a pessimistic view of transfers-to-End_Message.
   406.    -- When the actual transfer length is known, the end-of-transfer time can be
   407.    --    made more realistic by specifying its real length to correct_transfer_time.
   408.    -- correct_transfer_time must be called before finalize_transfer is called.
   409.
   410.    procedure correct_transfer_time (the_buffer  : in out IOC.device'Class;
   411.                                     actual_time : in KDF9.us) is
   412.    begin
   413.       the_buffer.transfer_time :=  actual_time;
   414.       the_buffer.completion_time := the_buffer.initiation_time + the_buffer.transfer_time;
   415.       if the_buffer.completion_time < the_next_interrupt_time then
   416.          the_next_interrupt_time := the_buffer.completion_time;
   417.       end if;
   418.    end correct_transfer_time;
   419.
   420.    procedure correct_transfer_time (the_buffer    : in out IOC.device'Class;
   421.                                     actual_length : in KDF9.word) is
   422.    begin
   423.       the_buffer.transfer_time := IO_elapsed_time(the_buffer, actual_length);
   424.       the_buffer.completion_time := the_buffer.initiation_time + the_buffer.transfer_time;
   425.       if the_buffer.completion_time < the_next_interrupt_time then
   426.          the_next_interrupt_time := the_buffer.completion_time;
   427.       end if;
   428.    end correct_transfer_time;
   429.
   430.    -- If the buffer has a terminated transfer, clear its lockouts, reset its state,
   431.    --    update the PHUs, and demand an EDT or PR interrupt as needed.
   432.    procedure finalize_transfer (the_buffer : in out IOC.device'Class;
   433.                                 need_EDT,
   434.                                 need_PR    : out Boolean) is
   435.       the_PHU : KDF9.PHU_store.PHU_register renames KDF9.PHU_store.PHU(the_buffer.priority_level);
   436.       blocked : PHU_reason;
   437.    begin
   438.       if the_buffer.transfer_time /= 0 then
   439.          take_note_of_IO_finis (
   440.                                 the_buffer.order_count,
   441.                                 the_buffer.order_address,
   442.                                 the_buffer.decoded_order,
   443.                                 the_buffer.initiation_time,
   444.                                 the_buffer.device_name,
   445.                                 the_buffer.is_for_Director,
   446.                                 the_buffer.priority_level,
   447.                                 the_buffer.completion_time,
   448.                                 the_buffer.control_word,
   449.                                 the_buffer.operation
   450.                                );
   451.       end if;
   452.
   453.       need_EDT := the_buffer.is_for_Director;
   454.
   455.       -- Clear down the transfer and idle the buffer.
   456.       if the_buffer.is_DMAing then
   457.          unlock_absolute_addresses(the_buffer.control_word);
   458.       end if;
   459.       the_buffer.is_busy := False;
   460.       the_buffer.is_for_Director := False;
   461.
   462.       -- The following code is somewhat redundant, but written like this to exactly mirror the
   463.       -- logic stated in the KDF9 TIME-SHARING DIRECTOR SUPPORT DOCUMENTATION of 1-May-1965.
   464.       need_PR := False;
   465.       if the_PHU.is_held_up then
   466.          blocked := the_PHU.blockage;
   467.          if (blocked.reason = buffer_busy and then blocked.by_INTQq)                      or else
   468.             (blocked.reason = buffer_busy and then not buffer(blocked.buffer_nr).is_busy) or else
   469.             (blocked.reason = locked_core and then is_unlocked(blocked.group_nr))            then
   470.             the_PHU := idle_PHU;
   471.             need_PR := the_buffer.priority_level < CPL;
   472.          end if;
   473.       end if;
   474.
   475.       -- A PR interrupt may be wanted, BUT not if an EDT interrupt is wanted.
   476.       -- EDT is wanted if the transfer was for Director OR another program awaits the same buffer.
   477.
   478.       -- Check the rest of the PHU stores for an EDT interrupt.
   479.       -- This is needed only when running a Director.
   480.       if the_execution_mode = boot_mode then
   481.          -- Test for possible priority inversion, i.e. other program(s) blocked on this buffer.
   482.          for p of PHU loop
   483.             if p.is_held_up                               and then
   484.                   p.blockage.reason = buffer_busy         and then
   485.                      p.blockage.buffer_nr = the_buffer.number then
   486.                -- The KDF9 TIME-SHARING DIRECTOR SUPPORT DOCUMENTATION of 1-May-1965
   487.                --   says such a PHU is NOT cleared, but EDT is requested INSTEAD of PR,
   488.                --   so Director can take action according to what it finds there.
   489.                need_EDT := True;
   490.             end if;
   491.          end loop;
   492.       end if;
   493.       if need_EDT then
   494.          need_PR := False;
   495.       end if;
   496.    end finalize_transfer;
   497.
   498.    procedure act_on_pending_interrupts is
   499.       time_now   : constant KDF9.us := the_clock_time;
   500.       EDT_needed,
   501.       PR_needed  : Boolean := False;
   502.       number     : IOC.device_number := 16;
   503.    begin
   504.       advance_the_clock(the_next_interrupt_time);
   505.       -- Predict another interrupt (at most 2**20 seconds in the future in boot mode).
   506.       the_next_interrupt_time := KDF9.us'Last;
   507.       for b of buffer loop
   508.          if b /= null and then
   509.                b.is_busy  then
   510.             if time_now >= b.completion_time then
   511.                finalize_transfer(b.all, EDT_needed, PR_needed);
   512.                if EDT_needed or PR_needed then
   513.                   number := b.number;
   514.                end if;
   515.             elsif the_next_interrupt_time > b.completion_time then
   516.                the_next_interrupt_time := b.completion_time;
   517.             end if;
   518.          end if;
   519.       end loop;
   520.       -- Prevent an inadvertant double clock interrupt.
   521.       if the_execution_mode = boot_mode                and then
   522.             the_next_interrupt_time > time_now + 1_048_575 then
   523.          the_next_interrupt_time := time_now + 1_048_575;
   524.       end if;
   525.       if EDT_needed then
   526.          effect_device_interrupt(EDT_interrupt, buffer(number).all);
   527.       elsif PR_needed then
   528.          effect_device_interrupt(PR_interrupt, buffer(number).all);
   529.       end if;
   530.    end act_on_pending_interrupts;
   531.
   532.    -- Advance the time to a point after all extant transfer have terminated,
   533.    --    finalizing all extant transfer in temporal order in the process.
   534.    procedure complete_all_extant_transfers is
   535.       EDT_needed,
   536.       PR_needed      : Boolean := False;
   537.       last_time      : KDF9.us := 0;
   538.       next_time      : KDF9.us;
   539.    begin
   540.       -- At least one transfer should be terminated each time around outer_loop,
   541.       --    if not, outer_loop is exited.
   542.    outer_loop:
   543.       for c in buffer'Range loop
   544.          -- Find the earliest transfer termination time.
   545.          next_time := KDF9.us'Last;
   546.          for b of buffer loop
   547.             if b /= null                       and then
   548.                   b.is_busy                    and then
   549.                      b.completion_time < next_time then
   550.                next_time := b.completion_time;
   551.             end if;
   552.          end loop;
   553.
   554.          if next_time = KDF9.us'Last then
   555.             -- All the buffers are quiescent.
   556.             exit outer_loop;
   557.          else
   558.             -- At least one transfer remains to be finalized.
   559.             advance_the_clock(next_time);
   560.             last_time := KDF9.us'Max(last_time, next_time);
   561.          end if;
   562.
   563.          -- Finalize all transfers with completion time <= next_time.
   564.          for b of buffer loop
   565.             if b /= null                        and then
   566.                   b.is_busy                     and then
   567.                      b.completion_time <= next_time then
   568.                finalize_transfer(b.all, EDT_needed, PR_needed);
   569.             end if;
   570.          end loop;
   571.
   572.       end loop outer_loop;
   573.    end complete_all_extant_transfers;
   574.
   575.    procedure handle_a_main_store_lockout is
   576.       the_locker : KDF9.buffer_number;
   577.    begin
   578.       PHU(CPL) := (
   579.                    is_held_up => True,
   580.                    blockage   => (locked_core, group_address(group(the_locked_out_address)))
   581.                   );
   582.       -- Store access LOV interrupts invoke instruction restart outside Director.
   583.       the_locker := the_locker_of(the_locked_out_address);
   584.       take_note_of_store_lockout(device_name_of(buffer(the_locker).all));
   585.       if the_execution_mode = boot_mode then
   586.          if_user_mode_then_LOV(the_locked_out_address);
   587.       else
   588.          set_NIA_to(CIA);
   589.          advance_the_clock(buffer(the_locker).completion_time);
   590.          act_on_pending_interrupts;
   591.       end if;
   592.       ICR := ICR + 1;
   593.    end handle_a_main_store_lockout;
   594.
   595.    procedure MANUAL_CT (the_buffer  : in out IOC.device'Class;
   596.                         Q_operand   : in KDF9.Q_register;
   597.                         set_offline : in Boolean) is
   598.       EDT_needed, PR_needed : Boolean := False;
   599.    begin
   600.       validate_device(the_buffer, Q_operand);
   601.       take_note_of_test(the_buffer.device_name, Q_operand, the_buffer.is_busy);
   602.       -- ee9 allows the transfer to terminate normally, as if MANUALQ with set_offline = True;
   603.       --    even when set_offline = False, i.e. CTQ, which aborted any residual I/O on the KDF9.
   604.       if the_buffer.is_busy then
   605.          the_buffer.completion_time := KDF9.us'Min(the_buffer.completion_time, the_clock_time);
   606.          finalize_transfer(the_buffer, EDT_needed, PR_needed);
   607.       end if;
   608.       the_buffer.is_busy     := False;
   609.       the_buffer.operation   := some_other_operation;
   610.       the_buffer.is_abnormal := False;
   611.       the_buffer.is_offline  := set_offline;
   612.    end MANUAL_CT;
   613.
   614.    procedure INT (the_buffer  : in out IOC.device'Class;
   615.                   Q_operand   : in KDF9.Q_register;
   616.                   set_offline : in Boolean) is
   617.       now  : constant KDF9.us := the_clock_time;
   618.       step : KDF9.us;
   619.    begin
   620.       validate_device(the_buffer, Q_operand);
   621.       if the_buffer.is_busy then
   622.          PHU(CPL) := (
   623.                       is_held_up => True,
   624.                       blockage   => (buffer_busy, the_buffer.number, by_INTQq => True)
   625.                      );
   626.          take_note_of_buffer_lockout(the_buffer.device_name, the_buffer.operation);
   627.          if the_execution_mode = boot_mode then
   628.             step := KDF9.us'Max((the_buffer.completion_time - now) / 16, 1);
   629.             advance_the_clock(KDF9.us'Min(the_buffer.completion_time, now + step));
   630.             effect(PR_interrupt, image(the_buffer));
   631.          else
   632.             advance_the_clock(the_buffer.completion_time);
   633.             act_on_pending_interrupts;
   634.          end if;
   635.       else
   636.          take_note_of_test(the_buffer.device_name, Q_operand, False);
   637.       end if;
   638.       the_buffer.is_offline := set_offline;
   639.    end INT;
   640.
   641.    procedure BUSY (the_buffer  : in out IOC.device'Class;
   642.                    Q_operand   : in KDF9.Q_register;
   643.                    set_offline : in Boolean;
   644.                    result      : out Boolean) is
   645.    begin
   646.       validate_device(the_buffer, Q_operand);
   647.       result := the_buffer.is_busy;
   648.       take_note_of_test(the_buffer.device_name, Q_operand, result);
   649.       if the_buffer.is_busy and then
   650.             (the_execution_mode /= boot_mode or the_CPU_state = Director_state) then
   651.          act_on_pending_interrupts;
   652.       end if;
   653.       the_buffer.is_offline := set_offline;
   654.    end BUSY;
   655.
   656.    procedure PAR (the_buffer  : in out IOC.device'Class;
   657.                   Q_operand   : in KDF9.Q_register;
   658.                   set_offline : in Boolean;
   659.                   result      : out Boolean) is
   660.    begin
   661.       validate_device(the_buffer, Q_operand);
   662.       deal_with_a_busy_device(the_buffer, 13, set_offline);
   663.       result := the_buffer.is_abnormal;
   664.       take_note_of_test(the_buffer.device_name, Q_operand, result);
   665.       the_buffer.is_abnormal := False;
   666.       the_buffer.is_offline := set_offline;
   667.    end PAR;
   668.
   669.    subtype IO_mnemonic is String(1 .. 5);
   670.    type synonyms       is array (1 .. 2) of IO_mnemonic;
   671.    type synonym_list   is array (Positive range <>) of synonyms;
   672.
   673.    FW_synonyms  : constant synonym_list
   674.                 := (
   675.                     ("POA  ", "TW   "), ("POB  ", "TWE  "),
   676.                     ("PIA  ", "TR   "), ("PIB  ", "TRE  ")
   677.                    );
   678.
   679.    TR_synonyms  : constant synonym_list
   680.                 := (
   681.                     ("PIA  ", "PR   "), ("PIB  ", "PRE  "),
   682.                     ("PIC  ", "PRC  "), ("PID  ", "PRCE ")
   683.                    );
   684.
   685.    TP_synonyms  : constant synonym_list
   686.                 := (
   687.                     ("POA  ", "PW   "), ("POB  ", "PWE  "),
   688.                     ("POC  ", "PWC  "), ("POD  ", "PWCE "),
   689.                     ("POE  ", "PGAP ")
   690.                    );
   691.
   692.    LP_synonyms  : constant synonym_list
   693.                 := (
   694.                     ("POA  ", "LP   "), ("POB  ", "LPE  ")
   695.                    );
   696.
   697.    MT_synonyms  : constant synonym_list
   698.                 := (
   699.                     ("PIA  ", "MFR  "), ("PIB  ", "MFRE "),
   700.                     ("PIE  ", "MBR  "), ("PIF  ", "MBRE "),
   701.                     ("POA  ", "MW   "), ("POB  ", "MWE  "),
   702.                     ("POC  ", "MLW  "), ("POD  ", "MLWE "),
   703.                     ("POE  ", "MGAP "), ("POF  ", "MWIPE"),
   704.                     ("PMA  ", "MFSK "), ("PMB  ", "MBT  "),
   705.                     ("PMC  ", "MLB  "), ("PMD  ", "MRWD "),
   706.                     ("PME  ", "MBSK "), ("PMF  ", "MET  ")
   707.                    );
   708.
   709.    function mnemonic (order : in String; class : in IOC.device_name)
   710.    return String is
   711.
   712.       key : constant IO_mnemonic := just_left(order(order'First..order'First+2), 5);
   713.       Qij : constant String      := order(order'First+3..order'Last);
   714.
   715.       function choose (synonyms : synonym_list)
   716.       return String is
   717.       begin
   718.          for s of synonyms loop
   719.             if s(1) = key then return trimmed(s(2)) & Qij; end if;
   720.          end loop;
   721.          return order;
   722.       end choose;
   723.
   724.       XY : constant String(1..2) := class(class'First..class'First+1);
   725.
   726.    begin
   727.       if key(1..3) in "TLO" | "CLO" | "PMH" | "SLO" then
   728.          -- These orders do not necessarily involve a device.
   729.          return order;
   730.       end if;
   731.       if XY in "AD" | "CP" | "CR" | "DR" | "FD" | "GP" | "ST" | "SI" then
   732.          return order;
   733.       elsif XY = "FW" then -- FlexoWriter
   734.          return choose(FW_synonyms);
   735.       elsif XY = "LP" then -- Line Printer
   736.          return choose(LP_synonyms);
   737.       elsif XY = "MT" then -- Magnetic Tape
   738.          return choose(MT_synonyms);
   739.       elsif XY = "TP" then -- Tape Punch
   740.          return choose(TP_synonyms);
   741.       elsif XY = "TR" then -- Tape Reader
   742.          return choose(TR_synonyms);
   743.       else
   744.          return "??";
   745.       end if;
   746.    end mnemonic;
   747.
   748.    procedure trap_failing_IO_operation (the_buffer : in out IOC.device; the_message : in String) is
   749.       the_diagnostic : constant String := "%" & the_message & " on " & the_buffer.device_name;
   750.    begin
   751.       if the_execution_mode in program_mode | test_program_mode then
   752.          raise IO_error with the_diagnostic;
   753.       elsif the_CPU_state = program_state then
   754.          the_buffer.is_abnormal := True;
   755.          raise abandon_this_order with the_diagnostic;
   756.       else
   757.          -- The Director itself has gone seriously wrong.
   758.          raise Director_IO_error with the_diagnostic;
   759.       end if;
   760.    end trap_failing_IO_operation;
   761.
   762.    procedure trap_illegal_IO_operation (order : in String; buffer : in IOC.device) is
   763.    begin
   764.       trap_illegal_instruction(order & " cannot be used on " & buffer.device_name);
   765.    end trap_illegal_IO_operation;
   766.
   767.    --
   768.    -- The following bodies provide inheritable default actions for
   769.    -- operations that are not implemented by specific device types.
   770.    --
   771.
   772.    procedure PIA (the_buffer  : in out IOC.device;
   773.                   Q_operand   : in KDF9.Q_register;
   774.                   set_offline : in Boolean) is
   775.       pragma Unreferenced(Q_operand);
   776.       pragma Unreferenced(set_offline);
   777.    begin
   778.       trap_illegal_IO_operation("PIA", the_buffer);
   779.    end PIA;
   780.
   781.    procedure PIB (the_buffer  : in out IOC.device;
   782.                   Q_operand   : in KDF9.Q_register;
   783.                   set_offline : in Boolean) is
   784.       pragma Unreferenced(Q_operand);
   785.       pragma Unreferenced(set_offline);
   786.    begin
   787.       trap_illegal_IO_operation("PIB", the_buffer);
   788.    end PIB;
   789.
   790.    procedure PIC (the_buffer  : in out IOC.device;
   791.                   Q_operand   : in KDF9.Q_register;
   792.                   set_offline : in Boolean) is
   793.       pragma Unreferenced(Q_operand);
   794.       pragma Unreferenced(set_offline);
   795.    begin
   796.       trap_illegal_IO_operation("PIC", the_buffer);
   797.    end PIC;
   798.
   799.    procedure PID (the_buffer  : in out IOC.device;
   800.                   Q_operand   : in KDF9.Q_register;
   801.                   set_offline : in Boolean) is
   802.       pragma Unreferenced(Q_operand);
   803.       pragma Unreferenced(set_offline);
   804.    begin
   805.       trap_illegal_IO_operation("PID", the_buffer);
   806.    end PID;
   807.
   808.    procedure PIE (the_buffer  : in out IOC.device;
   809.                   Q_operand   : in KDF9.Q_register;
   810.                   set_offline : in Boolean) is
   811.       pragma Unreferenced(Q_operand);
   812.       pragma Unreferenced(set_offline);
   813.    begin
   814.       trap_illegal_IO_operation("PIE", the_buffer);
   815.    end PIE;
   816.
   817.    procedure PIF (the_buffer  : in out IOC.device;
   818.                   Q_operand   : in KDF9.Q_register;
   819.                   set_offline : in Boolean) is
   820.       pragma Unreferenced(Q_operand);
   821.       pragma Unreferenced(set_offline);
   822.    begin
   823.       trap_illegal_IO_operation("PIF", the_buffer);
   824.    end PIF;
   825.
   826.    procedure PIG (the_buffer  : in out IOC.device;
   827.                   Q_operand   : in KDF9.Q_register;
   828.                   set_offline : in Boolean) is
   829.       pragma Unreferenced(Q_operand);
   830.       pragma Unreferenced(set_offline);
   831.    begin
   832.       trap_illegal_IO_operation("PIG", the_buffer);
   833.    end PIG;
   834.
   835.    procedure PIH (the_buffer  : in out IOC.device;
   836.                   Q_operand   : in KDF9.Q_register;
   837.                   set_offline : in Boolean) is
   838.       pragma Unreferenced(Q_operand);
   839.       pragma Unreferenced(set_offline);
   840.    begin
   841.       trap_illegal_IO_operation("PIH", the_buffer);
   842.    end PIH;
   843.
   844.    procedure PMA (the_buffer  : in out IOC.device;
   845.                   Q_operand   : in KDF9.Q_register;
   846.                   set_offline : in Boolean) is
   847.       pragma Unreferenced(Q_operand);
   848.       pragma Unreferenced(set_offline);
   849.    begin
   850.       trap_illegal_IO_operation("PMA", the_buffer);
   851.    end PMA;
   852.
   853.    procedure PMB (the_buffer  : in out IOC.device;
   854.                   Q_operand   : in KDF9.Q_register;
   855.                   set_offline : in Boolean) is
   856.       pragma Unreferenced(the_buffer);
   857.       pragma Unreferenced(Q_operand);
   858.       pragma Unreferenced(set_offline);
   859.    begin
   860.       null;
   861.    end PMB;
   862.
   863.    procedure PMC (the_buffer  : in out IOC.device;
   864.                   Q_operand   : in KDF9.Q_register;
   865.                   set_offline : in Boolean) is
   866.       pragma Unreferenced(the_buffer);
   867.       pragma Unreferenced(Q_operand);
   868.       pragma Unreferenced(set_offline);
   869.    begin
   870.       null;
   871.    end PMC;
   872.
   873.    procedure PMD (the_buffer  : in out IOC.device;
   874.                   Q_operand   : in KDF9.Q_register;
   875.                   set_offline : in Boolean) is
   876.       pragma Unreferenced(Q_operand);
   877.       pragma Unreferenced(set_offline);
   878.    begin
   879.       trap_illegal_IO_operation("PMD", the_buffer);
   880.    end PMD;
   881.
   882.    procedure PME (the_buffer  : in out IOC.device;
   883.                   Q_operand   : in KDF9.Q_register;
   884.                   set_offline : in Boolean) is
   885.       pragma Unreferenced(Q_operand);
   886.       pragma Unreferenced(set_offline);
   887.    begin
   888.       trap_illegal_IO_operation("PME", the_buffer);
   889.    end PME;
   890.
   891.    procedure PMF (the_buffer  : in out IOC.device;
   892.                   Q_operand   : in KDF9.Q_register;
   893.                   set_offline : in Boolean) is
   894.       pragma Unreferenced(the_buffer);
   895.       pragma Unreferenced(Q_operand);
   896.       pragma Unreferenced(set_offline);
   897.    begin
   898.       null;
   899.    end PMF;
   900.
   901.    procedure PMG (the_buffer  : in out IOC.device;
   902.                   Q_operand   : in KDF9.Q_register;
   903.                   set_offline : in Boolean) is
   904.       pragma Unreferenced(Q_operand);
   905.       pragma Unreferenced(set_offline);
   906.    begin
   907.       trap_illegal_IO_operation("PMG", the_buffer);
   908.    end PMG;
   909.
   910. -- procedure PMH is subsumed by SLOC.
   911.
   912.    procedure PMK (the_buffer  : in out IOC.device;
   913.                   Q_operand   : in KDF9.Q_register;
   914.                   set_offline : in Boolean) is
   915.       pragma Unreferenced(Q_operand);
   916.       pragma Unreferenced(set_offline);
   917.    begin
   918.       trap_illegal_IO_operation("PMK", the_buffer);
   919.    end PMK;
   920.
   921.    procedure PML (the_buffer  : in out IOC.device;
   922.                   Q_operand   : in KDF9.Q_register;
   923.                   set_offline : in Boolean) is
   924.       pragma Unreferenced(Q_operand);
   925.       pragma Unreferenced(set_offline);
   926.    begin
   927.       trap_illegal_IO_operation("PML", the_buffer);
   928.    end PML;
   929.
   930.    procedure POA (the_buffer  : in out IOC.device;
   931.                   Q_operand   : in KDF9.Q_register;
   932.                   set_offline : in Boolean) is
   933.       pragma Unreferenced(Q_operand);
   934.       pragma Unreferenced(set_offline);
   935.    begin
   936.       trap_illegal_IO_operation("POA", the_buffer);
   937.    end POA;
   938.
   939.    procedure POB (the_buffer  : in out IOC.device;
   940.                   Q_operand   : in KDF9.Q_register;
   941.                   set_offline : in Boolean) is
   942.       pragma Unreferenced(Q_operand);
   943.       pragma Unreferenced(set_offline);
   944.    begin
   945.       trap_illegal_IO_operation("POB", the_buffer);
   946.    end POB;
   947.
   948.    procedure POC (the_buffer  : in out IOC.device;
   949.                   Q_operand   : in KDF9.Q_register;
   950.                   set_offline : in Boolean) is
   951.       pragma Unreferenced(Q_operand);
   952.       pragma Unreferenced(set_offline);
   953.    begin
   954.       trap_illegal_IO_operation("POC", the_buffer);
   955.    end POC;
   956.
   957.    procedure POD (the_buffer  : in out IOC.device;
   958.                   Q_operand   : in KDF9.Q_register;
   959.                   set_offline : in Boolean) is
   960.       pragma Unreferenced(Q_operand);
   961.       pragma Unreferenced(set_offline);
   962.    begin
   963.       trap_illegal_IO_operation("POD", the_buffer);
   964.    end POD;
   965.
   966.    procedure POE (the_buffer  : in out IOC.device;
   967.                   Q_operand   : in KDF9.Q_register;
   968.                   set_offline : in Boolean) is
   969.       pragma Unreferenced(Q_operand);
   970.       pragma Unreferenced(set_offline);
   971.    begin
   972.       trap_illegal_IO_operation("POE", the_buffer);
   973.    end POE;
   974.
   975.    procedure POF (the_buffer  : in out IOC.device;
   976.                   Q_operand   : in KDF9.Q_register;
   977.                   set_offline : in Boolean) is
   978.       pragma Unreferenced(Q_operand);
   979.       pragma Unreferenced(set_offline);
   980.    begin
   981.       trap_illegal_IO_operation("POF", the_buffer);
   982.    end POF;
   983.
   984.    procedure POG (the_buffer  : in out IOC.device;
   985.                   Q_operand   : in KDF9.Q_register;
   986.                   set_offline : in Boolean) is
   987.       pragma Unreferenced(Q_operand);
   988.       pragma Unreferenced(set_offline);
   989.    begin
   990.       trap_illegal_IO_operation("POG", the_buffer);
   991.    end POG;
   992.
   993.    procedure POH (the_buffer  : in out IOC.device;
   994.                   Q_operand   : in KDF9.Q_register;
   995.                   set_offline : in Boolean) is
   996.       pragma Unreferenced(Q_operand);
   997.       pragma Unreferenced(set_offline);
   998.    begin
   999.       trap_illegal_IO_operation("POH", the_buffer);
  1000.    end POH;
  1001.
  1002.    procedure POK (the_buffer  : in out IOC.device;
  1003.                   Q_operand   : in KDF9.Q_register;
  1004.                   set_offline : in Boolean) is
  1005.       pragma Unreferenced(Q_operand);
  1006.       pragma Unreferenced(set_offline);
  1007.    begin
  1008.       trap_illegal_IO_operation("POK", the_buffer);
  1009.    end POK;
  1010.
  1011.    procedure POL (the_buffer  : in out IOC.device;
  1012.                   Q_operand   : in KDF9.Q_register;
  1013.                   set_offline : in Boolean) is
  1014.       pragma Unreferenced(Q_operand);
  1015.       pragma Unreferenced(set_offline);
  1016.    begin
  1017.       trap_illegal_IO_operation("POL", the_buffer);
  1018.    end POL;
  1019.
  1020. end IOC;

Compiling: ../Source/ioc.ads
Source file time stamp: 2021-02-08 00:49:51
Compiled at: 2021-02-08 17:20:56

     1. -- Emulation of the common functionality of a KDF9 IOC "buffer" (DMA channel),
     2. --    with fail-stop stubs for operations having device-specific behaviour.
     3. --
     4. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with Ada.Finalization;
    19. --
    20. with KDF9;
    21.
    22. private with Ada.Characters.Latin_1;
    23. --
    24. private with exceptions;
    25. private with formatting;
    26. private with host_IO;
    27. private with KDF9_char_sets;
    28. private with KDF9.store;
    29. private with POSIX;
    30. private with settings;
    31.
    32. use  Ada.Finalization;
    33. --
    34. use  KDF9;
    35.
    36. package IOC is
    37.
    38.    -- N.B. the KDF9 'buffer' is a DMA controller in more modern terminology.
    39.
    40.    -- Each KDF9 buffer is externally characterized by:
    41.    --    its (absolute) number,
    42.    --    its (attached-device) kind, and
    43.    --    its unit (the number of that device within its kind).
    44.
    45.    -- A device of AD_kind is attached to a buffer with No Device connected.
    46.    -- If commanded, it performs a basic default action,
    47.    --    which is to cause a LIV interrupt in the case of transfers,
    48.    --       but is both benign and appropriate for all other operations.
    49.
    50.    type device_kind is
    51.       (CP_kind,  -- Card Punch
    52.        CR_kind,  -- Card Reader
    53.        DR_kind,  -- Drum
    54.        FD_kind,  -- Fixed Disc
    55.        FW_kind,  -- FlexoWriter (monitor typewriter)
    56.        GP_kind,  -- Graph Plotter (Calcomp 120' by 29.5" model)
    57.        LP_kind,  -- Line Printer
    58.        MT_kind,  -- Magnetic Tape
    59.        SI_kind,  -- Standard Interface buffer
    60.        ST_kind,  -- Seven Track (IBM) magnetic Tape
    61.        TP_kind,  -- Tape Punch
    62.        TR_kind,  -- Tape Reader
    63.        AD_kind   -- Absent Device
    64.       );
    65.
    66.    -- An absent device has number 16 (not a valid buffer number).
    67.    subtype device_number is KDF9.Q_part range 0 .. 16;
    68.
    69.    -- There are at most 10 devices of a type (this is an ee9 limit, not imposed by KDF9 hardware).
    70.    subtype unit_number is KDF9.Q_part range 0 .. 9;
    71.
    72.    -- An IOC.device_name is of the form XYu, where XY is a two-letter device-type
    73.    --    code (e.g., "LP" or "CR"); and u is the one-digit logical unit number
    74.    --       of a device within its category.
    75.
    76.    subtype device_name is String(1..3);
    77.
    78. --
    79. --
    80.    -- This is the root for all I/O device types.
    81. --
    82. --
    83.
    84.    -- The quantum is the time, in µs, taken to transfer a basic datum.
    85.    -- For unit-record devices (CR, CP, LP) this is the card/line, respectively.
    86.    -- For other devices it is the KDF9 character.
    87.    -- A device is slow if it transfers data byte-by-byte; fast devices transfer whole words.
    88.
    89.    type device (
    90.                 number  : IOC.device_number;
    91.                 kind    : IOC.device_kind;
    92.                 unit    : IOC.unit_number;
    93.                 quantum : KDF9.us
    94.                )
    95.    is abstract new Limited_Controlled with private;
    96.
    97.    -- True iff the_buffer has been opened but not yet closed.
    98.    function is_open (the_buffer : IOC.device)
    99.    return Boolean;
   100.
   101.    -- A measure of the I/O volume transferred by the_buffer, so far.
   102.    function usage (the_buffer : IOC.device)
   103.    return KDF9.word;
   104.
   105.    -- Ensure that all output to the_buffer has been transmitted.
   106.    procedure flush (the_buffer : in out IOC.device);
   107.
   108.    -- Make the_buffer unavailable for further I/O use, after flushing if necessary.
   109.    procedure close (the_buffer : in out IOC.device);
   110.
   111.    -- A IOC.device_name is of the form XYu, where XY is a two-letter device-type
   112.    --    code (e.g., "LP" or "CR"); and u is the one-digit logical unit number
   113.    --       of a device within its category.
   114.
   115.    function device_name_of (the_buffer : IOC.device)
   116.    return IOC.device_name;
   117.
   118.    function device_name_of (the_number : IOC.device_number)
   119.    return IOC.device_name;
   120.
   121.    function device_kind_of (the_number : IOC.device_number)
   122.    return IOC.device_kind;
   123.
   124.    function mnemonic (order : in String; class : in IOC.device_name)
   125.    return String;
   126.
   127.    -- An I/O operation may fail for two distict reasons:
   128.    -- 1. the order is illegal per se
   129.    -- 2. the order is legal, but is attempting an impossible effect.
   130.
   131.    -- trap_illegal_IO_operation fails the run because of an attempt to use an I/O order
   132.    --   that is illegal or undefined for the device concerned.
   133.    procedure trap_illegal_IO_operation (order : in String; buffer : in IOC.device);
   134.
   135.    -- trap_failing_IO_operation fails the run iff either:
   136.    -- 1. ee9 is running in a non-boot mode, because nothing more can usefully be done
   137.    -- OR
   138.    -- 2. Director is running, because an impossible operation implies a serious failure in Director.
   139.    --
   140.    -- In boot mode, when Director is not running, it sets the buffer abnormal and abandons the order.
   141.    -- It is then up to the problem program to act accordingly.  Failure to do so may LIV.
   142.    procedure trap_failing_IO_operation (the_buffer : in out IOC.device; the_message : in String);
   143.
   144.    -- The elapsed time for the I/O of the given number of atomic_items
   145.    --    which may be, e.g., bytes, or card images, or printer lines.
   146.    function IO_elapsed_time (the_buffer   : IOC.device;
   147.                              atomic_items : KDF9.word)
   148.    return KDF9.us;
   149.
   150.    -- The total elapsed time taken, so far, by transfers on the attached device.
   151.    function IO_elapsed_time_total (the_buffer : IOC.device)
   152.    return KDF9.us;
   153.
   154.
   155.    --
   156.    -- The CLOQq, SLOQq and TLOQq operations do NOT address a buffer,
   157.    --    and so are fully implemented elsewhere.
   158.    --
   159.
   160.    --
   161.    -- The INTQq, BUSYQq, PARQq and MANUALQq/CTQq operations DO address a buffer,
   162.    --    but do NOT initiate an I/O transfer, and are common to all devices,
   163.    --       so they operate on a class-wide parameter.
   164.    --
   165.
   166.    procedure INT (the_buffer  : in out IOC.device'Class;
   167.                   Q_operand   : in KDF9.Q_register;
   168.                   set_offline : in Boolean);
   169.
   170.    procedure BUSY (the_buffer  : in out IOC.device'Class;
   171.                    Q_operand   : in KDF9.Q_register;
   172.                    set_offline : in Boolean;
   173.                    result      : out Boolean);
   174.
   175.    procedure PAR (the_buffer   : in out IOC.device'Class;
   176.                    Q_operand   : in KDF9.Q_register;
   177.                    set_offline : in Boolean;
   178.                    result      : out Boolean);
   179.
   180.    procedure MANUAL_CT (the_buffer  : in out IOC.device'Class;
   181.                         Q_operand   : in KDF9.Q_register;
   182.                         set_offline : in Boolean);
   183.
   184.    -- These KDF9 data-transfer operations must be overridden for non-trivial functionality.
   185.    -- Invoking any of them raises a LIV exception. This exactly mirrors the action of the
   186.    --    KDF9 in causing a LIV interrupt when an invalid operation was applied to a device.
   187.    -- A device without some of these operations inherits them from this list and so
   188.    --    implements correctly the original semantics of the KDF9.
   189.
   190.    --
   191.    -- The PI* are input operations.
   192.    --
   193.
   194.    procedure PIA (the_buffer  : in out IOC.device;
   195.                   Q_operand   : in KDF9.Q_register;
   196.                   set_offline : in Boolean);
   197.
   198.    procedure PIB (the_buffer  : in out IOC.device;
   199.                   Q_operand   : in KDF9.Q_register;
   200.                   set_offline : in Boolean);
   201.
   202.    procedure PIC (the_buffer  : in out IOC.device;
   203.                   Q_operand   : in KDF9.Q_register;
   204.                   set_offline : in Boolean);
   205.
   206.    procedure PID (the_buffer  : in out IOC.device;
   207.                   Q_operand   : in KDF9.Q_register;
   208.                   set_offline : in Boolean);
   209.
   210.    procedure PIE (the_buffer  : in out IOC.device;
   211.                   Q_operand   : in KDF9.Q_register;
   212.                   set_offline : in Boolean);
   213.
   214.    procedure PIF (the_buffer  : in out IOC.device;
   215.                   Q_operand   : in KDF9.Q_register;
   216.                   set_offline : in Boolean);
   217.
   218.    procedure PIG (the_buffer  : in out IOC.device;
   219.                   Q_operand   : in KDF9.Q_register;
   220.                   set_offline : in Boolean);
   221.
   222.    procedure PIH (the_buffer  : in out IOC.device;
   223.                   Q_operand   : in KDF9.Q_register;
   224.                   set_offline : in Boolean);
   225.
   226.    --
   227.    -- The PM* are device-status operations.
   228.    --
   229.
   230.    procedure PMA (the_buffer  : in out IOC.device;
   231.                   Q_operand   : in KDF9.Q_register;
   232.                   set_offline : in Boolean);
   233.
   234.    procedure PMB (the_buffer  : in out IOC.device;
   235.                   Q_operand   : in KDF9.Q_register;
   236.                   set_offline : in Boolean);
   237.
   238.    procedure PMC (the_buffer  : in out IOC.device;
   239.                   Q_operand   : in KDF9.Q_register;
   240.                   set_offline : in Boolean);
   241.
   242.    procedure PMD (the_buffer  : in out IOC.device;
   243.                   Q_operand   : in KDF9.Q_register;
   244.                   set_offline : in Boolean);
   245.
   246.    procedure PME (the_buffer  : in out IOC.device;
   247.                   Q_operand   : in KDF9.Q_register;
   248.                   set_offline : in Boolean);
   249.
   250.    procedure PMF (the_buffer  : in out IOC.device;
   251.                   Q_operand   : in KDF9.Q_register;
   252.                   set_offline : in Boolean);
   253.
   254.    procedure PMG (the_buffer  : in out IOC.device;
   255.                   Q_operand   : in KDF9.Q_register;
   256.                   set_offline : in Boolean);
   257.
   258. -- procedure PMH is implemented by SLO
   259.
   260.    procedure PMK (the_buffer  : in out IOC.device;
   261.                   Q_operand   : in KDF9.Q_register;
   262.                   set_offline : in Boolean);
   263.
   264.    procedure PML (the_buffer  : in out IOC.device;
   265.                   Q_operand   : in KDF9.Q_register;
   266.                   set_offline : in Boolean);
   267.
   268.    --
   269.    -- The PO* are output operations.
   270.    --
   271.
   272.    procedure POA (the_buffer  : in out IOC.device;
   273.                   Q_operand   : in KDF9.Q_register;
   274.                   set_offline : in Boolean);
   275.
   276.    procedure POB (the_buffer  : in out IOC.device;
   277.                   Q_operand   : in KDF9.Q_register;
   278.                   set_offline : in Boolean);
   279.
   280.    procedure POC (the_buffer  : in out IOC.device;
   281.                   Q_operand   : in KDF9.Q_register;
   282.                   set_offline : in Boolean);
   283.
   284.    procedure POD (the_buffer  : in out IOC.device;
   285.                   Q_operand   : in KDF9.Q_register;
   286.                   set_offline : in Boolean);
   287.
   288.    procedure POE (the_buffer  : in out IOC.device;
   289.                   Q_operand   : in KDF9.Q_register;
   290.                   set_offline : in Boolean);
   291.
   292.    procedure POF (the_buffer  : in out IOC.device;
   293.                   Q_operand   : in KDF9.Q_register;
   294.                   set_offline : in Boolean);
   295.
   296.    procedure POG (the_buffer  : in out IOC.device;
   297.                   Q_operand   : in KDF9.Q_register;
   298.                   set_offline : in Boolean);
   299.
   300.    procedure POH (the_buffer  : in out IOC.device;
   301.                   Q_operand   : in KDF9.Q_register;
   302.                   set_offline : in Boolean);
   303.
   304.    procedure POK (the_buffer  : in out IOC.device;
   305.                   Q_operand   : in KDF9.Q_register;
   306.                   set_offline : in Boolean);
   307.
   308.    procedure POL (the_buffer  : in out IOC.device;
   309.                   Q_operand   : in KDF9.Q_register;
   310.                   set_offline : in Boolean);
   311.
   312.
   313. --
   314. --
   315.    -- The buffer_configuration type enables the dynamic setting-up of a complement of I/O devices.
   316. --
   317. --
   318.
   319.    type device_class_access  is access all IOC.device'Class;
   320.
   321.    type buffer_configuration is array (KDF9.buffer_number) of IOC.device_class_access;
   322.
   323.    -- These are the I/O devices installed in this configuration.
   324.    -- Each device installs itself into the configuration when the device is initialized.
   325.
   326.    buffer : buffer_configuration;
   327.
   328. --
   329.    -- These operations are used by Directors to manage device allocation to problem programs.
   330. --
   331.
   332.    procedure set_state_of (the_buffer : in device_class_access;
   333.                            allocated  : in Boolean);
   334.
   335.    function is_allocated (the_buffer : device_class_access)  -- N.B. IS_allocated.
   336.    return Boolean;
   337.
   338.    function is_unallocated (the_buffer : device_class_access)  -- N.B. is_UNallocated.
   339.    return Boolean;
   340.
   341. --
   342.    -- These buffer-implementation operations are used outside IOC and apply to all device types.
   343. --
   344.
   345.    -- Complete all extant transfers, then Finalize each buffer.
   346.    procedure finalize_all_KDF9_buffers;
   347.
   348.    -- Advance the elapsed time to a point after all extant transfer have terminated.
   349.    procedure complete_all_extant_transfers;
   350.
   351.    -- Complete any terminated transfer operations and take any needed interrupts.
   352.    procedure act_on_pending_interrupts;
   353.
   354.    -- Handle non-data transfer operations on busy device.
   355.    procedure deal_with_a_busy_device (the_buffer  : in out IOC.device'Class;
   356.                                       order_time  : in KDF9.us;
   357.                                       set_offline : in Boolean);
   358.
   359.    -- A LOV interupt caused by an attempted store access must arrange
   360.    --    for the interrupted instruction to be resumed.
   361.    -- In boot mode, effect the LOV interrupt to Director.
   362.    -- In other modes, advance the elapsed time to the end-of-transfer time
   363.    --    for the_locked_out_address, then act on pending interrupts.
   364.    procedure handle_a_main_store_lockout;
   365.
   366.    type transfer_kind  is (input_operation,
   367.                            output_operation,
   368.                            control_operation,
   369.                            some_other_operation);
   370.
   371.    -- Take note of the start of a transfer.
   372.    -- For I/O operations that do not entail an actual data transfer,
   373.    --    such as testing a buffer for a graph plotter,
   374.    --    set the busy time to the order's MC execution time.
   375.    -- This keeps elapsed time in sync with CPU time,
   376.    --    and ensures that the operation waits for any preceding transfer
   377.    --    on the same buffer to complete before the test is actioned.
   378.    procedure start_data_transfer (the_buffer  : in out IOC.device'Class;
   379.                                   Q_operand   : in KDF9.Q_register;
   380.                                   set_offline : in Boolean;
   381.                                   busy_time   : in KDF9.us;
   382.                                   operation   : in IOC.transfer_kind := IOC.some_other_operation);
   383.
   384.    -- True iff the buffer is busy and the current operation is reading oe writing.
   385.    function is_DMAing (the_buffer  : in IOC.device'Class)
   386.    return Boolean;
   387.
   388.    -- Gives a short summary of the buffer state, showing some transfer parameters.
   389.    function image (the_buffer : in IOC.device'Class)
   390.    return String;
   391.
   392. private
   393.
   394.    -- The following packages are hereby made available to all children of IOC.
   395.
   396.    use exceptions;             pragma Warnings(Off, exceptions);
   397.    use formatting;             pragma Warnings(Off, formatting);
   398.    use host_IO;                pragma Warnings(Off, host_IO);
   399.    use KDF9_char_sets;         pragma Warnings(Off, KDF9_char_sets);
   400.    use KDF9.store;             pragma Warnings(Off, KDF9.store);
   401.    use settings;               pragma Warnings(Off, settings);
   402.    use POSIX;                  -- Used here, so no need to suppress warnings.
   403.
   404.    type device (
   405.                 number  : IOC.device_number;
   406.                 kind    : IOC.device_kind;
   407.                 unit    : IOC.unit_number;
   408.                 quantum : KDF9.us
   409.                )
   410.    is abstract new Limited_Controlled with
   411.                record
   412.                   is_abnormal,
   413.                   is_busy,
   414.                   is_offline,
   415.                   is_allocated,
   416.                   is_for_Director : Boolean := False;
   417.                   operation       : IOC.transfer_kind := IOC.some_other_operation;
   418.                   initiation_time : KDF9.us := KDF9.us'Last;
   419.                   transfer_time   : KDF9.us := KDF9.us'Last;
   420.                   completion_time : KDF9.us := KDF9.us'Last;
   421.                   priority_level  : KDF9.priority := 0;
   422.                   control_word    : KDF9.Q_register;
   423.                   decoded_order   : KDF9.decoded_order;
   424.                   device_name     : IOC.device_name := "AD0";
   425.                   order_address   : KDF9.syllable_address := (0, 0);
   426.                   order_count     : KDF9.order_counter;
   427.                   stream          : host_IO.stream;
   428.                end record;
   429.
   430.    overriding
   431.    procedure Initialize (the_buffer : in out IOC.device);
   432.
   433.    procedure open (the_buffer : in out IOC.device'Class;
   434.                    the_mode   : in POSIX.access_mode);
   435.
   436.    overriding
   437.    procedure Finalize (the_buffer : in out IOC.device);
   438.
   439.    -- Operations, used only within the IOC hierarchy, that apply to all device types.
   440.
   441.    -- Check that the buffer for the_device is unused, then set it to the_device.
   442.    procedure install (the_device : in out IOC.device'Class);
   443.
   444.    -- LIV if the_buffer is in the abnormal state.
   445.    procedure validate_parity (the_buffer : in IOC.device'Class);
   446.
   447.    -- Check that the_buffer is online, validly identified by the Q_operand,
   448.    --    and that access to it is permitted by the (perhaps simulated) Director;
   449.    --       LIV if not.
   450.    procedure validate_device (the_buffer : in IOC.device'Class;
   451.                               Q_operand  : in KDF9.Q_register);
   452.
   453.    -- Check that the device and the transfer address bounds are valid;
   454.    --    LIV if not.
   455.    procedure validate_transfer (the_buffer : in IOC.device'Class;
   456.                                 Q_operand  : in KDF9.Q_register);
   457.
   458.    -- When the real duration of a variable-length transfer is known,
   459.    --    its completion time can be made accurate by giving its actual_time.
   460.    -- correct_transfer_time must be called before finalize_transfer is called.
   461.    procedure correct_transfer_time (the_buffer  : in out IOC.device'Class;
   462.                                     actual_time : in KDF9.us);
   463.
   464.    procedure correct_transfer_time (the_buffer    : in out IOC.device'Class;
   465.                                     actual_length : in KDF9.word);
   466.
   467.    -- Account for the CPU (i.e., core store) time taken by the buffer's DMA cycles.
   468.    procedure add_in_the_IO_CPU_time (IO_CPU_time : in KDF9.us);
   469.
   470.    procedure add_in_the_IO_CPU_time (the_buffer  : in IOC.device'Class;
   471.                                      bytes_moved : in KDF9.word);
   472.
   473.    -- LIV if the repetition count is negative.
   474.    procedure require_nonnegative_count (count : in KDF9.Q_part);
   475.
   476.    -- LIV if the repetition count is negative or zero.
   477.    procedure require_positive_count (count : in KDF9.Q_part);
   478.
   479.    -- Account for the CPU time taken by the buffer in setting store lockouts.
   480.    procedure add_in_the_IO_lockout_CPU_time (Q_operand : in KDF9.Q_register);
   481.
   482.    -- These are handy, and also prevent a unreferenced warning for Ada.Characters.Latin_1.
   483.    LF : constant Character := Ada.Characters.Latin_1.LF;
   484.    SP : constant Character := Ada.Characters.Latin_1.Space;
   485.
   486. end IOC;

 1020 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-equipment.adb
Source file time stamp: 2021-02-08 01:03:22
Compiled at: 2021-02-08 17:20:56

     1. -- Data supporting the definition of a KDF9 I/O equipment configuration.
     2. --
     3. --
     4. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with IOC.absent;
    19. with IOC.fast.DR;
    20. with IOC.fast.FD;
    21. with IOC.fast.MT;
    22. with IOC.slow.shift.FW;
    23. with IOC.slow.shift.GP;
    24. with IOC.slow.shift.SI;
    25. with IOC.slow.shift.TP;
    26. with IOC.slow.shift.TR;
    27. with IOC.slow.unit.CP;
    28. with IOC.slow.unit.CR;
    29. with IOC.slow.unit.LP;
    30. with settings;
    31.
    32. package body IOC.equipment is
    33.
    34.    procedure configure is
    35.    begin
    36.       for b in KDF9.buffer_number loop
    37.          case equipment.choice(b) is
    38.             when AD => IOC.absent.enable(b);
    39.             when CP => IOC.slow.unit.CP.enable(b);
    40.             when CR => IOC.slow.unit.CR.enable(b);
    41.             when DR => IOC.fast.DR.enable(b);
    42.             when FD => IOC.fast.FD.enable(b);
    43.             when FW => IOC.slow.shift.FW.enable(b);
    44.             when GP => IOC.slow.shift.TP.remove_TP1(b);
    45.                        IOC.slow.shift.GP.enable(b);
    46.             when LP => IOC.slow.unit.LP.enable(b);
    47.             when MT => IOC.fast.MT.enable_MT_deck(b);
    48.             when SI => IOC.slow.shift.SI.enable(b);
    49.             when ST => IOC.fast.MT.enable_ST_deck(b);
    50.             when TP => IOC.slow.shift.TP.enable(b);
    51.             when TR => IOC.slow.shift.TR.enable(b);
    52.          end case;
    53.       end loop;
    54.       if IOC.buffer(0) = null              or else
    55.             IOC.buffer(0).kind /= IOC.FW_kind then
    56.          trap_operator_error("buffer #00 must be a FW");
    57.       end if;
    58.       if IOC.buffer(1) = null              or else
    59.             IOC.buffer(1).kind /= IOC.TR_kind then
    60.          trap_operator_error("buffer #01 must be a TR");
    61.       end if;
    62.       for b in IOC.equipment.setup'Range loop
    63.          if IOC.buffer(b) = null then
    64.             IOC.absent.enable(b);
    65.          end if;
    66.       end loop;
    67.    end configure;
    68.
    69.    procedure re_configure is
    70.    begin
    71.       for b in KDF9.buffer_number loop
    72.          case equipment.choice(b) is
    73.             when DR => IOC.fast.FD.disable(b);
    74.                        IOC.fast.DR.re_enable(b);
    75.             when FD => IOC.fast.DR.disable(b);
    76.                        IOC.fast.FD.re_enable(b);
    77.             when GP => IOC.slow.shift.TP.remove_TP1(b);
    78.                        IOC.slow.shift.GP.enable(b);
    79.             when SI => IOC.slow.shift.SI.re_enable(b);
    80.             when others => null;
    81.          end case;
    82.       end loop;
    83.    end re_configure;
    84.
    85. end IOC.equipment;

Compiling: ../Source/ioc-equipment.ads
Source file time stamp: 2021-02-08 00:40:11
Compiled at: 2021-02-08 17:20:56

     1. -- Enable the devices included in the chosen KDF9 I/O configuration.
     2. --
     3. --
     4. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with KDF9;
    19.
    20. package IOC.equipment is
    21.
    22.    -- These variables are used in the emulation of OUT 5.
    23.    -- They are set to the device buffer number at the start of each run by configure.
    24.    -- A value of 0 indicates that the device is not included in the configuration for the run.
    25.    -- Fast devices are not allocated by this mechanism and so do not appear here.
    26.
    27.    CP0_number  : KDF9.buffer_number := 0;
    28.    CP1_number  : KDF9.buffer_number := 0;
    29.    CR0_number  : KDF9.buffer_number := 0;
    30.    CR1_number  : KDF9.buffer_number := 0;
    31.    GP0_number  : KDF9.buffer_number := 0;
    32.    LP0_number  : KDF9.buffer_number := 0;
    33.    LP1_number  : KDF9.buffer_number := 0;
    34.    SI0_number  : KDF9.buffer_number := 0;
    35.    SI1_number  : KDF9.buffer_number := 0;
    36.    TP0_number  : KDF9.buffer_number := 0;
    37.    TP1_number  : KDF9.buffer_number := 0;
    38.    TR0_number  : KDF9.buffer_number := 0;
    39.    TR1_number  : KDF9.buffer_number := 0;
    40.
    41.    type kind   is (AD, CP, CR, DR, FD, FW, GP, LP, MT, SI, ST, TP, TR);
    42.
    43.    type setup  is array (KDF9.buffer_number) of equipment.kind;
    44.
    45.    -- These are the buffer numbers for the devices in the default configuration.
    46.    -- The Fixed Disc drive was on buffer 14 (#16) of Eldon 2 KDF9s, so I adopt that here.
    47.
    48.    FW0_default : constant KDF9.buffer_number := 0;
    49.    TR0_default : constant KDF9.buffer_number := 1;
    50.    TR1_default : constant KDF9.buffer_number := 2;
    51.    TP0_default : constant KDF9.buffer_number := 3;
    52.    TP1_default : constant KDF9.buffer_number := 4;
    53.    LP0_default : constant KDF9.buffer_number := 5;
    54.    CR0_default : constant KDF9.buffer_number := 6;
    55.    CP0_default : constant KDF9.buffer_number := 7;
    56.    MT0_default : constant KDF9.buffer_number := 8;
    57.    MT1_default : constant KDF9.buffer_number := 9;
    58.    MT2_default : constant KDF9.buffer_number := 10;
    59.    MT3_default : constant KDF9.buffer_number := 11;
    60.    MT4_default : constant KDF9.buffer_number := 12;
    61.    MT5_default : constant KDF9.buffer_number := 13;
    62.    DR0_default : constant KDF9.buffer_number := 14;
    63.    FD0_default : constant KDF9.buffer_number := 14;
    64.    ST0_default : constant KDF9.buffer_number := 15;
    65.
    66.    default : constant equipment.setup
    67.            := (
    68.                CP0_default => CP,
    69.                CR0_default => CR,
    70.                FD0_default => FD,
    71.                FW0_default => FW,
    72.                LP0_default => LP,
    73.                MT0_default => MT,
    74.                MT1_default => MT,
    75.                MT2_default => MT,
    76.                MT3_default => MT,
    77.                MT4_default => MT,
    78.                MT5_default => MT,
    79.                ST0_default => ST,
    80.                TP0_default => TP,
    81.                TP1_default => TP,
    82.                TR0_default => TR,
    83.                TR1_default => TR
    84.               );
    85.
    86.    choice  : equipment.setup := default;
    87.
    88.    -- Attach the chosen devices to their buffers.
    89.    procedure configure;
    90.
    91.    -- If a drum, disc or BSI has been enabled on the command line, make sure it is installed.
    92.    procedure re_configure;
    93.
    94. end IOC.equipment;

 85 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow.adb
Source file time stamp: 2021-02-08 12:53:52
Compiled at: 2021-02-08 17:20:57

     1. -- Emulation of the common functionality of a KDF9 "slow", byte-by-byte, devices.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with HCI;
    18. with OS_specifics;
    19. with environmental_value_of;
    20.
    21. use HCI;
    22.
    23. package body IOC.slow is
    24.
    25.    procedure display_device_usage (the_buffer  : in slow.device;
    26.                                    the_action  : in String;
    27.                                    the_amount  : in KDF9.word;
    28.                                    the_quantum : in String) is
    29.    begin
    30.          if the_final_state_is_wanted and then
    31.                the_log_is_wanted      and then
    32.                   the_buffer.is_open  and then
    33.                the_amount /= 0            then
    34.          if (the_buffer.number = 0) and not (API_logging_is_wanted or the_log_is_wanted) then
    35.             -- Take a new line at the head of the list, for low-visibility modes.
    36.             log_new_line;
    37.          end if;
    38.          log_line(
    39.                   the_buffer.device_name
    40.                 & " on buffer #"
    41.                 & oct_of(KDF9.Q_part(the_buffer.number), 2)
    42.                 & " "
    43.                 & the_action
    44.                 & the_amount'Image
    45.                 & " "
    46.                 & the_quantum
    47.                 & "."
    48.                  );
    49.       end if;
    50.    end display_device_usage;
    51.
    52.    procedure close (the_buffer  : in out slow.device;
    53.                     the_action  : in String;
    54.                     the_amount  : in KDF9.word;
    55.                     the_quantum : in String) is
    56.    begin
    57.       display_device_usage (the_buffer, the_action, the_amount, the_quantum);
    58.       IOC.device(the_buffer).close;
    59.    end close;
    60.
    61.    function atomic_item_count (the_buffer : slow.device;
    62.                                Q_operand  : KDF9.Q_register)
    63.    return KDF9.word is
    64.       words : constant KDF9.Q_part := Q_operand.M - Q_operand.I + 1;
    65.    begin
    66.       if the_buffer.is_open then
    67.          return KDF9.word(words) * 8;
    68.       else
    69.          return 0;
    70.       end if;
    71.    end atomic_item_count;
    72.
    73.    procedure reattach (the_buffer   : in out slow.device;
    74.                        the_file     : in String) is
    75.    begin
    76.       reattach(the_buffer.stream, the_file, read_mode);
    77.    end reattach;
    78.
    79.    procedure deal_with_end_of_data (the_buffer : in out slow.device) is
    80.       BEL      : constant String := (1 => Character'Val(7));   -- Audible prompt
    81.       response : response_kind;
    82.
    83.       procedure reattach_the_text_file (name : in String) is
    84.       begin
    85.          if name = "" then
    86.             the_buffer.is_abnormal := True;
    87.             raise end_of_stream;
    88.          elsif exists(name) then
    89.             reattach(the_buffer, name);
    90.             return;
    91.          elsif exists(name & ".txt") then
    92.             reattach(the_buffer, name & ".txt");
    93.             return;
    94.          else
    95.             raise operator_error;
    96.          end if;
    97.       end reattach_the_text_file;
    98.
    99.    begin
   100.       output_line(BEL & "");
   101.       output_line("ee9: End of given data for " & the_buffer.device_name & ".");
   102.       loop
   103.          POSIX.data_prompt(
   104.                            noninteractive_usage_is_enabled,
   105.                            "Type @ or / to name a file, = to type the data, ENTER key for EOF, Q or q to quit",
   106.                            response
   107.                           );
   108.          if response = wrong_response then
   109.             null;  -- repeat the prompt
   110.          elsif response = quit_response then
   111.             trap_failing_IO_operation(the_buffer, "quit requested by the user");
   112.          elsif response = EOF_response then
   113.             the_buffer.is_abnormal := True;
   114.             raise end_of_stream;
   115.          elsif response = here_response then
   116.             reattach(the_buffer, OS_specifics.UI_in_name);
   117.             return;
   118.          elsif response = at_response then
   119.             declare
   120.                here : constant String := environmental_value_of("KDF9_DATA", default => "Data") & "/";
   121.                next : constant String := next_file_name(BEL & "Give the name of a file in " & here);
   122.             begin
   123.                reattach_the_text_file(here & next);
   124.                return;
   125.             exception
   126.                when operator_error =>
   127.                   output_line(BEL & "ee9: The file '" & here & next & "' could not be found");
   128.             end;
   129.          elsif response = name_response then
   130.             declare
   131.                next : constant String := next_file_name(BEL & "Give the pathname of the file");
   132.             begin
   133.                reattach_the_text_file(next);
   134.                return;
   135.             exception
   136.                when operator_error =>
   137.                   output_line(BEL & "ee9: The file '" & next & "' could not be found");
   138.             end;
   139.          end if;
   140.       end loop;
   141.    end deal_with_end_of_data;
   142.
   143.    procedure start_slow_transfer (the_buffer   : in out slow.device;
   144.                                   Q_operand    : in KDF9.Q_register;
   145.                                   set_offline  : in Boolean;
   146.                                   operation    : in IOC.transfer_kind := some_other_operation) is
   147.       atomic_items : constant KDF9.word := atomic_item_count(the_buffer, Q_operand);
   148.       time_needed  : constant KDF9.us := IO_elapsed_time(the_buffer, atomic_items);
   149.    begin
   150.       start_data_transfer(the_buffer, Q_operand, set_offline,
   151.                           busy_time => time_needed,
   152.                           operation => start_slow_transfer.operation);
   153.    end start_slow_transfer;
   154.
   155.    procedure get_byte_from_stream (byte       : out Character;
   156.                                    the_buffer : in out slow.device) is
   157.    begin
   158.       loop
   159.          begin
   160.             get_byte(byte, the_buffer.stream);
   161.             return;
   162.          exception
   163.             when end_of_stream =>
   164.                deal_with_end_of_data(the_buffer);
   165.          end;
   166.       end loop;
   167.    end get_byte_from_stream;
   168.
   169.    procedure get_char_from_stream (char       : out Character;
   170.                                    the_buffer : in out slow.device) is
   171.    begin
   172.       loop
   173.          begin
   174.             get_char(char, the_buffer.stream);
   175.             return;
   176.          exception
   177.             when end_of_stream =>
   178.                deal_with_end_of_data(the_buffer);
   179.          end;
   180.       end loop;
   181.    end get_char_from_stream;
   182.
   183. end IOC.slow;

Compiling: ../Source/ioc-slow.ads
Source file time stamp: 2021-01-10 23:52:38
Compiled at: 2021-02-08 17:20:57

     1. -- Emulation of the common functionality of a KDF9 "slow", i.e. byte-by-byte, devices.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow is
    18.
    19.    --
    20.    -- This is the root type for all slow I/O device types.
    21.    --
    22.
    23.    type device is abstract new IOC.device with private;
    24.
    25.    -- Log the usage statistics for the device on the buffer.
    26.    procedure display_device_usage (the_buffer  : in slow.device;
    27.                                    the_action  : in String;
    28.                                    the_amount  : in KDF9.word;
    29.                                    the_quantum : in String);
    30.
    31.    -- Change the file associated with a device.
    32.    procedure reattach (the_buffer : in out slow.device;
    33.                        the_file   : in String);
    34.
    35. private
    36.
    37.    type device is abstract new IOC.device with
    38.       record
    39.          is_transcribing : Boolean := True;
    40.          byte_count      : KDF9.word := 0;
    41.       end record;
    42.
    43.    -- Optionally log an activity message for the device; close its I/O stream.
    44.    procedure close (the_buffer  : in out slow.device;
    45.                     the_action  : in String;
    46.                     the_amount  : in KDF9.word;
    47.                     the_quantum : in String);
    48.
    49.    -- The number of timed transfer units in the designated core-store area.
    50.    -- In the case of unit-record devices, such as card readers and line printers,
    51.    --    this is the number of unit records (cards, or lines, respectively).
    52.    -- In all other cases it is the number of characters in the designated core-store area.
    53.    function atomic_item_count (the_buffer : slow.device;
    54.                                Q_operand  : KDF9.Q_register)
    55.    return KDF9.word;
    56.
    57.    -- Check the IO parameters and the buffer state, and handle any old lockout.
    58.    -- Set the new buffer state, and project the next interrupt time.
    59.    procedure start_slow_transfer (the_buffer   : in out slow.device;
    60.                                   Q_operand    : in KDF9.Q_register;
    61.                                   set_offline  : in Boolean;
    62.                                   operation    : in IOC.transfer_kind := some_other_operation);
    63.
    64.    -- Read a character from the stream and deal with any input file concatenation.
    65.    procedure get_char_from_stream (char       : out Character;
    66.                                    the_buffer : in out slow.device);
    67.
    68.    -- Read a raw byte from the stream and deal with any input file concatenation.
    69.    procedure get_byte_from_stream (byte       : out Character;
    70.                                    the_buffer : in out slow.device);
    71.
    72. end IOC.slow;

 183 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift.adb
Source file time stamp: 2021-01-10 23:52:37
Compiled at: 2021-02-08 17:20:57

     1. -- Emulation of the common functionality of a 2-case (Normal/Shift) buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.shift is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_device : in out shift.device) is
    23.    begin
    24.       -- Open the associated file.
    25.       open(the_device, read_mode);
    26.    end Initialize;
    27.
    28.    procedure do_input_housekeeping (the_device : in out shift.device;
    29.                                     read_in,
    30.                                     stored     : in KDF9.word) is
    31.    begin
    32.       add_in_the_IO_CPU_time(the_device, stored);
    33.       correct_transfer_time(the_device, read_in);
    34.       the_device.byte_count := the_device.byte_count + read_in;
    35.    end do_input_housekeeping;
    36.
    37.    procedure get_symbols (the_device    : in out shift.device;
    38.                           Q_operand     : in KDF9.Q_register;
    39.                           reading_to_EM : in Boolean) is
    40.       start_address : constant KDF9.address := Q_operand.I;
    41.       end_address   : constant KDF9.address := Q_operand.M;
    42.       fill   : KDF9.word := 0;
    43.       size   : KDF9.word := 0;
    44.       symbol : KDF9_char_sets.symbol;
    45.       char   : Character;
    46.    begin
    47.       check_addresses_and_lockouts(start_address, end_address);
    48.    word_loop:
    49.       for w in start_address .. end_address loop
    50.          store_word(0, w);
    51.          for c in KDF9_char_sets.symbol_index'Range loop
    52.             get_char_from_stream(char, the_device);
    53.             size := size + 1;
    54.             if char = KDF9_char_sets.W_F then
    55.                -- Filler was suppressed on normal input from the slow devices.
    56.                fill := fill + 1;
    57.             elsif case_of(char) /= both                   and then
    58.                      case_of(char) /= the_device.current_case then
    59.                store_symbol(CN_TR(next_case(the_device.current_case)), w, c);
    60.                the_device.current_case := the_device.current_case xor 1;
    61.                back_off(the_device.stream);
    62.             else
    63.                symbol := CN_TR(char) or CS_TR(char);
    64.                store_symbol(symbol, w, c);
    65.                if reading_to_EM and symbol = KDF9_char_sets.End_Message then
    66.                   for d in 1 .. 7-c loop
    67.                      store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
    68.                   end loop;
    69.                   exit word_loop;
    70.                end if;
    71.             end if;
    72.          end loop;
    73.       end loop word_loop;
    74.       do_input_housekeeping(the_device, read_in => size, stored => size-fill);
    75.    exception
    76.       when end_of_stream =>
    77.          flush(the_device.stream);
    78.          do_input_housekeeping(the_device, read_in => size, stored => size-fill);
    79.    end get_symbols;
    80.
    81.    procedure read (the_device : in out shift.device;
    82.                    Q_operand  : in KDF9.Q_register) is
    83.    begin
    84.       get_symbols(the_device, Q_operand, reading_to_EM => False);
    85.    end read;
    86.
    87.    procedure read_to_EM (the_device : in out shift.device;
    88.                          Q_operand  : in KDF9.Q_register) is
    89.    begin
    90.       get_symbols(the_device, Q_operand, reading_to_EM => True);
    91.    end read_to_EM;
    92.
    93.    procedure get_words (the_device    : in out shift.device;
    94.                         Q_operand     : in KDF9.Q_register;
    95.                         reading_to_EM : in Boolean) is
    96.       start_address : constant KDF9.address := Q_operand.I;
    97.       end_address   : constant KDF9.address := Q_operand.M;
    98.       size : KDF9.word := 0;
    99.       word : KDF9.word;
   100.       char : Character;
   101.    begin
   102.       check_addresses_and_lockouts(start_address, end_address);
   103.       for w in start_address .. end_address loop
   104.          get_char_from_stream(char, the_device);
   105.          word := KDF9.word(Character'Pos(char));
   106.          size := size + 1;
   107.          store_word(word, w);
   108.       exit when reading_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   109.       end loop;
   110.       do_input_housekeeping(the_device, read_in => size, stored => size);
   111.    exception
   112.       when end_of_stream =>
   113.          flush(the_device.stream);
   114.          do_input_housekeeping(the_device, read_in => size, stored => size);
   115.    end get_words;
   116.
   117.    procedure words_read (the_device : in out shift.device;
   118.                          Q_operand  : in KDF9.Q_register) is
   119.    begin
   120.       get_words(the_device, Q_operand, reading_to_EM => False);
   121.    end words_read;
   122.
   123.    procedure words_read_to_EM (the_device : in out shift.device;
   124.                                Q_operand  : in KDF9.Q_register) is
   125.    begin
   126.       get_words(the_device, Q_operand, reading_to_EM => True);
   127.    end words_read_to_EM;
   128.
   129.    procedure put_symbols (the_device    : in out shift.device;
   130.                           Q_operand     : in KDF9.Q_register;
   131.                           writing_to_EM : in Boolean) is
   132.       start_address : constant KDF9.address := Q_operand.I;
   133.       end_address   : constant KDF9.address := Q_operand.M;
   134.       fill   : KDF9.word := 0;
   135.       size   : KDF9.word := 0;
   136.       symbol : KDF9_char_sets.symbol;
   137.       char   : Character;
   138.    begin
   139.       check_addresses_and_lockouts(start_address, end_address);
   140.    word_loop:
   141.       for w in start_address .. end_address loop
   142.          for c in KDF9_char_sets.symbol_index'Range loop
   143.             symbol := fetch_symbol(w, c);
   144.             size := size + 1;
   145.             if symbol = KDF9_char_sets.Word_Filler then
   146.                -- Filler was suppressed on normal output to the slow devices.
   147.                fill := fill + 1;
   148.             elsif symbol = KDF9_char_sets.Case_Shift then
   149.                the_device.current_case := KDF9_char_sets.Case_Shift;
   150.             elsif  symbol = KDF9_char_sets.Case_Normal then
   151.                the_device.current_case := KDF9_char_sets.Case_Normal;
   152.             else
   153.                if the_device.current_case = KDF9_char_sets.Case_Normal then
   154.                   char := TP_CN(symbol);
   155.                else
   156.                   char := TP_CS(symbol);
   157.                end if;
   158.                put_char(char, the_device.stream);
   159.                exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
   160.             end if;
   161.          end loop;
   162.       end loop word_loop;
   163.       do_output_housekeeping(the_device, written => size-fill, fetched => size);
   164.    exception
   165.       when end_of_stream =>
   166.          do_output_housekeeping(the_device, written => size-fill, fetched => size);
   167.    end put_symbols;
   168.
   169.    procedure write (the_device : in out shift.device;
   170.                     Q_operand  : in KDF9.Q_register) is
   171.    begin
   172.       put_symbols(the_device, Q_operand, writing_to_EM => False);
   173.    end write;
   174.
   175.    procedure write_to_EM (the_device : in out shift.device;
   176.                           Q_operand  : in KDF9.Q_register) is
   177.    begin
   178.       put_symbols(the_device, Q_operand, writing_to_EM => True);
   179.    end write_to_EM;
   180.
   181.    procedure put_words (the_device    : in out shift.device;
   182.                         Q_operand     : in KDF9.Q_register;
   183.                         writing_to_EM : in Boolean) is
   184.       start_address : constant KDF9.address := Q_operand.I;
   185.       end_address   : constant KDF9.address := Q_operand.M;
   186.       size : KDF9.word := 0;
   187.       word : KDF9.word;
   188.       char : Character;
   189.    begin
   190.       check_addresses_and_lockouts(start_address, end_address);
   191.       for w in start_address .. end_address loop
   192.          word := fetch_word(w) and 8#377#;
   193.          char := Character'Val(word);
   194.          put_byte(char, the_device.stream);
   195.          size := size + 1;
   196.       exit when writing_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   197.       end loop;
   198.       do_output_housekeeping(the_device, written => size, fetched => size);
   199.    exception
   200.       when end_of_stream =>
   201.          do_output_housekeeping(the_device, written => size, fetched => size);
   202.    end put_words;
   203.
   204.    procedure words_write (the_device : in out shift.device;
   205.                           Q_operand  : in KDF9.Q_register) is
   206.    begin
   207.       put_words(the_device, Q_operand, writing_to_EM => False);
   208.    end words_write;
   209.
   210.    procedure words_write_to_EM (the_device : in out shift.device;
   211.                                 Q_operand  : in KDF9.Q_register) is
   212.    begin
   213.       put_words(the_device, Q_operand, writing_to_EM => True);
   214.    end words_write_to_EM;
   215.
   216.    procedure output_a_gap (the_device   : in out shift.device;
   217.                            Q_operand    : in KDF9.Q_register;
   218.                            set_offline  : in Boolean;
   219.                            word_mode    : in Boolean := False;
   220.                            text_mode    : in Boolean := False) is
   221.       length : constant KDF9.word :=  KDF9.word(Q_operand.M) * (if word_mode then 8 else 1);
   222.       char   : constant Character := Character'Val(0);
   223.       size   : KDF9.word := 0;
   224.    begin
   225.       require_positive_count(Q_operand.M);
   226.       for i in 1 .. length loop
   227.          size := size + 1;
   228.          if text_mode then
   229.             do_not_put_byte(char, the_device.stream);
   230.          else
   231.             put_byte(char, the_device.stream);
   232.          end if;
   233.       end loop;
   234.       start_data_transfer(
   235.                           the_device,
   236.                           (Q_operand.C, 0, Q_operand.M),
   237.                           set_offline,
   238.                           busy_time => IO_elapsed_time(the_device, length)
   239.                          );
   240.       do_output_housekeeping(the_device, written => length, fetched => 0);
   241.    exception
   242.       when end_of_stream =>
   243.          do_output_housekeeping(the_device, written => size, fetched => 0);
   244.    end output_a_gap;
   245.
   246.    procedure do_output_housekeeping (the_device : in out shift.device;
   247.                                      written,
   248.                                      fetched    : in KDF9.word) is
   249.    begin
   250.       flush(the_device.stream);
   251.       add_in_the_IO_CPU_time(the_device, fetched);
   252.       correct_transfer_time(the_device, written);
   253.       the_device.byte_count := the_device.byte_count + fetched;
   254.    end do_output_housekeeping;
   255.
   256.    procedure set_case (the_device  : in out shift.device;
   257.                        the_setting : in KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal) is
   258.    begin
   259.       the_device.current_case := the_setting;
   260.    end set_case;
   261.
   262.    function uses_Latin_1 (the_device : in shift.device)
   263.    return Boolean
   264.    is (the_device.is_transcribing);
   265.
   266.    overriding
   267.    procedure Finalize (the_device : in out shift.device) is
   268.    begin
   269.       close(the_device, "transferred", the_device.byte_count, "character(s)");
   270.    end Finalize;
   271.
   272. end IOC.slow.shift;

Compiling: ../Source/ioc-slow-shift.ads
Source file time stamp: 2021-01-10 23:52:37
Compiled at: 2021-02-08 17:20:57

     1. -- Emulation of the common functionality of a 2-case (Normal/Shift) buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18.
    19. package IOC.slow.shift is
    20.
    21.    --
    22.    -- Abstract common functionality of Case Normal / Case Shift devices, e.g.,
    23.    --    the paper tape reader (TR), punch (TP) and console Flexowriter (FW).
    24.    --
    25.
    26.    type device is abstract new IOC.slow.device with private;
    27.
    28.    procedure set_case (the_device  : in out shift.device;
    29.                        the_setting : in KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal);
    30.
    31.    function uses_Latin_1 (the_device : in shift.device)
    32.    return Boolean;
    33.
    34. private
    35.
    36.    type device is abstract new IOC.slow.device with
    37.       record
    38.          current_case : KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal;
    39.       end record;
    40.
    41.    overriding
    42.    procedure Finalize (the_device : in out shift.device);
    43.
    44.    overriding
    45.    procedure Initialize (the_device : in out shift.device);
    46.
    47.    procedure do_input_housekeeping (the_device : in out shift.device;
    48.                                     read_in,
    49.                                     stored     : in KDF9.word);
    50.
    51.    procedure do_output_housekeeping (the_device : in out shift.device;
    52.                                      written,
    53.                                      fetched    : in KDF9.word);
    54.
    55.     procedure write (the_device : in out shift.device;
    56.                      Q_operand  : in KDF9.Q_register);
    57.
    58.     procedure read (the_device : in out shift.device;
    59.                     Q_operand  : in KDF9.Q_register);
    60.
    61.     procedure write_to_EM (the_device : in out shift.device;
    62.                            Q_operand  : in KDF9.Q_register);
    63.
    64.     procedure read_to_EM (the_device : in out shift.device;
    65.                           Q_operand  : in KDF9.Q_register);
    66.
    67.     procedure words_write (the_device : in out shift.device;
    68.                            Q_operand  : in KDF9.Q_register);
    69.
    70.     procedure words_read (the_device : in out shift.device;
    71.                           Q_operand  : in KDF9.Q_register);
    72.
    73.     procedure words_write_to_EM (the_device : in out shift.device;
    74.                                  Q_operand  : in KDF9.Q_register);
    75.
    76.     procedure words_read_to_EM (the_device : in out shift.device;
    77.                                 Q_operand  : in KDF9.Q_register);
    78.
    79.    procedure output_a_gap (the_device   : in out shift.device;
    80.                            Q_operand    : in KDF9.Q_register;
    81.                            set_offline  : in Boolean;
    82.                            word_mode    : in Boolean := False;
    83.                            text_mode    : in Boolean := False);
    84.
    85. end IOC.slow.shift;

 272 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-tp.adb
Source file time stamp: 2021-02-08 01:09:28
Compiled at: 2021-02-08 17:20:57

     1. -- Emulation of a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.equipment;
    18. with tracing;
    19.
    20. use  IOC.equipment;
    21. use  tracing;
    22.
    23. package body IOC.slow.shift.TP is
    24.
    25.    use KDF9_char_sets;
    26.
    27.    overriding
    28.    procedure Initialize (the_TP : in out TP.device) is
    29.    begin
    30.       open(the_TP, write_mode);
    31.    end Initialize;
    32.
    33.    -- the_T_bit_is_set := (the buffer has been switched from a tape punch to a graph plotter)
    34.    overriding
    35.    procedure PMB (the_TP      : in out TP.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean) is
    38.    begin
    39.       validate_device(the_TP, Q_operand);
    40.       validate_parity(the_TP);
    41.       deal_with_a_busy_device(the_TP, 13, set_offline);
    42.       the_T_bit_is_set := False;  -- We never get here if GP0 is enabled.
    43.       take_note_of_test(the_TP.device_name, Q_operand, the_T_bit_is_set);
    44.    end PMB;
    45.
    46. --
    47. --
    48.    --
    49.    -- See Manual, §17.4 for paper tape 8-bit frame format.
    50.    --
    51. --
    52. --
    53.
    54.    procedure write_KDF9_tape_code (the_TP        : in out TP.device;
    55.                                    Q_operand     : in KDF9.Q_register;
    56.                                    writing_to_EM : in Boolean := False) is
    57.
    58.       function framed (symbol : KDF9_char_sets.symbol)
    59.       return Natural is
    60.
    61.          SP : constant := 8#000#;
    62.
    63.          function channel_8
    64.          return KDF9.syllable
    65.          is (if symbol = SP then 2#10_000_000# else 0);
    66.
    67.          function parity
    68.          return KDF9.syllable is
    69.             frame  : KDF9.syllable := KDF9.syllable(KDF9_char_sets.symbol'Pos(symbol)) or channel_8;
    70.             parity : KDF9.syllable := 0;
    71.          begin -- parity
    72.             while frame /= 0 loop
    73.                parity := parity xor (frame and 1);
    74.                frame  := frame / 2;
    75.             end loop;
    76.             return (if parity = 0 then 0 else 2#00_010_000#);
    77.          end parity;
    78.
    79.          low_4_bits : constant KDF9.syllable := KDF9.syllable(symbol)   and 2#00_001_111#;
    80.          bits_5and6 : constant KDF9.syllable := KDF9.syllable(symbol)*2 and 2#01_100_000#;
    81.
    82.       begin -- framed
    83.          return KDF9.syllable'Pos(channel_8 or bits_5and6 or parity or low_4_bits);
    84.       end framed;
    85.
    86.       start_address : constant KDF9.address := Q_operand.I;
    87.       end_address   : constant KDF9.address := Q_operand.M;
    88.       size   : KDF9.word := 0;
    89.       symbol : KDF9_char_sets.symbol;
    90.       char   : Character;
    91.
    92.    begin -- write_KDF9_tape_code
    93.       check_addresses_and_lockouts(start_address, end_address);
    94.    word_loop:
    95.       for w in start_address .. end_address loop
    96.          for c in KDF9_char_sets.symbol_index'Range loop
    97.             symbol := fetch_symbol(w, c);
    98.             size := size + 1;
    99.             char := Character'Val(framed(symbol));
   100.             put_byte(char, the_TP.stream);
   101.          exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
   102.          end loop;
   103.       end loop word_loop;
   104.       do_output_housekeeping(the_TP, written => size, fetched => size);
   105.    exception
   106.       when end_of_stream =>
   107.          do_output_housekeeping(the_TP, written => size, fetched => size);
   108.    end write_KDF9_tape_code;
   109.
   110.    -- PWQq
   111.    overriding
   112.    procedure POA (the_TP      : in out TP.device;
   113.                   Q_operand   : in KDF9.Q_register;
   114.                   set_offline : in Boolean) is
   115.    begin
   116.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   117.       if the_TP.is_transcribing then
   118.          write(the_TP, Q_operand);
   119.       else
   120.          write_KDF9_tape_code(the_TP, Q_operand);
   121.       end if;
   122.       lock_out_relative_addresses(Q_operand);
   123.    end POA;
   124.
   125.    -- PWEQq
   126.    overriding
   127.    procedure POB (the_TP      : in out TP.device;
   128.                   Q_operand   : in KDF9.Q_register;
   129.                   set_offline : in Boolean) is
   130.    begin
   131.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   132.       if the_TP.is_transcribing then
   133.          write_to_EM(the_TP, Q_operand);
   134.       else
   135.          write_KDF9_tape_code(the_TP, Q_operand, writing_to_EM => True);
   136.       end if;
   137.       lock_out_relative_addresses(Q_operand);
   138.    end POB;
   139.
   140.    -- PWCQq
   141.    overriding
   142.    procedure POC (the_TP      : in out TP.device;
   143.                   Q_operand   : in KDF9.Q_register;
   144.                   set_offline : in Boolean) is
   145.    begin
   146.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   147.       words_write(the_TP, Q_operand);
   148.       lock_out_relative_addresses(Q_operand);
   149.    end POC;
   150.
   151.    -- PWCEQq
   152.    overriding
   153.    procedure POD (the_TP      : in out TP.device;
   154.                   Q_operand   : in KDF9.Q_register;
   155.                   set_offline : in Boolean) is
   156.    begin
   157.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   158.       words_write_to_EM(the_TP, Q_operand);
   159.       lock_out_relative_addresses(Q_operand);
   160.    end POD;
   161.
   162.    -- PGAPQq
   163.    overriding
   164.    procedure POE (the_TP      : in out TP.device;
   165.                   Q_operand   : in KDF9.Q_register;
   166.                   set_offline : in Boolean) is
   167.    begin
   168.       require_nonnegative_count(Q_operand.M);
   169.       output_a_gap(
   170.                    the_TP,
   171.                    Q_operand,
   172.                    set_offline,
   173.                    word_mode => False,
   174.                    text_mode => the_TP.is_transcribing
   175.                   );
   176.    end POE;
   177.
   178.    -- "word gap"
   179.    overriding
   180.    procedure POF (the_TP      : in out TP.device;
   181.                   Q_operand   : in KDF9.Q_register;
   182.                   set_offline : in Boolean) is
   183.    begin
   184.       require_nonnegative_count(Q_operand.M);
   185.       output_a_gap(
   186.                    the_TP,
   187.                    Q_operand,
   188.                    set_offline,
   189.                    word_mode => True,
   190.                    text_mode => the_TP.is_transcribing
   191.                   );
   192.    end POF;
   193.
   194.    overriding
   195.    procedure Finalize (the_TP : in out TP.device) is
   196.    begin
   197.       close(
   198.             the_TP,
   199.             "punched",
   200.             the_TP.byte_count,
   201.             "character" & plurality(the_TP.byte_count)
   202.           & " in "
   203.           & (if the_TP.is_transcribing then "Latin-1" else "KDF9")
   204.           & " code"
   205.            );
   206.    end Finalize;
   207.
   208.    TP_quantum : constant := 1E6 / 110;  -- 110 characters per second.
   209.
   210.    type TP_access is access TP.device;
   211.
   212.    TP0  : TP_access with Warnings => Off;
   213.    TP1  : TP_access with Warnings => Off;
   214.
   215.    unit : IOC.unit_number := 0;
   216.
   217.    procedure enable (b : in KDF9.buffer_number) is
   218.    begin
   219.       case unit is
   220.          when 0 =>
   221.             TP0 := new TP.device (number  => b,
   222.                                   kind    => TP_kind,
   223.                                   unit    => 0,
   224.                                   quantum => TP_quantum);
   225.             TP0_number := b;
   226.          when 1 =>
   227.             TP1 := new TP.device (number  => b,
   228.                                   kind    => TP_kind,
   229.                                   unit    => 1,
   230.                                   quantum => TP_quantum);
   231.             TP1_number := b;
   232.          when others =>
   233.             trap_operator_error("more than two TP units have been configured");
   234.       end case;
   235.       unit := unit + 1;
   236.    end enable;
   237.
   238.    procedure remove_TP1 (b : in KDF9.buffer_number) is
   239.    begin
   240.       if TP1 /= null then
   241.          if TP1.number = b then
   242.             Finalize(TP1.all);
   243.             TP1 := null;
   244.          else
   245.             trap_operator_error("TP1 is not on buffer #" & oct_of(b));
   246.          end if;
   247.       end if;
   248.    end remove_TP1;
   249.
   250.    -- Set the character code to be used by the designated TP.
   251.    procedure set_unit_code (unit : in Natural; is_transcribing : in Boolean) is
   252.    begin
   253.       if unit = 0 and then TP0 /= null then
   254.          TP0.is_transcribing := set_unit_code.is_transcribing;
   255.       elsif unit = 1 and then TP1 /= null then
   256.          TP1.is_transcribing := set_unit_code.is_transcribing;
   257.       end if;
   258.    end set_unit_code;
   259.
   260. end IOC.slow.shift.TP;

Compiling: ../Source/ioc-slow-shift-tp.ads
Source file time stamp: 2021-02-08 01:03:42
Compiled at: 2021-02-08 17:20:57

     1. -- Emulation of a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.TP is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    -- PWQq
    22.    overriding
    23.    procedure POA (the_TP      : in out TP.device;
    24.                   Q_operand   : in KDF9.Q_register;
    25.                   set_offline : in Boolean);
    26.
    27.    -- PWEQq
    28.    overriding
    29.    procedure POB (the_TP      : in out TP.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    -- PWCQq
    34.    overriding
    35.    procedure POC (the_TP      : in out TP.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    -- PWCEQq
    40.    overriding
    41.    procedure POD (the_TP      : in out TP.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    -- PGAPQq
    46.    overriding
    47.    procedure POE (the_TP      : in out TP.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- This is called "word gap" in the Manual, but never defined.
    52.    overriding
    53.    procedure POF (the_TP      : in out TP.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- the_T_bit_is_set (the buffer has been switched from a tape punch to a graph plotter)
    58.    overriding
    59.    procedure PMB (the_TP      : in out TP.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    procedure enable (b : in KDF9.buffer_number);
    64.
    65.    -- Finalize TP1 if necessary and remove it from the configuration, to allow GP0 to be attached.
    66.    procedure remove_TP1 (b : in KDF9.buffer_number);
    67.
    68.    -- Set the character code to be used by the TP unit.
    69.    procedure set_unit_code(unit : in Natural; is_transcribing : in Boolean);
    70.
    71. private
    72.
    73.    type device is new IOC.slow.shift.device with null record;
    74.
    75.    overriding
    76.    procedure Initialize (the_TP : in out TP.device);
    77.
    78.    overriding
    79.    procedure Finalize (the_TP : in out TP.device);
    80.
    81. end IOC.slow.shift.TP;

 260 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-tr.adb
Source file time stamp: 2021-02-07 23:18:07
Compiled at: 2021-02-08 17:20:57

     1. -- Emulation of a paper tape reader buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. --
    19. with IOC.equipment;
    20. with KDF9_char_sets;
    21. with KDF9.TOD_clock;
    22. with KDF9.TSD.timing;
    23. with tracing;
    24.
    25. use  IOC.equipment;
    26. use  KDF9_char_sets;
    27. use  KDF9.TOD_clock;
    28. use  tracing;
    29.
    30. package body IOC.slow.shift.TR is
    31.
    32.    use KDF9_char_sets;
    33.
    34.    overriding
    35.    procedure Initialize (the_TR : in out TR.device) is
    36.    begin
    37.       -- Open the associated file.
    38.       open(IOC.device(the_TR), read_mode);
    39.    end Initialize;
    40.
    41.    --
    42.    -- See Manual, §17.4 for paper tape 8-bit frame format.
    43.    --
    44.
    45.    function has_even_parity (octet : KDF9.syllable)
    46.    return Boolean is
    47.       frame  : KDF9.syllable := octet;
    48.       parity : KDF9.syllable := 0;
    49.    begin
    50.       while frame /= 0 loop
    51.          parity := parity xor (frame and 1);
    52.          frame  := frame / 2;
    53.       end loop;
    54.       return parity = 0;
    55.    end has_even_parity;
    56.
    57.    function symbol_from (octet : KDF9.syllable)
    58.    return KDF9_char_sets.symbol
    59.    is (KDF9_char_sets.symbol((octet and 2#01_100_000#)/2 or (octet and 2#00_001_111#)));
    60.
    61.    DEL_frame : constant := 8#377#;
    62.    NUL_frame : constant := 8#000#;
    63.
    64.    -- Read 8-bit paper tape frames, compress to 6-bit byteacters, and pack into words.
    65.    procedure read_KDF9_tape_code (the_TR        : in out TR.device;
    66.                                   Q_operand     : in KDF9.Q_register;
    67.                                   reading_to_EM,
    68.                                   loading_code  : in Boolean := False) is
    69.       c      : KDF9_char_sets.symbol_index := 0;
    70.       w      : KDF9.Q_part := Q_operand.I;
    71.       size   : KDF9.word := 0;
    72.       octet  : KDF9.syllable;
    73.       symbol : KDF9_char_sets.symbol;
    74.       byte   : Character;
    75.    begin
    76.       check_addresses_and_lockouts(Q_operand.I, Q_operand.M);
    77.    word_loop:
    78.       loop
    79.          loop
    80.             get_byte_from_stream(byte, the_TR);
    81.             octet := KDF9.syllable(Character'Pos(byte));
    82.          exit when octet not in NUL_frame | DEL_frame;
    83.          end loop;
    84.          if has_even_parity(octet) then
    85.             symbol := symbol_from(octet);
    86.          else
    87.             trap_invalid_paper_tape("probably not in KDF9 code (parity error detected)");
    88.          end if;
    89.          store_symbol(symbol, w, c);
    90.          size := size + 1;
    91.          c := c + 1;
    92.          if c = 0 then
    93.       exit word_loop when reading_to_EM and symbol = KDF9_char_sets.End_Message;
    94.             w := w + 1;
    95.       exit word_loop when w > Q_operand.M;
    96.          end if;
    97.          if reading_to_EM and then symbol = KDF9_char_sets.End_Message then
    98.             for d in c .. 7 loop
    99.                store_symbol(KDF9_char_sets.Blank_Space, w, d);
   100.             end loop;
   101.       exit word_loop;
   102.          end if;
   103.       exit word_loop when w > Q_operand.M;
   104.       end loop word_loop;
   105.       if not loading_code then
   106.          do_input_housekeeping(the_TR, read_in => size, stored => size);
   107.       end if;
   108.    exception
   109.       when end_of_stream =>
   110.          if size = 0 then
   111.             trap_invalid_paper_tape("there was no data on the tape");
   112.          end if;
   113.          if not loading_code then
   114.             do_input_housekeeping(the_TR, read_in => size, stored => size);
   115.          end if;
   116.          the_TR.is_abnormal := True;
   117.          if not reading_to_EM and c /= 0 then
   118.             trap_invalid_paper_tape("the last word on the tape was incomplete");
   119.          end if;
   120.    end read_KDF9_tape_code;
   121.
   122.    -- PRQq
   123.    overriding
   124.    procedure PIA (the_TR      : in out TR.device;
   125.                   Q_operand   : in KDF9.Q_register;
   126.                   set_offline : in Boolean) is
   127.    begin
   128.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   129.       if the_TR.is_transcribing then
   130.          read(the_TR, Q_operand);
   131.       else
   132.          read_KDF9_tape_code(the_TR, Q_operand);
   133.       end if;
   134.       lock_out_relative_addresses(Q_operand);
   135.    end PIA;
   136.
   137.    -- PREQq
   138.    overriding
   139.    procedure PIB (the_TR      : in out TR.device;
   140.                   Q_operand   : in KDF9.Q_register;
   141.                   set_offline : in Boolean) is
   142.    begin
   143.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   144.       if the_TR.is_transcribing then
   145.          read_to_EM(the_TR, Q_operand);
   146.       else
   147.          read_KDF9_tape_code(the_TR, Q_operand, reading_to_EM => True);
   148.       end if;
   149.       lock_out_relative_addresses(Q_operand);
   150.    end PIB;
   151.
   152.    -- PRCQq
   153.    overriding
   154.    procedure PIC (the_TR      : in out TR.device;
   155.                   Q_operand   : in KDF9.Q_register;
   156.                   set_offline : in Boolean) is
   157.    begin
   158.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   159.       words_read(the_TR, Q_operand);
   160.       lock_out_relative_addresses(Q_operand);
   161.    end PIC;
   162.
   163.    -- PRCEQq
   164.    overriding
   165.    procedure PID (the_TR      : in out TR.device;
   166.                   Q_operand   : in KDF9.Q_register;
   167.                   set_offline : in Boolean) is
   168.    begin
   169.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   170.       words_read_to_EM(the_TR, Q_operand);
   171.       lock_out_relative_addresses(Q_operand);
   172.    end PID;
   173.
   174.    -- as PIA
   175.    overriding
   176.    procedure PIE (the_TR      : in out TR.device;
   177.                   Q_operand   : in KDF9.Q_register;
   178.                   set_offline : in Boolean) is
   179.    begin
   180.       PIA(the_TR, Q_operand, set_offline);
   181.    end PIE;
   182.
   183.    -- as PIB
   184.    overriding
   185.    procedure PIF (the_TR      : in out TR.device;
   186.                   Q_operand   : in KDF9.Q_register;
   187.                   set_offline : in Boolean) is
   188.    begin
   189.       PIB(the_TR, Q_operand, set_offline);
   190.    end PIF;
   191.
   192.    -- as PIC
   193.    overriding
   194.    procedure PIG (the_TR      : in out TR.device;
   195.                   Q_operand   : in KDF9.Q_register;
   196.                   set_offline : in Boolean) is
   197.    begin
   198.       PIC(the_TR, Q_operand, set_offline);
   199.    end PIG;
   200.
   201.    -- as PID
   202.    overriding
   203.    procedure PIH (the_TR      : in out TR.device;
   204.                   Q_operand   : in KDF9.Q_register;
   205.                   set_offline : in Boolean) is
   206.    begin
   207.       PID(the_TR, Q_operand, set_offline);
   208.    end PIH;
   209.
   210.    -- the_T_bit_is_set := (the reader is set to 8-track mode);
   211.    --    it is always in 8-track mode, as 5-track input is not supported by ee9.
   212.    overriding
   213.    procedure PMB (the_TR      : in out TR.device;
   214.                   Q_operand   : in KDF9.Q_register;
   215.                   set_offline : in Boolean) is
   216.    begin
   217.       validate_device(the_TR, Q_operand);
   218.       validate_parity(the_TR);
   219.       deal_with_a_busy_device(the_TR, 13, set_offline);
   220.       the_T_bit_is_set := True;
   221.       take_note_of_test(the_TR.device_name, Q_operand, the_T_bit_is_set);
   222.    end PMB;
   223.
   224.
   225.
   226.    overriding
   227.    procedure Finalize (the_TR : in out TR.device) is
   228.    begin
   229.       close(
   230.             the_TR,
   231.             "read",
   232.             the_TR.byte_count,
   233.             "character" & plurality(the_TR.byte_count)
   234.           & " in "
   235.           & (if the_TR.is_transcribing then "Latin-1" else "KDF9")
   236.           & " code"
   237.            );
   238.    end Finalize;
   239.
   240.    type TR_access is access TR.device;
   241.
   242.    TR0  : TR_access with Warnings => Off;
   243.    TR1  : TR_access with Warnings => Off;
   244.
   245.    TR_quantum : constant := 1E6 / 1_000;  -- 1000 characters per second.
   246.
   247.    unit : IOC.unit_number := 0;
   248.
   249.    procedure enable (b : in KDF9.buffer_number) is
   250.    begin
   251.       case unit is
   252.          when 0 =>
   253.             TR0 := new TR.device (number  => b,
   254.                                   kind    => TR_kind,
   255.                                   unit    => 0,
   256.                                   quantum => TR_quantum);
   257.             TR0_number := b;
   258.          when 1 =>
   259.             TR1 := new TR.device (number  => b,
   260.                                   kind    => TR_kind,
   261.                                   unit    => 1,
   262.                                   quantum => TR_quantum);
   263.             TR1_number := b;
   264.          when others =>
   265.             trap_operator_error("more than two TR units have been configured");
   266.       end case;
   267.       unit := unit + 1;
   268.    end enable;
   269.
   270.    -- Set the character code to be used by the designated TR.
   271.    procedure set_unit_code (unit : in Natural; is_transcribing : in Boolean) is
   272.    begin
   273.       if unit = 0 then
   274.          TR0.is_transcribing := set_unit_code.is_transcribing;
   275.       elsif TR1 /= null then
   276.          TR1.is_transcribing := set_unit_code.is_transcribing;
   277.       end if;
   278.    end set_unit_code;
   279.
   280.    --
   281.    -- Support for loading programs and for bootstrapping the KDF9.
   282.    --
   283.
   284.    procedure reattach (unit : in Natural; next_file_name : in String) is
   285.       the_reader  : constant TR_access := (if unit = 0 then TR0 else TR1);
   286.    begin
   287.       reattach(the_reader.all, next_file_name);
   288.       if the_reader.is_open then
   289.          the_reader.current_case := KDF9_char_sets.Case_Normal;
   290.       else
   291.          trap_operator_error("'" & next_file_name & "' cannot be found");
   292.       end if;
   293.    end reattach;
   294.
   295.    procedure reset_loader_usage (unit : in Natural) is
   296.       the_reader  : constant TR_access := (if unit = 0 then TR0 else TR1);
   297.    begin
   298.       correct_transfer_time(the_reader.all, KDF9.us(0));
   299.       the_reader.byte_count := 0;
   300.       unlock_absolute_addresses((0, 0, 32767));
   301.    end reset_loader_usage;
   302.
   303.    -- This emulates the Director's program load from a designated  paper tape reader.
   304.    -- Once the loading is done, the tape reader is reattached to TR<unit>.
   305.
   306.    procedure load_a_program  (program_file_name : in String) is
   307.
   308.       -- This is the call sign for a program on Disc or Drum.
   309.       CN_LS_D_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   310.                                       or (KDF9.word(Line_Shift)   * 2**12)
   311.                                       or (KDF9.word(Upper_Case_D) * 2** 6)
   312.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   313.
   314.       -- This is the call sign for a program on Magnetic Tape.
   315.       CN_LS_M_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   316.                                       or (KDF9.word(Line_Shift)   * 2**12)
   317.                                       or (KDF9.word(Upper_Case_M) * 2** 6)
   318.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   319.
   320.       -- This is the call sign for a program on Paper Tape.
   321.       CN_LS_P_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   322.                                       or (KDF9.word(Line_Shift)   * 2**12)
   323.                                       or (KDF9.word(Upper_Case_P) * 2** 6)
   324.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   325.
   326.       threshold  : constant KDF9.word := 32767 * 2**24;
   327.       substitute : constant KDF9.word := 32736 * 2**24;
   328.       get_a_word : constant KDF9.Q_register := (TR0.number, 0, 0);
   329.
   330.       descriptor : KDF9.Q_register := (TR0.number, 1, 7);
   331.       word_count : Positive := 2;
   332.
   333.    begin -- load_a_program
   334.
   335.       loading_was_successful := False;
   336.
   337.       -- Access the program file as TR0.
   338.       reattach(0, program_file_name);
   339.
   340.       --
   341.       -- For the structure of a compiled program, see Manual §26.3.
   342.       --
   343.
   344.       -- Get the first word of the file into E0: it may start an A block or a B block.
   345.       read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True);
   346.
   347.       -- Check for an A block.  If one is found, check its validity, but otherwise ignore it.
   348.       if fetch_halfword(0, 0)/2**24 in CN_LS_D_LS | CN_LS_M_LS | CN_LS_P_LS then
   349.          -- We have an A block.
   350.          -- The next word completes the program name used by Director.  Ignore it.
   351.          read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True);
   352.
   353.       block_loop:
   354.          -- An A block is at most 8 words long but can end sooner with a word containing EM.
   355.          loop
   356.             word_count := word_count + 1;
   357.          exit block_loop when word_count > 8;
   358.             read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True, reading_to_EM => True);
   359.             for c in KDF9_char_sets.symbol_index loop
   360.          exit block_loop when fetch_symbol(0, c) = End_Message;
   361.             end loop;
   362.          end loop block_loop;
   363.
   364.          if word_count > 8 then
   365.             -- The file is not a valid program tape.
   366.             trap_invalid_paper_tape("excessively long A block");
   367.          end if;
   368.
   369.          -- Read the first word of the following B block.
   370.          read_KDF9_tape_code(TR0.all, (TR0.number, 0, 0), loading_code => True);
   371.       end if;
   372.
   373.       -- Check for an unconditional jump at the start of the B block.
   374.       if (fetch_word(0)/ 2**32 and 2#1111_0000_1111_0000#) /= 2#1000_0000_1011_0000# then
   375.          -- The file is not a valid program tape.
   376.          trap_invalid_paper_tape("no jump was found in E0H");
   377.       end if;
   378.
   379.       -- At this point, E0 contains the first word of the B block, so get the rest of it in E1-E7.
   380.       read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   381.
   382.       descriptor := as_Q(fetch_word(descriptor.M));
   383.       -- Read the non-final C blocks; the validity of the designated descriptors cannot be assumed.
   384.       while descriptor.C /= 0 loop
   385.          validate_address_range(descriptor.I, descriptor.M);
   386.          read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   387.          descriptor := as_Q(fetch_word(descriptor.M));
   388.       end loop;
   389.
   390.       -- Read the final C block.
   391.       validate_address_range(descriptor.I, descriptor.M);
   392.       read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   393.
   394.       -- Set up the rest of the stored image.
   395.
   396.       -- Preserve the initial jump in case of corruption by a buggy program.
   397.       save_the_initial_jump;
   398.
   399.       -- Set the (virtual) date in E7.
   400.       store_word(todays_date_28n_years_ago, 7);
   401.
   402.       -- Ensure valid parameters in E1 (some binaries may have invalid entries).
   403.       if fetch_halfword(1, 0) > threshold or else fetch_halfword(1, 0) = 0 then
   404.          store_halfword(substitute, 1, 0);
   405.       end if;
   406.       if fetch_halfword(1, 1) > threshold or else fetch_halfword(1, 1) = 0 then
   407.          store_halfword(substitute, 1, 1);
   408.       end if;
   409.
   410.       -- Do not set the time if we are computing a signature, so as to get a repeatable hash.
   411.       if not the_signature_is_enabled then
   412.          KDF9.TSD.timing.set_the_time_of_loading(the_time_of_day);
   413.       end if;
   414.
   415.       loading_was_successful := True;
   416.
   417.       -- Clear up the I/O system.
   418.       reattach(0, "TR0");
   419.       clear_IOC_FIFO;
   420.       reset_loader_usage(0);
   421.    exception
   422.       when invalid_paper_tape_file
   423.          | operator_error =>
   424.          raise;
   425.       when error : others =>
   426.          raise emulation_failure with "in load_a_program: " & Ada.Exceptions.Exception_Message(error);
   427.    end load_a_program;
   428.
   429.    -- TR0 is the hardware bootstrap device for reading initial orders.
   430.    procedure boot_the_KDF9 (program_file_name : in String) is
   431.       boot_descriptor : constant KDF9.Q_register := (C => TR0.number, I => 0, M => 8);
   432.    begin
   433.       loading_was_successful := False;
   434.       reattach(0, program_file_name);
   435.
   436.       -- The bootstrap is 9 words of instruction code, which reads in the rest of its file.
   437.       -- The validity of the bootstrap descriptor is hardware defined.
   438.       read_KDF9_tape_code(TR0.all, boot_descriptor, loading_code => True);
   439.
   440.       -- Reset the I/O system for execution of the Director.
   441.       clear_IOC_FIFO;
   442.       reset_loader_usage(0);
   443.       loading_was_successful := True;
   444.    exception
   445.       when invalid_paper_tape_file =>
   446.          raise;
   447.       when error : others =>
   448.          raise emulation_failure with "in boot_the_KDF9: " & Ada.Exceptions.Exception_Message(error);
   449.    end boot_the_KDF9;
   450.
   451. end IOC.slow.shift.TR;

Compiling: ../Source/ioc-slow-shift-tr.ads
Source file time stamp: 2021-01-10 23:52:37
Compiled at: 2021-02-08 17:20:57

     1. -- Emulation of a paper tape reader buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.TR is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    -- PRQq
    22.    overriding
    23.    procedure PIA (the_TR      : in out TR.device;
    24.                   Q_operand   : in KDF9.Q_register;
    25.                   set_offline : in Boolean);
    26.
    27.    -- PREQq
    28.    overriding
    29.    procedure PIB (the_TR      : in out TR.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    --PRCQq
    34.    overriding
    35.    procedure PIC (the_TR      : in out TR.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    -- PRCEQq
    40.    overriding
    41.    procedure PID (the_TR      : in out TR.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    -- as PIA
    46.    overriding
    47.    procedure PIE (the_TR      : in out TR.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- as PIB
    52.    overriding
    53.    procedure PIF (the_TR      : in out TR.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- as PIC
    58.    overriding
    59.    procedure PIG (the_TR      : in out TR.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    -- as PID
    64.    overriding
    65.    procedure PIH (the_TR      : in out TR.device;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    -- the_T_bit_is_set (the reader is set to 8-track mode)
    70.    overriding
    71.    procedure PMB (the_TR      : in out TR.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    procedure enable (b : in KDF9.buffer_number);
    76.
    77.    -- Reattach the designated TR to the specified file and set CASE NORMAL (may be irrelevant).
    78.    -- This is done after loading a binary program, to allow access any TR data file(s);
    79.    --    also to access a binary program for loading as an overlay.
    80.    procedure reattach (unit : in Natural; next_file_name : in String);
    81.
    82.    -- Read the 9-word bootstrap.
    83.    procedure boot_the_KDF9 (program_file_name : in String);
    84.
    85.    -- Read a binary program.
    86.    procedure load_a_program (program_file_name : in String);
    87.
    88.    -- Set the character code to be used by the TR unit.
    89.    procedure set_unit_code(unit : in Natural; is_transcribing : in Boolean);
    90.
    91. private
    92.
    93.    type device is new IOC.slow.shift.device with null record;
    94.
    95.    overriding
    96.    procedure Initialize (the_TR : in out TR.device);
    97.
    98.    overriding
    99.    procedure Finalize (the_TR : in out TR.device);
   100.
   101. end IOC.slow.shift.TR;

 451 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/say_goodbye.adb
Source file time stamp: 2021-02-07 00:12:29
Compiled at: 2021-02-08 17:20:57

     1. -- Finalize emulation with a helpful message derived from exception information.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Command_Line;
    18. with Ada.Strings.Fixed;
    19. with finalize_ee9;
    20. with HCI;
    21. with settings;
    22.
    23. use  Ada.Command_Line;
    24. use  Ada.Strings.Fixed;
    25.
    26. use  HCI;
    27. use  settings;
    28.
    29. procedure say_goodbye (
    30.                        reason : in String;
    31.                        cause  : in String := "";
    32.                        status : in Exit_Status := Failure
    33.                       ) is
    34.    function explanation
    35.    return String is
    36.       CR   : constant Character := Character'Val(16#D#);
    37.       LF   : constant Character := Character'Val(16#A#);
    38.       L, R : Natural;
    39.    begin  -- explanation
    40.       if cause'Length < 3 then
    41.          return cause;
    42.       end if;
    43.       L := Index(cause, "%", from => cause'First) + 1;
    44.       if cause(cause'Last-1) = CR then
    45.          R := cause'Last - 2;
    46.       elsif cause(cause'Last) in LF | CR then
    47.          R := cause'Last - 1;
    48.       else
    49.          R := cause'Last;
    50.       end if;
    51.       return cause(L .. R);
    52.    end explanation;
    53.
    54. begin  -- say_goodbye
    55.    if reason = "" then
    56.       finalize_ee9("Normal end of run");
    57.    elsif reason'Length > 2 and then
    58.          reason(reason'Last-2..reason'Last) = "OUT" then
    59.       finalize_ee9(reason & " " & explanation);
    60.    elsif reason'Length = 0 then
    61.       finalize_ee9(explanation);
    62.    else
    63.       finalize_ee9(reason & ": " & explanation);
    64.    end if;
    65.    if the_log_is_wanted then
    66.       log_new_line;
    67.    end if;
    68.    Set_Exit_Status(status);
    69. end say_goodbye;

 69 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/settings.adb
Source file time stamp: 2021-02-08 01:19:28
Compiled at: 2021-02-08 17:20:57

     1. -- execution mode, diagnostic mode, and other emulation-control settings
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. with Ada.Long_Float_Text_IO;
    19. with Ada.Text_IO;
    20. --
    21. with dumping;
    22. with exceptions;
    23. with formatting;
    24. with HCI;
    25. with IOC.equipment;
    26. with KDF9.store;
    27. with postscript;
    28. with settings.IO;
    29. with tracing;
    30.
    31. use  Ada.Exceptions;
    32. use  Ada.Long_Float_Text_IO;
    33. use  Ada.Text_IO;
    34. --
    35. use  dumping;
    36. use  exceptions;
    37. use  formatting;
    38. use  HCI;
    39. use  KDF9.store;
    40. use  settings.IO;
    41. use  tracing;
    42.
    43. package body settings is
    44.
    45.    function is_invalid_miscellany_flag (option : in Character)
    46.    return Boolean is
    47.    begin
    48.       for f of miscellany_flags loop
    49.          if f = option then
    50.             return False;
    51.          end if;
    52.       end loop;
    53.       if option = '-' then  -- Ignore hyphens to make the calling scripts easier.
    54.          return False;
    55.       end if;
    56.       return True;
    57.    end is_invalid_miscellany_flag;
    58.
    59.    procedure set_this_miscellany_flag (option : in Character) is
    60.       use IOC.equipment;
    61.    begin
    62.       if is_invalid_miscellany_flag(option) then
    63.          log_line(
    64.                   "***** Error in a miscellany specification: '"
    65.                 & option
    66.                 & "'."
    67.                  );
    68.          return;
    69.       end if;
    70.       case option is
    71.          when '-'        =>
    72.             null;  -- Ignore hyphens, to make the calling scripts easier.
    73.          when '.'        =>
    74.             time_limit := 1_000_000;
    75.          when '0' .. '9' =>
    76.             time_limit := (Character'Pos(option) - Character'Pos('0') + 1) * 100_000_000;
    77.          when 'a' | 'A' =>
    78.             API_logging_is_wanted := False;
    79.          when 'b' | 'B' =>
    80.             choice(KDF9.buffer_number'(15)) := SI;
    81.          when 'd' | 'D' =>
    82.             debugging_is_enabled := True;
    83.          when 'e' | 'E' =>
    84.             the_log_is_wanted := False;
    85.          when 'f' | 'F' =>
    86.             the_final_state_is_wanted := False;
    87.          when 'g' | 'G' =>
    88.             choice(if TP1_number = 0 then TP1_default else TP1_number) := GP;
    89.          when 'h' | 'H' =>
    90.             any_histogram_is_wanted := False;
    91.          when 'i' | 'I' =>
    92.             interrupt_tracing_is_wanted := False;
    93.          when 'k' | 'K' =>
    94.             choice(DR0_default) := DR;
    95.          when 'm' | 'M' =>
    96.             the_terminal_is_ANSI_compatible := False;
    97.          when 'n' | 'N' =>
    98.             noninteractive_usage_is_enabled := True;
    99.             time_limit := offline_time_limit;
   100.           when 'o' |'O' =>
   101.             pre_overlay_state_is_enabled := True;
   102.          when 'p' |'P' =>
   103.             peripheral_tracing_is_wanted := False;
   104.          when 'q' | 'Q' =>
   105.             do_not_execute := True;
   106.          when 'r' | 'R' =>
   107.             retrospective_tracing_is_wanted := False;
   108.          when 's' | 'S' =>
   109.             the_signature_is_wanted := False;
   110.          when 't' | 'T' =>
   111.             authentic_timing_is_enabled := True;
   112.          when 'w' | 'W' =>
   113.             flexowriter_output_is_wanted := False;
   114.          when 'x' | 'X' =>
   115.             only_signature_tracing := True;
   116.          when 'z' | 'Z' =>
   117.             the_log_is_wanted := False;
   118.             debugging_is_enabled := False;
   119.             API_logging_is_wanted := False;
   120.             any_histogram_is_wanted := False;
   121.             the_signature_is_wanted := False;
   122.             the_final_state_is_wanted := False;
   123.             interrupt_tracing_is_wanted := False;
   124.             peripheral_tracing_is_wanted := False;
   125.             retrospective_tracing_is_wanted := False;
   126.          when others =>
   127.             raise emulation_failure with "previously undectected invalid miscellany flag";
   128.       end case;
   129.       set_diagnostic_mode(the_diagnostic_mode);
   130.    end set_this_miscellany_flag;
   131.
   132.    procedure display_execution_modes (for_this_run : in String := "") is
   133.       needs_comma : Boolean := False;
   134.
   135.       procedure append_option (flag : in Boolean; name : in String) is
   136.       begin
   137.          if flag then
   138.             if needs_comma then
   139.                log(", ");
   140.             end if;
   141.             log(name);
   142.             needs_comma := True;
   143.          end if;
   144.       end append_option;
   145.
   146.       function description_of (type_of_run, name_of_code : String)
   147.       return String
   148.       is (if name_of_code = "" then type_of_run else type_of_run & " " & name_of_code);
   149.
   150.    begin -- display_execution_modes
   151.       if not the_log_is_wanted then return; end if;
   152.       log_new_line;
   153.       if for_this_run = "" then
   154.          log("Resuming the run");
   155.       else
   156.          log(
   157.              case the_execution_mode is
   158.                when boot_mode         => "Booting the KDF9 " & description_of("Director", for_this_run),
   159.                when program_mode      => "Running the KDF9 " & description_of("problem program", for_this_run),
   160.                when test_program_mode => "Running the KDF9 " & description_of("privileged program", for_this_run)
   161.             );
   162.       end if;
   163.       log(" in ");
   164.       log(
   165.           case the_diagnostic_mode is
   166.              when trace_mode    =>
   167.                 (if the_external_trace_is_enabled then "external trace mode" else "trace mode"),
   168.              when fast_mode     => "fast mode",
   169.              when pause_mode    => "pause mode",
   170.              when external_mode => "external trace mode"
   171.          );
   172.       if the_histogram_is_enabled           or else
   173.          the_interrupt_trace_is_enabled     or else
   174.          the_peripheral_trace_is_enabled    or else
   175.          the_retrospective_trace_is_enabled or else
   176.          the_signature_is_enabled           or else
   177.          the_external_trace_is_enabled      or else
   178.          authentic_timing_is_enabled        or else
   179.          debugging_is_enabled               or else
   180.          noninteractive_usage_is_enabled       then
   181.
   182.          log_line(", with option(s):");
   183.          log("   ");
   184.          append_option(authentic_timing_is_enabled,        "authentic timing");
   185.          append_option(debugging_is_enabled,               "debugging output");
   186.          append_option(the_histogram_is_enabled,           "histogram(s)");
   187.          append_option(the_interrupt_trace_is_enabled,     "interrupt trace");
   188.          append_option(noninteractive_usage_is_enabled,    "noninteractive");
   189.          append_option(the_peripheral_trace_is_enabled,    "peripheral trace");
   190.          append_option(the_retrospective_trace_is_enabled, "retro trace");
   191.          append_option(the_signature_is_enabled,           "signature hash");
   192.       end if;
   193.       log_line(".");
   194.       log_rule;
   195.    end display_execution_modes;
   196.
   197.    procedure quit_if_requested is
   198.    begin
   199.       if quit_was_requested then
   200.          raise quit_request;
   201.       end if;
   202.    end quit_if_requested;
   203.
   204.    procedure change_diagnostic_mode_if_requested is
   205.    begin
   206.       if the_diagnostic_mode_changed then
   207.          the_diagnostic_mode_changed := False;
   208.          raise mode_change_request;
   209.       end if;
   210.    end change_diagnostic_mode_if_requested;
   211.
   212.    procedure set_diagnostic_mode (a_diagnostic_mode : in settings.diagnostic_mode) is
   213.       the_signature_is_appropriate,
   214.       the_histogram_is_appropriate,
   215.       retrospective_tracing_is_appropriate,
   216.       peripheral_tracing_is_appropriate,
   217.       interrupt_tracing_is_appropriate : Boolean;
   218.    begin
   219.       if a_diagnostic_mode = external_mode then
   220.          if (the_diagnostic_mode /= external_mode) and (not the_external_trace_is_enabled) then
   221.             open(the_external_trace_file, the_external_trace_file_name);
   222.          end if;
   223.          the_diagnostic_mode := trace_mode;
   224.          the_external_trace_is_enabled := True;
   225.       else
   226.          the_diagnostic_mode := a_diagnostic_mode;
   227.       end if;
   228.       case a_diagnostic_mode is
   229.          when fast_mode =>
   230.             debugging_is_enabled := False;
   231.             the_signature_is_appropriate := False;
   232.             the_histogram_is_appropriate := False;
   233.             retrospective_tracing_is_appropriate := False;
   234.             peripheral_tracing_is_appropriate := False;
   235.             interrupt_tracing_is_appropriate := False;
   236.          when trace_mode | external_mode | pause_mode =>
   237.             the_signature_is_appropriate := True;
   238.             the_histogram_is_appropriate := True;
   239.             retrospective_tracing_is_appropriate := True;
   240.             peripheral_tracing_is_appropriate := True;
   241.             interrupt_tracing_is_appropriate := (the_execution_mode = boot_mode);
   242.       end case;
   243.       the_signature_is_enabled :=
   244.          the_signature_is_wanted and the_signature_is_appropriate;
   245.       the_histogram_is_enabled :=
   246.          any_histogram_is_wanted and the_histogram_is_appropriate;
   247.       the_retrospective_trace_is_enabled :=
   248.          retrospective_tracing_is_wanted and retrospective_tracing_is_appropriate;
   249.       the_peripheral_trace_is_enabled :=
   250.          peripheral_tracing_is_wanted and peripheral_tracing_is_appropriate;
   251.       the_interrupt_trace_is_enabled :=
   252.          interrupt_tracing_is_wanted and interrupt_tracing_is_appropriate;
   253.    end set_diagnostic_mode;
   254.
   255.    procedure set_execution_mode (an_execution_mode : in settings.execution_mode) is
   256.    begin
   257.       the_execution_mode := an_execution_mode;
   258.    end set_execution_mode;
   259.
   260.    package diagnostic_mode_IO   is new Ada.Text_IO.Enumeration_IO(settings.diagnostic_mode);
   261.
   262.    package execution_mode_IO    is new Ada.Text_IO.Enumeration_IO(settings.execution_mode);
   263.
   264.    package authenticity_mode_IO is new Ada.Text_IO.Enumeration_IO(KDF9.authenticity_mode);
   265.
   266.    package equipment_IO         is new Ada.Text_IO.Enumeration_IO(IOC.equipment.kind);
   267.
   268.    procedure get_settings_from_file (version : in String) is
   269.
   270.       the_settings_file_name : constant String := "settings_" & version & ".txt";
   271.       counts_are_set : Boolean := False;
   272.       settings_file  : File_Type;
   273.       flag           : Character;
   274.
   275.       procedure set_the_miscellany_flags is
   276.          option : Character;
   277.       begin
   278.          loop
   279.             get(settings_file, option);
   280.             if is_invalid_miscellany_flag(option) then
   281.                raise Data_Error;
   282.             else
   283.                set_this_miscellany_flag(option);
   284.             end if;
   285.          exit when End_Of_Line(settings_file);
   286.          end loop;
   287.       exception
   288.          when error : others =>
   289.             if not End_Of_Line(settings_file) then
   290.                Skip_Line(settings_file);
   291.             end if;
   292.             log_new_line;
   293.             log_line(
   294.                      "***** Error in a miscellany specification: '"
   295.                    & option
   296.                    & "' at "
   297.                    & Exception_Message(error)
   298.                     );
   299.       end set_the_miscellany_flags;
   300.
   301.       procedure set_breakpoints is
   302.          start, end_point : KDF9.order_word_number;
   303.       begin
   304.          begin
   305.             get_word(settings_file, KDF9.word(start));
   306.          exception
   307.             when others =>
   308.                log_new_line;
   309.                log_line("***** Error in lower address; no breakpoint set.");
   310.                return;
   311.          end;
   312.
   313.          log_new_line;
   314.          log_line(
   315.                   "Lower breakpoint: "
   316.                 & oct_of(KDF9.syllable_address'(start, 0))
   317.                 & " ("
   318.                 & dec_of(KDF9.syllable_address'(start, 0))
   319.                 & ")",
   320.                   iff => the_log_is_wanted
   321.                  );
   322.          breakpoints(start) := True;
   323.
   324.          begin
   325.             get_word(settings_file, KDF9.word(end_point));
   326.          exception
   327.             when Data_Error =>
   328.                log_line("      No upper address: one breakpoint set.", iff => the_log_is_wanted);
   329.                set_breakpoints(start, start);
   330.                return;
   331.          end;
   332.          log_line(
   333.                   "Upper breakpoint: "
   334.                 & oct_of(KDF9.syllable_address'(end_point, 5))
   335.                 & " (" & dec_of(KDF9.syllable_address'(end_point, 5))
   336.                 & ")",
   337.                   iff => the_log_is_wanted
   338.                  );
   339.          set_breakpoints(start, end_point);
   340.       exception
   341.          when others =>
   342.             log_line("***** Error setting breakpoints; ignored.");
   343.       end set_breakpoints;
   344.
   345.       procedure set_store_points is
   346.          start, end_point : KDF9.address;
   347.       begin
   348.          begin
   349.             get_word(settings_file, KDF9.word(start));
   350.          exception
   351.             when others =>
   352.                log_new_line;
   353.                log_line("***** Error in lower address; no storepoint set.");
   354.                return;
   355.          end;
   356.          log_new_line;
   357.          log_line(
   358.                   "Lower storepoint: #"
   359.                 & oct_of(start)
   360.                 & " ("
   361.                 & dec_of(start)
   362.                 & ")",
   363.                   iff => the_log_is_wanted
   364.                  );
   365.          begin
   366.             get_word(settings_file, KDF9.word(end_point));
   367.          exception
   368.             when Data_Error =>
   369.                log_line("      No upper address: one storepoint set.", iff => the_log_is_wanted);
   370.                set_store_points(start, start);
   371.                return;
   372.          end;
   373.          log_line(
   374.                   "Upper storepoint: #"
   375.                 & oct_of(end_point)
   376.                 & " ("
   377.                 & dec_of(end_point)
   378.                 & ")",
   379.                   iff => the_log_is_wanted
   380.                  );
   381.          set_store_points(start, end_point);
   382.       exception
   383.          when others =>
   384.             log_line("***** Error setting storepoints; ignored.");
   385.       end set_store_points;
   386.
   387.       procedure set_watchpoints is
   388.          start, end_point : KDF9.address;
   389.       begin
   390.          begin
   391.             get_word(settings_file, KDF9.word(start));
   392.          exception
   393.             when others =>
   394.                log_new_line;
   395.                log_line("***** Error in lower address; no watchpoint set.");
   396.                return;
   397.          end;
   398.          log_new_line;
   399.          log_line(
   400.                   "Lower watchpoint: #"
   401.                 & oct_of(start)
   402.                 & " ("
   403.                 & dec_of(start)
   404.                 & ")",
   405.                   iff => the_log_is_wanted
   406.                  );
   407.          begin
   408.             get_word(settings_file, KDF9.word(end_point));
   409.          exception
   410.             when Data_Error =>
   411.                log_line("      No upper address: one watchpoint set.", iff => the_log_is_wanted);
   412.                set_store_points(start, start);
   413.                set_fetch_points(start, start);
   414.                return;
   415.          end;
   416.          log_line("Upper watchpoint: #" & oct_of(end_point) & " (" & dec_of(end_point) & ")",
   417.                   iff => the_log_is_wanted);
   418.          set_fetch_points(start, end_point);
   419.          set_store_points(start, end_point);
   420.       exception
   421.          when others =>
   422.             log_line("***** Error setting watchpoints; ignored.");
   423.       end set_watchpoints;
   424.
   425.       procedure set_specified_dumping_ranges (epoch : in dumping.flag) is
   426.          use dumping.flag_support;
   427.          epoch_flag   : constant Character := (if epoch = initial_flag then 'I' else 'F');
   428.          format       : dumping.format_set := no_dumping_flags or epoch;
   429.          first_address,
   430.          last_address : KDF9.address := 0;
   431.          bad_range    : Boolean := False;
   432.          data         : KDF9.word;
   433.          c            : Character;
   434.          OK           : Boolean;
   435.       begin
   436.          log("Dump: format " & epoch_flag, iff => the_log_is_wanted);
   437.          while not End_Of_Line(settings_file) loop
   438.             get(settings_file, c);
   439.             log(c, iff => the_log_is_wanted);
   440.          exit when c = ' ';
   441.             if is_parameter_flag/dumping_flag(to_upper(c)) then
   442.                format := format or dumping_flag(to_upper(c));
   443.             else
   444.                if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   445.                log_new_line;
   446.                log_line("***** Error: '" & c & "' is not a valid dump type.");
   447.                return;
   448.             end if;
   449.          end loop;
   450.          log_new_line;
   451.          if (format and is_parameter_flag) /= no_dumping_flags then
   452.             get_word(settings_file, data);
   453.             if data > max_address                     or else
   454.                   (format/Usercode_flag and data > 8191) then
   455.                log_line(
   456.                         "***** Error: Lower dump address  = #"
   457.                       & oct_of(data)
   458.                       & " =" & data'Image
   459.                       & " is too large for this option."
   460.                        );
   461.                bad_range := True;
   462.             else
   463.                first_address := KDF9.address(data);
   464.                last_address  := KDF9.address(data);
   465.                log_line(
   466.                         "      Lower dump address: #"
   467.                       & oct_of(first_address)
   468.                       & " (" & dec_of(first_address)
   469.                       & ")",
   470.                         iff => the_log_is_wanted
   471.                        );
   472.             end if;
   473.
   474.            skip_to_next_non_blank (settings_file);
   475.
   476.             if not end_of_line(settings_file) then
   477.                get_word(settings_file, data);
   478.                if data > max_address                     or else
   479.                   (format/Usercode_flag and data > 8191) then
   480.                   log_line(
   481.                            "***** Error: Upper dump address: #"
   482.                          & oct_of(data)
   483.                          & " =" & data'Image
   484.                          & " is too large for this option."
   485.                           );
   486.                   bad_range := True;
   487.                else
   488.                   last_address := KDF9.address(data);
   489.                   log_line(
   490.                            "      Upper dump address: #"
   491.                          & oct_of(last_address)
   492.                          & " ("
   493.                          & dec_of(last_address)
   494.                          & ")",
   495.                            iff => the_log_is_wanted
   496.                           );
   497.                end if;
   498.             end if;
   499.
   500.             if first_address > last_address then
   501.                log_line(
   502.                         "***** Error: Upper dump address: #"
   503.                       & oct_of(last_address)
   504.                       & " =" & last_address'Image
   505.                       & " is less than lower dump address: #"
   506.                       & oct_of(first_address)
   507.                       & " =" & first_address'Image
   508.                       & "."
   509.                        );
   510.                bad_range := True;
   511.             end if;
   512.
   513.             if format/Usercode_flag then
   514.               if not end_of_line(settings_file) then
   515.                   get_word(settings_file, data);
   516.                   if data > 8190 then
   517.                      log_line(
   518.                               "***** Error: Scan start address: #"
   519.                             & oct_of(data)
   520.                             & " ="
   521.                             & data'Image
   522.                             & " > 8190, ignored."
   523.                              );
   524.                   else
   525.                      nominated_address := KDF9.order_word_number(data);
   526.                      log_line(
   527.                               "      Scan start address: #"
   528.                             & oct_of(nominated_address)
   529.                             & " ("
   530.                             & dec_of(nominated_address)
   531.                             & ")",
   532.                               iff => the_log_is_wanted
   533.                              );
   534.                   end if;
   535.                end if;
   536.             end if;
   537.
   538.          end if;
   539.
   540.          if not bad_range then
   541.             request_a_dumping_area(format, first_address, last_address, OK);
   542.             if not OK then
   543.                log_line("***** Error: Too many dump specifications (ignored).");
   544.             end if;
   545.          end if;
   546.
   547.          if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   548.       exception
   549.          when others =>
   550.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   551.             log_new_line;
   552.             log_line("***** Error in a dump area specification (ignored)." );
   553.       end set_specified_dumping_ranges;
   554.
   555.       procedure set_initial_dumping_ranges is
   556.       begin
   557.          set_specified_dumping_ranges(initial_flag);
   558.       end set_initial_dumping_ranges;
   559.
   560.       procedure set_final_dumping_ranges is
   561.       begin
   562.          set_specified_dumping_ranges(final_flag);
   563.       end set_final_dumping_ranges;
   564.
   565.       procedure set_histogram_options is
   566.          c : Character;
   567.       begin
   568.          while not End_Of_Line(settings_file) loop
   569.             get(settings_file, c);
   570.          exit when c = ' ';
   571.             if c not in 'P' | 'p' | 'T' | 't' then
   572.                raise Data_Error;
   573.             end if;
   574.             if c in 'P' | 'p' then
   575.                the_profile_is_wanted  := True;
   576.                clear_the_profile;
   577.             elsif c in  'T' | 't' then
   578.                the_INS_plot_is_wanted := True;
   579.                clear_the_histogram;
   580.             end if;
   581.          end loop;
   582.          ensure_not_at_end_of_line(settings_file);
   583.          get(settings_file, histogram_cutoff);
   584.          if histogram_cutoff >= 100.0 or histogram_cutoff < 0.0 then
   585.             raise Data_Error;
   586.          end if;
   587.          get(settings_file, c);
   588.          if c /= '%' then
   589.             raise Data_Error;
   590.          end if;
   591.       exception
   592.          when others =>
   593.             histogram_cutoff := cutoff_default;
   594.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   595.             log_new_line;
   596.             log_line("***** Error in the histogram option; default used.");
   597.       end set_histogram_options;
   598.
   599.       procedure set_time_limit is
   600.          begin
   601.             begin
   602.             get_decimal(settings_file, KDF9.word(time_limit));
   603.          exception
   604.             when others =>
   605.                if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   606.                time_limit := offline_time_limit;
   607.          end;
   608.
   609.          if not counts_are_set then
   610.             high_count := time_limit;
   611.          end if;
   612.
   613.          log_new_line;
   614.          log_line("Time limit (in instructions) =" & time_limit'Image,
   615.                   iff => the_log_is_wanted);
   616.       end set_time_limit;
   617.
   618.       procedure set_tracing_counts is
   619.
   620.          procedure show_counts is
   621.          begin
   622.             if not the_log_is_wanted then return; end if;
   623.             log_new_line;
   624.             log_line("Lower tracing count:" & low_count'Image);
   625.             log_line("Upper tracing count:" & high_count'Image);
   626.          end show_counts;
   627.
   628.       begin
   629.          get_decimal(settings_file, KDF9.word(low_count));
   630.          get_decimal(settings_file, KDF9.word(high_count));
   631.          show_counts;
   632.          if low_count > high_count then
   633.             log_new_line;
   634.             log_line("***** Error: Low count > high count.");
   635.             raise Data_Error;
   636.          end if;
   637.          counts_are_set := True;
   638.       exception
   639.          when others =>
   640.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   641.             low_count  := low_count_default;
   642.             high_count := high_count_default;
   643.             log_new_line;
   644.             log_line("***** Error in a tracing count; defaults used.");
   645.             show_counts;
   646.       end set_tracing_counts;
   647.
   648.       procedure set_tracing_range is
   649.
   650.          procedure show_range is
   651.          begin
   652.             if not the_log_is_wanted then return; end if;
   653.             log_new_line;
   654.             log_line(
   655.                      "Lower trace address: #"
   656.                    & oct_of(KDF9.syllable_address'(low_bound, 0))
   657.                    & " ("
   658.                    & dec_of(KDF9.syllable_address'(low_bound, 0))
   659.                    & ")"
   660.                     );
   661.             log_line(
   662.                      "Upper trace address: #"
   663.                    & oct_of(KDF9.syllable_address'(high_bound, 5))
   664.                    & " ("
   665.                    & dec_of(KDF9.syllable_address'(high_bound, 5))
   666.                    & ")"
   667.                     );
   668.          end show_range;
   669.
   670.       begin
   671.          get_word(settings_file, KDF9.word(low_bound));
   672.          get_word(settings_file, KDF9.word(high_bound));
   673.          if low_bound > high_bound then
   674.             log_new_line;
   675.             log_line("***** Error: Low bound > high bound.");
   676.             raise Data_Error;
   677.          end if;
   678.          show_range;
   679.       exception
   680.          when others =>
   681.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   682.             low_bound  := low_bound_default;
   683.             high_bound := high_bound_default;
   684.             log_new_line;
   685.             log_line("***** Error in a tracing address; defaults used.");
   686.             show_range;
   687.       end set_tracing_range;
   688.
   689.       procedure set_diagnostic_mode is
   690.          use diagnostic_mode_IO;
   691.          the_diagnostic_mode : settings.diagnostic_mode;
   692.       begin
   693.          ensure_not_at_end_of_line(settings_file);
   694.          get(settings_file, the_diagnostic_mode);
   695.          set_diagnostic_mode(the_diagnostic_mode);
   696.       exception
   697.          when others =>
   698.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   699.             set_diagnostic_mode(the_diagnostics_default);
   700.             log_new_line;
   701.             log_line("***** Error in the diagnostic mode; default used.");
   702.       end set_diagnostic_mode;
   703.
   704.       procedure set_execution_mode is
   705.          use execution_mode_IO;
   706.       begin
   707.          ensure_not_at_end_of_line(settings_file);
   708.          get(settings_file, the_execution_mode);
   709.       exception
   710.          when others =>
   711.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   712.             the_execution_mode := the_execution_default;
   713.             log_new_line;
   714.             log_line("***** Error in the testing mode; default used.");
   715.       end set_execution_mode;
   716.
   717.       procedure set_authenticity is
   718.          use authenticity_mode_IO;
   719.       begin
   720.          ensure_not_at_end_of_line(settings_file);
   721.          get(settings_file, the_authenticity_mode);
   722.          if the_authenticity_mode = authentic_time_mode then
   723.             authentic_timing_is_enabled := True;
   724.          end if;
   725.       exception
   726.          when others =>
   727.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   728.             the_authenticity_mode := the_authenticity_default;
   729.             log_new_line;
   730.             log_line("***** Error in the authenticity mode; default used.");
   731.       end set_authenticity;
   732.
   733.       procedure set_graph_plotting_pen is
   734.          use postscript;
   735.          use colour_IO;
   736.          use  width_IO;
   737.          the_colour   : pen_colour   := the_default_colour;
   738.          the_pen_size : pen_tip_size := the_default_tip_size;
   739.
   740.          procedure show_pen_options is
   741.          begin
   742.             if not the_log_is_wanted then return; end if;
   743.             log_new_line;
   744.             if the_colour /= the_default_colour then
   745.                log_line("The graph plotter pen colour is " & the_colour'Image & ".");
   746.             end if;
   747.             if the_pen_size /= the_default_tip_size then
   748.                log_line("The graph plotter pen tip is " & the_pen_size'Image & ".");
   749.             end if;
   750.          end show_pen_options;
   751.
   752.          procedure configure_the_plotter is
   753.          begin
   754.             if the_colour /= the_default_colour or the_pen_size /= the_default_tip_size then
   755.                set_the_pen_properties(the_colour, the_pen_size);
   756.                show_pen_options;
   757.             end if;
   758.          end configure_the_plotter;
   759.
   760.       begin  -- set_graph_plotting_pen
   761.          ensure_not_at_end_of_line(settings_file);
   762.          begin
   763.             Get(settings_file, the_colour);
   764.          exception
   765.             when others =>
   766.                log_new_line;
   767.                log_line("***** Error in the plotter pen the_colour; default used.");
   768.          end;
   769.          ensure_not_at_end_of_line(settings_file);
   770.          begin
   771.             Get(settings_file, the_pen_size);
   772.          exception
   773.             when others =>
   774.                log_new_line;
   775.                log_line("***** Error in the plotter pen tip; default used.");
   776.          end;
   777.          configure_the_plotter;
   778.       exception
   779.          when Data_Error =>
   780.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   781.             configure_the_plotter;
   782.       end set_graph_plotting_pen;
   783.
   784.       procedure set_non_interactivity is
   785.       begin
   786.          noninteractive_usage_is_enabled := True;
   787.          set_time_limit;
   788.       end set_non_interactivity;
   789.
   790.       procedure save_poke_value is
   791.          -- W: full Word, U: Upper halfword, L: Lower halfword, S: Syllable, C: Character
   792.          address  : KDF9.address;
   793.          sub_word : Character;
   794.          position : KDF9.address;
   795.          value    : KDF9.word;
   796.          OK       : Boolean;
   797.       begin
   798.          begin
   799.             get_word(settings_file, KDF9.word(address));
   800.          exception
   801.             when others =>
   802.                log_line("***** Error in poke word address.");
   803.                Skip_Line(settings_file);
   804.                return;
   805.          end;
   806.
   807.          get_char(settings_file, sub_word);
   808.          if sub_word not in 'S' | 's' | 'C' | 'c' | 'L' | 'l' | 'U' | 'u' | 'W' | 'w' then
   809.             log_line(
   810.                      "***** Error in (sub)word indicator; "
   811.                    & sub_word
   812.                    & " should be W, L, U, S, or C."
   813.                     );
   814.             Skip_Line(settings_file);
   815.             return;
   816.          end if;
   817.
   818.          if sub_word in 'S' | 's' | 'C' | 'c' then
   819.             begin
   820.                get_word(settings_file, KDF9.word(position));
   821.                if (sub_word in 'S' | 's' and position > 5) or else
   822.                   (sub_word in 'C' | 'c' and position > 7)    then
   823.                   log_line(
   824.                            "***** Error in position given for a "
   825.                          & (if sub_word in 'S' | 's' then "syllable:" else "character:")
   826.                          & position'Image
   827.                          & " is too large, poke request ignored."
   828.                           );
   829.                   Skip_Line(settings_file);
   830.                   return;
   831.                end if;
   832.             exception
   833.                when others =>
   834.                   log_line(
   835.                            "***** Error in position given for a "
   836.                          & (if sub_word in 'S' | 's' then "syllable" else "character")
   837.                          & ", poke request ignored."
   838.                           );
   839.                   Skip_Line(settings_file);
   840.                   return;
   841.             end;
   842.          else
   843.             position := 0;
   844.          end if;
   845.
   846.          begin
   847.             get_word(settings_file, value);
   848.          exception
   849.             when others =>
   850.                log_line("***** Error in poked value.");
   851.                Skip_Line(settings_file);
   852.                return;
   853.          end;
   854.
   855.          if (sub_word in 'L' | 'l' | 'U' | 'u' and value > 2**24-1) or else
   856.                (sub_word in 'S' | 's'          and value > 255)     or else
   857.                   (sub_word in 'C' | 'c'       and value > 63)      then
   858.             log_line(
   859.                      "***** Error in poked value #"
   860.                    & oct_of(value)
   861.                    & ": out of range for a "
   862.                    & (case sub_word is
   863.                          when 'L' | 'l' | 'U' | 'u' => "halfword",
   864.                          when 'S' | 's'             => "syllable",
   865.                          when 'C' | 'c'             => "character",
   866.                          when others                => "word")
   867.                    & ", poke request ignored."
   868.                     );
   869.             Skip_Line(settings_file);
   870.             return;
   871.          end if;
   872.
   873.          add_to_poke_list(address, sub_word, position, value, OK);
   874.
   875.          if not OK then
   876.             log_line("***** Error setting up a poke: poke list full; request ignored.");
   877.          end if;
   878.
   879.       exception
   880.
   881.          when others =>
   882.             null;  -- to skip line at end of input loop
   883.
   884.       end save_poke_value;
   885.
   886.       procedure set_KDF9_configuration is
   887.          use equipment_IO;
   888.          use IOC.equipment;
   889.          d : IOC.equipment.kind := AD;
   890.          b : KDF9.buffer_number;
   891.       begin
   892.          if version = "1" then
   893.             for i in IOC.equipment.setup'Range loop
   894.             exit when end_of_line(settings_file);
   895.                get_word(settings_file, KDF9.word(b));
   896.                ensure_not_at_end_of_line(settings_file);
   897.                get(settings_file, d);
   898.                IOC.equipment.choice(b) := d;
   899.             end loop;
   900.          else
   901.             log_new_line;
   902.             log_line("The previous KDF9 configuration is still being used.");
   903.          end if;
   904.          if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   905.       exception
   906.          when others =>
   907.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   908.             IOC.equipment.choice := IOC.equipment.default;
   909.             log_new_line;
   910.             log_line("***** Error in the device configuration; defaults used.");
   911.       end set_KDF9_configuration;
   912.
   913.    begin -- get_settings_from_file
   914.
   915.       do_not_execute := False;
   916.       high_count := time_limit;
   917.       open_options_file(settings_file, the_settings_file_name);
   918.       if end_of_file(settings_file) then
   919.          raise End_Error;
   920.       end if;
   921.
   922.       loop
   923.          skip_to_next_nonempty_line(settings_file);
   924.          get(settings_file, flag);
   925.          case flag is
   926.             when 'A' | 'a' =>
   927.                set_authenticity;
   928.             when 'B' | 'b' =>
   929.                set_breakpoints;
   930.             when 'C' | 'c' =>
   931.                set_tracing_counts;
   932.             when 'D' | 'd' =>
   933.                set_diagnostic_mode;
   934.             when 'F' | 'f' =>
   935.                set_final_dumping_ranges;
   936.             when 'G' | 'g' =>
   937.                set_graph_plotting_pen;
   938.             when 'H' | 'h' =>
   939.                set_histogram_options;
   940.             when 'I' | 'i' =>
   941.                set_initial_dumping_ranges;
   942.             when 'K' | 'k' =>
   943.                set_KDF9_configuration;
   944.             when 'L' | 'l' =>
   945.                set_time_limit;
   946.             when 'N' | 'n' =>
   947.                set_non_interactivity;
   948.                time_limit := offline_time_limit;
   949.             when 'O' |'o' =>
   950.                set_this_miscellany_flag(flag);
   951.             when 'P' | 'p' =>
   952.                save_poke_value;
   953.             when 'Q' | 'q' =>
   954.                do_not_execute := True;
   955.                raise End_Error;
   956.             when 'R' | 'r' =>
   957.                set_tracing_range;
   958.             when 'S' | 's' =>
   959.                set_store_points;
   960.             when 'T' | 't' =>
   961.                set_execution_mode;
   962.             when 'V' | 'v' =>
   963.                set_the_miscellany_flags;
   964.             when 'W' | 'w' =>
   965.                set_watchpoints;
   966.             when 'X' | 'x' =>
   967.                only_signature_tracing := True;
   968.             when '-' | '/' =>
   969.                Skip_Line(settings_file);
   970.             when others =>
   971.                log_new_line;
   972.                log_line(
   973.                         "Invalid flag: """
   974.                       & flag
   975.                       & """ at line/column "
   976.                       & line_number'Image
   977.                       & "/"
   978.                       & Ada.Text_IO.Count'Image(Col(settings_file))
   979.                       & " of the settings file!"
   980.                        );
   981.                log_line(" ...  the valid flags are A,B,C,D,F,G,I,L,N,O,P,Q,R,S,T,V,W,X, -, and /");
   982.                Skip_Line(settings_file);
   983.          end case;
   984.       end loop;
   985.
   986.    exception
   987.
   988.       when Status_Error =>
   989.          null;
   990.
   991.       when End_Error =>
   992.          close_options_file(settings_file, the_settings_file_name);
   993.
   994.       when Data_Error =>
   995.          close_options_file(settings_file, the_settings_file_name);
   996.          log_new_line;
   997.          log_line("***** Error: invalid data in the settings file.");
   998.          log_line(
   999.                   "Reading of settings abandoned at line "
  1000.                 & line_number'Image
  1001.                 & " of '"
  1002.                 & the_settings_file_name
  1003.                 & "'."
  1004.                  );
  1005.
  1006.       when quit_request =>
  1007.          close_options_file(settings_file, the_settings_file_name);
  1008.          log_new_line;
  1009.          log_line(
  1010.                   "Quit requested at line "
  1011.                 & line_number'Image
  1012.                 & " of '"
  1013.                 & the_settings_file_name
  1014.                 & "'."
  1015.                  );
  1016.          log_rule;
  1017.          raise;
  1018.
  1019.       when error : others =>
  1020.          close_options_file(settings_file, the_settings_file_name);
  1021.          log_new_line;
  1022.          log_line(
  1023.                   "Failure in ee9; unexpected exception: "
  1024.                 & Exception_Information(error)
  1025.                 & " in 'get_settings_from_file'!"
  1026.                  );
  1027.          log_line(
  1028.                   "Reading of settings abandoned at line "
  1029.                 & line_number'Image
  1030.                 & " of '"
  1031.                 & the_settings_file_name
  1032.                 & "'!"
  1033.                  );
  1034.          log_rule;
  1035.          raise emulation_failure with "reading settings from file";
  1036.
  1037.    end get_settings_from_file;
  1038.
  1039. end settings;

Compiling: ../Source/settings.ads
Source file time stamp: 2021-02-08 01:19:37
Compiled at: 2021-02-08 17:20:57

     1. -- execution mode, diagnostic mode, and other emulation-control settings
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18. with logging.file;
    19.
    20. use  KDF9;
    21. use  logging.file;
    22.
    23. package settings is
    24.
    25. --
    26.    -- In fast mode: code runs as efficiently as possible, without diagnostics.
    27.
    28.    -- In trace mode: breakpoints, watchpoints, tracing address bounds and
    29.    --    tracing instruction count bounds are all honoured;
    30.    --       entries may be made in all the retrospective trace logs;
    31.    --          a digital execution signature may be computed,
    32.    --             and an instruction-frequency histogram may be generated.
    33.
    34.    -- In pause mode: execution proceeds as in trace mode;
    35.    --    additionally, breakpoints occur on every order executed within trace bounds.
    36.
    37.    -- The external mode is a user-interface value only. It requests the trace mode,
    38.    --    combined with the logging of a running trace to an external file.
    39. --
    40.
    41.    type diagnostic_mode is (fast_mode,
    42.                             trace_mode,
    43.                             pause_mode,
    44.                             external_mode);
    45.
    46.    procedure set_diagnostic_mode (a_diagnostic_mode : in settings.diagnostic_mode);
    47.
    48.    procedure change_diagnostic_mode_if_requested;
    49.
    50.    the_diagnostics_default  : constant settings.diagnostic_mode := fast_mode;
    51.    the_diagnostic_mode      : settings.diagnostic_mode := the_diagnostics_default;
    52.
    53.    the_external_trace_file_name : constant String := "trace.txt";
    54.    only_signature_tracing       : Boolean := False;
    55.    the_external_trace_file      : logging.file.output;
    56.
    57.    -- The diagnostic generation and display controls, inter alia.
    58.    -- The *_trace_is_wanted flags are set to True iff
    59.    --    they are both requested, and offered by the_diagnostic_mode.
    60.    -- These requests may be set by the miscellany and visibilty options.
    61.
    62.    miscellany_flags  : constant String := "abdefghikmnopqrstwxz.0123456789ABDEFGHIKMNOPQRSTWXZ";
    63.    miscellany_prompt : constant String := "{a|b|d|e|f|g|h|i|k|m|n|o|p|q|r|s|t|w|x|z|.|0..9}";
    64.
    65.    the_log_is_wanted,
    66.    API_logging_is_wanted,
    67.    the_signature_is_wanted,
    68.    any_histogram_is_wanted,
    69.    the_final_state_is_wanted,
    70.    interrupt_tracing_is_wanted,
    71.    peripheral_tracing_is_wanted,
    72.    flexowriter_output_is_wanted,
    73.    realistic_FW_output_is_wanted,
    74.    the_terminal_is_ANSI_compatible,
    75.    retrospective_tracing_is_wanted    : Boolean := True;
    76.
    77.    do_not_execute,
    78.    debugging_is_enabled,
    79.    the_signature_is_enabled,
    80.    the_histogram_is_enabled,
    81.    pre_overlay_state_is_enabled,
    82.    the_external_trace_is_enabled,
    83.    the_interrupt_trace_is_enabled,
    84.    noninteractive_usage_is_enabled,
    85.    the_peripheral_trace_is_enabled,
    86.    the_retrospective_trace_is_enabled : Boolean := False;
    87.
    88.    -- This option may also be set by an authenticity option (see KDF9).
    89.    authentic_timing_is_enabled : Boolean := False;
    90.
    91.    -- In boot_mode: a Director program is read from TR0 and executed
    92.    --    in Director state, with full use of the emulated hardware.
    93.    -- In program_mode: a user program is read from TR0 and executed
    94.    --    in program state, with basic OUTs implemented by the emulator.
    95.    -- In test_program_mode: a user program is read from TR0 and executed
    96.    --    in Director state, with basic OUTs implemented by the emulator,
    97.    --    this being useful for executing "hardware test" programs.
    98.
    99.    type execution_mode is (boot_mode, program_mode, test_program_mode);
   100.
   101.    procedure set_execution_mode (an_execution_mode : in settings.execution_mode);
   102.
   103.    the_execution_default : constant settings.execution_mode := program_mode;
   104.    the_execution_mode    :          settings.execution_mode := the_execution_default;
   105.
   106.    --
   107.    -- Tracing bound settings.
   108.    --
   109.
   110.    -- time_limit bounds the number of KDF9 instructions executed.
   111.
   112.    time_limit_default : constant KDF9.order_counter := KDF9.order_counter'Last;
   113.    time_slice         : constant KDF9.order_counter := 10_000;
   114.    offline_time_limit : constant KDF9.order_counter := 10_000 * time_slice;
   115.    time_limit         :          KDF9.order_counter := time_limit_default;
   116.
   117.
   118.    -- low_bound and high_bound bound the static scope of tracing.
   119.
   120.    low_bound_default  : constant KDF9.order_word_number := 0;
   121.    high_bound_default : constant KDF9.order_word_number := KDF9.order_word_number'Last;
   122.    low_bound          :          KDF9.order_word_number := low_bound_default;
   123.    high_bound         :          KDF9.order_word_number := high_bound_default;
   124.
   125.    -- nominated_address sets a flow analysis starting point for Usercode format dumps.
   126.    invalid_address    :          KDF9.order_word_number := 8191;
   127.    nominated_address  :          KDF9.order_word_number := invalid_address;
   128.
   129.    -- low_count and high_count bound the dynamic scope of tracing.
   130.
   131.    low_count_default  : constant KDF9.order_counter := 0;
   132.    high_count_default : constant KDF9.order_counter := time_limit_default;
   133.    low_count          :          KDF9.order_counter := low_count_default;
   134.    high_count         :          KDF9.order_counter := high_count_default;
   135.
   136.    -- Histogram bin frequencies less than histogram_cutoff are not logged.
   137.    the_profile_is_wanted  :          Boolean := False;
   138.    the_INS_plot_is_wanted :          Boolean := False;
   139.    cutoff_default         : constant Long_Float := 0.0;
   140.    histogram_cutoff       :          Long_Float := cutoff_default;
   141.
   142.    function is_invalid_miscellany_flag (option : in Character)
   143.    return Boolean;
   144.
   145.    procedure set_this_miscellany_flag (option : in Character);
   146.
   147.    -- do_not_execute is set if a quit is requested in the settings file.
   148.    -- The K option is not actioned unless version = "1".
   149.    procedure get_settings_from_file (version : in String);
   150.
   151.    procedure display_execution_modes (for_this_run : in String := "");
   152.
   153.    procedure quit_if_requested;
   154.
   155.    quit_was_requested          : Boolean := False;
   156.
   157.    the_diagnostic_mode_changed : Boolean := False;
   158.
   159.    loading_was_successful      : Boolean := False;
   160.
   161.    mode_change_request         : exception;
   162.
   163. end settings;

 1039 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/break_in.adb
Source file time stamp: 2021-01-11 00:14:12
Compiled at: 2021-02-08 17:20:57

     1. -- This communicates a break-in to the microcode.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with exceptions;
    18. with HCI;
    19. with KDF9;
    20. with POSIX;
    21. with finalize_ee9;
    22. with settings;
    23. with state_display;
    24.
    25. use  exceptions;
    26. use  HCI;
    27. use  KDF9;
    28. use  settings;
    29. use  state_display;
    30.
    31. package body break_in is
    32.
    33.    requested : Boolean := False
    34.       with Atomic, Volatile;
    35.
    36.    procedure note_user_interrupt is
    37.    begin
    38.       requested := True;
    39.    end note_user_interrupt;
    40.
    41.    function has_been_requested
    42.    return Boolean is
    43.    begin
    44.       return requested;
    45.    end has_been_requested;
    46.
    47.    procedure handler is
    48.    begin
    49.       requested := False;
    50.       interact("Break-in");
    51.       quit_if_requested;
    52.       if the_execution_mode = boot_mode then
    53.          effect(FLEX_interrupt);
    54.       else
    55.          show_current_state;
    56.       end if;
    57.       flush;
    58.    exception
    59.       when quit_request =>
    60.          finalize_ee9("Quit requested by the user");
    61.          POSIX.exit_program(0);
    62.    end handler;
    63.
    64. end break_in;

Compiling: ../Source/break_in.ads
Source file time stamp: 2021-01-10 23:52:34
Compiled at: 2021-02-08 17:20:57

     1. -- This conveys a break-in to the microcode.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package break_in is
    18.
    19.    function has_been_requested
    20.    return Boolean
    21.       with Inline;
    22.
    23.    procedure note_user_interrupt;
    24.
    25.    procedure handler;
    26.
    27. end break_in;

 64 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/dumping.adb
Source file time stamp: 2021-01-21 01:40:12
Compiled at: 2021-02-08 17:20:57

     1. -- Provide support for diagnostic core-dumping area descriptions.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with formatting;
    18. with state_display;
    19.
    20. use  formatting;
    21. use  state_display;
    22.
    23. package body dumping is
    24.
    25.    type poke_list_entry is
    26.       record
    27.          address  : KDF9.address;
    28.          sub_word : Character;
    29.          position : KDF9.address;
    30.          value    : KDF9.word;
    31.       end record;
    32.
    33.    length_of_poke_list : constant := 100;
    34.    poke_list_count     : Natural range 0 .. length_of_poke_list := 0;
    35.    poke_list           : array (Positive range 1 .. length_of_poke_list) of poke_list_entry;
    36.
    37.    use dumping.flag_support;
    38.
    39.    function dumping_flag (c : Character)
    40.    return dumping.flag
    41.    is (dumping.flag(to_upper(c)));
    42.
    43.    type area is
    44.       record
    45.          format_set  : dumping.format_set := no_dumping_flags;
    46.          first, last : KDF9.address;
    47.       end record;
    48.
    49.    no_dumping_area : constant dumping.area := (no_dumping_flags, 0, 0);
    50.
    51.    dumping_areas : array (dumping.area_number) of dumping.area := (others => no_dumping_area);
    52.
    53.    pre_dumping_area_count  : area_count := 0;
    54.    post_dumping_area_count : area_count := 0;
    55.
    56.    function nr_of_pre_dumping_areas
    57.    return dumping.area_count
    58.    is (pre_dumping_area_count);
    59.
    60.    function nr_of_post_dumping_areas
    61.    return dumping.area_count
    62.    is (post_dumping_area_count);
    63.
    64.    procedure request_a_dumping_area (format_set  : in dumping.format_set;
    65.                                      first, last : in KDF9.address;
    66.                                      was_stored  : out Boolean) is
    67.    begin
    68.       was_stored := False;
    69.       if pre_dumping_area_count+post_dumping_area_count = nr_of_dumping_areas then
    70.          return;
    71.       end if;
    72.       for d of dumping_areas loop
    73.          if d = (format_set, first, last) then
    74.             was_stored := True;
    75.             return;
    76.          end if;
    77.       end loop;
    78.       for d of dumping_areas loop
    79.          if d.format_set = no_dumping_flags then
    80.             d := (format_set, first, last);
    81.             was_stored := True;
    82.             if format_set/initial_flag then
    83.                pre_dumping_area_count := pre_dumping_area_count + 1;
    84.             end if;
    85.             if format_set/final_flag then
    86.                post_dumping_area_count := post_dumping_area_count + 1;
    87.             end if;
    88.             return;
    89.          end if;
    90.       end loop;
    91.    end request_a_dumping_area;
    92.
    93.    procedure print_formatted_area (d : in dumping.area) is
    94.       format_set  : constant dumping.format_set := d.format_set;
    95.       first       : constant KDF9.address := d.first;
    96.       last        : constant KDF9.address := d.last;
    97.    begin
    98.       if format_set/tape_code_flag then
    99.          show_core_in_tape_code(first, last);
   100.       end if;
   101.       if format_set/normal_flag then
   102.          show_core_in_case_normal(first, last);
   103.       end if;
   104.       if format_set/shift_flag then
   105.          show_core_in_case_shift(first, last);
   106.       end if;
   107.       if format_set/ card_code_flag then
   108.          show_core_in_card_code(first, last);
   109.       end if;
   110.       if format_set/printer_flag then
   111.          show_core_in_print_code(first, last);
   112.       end if;
   113.       if format_set/ASCII_flag then
   114.          show_core_in_Latin_1(first, last);
   115.       end if;
   116.       if format_set/word_flag then
   117.          show_core_as_word_forms(first, last);
   118.       end if;
   119.       if format_set/Usercode_flag then
   120.          show_core_as_Usercode((KDF9.order_word_number(first), 0),
   121.                                (KDF9.order_word_number(last), 0),
   122.                                 octal_option => not format_set/decimal_flag);
   123.       end if;
   124.       if format_set/orders_flag then
   125.          show_core_as_syllables((KDF9.order_word_number(first), 0),
   126.                                 (KDF9.order_word_number( last), 0));
   127.       end if;
   128.    end print_formatted_area;
   129.
   130.    procedure print_dump_areas (flag : in dumping.flag; count : in dumping.area_count) is
   131.       Usercode_wanted : Boolean := False;
   132.    begin
   133.       if count = 0 then
   134.          return;
   135.       end if;
   136.       for d of dumping_areas loop
   137.          Usercode_wanted := Usercode_wanted or d.format_set/Usercode_flag;
   138.       end loop;
   139.       if Usercode_wanted then
   140.          mark_all_code_blocks_and_data_blocks;
   141.       end if;
   142.       for d of dumping_areas loop
   143.          if d.format_set/flag then
   144.             print_formatted_area(d);
   145.          end if;
   146.       end loop;
   147.    end print_dump_areas;
   148.
   149.    procedure print_prerun_dump_areas is
   150.    begin
   151.       print_dump_areas(initial_flag, pre_dumping_area_count);
   152.    end print_prerun_dump_areas;
   153.
   154.    procedure print_postrun_dump_areas is
   155.    begin
   156.       print_dump_areas(final_flag, post_dumping_area_count);
   157.    end print_postrun_dump_areas;
   158.
   159.    procedure remove_dump_areas (flag : in dumping.flag; count : in out dumping.area_count) is
   160.    begin
   161.       if count = 0 then
   162.          return;
   163.       end if;
   164.       for d of dumping_areas loop
   165.          if d.format_set/flag then
   166.             d := no_dumping_area;
   167.          end if;
   168.       end loop;
   169.       count := 0;
   170.    end remove_dump_areas;
   171.
   172.    procedure remove_prerun_dump_areas is
   173.    begin
   174.       remove_dump_areas(initial_flag, pre_dumping_area_count);
   175.    end remove_prerun_dump_areas;
   176.
   177.    procedure remove_postrun_dump_areas is
   178.    begin
   179.       remove_dump_areas(final_flag, post_dumping_area_count);
   180.    end remove_postrun_dump_areas;
   181.
   182.    procedure add_to_poke_list (address    : in KDF9.address;
   183.                                sub_word   : in Character;
   184.                                position   : in KDF9.address;
   185.                                value      : in KDF9.word;
   186.                                was_stored : out Boolean) is
   187.    begin
   188.       if poke_list_count < length_of_poke_list then
   189.          poke_list_count := poke_list_count + 1;
   190.          poke_list(poke_list_count) := (address, sub_word, position, value);
   191.          was_stored := True;
   192.       else
   193.          was_stored := False;
   194.       end if;
   195.    end add_to_poke_list;
   196.
   197.    procedure poke_all_amendments is
   198.    begin
   199.       for p in 1..poke_list_count loop
   200.          poke(poke_list(p).address, poke_list(p).sub_word, poke_list(p).position, poke_list(p).value);
   201.       end loop;
   202.       poke_list_count := 0;
   203.    end poke_all_amendments;
   204.
   205. end dumping;

Compiling: ../Source/dumping.ads
Source file time stamp: 2021-01-21 01:37:48
Compiled at: 2021-02-08 17:20:57

     1. -- Provide support for diagnostic core-dumping area descriptions.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with generic_sets;
    18. with KDF9;
    19.
    20. use  KDF9;
    21.
    22. package dumping is
    23.
    24.    type flag is new Character range '@' .. 'Z';
    25.
    26.    no_flag        : constant dumping.flag := '@';
    27.    ASCII_flag     : constant dumping.flag := 'A';
    28.    card_code_flag : constant dumping.flag := 'C';
    29.    decimal_flag   : constant dumping.flag := 'D';
    30.    single_flag    : constant dumping.flag := 'E';
    31.    final_flag     : constant dumping.flag := 'F';
    32.    half_flag      : constant dumping.flag := 'H';
    33.    initial_flag   : constant dumping.flag := 'I';
    34.    normal_flag    : constant dumping.flag := 'N';
    35.    orders_flag    : constant dumping.flag := 'O';
    36.    printer_flag   : constant dumping.flag := 'L';
    37.    shift_flag     : constant dumping.flag := 'S';
    38.    tape_code_flag : constant dumping.flag := 'T';
    39.    Usercode_flag  : constant dumping.flag := 'U';
    40.    word_flag      : constant dumping.flag := 'W';
    41.
    42.    function dumping_flag (c : Character)
    43.    return dumping.flag;
    44.
    45.    package flag_support is new generic_sets(member => dumping.flag);
    46.
    47.    subtype format_set is flag_support.set;
    48.    use type format_set;
    49.
    50.    is_parameter_flag : constant dumping.format_set
    51.                      := (  decimal_flag
    52.                          | single_flag
    53.                          | half_flag
    54.                          | ASCII_flag
    55.                          | orders_flag
    56.                          | printer_flag
    57.                          | tape_code_flag
    58.                          | Usercode_flag
    59.                          | card_code_flag
    60.                          | normal_flag
    61.                          | shift_flag
    62.                          | word_flag     => True,
    63.                            others        => False
    64.                         );
    65.
    66.
    67.    is_epoch_flag : constant dumping.format_set
    68.                  := (  initial_flag
    69.                      | final_flag => True,
    70.                        others     => False
    71.                     );
    72.
    73.    is_dumping_flag  : constant dumping.format_set
    74.                     := is_parameter_flag or is_epoch_flag;
    75.
    76.    no_dumping_flags : constant dumping.format_set
    77.                     := flag_support.empty_set;
    78.
    79.    nr_of_dumping_areas : constant := 100;
    80.    subtype area_count  is Natural  range 0 .. nr_of_dumping_areas;
    81.    subtype area_number is Positive range 1 .. nr_of_dumping_areas;
    82.
    83.    procedure request_a_dumping_area (format_set  : in dumping.format_set;
    84.                                      first, last : in KDF9.address;
    85.                                      was_stored  : out Boolean);
    86.
    87.    procedure print_prerun_dump_areas;
    88.
    89.    procedure remove_prerun_dump_areas;
    90.
    91.    procedure print_postrun_dump_areas;
    92.
    93.    procedure remove_postrun_dump_areas;
    94.
    95.    function nr_of_pre_dumping_areas
    96.    return dumping.area_count;
    97.
    98.    function nr_of_post_dumping_areas
    99.    return dumping.area_count;
   100.
   101.    no_specification : constant String := "";
   102.
   103.    -- poke support is in dumping because it is needed at the same time during initialization.
   104.    procedure add_to_poke_list (address    : in KDF9.address;
   105.                                sub_word   : in Character;
   106.                                position   : in KDF9.address;
   107.                                value      : in KDF9.word;
   108.                                was_stored : out Boolean);
   109.
   110.    -- poke_all_amendments effects all stored pokes and then clears the poke list for reuse.
   111.    procedure poke_all_amendments;
   112.
   113. end dumping;

 205 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9.adb
Source file time stamp: 2021-02-07 23:43:20
Compiled at: 2021-02-08 17:20:58

     1. -- The machine-state manipulations used by the CPU microcode.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Unchecked_Conversion;
    18. --
    19. with exceptions;
    20. with KDF9.CPU;
    21. with KDF9.decoding;
    22. with KDF9.PHU_store;
    23. with KDF9.store;
    24. with settings;
    25. with tracing;
    26.
    27. use  exceptions;
    28. use  KDF9.CPU;
    29. use  KDF9.decoding;
    30. use  KDF9.PHU_store;
    31. use  KDF9.store;
    32. use  settings;
    33. use  tracing;
    34.
    35. package body KDF9 is
    36.
    37.    C_part_scale : constant := 2**32;
    38.    I_part_scale : constant := 2**16;
    39.
    40.    function as_Q (the_word : KDF9.word)
    41.    return KDF9.Q_register
    42.    is (
    43.        (C => KDF9.Q_part(KDF9.word'(the_word / C_part_scale)),
    44.         I => KDF9.Q_part(KDF9.word'(the_word / I_part_scale) and Q_part_mask),
    45.         M => KDF9.Q_part(the_word and Q_part_mask)
    46.        )
    47.       );
    48.
    49.    function as_word (the_Q : KDF9.Q_register)
    50.    return KDF9.word
    51.    is (KDF9.word(the_Q.C)*C_part_scale + KDF9.word(the_Q.I)*I_part_scale + KDF9.word(the_Q.M));
    52.
    53.    function sign_extended (Q : KDF9.Q_part)
    54.    return KDF9.word
    55.    is (unsign(CPU.signed(resign(Q))));
    56.
    57.    function as_word (the_link : KDF9.sjns_link)
    58.    return KDF9.word is
    59.       function link_Q_part is new Ada.Unchecked_Conversion(KDF9.sjns_link, KDF9.Q_part);
    60.    begin
    61.       return KDF9.word(link_Q_part(the_link));
    62.    end as_word;
    63.
    64.    function as_link (the_word : KDF9.word)
    65.    return KDF9.sjns_link is
    66.       function Q_part_link is new Ada.Unchecked_Conversion(KDF9.Q_part, KDF9.sjns_link);
    67.    begin
    68.       return Q_part_link(KDF9.Q_part(the_word and Q_part_mask));
    69.    end as_link;
    70.
    71.    procedure ensure_that_the_sjns_is_not_empty is
    72.    begin
    73.       if the_sjns_depth > 0             or else
    74.             the_CPU_state = Director_state then
    75.          return;
    76.       end if;
    77.       effect(NOUV_interrupt, "empty SJNS");
    78.    end ensure_that_the_sjns_is_not_empty;
    79.
    80.    procedure ensure_that_the_sjns_is_not_full is
    81.    begin
    82.       if the_sjns_depth < 16             or else
    83.             the_CPU_state = Director_state  then
    84.          return;
    85.       end if;
    86.       effect(NOUV_interrupt, "full SJNS");
    87.    end ensure_that_the_sjns_is_not_full;
    88.
    89.    procedure push (the_link : in KDF9.syllable_address) is
    90.    begin
    91.       the_sjns(the_sjns_depth) := KDF9.sjns_link(the_link);
    92.       the_sjns_depth := the_sjns_depth + 1;
    93.    end push;
    94.
    95.    function pop
    96.    return KDF9.syllable_address is
    97.    begin
    98.       the_sjns_depth := the_sjns_depth - 1;
    99.       return KDF9.syllable_address(the_sjns(the_sjns_depth));
   100.    end pop;
   101.
   102.    function sjns_top
   103.    return KDF9.sjns_link
   104.    is (the_sjns(the_sjns_depth-1));
   105.
   106.    function operand_words_needed (need : KDF9.nest_depth)
   107.    return String
   108.    is ("NEST lacks" & need'Image & " operand" & (if need > 1 then "s" else ""));
   109.
   110.    procedure ensure_that_the_nest_holds (at_least : in KDF9.nest_depth) is
   111.    begin
   112.       if the_nest_depth >= at_least          or else
   113.             the_CPU_state = Director_state      then
   114.          return;
   115.       end if;
   116.       effect(NOUV_interrupt, operand_words_needed(need => at_least-the_nest_depth));
   117.    end ensure_that_the_nest_holds;
   118.
   119.    procedure ensure_that_the_nest_holds_an_operand is
   120.    begin
   121.       ensure_that_the_nest_holds (at_least => 1);
   122.    end ensure_that_the_nest_holds_an_operand;
   123.
   124.    procedure ensure_that_the_nest_holds_2_operands is
   125.    begin
   126.       ensure_that_the_nest_holds (at_least => 2);
   127.    end ensure_that_the_nest_holds_2_operands;
   128.
   129.    function result_space_needed (need : KDF9.nest_depth)
   130.    return String
   131.    is (if need = 1 then "full NEST" else "NEST too full for" & need'Image & " operands");
   132.
   133.    procedure ensure_that_the_nest_has_room_for (at_least : in KDF9.nest_depth) is
   134.    begin
   135.       if the_nest_depth <= 16-at_least     or else
   136.             the_CPU_state = Director_state    then
   137.          return;
   138.       end if;
   139.       effect(NOUV_interrupt, result_space_needed(need => at_least - (16-the_nest_depth)));
   140.    end ensure_that_the_nest_has_room_for;
   141.
   142.    procedure ensure_that_the_nest_has_room_for_a_result is
   143.    begin
   144.       ensure_that_the_nest_has_room_for (at_least => 1);
   145.    end ensure_that_the_nest_has_room_for_a_result;
   146.
   147.    procedure ensure_that_the_nest_has_room_for_2_results is
   148.    begin
   149.       ensure_that_the_nest_has_room_for (at_least => 2);
   150.    end ensure_that_the_nest_has_room_for_2_results;
   151.
   152.    procedure push (the_word : in KDF9.word) is
   153.    begin
   154.       the_nest(the_nest_depth) := the_word;
   155.       the_nest_depth := the_nest_depth + 1;
   156.    end push;
   157.
   158.    function pop
   159.    return KDF9.word is
   160.    begin
   161.       return result : constant KDF9.word := the_nest(the_nest_depth - 1) do
   162.          the_nest(the_nest_depth - 1) := 0;
   163.          the_nest_depth := the_nest_depth - 1;
   164.       end return;
   165.    end pop;
   166.
   167.    procedure pop is
   168.    begin
   169.       the_nest(the_nest_depth - 1) := 0;
   170.       the_nest_depth := the_nest_depth - 1;
   171.    end pop;
   172.
   173.    function read_top
   174.    return KDF9.word
   175.    is (the_nest(the_nest_depth-1));
   176.
   177.    procedure write_top (the_word : in KDF9.word) is
   178.    begin
   179.       the_nest(the_nest_depth-1) := the_word;
   180.    end write_top;
   181.
   182.    procedure push (the_pair : in KDF9.pair) is
   183.    begin
   184.       the_nest(the_nest_depth+0) := the_pair.lsw;
   185.       the_nest(the_nest_depth+1) := the_pair.msw;
   186.       the_nest_depth := the_nest_depth + 2;
   187.    end push;
   188.
   189.    function pop
   190.    return KDF9.pair is
   191.    begin
   192.       return result : constant KDF9.pair := (msw => the_nest(the_nest_depth-1),
   193.                                              lsw => the_nest(the_nest_depth-2)) do
   194.          the_nest(the_nest_depth-1) := 0;
   195.          the_nest(the_nest_depth-2) := 0;
   196.          the_nest_depth := the_nest_depth - 2;
   197.       end return;
   198.    end pop;
   199.
   200.    procedure pop_pair is
   201.    begin
   202.       the_nest(the_nest_depth-1) := 0;
   203.       the_nest(the_nest_depth-2) := 0;
   204.       the_nest_depth := the_nest_depth - 2;
   205.    end pop_pair;
   206.
   207.    function read_top
   208.    return KDF9.pair
   209.    is ((msw => the_nest(the_nest_depth-1), lsw => the_nest(the_nest_depth-2)));
   210.
   211.    procedure write_top (the_pair : in KDF9.pair) is
   212.    begin
   213.       the_nest(the_nest_depth-1) := the_pair.msw;
   214.       the_nest(the_nest_depth-2) := the_pair.lsw;
   215.    end write_top;
   216.
   217.
   218. --
   219.    -- Support for Director-only operations.
   220. --
   221.
   222.    -- Set BA (bits D38:47), CPL (D34:35) and NOL (D24:33).
   223.
   224.    procedure set_K1_register (setting : in KDF9.word) is
   225.    begin
   226.       BA  := KDF9.address(setting mod 2**10) * 2**5;
   227.       CPL := KDF9.priority((setting / 2**12) and 2#11#);
   228.       NOL := KDF9.address((setting / 2**14) mod 2**10) * 2**5 + 31;
   229.    end set_K1_register;
   230.
   231.    -- Set CPDAR (bits D32:47).
   232.
   233.    procedure set_K2_register (setting : in KDF9.word) is
   234.       CPDAR_Q : KDF9.Q_part := as_Q(setting).M;
   235.    begin
   236.       for i in KDF9.buffer_number loop
   237.          the_CPDAR(i) := (CPDAR_Q mod 2) = 1;
   238.          CPDAR_Q := CPDAR_Q / 2;
   239.       end loop;
   240.    end set_K2_register;
   241.
   242.    -- Set context (bits D0:1), nest_depth (D2:6) and sjns_depth (D7:11).
   243.
   244.    procedure set_K3_register (setting : in KDF9.word) is
   245.    begin
   246.       -- Save the current register values in the register bank.
   247.       register_bank(the_context).NEST := the_nest;
   248.       register_bank(the_context).SJNS := the_sjns;
   249.       register_bank(the_context).Q_store := the_Q_store;
   250.       -- Set the new context.
   251.       the_context := KDF9.context(KDF9.word'(setting / 2**46));
   252.       the_nest_depth := KDF9.nest_depth(setting / 2**41 mod 2**5);
   253.       the_sjns_depth := KDF9.sjns_depth(setting / 2**36 mod 2**5);
   254.       -- Restore the register values for the new context.
   255.       the_nest := register_bank(the_context).NEST;
   256.       the_sjns := register_bank(the_context).SJNS;
   257.       the_Q_store := register_bank(the_context).Q_store;
   258.    end set_K3_register;
   259.
   260.    a_jiffy : constant := 1.0 / 2.0**20;  -- a bit less than a microsecond
   261.
   262.    type seconds is delta a_jiffy range 0.0 .. 1000.0*366.0*24.0*3600.0;  -- 1000 leap years!
   263.
   264.    procedure update_the_elapsed_time;
   265.
   266.    -- Let the real elapsed time catch up with the_real_time virtual seconds.
   267.
   268.    procedure delay_until (the_real_time : in KDF9.us) is
   269.       quantum : constant seconds := seconds(2**10) * a_jiffy;  -- ca. TR character-read time of 1ms
   270.       the_lag : seconds;
   271.    begin
   272.        if the_real_time < the_last_delay_time then
   273.           the_last_delay_time := the_real_time;
   274.        end if;
   275.       the_lag := seconds(the_real_time - the_last_delay_time) * a_jiffy;
   276.       if the_lag >= quantum then  -- More than a quantum of virtual elapsed time has passed.
   277.          delay Duration(the_lag);
   278.          the_last_delay_time := the_real_time;
   279.       end if;
   280.      -- the_elapsed_time := the_real_time;
   281.       update_the_elapsed_time;
   282.    end delay_until;
   283.
   284.    procedure delay_by (the_delay_time : in KDF9.us) is
   285.    begin
   286.       if authentic_timing_is_enabled then
   287.          delay_until(the_clock_time + the_delay_time);
   288.       end if;
   289.    end delay_by;
   290.
   291.    -- Advance to the larger of the_CPU_time, the_elapsed_time, and the_last_delay_time.
   292.    -- Cap the increase to prevent a spurious double-clock (RESET) interrupt in Director.
   293.
   294.    procedure update_the_elapsed_time is
   295.       max_elapsed_time : constant KDF9.us := the_last_K4_time + 2**20 - 1;
   296.    begin
   297.       the_elapsed_time := KDF9.us'Max(the_elapsed_time, the_last_delay_time);
   298.       the_elapsed_time := KDF9.us'Max(the_elapsed_time, the_CPU_time);
   299.       if the_execution_mode = boot_mode and the_CPU_state = Director_state then
   300.          the_elapsed_time := KDF9.us'Min(the_elapsed_time, max_elapsed_time);
   301.       end if;
   302.    end update_the_elapsed_time;
   303.
   304.    -- The virtual elapsed time.
   305.
   306.    function the_clock_time
   307.    return KDF9.us is
   308.    begin
   309.       update_the_elapsed_time;
   310.       return the_elapsed_time;
   311.    end the_clock_time;
   312.
   313.    procedure advance_the_clock (past : in KDF9.us) is
   314.    begin
   315.       the_elapsed_time := KDF9.us'Max(the_elapsed_time, past);
   316.       update_the_elapsed_time;
   317.       if authentic_timing_is_enabled then
   318.          delay_until(the_elapsed_time);
   319.       end if;
   320.    end advance_the_clock;
   321.
   322.    procedure synchronize_the_real_and_virtual_times is
   323.    begin
   324.       if authentic_timing_is_enabled then
   325.          update_the_elapsed_time;
   326.          delay_until(the_elapsed_time);
   327.       end if;
   328.    end synchronize_the_real_and_virtual_times;
   329.
   330.    -- Get clock (bits D0:15) and RFIR (D16:31).
   331.
   332.    function get_K4_operand
   333.    return KDF9.word is
   334.
   335.       function RFIR_in_a_word
   336.       return KDF9.word is
   337.          result : KDF9.word := 0;
   338.       begin
   339.          for r of the_RFIR loop
   340.             result := result*2;
   341.             if r then
   342.                result := result or 1;
   343.             end if;
   344.          end loop;
   345.          return result;
   346.       end RFIR_in_a_word;
   347.
   348.       -- The KDF9's interval timing clock ticks once per 32 µs;
   349.       --    the emulator virtual time has a resolution of 1 µs.
   350.
   351.       time_now : constant KDF9.us := the_clock_time;
   352.       interval : constant KDF9.us := (time_now - the_last_K4_time);
   353.
   354.    begin
   355.       the_last_K4_time := time_now;
   356.       if interval / 32 >= 2**16 then
   357.          effect(RESET_interrupt, "double clock");
   358.          the_RFIR(RESET_interrupt) := True;
   359.       elsif interval / 32 >= 2**15 then
   360.          effect(CLOCK_interrupt, "time since a K4" & interval'Image & "us");
   361.          the_RFIR(CLOCK_interrupt) := True;  --?? why is this needed?
   362.       end if;
   363.       return (KDF9.word(interval / 32) * 2**32) or (RFIR_in_a_word * 2**16);
   364.    end get_K4_operand;
   365.
   366.    -- Get PHUi (bits D6i:6i+5, i = 0 .. 3).
   367.
   368.    function get_K5_operand
   369.    return KDF9.word
   370.    is (K5_operand);
   371.
   372.    -- Get context (bits D0:1), nest_depth (D2:6) and sjns_depth (D7:11).
   373.
   374.    function get_K7_operand
   375.    return KDF9.word
   376.    is (
   377.        (KDF9.word(the_context)    * 2**46) or
   378.        (KDF9.word(the_nest_depth) * 2**41) or
   379.        (KDF9.word(the_sjns_depth) * 2**36)
   380.       );
   381.
   382.    procedure reset_V_and_T is
   383.    begin
   384.       the_V_bit_is_set := False;
   385.       the_T_bit_is_set := False;
   386.    end reset_V_and_T;
   387.
   388.    procedure reset_the_internal_registers (the_new_state : in CPU_state) is
   389.    begin
   390.       -- Set the state of a newly bootstrapped CPU.
   391.       reset_V_and_T;
   392.       CIA := (0, 0);
   393.       CPL := 0;
   394.       BA  := 0;
   395.       NOL := max_address;
   396.       the_RFIR := (others => False);
   397.       ICR := 0;
   398.       the_CPU_time := 0;
   399.       the_elapsed_time := 0;
   400.       the_last_delay_time := 0;
   401.       the_last_K4_time := 0;
   402.       the_CPU_state := the_new_state;
   403.       the_CPDAR := (0 => True, others => False);  -- FW0 is always allocated.
   404.    end reset_the_internal_registers;
   405.
   406.    empty_nest : constant NEST := (others => 0);
   407.    empty_sjns : constant SJNS := (others => (0, 0));
   408.    empty_Q_s  : constant Q_store := (others => (0, 0, 0));
   409.
   410.    procedure reset_the_CPU_state is
   411.    begin
   412.       the_context := 0;
   413.       for bank of register_bank loop
   414.          bank := (NEST => empty_nest, SJNS => empty_sjns, Q_store => empty_Q_s);
   415.       end loop;
   416.       the_nest_depth := 0;
   417.       the_nest       := empty_nest;
   418.       the_sjns_depth := 0;
   419.       the_sjns       := empty_sjns;
   420.       the_Q_store    := empty_Q_s;
   421.       if the_execution_mode = program_mode then
   422.          reset_the_internal_registers(program_state);
   423.       else
   424.          reset_the_internal_registers(Director_state);
   425.       end if;
   426.       -- Setting NIA must follow program loading, as it fetches E0 into the IWBs.
   427.       set_NIA_to((0, 0));
   428.    end reset_the_CPU_state;
   429.
   430.    procedure reset_the_program_state is
   431.    begin
   432.       the_nest_depth := 0;
   433.       the_nest       := empty_nest;
   434.       the_sjns_depth := 0;
   435.       the_sjns       := empty_sjns;
   436.       reset_V_and_T;
   437.       the_CPDAR := (0 => True, others => False);  -- FW0 is always allocated.
   438.       -- Setting NIA must follow program loading, as it fetches E0 into the IWBs.
   439.       set_NIA_to((0, 0));
   440.    end reset_the_program_state;
   441.
   442.    procedure effect (this_interrupt : in KDF9.interrupt_number; message : in String := "") is
   443.       return_address : KDF9.syllable_address;
   444.    begin
   445.       take_note_of_interrupt(this_interrupt, message);
   446.       the_RFIR(this_interrupt) := True;
   447.       case the_execution_mode is
   448.          when boot_mode =>
   449.             -- Interrupts are either effected or deferred to Director.
   450.             if the_CPU_state = program_state or else this_interrupt = RESET_interrupt then
   451.                -- Effect an actual interrupt into Director.
   452.                if this_interrupt in LOV_interrupt | OUT_interrupt then
   453.                   return_address := CIA;  -- Restart the interrupted instruction.
   454.                else
   455.                   return_address := NIA;  -- Proceed after the interrupted instruction.
   456.                end if;
   457.                if the_sjns_depth < 16 then
   458.                   push(return_address);                  -- The program link fits into the SJNS.
   459.                else
   460.                   JB := KDF9.sjns_link(return_address);  -- The program link overwrites JB.
   461.                end if;
   462.                BA := 0;
   463.                fetching_normally := True;
   464.                set_NIA_to((0, 0));
   465.                the_CPU_state := Director_state;
   466.                raise abandon_this_order;
   467.             else
   468.                -- Defer: Director will eventually find any request left in the_RFIR.
   469.                -- NOUV is completely suppressed in Director state.
   470.                the_RFIR(NOUV_interrupt) := False;
   471.             end if;
   472.
   473.          when test_program_mode =>
   474.             -- Interrupts other than LOV and RESET are ignored.
   475.             -- There is no need to accurately emulate the address placed by the hardware in JB.
   476.             case this_interrupt is
   477.                when LOV_interrupt =>
   478.                   raise LOV_trap with message;
   479.                when RESET_interrupt =>
   480.                   raise RESET_trap with message;
   481.                when others =>
   482.                   null;
   483.             end case;
   484.
   485.          when program_mode =>
   486.             -- Interrupts other than LOV are treated as failures.
   487.             -- There is no need to accurately emulate the address placed by the hardware in JB.
   488.             case this_interrupt is
   489.                when PR_interrupt =>
   490.                   raise PR_trap with message;
   491.                when FLEX_interrupt =>
   492.                   raise FLEX_trap with message;
   493.                when LIV_interrupt =>
   494.                   raise LIV_trap with message;
   495.                when NOUV_interrupt =>
   496.                   raise NOUV_trap with message;
   497.                when EDT_interrupt =>
   498.                   raise EDT_trap with message;
   499.                when OUT_interrupt =>
   500.                   raise OUT_trap with message;
   501.                when LOV_interrupt =>
   502.                   raise LOV_trap with message;
   503.                when RESET_interrupt =>
   504.                   raise RESET_trap with message;
   505.                when others =>
   506.                   raise emulation_failure with "invalid RFI in KDF9.effect";
   507.             end case;
   508.       end case;
   509.    end effect;
   510.
   511.    procedure effect_clock_interrupt (interval : in KDF9.us)
   512.       with Inline => False;
   513.
   514.    procedure effect_clock_interrupt (interval : in KDF9.us) is
   515.    begin
   516.       effect(CLOCK_interrupt, interval'Image & " KDF9 us");
   517.    end effect_clock_interrupt;
   518.
   519.    procedure check_for_a_clock_interrupt is
   520.       interval : KDF9.us;
   521.    begin
   522.       -- Clock ticks are ignored in program_mode and test_program_mode.
   523.       -- In boot_mode:
   524.       --    they are actioned in program_state;
   525.       --    they are deferred in Director_state: Director will eventually find the time for itself.
   526.       if the_execution_mode = boot_mode and then
   527.             the_CPU_state = program_state   then
   528.          interval := (the_clock_time - the_last_K4_time);
   529.          if interval >= 2**20 then
   530.             effect_clock_interrupt(interval);
   531.          end if;
   532.       end if;
   533.    end check_for_a_clock_interrupt;
   534.
   535.    procedure fail_in_problem_program_state is
   536.    begin
   537.       case the_execution_mode is
   538.          when program_mode =>
   539.             -- The unprivileged program has attempted a privileged operation.
   540.             raise LIV_trap with "%Director-only instruction";
   541.          when test_program_mode =>
   542.             -- The privileged program is allowed to use privileged instructions.
   543.             return;
   544.          when boot_mode =>
   545.             if the_CPU_state = program_state then
   546.                -- Punt the error to Director.
   547.                effect(LIV_interrupt);
   548.             else
   549.                -- All privileged operations are permitted to Director.
   550.                return;
   551.             end if;
   552.       end case;
   553.    end fail_in_problem_program_state;
   554.
   555.    procedure LOV_if_user_mode (cause : in String) is
   556.    begin
   557.       -- LOV was TOTALLY suppressed in Director state.
   558.       if the_CPU_state /= Director_state then
   559.          set_NIA_to(CIA);
   560.          effect(LOV_interrupt, cause);
   561.       end if;
   562.    end LOV_if_user_mode;
   563.
   564.    -- The %  prepended to the_message aids parsing of exception error messages in failure shutdown.
   565.
   566.    procedure trap_illegal_instruction (the_message : in String := "invalid opcode") is
   567.    begin
   568.       -- The program has failed in a manner that could cause a LIV interrupt.
   569.       case the_execution_mode is
   570.          when program_mode
   571.             | test_program_mode =>
   572.             raise LIV_trap with "%" & the_message;
   573.          when boot_mode =>
   574.             if the_CPU_state = program_state then
   575.                -- Punt the problem to Director.
   576.                effect(LIV_interrupt, the_message);
   577.             else
   578.                -- The Director itself has gone seriously wrong.
   579.                -- LIV is impossible in Director, so ee9 takes responsibility for stopping the run
   580.                --    to avert consequential emulation failure.
   581.                raise Director_failure with "%" & the_message;
   582.             end if;
   583.       end case;
   584.    end trap_illegal_instruction;
   585.
   586.    procedure trap_operator_error (the_message : in String) is
   587.    begin
   588.       -- The program has failed for a reason, such as a misconfigured environment,
   589.       --    that is beyond its control and prevents further execution.
   590.       raise operator_error with "%" & the_message;
   591.    end trap_operator_error;
   592.
   593.    procedure trap_unimplemented_feature (the_message : in String) is
   594.    begin
   595.       -- The program has attempted to use something that ee9 does not (yet) support.
   596.       raise not_yet_implemented with "%" & the_message;
   597.    end trap_unimplemented_feature;
   598.
   599.    procedure trap_failing_OUT (OUT_number : in KDF9.word; the_message : in String) is
   600.       OUT_name : constant String := OUT_number'Image;
   601.    begin
   602.       -- The program has issued an invalid OUT.
   603.       raise OUT_error with "%" & OUT_name(2..OUT_name'Last) & ": " & the_message;
   604.    end trap_failing_OUT;
   605.
   606.    procedure trap_invalid_paper_tape (the_message : in String) is
   607.    begin
   608.       -- The paper tape file given to load or boot has defects.
   609.       raise invalid_paper_tape_file with "%" & the_message;
   610.    end trap_invalid_paper_tape;
   611.
   612.    procedure return_from_Director_to (new_IAR : in KDF9.syllable_address) is
   613.    begin
   614.       the_CPU_state := program_state;
   615.       set_NIA_to(new_IAR);
   616.    end return_from_Director_to;
   617.
   618.    procedure increment_by_1 (the_link : in out KDF9.syllable_address) is
   619.    begin
   620.       if the_link.syllable_index < 5 then
   621.          the_link.syllable_index := the_link.syllable_index + 1;
   622.       else
   623.          the_link.syllable_index := 0;
   624.          the_link.order_word_number     := the_link.order_word_number + 1;
   625.       end if;
   626.    end increment_by_1;
   627.
   628.    procedure increment_by_2 (the_link : in out KDF9.syllable_address) is
   629.    begin
   630.       if the_link.syllable_index < 4 then
   631.          the_link.syllable_index := the_link.syllable_index + 2;
   632.       else
   633.          the_link.syllable_index := the_link.syllable_index - 4;
   634.          the_link.order_word_number     := the_link.order_word_number + 1;
   635.       end if;
   636.    end increment_by_2;
   637.
   638.    procedure increment_by_3 (the_link : in out KDF9.syllable_address) is
   639.    begin
   640.       if the_link.syllable_index < 3 then
   641.          the_link.syllable_index := the_link.syllable_index + 3;
   642.       else
   643.          the_link.syllable_index := the_link.syllable_index - 3;
   644.          the_link.order_word_number     := the_link.order_word_number + 1;
   645.       end if;
   646.    end increment_by_3;
   647.
   648.    -- the_syllable_cache holds two instruction words, pre-split into syllables.
   649.    -- They would have been held in IWB0 and IWB1 by Main Control in the KDF9.
   650.
   651.    subtype syllable_cache_range is Natural range 0 .. 11;
   652.
   653.    the_syllable_cache  : array (syllable_cache_range) of KDF9.syllable;
   654.    the_cache_index     : syllable_cache_range   := 0;
   655.    the_cached_location : KDF9.order_word_number := 0;
   656.
   657.    function NIA
   658.    return KDF9.syllable_address
   659.    is (
   660.        if the_cache_index > 5 then
   661.           (the_cached_location, KDF9.syllable_index(the_cache_index-6))
   662.        else
   663.           (the_cached_location-1, KDF9.syllable_index(the_cache_index))
   664.       );
   665.
   666.    function NIA_word_number
   667.    return KDF9.order_word_number
   668.    is (the_cached_location - (if the_cache_index > 5 then 0 else 1));
   669.
   670.    procedure trap_an_invalid_order_address (new_NIA : in KDF9.syllable_address)
   671.       with Inline => False;
   672.
   673.    procedure trap_an_invalid_order_address (new_NIA : in KDF9.syllable_address) is
   674.    begin
   675.       if new_NIA.syllable_index = 6 then
   676.          effect(RESET_interrupt, "syllable number = 6");
   677.       elsif new_NIA.syllable_index = 7 then
   678.          effect(RESET_interrupt, "syllable number = 7");
   679.       else
   680.          effect(LIV_interrupt, "jump to 8191");  -- See EE Report K/GD y 82.
   681.       end if;
   682.    end trap_an_invalid_order_address;
   683.
   684.    procedure set_NIA_to (new_NIA : in KDF9.syllable_address) is
   685.       mask        : constant := 8#377#;
   686.       shift       : constant := 8#400#;
   687.       IWB0, IWB1  : KDF9.word;
   688.    begin
   689.       if new_NIA.order_word_number = 8191 or else
   690.             new_NIA.syllable_index > 5       then
   691.          trap_an_invalid_order_address(new_NIA);
   692.       end if;
   693.
   694.       IWB0 := fetch_word(KDF9.address(new_NIA.order_word_number) + 0);
   695.       IWB1 := fetch_word(KDF9.address(new_NIA.order_word_number) + 1);
   696.
   697.       the_cache_index := syllable_cache_range(new_NIA.syllable_index);
   698.       the_cached_location := new_NIA.order_word_number + 1;
   699.
   700.       the_syllable_cache(5+0) := KDF9.syllable(IWB0 and mask);
   701.       IWB0 := IWB0 / shift;
   702.       the_syllable_cache(4+0) := KDF9.syllable(IWB0 and mask);
   703.       IWB0 := IWB0 / shift;
   704.       the_syllable_cache(3+0) := KDF9.syllable(IWB0 and mask);
   705.       IWB0 := IWB0 / shift;
   706.       the_syllable_cache(2+0) := KDF9.syllable(IWB0 and mask);
   707.       IWB0 := IWB0 / shift;
   708.       the_syllable_cache(1+0) := KDF9.syllable(IWB0 and mask);
   709.       IWB0 := IWB0 / shift;
   710.       the_syllable_cache(0+0) := KDF9.syllable(IWB0);
   711.
   712.       the_syllable_cache(5+6) := KDF9.syllable(IWB1 and mask);
   713.       IWB1 := IWB1 / shift;
   714.       the_syllable_cache(4+6) := KDF9.syllable(IWB1 and mask);
   715.       IWB1 := IWB1 / shift;
   716.       the_syllable_cache(3+6) := KDF9.syllable(IWB1 and mask);
   717.       IWB1 := IWB1 / shift;
   718.       the_syllable_cache(2+6) := KDF9.syllable(IWB1 and mask);
   719.       IWB1 := IWB1 / shift;
   720.       the_syllable_cache(1+6) := KDF9.syllable(IWB1 and mask);
   721.       IWB1 := IWB1 / shift;
   722.       the_syllable_cache(0+6) := KDF9.syllable(IWB1);
   723.    end set_NIA_to;
   724.
   725.    procedure set_NIA_to_the_INS_target_address is
   726.    begin
   727.       set_NIA_to(INS.target);
   728.    end set_NIA_to_the_INS_target_address;
   729.
   730.    procedure set_IWB0_and_IWB1_for_a_JCqNZS_loop is
   731.    begin
   732.       set_NIA_to((order_word_number => CIA.order_word_number-1, syllable_index => 0));
   733.       fetching_normally := False;
   734.    end set_IWB0_and_IWB1_for_a_JCqNZS_loop;
   735.
   736.    procedure go_back_to_the_start_of_IWB0 is
   737.    begin
   738.       the_cache_index := 0;
   739.    end go_back_to_the_start_of_IWB0;
   740.
   741.    procedure continue_after_JCqNZS is
   742.    begin
   743.       if CIA.syllable_index = 4 and the_cached_location = CIA.order_word_number then
   744.          set_NIA_to((order_word_number => CIA.order_word_number+1, syllable_index => 0));
   745.       end if;
   746.       fetching_normally := True;
   747.    end continue_after_JCqNZS;
   748.
   749.    function next_order_syllable
   750.    return KDF9.syllable
   751.       with Inline;
   752.
   753.    -- The amount by which the_CPU_time is increased, for a refill of both Instruction Word Buffers.
   754.
   755.    the_IWB01_reload_time : constant KDF9.us := 7;  -- microseconds
   756.
   757.    function next_order_syllable
   758.    return KDF9.syllable is
   759.       the_next_syllable : KDF9.syllable;
   760.    begin
   761.       the_next_syllable := the_syllable_cache(the_cache_index);
   762.       if the_cache_index < 11 then
   763.          the_cache_index := the_cache_index + 1;
   764.       elsif fetching_normally then
   765.          set_NIA_to((order_word_number => CIA.order_word_number+1, syllable_index => 0));
   766.          -- Part-overlapped order-word fetch: can happen only once per instruction,
   767.          --    and only before the instruction is executed, so no need to ADD to the_CPU_delta.
   768.          if (CIA.order_word_number and 15) < 10 then
   769.             -- The fudge factor applied here gives the Whetstone Benchmark its historical run time.
   770.             the_CPU_delta := the_IWB01_reload_time + 1;
   771.          else
   772.             the_CPU_delta := the_IWB01_reload_time;
   773.          end if;
   774.       else
   775.          go_back_to_the_start_of_IWB0;
   776.       end if;
   777.       return the_next_syllable;
   778.    end next_order_syllable;
   779.
   780.    procedure decode_syllable_0 (decoded : in out KDF9.decoded_order)
   781.       with Inline;
   782.
   783.    procedure decode_syllable_1 (decoded : in out KDF9.decoded_order)
   784.       with Inline;
   785.
   786.    procedure decode_a_jump_order (decoded : in out KDF9.decoded_order)
   787.       with Inline;
   788.
   789.    procedure decode_a_store_access_order (decoded : in out KDF9.decoded_order)
   790.       with Inline;
   791.
   792.    procedure decode_a_set_literal_order (decoded : in out KDF9.decoded_order)
   793.       with Inline;
   794.
   795.    procedure decode_syllable_0 (decoded : in out KDF9.decoded_order) is
   796.    begin
   797.       decoded.compressed_opcode := decoded.order.syllable_0 and 8#77#;
   798.       decoded.kind := KDF9.INS_kind(decoded.order.syllable_0 / 2**6);
   799.    end decode_syllable_0;
   800.
   801.    procedure process_syllable_0_of_INS is
   802.    begin
   803.       if the_cache_index > 5 then
   804.          CIA.order_word_number := the_cached_location;
   805.          CIA.syllable_index   := KDF9.syllable_index(the_cache_index-6);
   806.       else
   807.          CIA.order_word_number := the_cached_location - 1;
   808.          CIA.syllable_index   := KDF9.syllable_index(the_cache_index);
   809.       end if;
   810.       INS.order.syllable_0 := next_order_syllable;
   811.       INS.compressed_opcode := INS.order.syllable_0 and 8#77#;
   812.       INS.kind := KDF9.INS_kind(INS.order.syllable_0 / 2**6);
   813.    end process_syllable_0_of_INS;
   814.
   815.    procedure decode_syllable_1 (decoded : in out KDF9.decoded_order) is
   816.    begin
   817.       decoded.Qq := KDF9.Q_number(decoded.order.syllable_1 / 2**4);
   818.       decoded.Qk := KDF9.Q_number(decoded.order.syllable_1 and 8#17#);
   819.    end decode_syllable_1;
   820.
   821.    procedure process_syllable_1_of_INS is
   822.    begin
   823.       INS.order.syllable_1 := next_order_syllable;
   824.       INS.Qq := KDF9.Q_number(INS.order.syllable_1 / 2**4);
   825.       INS.Qk := KDF9.Q_number(INS.order.syllable_1 and 8#17#);
   826.    end process_syllable_1_of_INS;
   827.
   828.    syllable_nr_mask : constant := 2#111#;
   829.    D4_mask          : constant := 2#1000#;
   830.    D2_mask          : constant := 2#00_100_000#;
   831.    D0_thru_3_mask   : constant := 2#11_110_000#;
   832.
   833.    procedure decode_a_jump_order (decoded : in out KDF9.decoded_order) is
   834.    begin
   835.       decoded.target.syllable_index
   836.          := KDF9.syllable_index(decoded.order.syllable_0 and syllable_nr_mask);
   837.       decoded.target.order_word_number
   838.          := KDF9.order_word_number(decoded.order.syllable_2)
   839.           + KDF9.order_word_number(decoded.Qk) * 2**8
   840.           + KDF9.order_word_number(decoded.order.syllable_0 and D4_mask) * 2**9;
   841.       if (decoded.compressed_opcode and D2_mask) /= 0 then -- not JrCq ...
   842.          decoded.compressed_opcode := decoded.compressed_opcode and D0_thru_3_mask;
   843.       else
   844.          decoded.compressed_opcode := (decoded.compressed_opcode and D0_thru_3_mask) or KDF9.syllable(decoded.Qq);
   845.       end if;
   846.       if decoded.compressed_opcode = EXIT_n then
   847.          -- The syllable part of EXIT is actually a halfword offset,
   848.          --    so convert it to an actual syllable number.
   849.          if decoded.target.syllable_index = 2 then
   850.             decoded.target.syllable_index := 0;
   851.          else
   852.             decoded.target.syllable_index := 3;
   853.          end if;
   854.       end if;
   855.    end decode_a_jump_order;
   856.
   857.    procedure process_syllables_1_and_2_of_a_jump_order is
   858.    begin
   859.       process_syllable_1_of_INS;
   860.       INS.order.syllable_2 := next_order_syllable;
   861.       decode_a_jump_order(INS);
   862.    end process_syllables_1_and_2_of_a_jump_order;
   863.
   864.    D5_thru_7_mask : constant := 2#111#;
   865.    D5_and_7_mask  : constant := 2#101#;
   866.    D2_thru_4_mask : constant := 2#111000#;
   867.
   868.    procedure decode_a_store_access_order (decoded : in out KDF9.decoded_order) is
   869.    begin
   870.       decoded.operand := KDF9.Q_part(decoded.order.syllable_2) + KDF9.Q_part(decoded.Qk)*2**8
   871.                        + KDF9.Q_part((decoded.order.syllable_0 and D2_thru_4_mask)) * 2**9;
   872.       decoded.compressed_opcode := decoded.compressed_opcode and D5_thru_7_mask;
   873.    end decode_a_store_access_order;
   874.
   875.    procedure decode_a_set_literal_order (decoded : in out KDF9.decoded_order) is
   876.    begin
   877.       decoded.operand := KDF9.Q_part(decoded.order.syllable_2)
   878.                        + KDF9.Q_part(decoded.order.syllable_1)*2**8;
   879.       decoded.compressed_opcode := 2#100#;
   880.    end decode_a_set_literal_order;
   881.
   882.    procedure process_syllables_1_and_2_of_a_data_access_order is
   883.    begin
   884.       if (INS.compressed_opcode and D5_thru_7_mask) < SET then
   885.          process_syllable_1_of_INS;
   886.          INS.order.syllable_2 := next_order_syllable;
   887.          decode_a_store_access_order(INS);
   888.       elsif (INS.compressed_opcode and D5_and_7_mask) = SET then
   889.          -- SET n
   890.          INS.order.syllable_1 := next_order_syllable;
   891.          INS.order.syllable_2 := next_order_syllable;
   892.          decode_a_set_literal_order(INS);
   893.       else
   894.          INS.order.syllable_1 := next_order_syllable;
   895.          INS.order.syllable_2 := next_order_syllable;
   896.          decode_a_set_literal_order(INS);
   897.          INS.compressed_opcode := 7;  -- an invalid compression.
   898.       end if;
   899.    end process_syllables_1_and_2_of_a_data_access_order;
   900.
   901.    procedure decode_the_next_order is
   902.    begin
   903.       -- The CPU time is adjusted by a fudge factor to account for
   904.       --    the instruction-fetch time being partly overlapped.
   905.       process_syllable_0_of_INS;
   906.       case INS.kind is
   907.          when one_syllable_order =>
   908.             return;
   909.          when two_syllable_order =>
   910.             process_syllable_1_of_INS;
   911.          when normal_jump_order =>
   912.             process_syllables_1_and_2_of_a_jump_order;
   913.          when data_access_order =>
   914.             process_syllables_1_and_2_of_a_data_access_order;
   915.       end case;
   916.    end decode_the_next_order;
   917.
   918.    procedure decode (the_order : in out KDF9.decoded_order) is
   919.    begin
   920.       decode_syllable_0(the_order);
   921.       case the_order.kind is
   922.          when one_syllable_order =>
   923.             null;
   924.          when two_syllable_order =>
   925.             decode_syllable_1(the_order);
   926.          when normal_jump_order =>
   927.             decode_syllable_1(the_order);
   928.             decode_a_jump_order(the_order);
   929.          when data_access_order =>
   930.             if (the_order.compressed_opcode and D5_thru_7_mask) < SET then
   931.                decode_syllable_1(the_order);
   932.                decode_a_store_access_order(the_order);
   933.             elsif (INS.compressed_opcode and D5_and_7_mask) = SET then
   934.                -- SET n
   935.                decode_a_set_literal_order(the_order);
   936.             else
   937.                decode_a_set_literal_order(the_order);
   938.                INS.compressed_opcode := 7;  -- an invalid compression.
   939.             end if;
   940.       end case;
   941.    end decode;
   942.
   943.    -- the_order_at_NIA gets three syllables starting at [NIA].  It is FOR DIAGNOSTIC USE ONLY!
   944.    -- It does NOT update the CPU time properly and MUST NOT be used inside an instruction cycle.
   945.
   946.    function the_order_at_NIA
   947.    return KDF9.syllable_group is
   948.       saved_NIA : constant KDF9.syllable_address := NIA;
   949.       result    : KDF9.syllable_group;
   950.    begin
   951.       result.syllable_0 := next_order_syllable;
   952.       result.syllable_1 := next_order_syllable;
   953.       result.syllable_2 := next_order_syllable;
   954.       set_NIA_to(saved_NIA);
   955.       return result;
   956.    end the_order_at_NIA;
   957.
   958.    -- This is the initial jump from the top halfword of E0 just after loading.
   959.
   960.    E0U : KDF9.word := 0;  -- N.B. the lower halfword is used for option flags.
   961.
   962.    procedure save_the_initial_jump is
   963.    begin
   964.       E0U := fetch_halfword(0, 0);
   965.    end save_the_initial_jump;
   966.
   967.    procedure restore_the_initial_jump is
   968.    begin
   969.        store_halfword(E0U, 0, 0);
   970.    end restore_the_initial_jump;
   971.
   972.    function the_initial_jump_was_corrupted
   973.    return Boolean
   974.    is (E0U /= fetch_halfword(0, 0));
   975.
   976.    function is_an_invalid_order (decoded : KDF9.decoded_order)
   977.    return Boolean
   978.    is (
   979.        (decoded.kind = data_access_order and then (decoded.order.syllable_0 and 2#101#) > 2#100#)
   980.          or else (decoded.kind = normal_jump_order and decoded.target.syllable_index > 5)
   981.             -- 0 is now treated as a valid DUMMY0 order for KAlgol
   982.                or else decoded.order.syllable_0 = 8#006#
   983.                   or else decoded.order.syllable_0 = 8#040#
   984.                      or else decoded.order.syllable_0 = 8#046#
   985.                         or else decoded.order.syllable_0 = 8#055#
   986.                            or else decoded.order.syllable_0 = 8#073#
   987.                               or else decoded.order.syllable_0 = 8#076#
   988.                                  or else decoded.order.syllable_0 = 8#150#
   989.       );
   990.
   991.    the_signature_hash : KDF9.word := 0;
   992.
   993.    function the_digital_signature
   994.    return KDF9.word
   995.    is (the_signature_hash);
   996.
   997.    function visible_state_hash
   998.    return KDF9.word
   999.       with Inline;
  1000.
  1001.    function visible_state_hash
  1002.    return KDF9.word is
  1003.       hash : KDF9.word;
  1004.    begin
  1005.       hash := rotate_word_right(the_signature_hash, 1) xor KDF9.word(ICR);
  1006.       hash := rotate_word_right(hash, 1) xor as_word(the_Q_store(INS.Qq));
  1007.       hash := rotate_word_right(hash, 1) xor as_word(the_Q_store(INS.Qk));
  1008.       if the_sjns_depth > 0 then
  1009.          for s in reverse KDF9.sjns_depth range 0 .. the_sjns_depth-1 loop
  1010.                hash := rotate_word_right(hash, 1) xor as_word(the_sjns(s));
  1011.          end loop;
  1012.       end if;
  1013.       if the_nest_depth > 0 then
  1014.          for n in reverse KDF9.nest_depth range 0 .. the_nest_depth-1 loop
  1015.                hash := rotate_word_right(hash, 1) xor the_nest(n);
  1016.          end loop;
  1017.       end if;
  1018.       return hash;
  1019.    end visible_state_hash;
  1020.
  1021.    procedure update_the_digital_signature is
  1022.    begin
  1023.       the_signature_hash := visible_state_hash;
  1024.    end update_the_digital_signature;
  1025.
  1026. end KDF9;

Compiling: ../Source/kdf9.ads
Source file time stamp: 2021-02-07 23:42:18
Compiled at: 2021-02-08 17:20:58

     1. -- The architecturally-defined data and register formats of the KDF9 computer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with System;
    18.
    19. package KDF9 is
    20.
    21.    --
    22.    --
    23.    -- The fundamental storage unit is the 48-bit word.
    24.    --
    25.    --
    26.
    27.    --
    28.    -- The 48-bit word, considered as an unsigned integer.
    29.    --
    30.
    31.    type word is mod 2**48;  -- Let the compiler choose the best Size for this.
    32.
    33.    word_mask : constant := 8#7777777777777777#;
    34.    min_word  : constant := 8#4000000000000000#;
    35.    max_word  : constant := 8#3777777777777777#;
    36.
    37.    all_zero_bits : constant KDF9.word := 0;
    38.    sign_bit      : constant KDF9.word := KDF9.min_word;
    39.    not_sign_bit  : constant KDF9.word := KDF9.max_word;
    40.    all_one_bits  : constant KDF9.word := KDF9.word_mask;
    41.
    42.
    43.    --
    44.    -- The 96-bit double word, considered as a pair of words.
    45.    --
    46.
    47.    type pair is
    48.       record
    49.          msw, lsw : KDF9.word;
    50.       end record;
    51.
    52.
    53.    --
    54.    -- The basic 16-bit operand.
    55.    --
    56.
    57.    type field_of_16_bits is mod 2**16;
    58.
    59.    --
    60.    -- The 16-bit word, considered as a field of a Q register.
    61.    --
    62.
    63.    type Q_part is new KDF9.field_of_16_bits;
    64.
    65.    Q_part_mask : constant := KDF9.Q_part'Last;
    66.
    67.    function sign_extended (Q : KDF9.Q_part)
    68.    return KDF9.word
    69.       with Inline;
    70.
    71.    --
    72.    -- The 16-bit word, considered as a buffer (DMA channel) number.
    73.    --
    74.
    75.    subtype buffer_number is KDF9.Q_part range 0 .. 15;
    76.
    77.    buffer_number_mask : constant := buffer_number'Last;
    78.
    79.    --
    80.    -- The 16-bit word, considered as a core-store address.
    81.    --
    82.
    83.    subtype address is KDF9.Q_part range 0 .. 8#77777#;
    84.
    85.    --
    86.    -- The Q-store element.
    87.    --
    88.
    89.    type Q_register is
    90.       record
    91.          C, I, M : KDF9.Q_part;
    92.       end record;
    93.
    94.    function as_Q (the_word : KDF9.word)
    95.    return KDF9.Q_register
    96.       with Inline;
    97.
    98.    function as_word (the_Q : KDF9.Q_register)
    99.    return KDF9.word
   100.       with Inline;
   101.
   102.
   103.    --
   104.    -- The 8-bit instruction syllable and its components.
   105.    --
   106.
   107.    type syllable is mod 2**8;
   108.
   109.    subtype compressed_opcode is KDF9.syllable range 0 .. 63;
   110.    subtype Q_number          is KDF9.syllable range 0 .. 15;
   111.
   112.    type syllable_group is
   113.       record
   114.          syllable_0, syllable_1, syllable_2 : KDF9.syllable := 0;
   115.       end record;
   116.
   117.
   118.    --
   119.    -- An instruction address.
   120.    --
   121.    -- N.B. 5 is the hardware's largest valid syllable address.
   122.    -- The values 6 and 7 are used as diagnostic flags by ee9.
   123.    -- They cause a RESET trap if encountered during execution.
   124.    --
   125.
   126.    type syllable_index    is mod 2**3;
   127.    type order_word_number is mod 2**13;
   128.
   129.    type syllable_address is
   130.       record
   131.          order_word_number : KDF9.order_word_number;
   132.          syllable_index    : KDF9.syllable_index;
   133.       end record;
   134.
   135.    --
   136.    -- An instruction address, in the packed format of a hardware (SJNS) link.
   137.    --
   138.
   139.    type sjns_link is new KDF9.syllable_address
   140.       with Size => 16;
   141.    for sjns_link'Bit_Order use System.Low_Order_First;
   142.    for sjns_link use
   143.       record
   144.          order_word_number at 0 range  0 .. 12;
   145.          syllable_index    at 0 range 13 .. 15;
   146.       end record;
   147.
   148.    function as_word (the_link : KDF9.sjns_link)
   149.    return KDF9.word;
   150.
   151.    function as_link (the_word : KDF9.word)
   152.    return KDF9.sjns_link;
   153.
   154.    procedure increment_by_1 (the_link : in out KDF9.syllable_address)
   155.       with Inline;
   156.
   157.    procedure increment_by_2 (the_link : in out KDF9.syllable_address)
   158.       with Inline;
   159.
   160.    procedure increment_by_3 (the_link : in out KDF9.syllable_address)
   161.       with Inline;
   162.
   163.
   164.    --
   165.    -- The KDF9 halfword. Each occupies 24 bits, packed 2 per word.
   166.    --
   167.
   168.    type halfword is mod 2**24;
   169.    halfword_mask : constant := 8#77_77_77_77#;
   170.
   171.    subtype halfword_number is KDF9.address range 0 .. 1;
   172.
   173.
   174.    --
   175.    -- The KDF9 character occupies six bits, and they are packed 8 per word.
   176.    -- The various character sets, and the symbol type, are defined in the package KDF9_char_sets.
   177.    --
   178.
   179.
   180.    --
   181.    --
   182.    --
   183.    -- The following types define the structure of the KDF9's programmable registers.
   184.    --
   185.    --
   186.    --
   187.
   188.
   189.    --
   190.    -- authenticity_mode is declared here instead of in settings, to avoid a cyclic dependency.
   191.    --
   192.
   193.    type authenticity_mode is (modern_times_mode, authentic_time_mode);
   194.
   195.    the_authenticity_default : constant KDF9.authenticity_mode := modern_times_mode;
   196.    the_authenticity_mode    :          KDF9.authenticity_mode := the_authenticity_default;
   197.
   198.
   199.    --
   200.    --
   201.    --
   202.    -- The following variables (the_nest, the_sjns and the_Q_store) constitute
   203.    --    the emulation microcode's fixed working set of registers.
   204.    -- ee9 (unlike the real KDF9) swaps them with register_bank(the_context)
   205.    --    when a context switch is made by the =K3 instruction.
   206.    -- The real KDF9 used register_bank(the_context) directly for operands.
   207.    -- ee9's approach improves host cache locality and avoids indexing overheads,
   208.    --    the trade off being microscopically increased context-switching time.
   209.    --
   210.    --
   211.    --
   212.
   213.    --
   214.    -- The NEST.
   215.    --
   216.
   217.    type nest_depth is mod 19;
   218.
   219.    type NEST is array (KDF9.nest_depth) of KDF9.word;
   220.
   221.    the_nest       : KDF9.NEST;
   222.    the_nest_depth : KDF9.nest_depth  := 0;
   223.
   224.    -- The ensure_that_the_nest_holds* procedures trap NOUV.
   225.    -- They are used to validate operations that reduce the NEST depth.
   226.
   227.    procedure ensure_that_the_nest_holds (at_least : in KDF9.nest_depth)
   228.       with Inline;
   229.
   230.    procedure ensure_that_the_nest_holds_an_operand
   231.       with Inline;
   232.
   233.    procedure ensure_that_the_nest_holds_2_operands
   234.       with Inline;
   235.
   236.    function operand_words_needed (need : KDF9.nest_depth)
   237.    return String
   238.       with Inline => False;
   239.
   240.    function result_space_needed (need : KDF9.nest_depth)
   241.    return String
   242.       with Inline => False;
   243.
   244.    function pop
   245.    return KDF9.word
   246.       with Inline;
   247.
   248.    procedure pop
   249.       with Inline;
   250.
   251.    procedure write_top (the_word : in KDF9.word)
   252.       with Inline;
   253.
   254.    function read_top
   255.    return KDF9.word
   256.       with Inline;
   257.
   258.    function pop
   259.    return KDF9.pair
   260.       with Inline;
   261.
   262.    procedure pop_pair
   263.       with Inline;
   264.
   265.    procedure write_top (the_pair : in KDF9.pair)
   266.       with Inline;
   267.
   268.    function read_top
   269.    return KDF9.pair
   270.       with Inline;
   271.
   272.    -- The ensure_that_the_nest_has_room_for* procedures trap NOUV.
   273.    -- They are used to validate operations that increase the NEST depth.
   274.
   275.    procedure ensure_that_the_nest_has_room_for (at_least : in KDF9.nest_depth)
   276.       with Inline;
   277.
   278.    procedure ensure_that_the_nest_has_room_for_a_result
   279.       with Inline;
   280.
   281.    procedure push (the_word : in KDF9.word)
   282.       with Inline;
   283.
   284.    procedure ensure_that_the_nest_has_room_for_2_results
   285.       with Inline;
   286.
   287.    procedure push (the_pair : in KDF9.pair)
   288.       with Inline;
   289.
   290.
   291.    --
   292.    -- The SJNS.
   293.    --
   294.
   295.    type sjns_depth is mod 17;
   296.
   297.    type SJNS is array (KDF9.sjns_depth) of KDF9.sjns_link;
   298.
   299.    the_sjns       : KDF9.SJNS;
   300.    JB             : KDF9.sjns_link renames the_sjns(16);
   301.    the_sjns_depth : KDF9.sjns_depth := 0;
   302.
   303.    procedure ensure_that_the_sjns_is_not_empty
   304.       with Inline;
   305.
   306.    function pop
   307.    return KDF9.syllable_address
   308.       with Inline;
   309.
   310.    function sjns_top
   311.    return KDF9.sjns_link
   312.       with Inline;
   313.
   314.    procedure ensure_that_the_sjns_is_not_full
   315.       with Inline;
   316.
   317.    procedure push (the_link : in KDF9.syllable_address)
   318.       with Inline;
   319.
   320.
   321.    --
   322.    -- The Q Store.
   323.    -- Q0 is kept permanently zeroised.
   324.    --
   325.
   326.    type Q_store is array (KDF9.Q_number) of KDF9.Q_register;
   327.
   328.    the_Q_store : KDF9.Q_store;
   329.
   330.
   331.    --
   332.    -- The Boolean registers.
   333.    --
   334.
   335.    the_V_bit_is_set : Boolean := False;
   336.    the_T_bit_is_set : Boolean := False;
   337.
   338.
   339.    --
   340.    --
   341.    -- The following are to do with maintaining the virtual time.
   342.    --
   343.    --
   344.
   345.    type us is mod 2**64;  -- The emulation clocks tick in microseconds (unlike KDF9's clock).
   346.
   347.    -- The virtual processor time.
   348.
   349.    the_CPU_time  : KDF9.us := 0;
   350.
   351.    -- The amount by which the_CPU_time is increased by an instruction execution.
   352.
   353.    the_CPU_delta : KDF9.us := 0;
   354.
   355.    -- The virtual elapsed time, capped to prevent a spurious double-clock (RESET) interrupt.
   356.
   357.    function the_clock_time
   358.    return KDF9.us
   359.       with Inline;
   360.
   361.    -- Advance to the largest of the_CPU_time, the_elapsed_time, the_last_delay_time, and past.
   362.    -- Cap the increase to prevent a spurious double-clock (RESET) interrupt in Director.
   363.    -- If necessary, pause execution until the real time equals the virtual elapsed time.
   364.
   365.    procedure advance_the_clock (past : in KDF9.us);
   366.
   367.    -- The virtual clock time at which the next IO interrupt is expected.
   368.
   369.    the_next_interrupt_time : KDF9.us := KDF9.us'Last;
   370.
   371.    -- Pause execution for the_delay_time in virtual microseconds.
   372.
   373.    procedure delay_by (the_delay_time : in KDF9.us);
   374.
   375.    -- If necessary, pause execution until the real time equals the virtual elapsed time.
   376.
   377.    procedure synchronize_the_real_and_virtual_times;
   378.
   379. ------------------------------------------------------------------------------------------------
   380.
   381.    --
   382.    --
   383.    -- The following registers are used only in Director state.
   384.    --
   385.    --
   386.
   387.
   388.    --
   389.    -- The following are to do with the K1 order.
   390.    --
   391.
   392.    type priority is mod 2**2;
   393.
   394.    -- CPL = priority level of the currently-executing problem program.
   395.
   396.    CPL : KDF9.priority;
   397.
   398.    -- BA = word address of first allocated word (NOT group number as in the KDF9).
   399.
   400.    BA  : KDF9.address;
   401.
   402.    -- NOL = word address of last allocated word (NOT group number as in the KDF9).
   403.
   404.    NOL : KDF9.address;
   405.
   406.    -- Set BA (setting bits D38:47), CPL (D34:35) and NOL (D24:33).
   407.
   408.    procedure set_K1_register (setting : in KDF9.word);
   409.
   410.
   411.    --
   412.    -- The following are to do with the =K2 order.
   413.    --
   414.
   415.    -- The Current Peripheral Device Allocation Register.
   416.
   417.    type CPDAR is array (KDF9.buffer_number) of Boolean
   418.       with Component_Size => 8, Convention => C;
   419.
   420.    the_CPDAR : KDF9.CPDAR;
   421.
   422.    -- Set CPDAR (setting bits D32 .. D47).
   423.
   424.    procedure set_K2_register (setting : in KDF9.word);
   425.
   426.
   427.    --
   428.    -- The following are to do with the =K3 and K7 orders.
   429.    --
   430.
   431.    type user_register_set is
   432.       record
   433.          NEST     : KDF9.NEST;
   434.          SJNS     : KDF9.SJNS;
   435.          Q_store  : KDF9.Q_store;
   436.       end record;
   437.
   438.
   439.    -- There are 4 sets of user registers.
   440.    -- The execution context is the number of the register set in active use.
   441.
   442.    type context is mod 2**2;
   443.
   444.    -- register_bank holds the currently inactive register sets.
   445.
   446.    register_bank : array(KDF9.context) of KDF9.user_register_set;
   447.
   448.    -- KDF9 actually indexed the register bank with the value of the_context,
   449.    --   but the emulator swaps register sets between register_bank and
   450.    --      the_nest, the_sjns, and the_Q_store (q.v.).
   451.
   452.    the_context : KDF9.context := 0;
   453.
   454.    -- Set context (bits D46:47), nest_depth (D41:45) and sjns_depth (D36:41).
   455.
   456.    procedure set_K3_register (setting : in KDF9.word);
   457.
   458.    -- Get BA (bits D0 .. D9), CPL (D12 .. D13) and NOL (D14 .. D23).
   459.
   460.    function get_K7_operand
   461.    return KDF9.word;
   462.
   463.
   464.    --
   465.    -- The following are to do with the K4 order.
   466.    --
   467.
   468.    type interrupt_number is range 22 .. 31;
   469.
   470.    -- higher PRiority PRogram unblocked by end of I/O, or INTQq on busy device
   471.    PR_interrupt    : constant KDF9.interrupt_number := 22;
   472.    PR_trap         : exception;
   473.
   474.    -- FLEXowriter interrupt from operator
   475.    FLEX_interrupt  : constant KDF9.interrupt_number := 23;
   476.    FLEX_trap       : exception;
   477.
   478.    -- Lock-In Violation (attempt at a disallowed operation)
   479.    LIV_interrupt   : constant KDF9.interrupt_number := 24;
   480.    LIV_trap        : exception;
   481.
   482.    -- Nest (or SJNS) Over/Underflow Violation
   483.    NOUV_interrupt  : constant KDF9.interrupt_number := 25;
   484.    NOUV_trap       : exception;
   485.
   486.    -- End of Director Transfer, or I/O priority inversion
   487.    EDT_interrupt   : constant KDF9.interrupt_number := 26;
   488.    EDT_trap        : exception;
   489.
   490.    -- OUT system call
   491.    OUT_interrupt   : constant KDF9.interrupt_number := 27;
   492.    OUT_trap        : exception;
   493.
   494.    -- Lock-Out Violation
   495.    LOV_interrupt   : constant KDF9.interrupt_number := 28;
   496.    LOV_trap        : exception;
   497.
   498.    -- invalid syllable number or 'double-clock'
   499.    RESET_interrupt : constant KDF9.interrupt_number := 29;
   500.    RESET_trap      : exception;
   501.
   502.    type RFIR is array (KDF9.interrupt_number) of Boolean;
   503.
   504.    the_RFIR : KDF9.RFIR := (others => False);
   505.
   506.    -- The time at which the last K4 order was executed.
   507.    the_last_K4_time : KDF9.us := 0;
   508.
   509.    -- Get clock (bits D0:15) and RFIR (D16:31), clearing both.
   510.    function get_K4_operand
   511.    return KDF9.word;
   512.
   513.    -- An interrupt is raised when 1 second expires outside Director;
   514.    --    the flag does not correspond to any RFIR bit.
   515.    CLOCK_interrupt : constant KDF9.interrupt_number := 31;
   516.    CLOCK_trap      : exception;
   517.
   518.    -- This is for tracing a return from Director;
   519.    --    the flag does not correspond to any RFIR bit.
   520.    EXITD_flag : constant KDF9.interrupt_number := 30;
   521.
   522.    -- abandon_this_order is raised
   523.    -- 1. when an interrupt is punted to Director
   524.    -- OR
   525.    -- 2. when an operation is attempted, in a program running under Director,
   526.    --    that is invalid but is not defined to cause a LIV interrupt.
   527.    abandon_this_order : exception;
   528.
   529.    --
   530.    -- The following are to do with the K5 order.
   531.    --
   532.
   533.    -- The Program Hold-Up register is internal to I/O Control.
   534.    -- Get PHUi (bits D6i .. 6i+5), i = 0 .. 3.
   535.
   536.    function get_K5_operand
   537.    return KDF9.word;
   538.
   539.
   540.    --
   541.    -- The following are to do with management of the CPU's internal state.
   542.    --
   543.
   544.    type CPU_state is (Director_state, program_state);
   545.
   546.    the_CPU_state : KDF9.CPU_state;
   547.
   548.    procedure reset_V_and_T;
   549.
   550.    procedure reset_the_CPU_state;
   551.
   552.    procedure reset_the_internal_registers (the_new_state : in CPU_state);
   553.
   554.    procedure fail_in_problem_program_state;
   555.
   556.    procedure LOV_if_user_mode (cause : in String);
   557.
   558.    procedure return_from_Director_to (new_IAR : in KDF9.syllable_address);
   559.
   560.    procedure effect (this_interrupt : in KDF9.interrupt_number; message : in String := "")
   561.       with Inline => False;
   562.
   563.    procedure check_for_a_clock_interrupt
   564.       with Inline;
   565.
   566.    procedure trap_illegal_instruction (the_message : in String := "invalid opcode")
   567.       with Inline => False;
   568.
   569.    procedure trap_operator_error (the_message : in String)
   570.       with Inline => False, No_Return;
   571.
   572.    procedure trap_unimplemented_feature (the_message : in String)
   573.       with Inline => False, No_Return;
   574.
   575.    procedure trap_failing_OUT (OUT_number : in KDF9.word; the_message : in String)
   576.       with Inline => False, No_Return;
   577.
   578.    procedure trap_invalid_paper_tape (the_message : in String)
   579.       with Inline => False, No_Return;
   580.
   581.    procedure reset_the_program_state;
   582.
   583.
   584.    --
   585.    --
   586.    -- Instruction fetch and decode.
   587.    --
   588.    --
   589.
   590.    -- These Instruction Address Registers are the nearest KDF9 has
   591.    --    to a conventional 'Program Counter' register.
   592.    -- NIA is significant only after an instruction has been decoded.
   593.
   594.    function NIA
   595.    return KDF9.syllable_address  -- the Next Instruction Address
   596.       with Inline;
   597.
   598.    function NIA_word_number
   599.    return KDF9.order_word_number
   600.       with Inline;
   601.
   602.    CIA : KDF9.syllable_address;  -- the Current Instruction Address
   603.
   604.    -- IWB0 and IWB1 in KDF9 contained the current 2 instruction words.
   605.    -- A 'short' loop, initiated by the JCqNZS instruction, ran entirely
   606.    --    inside the IWBs, obviating repeated instruction-fetch overhead.
   607.    -- Director exploits this in a loop that zeroizes the whole of core,
   608.    --    including that loop, which runs, immune to overwriting, in the IWBs.
   609.
   610.    procedure set_NIA_to (new_NIA : in KDF9.syllable_address)
   611.       with Inline;
   612.
   613.    procedure set_NIA_to_the_INS_target_address
   614.       with Inline;
   615.
   616.    procedure set_IWB0_and_IWB1_for_a_JCqNZS_loop
   617.       with Inline;
   618.
   619.    procedure go_back_to_the_start_of_IWB0
   620.       with Inline;
   621.
   622.    procedure continue_after_JCqNZS
   623.       with Inline;
   624.
   625.    -- Bits 0-1 of every order indicate its type as follows.
   626.
   627.    type INS_kind is mod 2**2;
   628.
   629.    one_syllable_order : constant := 0;
   630.    two_syllable_order : constant := 1;
   631.    normal_jump_order  : constant := 2;
   632.    data_access_order  : constant := 3;
   633.
   634.    type decoded_order is
   635.       record
   636.          order : KDF9.syllable_group := (0, 0, 0);
   637.          kind  : KDF9.INS_kind := 0;
   638.
   639.          -- The compressed_opcode is:
   640.          --    bits 2-7 of 1- and 2-syllable orders
   641.          --    bits 2-3|8-11 of normal jumps
   642.          --    bits 5-7 of SET and directly-addressed store access orders.
   643.          -- See the KDF9.decoding package.
   644.          compressed_opcode : KDF9.compressed_opcode := 0;
   645.
   646.           -- Qq is bits 8-11, Qk is bits 12-15.
   647.          Qq, Qk : KDF9.Q_number := 0;
   648.
   649.          -- For an jump instruction, syllable_index is bits 5-7.
   650.          target : KDF9.syllable_address;
   651.
   652.          -- For a data address or value (SET), operand is bits 2-4|12-23.
   653.          operand : KDF9.Q_part := 0;
   654.       end record;
   655.
   656.    INS : KDF9.decoded_order;  -- analogous to the INS register in Main Control
   657.
   658.    -- After decode_the_next_order:
   659.    --    INS contains the whole instruction at the address given by CIA,
   660.    --       with its components unpacked (not all are significant in every case).
   661.
   662.    procedure decode_the_next_order
   663.       with Inline;
   664.
   665.    procedure decode (the_order : in out KDF9.decoded_order)
   666.       with Inline;
   667.
   668.    procedure process_syllable_0_of_INS
   669.       with Inline;
   670.
   671.    procedure process_syllable_1_of_INS
   672.       with Inline;
   673.
   674.    procedure process_syllables_1_and_2_of_a_jump_order
   675.       with Inline;
   676.
   677.    procedure process_syllables_1_and_2_of_a_data_access_order
   678.       with Inline;
   679.
   680.    -- the_order_at_NIA gets three syllables starting at [NIA].
   681.    -- It is FOR DIAGNOSTIC USE ONLY!
   682.    -- It does NOT update the CPU time properly and must not be used inside an instruction cycle!
   683.
   684.    function the_order_at_NIA
   685.    return KDF9.syllable_group
   686.       with Inline;
   687.
   688.    -- Save E0U, lest the initial jump in E0 be corrupted during the run.
   689.    procedure save_the_initial_jump;
   690.
   691.    -- Restore E0U to its saved value.
   692.    procedure restore_the_initial_jump;
   693.
   694.    -- Check whether E0U has changed.
   695.    function the_initial_jump_was_corrupted
   696.    return Boolean;
   697.
   698.    -- True if the parameter is not a valid KDF9 instruction.
   699.
   700.    function is_an_invalid_order (decoded : KDF9.decoded_order)
   701.    return Boolean;
   702.
   703.
   704.    --
   705.    -- The Instruction Counter Register, ICR, (N.B. NOT a 'PROGRAM counter')
   706.    --   indicates the number of instructions executed by the KDF9.
   707.    --
   708.
   709.    type order_counter is mod 2**64;
   710.
   711.    ICR : KDF9.order_counter := 0;
   712.
   713.
   714.    --
   715.    -- The following support hashed execution-signature checking,
   716.    --    mainly for self-checking of new versions and ports.
   717.    --
   718.
   719.    function the_digital_signature
   720.    return KDF9.word;
   721.
   722.    procedure update_the_digital_signature
   723.       with Inline;
   724.
   725. private
   726.
   727.    the_elapsed_time    : KDF9.us := 0;
   728.    the_last_delay_time : KDF9.us := 0;
   729.
   730.    fetching_normally   : Boolean := True;
   731.
   732. end KDF9;

 1026 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-microcode.adb
Source file time stamp: 2021-01-21 03:10:51
Compiled at: 2021-02-08 17:20:58

     1. -- KDF9 ISP emulation - CPU microcode routines.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with break_in;
    18. with exceptions;
    19. with IOC;
    20. with IOC.dispatcher;
    21. with KDF9.CPU;
    22. with KDF9.decoding;
    23. with KDF9.EGDON;
    24. with KDF9.store;
    25. with KDF9.TSD;
    26. with KDF9.TSD.processes;
    27. with POSIX;
    28. with settings;
    29. with state_display;
    30. with tracing;
    31.
    32. use  exceptions;
    33. use  IOC;
    34. use  IOC.dispatcher;
    35. use  KDF9.CPU;
    36. use  KDF9.decoding;
    37. use  KDF9.EGDON;
    38. use  KDF9.store;
    39. use  KDF9.TSD;
    40. use  KDF9.TSD.processes;
    41. use  POSIX;
    42. use  settings;
    43. use  state_display;
    44. use  tracing;
    45.
    46. package body KDF9.microcode is
    47.
    48.    procedure do_a_one_syllable_order is
    49.       A, B, C, E : KDF9.word;
    50.       bit_count  : KDF9.word;
    51.       AB, CD     : KDF9.pair;
    52.       X, Y       : CPU.f48;
    53.       XY, ZT     : CPU.f96;
    54.    begin
    55.       case INS.compressed_opcode is
    56.
    57.          when 0 =>
    58.             -- The DUMMY order originally had code 0, before being changed to #17.
    59.             -- The Kidsgrove compiler continued to use code 0, so we must assume that,
    60.             --    despite the Manual, 0 continued to be a valid no-op order.
    61.             the_CPU_delta := the_CPU_delta + 1;
    62.
    63.          when VR =>
    64.             the_V_bit_is_set := False;
    65.             the_CPU_delta := the_CPU_delta + 1;
    66.
    67.          when TO_TR =>
    68.             ensure_that_the_nest_holds_an_operand;
    69.             if resign(pop) < 0 then
    70.                the_T_bit_is_set := True;
    71.             end if;
    72.             the_CPU_delta := the_CPU_delta + 2;
    73.
    74.          when BITS =>
    75.             write_top(cardinality(read_top));
    76.             the_CPU_delta := the_CPU_delta + 27;
    77.
    78.          when XF =>
    79.             ensure_that_the_nest_holds_2_operands;
    80.             X := pop;
    81.             Y := read_top;
    82.             write_top(CPU.f48'(Y * X));
    83.             the_CPU_delta := the_CPU_delta + 15;
    84.
    85.          when XDF =>
    86.             ensure_that_the_nest_holds_2_operands;
    87.             XY := read_top;
    88.             ZT := XY.lsw * XY.msw;
    89.             write_top(ZT);
    90.             the_CPU_delta := the_CPU_delta + 16;
    91.
    92.          when XPLUSF =>
    93.             ensure_that_the_nest_holds(at_least => 4);
    94.             XY := pop;
    95.             ZT := XY.lsw * XY.msw;
    96.             XY := read_top;
    97.             write_top(XY + ZT);
    98.             the_CPU_delta := the_CPU_delta + 18;
    99.
   100.          when NEGD =>
   101.             AB := read_top;
   102.             write_top( - AB);
   103.             the_CPU_delta := the_CPU_delta + 2;
   104.
   105.          when OR_9 =>
   106.             ensure_that_the_nest_holds_2_operands;
   107.             A := pop;
   108.             write_top(read_top or A);
   109.             the_CPU_delta := the_CPU_delta + 1;
   110.
   111.          when PERM =>
   112.             A := pop;
   113.             CD := pop;
   114.             push(A);
   115.             push(CD);
   116.             the_CPU_delta := the_CPU_delta + 2;
   117.
   118.          when TOB =>
   119.             ensure_that_the_nest_holds_2_operands;
   120.             A := pop;      -- the value
   121.             bit_count := cardinality(A);
   122.             B := read_top; -- the radixes
   123.             C := 0;
   124.
   125.             for i in 1 .. 8 loop
   126.                A := rotate_word_left(A, 6);
   127.                B := rotate_word_left(B, 6);
   128.                E := B and 8#77#; -- this radix
   129.                C := C*E + (A and 8#77#);
   130.             end loop;
   131.
   132.             write_top(C);
   133.             the_CPU_delta := the_CPU_delta + 2 + 4*KDF9.us(bit_count);
   134.
   135.          when ROUNDH =>
   136.             A := read_top;
   137.             write_top(resign(A) + 2**23);
   138.             the_CPU_delta := the_CPU_delta + 22;
   139.
   140.          when NEV =>
   141.             ensure_that_the_nest_holds_2_operands;
   142.             A := pop;
   143.             write_top(read_top xor A);
   144.             the_CPU_delta := the_CPU_delta + 2;
   145.
   146.          when ROUND =>
   147.             ensure_that_the_nest_holds_2_operands;
   148.             A := pop;
   149.             write_top(resign(A) + resign(shift_word_right(read_top, 46) and 1));
   150.             the_CPU_delta := the_CPU_delta + 1;
   151.
   152.          when DUMMY =>
   153.             the_CPU_delta := the_CPU_delta + 1;
   154.
   155.          when ROUNDF =>
   156.             ensure_that_the_nest_holds_2_operands;
   157.             XY := pop;
   158.             ZT := XY;
   159.             push(narrowed(XY));
   160.             the_CPU_delta := the_CPU_delta + 3;
   161.
   162.          when ROUNDHF =>
   163.             X := pop;
   164.             push(narrowed(X));
   165.             the_CPU_delta := the_CPU_delta + 3;
   166.
   167.          when MINUSDF =>
   168.             ensure_that_the_nest_holds(at_least => 4);
   169.             XY := pop;
   170.             ZT := read_top;
   171.             write_top(ZT - XY);
   172.             the_CPU_delta := the_CPU_delta + 12;
   173.
   174.          when PLUSDF =>
   175.             ensure_that_the_nest_holds(at_least => 4);
   176.             XY := pop;
   177.             ZT := read_top;
   178.             write_top(ZT + XY);
   179.             the_CPU_delta := the_CPU_delta + 12;
   180.
   181.          when FLOAT_9 =>
   182.             ensure_that_the_nest_holds_2_operands;
   183.             -- There is great uncertainty as to how the FLOAT/FLOATD orders handled scale factors
   184.             --   in N1 that lie outside the range allowed by the Manual, namely -128 <= N1 <= +127.
   185.             -- ee9 here takes a safety-first approach which is consistent with the
   186.             --    behaviour of the Kidsgrove sqrt function with arguments < 0.5º0.
   187.             A := shift_arithmetic(shift_logical(pop, +40), -40);
   188.             B := read_top;
   189.             write_top(KDF9.word(normalized(full_fraction => B, scaler => A)));
   190.
   191.          when FLOATD =>
   192.             ensure_that_the_nest_holds(at_least => 3);
   193.             A := shift_arithmetic(shift_logical(pop, +40), -40);
   194.             CD := read_top;
   195.             -- See §3.4 of Report K/GD.y.83, dated 6/12/1962.  It would seem to require this:
   196.             -- CD.lsw := CD.lsw and not 8#77#;  -- The 6 l.s.b. are lost.
   197.             -- The above is commented out because it gives the wrong answer with KAA01.
   198.             -- A post-document hardware modification is suspected.
   199.             reconstruct(CD, scaler => A);
   200.             write_top(CD);
   201.             the_CPU_delta := the_CPU_delta + 8;
   202.
   203.          when ABS_9 =>
   204.             write_top( abs resign(read_top));
   205.             the_CPU_delta := the_CPU_delta + 1;
   206.
   207.          when NEG =>
   208.             write_top( - resign(read_top));
   209.             the_CPU_delta := the_CPU_delta + 1;
   210.
   211.          when ABSF =>
   212.             X := read_top;
   213.             if resign(KDF9.word(X)) < 0 then
   214.                write_top( - X);
   215.                the_CPU_delta := the_CPU_delta + 4;
   216.             else
   217.                the_CPU_delta := the_CPU_delta + 1;
   218.             end if;
   219.
   220.          when NEGF =>
   221.             X := read_top;
   222.             write_top( - X);
   223.             the_CPU_delta := the_CPU_delta + 3;
   224.
   225.          when MAX =>
   226.             AB := read_top;
   227.             if resign(AB.lsw) >= resign(AB.msw) then
   228.                write_top(KDF9.pair'(msw => AB.lsw, lsw =>AB.msw));
   229.                the_V_bit_is_set := True;
   230.             end if;
   231.             the_CPU_delta := the_CPU_delta + 4;
   232.
   233.          when NOT_9 =>
   234.             A := read_top;
   235.             write_top(not A);
   236.             the_CPU_delta := the_CPU_delta + 1;
   237.
   238.          when XD =>
   239.             AB := read_top;
   240.             CD := AB.msw * AB.lsw;
   241.             write_top(CD);
   242.             the_CPU_delta := the_CPU_delta + 14;
   243.
   244.          when X_frac =>
   245.             ensure_that_the_nest_holds_2_operands;
   246.             A := pop;
   247.             write_top(as_word(CPU.fraction'(read_top * A)));
   248.             the_CPU_delta := the_CPU_delta + 15;
   249.
   250.          when MINUS =>
   251.             ensure_that_the_nest_holds_2_operands;
   252.             A := pop;
   253.             B := read_top;
   254.             write_top(resign(B) - resign(A));
   255.             the_CPU_delta := the_CPU_delta + 1;
   256.
   257.          when SIGN =>
   258.             ensure_that_the_nest_holds_2_operands;
   259.             A := pop;
   260.             B := read_top;
   261.             if B = A then
   262.                write_top(KDF9.word'(0));
   263.             elsif resign(B) > resign(A) then
   264.                write_top(KDF9.word'(1));
   265.             else
   266.                write_top(all_one_bits);
   267.             end if;
   268.             the_CPU_delta := the_CPU_delta + 3;
   269.
   270.          when ZERO =>
   271.             ensure_that_the_nest_has_room_for_a_result;
   272.             push(all_zero_bits);
   273.             the_CPU_delta := the_CPU_delta + 2;
   274.
   275.          when DUP =>
   276.             ensure_that_the_nest_has_room_for_a_result;
   277.             A := read_top;
   278.             push(A);
   279.             the_CPU_delta := the_CPU_delta + 2;
   280.
   281.          when DUPD =>
   282.             ensure_that_the_nest_has_room_for_2_results;
   283.             AB := read_top;
   284.             push(AB);
   285.             the_CPU_delta := the_CPU_delta + 4;
   286.
   287.          when DIVI =>
   288.             AB := read_top;
   289.             do_DIVI(L => AB.lsw,
   290.                     R => AB.msw,
   291.                     Quotient  => CD.lsw,
   292.                     Remainder => CD.msw);
   293.             write_top(CD);
   294.             the_CPU_delta := the_CPU_delta + 36;
   295.
   296.          when FIX =>
   297.             ensure_that_the_nest_holds_an_operand;
   298.             ensure_that_the_nest_has_room_for_a_result;
   299.             X := read_top;
   300.             write_top(fraction_word(X));
   301.             push(scaler(X));
   302.             the_CPU_delta := the_CPU_delta + 6;
   303.
   304.          when STR =>
   305.             ensure_that_the_nest_has_room_for_a_result;
   306.             A := read_top;
   307.             if resign(A) < 0 then
   308.                write_top(A and not_sign_bit);
   309.                push(all_one_bits);
   310.             else
   311.                push(all_zero_bits);
   312.             end if;
   313.             the_CPU_delta := the_CPU_delta + 3;
   314.
   315.          when CONT =>
   316.             ensure_that_the_nest_holds_2_operands;
   317.             A := pop;
   318.             B := read_top;
   319.             write_top(contracted(msw => A, lsw => B));
   320.             the_CPU_delta := the_CPU_delta + 2;
   321.
   322.          when REVD =>
   323.             AB := pop;
   324.             CD := pop;
   325.             push(AB);
   326.             push(CD);
   327.             the_CPU_delta := the_CPU_delta + 4;
   328.
   329.          when ERASE =>
   330.             ensure_that_the_nest_holds_an_operand;
   331.             pop;
   332.             the_CPU_delta := the_CPU_delta + 1;
   333.
   334.          when MINUSD =>
   335.             ensure_that_the_nest_holds(at_least => 4);
   336.             AB := pop;
   337.             CD := read_top;
   338.             write_top(CD - AB);
   339.             the_CPU_delta := the_CPU_delta + 3;
   340.
   341.          when AND_9 =>
   342.             ensure_that_the_nest_holds_2_operands;
   343.             A := pop;
   344.             write_top(read_top and A);
   345.             the_CPU_delta := the_CPU_delta + 1;
   346.
   347.          when PLUS =>
   348.             ensure_that_the_nest_holds_2_operands;
   349.             A := pop;
   350.             B := read_top;
   351.             write_top(resign(B) + resign(A));
   352.             the_CPU_delta := the_CPU_delta + 1;
   353.
   354.          when PLUSD =>
   355.             ensure_that_the_nest_holds(at_least => 4);
   356.             AB := pop;
   357.             CD := read_top;
   358.             write_top(CD + AB);
   359.             the_CPU_delta := the_CPU_delta + 3;
   360.
   361.          when DIV =>
   362.             ensure_that_the_nest_holds_2_operands;
   363.             AB := pop;
   364.             push(as_word(CPU.fraction'(AB.lsw / AB.msw)));
   365.             the_CPU_delta := the_CPU_delta + 36;
   366.
   367.          when DIVD =>
   368.             ensure_that_the_nest_holds(at_least => 3);
   369.             A := pop;
   370.             CD := pop;
   371.             do_DIVD(L => CD,
   372.                     R => A,
   373.                     Q => E);
   374.             push(E);
   375.             the_CPU_delta := the_CPU_delta + 36;
   376.
   377.          when DIVF =>
   378.             X := pop;
   379.             Y := read_top;
   380.             write_top(Y / X);
   381.             the_CPU_delta := the_CPU_delta + 36;
   382.
   383.          when DIVDF =>
   384.             ensure_that_the_nest_holds(at_least => 3);
   385.             Y := pop;
   386.             XY := pop;
   387.             push(XY / Y);
   388.             the_CPU_delta := the_CPU_delta + 35;
   389.
   390.          when DIVR =>
   391.             ensure_that_the_nest_holds(at_least => 3);
   392.             A := pop;
   393.             CD := read_top;
   394.             do_DIVR(L => CD,
   395.                     R => A,
   396.                     Quotient  => AB.msw,
   397.                     Remainder => AB.lsw);
   398.             write_top(AB);
   399.             the_CPU_delta := the_CPU_delta + 36;
   400.
   401.          when REV =>
   402.             AB := read_top;
   403.             write_top(KDF9.pair'(msw => AB.lsw, lsw =>AB.msw));
   404.             the_CPU_delta := the_CPU_delta + 1;
   405.
   406.          when CAB =>
   407.             AB := pop;
   408.             C := pop;
   409.             push(AB);
   410.             push(C);
   411.             the_CPU_delta := the_CPU_delta + 2;
   412.
   413.          when FRB =>
   414.             ensure_that_the_nest_holds_2_operands;
   415.             A := pop;      -- the value
   416.             bit_count := cardinality(A);
   417.             B := read_top; -- the radixes
   418.             C := 0;
   419.
   420.             for i in 1 .. 8 loop
   421.                E := B and 8#77#;
   422.                if E /= 0 then
   423.                   C := C or (A mod E);
   424.                   A := A / E;
   425.                else
   426.                   if A /= 0 then the_V_bit_is_set := True; end if;
   427.                end if;
   428.                B := shift_word_right(B, 6);
   429.                C := rotate_word_right(C, 6);
   430.             end loop;
   431.
   432.             if A /= 0 then
   433.                -- The value was too big for the representation; see Manual.
   434.                the_V_bit_is_set := True;
   435.             end if;
   436.             write_top(C);
   437.             the_CPU_delta := the_CPU_delta + 8 + 3*KDF9.us(bit_count);
   438.
   439.          when STAND =>
   440.             X := read_top;
   441.             write_top(normalized(X));
   442.             the_CPU_delta := the_CPU_delta + 5;
   443.
   444.          when NEGDF =>
   445.             XY := read_top;
   446.             write_top( - XY);
   447.             the_CPU_delta := the_CPU_delta + 9;
   448.
   449.          when MAXF =>
   450.             XY := read_top;
   451.             if XY.lsw >= XY.msw then
   452.                write_top(CPU.f96'(msw => XY.lsw, lsw =>XY.msw));
   453.                the_V_bit_is_set := True;
   454.             end if;
   455.             the_CPU_delta := the_CPU_delta + 6;
   456.
   457.          when PLUSF =>
   458.             ensure_that_the_nest_holds_2_operands;
   459.             X := pop;
   460.             Y := read_top;
   461.             write_top(Y + X);
   462.             the_CPU_delta := the_CPU_delta + 7;
   463.
   464.          when MINUSF =>
   465.             ensure_that_the_nest_holds_2_operands;
   466.             X := pop;
   467.             Y := read_top;
   468.             write_top(Y - X);
   469.             the_CPU_delta := the_CPU_delta + 7;
   470.
   471.          when SIGNF =>
   472.             ensure_that_the_nest_holds_2_operands;
   473.             XY := pop;
   474.             if KDF9.word(XY.lsw) = KDF9.word(XY.msw) then
   475.                push(all_zero_bits);
   476.             elsif XY.lsw < XY.msw then
   477.                push(all_one_bits);
   478.             else
   479.                push(KDF9.word(1));
   480.             end if;
   481.             the_CPU_delta := the_CPU_delta + 5;
   482.
   483.          when others =>
   484.             trap_illegal_instruction;
   485.
   486.       end case;
   487.    end do_a_one_syllable_order;
   488.
   489.
   490.    procedure do_an_IO_order is
   491.       IO_opcode   : constant KDF9.compressed_opcode := (INS.Qk and not manual_bit);
   492.       IO_operand  : constant KDF9.Q_register := the_Q_store(INS.Qq);
   493.       set_offline : constant Boolean         := (INS.Qk and manual_bit) /= 0;
   494.    begin
   495.       case INS.compressed_opcode is
   496.
   497.          when PAR_Qq =>
   498.             the_CPU_delta := the_CPU_delta + 11;
   499.             PAR(IO_operand, set_offline, the_T_bit_is_set);
   500.             the_CPU_delta := the_CPU_delta + 3;
   501.
   502.          when PIA_PIC_CLO_TLO_Qq =>
   503.             the_CPU_delta := the_CPU_delta + 15;
   504.             case IO_opcode is
   505.                when PIA_bits =>
   506.                   PIA(IO_operand, set_offline);
   507.                   the_CPU_delta := the_CPU_delta + 7;
   508.                when PIC_bits =>
   509.                   PIC(IO_operand, set_offline);
   510.                   the_CPU_delta := the_CPU_delta + 7;
   511.                when CLO_bits =>
   512.                   fail_in_problem_program_state;
   513.                   CLO(IO_operand, set_offline);
   514.                   the_CPU_delta := the_CPU_delta + 1;
   515.                when TLO_bits =>
   516.                   TLO(IO_operand, the_T_bit_is_set);
   517.                when others =>
   518.                   trap_illegal_instruction;
   519.             end case;
   520.
   521.          when PIB_PID_Qq =>
   522.             the_CPU_delta := the_CPU_delta + 15;
   523.             case IO_opcode is
   524.                when PIB_bits =>
   525.                   PIB(IO_operand, set_offline);
   526.                   the_CPU_delta := the_CPU_delta + 7;
   527.                when PID_bits =>
   528.                   PID(IO_operand, set_offline);
   529.                   the_CPU_delta := the_CPU_delta + 7;
   530.                when others =>
   531.                   trap_illegal_instruction;
   532.             end case;
   533.
   534.          when PIE_PIG_Qq =>
   535.             the_CPU_delta := the_CPU_delta + 15;
   536.             case IO_opcode is
   537.                when PIE_bits =>
   538.                   PIE(IO_operand, set_offline);
   539.                   the_CPU_delta := the_CPU_delta + 7;
   540.                when PIG_bits =>
   541.                   PIG(IO_operand, set_offline);
   542.                   the_CPU_delta := the_CPU_delta + 7;
   543.                when others =>
   544.                   trap_illegal_instruction;
   545.             end case;
   546.
   547.          when PIF_PIH_Qq =>
   548.             the_CPU_delta := the_CPU_delta + 15;
   549.             case IO_opcode is
   550.                when PIF_bits =>
   551.                   PIF(IO_operand, set_offline);
   552.                   the_CPU_delta := the_CPU_delta + 7;
   553.                when PIH_bits =>
   554.                   PIH(IO_operand, set_offline);
   555.                   the_CPU_delta := the_CPU_delta + 7;
   556.                when others =>
   557.                   trap_illegal_instruction;
   558.             end case;
   559.
   560.          when PMA_PMK_INT_Qq =>
   561.             the_CPU_delta := the_CPU_delta + 11;
   562.             case IO_opcode is
   563.                when PMA_bits =>
   564.                   PMA(IO_operand, set_offline);
   565.                when PMK_bits =>
   566.                   PMK(IO_operand, set_offline);
   567.                when INT_bits =>
   568.                   INT(IO_operand, set_offline);
   569.                when others =>
   570.                   trap_illegal_instruction;
   571.             end case;
   572.
   573.          when CT_PMB_PMC_BUSY_Qq =>
   574.             the_CPU_delta := the_CPU_delta + 11;
   575.             case IO_opcode is
   576.                when CTQ_bits =>
   577.                   -- if set_offline then MANUALQq else CTQq
   578.                   if set_offline                      or else
   579.                         the_CPU_state = Director_state   then
   580.                      MANUAL_CT(IO_operand, set_offline);
   581.                      the_CPU_delta := the_CPU_delta + 2;
   582.                   else
   583.                      trap_illegal_instruction; -- This will always LIV, as we are not in Director.
   584.                   end if;
   585.                when PMB_bits =>
   586.                   PMB(IO_operand, set_offline);
   587.                   the_CPU_delta := the_CPU_delta + 3;
   588.                when PMC_bits =>
   589.                   PMC(IO_operand, set_offline);
   590.                   the_CPU_delta := the_CPU_delta + 3;
   591.                when BUSY_bits =>
   592.                   BUSY(IO_operand, set_offline, the_T_bit_is_set);
   593.                   the_CPU_delta := the_CPU_delta + 2;
   594.                when others =>
   595.                   trap_illegal_instruction;
   596.             end case;
   597.
   598.          when PMD_PME_PML_Qq =>
   599.             the_CPU_delta := the_CPU_delta + 14;
   600.             case IO_opcode is
   601.                when PMD_bits =>
   602.                   PMD(IO_operand, set_offline);
   603.                   the_CPU_delta := the_CPU_delta + 5;
   604.                when PME_bits =>
   605.                   PME(IO_operand, set_offline);
   606.                   the_CPU_delta := the_CPU_delta + 5;
   607.                when PML_bits =>
   608.                   PML(IO_operand, set_offline);
   609.                   the_CPU_delta := the_CPU_delta + 5;
   610.                when others =>
   611.                   trap_illegal_instruction;
   612.             end case;
   613.
   614.          when PMF_PMG_Qq =>
   615.             the_CPU_delta := the_CPU_delta + 11;
   616.             case IO_opcode is
   617.                when PMF_bits =>
   618.                   PMF(IO_operand, set_offline);
   619.                   the_CPU_delta := the_CPU_delta + 3;
   620.                when PMG_bits =>
   621.                   fail_in_problem_program_state;
   622.                   the_CPU_delta := the_CPU_delta + 14;  -- ??
   623.                   PMG(IO_operand, set_offline);
   624.                 when others =>
   625.                   trap_illegal_instruction;
   626.             end case;
   627.
   628.          when POA_POC_POE_POF_PMH_Qq =>
   629.             the_CPU_delta := the_CPU_delta + 15;
   630.             case IO_opcode is
   631.                when POA_bits =>
   632.                   POA(IO_operand, set_offline);
   633.                   the_CPU_delta := the_CPU_delta + 7;
   634.                when POC_bits =>
   635.                   POC(IO_operand, set_offline);
   636.                   the_CPU_delta := the_CPU_delta + 7;
   637.                when POE_bits =>
   638.                   POE(IO_operand, set_offline);
   639.                   the_CPU_delta := the_CPU_delta + 4;
   640.                when POF_bits =>
   641.                   POF(IO_operand, set_offline);
   642.                   the_CPU_delta := the_CPU_delta + 4;
   643.                when PMH_bits =>
   644.                   fail_in_problem_program_state;
   645.                   SLO(IO_operand, set_offline);
   646.                   the_CPU_delta := the_CPU_delta + 1;
   647.                when others =>
   648.                   trap_illegal_instruction;
   649.             end case;
   650.
   651.          when POB_POD_Qq =>
   652.             the_CPU_delta := the_CPU_delta + 15;
   653.             case IO_opcode is
   654.                when POB_bits =>
   655.                   POB(IO_operand, set_offline);
   656.                   the_CPU_delta := the_CPU_delta + 7;
   657.                when POD_bits =>
   658.                   POD(IO_operand, set_offline);
   659.                   the_CPU_delta := the_CPU_delta + 7;
   660.                when others =>
   661.                   trap_illegal_instruction;
   662.             end case;
   663.
   664.          when POG_POL_Qq =>
   665.             the_CPU_delta := the_CPU_delta + 15;
   666.             case IO_opcode is
   667.                when POG_bits =>
   668.                   POG(IO_operand, set_offline);
   669.                   the_CPU_delta := the_CPU_delta + 7;
   670.                when POL_bits =>
   671.                   POL(IO_operand, set_offline);
   672.                   the_CPU_delta := the_CPU_delta + 7;
   673.                when others =>
   674.                   trap_illegal_instruction;
   675.             end case;
   676.
   677.          when POH_POK_Qq =>
   678.             the_CPU_delta := the_CPU_delta + 15;
   679.             case IO_opcode is
   680.                when POH_bits =>
   681.                   POH(IO_operand, set_offline);
   682.                   the_CPU_delta := the_CPU_delta + 7;
   683.                when POK_bits =>
   684.                   POK(IO_operand, set_offline);
   685.                   the_CPU_delta := the_CPU_delta + 7;
   686.                when others =>
   687.                   trap_illegal_instruction;
   688.             end case;
   689.
   690.          when others =>
   691.             trap_illegal_instruction;
   692.
   693.       end case;
   694.    end do_an_IO_order;
   695.
   696.
   697.    all_zero_Q_store : constant KDF9.Q_register := (C | I | M => 0);
   698.
   699.    procedure ensure_that_Q0_contains_zero (suspect : KDF9.Q_number)
   700.       with Inline;
   701.
   702.    procedure ensure_that_Q0_contains_zero (suspect : KDF9.Q_number) is
   703.    begin
   704.       if suspect = 0 then
   705.          the_Q_store(0) := all_zero_Q_store;  -- Override any assignment to Q0.
   706.       end if;
   707.    end ensure_that_Q0_contains_zero;
   708.
   709.    procedure auto_increment
   710.       with Inline;
   711.
   712.    procedure auto_increment is
   713.    begin
   714.       if INS.Qq /= 0 then
   715.          the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M + the_Q_store(INS.Qq).I;
   716.          the_Q_store(INS.Qq).C := the_Q_store(INS.Qq).C - 1;
   717.       end if;
   718.    end auto_increment;
   719.
   720.    function shift_count
   721.    return CPU.signed_Q_part
   722.       with Inline;
   723.
   724.    function shift_count
   725.    return CPU.signed_Q_part
   726.    is (
   727.        if (INS.order.syllable_1 and constant_bit) /= 0  then
   728.           resign(KDF9.Q_part(INS.order.syllable_1/2 xor 64)) - 64
   729.        else
   730.           resign((the_Q_store(INS.Qq).C and 255) xor 128) - 128
   731.       );
   732.
   733.
   734.    procedure do_a_two_syllable_order is
   735.       A  : KDF9.word;
   736.       AB : KDF9.pair;
   737.       CD : KDF9.pair;
   738.    begin
   739.       case INS.compressed_opcode is
   740.
   741.          when JCqNZS =>
   742.             if CIA.syllable_index = 5 then
   743.                -- KDF9 did not actually detect this error, and the JCqNZS instruction often worked,
   744.                --    unless broken-into by an interrupt, which returned to the word following that
   745.                --       containing the first syllable of the JCqNZS instruction.
   746.                -- I see no case for reproducing this behaviour.
   747.                trap_illegal_instruction ("JCqNZS instruction at syllable 5");
   748.             end if;
   749.             if the_Q_store(INS.Qq).C /= 0 then
   750.                if fetching_normally then
   751.                   set_IWB0_and_IWB1_for_a_JCqNZS_loop;
   752.                   the_CPU_delta := the_CPU_delta + 7;  -- Takes 11µs the first time it jumps.
   753.                end if;
   754.                -- The IWBs now contain the loop, so go to syllable 0 of IWB0.
   755.                go_back_to_the_start_of_IWB0;
   756.             else
   757.                continue_after_JCqNZS;
   758.             end if;
   759.             the_CPU_delta := the_CPU_delta + 4;
   760.
   761.          when MkMq =>
   762.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   763.             check_address_and_lockout(the_trace_address);
   764.             ensure_that_the_nest_has_room_for_a_result;
   765.             the_trace_operand := fetch_word(the_trace_address);
   766.             push(the_trace_operand);
   767.             the_CPU_delta := the_CPU_delta + 7;
   768.
   769.          when MkMqQ =>
   770.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   771.             check_address_and_lockout(the_trace_address);
   772.             ensure_that_the_nest_has_room_for_a_result;
   773.             the_trace_operand := fetch_word(the_trace_address);
   774.             push(the_trace_operand);
   775.             auto_increment;
   776.             the_CPU_delta := the_CPU_delta + 8;
   777.
   778.          when MkMqH =>
   779.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   780.             check_address_and_lockout(the_trace_address);
   781.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   782.             ensure_that_the_nest_has_room_for_a_result;
   783.             push(the_trace_operand);
   784.             the_CPU_delta := the_CPU_delta + 7;
   785.
   786.          when MkMqQH =>
   787.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   788.             check_address_and_lockout(the_trace_address);
   789.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   790.             ensure_that_the_nest_has_room_for_a_result;
   791.             push(the_trace_operand);
   792.             auto_increment;
   793.             the_CPU_delta := the_CPU_delta + 8;
   794.
   795.          when MkMqN =>
   796.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   797.             check_address_and_lockout(the_trace_address);
   798.             ensure_that_the_nest_has_room_for_a_result;
   799.             the_trace_operand := fetch_word(the_trace_address);
   800.             push(the_trace_operand);
   801.             the_CPU_delta := the_CPU_delta + 7;
   802.
   803.          when MkMqQN =>
   804.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   805.             check_address_and_lockout(the_trace_address);
   806.             ensure_that_the_nest_has_room_for_a_result;
   807.             the_trace_operand := fetch_word(the_trace_address);
   808.             push(the_trace_operand);
   809.             auto_increment;
   810.             the_CPU_delta := the_CPU_delta + 8;
   811.
   812.          when MkMqHN =>
   813.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   814.             check_address_and_lockout(the_trace_address);
   815.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   816.             ensure_that_the_nest_has_room_for_a_result;
   817.             push(the_trace_operand);
   818.             the_CPU_delta := the_CPU_delta + 7;
   819.
   820.          when MkMqQHN =>
   821.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   822.             check_address_and_lockout(the_trace_address);
   823.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   824.             ensure_that_the_nest_has_room_for_a_result;
   825.             push(the_trace_operand);
   826.             auto_increment;
   827.             the_CPU_delta := the_CPU_delta + 8;
   828.
   829.          when TO_MkMq =>
   830.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   831.             check_address_and_lockout(the_trace_address);
   832.             ensure_that_the_nest_holds_an_operand;
   833.             the_trace_operand := pop;
   834.             store_word(the_trace_operand, the_trace_address);
   835.             the_CPU_delta := the_CPU_delta + 7;
   836.
   837.          when TO_MkMqQ =>
   838.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   839.             check_address_and_lockout(the_trace_address);
   840.             ensure_that_the_nest_holds_an_operand;
   841.             the_trace_operand := pop;
   842.             store_word(the_trace_operand, the_trace_address);
   843.             auto_increment;
   844.             the_CPU_delta := the_CPU_delta + 8;
   845.
   846.          when TO_MkMqH =>
   847.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   848.             check_address_and_lockout(the_trace_address);
   849.             ensure_that_the_nest_holds_an_operand;
   850.             the_trace_operand := pop;
   851.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   852.             the_CPU_delta := the_CPU_delta + 7;
   853.
   854.          when TO_MkMqQH =>
   855.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   856.             check_address_and_lockout(the_trace_address);
   857.             ensure_that_the_nest_holds_an_operand;
   858.             the_trace_operand := pop;
   859.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   860.             auto_increment;
   861.             the_CPU_delta := the_CPU_delta + 8;
   862.
   863.          when TO_MkMqN =>
   864.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   865.             check_address_and_lockout(the_trace_address);
   866.             ensure_that_the_nest_holds_an_operand;
   867.             the_trace_operand := pop;
   868.             store_word(the_trace_operand, the_trace_address);
   869.             the_CPU_delta := the_CPU_delta + 7;
   870.
   871.          when TO_MkMqQN =>
   872.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   873.             check_address_and_lockout(the_trace_address);
   874.             ensure_that_the_nest_holds_an_operand;
   875.             the_trace_operand := pop;
   876.             store_word(the_trace_operand, the_trace_address);
   877.             auto_increment;
   878.             the_CPU_delta := the_CPU_delta + 8;
   879.
   880.          when TO_MkMqHN =>
   881.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   882.             check_address_and_lockout(the_trace_address);
   883.             ensure_that_the_nest_holds_an_operand;
   884.             the_trace_operand := pop;
   885.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   886.             the_CPU_delta := the_CPU_delta + 7;
   887.
   888.          when TO_MkMqQHN =>
   889.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   890.             check_address_and_lockout(the_trace_address);
   891.             ensure_that_the_nest_holds_an_operand;
   892.             the_trace_operand := pop;
   893.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   894.             auto_increment;
   895.             the_CPU_delta := the_CPU_delta + 8;
   896.
   897.          when M_PLUS_Iq =>
   898.             the_CPU_delta := the_CPU_delta + 4;
   899.             the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M + the_Q_store(INS.Qq).I;
   900.
   901.          when M_MINUS_Iq =>
   902.             the_CPU_delta := the_CPU_delta + 5;
   903.             the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M - the_Q_store(INS.Qq).I;
   904.
   905.          when NCq =>
   906.             the_CPU_delta := the_CPU_delta + 5;
   907.             the_Q_store(INS.Qq).C := - the_Q_store(INS.Qq).C;
   908.
   909.          when DCq =>
   910.             the_CPU_delta := the_CPU_delta + 3;
   911.             if INS.Qq /= 0 then
   912.                the_Q_store(INS.Qq).C := the_Q_store(INS.Qq).C - 1;
   913.             end if;
   914.
   915.          when POS1_TO_Iq =>
   916.             the_CPU_delta := the_CPU_delta + 3;
   917.             if INS.Qq /= 0 then
   918.                the_Q_store(INS.Qq).I := + 1;
   919.             end if;
   920.
   921.          when NEG1_TO_Iq =>
   922.             the_CPU_delta := the_CPU_delta + 3;
   923.             if INS.Qq /= 0 then
   924.                the_Q_store(INS.Qq).I := - 1;
   925.             end if;
   926.
   927.          when POS2_TO_Iq =>
   928.             the_CPU_delta := the_CPU_delta + 3;
   929.             if INS.Qq /= 0 then
   930.                the_Q_store(INS.Qq).I := + 2;
   931.             end if;
   932.
   933.          when NEG2_TO_Iq =>
   934.             the_CPU_delta := the_CPU_delta + 3;
   935.             if INS.Qq /= 0 then
   936.                the_Q_store(INS.Qq).I := - 2;
   937.             end if;
   938.
   939.          when CqTOQk =>
   940.             the_CPU_delta := the_CPU_delta + 4;
   941.             if INS.Qk /= 0 then
   942.                the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   943.             end if;
   944.
   945.          when IqTOQk =>
   946.             the_CPU_delta := the_CPU_delta + 4;
   947.             if INS.Qk /= 0 then
   948.                the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   949.             end if;
   950.
   951.          when MqTOQk =>
   952.             the_CPU_delta := the_CPU_delta + 4;
   953.             if INS.Qk /= 0 then
   954.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   955.             end if;
   956.
   957.          when QqTOQk =>
   958.             the_CPU_delta := the_CPU_delta + 4;
   959.             if INS.Qk /= 0 then
   960.                the_Q_store(INS.Qk) := the_Q_store(INS.Qq);
   961.             end if;
   962.
   963.          when CIqTOQk =>
   964.            the_CPU_delta := the_CPU_delta + 4;
   965.            if INS.Qk /= 0 then
   966.               the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   967.               the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   968.            end if;
   969.
   970.          when IMqTOQk =>
   971.             the_CPU_delta := the_CPU_delta + 4;
   972.             if INS.Qk /= 0 then
   973.                the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   974.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   975.             end if;
   976.
   977.          when CMqTOQk =>
   978.             the_CPU_delta := the_CPU_delta + 4;
   979.             if INS.Qk /= 0 then
   980.                the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   981.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   982.             end if;
   983.
   984.          when QCIMq =>
   985.             ensure_that_the_nest_has_room_for_a_result;
   986.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- Qq
   987.                push(as_word(the_Q_store(INS.Qq)));
   988.                the_CPU_delta := the_CPU_delta + 4;
   989.             elsif (INS.Qk and M_part_choice) /= 0 then       -- Mq
   990.                push(sign_extended(the_Q_store(INS.Qq).M));
   991.                the_CPU_delta := the_CPU_delta + 4;
   992.             elsif (INS.Qk and C_part_choice) /= 0 then       -- Cq
   993.                push(sign_extended(the_Q_store(INS.Qq).C));
   994.                the_CPU_delta := the_CPU_delta + 5;
   995.             elsif (INS.Qk and I_part_choice) /= 0 then       -- Iq
   996.                push(sign_extended(the_Q_store(INS.Qq).I));
   997.                the_CPU_delta := the_CPU_delta + 6;
   998.             else
   999.                trap_illegal_instruction;
  1000.             end if;
  1001.
  1002.          when TO_RCIMq =>
  1003.             ensure_that_the_nest_holds_an_operand;
  1004.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- =Qq
  1005.                the_Q_store(INS.Qq) := as_Q(pop);
  1006.                the_CPU_delta := the_CPU_delta + 2;
  1007.             elsif (INS.Qk and M_part_choice) /= 0 then       -- =[R]Mq
  1008.                the_Q_store(INS.Qq).M := KDF9.Q_part(pop and Q_part_mask);
  1009.                if (INS.Qk and reset_choice) /= 0 then
  1010.                   the_Q_store(INS.Qq).C := 0;
  1011.                   the_Q_store(INS.Qq).I := 1;
  1012.                   the_CPU_delta := the_CPU_delta + 3;
  1013.                else
  1014.                   the_CPU_delta := the_CPU_delta + 2;
  1015.                end if;
  1016.             elsif (INS.Qk and C_part_choice) /= 0 then       -- =[R]Cq
  1017.                the_Q_store(INS.Qq).C := KDF9.Q_part(pop and Q_part_mask);
  1018.                if (INS.Qk and reset_choice) /= 0 then
  1019.                   the_Q_store(INS.Qq).I := 1;
  1020.                   the_Q_store(INS.Qq).M := 0;
  1021.                   the_CPU_delta := the_CPU_delta + 3;
  1022.                else
  1023.                   the_CPU_delta := the_CPU_delta + 2;
  1024.                end if;
  1025.             elsif (INS.Qk and I_part_choice) /= 0 then       -- =[R]Iq
  1026.                the_Q_store(INS.Qq).I := KDF9.Q_part(pop and Q_part_mask);
  1027.                if (INS.Qk and reset_choice) /= 0 then
  1028.                   the_Q_store(INS.Qq).C := 0;
  1029.                   the_Q_store(INS.Qq).M := 0;
  1030.                   the_CPU_delta := the_CPU_delta + 3;
  1031.                else
  1032.                   the_CPU_delta := the_CPU_delta + 2;
  1033.                end if;
  1034.             else
  1035.                trap_illegal_instruction;
  1036.             end if;
  1037.             ensure_that_Q0_contains_zero(suspect => INS.Qq);
  1038.
  1039.          when ADD_TO_QCIMq =>
  1040.             ensure_that_the_nest_has_room_for_a_result;
  1041.             ensure_that_the_nest_holds_an_operand;
  1042.
  1043.             -- Because the following does not push the Q operand on to the NEST,
  1044.             --   it will not leave an authentic bit pattern in the NEST core stack,
  1045.             --      in the event of a subsequent NOUV.
  1046.             -- I take this to be of no importance.
  1047.
  1048.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- =+Qq
  1049.                the_Q_store(INS.Qq) := as_Q(as_word(the_Q_store(INS.Qq)) + pop);
  1050.                the_CPU_delta := the_CPU_delta + 5;
  1051.             elsif (INS.Qk and M_part_choice) /= 0 then       -- =+Mq
  1052.                the_Q_store(INS.Qq).M := KDF9.Q_part(Q_part_mask and
  1053.                                              (sign_extended(the_Q_store(INS.Qq).M) + pop));
  1054.                the_CPU_delta := the_CPU_delta + 5;
  1055.             elsif (INS.Qk and C_part_choice) /= 0 then       -- =+Cq
  1056.                the_Q_store(INS.Qq).C := KDF9.Q_part(Q_part_mask and
  1057.                                              (sign_extended(the_Q_store(INS.Qq).C) + pop));
  1058.                the_CPU_delta := the_CPU_delta + 6;
  1059.             elsif (INS.Qk and I_part_choice) /= 0 then       -- =+Iq
  1060.                the_Q_store(INS.Qq).I := KDF9.Q_part(Q_part_mask and
  1061.                                              (sign_extended(the_Q_store(INS.Qq).I) + pop));
  1062.                the_CPU_delta := the_CPU_delta + 7;
  1063.             else
  1064.                trap_illegal_instruction;
  1065.             end if;
  1066.             ensure_that_Q0_contains_zero(suspect => INS.Qq);
  1067.
  1068.          when SHA =>
  1069.             A := read_top;
  1070.             write_top(KDF9.word'(shift_arithmetic(A, shift_count)));
  1071.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1072.
  1073.          when SHAD =>
  1074.             AB := read_top;
  1075.             write_top(KDF9.pair'(shift_arithmetic(AB, shift_count)));
  1076.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1077.
  1078.          when MACC =>
  1079.             ensure_that_the_nest_holds(at_least => 4);
  1080.             AB := pop;
  1081.             AB := AB.msw * AB.lsw;
  1082.             CD := read_top;
  1083.             write_top(CD + shift_arithmetic(AB, shift_count));
  1084.             the_CPU_delta := the_CPU_delta + 15 + shift_time(Natural(abs shift_count));
  1085.
  1086.          when SHL =>
  1087.             write_top(KDF9.word'(shift_logical(read_top, shift_count)));
  1088.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1089.
  1090.          when SHLD =>
  1091.             write_top(KDF9.pair'(shift_logical(read_top, shift_count)));
  1092.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1093.
  1094.          when SHC =>
  1095.             write_top(shift_circular(read_top, shift_count));
  1096.             the_CPU_delta := the_CPU_delta + 3 + shift_time(Natural(abs shift_count));
  1097.
  1098.          when TO_Kq =>
  1099.             fail_in_problem_program_state;
  1100.             case INS.Qq is
  1101.                when K0 =>
  1102.                   if read_top /= all_zero_bits then
  1103.                      for w in all_zero_bits .. read_top mod 8 loop
  1104.                         POSIX.output_line("BLEEP!");
  1105.                      end loop;
  1106.                      delay 10.0;
  1107.                   end if;
  1108.                when K1 =>
  1109.                   set_K1_register(read_top);
  1110.                when K2 =>
  1111.                   set_K2_register(read_top);
  1112.                when K3 =>
  1113.                   set_K3_register(read_top);
  1114.                when others =>
  1115.                   trap_illegal_instruction;
  1116.             end case;
  1117.             the_CPU_delta := the_CPU_delta + 3;
  1118.
  1119.          when Kk =>
  1120.             fail_in_problem_program_state;
  1121.             ensure_that_the_nest_has_room_for_a_result;
  1122.             case INS.Qk is
  1123.                when K4 =>
  1124.                   push(get_K4_operand);
  1125.                   the_RFIR := (others => False);
  1126.                when K5 =>
  1127.                   push(get_K5_operand);
  1128.                when K7 =>
  1129.                   push(get_K7_operand);
  1130.                when others =>
  1131.                   trap_illegal_instruction;
  1132.             end case;
  1133.             the_CPU_delta := the_CPU_delta + 3;
  1134.
  1135.          when LINK =>
  1136.             if the_CPU_state = Director_state and the_sjns_depth = 0 then -- clear out JB
  1137.                push(all_zero_bits);
  1138.                the_sjns_depth := 0 - 1;
  1139.             else
  1140.                ensure_that_the_nest_has_room_for_a_result;
  1141.                ensure_that_the_sjns_is_not_empty;
  1142.                push(as_word(KDF9.sjns_link(KDF9.syllable_address'(pop))));
  1143.             end if;
  1144.             the_CPU_delta := the_CPU_delta + 4;
  1145.
  1146.          when TO_LINK =>
  1147.             ensure_that_the_sjns_is_not_full;
  1148.             ensure_that_the_nest_holds_an_operand;
  1149.             push(KDF9.syllable_address(as_link(pop)));
  1150.             the_CPU_delta := the_CPU_delta + 3;
  1151.
  1152.          when others =>
  1153.             do_an_IO_order;
  1154.
  1155.       end case;
  1156.    end do_a_two_syllable_order;
  1157.
  1158.    procedure do_a_jump_order is
  1159.       RA        : KDF9.syllable_address;
  1160.       A         : KDF9.word;
  1161.    begin
  1162.       fetching_normally := True;
  1163.
  1164.       case INS.compressed_opcode is
  1165.
  1166.          when Jr =>
  1167.             set_NIA_to_the_INS_target_address;
  1168.             the_CPU_delta := the_CPU_delta + 8;
  1169.
  1170.          when JSr =>
  1171.             if the_sjns_depth < 16 or else the_CPU_state = Director_state  then
  1172.                push(CIA);
  1173.                set_NIA_to_the_INS_target_address;
  1174.                the_CPU_delta := the_CPU_delta + 11;
  1175.             else
  1176.                effect(NOUV_interrupt, "full SJNS");
  1177.             end if;
  1178.
  1179.          when JrEQ =>
  1180.             if the_nest_depth >= 2 or else the_CPU_state = Director_state then
  1181.                A := pop;
  1182.                if A = read_top then
  1183.                   set_NIA_to_the_INS_target_address;
  1184.                   the_CPU_delta := the_CPU_delta + 12;
  1185.                else
  1186.                   the_CPU_delta := the_CPU_delta + 5;
  1187.                end if;
  1188.             else
  1189.                effect(NOUV_interrupt, operand_words_needed(need => 2-the_nest_depth));
  1190.             end if;
  1191.
  1192.          when JrNE =>
  1193.             if the_nest_depth >= 2 or else the_CPU_state = Director_state then
  1194.                A := pop;
  1195.                if A /= read_top then
  1196.                   set_NIA_to_the_INS_target_address;
  1197.                   the_CPU_delta := the_CPU_delta + 12;
  1198.                else
  1199.                   the_CPU_delta := the_CPU_delta + 5;
  1200.                end if;
  1201.             else
  1202.                effect(NOUV_interrupt, operand_words_needed(need => 2-the_nest_depth));
  1203.             end if;
  1204.
  1205.          when JrGTZ =>
  1206.             if the_nest_depth >= 1 or else the_CPU_state = Director_state then
  1207.                if resign(pop) > 0 then
  1208.                   set_NIA_to_the_INS_target_address;
  1209.                   the_CPU_delta := the_CPU_delta + 11;
  1210.                else
  1211.                   the_CPU_delta := the_CPU_delta + 4;
  1212.                end if;
  1213.             else
  1214.                effect(NOUV_interrupt, "empty NEST");
  1215.             end if;
  1216.
  1217.          when JrLTZ =>
  1218.             if the_nest_depth >= 1 or else the_CPU_state = Director_state then
  1219.                A := pop;
  1220.                if resign(A) < 0 then
  1221.                   set_NIA_to_the_INS_target_address;
  1222.                   the_CPU_delta := the_CPU_delta + 11;
  1223.                else
  1224.                   the_CPU_delta := the_CPU_delta + 4;
  1225.                end if;
  1226.             else
  1227.                effect(NOUV_interrupt, "empty NEST");
  1228.             end if;
  1229.
  1230.          when JrEQZ =>
  1231.             if the_nest_depth >= 1 or else the_CPU_state = Director_state then
  1232.                 if pop = all_zero_bits then
  1233.                   set_NIA_to_the_INS_target_address;
  1234.                   the_CPU_delta := the_CPU_delta + 11;
  1235.                else
  1236.                   the_CPU_delta := the_CPU_delta + 4;
  1237.                end if;
  1238.             else
  1239.                effect(NOUV_interrupt, "empty NEST");
  1240.             end if;
  1241.
  1242.          when JrLEZ =>
  1243.             if the_nest_depth >= 1 or else the_CPU_state = Director_state then
  1244.                if resign(pop) <= 0 then
  1245.                   set_NIA_to_the_INS_target_address;
  1246.                   the_CPU_delta := the_CPU_delta + 11;
  1247.                else
  1248.                   the_CPU_delta := the_CPU_delta + 4;
  1249.                end if;
  1250.             else
  1251.                effect(NOUV_interrupt, "empty NEST");
  1252.             end if;
  1253.
  1254.          when JrGEZ =>
  1255.             if the_nest_depth >= 1 or else the_CPU_state = Director_state then
  1256.                if resign(pop) >= 0 then
  1257.                   set_NIA_to_the_INS_target_address;
  1258.                   the_CPU_delta := the_CPU_delta + 11;
  1259.                else
  1260.                   the_CPU_delta := the_CPU_delta + 4;
  1261.                end if;
  1262.             else
  1263.                effect(NOUV_interrupt, "empty NEST");
  1264.             end if;
  1265.
  1266.          when JrNEZ =>
  1267.             if the_nest_depth >= 1 or else the_CPU_state = Director_state then
  1268.                if pop /= all_zero_bits then
  1269.                   set_NIA_to_the_INS_target_address;
  1270.                   the_CPU_delta := the_CPU_delta + 11;
  1271.                else
  1272.                   the_CPU_delta := the_CPU_delta + 4;
  1273.                end if;
  1274.             else
  1275.                effect(NOUV_interrupt, "empty NEST");
  1276.             end if;
  1277.
  1278.          when JrV =>
  1279.             if the_V_bit_is_set then
  1280.                the_V_bit_is_set := False;
  1281.                set_NIA_to_the_INS_target_address;
  1282.                the_CPU_delta := the_CPU_delta + 10;
  1283.             else
  1284.                the_CPU_delta := the_CPU_delta + 3;
  1285.             end if;
  1286.
  1287.          when JrNV =>
  1288.             if the_V_bit_is_set then
  1289.                the_V_bit_is_set := False;
  1290.                the_CPU_delta := the_CPU_delta + 3;
  1291.             else
  1292.                set_NIA_to_the_INS_target_address;
  1293.                the_CPU_delta := the_CPU_delta + 10;
  1294.             end if;
  1295.
  1296.          when JrEN =>
  1297.             the_trace_operand := KDF9.word(the_nest_depth);
  1298.             if the_nest_depth = 0 then
  1299.                set_NIA_to_the_INS_target_address;
  1300.                the_CPU_delta := the_CPU_delta + 10;
  1301.             else
  1302.                the_CPU_delta := the_CPU_delta + 3;
  1303.             end if;
  1304.
  1305.          when JrNEN =>
  1306.             the_trace_operand := KDF9.word(the_nest_depth);
  1307.             if the_nest_depth /= 0 then
  1308.                set_NIA_to_the_INS_target_address;
  1309.                the_CPU_delta := the_CPU_delta + 10;
  1310.             else
  1311.                the_CPU_delta := the_CPU_delta + 3;
  1312.             end if;
  1313.
  1314.          when JrEJ =>
  1315.             the_trace_operand := KDF9.word(the_sjns_depth);
  1316.             if the_sjns_depth = 0 then
  1317.                set_NIA_to_the_INS_target_address;
  1318.                the_CPU_delta := the_CPU_delta + 10;
  1319.             end if;
  1320.             the_CPU_delta := the_CPU_delta + 3;
  1321.
  1322.          when JrNEJ =>
  1323.             the_trace_operand := KDF9.word(the_sjns_depth);
  1324.             if the_sjns_depth /= 0 then
  1325.                set_NIA_to_the_INS_target_address;
  1326.                the_CPU_delta := the_CPU_delta + 10;
  1327.             end if;
  1328.             the_CPU_delta := the_CPU_delta + 3;
  1329.
  1330.          when JrTR =>
  1331.             if the_T_bit_is_set then
  1332.                the_T_bit_is_set := False;
  1333.                set_NIA_to_the_INS_target_address;
  1334.                the_CPU_delta := the_CPU_delta + 10;
  1335.             else
  1336.                the_CPU_delta := the_CPU_delta + 3;
  1337.             end if;
  1338.
  1339.          when JrNTR =>
  1340.             if the_T_bit_is_set then
  1341.                the_T_bit_is_set := False;
  1342.                the_CPU_delta := the_CPU_delta + 3;
  1343.             else
  1344.                set_NIA_to_the_INS_target_address;
  1345.                the_CPU_delta := the_CPU_delta + 10;
  1346.             end if;
  1347.
  1348.          when EXIT_n =>
  1349.             if the_sjns_depth > 0 or else the_CPU_state = Director_state then
  1350.                RA := pop;
  1351.                if INS.target.syllable_index = 3 then  -- c.f. decode_a_jump_order.
  1352.                   increment_by_3(RA);
  1353.                end if;
  1354.                RA.order_word_number := RA.order_word_number+INS.target.order_word_number;
  1355.                set_NIA_to(RA);
  1356.                the_CPU_delta := the_CPU_delta + 12 + KDF9.us(INS.target.syllable_index mod 2);
  1357.             else
  1358.                effect(NOUV_interrupt, "empty SJNS");
  1359.             end if;
  1360.
  1361.          when EXITD =>
  1362.             fail_in_problem_program_state;
  1363.             if the_sjns_depth = 0 then
  1364.                -- This indicates a serious failure in Director; best to abandon it at once.
  1365.                trap_illegal_instruction("empty SJNS in Director");
  1366.             end if;
  1367.             RA := pop;
  1368.             the_CPU_delta := the_CPU_delta + 11;
  1369.             return_from_Director_to(RA);
  1370.
  1371.          when JrCqZ =>
  1372.             if the_Q_store(INS.Qq).C = 0 then
  1373.                set_NIA_to_the_INS_target_address;
  1374.                the_CPU_delta := the_CPU_delta + 11;
  1375.             else
  1376.                the_CPU_delta := the_CPU_delta + 4;
  1377.             end if;
  1378.
  1379.          when JrCqNZ =>
  1380.             if the_Q_store(INS.Qq).C /= 0 then
  1381.                set_NIA_to_the_INS_target_address;
  1382.                the_CPU_delta := the_CPU_delta + 11;
  1383.             else
  1384.                the_CPU_delta := the_CPU_delta + 4;
  1385.             end if;
  1386.
  1387.          when OS_OUT =>
  1388.             the_CPU_delta := the_CPU_delta + 13;
  1389.             if the_sjns_depth < 16 or else the_CPU_state = Director_state then
  1390.                A := (if the_nest_depth = 0 then 0 else read_top);
  1391.                if the_execution_mode = boot_mode then
  1392.                   effect(OUT_interrupt, A'Image);
  1393.                   -- We get here only in Director state, when the OUT does not interrupt.
  1394.                   -- Arguably, this should be notified as an error.
  1395.                   return; -- OUT has the effect of a no-op in Director state.
  1396.                end if;
  1397.                -- Emulate a subset of the appropriate Director's API.
  1398.                if A < 100 then
  1399.                   do_a_TSD_OUT(OUT_number => A);
  1400.                elsif A < 200 then
  1401.                   do_an_EGDON_OUT(OUT_number => A);
  1402.                else
  1403.                   trap_unimplemented_feature("OUT" & A'Image);
  1404.                end if;
  1405.             else
  1406.                effect(NOUV_interrupt, "full SJNS in OUT");
  1407.             end if;
  1408.
  1409.          when others =>
  1410.             trap_illegal_instruction;
  1411.
  1412.       end case;
  1413.    end do_a_jump_order;
  1414.
  1415.    procedure do_a_data_access_order is
  1416.    begin
  1417.       case INS.compressed_opcode is
  1418.
  1419.          when EaMq =>
  1420.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1421.             check_address_and_lockout(the_trace_address);
  1422.             ensure_that_the_nest_has_room_for_a_result;
  1423.             the_trace_operand := fetch_word(the_trace_address);
  1424.             push(the_trace_operand);
  1425.             the_CPU_delta := the_CPU_delta + 6;
  1426.
  1427.          when TO_EaMq =>
  1428.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1429.             check_address_and_lockout(the_trace_address);
  1430.             ensure_that_the_nest_holds_an_operand;
  1431.             the_trace_operand := pop;
  1432.             store_word(the_trace_operand, the_trace_address);
  1433.             the_CPU_delta := the_CPU_delta + 6;
  1434.
  1435.          when EaMqQ =>
  1436.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1437.             check_address_and_lockout(the_trace_address);
  1438.             ensure_that_the_nest_has_room_for_a_result;
  1439.             the_trace_operand := fetch_word(the_trace_address);
  1440.             push(the_trace_operand);
  1441.             auto_increment;
  1442.             the_CPU_delta := the_CPU_delta + 7;
  1443.
  1444.          when TO_EaMqQ =>
  1445.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1446.             check_address_and_lockout(the_trace_address);
  1447.             ensure_that_the_nest_holds_an_operand;
  1448.             the_trace_operand := pop;
  1449.             store_word(the_trace_operand, the_trace_address);
  1450.             auto_increment;
  1451.             the_CPU_delta := the_CPU_delta + 7;
  1452.
  1453.          when SET =>
  1454.             ensure_that_the_nest_has_room_for_a_result;
  1455.             the_trace_operand := sign_extended(INS.operand);
  1456.             push(the_trace_operand);
  1457.             the_CPU_delta := the_CPU_delta + 4;
  1458.
  1459.          when others =>
  1460.             trap_illegal_instruction;
  1461.
  1462.       end case;
  1463.    end do_a_data_access_order;
  1464.
  1465.    procedure update_the_virtual_clocks
  1466.       with Inline;
  1467.
  1468.    procedure update_the_virtual_clocks is
  1469.    begin
  1470.       the_CPU_time := the_CPU_time + the_CPU_delta;
  1471.       the_elapsed_time := the_elapsed_time + the_CPU_delta;
  1472.       if the_CPU_time > the_elapsed_time then
  1473.          the_elapsed_time := the_CPU_time;
  1474.       end if;
  1475.       ICR := ICR + 1;
  1476.    end update_the_virtual_clocks;
  1477.
  1478.    procedure do_a_fast_time_slice is
  1479.    begin
  1480.
  1481.       if break_in.has_been_requested then
  1482.          break_in.handler;
  1483.       end if;
  1484.
  1485.       for i in 1 .. time_slice loop
  1486.
  1487.          the_CPU_delta := 0;
  1488.
  1489.          process_syllable_0_of_INS;
  1490.          case INS.kind is
  1491.             when one_syllable_order =>
  1492.                do_a_one_syllable_order;
  1493.             when two_syllable_order =>
  1494.                process_syllable_1_of_INS;
  1495.                do_a_two_syllable_order;
  1496.             when normal_jump_order =>
  1497.                process_syllables_1_and_2_of_a_jump_order;
  1498.                do_a_jump_order;
  1499.             when data_access_order =>
  1500.                process_syllables_1_and_2_of_a_data_access_order;
  1501.                do_a_data_access_order;
  1502.          end case;
  1503.
  1504.          update_the_virtual_clocks;
  1505.          check_for_a_clock_interrupt;
  1506.          if the_elapsed_time > the_next_interrupt_time then
  1507.             act_on_pending_interrupts;
  1508.          end if;
  1509.
  1510.       end loop;
  1511.
  1512.    exception
  1513.
  1514.       when program_exit =>
  1515.          complete_all_extant_transfers;
  1516.          update_the_virtual_clocks;
  1517.          synchronize_the_real_and_virtual_times;
  1518.          raise;
  1519.
  1520.       when OUT_2_restart =>
  1521.          complete_all_extant_transfers;
  1522.          update_the_virtual_clocks;
  1523.          synchronize_the_real_and_virtual_times;
  1524.          complete_TSD_OUT_2;
  1525.
  1526.    end do_a_fast_time_slice;
  1527.
  1528.    procedure do_a_traced_instruction_cycle is
  1529.       use tracing.order_flags;
  1530.
  1531.       procedure finalize_the_traced_instruction_execution is
  1532.       begin
  1533.          update_the_virtual_clocks;
  1534.          synchronize_the_real_and_virtual_times;
  1535.
  1536.          if ICR in low_count .. high_count            and then
  1537.                NIA_word_number in low_bound .. high_bound then
  1538.             take_note_of(the_trace_operand);
  1539.             if the_signature_is_enabled then
  1540.                update_the_digital_signature;
  1541.             end if;
  1542.             if the_histogram_is_enabled then
  1543.                add_INS_to_the_histogram;
  1544.                add_CIA_to_the_profile;
  1545.             end if;
  1546.             if the_external_trace_is_enabled then
  1547.                log_to_external_trace;
  1548.             end if;
  1549.             case INS.kind is
  1550.                when two_syllable_order =>
  1551.                   act_on_any_two_syllable_order_watchpoints;
  1552.                when data_access_order =>
  1553.                   act_on_any_data_access_order_watchpoints;
  1554.                when others =>
  1555.                   null;
  1556.             end case;
  1557.          end if;
  1558.       end finalize_the_traced_instruction_execution;
  1559.
  1560.    begin  -- do_a_traced_instruction_cycle
  1561.
  1562.       if break_in.has_been_requested then
  1563.          break_in.handler;
  1564.       end if;
  1565.
  1566.       the_trace_operand := 0;
  1567.       the_trace_address := 0;
  1568.       the_CPU_delta := 0;
  1569.
  1570.       process_syllable_0_of_INS;
  1571.
  1572.       case INS.kind is
  1573.          when one_syllable_order =>
  1574.             preview_a_one_syllable_order;
  1575.                do_a_one_syllable_order;
  1576.             look_back_at_a_one_syllable_order;
  1577.          when two_syllable_order =>
  1578.             process_syllable_1_of_INS;
  1579.             preview_a_two_syllable_order;
  1580.                do_a_two_syllable_order;
  1581.             look_back_at_a_two_syllable_order;
  1582.          when normal_jump_order =>
  1583.             process_syllables_1_and_2_of_a_jump_order;
  1584.             preview_a_jump_order;
  1585.                do_a_jump_order;
  1586.             look_back_at_a_jump_order;
  1587.          when data_access_order =>
  1588.             process_syllables_1_and_2_of_a_data_access_order;
  1589.             preview_a_data_access_order;
  1590.                do_a_data_access_order;
  1591.             look_back_at_a_data_access_order;
  1592.       end case;
  1593.
  1594.       finalize_the_traced_instruction_execution;
  1595.
  1596.       if ICR >= time_limit then
  1597.          raise time_expired;
  1598.       end if;
  1599.
  1600.       if (breakpoints/NIA_word_number        and then
  1601.              ICR in low_count .. high_count)  or else
  1602.                 the_diagnostic_mode = pause_mode then
  1603.          handle_breakpoint;
  1604.       end if;
  1605.
  1606.       check_for_a_clock_interrupt;
  1607.       if the_elapsed_time > the_next_interrupt_time then
  1608.          act_on_pending_interrupts;
  1609.       end if;
  1610.
  1611.    exception
  1612.
  1613.       when program_exit =>
  1614.          case INS.kind is
  1615.             when one_syllable_order =>
  1616.                look_back_at_a_one_syllable_order;
  1617.             when two_syllable_order =>
  1618.                look_back_at_a_two_syllable_order;
  1619.             when normal_jump_order =>
  1620.                look_back_at_a_jump_order;
  1621.             when data_access_order =>
  1622.                look_back_at_a_data_access_order;
  1623.          end case;
  1624.          complete_all_extant_transfers;
  1625.          finalize_the_traced_instruction_execution;
  1626.          raise;
  1627.
  1628.       when OUT_2_restart =>
  1629.          complete_all_extant_transfers;
  1630.          finalize_the_traced_instruction_execution;
  1631.          complete_TSD_OUT_2;
  1632.
  1633.    end do_a_traced_instruction_cycle;
  1634.
  1635. end KDF9.microcode;

Compiling: ../Source/kdf9-microcode.ads
Source file time stamp: 2021-01-10 23:52:38
Compiled at: 2021-02-08 17:20:58

     1. -- KDF9 ISP emulation - CPU microcode routines.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.microcode is
    18.
    19.    procedure do_a_fast_time_slice;
    20.
    21.    procedure do_a_traced_instruction_cycle;
    22.
    23. end KDF9.microcode;

 1635 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/state_display.adb
Source file time stamp: 2021-02-07 00:29:32
Compiled at: 2021-02-08 17:20:58

     1. -- Provide the comprehensive machine-state display panel KDF9 never had.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Latin_1;
    18. with Ada.Exceptions;
    19. with Ada.Long_Float_Text_IO;
    20. --
    21. with disassembly;
    22. with dumping;
    23. with exceptions;
    24. with formatting;
    25. with generic_sets;
    26. with HCI;
    27. with IOC;
    28. with IOC.fast.DR;
    29. with IOC.fast.FD;
    30. with KDF9_char_sets;
    31. with KDF9.CPU;
    32. with KDF9.decoding;
    33. with KDF9.PHU_store;
    34. with KDF9.store;
    35. with logging.file;
    36. with settings;
    37. with tracing;
    38.
    39. with IOC.diagnostics;
    40.
    41. use  Ada.Characters.Latin_1;
    42. use  Ada.Exceptions;
    43. use  Ada.Long_Float_Text_IO;
    44. --
    45. use  disassembly;
    46. use  dumping;
    47. use  exceptions;
    48. use  formatting;
    49. use  HCI;
    50. use  IOC;
    51. use  IOC.fast.DR;
    52. use  IOC.fast.FD;
    53. use  KDF9_char_sets;
    54. use  KDF9.CPU;
    55. use  KDF9.decoding;
    56. use  KDF9.PHU_store;
    57. use  KDF9.store;
    58. use  logging.file;
    59. use  settings;
    60. use  tracing;
    61.
    62. package body state_display is
    63.
    64.    procedure show_IM_parts (the_Q_register : in KDF9.Q_register;
    65.                             width          : in Positive := 8) is
    66.    begin
    67.       log(
    68.           "/"
    69.         & just_right("#" & oct_of(the_Q_register.I, width-2), width)
    70.         & "/"
    71.         & just_right("#" & oct_of(the_Q_register.M, width-2), width)
    72.          );
    73.    end show_IM_parts;
    74.
    75.    procedure show_IO_register (the_Q_register : in KDF9.Q_register;
    76.                                width          : in Positive := 8;
    77.                                for_DR,
    78.                                for_FD,
    79.                                for_FH,
    80.                                for_seek,
    81.                                for_OUT         : in Boolean  := False) is
    82.    begin
    83.       log('Q');
    84.       if for_FD then
    85.          log(just_right(as_FD_command(the_Q_register, for_FD and for_seek, for_FD and for_FH), width));
    86.       elsif for_DR then
    87.          log(just_right(as_DR_command(the_Q_register, for_OUT), width));
    88.       else
    89.          log(just_right("#" & oct_of(the_Q_register.C, width-2), width));
    90.       end if;
    91.       show_IM_parts(the_Q_register, width);
    92.    end show_IO_register;
    93.
    94.    procedure show_Q_register (the_Q_register : in KDF9.Q_register;
    95.                               width          : in Positive := 8) is
    96.    begin
    97.       log('Q' & just_right("#" & oct_of(the_Q_register.C, width-2), width));
    98.       show_IM_parts(the_Q_register, width);
    99.    end show_Q_register;
   100.
   101.    procedure show_Q_in_decimal (the_Q_register : in KDF9.Q_register;
   102.                                 width          : in Positive := 7) is
   103.    begin
   104.       log(
   105.           'Q'
   106.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.C)), width)
   107.         & "/"
   108.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.I)), width)
   109.         & "/"
   110.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.M)), width)
   111.          );
   112.    end show_Q_in_decimal;
   113.
   114.    procedure show_in_syllables_form (the_word : in KDF9.word) is
   115.       word : KDF9.word := the_word;
   116.       syllable : KDF9.syllable;
   117.    begin
   118.       for b in 0 .. 5 loop
   119.          word := rotate_word_left(word, 8);
   120.          syllable := KDF9.syllable(word and 8#377#);
   121.          log("#" & just_right(oct_of(syllable), 3) & " ");
   122.       end loop;
   123.    end show_in_syllables_form;
   124.
   125.    procedure show_as_characters (the_word : in KDF9.word) is
   126.       word : KDF9.word := the_word;
   127.       data : String(1 .. 8);
   128.    begin
   129.       for b of reverse data loop
   130.          b := glyph_for(to_CP(KDF9_char_sets.symbol(word and 8#77#)));
   131.          word := shift_logical(word, -6);
   132.       end loop;
   133.       log(data);
   134.    end show_as_characters;
   135.
   136.   procedure show_in_various_formats (the_word : in KDF9.word;
   137.                                      column   : in Positive := 5) is
   138.       image : String(1 .. 21);
   139.    begin
   140.       log_octal(the_word);
   141.       log(" = " & just_right(trimmed(CPU.signed'Image(resign(the_word))), 16) & " = ");
   142.       Put(image, host_float(CPU.f48(the_word)), Aft => 12, Exp => 2);
   143.       log(trimmed(image) & " = ");
   144.       log(as_fraction(the_word)'Image);
   145.       log_new_line;
   146.       tab_log_to(column);
   147.       log(" = ");
   148.       show_Q_register(as_Q(the_word));
   149.       log("   = ");
   150.       show_Q_in_decimal(as_Q(the_word));
   151.       log_new_line;
   152.       tab_log_to(column);
   153.       log(" = ");
   154.       show_in_syllables_form(the_word);
   155.       log("= """);
   156.       show_as_characters(the_word);
   157.       log("""");
   158.    end show_in_various_formats;
   159.
   160.    procedure show_progress is
   161.
   162.       function readable (t : KDF9.us)
   163.       return String is
   164.          t_plus_5E2 : constant KDF9.us := (t + 5E2)/ 1E3;
   165.          t_plus_5E5 : constant KDF9.us := (t + 5E5)/ 1E6;
   166.       begin
   167.          return (if t < 1E3 then
   168.                     ""
   169.               elsif t < 1E6 then
   170.                     " about" & t_plus_5E2'Image & " ms"
   171.               else  " about" & t_plus_5E5'Image & " sec" );
   172.       end readable;
   173.
   174.       CPU : constant String := " KDF9 us. (RAN)" & readable(the_CPU_time);
   175.       EL  : constant String := " KDF9 us. (EL) " & readable(the_clock_time);
   176.
   177.    begin
   178.       log_line("ORDERS:     " & just_right(ICR'Image, 10) & " executed (ICR)");
   179.       log_line("CPU TIME:   " & just_right(the_CPU_time'Image, 10) & CPU);
   180.       log_line("CLOCK TIME: " & just_right(KDF9.us'Image(the_clock_time), 10) & EL);
   181.    end show_progress;
   182.
   183.    slot_name : constant array (KDF9.context) of String(1..1)  := ("P", "Q", "R", "S");
   184.
   185.    procedure show_Director_registers is
   186.       interval : constant KDF9.us := the_clock_time - the_last_K4_time;
   187.    begin
   188.       log_line("The CPU is in " & the_CPU_state'Image);
   189.       log_line("CONTEXT:  " & slot_name(the_context));
   190.       log_line("PRIORITY: " & just_right(CPL'Image, 1));
   191.       log_line("BA:       " & just_right("#" & oct_of(BA), 6));
   192.       log_line("NOL:      " & just_right("#" & oct_of(NOL), 6));
   193.       log("CPDAR:    ");
   194.       for i in KDF9.buffer_number loop
   195.          log(if the_CPDAR(i) then device_name_of(buffer(i).all) & " " else "");
   196.       end loop;
   197.       log_new_line;
   198.       log_new_line;
   199.       log_line("PHU stores:");
   200.       for p in KDF9.priority loop
   201.          log("PHU" & p'Image & " is ");
   202.          if PHU(p).is_held_up then
   203.             if PHU(p).blockage.reason = buffer_busy then
   204.                log("waiting for " & device_name_of(IOC.device_number(PHU(p).blockage.buffer_nr)));
   205.                log(" on buffer #" & oct_of(PHU(p).blockage.buffer_nr, 2));
   206.                if PHU(p).blockage.by_INTQq then
   207.                   log(", because of INTQq");
   208.                end if;
   209.             else
   210.                log("locked out of group" & KDF9.store.group_address'Image(PHU(p).blockage.group_nr));
   211.             end if;
   212.          else
   213.             log("idle");
   214.          end if;
   215.          log_new_line;
   216.       end loop;
   217.       log_new_line;
   218.       log_line("RFIR (Interrupt Flags):");
   219.       log_line(
   220.                "CLOCK:    "
   221.              & Boolean'Image(interval >= 2**20)
   222.              & "; time since last CLOCK interrupt ="
   223.              & KDF9.us'Image(interval)
   224.              & " KDF9 us."
   225.               );
   226.       log_line("PR:       " & Boolean'Image(the_RFIR(PR_interrupt)));
   227.       log_line("FLEX:     " & Boolean'Image(the_RFIR(FLEX_interrupt)));
   228.       log_line("LIV:      " & Boolean'Image(the_RFIR(LIV_interrupt)));
   229.       log_line("NOUV:     " & Boolean'Image(the_RFIR(NOUV_interrupt)));
   230.       log_line("EDT:      " & Boolean'Image(the_RFIR(EDT_interrupt)));
   231.       log_line("OUT:      " & Boolean'Image(the_RFIR(OUT_interrupt)));
   232.       log_line("LOV:      " & Boolean'Image(the_RFIR(LOV_interrupt)));
   233.       log_line("RESET:    " & Boolean'Image(the_RFIR(RESET_interrupt)));
   234.    end show_Director_registers;
   235.
   236.    procedure show_V_and_T is
   237.    begin
   238.       if the_V_bit_is_set or the_T_bit_is_set then
   239.          log_new_line;
   240.          if the_V_bit_is_set then
   241.             log("V is set. ");
   242.          else
   243.             log("V is clear. ");
   244.          end if;
   245.          if the_T_bit_is_set then
   246.             log("T is set. ");
   247.          else
   248.             log("T is clear. ");
   249.          end if;
   250.          log_new_line;
   251.       end if;
   252.    end show_V_and_T;
   253.
   254.    procedure show_nest (when_empty : Boolean := True) is
   255.    begin
   256.       if the_nest_depth = 0 then
   257.          if when_empty then
   258.             log_line("The NEST is empty.");
   259.          end if;
   260.       else
   261.          log_line("NEST:");
   262.          for i in reverse KDF9.nest_depth loop
   263.             if i < the_nest_depth then
   264.                log(just_right("N" & trimmed(KDF9.nest_depth'Image(the_nest_depth-i)), 3) & ": ");
   265.                log_new_line;
   266.                show_in_various_formats(the_nest(i));
   267.                log_new_line;
   268.             end if;
   269.          end loop;
   270.       end if;
   271.    end show_nest;
   272.
   273.    procedure show_sjns (when_empty : Boolean := True) is
   274.    begin
   275.       if the_sjns_depth = 0 then
   276.          if when_empty then
   277.             log_line("The SJNS is empty.");
   278.          end if;
   279.       else
   280.          log_line("SJNS:");
   281.       end if;
   282.       for i in reverse KDF9.sjns_depth loop
   283.          if i < the_sjns_depth then
   284.             log(just_right("S" & trimmed(KDF9.sjns_depth'Image(the_sjns_depth-i)), 3) & ": ");
   285.             log_line(oct_of(the_sjns(i)) & " (" & dec_of(KDF9.syllable_address(the_sjns(i))) & ")");
   286.          end if;
   287.       end loop;
   288.    end show_sjns;
   289.
   290.    procedure show_Q_store is
   291.       Q_bits  : KDF9.word := 0;
   292.    begin
   293.       for Qq of the_Q_store loop
   294.          Q_bits := Q_bits or as_word(Qq);
   295.       end loop;
   296.       if Q_bits = 0 then
   297.          log_line("Q store: all zero.");
   298.          return;
   299.       else
   300.          log_line("Q store:");
   301.       end if;
   302.       for q in KDF9.Q_store'Range loop
   303.          if as_word(the_Q_store(q)) /= KDF9.word'(0) then
   304.             log(just_right("Q" & trimmed(q'Image), 3) & ": ");
   305.             show_Q_register(the_Q_store(q));
   306.             log("  = ");
   307.             show_Q_in_decimal(the_Q_store(q));
   308.             log_new_line;
   309.          end if;
   310.       end loop;
   311.    end show_Q_store;
   312.
   313.    procedure show_registers is
   314.    begin
   315.       show_progress;
   316.       log_new_line;
   317.       if the_execution_mode = boot_mode then
   318.          show_Director_registers;
   319.          log_new_line;
   320.       end if;
   321.       show_sjns;
   322.       log_new_line;
   323.       show_Q_store;
   324.       show_V_and_T;
   325.       log_new_line;
   326.       show_nest;
   327.    end show_registers;
   328.
   329.    procedure show_order is
   330.    begin
   331.       log(the_code_and_name_of_INS);
   332.    end show_order;
   333.
   334.    procedure show_execution_context is
   335.    begin
   336.       log("At "
   337.         & oct_of(CIA)
   338.         & " ("
   339.         & dec_of(CIA)
   340.         & ")"
   341.         & "; ICR ="
   342.         & ICR'Image
   343.         & "; EL ="
   344.         & the_clock_time'Image
   345.         & "; the instruction was ");
   346.       show_order;
   347.       log_new_line;
   348.    end show_execution_context;
   349.
   350.    procedure log_to_external_trace is
   351.    begin
   352.       log(the_external_trace_file, oct_of(CIA));
   353.       tab_log_to(the_external_trace_file, 10);
   354.       log(the_external_trace_file, ICR'Image);
   355.       tab_log_to(the_external_trace_file, 20);
   356.       if only_signature_tracing then
   357.          log(
   358.              the_external_trace_file,
   359.              "#"
   360.            & oct_of(the_digital_signature)
   361.            & (if the_V_bit_is_set then "V" else " ")
   362.            & (if the_T_bit_is_set then "T" else " ")
   363.             );
   364.          tab_log_to(the_external_trace_file, 40);
   365.          if the_nest_depth > 0 then
   366.             log(the_external_trace_file, "#" & oct_of(read_top));
   367.          end if;
   368.          tab_log_to(the_external_trace_file, 58);
   369.       else
   370.          log(the_external_trace_file, the_CPU_time'Image);
   371.          tab_log_to(the_external_trace_file, 40);
   372.          log(the_external_trace_file, the_nest_depth'Image);
   373.          tab_log_to(the_external_trace_file, 43);
   374.          log(the_external_trace_file, the_sjns_depth'Image);
   375.          tab_log_to(the_external_trace_file, 46);
   376.          log(the_external_trace_file, (if the_V_bit_is_set then "V" else " "));
   377.          log(the_external_trace_file, (if the_T_bit_is_set then "T" else " "));
   378.          tab_log_to(the_external_trace_file, 50);
   379.          if the_nest_depth > 0 then
   380.             log(the_external_trace_file, "#" & oct_of(read_top));
   381.          end if;
   382.          tab_log_to(the_external_trace_file, 68);
   383.       end if;
   384.       log(the_external_trace_file, " |" & the_full_name_of(INS));
   385.       tab_log_to(the_external_trace_file, 90);
   386.       log(the_external_trace_file, KDF9.us'Image(the_clock_time));
   387.       log_new_line(the_external_trace_file);
   388.    end log_to_external_trace;
   389.
   390.    procedure log_an_external_trace_header (caption : in String := "") is
   391.    begin
   392.       if caption /= "" then
   393.          log_new_line(the_external_trace_file);
   394.          log(the_external_trace_file, caption);
   395.          log_new_line(the_external_trace_file);
   396.       end if;
   397.       log(the_external_trace_file, "LOCATION");
   398.       tab_log_to(the_external_trace_file, 11);
   399.       log(the_external_trace_file, "ICR");
   400.       tab_log_to(the_external_trace_file, 20);
   401.       if only_signature_tracing then
   402.          log(the_external_trace_file, "DIGITAL SIGNATURE");
   403.          tab_log_to(the_external_trace_file, 40);
   404.          log(the_external_trace_file, "[N1]");
   405.          tab_log_to(the_external_trace_file, 58);
   406.       else
   407.          log(the_external_trace_file, " CPU");
   408.          tab_log_to(the_external_trace_file, 40);
   409.          log(the_external_trace_file, "ND");
   410.          tab_log_to(the_external_trace_file, 43);
   411.          log(the_external_trace_file, "SD");
   412.          tab_log_to(the_external_trace_file, 46);
   413.          log(the_external_trace_file, "VT");
   414.          tab_log_to(the_external_trace_file, 50);
   415.          log(the_external_trace_file, "[N1]");
   416.          tab_log_to(the_external_trace_file, 68);
   417.       end if;
   418.       log(the_external_trace_file, " |INSTRUCTION");
   419.       log_new_line(the_external_trace_file);
   420.    end log_an_external_trace_header;
   421.
   422.    procedure show_CIA_and_NIA is
   423.    begin
   424.       log_line("CIA:        " & just_right(oct_of(CIA), 10) & " (" & just_right(dec_of(CIA) & ")"));
   425.       log_line("NIA:        " & just_right(oct_of(NIA), 10) & " (" & just_right(dec_of(NIA) & ")"));
   426.    end show_CIA_and_NIA;
   427.
   428.    procedure long_witness is
   429.    begin
   430.       log_new_line;
   431.       log("At " & oct_of(CIA) & " (" & dec_of(CIA) & ") the instruction was ");
   432.       show_order;
   433.       log_new_line;
   434.       show_registers;
   435.    end long_witness;
   436.
   437.    procedure short_witness is
   438.
   439.       type register_usage is array (KDF9.compressed_opcode) of Boolean
   440.          with Size => 64, Component_Size => 1;
   441.
   442.       it_uses_JB : constant register_usage
   443.                  := (
   444.                       LINK
   445.                     | TO_LINK
   446.                     | OS_OUT
   447.                     | JrNEJ
   448.                     | JSr
   449.                     | EXIT_n
   450.                     | JrEJ
   451.                     | EXITD     => True,
   452.                       others    => False
   453.                     );
   454.
   455.       it_uses_Qq : constant register_usage
   456.                  := (
   457.                       MkMq
   458.                     | MkMqQ
   459.                     | MkMqH
   460.                     | MkMqQH
   461.                     | MkMqN
   462.                     | MkMqQN
   463.                     | MkMqHN
   464.                     | MkMqQHN
   465.                     | TO_MkMq
   466.                     | TO_MkMqQ
   467.                     | TO_MkMqH
   468.                     | TO_MkMqQH
   469.                     | TO_MkMqN
   470.                     | TO_MkMqQN
   471.                     | TO_MkMqHN
   472.                     | TO_MkMqQHN
   473.                     | MqTOQk
   474.                     | IqTOQk
   475.                     | IMqTOQk
   476.                     | CqTOQk
   477.                     | CMqTOQk
   478.                     | CIqTOQk
   479.                     | QqTOQk
   480.                     | M_PLUS_Iq
   481.                     | M_MINUS_Iq
   482.                     | NCq
   483.                     | DCq
   484.                     | POS1_TO_Iq
   485.                     | NEG1_TO_Iq
   486.                     | POS2_TO_Iq
   487.                     | NEG2_TO_Iq
   488.                     | SHA
   489.                     | SHAD
   490.                     | MACC
   491.                     | SHL
   492.                     | SHLD
   493.                     | SHC
   494.                     | TO_RCIMq
   495.                     | QCIMq
   496.                     | ADD_TO_QCIMq
   497.                     | JCqNZS
   498.                     | PAR_Qq
   499.                     | PIA_PIC_CLO_TLO_Qq
   500.                     | PIB_PID_Qq
   501.                     | PIE_PIG_Qq
   502.                     | PIF_PIH_Qq
   503.                     | PMA_PMK_INT_Qq
   504.                     | CT_PMB_PMC_BUSY_Qq
   505.                     | PMD_PME_PML_Qq
   506.                     | PMF_PMG_Qq
   507.                     | POA_POC_POE_POF_PMH_Qq
   508.                     | POB_POD_Qq
   509.                     | POG_POL_Qq
   510.                     | POH_POK_Qq
   511.                     | JrCqNZ    => True,
   512.                       others    => False
   513.                     );
   514.
   515.       is_modified : constant register_usage
   516.                   := (
   517.                        EaMq
   518.                      | TO_EaMq
   519.                      | EaMqQ
   520.                      | TO_EaMqQ  => True,
   521.                        others    => False
   522.                      );
   523.
   524.       it_uses_Qk : constant register_usage
   525.                  := (
   526.                       MkMq
   527.                     | MkMqQ
   528.                     | MkMqH
   529.                     | MkMqQH
   530.                     | MkMqN
   531.                     | MkMqQN
   532.                     | MkMqHN
   533.                     | MkMqQHN
   534.                     | TO_MkMq
   535.                     | TO_MkMqQ
   536.                     | TO_MkMqH
   537.                     | TO_MkMqQH
   538.                     | TO_MkMqN
   539.                     | TO_MkMqQN
   540.                     | TO_MkMqHN
   541.                     | TO_MkMqQHN
   542.                     | MqTOQk
   543.                     | IqTOQk
   544.                     | IMqTOQk
   545.                     | CqTOQk
   546.                     | CMqTOQk
   547.                     | CIqTOQk
   548.                     | QqTOQk    => True,
   549.                       others    => False
   550.                     );
   551.
   552.       function INS_uses_Qq
   553.       return Boolean is
   554.          (
   555.           -- A compressed_opcode may be ambiguous: to know which opcode it represents,
   556.           --   further attributes of the order may need to be considered.
   557.           case INS.kind is
   558.              when two_syllable_order =>
   559.                 it_uses_Qq(INS.compressed_opcode)
   560.                   and
   561.                 -- If a shift, exclude fixed-amount shifts.
   562.                 ((INS.order.syllable_1 and 1) = 0 or else INS.compressed_opcode not in SHA..SHC),
   563.              when normal_jump_order =>
   564.                 INS.compressed_opcode in JrCqZ | JrCqNZ,
   565.              when data_access_order =>
   566.                 is_modified(INS.compressed_opcode),
   567.              when others =>
   568.                 False
   569.          );
   570.
   571.    begin  -- short_witness
   572.       log_new_line;
   573.       show_execution_context;
   574.       if the_CPU_state = Director_state then
   575.          show_Director_registers;
   576.       end if;
   577.       if it_uses_JB(INS.compressed_opcode)                     and then
   578.             INS.kind in two_syllable_order | normal_jump_order and then
   579.                the_sjns_depth > 0                                  then
   580.          log_line(
   581.                   " JB: "
   582.                 & oct_of(the_sjns(the_sjns_depth-1))
   583.                 & "; SJNS depth: " & just_right(the_sjns_depth'Image, 3)
   584.                  );
   585.       end if;
   586.       if INS.Qq /= 0 and then
   587.             INS_uses_Qq  then
   588.          log(just_right("Q" & trimmed(INS.Qq'Image), 3) & ": ");
   589.          show_Q_register(the_Q_store(INS.Qq));
   590.          log("  = ");
   591.          show_Q_in_decimal(the_Q_store(INS.Qq));
   592.          log_new_line;
   593.       end if;
   594.       if INS.Qk /= 0                       and then
   595.             INS.kind in two_syllable_order and then
   596.                it_uses_Qk(INS.compressed_opcode)    and then
   597.                   INS.Qq /= INS.Qk             then
   598.          log(just_right("Q" & trimmed(INS.Qk'Image), 3) & ": ");
   599.          show_Q_register(the_Q_store(INS.Qk));
   600.          log("  = ");
   601.          show_Q_in_decimal(the_Q_store(INS.Qk));
   602.          log_new_line;
   603.          log_new_line;
   604.       end if;
   605.       show_V_and_T;
   606.       show_nest(when_empty => False);
   607.       log_rule;
   608.    end short_witness;
   609.
   610.    procedure show_frequency_plots is
   611.
   612.       function summed_counts (from, to : KDF9.syllable)
   613.       return KDF9.order_counter is
   614.          sum : KDF9.order_counter := 0;
   615.       begin
   616.          for i in from .. to loop
   617.             sum := sum + the_histogram(i);
   618.          end loop;
   619.          return sum;
   620.       end summed_counts;
   621.
   622.       procedure log_opcode_bin (bin    : in KDF9.syllable;
   623.                                 sum    : in KDF9.order_counter;
   624.                                 bound  : in Long_Float) is
   625.          percent : Long_Float;
   626.          image   : String(1 .. 6);
   627.       begin
   628.          if sum /= 0 then
   629.             percent := Long_Float(sum)/Long_Float(ICR)*100.0;
   630.             if percent < bound then
   631.                return;
   632.             end if;
   633.             log(oct_of(bin) & ": " & the_short_name_of(bin));
   634.             tab_log_to(32);
   635.             log(sum'Image);
   636.             tab_log_to(42);
   637.             Put(image, percent, Aft => 2, Exp => 0);
   638.             log(image & "% :");
   639.             for i in 1 .. Integer(percent) loop
   640.                log("|");
   641.             end loop;
   642.             log_new_line;
   643.          end if;
   644.       end log_opcode_bin;
   645.
   646.       procedure log_opcode_usage (bound : in Long_Float) is
   647.       begin
   648.          for i in KDF9.syllable'(0) .. 8#167# loop
   649.             log_opcode_bin(i, the_histogram(i), bound);
   650.          end loop;
   651.          for i in KDF9.syllable'(8#170#) .. 8#237# loop
   652.             log_opcode_bin(i, the_histogram(i), bound);
   653.          end loop;
   654.          log_opcode_bin(8#240#, summed_counts(from => 8#240#, to => 8#257#), bound);
   655.          log_opcode_bin(8#260#, summed_counts(from => 8#240#, to => 8#277#), bound);
   656.          for i in KDF9.syllable'(8#300#) .. 8#377# loop
   657.             log_opcode_bin(i, the_histogram(i), bound);
   658.          end loop;
   659.       end log_opcode_usage;
   660.
   661.       accounted_for : Long_Float;
   662.       cutoff_image  : String(1 .. 7) := "      %";
   663.       percent_image : String(1 .. 7) := "      %";
   664.
   665.       procedure log_order_word_bin (bin    : in KDF9.order_word_number;
   666.                                     sum    : in KDF9.order_counter;
   667.                                     bound  : in Long_Float) is
   668.          percent : Long_Float;
   669.       begin
   670.          if sum /= 0 then
   671.             percent := Long_Float(sum)/Long_Float(ICR)*100.0;
   672.             if percent < bound then
   673.                return;
   674.             end if;
   675.             accounted_for := accounted_for + percent;
   676.             log("#" & oct_of(bin) & ": ");
   677.             tab_log_to(32);
   678.             log(sum'Image);
   679.             tab_log_to(42);
   680.             Put(percent_image, percent, Aft => 2, Exp => 0);
   681.             percent_image(7) := '%';
   682.             log(percent_image);
   683.             log(" :");
   684.             for i in 1 .. Integer(percent) loop
   685.                log("|");
   686.             end loop;
   687.             log_new_line;
   688.          end if;
   689.       end log_order_word_bin;
   690.
   691.       procedure log_profile (bound : in Long_Float) is
   692.       begin
   693.          accounted_for := 0.0;
   694.          for w in KDF9.order_word_number loop
   695.             if the_profile(w) /= 0 then
   696.                log_order_word_bin(w, the_profile(w), bound);
   697.             end if;
   698.          end loop;
   699.       end log_profile;
   700.
   701.       procedure sum_logged_frequencies (bound  : in Long_Float) is
   702.          percent : Long_Float;
   703.       begin
   704.          accounted_for := 0.0;
   705.          for w in KDF9.order_word_number loop
   706.             percent := Long_Float(the_profile(w))/Long_Float(ICR)*100.0;
   707.             if percent >= bound then
   708.                accounted_for := accounted_for + percent;
   709.             end if;
   710.          end loop;
   711.       end sum_logged_frequencies;
   712.
   713.    begin -- show_frequency_plots
   714.       Put(cutoff_image(1..6), histogram_cutoff, Aft => 2, Exp => 0);
   715.       cutoff_image(7) := '%';
   716.       if the_INS_plot_is_wanted and ICR /= 0 and the_diagnostic_mode /= fast_mode then
   717.          -- Print the instruction execution-frequency histogram.
   718.          log_title(
   719.                    "Histogram of the opcodes of"
   720.                  & ICR'Image
   721.                  & " executed instructions with frequency >="
   722.                  & cutoff_image
   723.                   );
   724.          log_opcode_usage(bound => histogram_cutoff);
   725.          log_new_line;
   726.       end if;
   727.       if the_profile_is_wanted and ICR /= 0 and the_diagnostic_mode /= fast_mode then
   728.          log_title(
   729.                    "Histogram of the loci of"
   730.                  & ICR'Image
   731.                  & " executed instructions with frequency >="
   732.                  & cutoff_image
   733.                   );
   734.          log_profile(bound => histogram_cutoff);
   735.          log_new_line;
   736.       end if;
   737.       sum_logged_frequencies(bound => histogram_cutoff);
   738.       Put(percent_image(1..6), accounted_for, Aft =>1, Exp => 0);
   739.       log_line("Executions accounted for in the profile:" & percent_image);
   740.       log_rule;
   741.    end show_frequency_plots;
   742.
   743.    function as_RFIR (K4_word : KDF9.word)
   744.    return KDF9.RFIR is
   745.       mask : KDF9.word := 2**16;
   746.       RFIR : KDF9.RFIR := (others => False);
   747.    begin
   748.       for r in reverse KDF9.interrupt_number loop
   749.          if (K4_word and mask) /= 0 then
   750.             RFIR(r) := True;
   751.          end if;
   752.          mask := 2 * mask;
   753.       end loop;
   754.       return RFIR;
   755.    end as_RFIR;
   756.
   757.    function for_FH_disc (compressed_opcode : KDF9.compressed_opcode; Pxy_bits : KDF9.Q_number)
   758.    return Boolean
   759.    is (case compressed_opcode is
   760.           when PIA_PIC_CLO_TLO_Qq     => Pxy_bits = PIC_bits,
   761.           when PIB_PID_Qq             => Pxy_bits = PID_bits,
   762.           when PIE_PIG_Qq             => Pxy_bits = PIG_bits,
   763.           when PIF_PIH_Qq             => Pxy_bits = PIH_bits,
   764.           when POA_POC_POE_POF_PMH_Qq => Pxy_bits = POC_bits,
   765.           when POB_POD_Qq             => Pxy_bits = POD_bits,
   766.           when POG_POL_Qq             => Pxy_bits = POL_bits,
   767.           when POH_POK_Qq             => Pxy_bits = POK_bits,
   768.           when others                 => False
   769.       );
   770.
   771.
   772.    first_col   : constant := 17;
   773.    device_col  : constant := first_col + 20;
   774.    operand_col : constant := device_col;
   775.    event_col   : constant := operand_col + 4;
   776.    is_D_col    : constant := event_col + 29;
   777.    depth_col   : constant := operand_col + 29;
   778.    time_col    : constant := depth_col + 11;
   779.    ICR_col     : constant := time_col + 13;
   780.
   781.    procedure show_retro_FIFO is
   782.
   783.       RFIR_id : constant array (KDF9.interrupt_number) of Character
   784.               := ('P', 'F', 'I', 'N', 'E', 'S', 'O', 'R', 'Y', 'Z');
   785.       image   : String(1 .. 21);
   786.       RFIR    : KDF9.RFIR;
   787.    begin
   788.       if retro_FIFO_count = 0 then
   789.          return;
   790.       end if;
   791.       log_title("Retrospective trace of all instructions.");
   792.       tab_log_to(depth_col);
   793.       log_line("ND SD VTD   CPU TIME     ICR");
   794.       for i in 1 .. retro_FIFO_count loop
   795.          if i = 1 then
   796.             log("Ended ");
   797.          else
   798.             log("After ");
   799.          end if;
   800.          declare
   801.             this      : tracing.retro_FIFO_entry renames retro_FIFO(retro_FIFO_index);
   802.             Q         : constant KDF9.Q_register := as_Q(this.parameter);
   803.             decoded   : KDF9.decoded_order;
   804.          begin
   805.             log(oct_of(this.location) & ":");
   806.             tab_log_to(first_col);
   807.             decoded.order := this.order;
   808.             decode(decoded);
   809.             log(the_full_name_of(decoded,
   810.                                  octal_option => decoded.kind = normal_jump_order,
   811.                                  both_bases   => False));
   812.             tab_log_to(operand_col);
   813.             case decoded.kind is
   814.                when one_syllable_order =>
   815.                   if this.nested > 0 then
   816.                      case decoded.compressed_opcode is
   817.                         when DIV
   818.                            | DIVD
   819.                            | X_frac =>
   820.                            log(CPU.fraction'Image(as_fraction(this.parameter)));
   821.                         when DIVI =>
   822.                            log(CPU.signed'Image(resign(this.parameter)));
   823.                         when STAND
   824.                            | ABSF
   825.                            | DIVDF
   826.                            | DIVF
   827.                            | FLOAT_9
   828.                            | FLOATD
   829.                            | MINUSDF
   830.                            | MINUSF
   831.                            | NEGDF
   832.                            | NEGF
   833.                            | PLUSDF
   834.                            | PLUSF
   835.                            | ROUNDF
   836.                            | ROUNDHF
   837.                            | XDF
   838.                            | XF
   839.                            | XPLUSF
   840.                            | MAXF =>
   841.                            Put(image, host_float(CPU.f48(this.parameter)), Aft => 12, Exp => 2);
   842.                            log(trimmed(image));
   843.                         when others =>
   844.                            if this.nested > 0 then
   845.                               log_octal(this.parameter);
   846.                            end if;
   847.                      end case;
   848.                   end if;
   849.                when two_syllable_order =>
   850.                   case decoded.compressed_opcode is
   851.                      when PAR_Qq =>
   852.                         show_IO_register(Q, for_DR => False, for_FD => False);
   853.                      when CT_PMB_PMC_BUSY_Qq
   854.                         | PMA_PMK_INT_Qq
   855.                         | PMD_PME_PML_Qq
   856.                         | PMF_PMG_Qq =>
   857.                         show_IO_register(
   858.                                          Q,
   859.                                          for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
   860.                                          for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
   861.                                          for_seek => decoded.Qk = PMA_bits
   862.                                         );
   863.                      when PIA_PIC_CLO_TLO_Qq
   864.                         | PIB_PID_Qq
   865.                         | PIE_PIG_Qq
   866.                         | PIF_PIH_Qq
   867.                         | POA_POC_POE_POF_PMH_Qq
   868.                         | POB_POD_Qq
   869.                         | POG_POL_Qq
   870.                         | POH_POK_Qq =>
   871.                         show_IO_register(
   872.                                          Q,
   873.                                          for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
   874.                                          for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
   875.                                          for_FH   => for_FH_disc(decoded.compressed_opcode, decoded.Qk)
   876.                                         );
   877.                      when M_PLUS_Iq
   878.                         | M_MINUS_Iq
   879.                         | NCq
   880.                         | DCq
   881.                         | POS1_TO_Iq
   882.                         | NEG1_TO_Iq
   883.                         | POS2_TO_Iq
   884.                         | NEG2_TO_Iq
   885.                         | CqTOQk
   886.                         | IqTOQk
   887.                         | MqTOQk
   888.                         | QqTOQk
   889.                         | CIqTOQk
   890.                         | IMqTOQk
   891.                         | CMqTOQk
   892.                         | TO_RCIMq
   893.                         | ADD_TO_QCIMq
   894.                         | JCqNZS =>
   895.                         show_Q_register(Q);
   896.                      when Kk =>
   897.                         case decoded.Qk is
   898.                            when K4 =>
   899.                               log(KDF9.word'Image(32*KDF9.word(Q.C)));
   900.                               log("us");
   901.                               if Q.I /= 0 then
   902.                                  log("; RFIR: ");
   903.                                  RFIR := as_RFIR(this.parameter);
   904.                                  for r in KDF9.interrupt_number loop
   905.                                     if RFIR(r) then
   906.                                        log(RFIR_id(r)&"");
   907.                                     end if;
   908.                                  end loop;
   909.                               end if;
   910.                               if resign(this.parameter) < 0 then
   911.                                  log("C");
   912.                               end if;
   913.                            when K5 | K7 =>
   914.                               log_octal(this.parameter);
   915.                            when others =>
   916.                               raise emulation_failure
   917.                                  with "invalid K order: #" & oct_of(decoded.compressed_opcode);
   918.                         end case;
   919.                      when TO_LINK =>
   920.                         log(oct_of(as_link(this.parameter)));
   921.                      when LINK =>
   922.                         log(oct_of(as_link(this.parameter)));
   923.                      when TO_MkMq
   924.                         | TO_MkMqQ
   925.                         | TO_MkMqH
   926.                         | TO_MkMqQH
   927.                         | TO_MkMqN
   928.                         | TO_MkMqQN
   929.                         | TO_MkMqHN
   930.                         | TO_MkMqQHN =>
   931.                         log_octal(this.parameter);
   932.                      when others =>
   933.                         if this.nested > 0 then
   934.                            log_octal(this.parameter);
   935.                         end if;
   936.                   end case;
   937.                when normal_jump_order =>
   938.                   case decoded.compressed_opcode is
   939.                      when Jr
   940.                         | JSr =>
   941.                         log(oct_of(as_link(this.parameter)));
   942.                      when EXIT_n =>
   943.                         if this.parameter < 8 then
   944.                            log(this.parameter'Image);
   945.                         else
   946.                            log(oct_of(as_link(this.parameter)));
   947.                         end if;
   948.                      when EXITD =>
   949.                         log(oct_of(as_link(this.parameter)));
   950.                      when JrCqZ
   951.                         | JrCqNZ =>
   952.                         show_Q_register(Q);
   953.                      when OS_OUT =>
   954.                         if this.parameter < 16 then
   955.                            log_octal(this.parameter);
   956.                         elsif this.parameter < 64 then
   957.                            log(this.parameter'Image);
   958.                         elsif this.parameter > 2**47 then
   959.                            log_octal(this.parameter);
   960.                         else
   961.                            show_Q_register(Q);
   962.                         end if;
   963.                      when JrEJ
   964.                         | JrNEJ
   965.                         | JrEN
   966.                         | JrNEN =>
   967.                            log(this.parameter'Image);
   968.                      when JrTR
   969.                         | JrV =>
   970.                            log(Boolean'Image(Boolean'Val(this.parameter)));
   971.                      when JrNTR
   972.                         | JrNV =>
   973.                            log(Boolean'Image(not Boolean'Val(this.parameter)));
   974.                      when others =>
   975.                         if this.nested > 0 then
   976.                            log_octal(this.parameter);
   977.                         end if;
   978.                      end case;
   979.                when others =>
   980.                   if this.nested > 0 then
   981.                      log_octal(this.parameter);
   982.                   end if;
   983.             end case;
   984.             tab_log_to(depth_col);
   985.             log(just_right(this.nested'Image,2));
   986.             log(" ");
   987.             log(just_right(this.called'Image,2));
   988.             log(" ");
   989.             log(if this.V then "V" else " ");
   990.             log(if this.T then "T" else " ");
   991.             log(if this.D then "D" else " ");
   992.             tab_log_to(time_col);
   993.             log(this.CPU_time'Image);
   994.             tab_log_to(ICR_col);
   995.             log(this.ICR_value'Image);
   996.             log_new_line;
   997.          end;
   998.          retro_FIFO_index := retro_FIFO_index - 1;
   999.       end loop;
  1000.       if retro_FIFO_count = FIFO_size then
  1001.          log("After earlier instructions, whose tracing is now lost.");
  1002.       else
  1003.          log("After the start of traced execution.");
  1004.       end if;
  1005.       log_new_line;
  1006.       log_rule;
  1007.    end show_retro_FIFO;
  1008.
  1009.    the_final_ICR : KDF9.order_counter := 0;
  1010.
  1011.    procedure notify_state_display_of_final_ICR is
  1012.    begin
  1013.       the_final_ICR := ICR;
  1014.    end notify_state_display_of_final_ICR;
  1015.
  1016.    procedure show_IOC_FIFO is
  1017.    begin
  1018.       if IOC_FIFO_count = 0 then return; end if;
  1019.       log_title("Retrospective trace of peripheral I/O events.");
  1020.       tab_log_to(is_D_col);
  1021.       log_line("CPL T   EL. TIME     ICR");
  1022.       for i in 1 .. IOC_FIFO_count loop
  1023.          if i = 1 then
  1024.             log("Ended ");
  1025.          else
  1026.             log("After ");
  1027.          end if;
  1028.
  1029.          declare
  1030.             this    : tracing.IOC_FIFO_entry renames IOC_FIFO(IOC_FIFO_index);
  1031.             decoded : constant KDF9.decoded_order := this.decoded_order;
  1032.
  1033.             procedure show_transfer (
  1034.                                      Q                 : in KDF9.Q_register;
  1035.                                      for_OUT, for_seek : in Boolean := False
  1036.                                     ) is
  1037.             begin
  1038.                case decoded.compressed_opcode is
  1039.                   when PAR_Qq =>
  1040.                      show_IO_register(Q, for_DR => False, for_FD => False);
  1041.                   when CT_PMB_PMC_BUSY_Qq
  1042.                      | PMA_PMK_INT_Qq
  1043.                      | PMD_PME_PML_Qq
  1044.                      | PMF_PMG_Qq =>
  1045.                      show_IO_register(
  1046.                                       Q,
  1047.                                       for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
  1048.                                       for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
  1049.                                       for_seek => (decoded.Qk in PMA_bits) or show_transfer.for_seek,
  1050.                                       for_OUT  => show_transfer.for_OUT
  1051.                                      );
  1052.                   when PIA_PIC_CLO_TLO_Qq
  1053.                      | PIB_PID_Qq
  1054.                      | PIE_PIG_Qq
  1055.                      | PIF_PIH_Qq
  1056.                      | POA_POC_POE_POF_PMH_Qq
  1057.                      | POB_POD_Qq
  1058.                      | POG_POL_Qq
  1059.                      | POH_POK_Qq
  1060.                      | OS_OUT =>
  1061.                      show_IO_register(
  1062.                                       Q,
  1063.                                       for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
  1064.                                       for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
  1065.                                       for_FH   => for_FH_disc(decoded.compressed_opcode, decoded.Qk),
  1066.                                       for_OUT  => show_transfer.for_OUT
  1067.                                      );
  1068.                   when others =>
  1069.                      raise emulation_failure
  1070.                         with "invalid IO order: #" & oct_of(decoded.compressed_opcode);
  1071.                end case;
  1072.             end show_transfer;
  1073.
  1074.             shown_ICR : KDF9.order_counter := this.ICR_value;
  1075.             FD_seek   : Boolean := False;
  1076.             FD_xfer   : Boolean := False;
  1077.
  1078.          begin -- show_IOC_FIFO
  1079.             log(oct_of(this.order_address) & ":");
  1080.             tab_log_to(first_col);
  1081.             if the_full_name_of(this.decoded_order) = "OUT"  then
  1082.                 if this.device_name(1..2) in "MT" | "ST" and then
  1083.                       this.ICR_value >= the_final_ICR        then
  1084.                   log("OUT 0/2 rewind");
  1085.                   shown_ICR := the_final_ICR + 1;
  1086.                elsif this.device_name(1..2) in "MT" | "ST" then
  1087.                   log("OUT 6/7 rewind");
  1088.                elsif this.device_name(1..2) in "LP" | "TP" then
  1089.                   log("OUT 8");
  1090.                elsif this.device_name(1..2) = "DR" then
  1091.                   if this.kind in start_transfer | finis_transfer | buffer_lockout | store_lockout then
  1092.                      log(if this.operation = output_operation then "OUT 11" else "OUT 12");
  1093.                   else
  1094.                      log("OUT 11/12");
  1095.                   end if;
  1096.                elsif this.device_name(1..2) = "FD" then
  1097.                   if this.kind in start_transfer | finis_transfer | buffer_lockout | store_lockout then
  1098.                      log(if this.operation = output_operation then "OUT 41" else "OUT 42");
  1099.                   else
  1100.                      log("OUT 41/42 seek"); FD_seek := True;
  1101.                   end if;
  1102.                elsif this.device_name(1..2) = "FW" then
  1103.                   log("OUT 8/16");
  1104.                else
  1105.                   log("OUT ?");
  1106.                end if;
  1107.             else
  1108.                log(mnemonic(the_full_name_of(this.decoded_order), this.device_name));
  1109.             end if;
  1110.             tab_log_to(device_col);
  1111.             log(this.device_name);
  1112.             case this.kind is
  1113.                when store_lockout =>
  1114.                   tab_log_to(event_col);
  1115.                   log("locks out #");
  1116.                   log(oct_of(this.data_address));
  1117.                   log(" = E");
  1118.                   log(dec_of(this.data_address));
  1119.                   tab_log_to(is_D_col);
  1120.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1121.                   log(this.priority_level'Image);
  1122.                   tab_log_to(time_col);
  1123.                   log(this.initiation_time'Image);
  1124.                   tab_log_to(ICR_col);
  1125.                   log(shown_ICR'Image);
  1126.                 when buffer_lockout =>
  1127.                   tab_log_to(event_col);
  1128.                   log("buffer lockout");
  1129.                   tab_log_to(is_D_col);
  1130.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1131.                   log(this.priority_level'Image);
  1132.                   tab_log_to(time_col);
  1133.                   log(this.initiation_time'Image);
  1134.                   tab_log_to(ICR_col);
  1135.                   log(shown_ICR'Image);
  1136.                when start_transfer =>
  1137.                   tab_log_to(event_col);
  1138.                   show_transfer(this.control_word);
  1139.                   tab_log_to(is_D_col);
  1140.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1141.                   log(this.priority_level'Image);
  1142.                   tab_log_to(time_col-2);
  1143.                   log(" S" & this.initiation_time'Image);
  1144.                   tab_log_to(ICR_col);
  1145.                   log(shown_ICR'Image);
  1146.                when finis_transfer =>
  1147.                   tab_log_to(event_col);
  1148.                   show_transfer(this.control_word);
  1149.                   tab_log_to(is_D_col);
  1150.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1151.                   log(this.priority_level'Image);
  1152.                   tab_log_to(time_col-2);
  1153.                   log(" E" & this.completion_time'Image);
  1154.                   tab_log_to(ICR_col);
  1155.                   log(shown_ICR'Image);
  1156.                when buffer_status =>
  1157.                   tab_log_to(event_col);
  1158.                   FD_xfer := this.device_name(1..2) = "FD";
  1159.                   -- PMFQq entails no data transfer or seek, but has a sector address parameter.
  1160.                   FD_seek := (FD_seek or (decoded.Qk in PMA_bits)) and FD_xfer;
  1161.                   FD_seek := FD_seek and decoded.compressed_opcode /= PMF_PMG_Qq;
  1162.                   show_IO_register(this.Q_register, for_FD => FD_xfer, for_seek => FD_seek);
  1163.                   tab_log_to(is_D_col);
  1164.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1165.                   log(this.priority_level'Image);
  1166.                   log(if this.status then " Y" else " N");
  1167.                   tab_log_to(time_col);
  1168.                   log(this.initiation_time'Image);
  1169.                   tab_log_to(ICR_col);
  1170.                   log(shown_ICR'Image);
  1171.             end case;
  1172.             log_new_line;
  1173.          end;
  1174.          IOC_FIFO_index := IOC_FIFO_index - 1;
  1175.       end loop;
  1176.       if IOC_FIFO_count = FIFO_size then
  1177.          log_line("After earlier instructions, whose tracing is now lost.");
  1178.       else
  1179.          log_line("After the start of traced execution.");
  1180.       end if;
  1181.       log_line("Total time waiting for unoverlapped I/O to finish ="
  1182.              & KDF9.us'Image((the_clock_time-the_CPU_time+500) / 1000)
  1183.              & " ms.");
  1184.       log_rule;
  1185.    end show_IOC_FIFO;
  1186.
  1187.    procedure show_interrupt_FIFO is
  1188.    begin
  1189.       if interrupt_FIFO_count = 0 then return; end if;
  1190.       log_title("Retrospective trace of interrupt requests.");
  1191.       tab_log_to(is_D_col);
  1192.       log_line("CPL     EL. TIME     ICR");
  1193.       for i in 1 .. interrupt_FIFO_count loop
  1194.          log(if i = 1 then "Ended " else "After ");
  1195.          declare
  1196.             this : tracing.interrupt_FIFO_entry renames interrupt_FIFO(interrupt_FIFO_index);
  1197.          begin
  1198.             log(oct_of(this.order_address) & ": ");
  1199.             tab_log_to(first_col);
  1200.             log(case this.interrupt_code is
  1201.                    when PR_interrupt     => "PR   ",
  1202.                    when FLEX_interrupt   => "FLEX ",
  1203.                    when LIV_interrupt    => "LIV  ",
  1204.                    when NOUV_interrupt   => "NOUV ",
  1205.                    when EDT_interrupt    => "EDT  ",
  1206.                    when OUT_interrupt    => "OUT  ",
  1207.                    when LOV_interrupt    => "LOV  ",
  1208.                    when RESET_interrupt  => "RESET",
  1209.                    when CLOCK_interrupt  => "CLOCK",
  1210.                    when EXITD_flag       => "EXITD"
  1211.                );
  1212.             tab_log_to(event_col-4);
  1213.             log(trimmed(this.message));
  1214.             tab_log_to(is_D_col);
  1215.             log(slot_name(this.context));
  1216.             log(this.priority_level'Image);
  1217.             tab_log_to(time_col);
  1218.             log(this.busy_time'Image);
  1219.             tab_log_to(ICR_col);
  1220.             log(this.ICR_value'Image);
  1221.             log_new_line;
  1222.          end;
  1223.          interrupt_FIFO_index := interrupt_FIFO_index - 1;
  1224.       end loop;
  1225.       log(
  1226.           if interrupt_FIFO_count = FIFO_size then
  1227.              "After earlier interrupts, whose tracing is now lost."
  1228.           else
  1229.             "After the start of traced execution."
  1230.          );
  1231.       log_new_line;
  1232.       log_new_line;
  1233.    end show_interrupt_FIFO;
  1234.
  1235.    procedure show_retrospective_traces is
  1236.    begin
  1237.       if the_peripheral_trace_is_enabled then
  1238.          pragma Debug(IOC.diagnostics);
  1239.       end if;
  1240.       if the_interrupt_trace_is_enabled then
  1241.          show_interrupt_FIFO;
  1242.       end if;
  1243.       if the_peripheral_trace_is_enabled then
  1244.          show_IOC_FIFO;
  1245.       end if;
  1246.       if the_retrospective_trace_is_enabled then
  1247.          show_retro_FIFO;
  1248.       end if;
  1249.    end show_retrospective_traces;
  1250.
  1251.    procedure show_current_state is
  1252.    begin
  1253.       show_execution_context;
  1254.       log_rule;
  1255.       show_registers;
  1256.       log_rule;
  1257.    end show_current_state;
  1258.
  1259.    procedure show_final_state (because : in String) is
  1260.    begin
  1261.       if the_final_state_is_wanted then
  1262.          if loading_was_successful then
  1263.             -- make sure there is at least one NL after any FW output.
  1264.             if the_log_is_wanted then
  1265.                log_new_line;
  1266.                log_rule;
  1267.             else
  1268.                log_new_line;
  1269.             end if;
  1270.             log_line("Final State: " & because & ".");
  1271.             if not the_log_is_wanted then return; end if;
  1272.             long_witness;
  1273.             log_rule;
  1274.
  1275.             if nr_of_post_dumping_areas /= 0 then
  1276.                log_title("Post-run Dump:");
  1277.                print_postrun_dump_areas;
  1278.             end if;
  1279.
  1280.             if the_INS_plot_is_wanted or the_profile_is_wanted then
  1281.                if the_histogram_is_enabled then
  1282.                   show_frequency_plots;
  1283.                end if;
  1284.             end if;
  1285.
  1286.             show_retrospective_traces;
  1287.
  1288.             if the_signature_is_enabled then
  1289.                log_title("Digital signature of traced orders = #"
  1290.                        & oct_of(the_digital_signature)
  1291.                        & ".");
  1292.             end if;
  1293.          else
  1294.             log_line("ee9: " & because & ".");
  1295.             show_all_prerun_dump_areas;
  1296.             return;
  1297.          end if;
  1298.       end if;
  1299.    end show_final_state;
  1300.
  1301.    procedure show_all_prerun_dump_areas is
  1302.    begin
  1303.       if the_log_is_wanted and nr_of_pre_dumping_areas /= 0 then
  1304.          log_title("Pre-run Dump:");
  1305.          print_prerun_dump_areas;
  1306.          remove_prerun_dump_areas;
  1307.       end if;
  1308.    end show_all_prerun_dump_areas;
  1309.
  1310.    quantum     : constant := 8;
  1311.    jump_tab    : constant := 12;
  1312.    first_tab   : constant := 16;
  1313.    last_column : constant := 80;
  1314.
  1315.    function is_non_blank (first : in KDF9.address)
  1316.    return Boolean is
  1317.       result : Boolean := False;
  1318.    begin
  1319.       for address in first .. first+quantum-1 loop
  1320.          result := result or (fetch_word(address) /= 0);
  1321.       end loop;
  1322.       return result;
  1323.    end is_non_blank;
  1324.
  1325.    subtype converted_word is String(1..8);
  1326.
  1327.    type convertor is
  1328.       not null access function (address : KDF9.address) return converted_word;
  1329.
  1330.    procedure show_core (first, last : in KDF9.address;
  1331.                         head, side  : in String;
  1332.                         converted   : in convertor) is
  1333.
  1334.       procedure show_group (first : in KDF9.address) is
  1335.          address : KDF9.address := first;
  1336.       begin
  1337.          while address <= first+quantum-1 loop
  1338.             log(converted(address));
  1339.             address := address + 1;
  1340.             exit when address < first;
  1341.          end loop;
  1342.       end show_group;
  1343.
  1344.       address : KDF9.address := first;
  1345.
  1346.    begin
  1347.       if (last-first+1) < 1 then
  1348.          return;
  1349.       end if;
  1350.       BA := 0; -- Ensure that physical store is examined when running in boot mode.
  1351.       log_title("Core store [#" & oct_of(first) & " .. #" & oct_of(last) & "] interpreted as " & head & ":");
  1352.       while address <= last loop
  1353.          if is_non_blank(address) then
  1354.             log_octal(KDF9.field_of_16_bits(address));
  1355.             log(":");
  1356.             tab_log_to(jump_tab);
  1357.             log(side);
  1358.             log(" """);
  1359.             show_group(address);
  1360.             log("""");
  1361.             log_new_line;
  1362.          else
  1363.             log_line("========  blank  ========");
  1364.          end if;
  1365.       exit when address >= KDF9.address'Last - quantum;
  1366.          address := address + quantum;
  1367.       end loop;
  1368.       log_new_line;
  1369.    end show_core;
  1370.
  1371.    function encoding_of (address : KDF9.address; code_table : output_code_table)
  1372.    return converted_word is
  1373.       result : converted_word;
  1374.    begin
  1375.       for b in KDF9_char_sets.symbol_index loop
  1376.          result(Natural(b)+1) := glyph_for(code_table(fetch_symbol(address, b)));
  1377.       end loop;
  1378.       return result;
  1379.    end encoding_of;
  1380.
  1381.    current_case : KDF9_char_sets.symbol := KDF9_char_sets.Case_Normal;
  1382.
  1383.    function interpretation_of (address : KDF9.address)
  1384.    return converted_word is
  1385.       result : converted_word;
  1386.       symbol : KDF9_char_sets.symbol;
  1387.       char   : Character;
  1388.    begin
  1389.       for b in KDF9_char_sets.symbol_index loop
  1390.          symbol := fetch_symbol(address, b);
  1391.          if current_case = KDF9_char_sets.Case_Normal then
  1392.             char := TP_CN(symbol);
  1393.          else
  1394.             char := TP_CS(symbol);
  1395.          end if;
  1396.          if symbol = KDF9_char_sets.Case_Normal then
  1397.             current_case := KDF9_char_sets.Case_Normal;
  1398.          elsif symbol = KDF9_char_sets.Case_Shift then
  1399.             current_case := KDF9_char_sets.Case_Shift;
  1400.          end if;
  1401.          result(Natural(b)+1) := glyph_for(char);
  1402.       end loop;
  1403.       return result;
  1404.    end interpretation_of;
  1405.
  1406.    function case_visible (address : KDF9.address)
  1407.    return converted_word
  1408.    is (interpretation_of(address));
  1409.
  1410.    function case_normal (address : KDF9.address)
  1411.    return converted_word
  1412.    is (encoding_of(address, code_table => TP_CN));
  1413.
  1414.    function case_shift (address : KDF9.address)
  1415.    return converted_word
  1416.    is (encoding_of(address, code_table => TP_CS));
  1417.
  1418.    function printer_code (address : KDF9.address)
  1419.    return converted_word
  1420.    is (encoding_of(address, code_table => to_LP));
  1421.
  1422.    function card_code (address : KDF9.address)
  1423.    return converted_word
  1424.    is (encoding_of(address, code_table => to_CP));
  1425.
  1426.    function Latin_1_code (address : KDF9.address)
  1427.    return converted_word
  1428.    is (converted_word'(1..7 => Space,
  1429.                        8    => glyph_for(Character'Val(fetch_word(address) and 8#377#))));
  1430.
  1431.    procedure show_core_in_case_visible (first, last : in KDF9.address) is
  1432.    begin
  1433.       show_core(first, last,
  1434.                 head => "characters in TR/TP code with case shifting",
  1435.                 side => "  ",
  1436.                 converted => case_visible'Access);
  1437.    end show_core_in_case_visible;
  1438.
  1439.    procedure show_core_in_case_normal (first, last : in KDF9.address) is
  1440.    begin
  1441.       show_core(first, last,
  1442.                 head => "characters in TR/TP Normal Case code",
  1443.                 side => "NC",
  1444.                 converted => case_normal'Access);
  1445.    end show_core_in_case_normal;
  1446.
  1447.    procedure show_core_in_case_shift (first, last : in KDF9.address) is
  1448.    begin
  1449.       show_core(first, last,
  1450.                 head => "characters in TR/TP Shift Case code",
  1451.                 side => "SC",
  1452.                 converted => case_shift'Access);
  1453.    end show_core_in_case_shift;
  1454.
  1455.    procedure show_core_in_print_code (first, last : in KDF9.address) is
  1456.    begin
  1457.       show_core(first, last,
  1458.                 head => "characters in LP code",
  1459.                 side => "LP",
  1460.                 converted => printer_code'Access);
  1461.    end show_core_in_print_code;
  1462.
  1463.    procedure show_core_in_card_code (first, last : in KDF9.address) is
  1464.    begin
  1465.       show_core(first, last,head => "characters in CR/CP code",
  1466.                 side => "CP",
  1467.                 converted => card_code'Access);
  1468.    end show_core_in_card_code;
  1469.
  1470.    procedure show_core_in_Latin_1 (first, last : in KDF9.address) is
  1471.    begin
  1472.       show_core(first, last,
  1473.                 head => "words with bits 40-47 of each in Latin-1 code",
  1474.                 side => "L1",
  1475.                 converted => Latin_1_code'Access);
  1476.    end show_core_in_Latin_1;
  1477.
  1478.    procedure show_core_in_tape_code (first, last : in KDF9.address) is
  1479.    begin
  1480.       show_core_in_case_visible(first, last);
  1481.    end show_core_in_tape_code;
  1482.
  1483.    procedure show_core_as_word_forms (first, last  : KDF9.address) is
  1484.
  1485.       procedure show_word (address : KDF9.address) is
  1486.          word : constant KDF9.word := fetch_word(address);
  1487.       begin
  1488.          log_octal(KDF9.field_of_16_bits(address));
  1489.          log(":");
  1490.          tab_log_to(jump_tab);
  1491.          show_in_various_formats(word, column => jump_tab);
  1492.          log_new_line;
  1493.       end show_word;
  1494.
  1495.       procedure show_word_group (first, last  : KDF9.address) is
  1496.          last_address : KDF9.address := first;
  1497.          this_word, last_word : KDF9.word;
  1498.       begin
  1499.          if last = first or last = 0 then
  1500.             show_word(last);
  1501.             return;
  1502.          end if;
  1503.          this_word := fetch_word(first);
  1504.          last_word := this_word;
  1505.          show_word(first);
  1506.          for address in first+1 .. last-1 loop
  1507.             this_word := fetch_word(address);
  1508.             if this_word = last_word and address = last_address+1 then
  1509.                log_line("==========  ditto  ========");
  1510.             elsif this_word /= last_word then
  1511.                show_word(address);
  1512.                last_word := this_word;
  1513.                last_address := address;
  1514.             end if;
  1515.          end loop;
  1516.          if last > first then
  1517.             show_word(last);
  1518.          end if;
  1519.       end show_word_group;
  1520.
  1521.    begin
  1522.       if first > last then
  1523.          return;
  1524.       end if;
  1525.       BA := 0; -- Ensure that physical store is examined when running in boot mode.
  1526.       log_title("Core store interpreted as 48-bit words:");
  1527.       show_word_group(first, last);
  1528.       log_new_line;
  1529.    end show_core_as_word_forms;
  1530.
  1531.    -- Each word of code space is described by a set of flags.
  1532.    -- Flags 0 .. 5 are set iff a jump order has that syllable as target.
  1533.    -- Flag 6 is set if the word is thought to be code, but not a target.
  1534.    -- Flag 7 is set if the word is thought to be addressed as data.
  1535.
  1536.    is_a_code_word : constant KDF9.syllable_index := 6;
  1537.    is_a_data_word : constant KDF9.syllable_index := 7;
  1538.
  1539.    package word_flags is new generic_sets(member => KDF9.syllable_index);
  1540.    use word_flags;
  1541.
  1542.    all_jump_targets : constant word_flags.set := (0 .. 5 => True, 6|7 => False);
  1543.
  1544.    analysis_flags : array (KDF9.order_word_number) of word_flags.set;
  1545.
  1546.    function "/" (word : KDF9.order_word_number; flag : KDF9.syllable_index)
  1547.    return Boolean
  1548.    is (analysis_flags(word)(flag));
  1549.
  1550.    function is_a_jump_target (the_point : in KDF9.syllable_address)
  1551.    return Boolean
  1552.    is (analysis_flags(the_point.order_word_number)(the_point.syllable_index));
  1553.
  1554.    function is_a_jump_target (the_operand : in KDF9.order_word_number)
  1555.    return Boolean
  1556.    is ((analysis_flags(the_operand) and all_jump_targets) /= empty_set);
  1557.
  1558.    procedure clear_all_analysis_flags is
  1559.    begin
  1560.       analysis_flags := (others => empty_set);
  1561.    end clear_all_analysis_flags;
  1562.
  1563.    procedure unmark_as_a_data_word (the_operand : in KDF9.order_word_number) is
  1564.    begin
  1565.       analysis_flags(the_operand)(is_a_data_word) := False;
  1566.    end unmark_as_a_data_word;
  1567.
  1568.    procedure unmark_as_a_code_word (the_operand : in KDF9.order_word_number) is
  1569.    begin
  1570.       analysis_flags(the_operand)(is_a_code_word) := False;
  1571.    end unmark_as_a_code_word;
  1572.
  1573.    procedure mark_as_a_code_word (the_operand : in KDF9.order_word_number) is
  1574.    begin
  1575.       analysis_flags(the_operand)(is_a_code_word) := True;
  1576.       unmark_as_a_data_word(the_operand);
  1577.    end mark_as_a_code_word;
  1578.
  1579.    procedure mark_as_a_jump_target (the_point : in KDF9.syllable_address) is
  1580.    begin
  1581.       analysis_flags(the_point.order_word_number)(the_point.syllable_index) := True;
  1582.       mark_as_a_code_word(the_point.order_word_number);
  1583.    end mark_as_a_jump_target;
  1584.
  1585.    procedure mark_as_a_data_word (the_operand : in KDF9.order_word_number) is
  1586.    begin
  1587.       analysis_flags(the_operand)(is_a_data_word) := True;
  1588.       unmark_as_a_code_word(the_operand);
  1589.    end mark_as_a_data_word;
  1590.
  1591.    procedure mark_all_code_blocks_and_data_blocks is
  1592.
  1593.       procedure mark_all_code_blocks (the_beginning : in KDF9.syllable_address) is
  1594.          address : KDF9.syllable_address := the_beginning;
  1595.       begin
  1596.          if address.syllable_index > 5 then
  1597.             return;  -- We have blundered into non-code words.
  1598.          end if;
  1599.          -- Mark the first syllable of the block.
  1600.          mark_as_a_jump_target(the_beginning);
  1601.          -- Mark the destinations of all jumps in the block as code.
  1602.          loop
  1603.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1604.          exit when address.order_word_number = 8191;
  1605.             set_NIA_to(address);
  1606.             decode_the_next_order;
  1607.             if is_an_invalid_order(INS)                                                  or else
  1608.                   (address.order_word_number/is_a_data_word and address.syllable_index = 0) then
  1609.                return;
  1610.             else
  1611.                -- Assuming a valid code word, act on it.
  1612.                mark_as_a_code_word(address.order_word_number);
  1613.                case INS.kind is
  1614.                   when normal_jump_order =>
  1615.                      if not is_a_jump_target((INS.target.order_word_number, INS.target.syllable_index)) then
  1616.                         -- Mark the jump's destination recursively.
  1617.                         -- N.B. EXIT is actioned only if it is of EXIT ARr type.
  1618.                         mark_all_code_blocks((INS.target.order_word_number, INS.target.syllable_index));
  1619.                      end if;
  1620.                      increment_by_3(address);
  1621.                      if INS.compressed_opcode = JSr  then
  1622.                         -- Mark its return point.
  1623.                         mark_as_a_jump_target(address);
  1624.                      end if;
  1625.                   when one_syllable_order =>
  1626.                      increment_by_1(address);
  1627.                   when two_syllable_order =>
  1628.                      if INS.compressed_opcode = JCqNZS then
  1629.                         -- Mark the preceding word.
  1630.                         mark_as_a_jump_target((address.order_word_number-1, 0));
  1631.                      end if;
  1632.                      increment_by_2(address);
  1633.                   when data_access_order =>
  1634.                      increment_by_3(address);
  1635.                end case;
  1636.             end if;
  1637.          end loop;
  1638.       end mark_all_code_blocks;
  1639.
  1640.       procedure mark_all_data_blocks (the_beginning : in KDF9.syllable_address) is
  1641.          address : KDF9.syllable_address := the_beginning;
  1642.       begin
  1643.          if address.syllable_index > 5 then
  1644.             return;  -- We have blundered into non-code words.
  1645.          end if;
  1646.          the_code_block_handler: loop
  1647.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1648.          exit when address.order_word_number = 8191;
  1649.             -- Process orders, starting at an established code word.
  1650.             set_NIA_to(address); -- **
  1651.             decode_the_next_order;
  1652.             if (is_an_invalid_order(INS)                         or else
  1653.                   address.order_word_number/is_a_data_word)     and then
  1654.                      not (address.order_word_number/is_a_code_word) then
  1655.                -- This word is data: make sure it is not designated as code;
  1656.                --    and find the start of the next code block.
  1657.                for a in address.order_word_number .. 8190 loop
  1658.                   address := (a, 0);
  1659.                   exit when is_a_jump_target(a);
  1660.                   unmark_as_a_code_word(a);
  1661.                   mark_as_a_data_word(a);
  1662.                end loop;
  1663.
  1664.                exit the_code_block_handler
  1665.                   when address.order_word_number = 8190;
  1666.
  1667.                -- Find the syllable at which the block starts.
  1668.                for s in KDF9.syllable_index'(0) .. 5 loop
  1669.                   address.syllable_index := s;
  1670.                   exit when is_a_jump_target(address);
  1671.                end loop;
  1672.
  1673.             else
  1674.
  1675.                -- Assuming a valid code word, act on it.
  1676.                case INS.kind is
  1677.                   when data_access_order =>
  1678.                      if INS.operand < 8192 then
  1679.                         declare
  1680.                            operand : constant KDF9.order_word_number
  1681.                                    := KDF9.order_word_number(INS.operand);
  1682.                         begin
  1683.                            if INS.compressed_opcode /= KDF9.decoding.SET and then
  1684.                                  not is_a_jump_target(operand)               then
  1685.                               mark_as_a_data_word(operand);
  1686.                            end if;
  1687.                         end;
  1688.                      end if;
  1689.                      increment_by_3(address);
  1690.                   when one_syllable_order =>
  1691.                      increment_by_1(address);
  1692.                   when two_syllable_order =>
  1693.                      increment_by_2(address);
  1694.                   when normal_jump_order =>
  1695.                      increment_by_3(address);
  1696.                end case;
  1697.             end if;
  1698.
  1699.             exit the_code_block_handler
  1700.                when address.order_word_number = KDF9.order_word_number'Last;
  1701.
  1702.          end loop the_code_block_handler;
  1703.       end mark_all_data_blocks;
  1704.
  1705.       procedure reset_wrong_data_marks (the_beginning : in KDF9.syllable_address) is
  1706.          address : KDF9.syllable_address := the_beginning;
  1707.          locus   : KDF9.order_word_number;
  1708.       begin
  1709.          if address.syllable_index > 5 then
  1710.             return;  -- We have blundered into non-code words.
  1711.          end if;
  1712.          -- Unmark the first instruction of the block.
  1713.          unmark_as_a_data_word(address.order_word_number);
  1714.
  1715.          -- Unmark data marks on destinations of jumps.
  1716.          loop
  1717.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1718.          exit when address.order_word_number = 8191;
  1719.             set_NIA_to(address);
  1720.             decode_the_next_order;
  1721.             if is_an_invalid_order(INS)                          or else
  1722.                   address.order_word_number/is_a_data_word       or else
  1723.                      not (address.order_word_number/is_a_code_word) then
  1724.                -- We have reached the end of the code block.
  1725.                return;
  1726.             else
  1727.                -- Assuming a valid code word, act on it.
  1728.                case INS.kind is
  1729.                   when normal_jump_order =>
  1730.                      locus := address.order_word_number;
  1731.                      increment_by_3(address);
  1732.                      if INS.target.order_word_number/is_a_data_word    then
  1733.                         -- UNmark the jump's destination recursively.
  1734.                         reset_wrong_data_marks((INS.target.order_word_number, INS.target.syllable_index));
  1735.                      end if;
  1736.                      if INS.compressed_opcode /= Jr          and then
  1737.                            INS.compressed_opcode /= EXIT_n   and then
  1738.                               locus /= address.order_word_number then
  1739.                         -- It flows on, so the next word cannot be data.
  1740.                         unmark_as_a_data_word(address.order_word_number);
  1741.                      elsif not (address.order_word_number/is_a_data_word) then
  1742.                         -- The next syllable starts a block, iff it is not the end of a block.
  1743.                         set_NIA_to(address);
  1744.                         decode_the_next_order;
  1745.                         if not is_an_invalid_order(INS) then
  1746.                            mark_as_a_jump_target(address);
  1747.                         end if;
  1748.                      end if;
  1749.                   when one_syllable_order =>
  1750.                      increment_by_1(address);
  1751.                   when two_syllable_order =>
  1752.                      increment_by_2(address);
  1753.                   when data_access_order =>
  1754.                      increment_by_3(address);
  1755.                end case;
  1756.             end if;
  1757.             exit when address.order_word_number = KDF9.order_word_number'Last;
  1758.          end loop;
  1759.       end reset_wrong_data_marks;
  1760.
  1761.       procedure mark_the_words_reachable_from (address : in KDF9.syllable_address) is
  1762.          start_point : KDF9.syllable_address;
  1763.       begin
  1764.          mark_as_a_jump_target(address);
  1765.          set_NIA_to(address);
  1766.          decode_the_next_order;
  1767.          if INS.kind =normal_jump_order then
  1768.          start_point := (INS.target.order_word_number, INS.target.syllable_index);
  1769.          mark_all_code_blocks(start_point);
  1770.          mark_all_data_blocks(start_point);
  1771.          reset_wrong_data_marks(start_point);
  1772.          end if;
  1773.       end mark_the_words_reachable_from;
  1774.
  1775.       procedure markup_a_problem_program is
  1776.       begin
  1777.          if the_initial_jump_was_corrupted then
  1778.             -- We cannot sensibly locate the order words using E0  ...
  1779.             log_new_line;
  1780.             log_line("The initial jump, in E0U, has been corrupted!");
  1781.             log_new_line;
  1782.             show_core_as_syllables((0, 0), (5, 0));
  1783.             --  ... so restore it to the value it had on loading.
  1784.             restore_the_initial_jump;
  1785.             log_line("E0U has been restored to the value it had on loading.");
  1786.             log_new_line;
  1787.          end if;
  1788.
  1789.          -- Mark all orders reachable from the initial jump in E0 and the restart jumps in E4.
  1790.
  1791.          mark_the_words_reachable_from((0, 0));
  1792.          mark_the_words_reachable_from((0, 4));
  1793.          mark_the_words_reachable_from((1, 4));
  1794.
  1795.          -- Mark the words between E0 and P0 as data, skipping E4.
  1796.          mark_as_a_data_word(1);
  1797.          mark_as_a_data_word(2);
  1798.          mark_as_a_data_word(3);
  1799.          set_NIA_to((0, 0));
  1800.          decode_the_next_order;
  1801.          for d in 5 .. INS.target.order_word_number-1 loop
  1802.             mark_as_a_data_word(d);
  1803.          end loop;
  1804.
  1805.          the_program_has_been_analysed := True;
  1806.       end markup_a_problem_program;
  1807.
  1808.       -- This analysis assumes that the Director has much the same structure as KKT40E007UPU.
  1809.       procedure markup_a_Director is
  1810.
  1811.       begin
  1812.          BA := 0;  -- Director starts at physical word 0.
  1813.
  1814.          mark_as_a_code_word(0);
  1815.          mark_as_a_code_word(1);
  1816.          mark_as_a_code_word(2);
  1817.          mark_as_a_data_word(3);
  1818.          mark_as_a_code_word(4);
  1819.
  1820.          for a in nominated_address .. 3200 loop  -- 3200 was the size of the Eldon 2 Director.
  1821.             -- mark_as_a_code_word(a);
  1822.             -- mark_as_a_jump_target((a, 0));
  1823.             set_NIA_to((a, 0));
  1824.             decode_the_next_order;
  1825.             if INS.kind = normal_jump_order then
  1826.                mark_the_words_reachable_from((a, 0));
  1827.             elsif INS.kind = data_access_order then
  1828.                if INS.operand < 8192 then
  1829.                   declare
  1830.                      operand : constant KDF9.order_word_number
  1831.                              := KDF9.order_word_number(INS.operand);
  1832.                   begin
  1833.                      if INS.compressed_opcode /= KDF9.decoding.SET and then
  1834.                            not is_a_jump_target(operand)               then
  1835.                         mark_as_a_data_word(operand);
  1836.                      end if;
  1837.                   end;
  1838.                end if;
  1839.              else
  1840.                 mark_as_a_jump_target((a, 0));
  1841.             end if;
  1842.             set_NIA_to((a, 3));
  1843.             decode_the_next_order;
  1844.             if INS.kind = normal_jump_order then
  1845.                mark_the_words_reachable_from((a, 3));
  1846.             elsif INS.kind = data_access_order then
  1847.                if INS.operand < 8192 then
  1848.                   declare
  1849.                      operand : constant KDF9.order_word_number
  1850.                              := KDF9.order_word_number(INS.operand);
  1851.                   begin
  1852.                      if INS.compressed_opcode /= KDF9.decoding.SET and then
  1853.                            not is_a_jump_target(operand)               then
  1854.                         mark_as_a_data_word(operand);
  1855.                      end if;
  1856.                   end;
  1857.                end if;
  1858.              else
  1859.                 mark_as_a_jump_target((a, 3));
  1860.             end if;
  1861.          end loop;
  1862.
  1863.          -- Mark all orders reachable from the initial jump(s).
  1864.
  1865.          set_NIA_to((order_word_number => 2, syllable_index => 0));
  1866.          decode_the_next_order;
  1867.          if INS.kind /= normal_jump_order then
  1868.             log_line("An initial jump, in E2U, has not been found!");
  1869.          else
  1870.             mark_the_words_reachable_from((0, 2));
  1871.             -- Mark the words between E4 and P0 as data.
  1872.             set_NIA_to((0, 2));
  1873.             decode_the_next_order;
  1874.             for d in 5 .. INS.target.order_word_number-1 loop
  1875.                mark_as_a_data_word(d);
  1876.             end loop;
  1877.             the_program_has_been_analysed := True;
  1878.          end if;
  1879.
  1880.          set_NIA_to((0, 4));
  1881.          decode_the_next_order;
  1882.          if INS.kind /= normal_jump_order then
  1883.             log_line("An expected jump, in E4U, has not been found!");
  1884.             return;
  1885.          else
  1886.             mark_the_words_reachable_from((0, 4));
  1887.             the_program_has_been_analysed := True;
  1888.          end if;
  1889.
  1890.          set_NIA_to((1, 4));
  1891.          decode_the_next_order;
  1892.          if INS.kind /= normal_jump_order then
  1893.             log_line("An expected jump, in E4L, has not been found!");
  1894.             return;
  1895.          else
  1896.             mark_the_words_reachable_from((1, 4));
  1897.             the_program_has_been_analysed := True;
  1898.          end if;
  1899.       end markup_a_Director;
  1900.
  1901.    begin -- mark_all_code_blocks_and_data_blocks
  1902.       if the_program_has_been_analysed then
  1903.          return;
  1904.       end if;
  1905.
  1906.       clear_all_analysis_flags;
  1907.
  1908.       if the_execution_mode = boot_mode  then
  1909.          markup_a_Director;
  1910.       else
  1911.          markup_a_problem_program;
  1912.       end if;
  1913.
  1914.       if nominated_address < invalid_address then
  1915.          mark_the_words_reachable_from((nominated_address, 0));
  1916.       end if;
  1917.
  1918.    end mark_all_code_blocks_and_data_blocks;
  1919.
  1920.    procedure show_core_as_Usercode (first, last  : in KDF9.syllable_address;
  1921.                                     octal_option : in Boolean) is
  1922.
  1923.       six_DUMMIES : constant KDF9.word := 8#0360741703607417#;
  1924.       saved_CIA   : constant KDF9.syllable_address := CIA;
  1925.       last_word   : KDF9.word := 8#0706050403020100#; -- invalid opcodes
  1926.       comparator  : KDF9.word := last_word;
  1927.       this_word   : KDF9.word;
  1928.       address     : KDF9.syllable_address;
  1929.
  1930.       procedure show_a_block_of_orders is
  1931.
  1932.          function is_a_store_order (decoded : KDF9.decoded_order)
  1933.          return Boolean
  1934.          is (
  1935.              if decoded.kind = one_syllable_order then
  1936.                 False
  1937.              elsif decoded.kind = two_syllable_order then
  1938.                 (
  1939.                  case decoded.compressed_opcode is
  1940.                    when TO_MkMq   | TO_MkMqQ
  1941.                       | TO_MkMqH  | TO_MkMqQH
  1942.                       | TO_MkMqN  | TO_MkMqQN
  1943.                       | TO_MkMqHN | TO_MkMqQHN => True,
  1944.                    when others                 => False
  1945.                 )
  1946.              elsif decoded.kind = data_access_order then
  1947.                 (
  1948.                  case decoded.compressed_opcode is
  1949.                     when TO_EaMq | TO_EaMqQ => True,
  1950.                     when others             => False
  1951.                 )
  1952.              else
  1953.                 False
  1954.             );
  1955.
  1956.          procedure set_line_at_minimum (tab : in Natural) is
  1957.          begin
  1958.             if panel_logger.column < tab then
  1959.                tab_log_to(tab);
  1960.             end if;
  1961.          end set_line_at_minimum;
  1962.
  1963.          procedure set_line_at (tab : in Natural) is
  1964.          begin
  1965.             if panel_logger.column > tab then
  1966.                log_new_line;
  1967.             end if;
  1968.             if panel_logger.column < tab then
  1969.                tab_log_to(tab);
  1970.             end if;
  1971.          end set_line_at;
  1972.
  1973.          procedure set_at_new_line is
  1974.          begin
  1975.             if panel_logger.column > 1 then
  1976.                log_new_line;
  1977.             end if;
  1978.          end set_at_new_line;
  1979.
  1980.       last_nz_location : KDF9.syllable_address;
  1981.
  1982.       begin -- show_a_block_of_orders
  1983.          this_word := fetch_word(KDF9.address(address.order_word_number));
  1984.
  1985.          if this_word+1 < 2 or this_word = six_DUMMIES then
  1986.             -- The word is not worth logging.
  1987.             address := (address.order_word_number+1, 0);
  1988.             return;
  1989.          end if;
  1990.
  1991.          -- Log useful information about data words.
  1992.          if address.order_word_number/is_a_data_word then
  1993.             set_at_new_line;
  1994.          end if;
  1995.          loop
  1996.             if address.order_word_number/is_a_data_word then
  1997.                last_nz_location := address;
  1998.                -- Display a line of data.
  1999.                log(oct_or_dec_of(address, octal_option) & ": ");
  2000.                set_line_at(jump_tab);
  2001.                show_in_various_formats(fetch_word(KDF9.address(address.order_word_number)),
  2002.                                        column => jump_tab);
  2003.                log_new_line;
  2004.                loop
  2005.                   if address.order_word_number = last.order_word_number then
  2006.                      return;
  2007.                   end if;
  2008.                   address := (address.order_word_number+1, 0);
  2009.                exit when fetch_word(KDF9.address(address.order_word_number)) /= 0;
  2010.                end loop;
  2011.                if address.order_word_number > last_nz_location.order_word_number+1 then
  2012.                   log("========  zeros  ========");
  2013.                   log_new_line;
  2014.                end if;
  2015.             else
  2016.                log_new_line;
  2017.                exit;
  2018.             end if;
  2019.          end loop;
  2020.
  2021.          loop
  2022.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  2023.          exit when address.order_word_number = 8191;
  2024.             this_word := fetch_word(KDF9.address(address.order_word_number));
  2025.             if this_word = comparator and this_word = last_word then
  2026.                -- The word is not worth logging.
  2027.                address := (address.order_word_number+1, 0);
  2028.                return;
  2029.             end if;
  2030.
  2031.             if this_word+1 < 2 or this_word = six_DUMMIES then
  2032.                comparator := this_word;
  2033.             end if;
  2034.
  2035.             set_NIA_to(address);
  2036.             decode_the_next_order;
  2037.             if is_an_invalid_order(INS) then
  2038.                -- The word is not worth logging.
  2039.                address := (address.order_word_number+1, 0);
  2040.                return;
  2041.             end if;
  2042.
  2043.             if is_a_jump_target(address) then
  2044.                -- Start a code paragraph, with its address for easy reference.
  2045.                set_at_new_line;
  2046.                log(oct_or_dec_of(address, octal_option) & ": ");
  2047.                log_new_line;
  2048.             end if;
  2049.
  2050.             -- Set the tab position appropriately for the order type.
  2051.             case INS.kind is
  2052.                when one_syllable_order | data_access_order =>
  2053.                   set_line_at_minimum(first_tab);
  2054.                when two_syllable_order =>
  2055.                   case INS.compressed_opcode is
  2056.                      when JCqNZS =>
  2057.                         set_line_at(jump_tab);
  2058.                      when  CT_PMB_PMC_BUSY_Qq
  2059.                         |  PAR_Qq
  2060.                         |  PMF_PMG_Qq
  2061.                         |  PIA_PIC_CLO_TLO_Qq
  2062.                         |  PIB_PID_Qq
  2063.                         |  PIE_PIG_Qq
  2064.                         |  PIF_PIH_Qq
  2065.                         |  POA_POC_POE_POF_PMH_Qq
  2066.                         |  POB_POD_Qq
  2067.                         |  POG_POL_Qq
  2068.                         |  POH_POK_Qq
  2069.                         |  PMA_PMK_INT_Qq
  2070.                         |  PMA_PMK_INT_Qq+1
  2071.                         |  PMD_PME_PML_Qq
  2072.                         |  PMD_PME_PML_Qq+1 =>
  2073.                         set_line_at(first_tab);
  2074.                      when others =>
  2075.                         if panel_logger.column < first_tab then
  2076.                            set_line_at_minimum(first_tab);
  2077.                         end if;
  2078.                   end case;
  2079.                when normal_jump_order =>
  2080.                   set_line_at(jump_tab);
  2081.             end case;
  2082.
  2083.             -- Show the order in pseudo-Usercode format.
  2084.             log(the_full_name_of(INS, octal_option) &  "; ");
  2085.
  2086.             case INS.kind is
  2087.                when one_syllable_order =>
  2088.                   increment_by_1(address);
  2089.                when two_syllable_order =>
  2090.                   increment_by_2(address);
  2091.                when normal_jump_order | data_access_order =>
  2092.                   increment_by_3(address);
  2093.             end case;
  2094.
  2095.             if address.order_word_number = last.order_word_number then
  2096.                log_new_line;
  2097.                return;
  2098.             end if;
  2099.
  2100.             if (address.order_word_number+1)/is_a_data_word or
  2101.                   address.order_word_number > last.order_word_number then
  2102.                return;
  2103.             end if;
  2104.
  2105.             if is_a_store_order(INS)                   or else
  2106.                   INS.compressed_opcode = JCqNZS                or else
  2107.                      INS.kind = normal_jump_order      or else
  2108.                         panel_logger.column > last_column then
  2109.                log_new_line;
  2110.             elsif this_word = comparator and this_word /= last_word then
  2111.                log_new_line;
  2112.                log_line("==========  #"
  2113.                       & oct_of(KDF9.syllable(this_word and 255))
  2114.                       & "  ==========");
  2115.                address := (address.order_word_number+1, 0);
  2116.                if address.order_word_number > last.order_word_number or
  2117.                      address.order_word_number/is_a_data_word then
  2118.                   return;
  2119.                end if;
  2120.             end if;
  2121.
  2122.             last_word := this_word;
  2123.
  2124.          end loop;
  2125.
  2126.       end show_a_block_of_orders;
  2127.
  2128.    begin
  2129.       if the_program_has_been_analysed then
  2130.          log_line("Core store interpreted as instructions.");
  2131.          BA := 0; -- Ensure that physical store is examined when running in boot mode.
  2132.          address := first;
  2133.          loop
  2134.             show_a_block_of_orders;
  2135.             exit when address.order_word_number >= last.order_word_number;
  2136.          end loop;
  2137.          log_new_line;
  2138.          log_rule;
  2139.          CIA := saved_CIA;
  2140.          decode_the_next_order;
  2141.       else
  2142.          log_line(" ... Core store cannot be interpreted as instructions!");
  2143.          log_new_line;
  2144.       end if;
  2145.    end show_core_as_Usercode;
  2146.
  2147.    procedure show_core_as_syllables (first, last  : KDF9.syllable_address) is
  2148.
  2149.       address     :   KDF9.syllable_address;
  2150.
  2151.       procedure show_a_block is
  2152.
  2153.          procedure set_line_at (tab : Natural) is
  2154.          begin  -- set_line_at
  2155.             if panel_logger.column > tab then
  2156.                log_new_line;
  2157.             end if;
  2158.             if panel_logger.column < tab then
  2159.                tab_log_to(tab);
  2160.             end if;
  2161.          end set_line_at;
  2162.
  2163.       begin  -- show_a_block
  2164.          loop
  2165.             if address.syllable_index = 0 then
  2166.                log_new_line;
  2167.                log(oct_of(address) & ": ");
  2168.                set_line_at(jump_tab);
  2169.             end if;
  2170.             log(oct_of(fetch_syllable(address)) &  "; ");
  2171.             increment_by_1(address);
  2172.          exit when address.order_word_number > last.order_word_number;
  2173.          end loop;
  2174.          log_new_line;
  2175.       end show_a_block;
  2176.
  2177.     begin  -- show_core_as_syllables
  2178.        BA := 0; -- Ensure that physical store is examined when running in boot mode.
  2179.       log_line("Core store interpreted as order syllables.");
  2180.       address := first;
  2181.       loop
  2182.          show_a_block;
  2183.          exit when address.order_word_number > last.order_word_number;
  2184.       end loop;
  2185.       log_new_line;
  2186.       log_rule;
  2187.    end show_core_as_syllables;
  2188.
  2189.    procedure poke (address    : in KDF9.address;
  2190.                    sub_word   : in Character;
  2191.                    position   : in KDF9.address;
  2192.                    value      : in KDF9.word) is
  2193.    begin
  2194.       case sub_word is
  2195.          when 'W' | 'w' =>
  2196.             store_word(value, address);
  2197.          when 'U' | 'u' =>
  2198.             store_halfword(value*2**24, address, 0);
  2199.          when 'L' | 'l' =>
  2200.             store_halfword(value*2**24, address, 1);
  2201.          when 'S' | 's' =>
  2202.             store_syllable(KDF9.syllable(value), address, KDF9.syllable_index(position));
  2203.          when 'C' | 'c' =>
  2204.             store_symbol(KDF9_char_sets.symbol(value), address, KDF9_char_sets.symbol_index(position));
  2205.          when others =>
  2206.             raise emulation_failure with "invalid poke position " & sub_word & ".";
  2207.       end case;
  2208.    exception
  2209.       when error : others =>
  2210.          raise emulation_failure
  2211.             with "invalid poke operation: " & Ada.Exceptions.Exception_Information(error);
  2212.    end poke;
  2213.
  2214. end state_display;

Compiling: ../Source/state_display.ads
Source file time stamp: 2021-01-16 00:43:24
Compiled at: 2021-02-08 17:20:58

     1. -- Provide the comprehensive machine-state display panel KDF9 never had.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18.
    19. use  KDF9;
    20.
    21. package state_display is
    22.
    23.    procedure show_all_prerun_dump_areas;
    24.
    25.    procedure show_CIA_and_NIA;
    26.
    27.    procedure show_V_and_T;
    28.
    29.    procedure show_nest (when_empty : Boolean := True);
    30.
    31.    procedure show_sjns (when_empty : Boolean := True);
    32.
    33.    procedure show_IO_register (the_Q_register : in KDF9.Q_register;
    34.                                width          : in Positive := 8;
    35.                                for_DR,
    36.                                for_FD,
    37.                                for_FH,
    38.                                for_seek,
    39.                                for_OUT         : in Boolean  := False);
    40.
    41.    procedure show_Q_register (the_Q_register : in KDF9.Q_register;
    42.                               width          : in Positive := 8);
    43.
    44.    procedure show_Q_store;
    45.
    46.    procedure show_registers;
    47.
    48.    procedure show_execution_context;
    49.
    50.    procedure long_witness;
    51.
    52.    procedure short_witness;
    53.
    54.    procedure log_an_external_trace_header (caption : in String := "");
    55.
    56.    procedure log_to_external_trace;
    57.
    58.    procedure show_progress;
    59.
    60.    procedure show_Director_registers;
    61.
    62.    procedure show_retrospective_traces;
    63.
    64.    procedure show_current_state;
    65.
    66.    procedure show_final_state (because : String);
    67.
    68.    procedure mark_all_code_blocks_and_data_blocks;
    69.
    70.    the_program_has_been_analysed : Boolean := False;
    71.
    72.    procedure show_core_as_word_forms (first, last : in KDF9.address);
    73.
    74.    procedure show_core_as_syllables (first, last : in KDF9.syllable_address);
    75.
    76.    procedure show_core_as_Usercode (first, last  : in KDF9.syllable_address;
    77.                                     octal_option : in Boolean);
    78.
    79.    procedure show_core_in_print_code (first, last : in KDF9.address);
    80.
    81.    procedure show_core_in_card_code (first, last : in KDF9.address);
    82.
    83.    procedure show_core_in_tape_code (first, last : in KDF9.address);
    84.
    85.    procedure show_core_in_case_normal (first, last : in KDF9.address);
    86.
    87.    procedure show_core_in_case_shift (first, last : in KDF9.address);
    88.
    89.    procedure show_core_in_Latin_1 (first, last : in KDF9.address);
    90.
    91.    -- poke is included here as it has the same relationship to dumping as show_core_*.
    92.    procedure poke (address    : in KDF9.address;
    93.                    sub_word   : in Character;
    94.                    position   : in KDF9.address;
    95.                    value      : in KDF9.word);
    96.
    97.    -- Take note that an OUT 2 or OUT 0 has been obeyed.
    98.    procedure notify_state_display_of_final_ICR;
    99.
   100. end state_display;

 2214 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/formatting.adb
Source file time stamp: 2021-01-10 23:52:35
Compiled at: 2021-02-08 17:20:58

     1. -- Provide basic data-formatting operations for KDF9 data types.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Handling;
    18. with Ada.Strings;
    19. with Ada.Strings.Fixed;
    20. --
    21. with KDF9_char_sets;
    22. with KDF9.CPU;
    23.
    24. use  Ada.Characters.Handling;
    25. use  Ada.Strings;
    26. use  Ada.Strings.Fixed;
    27. --
    28. use  KDF9_char_sets;
    29. use  KDF9.CPU;
    30.
    31. package body formatting is
    32.
    33.    digit_map : constant array (KDF9.halfword range 0 .. 15) of Character := "0123456789ABCDEF";
    34.
    35.    -- Return N as 3 octal digits.
    36.    function oct_of (N : KDF9.syllable)
    37.    return String
    38.    is (oct_of(KDF9.halfword(N))(6 .. 8));
    39.
    40.    -- Return N as 6 octal digits.
    41.    function oct_of (N : KDF9.field_of_16_bits)
    42.    return String is
    43.       value : KDF9.field_of_16_bits := N;
    44.       oct   : String(1 .. 6);
    45.    begin
    46.       for i in reverse oct'Range loop
    47.          oct(i) := digit_map(KDF9.halfword(value mod 8));
    48.          value := value / 8;
    49.       end loop;
    50.       return oct;
    51.    end oct_of;
    52.
    53.    -- Return N as 1 .. min_digits octal digits, with (partial) zero suppression.
    54.    function oct_of (N : KDF9.Q_part; min_digits : octal_width := 6)
    55.    return String is
    56.       oct : constant String(octal_width) := oct_of(KDF9.field_of_16_bits(N));
    57.    begin
    58.      if N = 0 then return (1..min_digits => '0'); end if;
    59.      for i in 1 .. 6-min_digits loop
    60.         if oct(i) /= '0' then
    61.            return oct(i .. 6);
    62.         end if;
    63.       end loop;
    64.       return oct(7-min_digits .. 6);
    65.    end oct_of;
    66.
    67.    -- Return N as 1 .. 5 decimal digits, with zero suppression and sign when neagtive.
    68.    function signed_dec_of (N : KDF9.Q_part)
    69.    return String is
    70.       dec : constant String := resign(N)'Image;
    71.    begin
    72.       return trimmed(dec);
    73.    end signed_dec_of;
    74.
    75.    -- Return N as decimal digits, with zero suppression.
    76.    function dec_of (N : KDF9.Q_part)
    77.    return String is
    78.       dec : constant String := N'Image;
    79.    begin
    80.       return trimmed(dec);
    81.    end dec_of;
    82.
    83.    -- Return N as up to 5 octal digits.
    84.    function oct_of (N : KDF9.order_word_number)
    85.    return String is
    86.       value : KDF9.order_word_number := N;
    87.       j     : Positive := 5;
    88.       oct   : String(1 .. 5);
    89.    begin
    90.       for i in reverse oct'Range loop
    91.          oct(i) := digit_map(KDF9.halfword(value mod 8));
    92.          value := value / 8;
    93.       end loop;
    94.       for i in oct'Range loop
    95.          if oct(i) /= '0' then j := i; exit; end if;
    96.       end loop;
    97.       return oct(j..5);
    98.    end oct_of;
    99.
   100.    -- Return N as decimal digits, with zero suppression.
   101.    function dec_of (N : KDF9.order_word_number)
   102.    return String
   103.    is (trimmed(N'Image));
   104.
   105.    -- Return N as 8 octal digits.
   106.    function oct_of (N : KDF9.halfword)
   107.    return String is
   108.       value : KDF9.halfword := N;
   109.       oct   : String(1 .. 8);
   110.    begin
   111.       for i in reverse oct'Range loop
   112.          oct(i) := digit_map(value mod 8);
   113.          value := value / 8;
   114.       end loop;
   115.       return oct;
   116.    end oct_of;
   117.
   118.    -- Return N as #wwwww/s, where w and s are octal digits.
   119.    function oct_of (N : KDF9.sjns_link)
   120.    return String
   121.    is (
   122.        "#"
   123.       &  oct_of(N.order_word_number)
   124.       & '/'
   125.       & digit_map(KDF9.halfword(N.syllable_index))
   126.       );
   127.
   128.    -- Return N as #wwwww/s, where w and s are octal digits.
   129.    function oct_of (N : KDF9.syllable_address)
   130.    return String
   131.    is (oct_of(KDF9.sjns_link(N)));
   132.
   133.    -- Return N as dddd/d, where d is a decimal digit.
   134.    function dec_of (N : KDF9.syllable_address)
   135.    return String
   136.    is (
   137.        trimmed(N.order_word_number'Image)
   138.             & '/'
   139.             & digit_map(KDF9.halfword(N.syllable_index))
   140.       );
   141.
   142.    -- Return N as #wwwww/s, where w and s are octal digits;
   143.    --    or as dddd/s, where d is a decimal digit, according to octal_option.
   144.    function oct_or_dec_of (N : KDF9.syllable_address; octal_option : Boolean)
   145.    return String
   146.    is (if octal_option then oct_of(N) else dec_of(N));
   147.
   148.    -- Return N as 16 octal digits
   149.    function oct_of (N : KDF9.word)
   150.    return String is
   151.       value : KDF9.word := N;
   152.       oct   : String(1 .. 16);
   153.    begin
   154.       for i in reverse oct'Range loop
   155.          oct(i) := digit_map(KDF9.halfword(value mod 8));
   156.          value := value / 8;
   157.       end loop;
   158.       return oct;
   159.    end oct_of;
   160.
   161.    -- Return "L', R'", or "L'" if R' is empty; "'" indicates removal of trailing blanks.
   162.    function "-" (L, R : String)
   163.    return String is
   164.       trim_R : constant String := trim(R, right);
   165.    begin
   166.       if trim_R /= "" then
   167.          return trim(L, right) & ", " & trim_R;
   168.       else
   169.          return trim(L, right);
   170.       end if;
   171.    end "-";
   172.
   173.    -- Return S with all leading an trailing blanks removed.
   174.    function trimmed (S : String)
   175.    return String
   176.    is (Trim(S, Ada.Strings.Both));
   177.
   178.    -- Return trimmed(S), right-just_right in a field of width at least W.
   179.    function just_right (S : String; W : Positive := 3)
   180.    return String is
   181.      image   : constant String   := Trim(S, Ada.Strings.Both);
   182.      columns : constant Positive := Positive'Max(W, image'Length);
   183.    begin
   184.      return Ada.Strings.Fixed.Tail(image, columns, ' ');
   185.    end just_right;
   186.
   187.    -- Return trimmed(S), left-justified in a field of width at least W.
   188.    function just_left (S : String; W : Positive := 3)
   189.    return String is
   190.      image   : constant String   := Trim(S, Ada.Strings.Both);
   191.      columns : constant Positive := Positive'Max(W, image'Length);
   192.    begin
   193.      return Ada.Strings.Fixed.Head(image, columns, ' ');
   194.    end just_left;
   195.
   196.    function plurality (count : KDF9.word; for_1 : String := ""; for_more : String := "s")
   197.    return String
   198.    is (if count /= 1 then for_more else for_1);
   199.
   200.    -- Return C converted to a 1-character string.
   201.    function "+" (C : Character)
   202.    return unit_string
   203.    is ((1 => C));
   204.
   205.    -- Return C with all Latin-1 lower-case letters converted to upper-case.
   206.    function to_upper (C : Character)
   207.    return Character
   208.    renames Ada.Characters.Handling.to_upper;
   209.
   210.    -- Return S with all Latin-1 lower-case letters converted to upper-case.
   211.    function to_upper (S : String)
   212.    return String
   213.    renames Ada.Characters.Handling.to_upper;
   214.
   215.    -- Return C with all Latin-1 upper-case letters converted to lower-case.
   216.    function to_lower (C : Character)
   217.    return Character
   218.    renames Ada.Characters.Handling.to_lower;
   219.
   220.    -- Return S with all Latin-1 upper-case letters converted to lower-case.
   221.    function to_lower (S : String)
   222.    return String
   223.    renames Ada.Characters.Handling.to_lower;
   224.
   225.    -- Return the 8-character Latin-1 string representing the 8 Case Normal characters in N.
   226.    function to_string (N : KDF9.word)
   227.    return word_as_byte_string is
   228.       word   : KDF9.word := N;
   229.       result : word_as_byte_string;
   230.    begin
   231.       for i in reverse 1 .. 8 loop
   232.          result(i) := KDF9_char_sets.TP_CN(KDF9_char_sets.symbol(word and 8#77#));
   233.          word := word / 64;
   234.       end loop;
   235.       return result;
   236.    end to_string;
   237.
   238.    -- Return the result of applying to_string to each word of a double-word.
   239.    function to_string (P : KDF9.pair)
   240.    return pair_as_byte_string is
   241.       result : pair_as_byte_string;
   242.    begin
   243.       result(1 ..  8) := to_string(P.msw);
   244.       result(9 .. 16) := to_string(P.lsw);
   245.       return result;
   246.    end to_string;
   247.
   248.    -- Take a string and ignore it.
   249.    procedure discard (S : String) is null;
   250.
   251. end formatting;

Compiling: ../Source/formatting.ads
Source file time stamp: 2021-01-10 23:52:35
Compiled at: 2021-02-08 17:20:58

     1. -- Provide basic data-formatting operations for KDF9 data types.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18.
    19. use  KDF9;
    20.
    21. package formatting is
    22.
    23.    subtype unit_string         is String(1 .. 1);
    24.    subtype word_as_byte_string is String(1 .. 8);
    25.    subtype pair_as_byte_string is String(1 .. 16);
    26.
    27.    -- Return N as 3 octal digits.
    28.    function oct_of (N : KDF9.syllable)
    29.    return String;
    30.
    31.    -- Return N as 6 octal digits.
    32.    function oct_of (N : KDF9.field_of_16_bits)
    33.    return String;
    34.
    35.    subtype octal_width is Positive range 1 .. 6;
    36.
    37.    -- Return N as octal digits, with (partial) zero suppression.
    38.    -- The first (6-min_digits) are elided if '0'; all remaining digits are returned.
    39.    -- Up to 6 digits can be returned if the result is longer than min_digits.
    40.    -- If N is 0, the String (1..min_digits => '0') is returned.
    41.    function oct_of (N : KDF9.Q_part; min_digits : octal_width := 6)
    42.    return String;
    43.
    44.    -- Return N as 1 .. 5 decimal digits, with zero suppression and sign when neagtive.
    45.    function signed_dec_of (N : KDF9.Q_part)
    46.    return String;
    47.
    48.    -- Return N as 1 .. 6 decimal digits, with zero suppression.
    49.    function dec_of (N : KDF9.Q_part)
    50.    return String;
    51.
    52.    -- Return N as up to 5 octal digits.
    53.    function oct_of (N : KDF9.order_word_number)
    54.    return String;
    55.
    56.    -- Return N as decimal digits, with zero suppression.
    57.    function dec_of (N : KDF9.order_word_number)
    58.    return String ;
    59.
    60.    -- Return N as 8 octal digits.
    61.    function oct_of (N : KDF9.halfword)
    62.    return String;
    63.
    64.    -- Return N as #wwwww/s, where w and s are octal digits.
    65.    function oct_of (N : KDF9.sjns_link)
    66.    return String;
    67.
    68.    -- Return N as #wwwww/s, where w and s are octal digits.
    69.    function oct_of (N : KDF9.syllable_address)
    70.    return String;
    71.
    72.    -- Return N as dddd/d, where d is a decimal digit.
    73.    function dec_of (N : KDF9.syllable_address)
    74.    return String;
    75.
    76.    -- Return N as #wwwww/s, where w and s are octal digits;
    77.    --    or as dddd/s, where d is a decimal digit, according to octal_option.
    78.    function oct_or_dec_of (N : KDF9.syllable_address; octal_option : Boolean)
    79.    return String;
    80.
    81.    -- Return N as 16 octal digits.
    82.    function oct_of (N : KDF9.word)
    83.    return String;
    84.
    85.    -- Return "L', R'", or "L'" if R' is empty: "'" indicates removal of trailing blanks.
    86.    function "-" (L, R : String)
    87.    return String;
    88.
    89.    -- Return S with all leading and trailing blanks removed.
    90.    function trimmed (S : String)
    91.    return String;
    92.
    93.    -- Return trimmed(S), right-justified in a field of width at least W.
    94.    function just_right (S : String; W : Positive := 3)
    95.    return String;
    96.
    97.    -- Return trimmed(S), left-justified in a field of width at least W.
    98.    function just_left (S : String; W : Positive := 3)
    99.    return String;
   100.
   101.    -- Return the (pluralizing) suffix if count /= 1.
   102.    function plurality (count : KDF9.word; for_1 : String := ""; for_more : String := "s")
   103.    return String;
   104.
   105.    -- Return C converted to a 1-character string.
   106.    function "+" (C : Character)
   107.    return unit_string;
   108.
   109.    -- Return C with all Latin-1 lower-case letters converted to upper-case.
   110.    function to_upper (C : Character)
   111.    return Character;
   112.
   113.    -- Return S with all Latin-1 lower-case letters converted to upper-case.
   114.    function to_upper (S : String)
   115.    return String;
   116.
   117.    -- Return C with all Latin-1 upper-case letters converted to lower-case.
   118.    function to_lower (C : Character)
   119.    return Character;
   120.
   121.    -- Return S with all Latin-1 upper-case letters converted to lower-case.
   122.    function to_lower (S : String)
   123.    return String;
   124.
   125.    -- Return the 8-character Latin-1 string representing the 8 Case Normal characters in N.
   126.    function to_string (N : KDF9.word)
   127.    return word_as_byte_string;
   128.
   129.    -- Return the result of applying to_string to each word of a double-word.
   130.    function to_string (P : KDF9.pair)
   131.    return pair_as_byte_string;
   132.
   133.    -- Take a string and ignore it.
   134.    procedure discard (S : String);
   135.
   136. end formatting;

 251 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/generic_logger.adb
Source file time stamp: 2021-01-11 02:47:59
Compiled at: 2021-02-08 17:20:58

     1. -- Provide operations supporting replicated output to a list of logging interfaces.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. -- generic
    18. --    max_logger_list_size : in Positive;
    19. package body generic_logger is
    20.
    21.    not overriding
    22.    procedure set_logger_list (logger : in out replicator; list : in distribution_list) is
    23.    begin
    24.       logger.data := (list'Length, list);
    25.    end set_logger_list;
    26.
    27.    overriding
    28.    procedure tab_log (logger   : in out replicator;
    29.                       at_least : in Natural;
    30.                       spacing  : in Positive;
    31.                       iff      : in Boolean := True) is
    32.    begin
    33.       for l in logger.data.list'Range loop
    34.          logger.data.list(l).tab_log(at_least, spacing, iff);
    35.       end loop;
    36.    end tab_log;
    37.
    38.    overriding
    39.    procedure tab_log_to (logger : in out replicator;
    40.                          column : in Positive;
    41.                          iff    : in Boolean := True) is
    42.    begin
    43.       for l in logger.data.list'Range loop
    44.          logger.data.list(l).tab_log_to(column, iff);
    45.       end loop;
    46.    end tab_log_to;
    47.
    48.    overriding
    49.    procedure log (logger : in out replicator;
    50.                   char   : in Character;
    51.                   iff    : in Boolean := True) is
    52.    begin
    53.       for l in logger.data.list'Range loop
    54.          logger.data.list(l).log(char, iff);
    55.       end loop;
    56.    end log;
    57.
    58.    overriding
    59.    procedure log (logger : in out replicator;
    60.                   text   : in String;
    61.                   iff    : in Boolean := True) is
    62.    begin
    63.       for l in logger.data.list'Range loop
    64.          logger.data.list(l).log(text, iff);
    65.       end loop;
    66.    end log;
    67.
    68.    overriding
    69.    procedure log_new_line (logger : in out replicator;
    70.                            iff    : in Boolean := True) is
    71.    begin
    72.       for l in logger.data.list'Range loop
    73.          logger.data.list(l).log_new_line(iff);
    74.       end loop;
    75.    end log_new_line;
    76.
    77.    overriding
    78.    procedure open (logger : in out replicator; log_name : in String) is
    79.    begin
    80.       for l in logger.data.list'Range loop
    81.          logger.data.list(l).open(log_name);
    82.       end loop;
    83.    end open;
    84.
    85.    overriding
    86.    procedure close (logger : in out replicator; log_name : in String) is
    87.    begin
    88.       for l in logger.data.list'Range loop
    89.          logger.data.list(l).close(log_name);
    90.       end loop;
    91.    end close;
    92.
    93.    overriding
    94.    procedure flush (logger : in out replicator; iff : in Boolean := True) is
    95.    begin
    96.       for l in logger.data.list'Range loop
    97.          logger.data.list(l).flush(iff);
    98.       end loop;
    99.    end flush;
   100.
   101. end generic_logger;

Compiling: ../Source/generic_logger.ads
Source file time stamp: 2021-01-10 23:52:35
Compiled at: 2021-02-08 17:20:58

     1. -- Provide operations supporting replicated output to a list of logging interfaces.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with logging;
    18.
    19. generic
    20.    max_logger_list_size : in Positive;
    21. package generic_logger is
    22.
    23.    type distribution_list is array (Positive range <>) of access logging.output'Class;
    24.
    25.    type replicator is new logging.output with private;
    26.
    27.    not overriding
    28.    procedure set_logger_list (logger : in out replicator; list : in distribution_list);
    29.
    30.    overriding
    31.    procedure tab_log (logger   : in out replicator;
    32.                       at_least : in Natural;
    33.                       spacing  : in Positive;
    34.                       iff      : in Boolean := True);
    35.
    36.    overriding
    37.    procedure tab_log_to (logger : in out replicator;
    38.                          column : in Positive;
    39.                          iff    : in Boolean := True);
    40.
    41.    overriding
    42.    procedure log (logger : in out replicator;
    43.                   char   : in Character;
    44.                   iff    : in Boolean := True);
    45.
    46.    overriding
    47.    procedure log (logger : in out replicator;
    48.                   text   : in String;
    49.                   iff    : in Boolean := True);
    50.
    51.    overriding
    52.    procedure log_new_line (logger : in out replicator;
    53.                            iff    : in Boolean := True);
    54.
    55.    overriding
    56.    procedure open  (logger : in out replicator; log_name : in String);
    57.
    58.    overriding
    59.    procedure close (logger : in out replicator; log_name : in String);
    60.
    61.    overriding
    62.    procedure flush (logger : in out replicator; iff : in Boolean := True);
    63.
    64. private
    65.
    66.    subtype logger_list_size is Natural range 0 .. max_logger_list_size;
    67.
    68.    -- This type is needed because tagged types cannot have discriminants.
    69.    type replica_list (length : logger_list_size := 0) is
    70.       record
    71.          list : distribution_list(1 .. length);
    72.       end record;
    73.
    74.    type replicator is new logging.output with
    75.       record
    76.          data : replica_list;
    77.       end record;
    78.
    79. end generic_logger;

 101 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/logging.ads
Source file time stamp: 2021-01-10 23:52:39
Compiled at: 2021-02-08 17:20:58

     1. -- Define an abstract log output device.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package logging is
    18.
    19.    type output is interface;
    20.
    21.    procedure tab_log (logger   : in out logging.output;
    22.                       at_least : in Natural;
    23.                       spacing  : in Positive;
    24.                       iff      : in Boolean := True) is abstract;
    25.
    26.    procedure tab_log_to (logger : in out logging.output;
    27.                          column : in Positive;
    28.                          iff    : in Boolean := True) is abstract;
    29.
    30.    procedure log (logger : in out logging.output;
    31.                   char   : in Character;
    32.                   iff    : in Boolean := True) is abstract;
    33.
    34.    procedure log (logger : in out logging.output;
    35.                   text   : in String;
    36.                   iff    : in Boolean := True) is abstract;
    37.
    38.    procedure log_new_line (logger : in out logging.output;
    39.                            iff    : in Boolean := True) is abstract;
    40.
    41.    procedure open  (logger : in out logging.output; log_name : in String) is abstract;
    42.
    43.    procedure close (logger : in out logging.output; log_name : in String) is abstract;
    44.
    45.    procedure flush (logger : in out logging.output; iff : in Boolean := True) is abstract;
    46.
    47. end logging;

 47 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/logging-file.adb
Source file time stamp: 2021-01-10 23:52:39
Compiled at: 2021-02-08 17:20:58

     1. -- Provide logging output to a named text file.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18. with Ada.Unchecked_Deallocation;
    19. --
    20. with file_interfacing;
    21.
    22. use  Ada.Text_IO;
    23. --
    24. use  file_interfacing;
    25.
    26. package body logging.file is
    27.
    28.    overriding
    29.    procedure tab_log (logger   : in out file.output;
    30.                       at_least : in Natural;
    31.                       spacing  : in Positive;
    32.                       iff      : in Boolean := True) is
    33.       column_nr : constant Positive_Count := Col(logger.the_log.all) + Count(at_least);
    34.       excess    : constant Count          := column_nr mod Count(spacing);
    35.    begin
    36.       if not iff or logger.log_file_is_shut then return; end if;
    37.       Set_Col(logger.the_log.all, column_nr);
    38.       if excess /= 0 then
    39.          Set_Col(logger.the_log.all, column_nr + Count(spacing) - excess);
    40.       end if;
    41.    end tab_log;
    42.
    43.    overriding
    44.    procedure tab_log_to (logger : in out file.output;
    45.                          column : in Positive;
    46.                          iff    : in Boolean := True) is
    47.    begin
    48.       if not iff or logger.log_file_is_shut then return; end if;
    49.       Set_Col(logger.the_log.all, Positive_Count(column));
    50.    end tab_log_to;
    51.
    52.    overriding
    53.    procedure log_new_line (logger : in out file.output;
    54.                            iff    : in Boolean := True) is
    55.    begin
    56.       if not iff or logger.log_file_is_shut then return; end if;
    57.       New_Line(logger.the_log.all);
    58.    end log_new_line;
    59.
    60.    overriding
    61.    procedure log (logger : in out file.output;
    62.                   char   : in Character;
    63.                   iff    : in Boolean := True) is
    64.    begin
    65.       if not iff or logger.log_file_is_shut then return; end if;
    66.       Put(logger.the_log.all, char);
    67.    end log;
    68.
    69.    overriding
    70.    procedure log (logger : in out file.output;
    71.                   text   : in String;
    72.                   iff    : in Boolean := True) is
    73.    begin
    74.       if not iff or logger.log_file_is_shut then return; end if;
    75.       Put(logger.the_log.all, text);
    76.    end log;
    77.
    78.    overriding
    79.    procedure open (logger : in out file.output; logfile_name : in String) is
    80.    begin
    81.       if logger.log_file_is_shut then
    82.          logger.the_log := new Ada.Text_IO.File_Type;
    83.          file_interfacing.initialize(logger.the_log.all, out_file, logfile_name);
    84.          logger.log_file_is_shut := False;
    85.       end if;
    86.    end open;
    87.
    88.    overriding
    89.    procedure close (logger : in out file.output; logfile_name : in String) is
    90.
    91.       procedure free_log_file is
    92.          new Ada.Unchecked_Deallocation(Ada.Text_IO.File_Type, File_Type_access);
    93.
    94.    begin
    95.       if logger.log_file_is_shut then return; end if;
    96.       file_interfacing.finalize(logger.the_log.all, logfile_name);
    97.       free_log_file(logger.the_log);
    98.       logger.log_file_is_shut := True;
    99.    end close;
   100.
   101.    overriding
   102.    procedure flush (logger : in out file.output; iff : in Boolean := True) is
   103.    begin
   104.       if not iff or logger.log_file_is_shut then return; end if;
   105.       Flush(logger.the_log.all);
   106.    end flush;
   107.
   108. end logging.file;

Compiling: ../Source/logging-file.ads
Source file time stamp: 2021-01-10 23:52:39
Compiled at: 2021-02-08 17:20:58

     1. -- Provide logging output to a named text file.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. private with Ada.Text_IO;
    18.
    19. package logging.file is
    20.
    21.    type output is new logging.output with private;
    22.
    23.    overriding
    24.    procedure tab_log (logger   : in out file.output;
    25.                       at_least : in Natural;
    26.                       spacing  : in Positive;
    27.                       iff      : in Boolean := True);
    28.
    29.    overriding
    30.    procedure tab_log_to (logger : in out file.output;
    31.                          column : in Positive;
    32.                          iff    : in Boolean := True);
    33.
    34.    overriding
    35.    procedure log (logger : in out file.output;
    36.                   char   : in Character;
    37.                   iff    : in Boolean := True);
    38.
    39.    overriding
    40.    procedure log (logger : in out file.output;
    41.                   text   : in String;
    42.                   iff    : in Boolean := True);
    43.
    44.    overriding
    45.    procedure log_new_line (logger : in out file.output;
    46.                            iff    : in Boolean := True);
    47.
    48.    overriding
    49.    procedure open  (logger : in out file.output; logfile_name : in String);
    50.
    51.    overriding
    52.    procedure close (logger : in out file.output; logfile_name : in String);
    53.
    54.    overriding
    55.    procedure flush (logger : in out file.output; iff    : in Boolean := True);
    56.
    57. private
    58.
    59.    type File_Type_access is access Ada.Text_IO.File_Type;
    60.
    61.    type output is new logging.output with
    62.       record
    63.          log_file_is_shut : Boolean := True;
    64.          the_log          : file.File_Type_access;
    65.       end record;
    66.
    67. end logging.file;

 108 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/logging-panel.adb
Source file time stamp: 2021-01-10 23:52:39
Compiled at: 2021-02-08 17:20:58

     1. -- Provide logging output to an interactive terminal/control panel.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with POSIX;
    18. with settings;
    19.
    20. use  POSIX;
    21. use  settings;
    22.
    23. package body logging.panel is
    24.
    25.    not overriding
    26.    function column (logger : panel.display)
    27.    return Positive
    28.    is (logger.column_number);
    29.
    30.    overriding
    31.    procedure tab_log (logger   : in out panel.display;
    32.                       at_least : in Natural;
    33.                       spacing  : in Positive;
    34.                       iff      : in Boolean := True) is
    35.       new_col : constant Natural := logger.column_number + at_least;
    36.       deficit : constant Natural := (spacing - new_col mod spacing) mod spacing;
    37.    begin
    38.       if not iff then return; end if;
    39.       for i in logger.column_number .. (new_col + deficit) loop
    40.          POSIX.output(' ');
    41.       end loop;
    42.       logger.column_number := new_col + deficit;
    43.    end tab_log;
    44.
    45.    overriding
    46.    procedure tab_log_to (logger : in out panel.display;
    47.                          column : in Positive;
    48.                          iff    : in Boolean := True) is
    49.    begin
    50.       if not iff then return; end if;
    51.       if column < logger.column_number then
    52.          logger.log_new_line;
    53.       end if;
    54.       for i in logger.column_number .. column-1 loop
    55.          POSIX.output(' ');
    56.       end loop;
    57.       logger.column_number := column;
    58.    end tab_log_to;
    59.
    60.    overriding
    61.    procedure log (logger : in out panel.display;
    62.                   char   : in Character;
    63.                   iff    : in Boolean := True) is
    64.    begin
    65.       if not iff then return; end if;
    66.       POSIX.output(char);
    67.       logger.column_number := logger.column_number + 1;
    68.    end log;
    69.
    70.    overriding
    71.    procedure log (logger : in out panel.display;
    72.                   text   : in String;
    73.                   iff    : in Boolean := True) is
    74.    begin
    75.       if not iff then return; end if;
    76.       if text /= "" then
    77.          POSIX.output(text);
    78.       end if;
    79.       logger.column_number := logger.column_number + text'Length;
    80.    end log;
    81.
    82.    overriding
    83.    procedure log_new_line (logger : in out panel.display;
    84.                            iff    : in Boolean := True) is
    85.    begin
    86.       if not iff then return; end if;
    87.       POSIX.output_line;
    88.       logger.column_number := 1;
    89.    end log_new_line;
    90.
    91.    not overriding
    92.    procedure show (logger : in out panel.display; message : in String := "") is
    93.    begin
    94.       if message /= "" then
    95.          logger.log(message);
    96.       end if;
    97.    end show;
    98.
    99.    not overriding
   100.    procedure show_line (logger : in out panel.display; message : in String := "") is
   101.    begin
   102.       if message /= "" then
   103.          logger.log(message);
   104.       end if;
   105.       logger.log_new_line;
   106.    end show_line;
   107.
   108.    not overriding
   109.    procedure interact (logger : in out panel.display; reason : in String := "Mode") is
   110.       old_mode : constant settings.diagnostic_mode := the_diagnostic_mode;
   111.       response : response_kind;
   112.       choice   : Character;
   113.    begin
   114.    interaction_loop:
   115.       loop
   116.          logger.column_number := 1;
   117.          POSIX.debug_prompt(noninteractive_usage_is_enabled, reason, response, choice);
   118.          if response = name_response then
   119.             case choice is
   120.                when 'q' | 'Q' =>
   121.                   quit_was_requested := True;
   122.                   exit interaction_loop;
   123.                when 'd' | 'D' =>
   124.                   debugging_is_enabled := not debugging_is_enabled;
   125.                   exit interaction_loop;
   126.                when 'f' | 'F' =>
   127.                   set_diagnostic_mode(fast_mode);
   128.                   exit interaction_loop;
   129.                when 'p' | 'P' =>
   130.                   set_diagnostic_mode(pause_mode);
   131.                   exit interaction_loop;
   132.                when 't' | 'T' =>
   133.                   set_diagnostic_mode(trace_mode);
   134.                   exit interaction_loop;
   135.                when others =>
   136.                   null; -- An invalid choice, try again.
   137.             end case;
   138.          elsif response = EOF_response then
   139.             exit;
   140.          end if;
   141.       end loop interaction_loop;
   142.       the_diagnostic_mode_changed := (the_diagnostic_mode /= old_mode) or quit_was_requested;
   143.    end interact;
   144.
   145. end logging.panel;

Compiling: ../Source/logging-panel.ads
Source file time stamp: 2021-01-10 23:52:39
Compiled at: 2021-02-08 17:20:58

     1. -- Provide logging output to an interactive terminal/control panel.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package logging.panel is
    18.
    19.    type display is new logging.output with private;
    20.
    21.    not overriding
    22.    function column (logger : panel.display)
    23.    return Positive;
    24.
    25.    overriding
    26.    procedure tab_log (logger   : in out panel.display;
    27.                       at_least : in Natural;
    28.                       spacing  : in Positive;
    29.                       iff      : in Boolean := True);
    30.
    31.    overriding
    32.    procedure tab_log_to (logger : in out panel.display;
    33.                          column : in Positive;
    34.                          iff    : in Boolean := True);
    35.
    36.    overriding
    37.    procedure log (logger : in out panel.display;
    38.                   char   : in Character;
    39.                   iff    : in Boolean := True);
    40.
    41.    overriding
    42.    procedure log (logger : in out panel.display;
    43.                   text   : in String;
    44.                   iff    : in Boolean := True);
    45.
    46.    overriding
    47.    procedure log_new_line (logger : in out panel.display;
    48.                            iff    : in Boolean := True);
    49.
    50.    not overriding
    51.    procedure show (logger : in out panel.display; message : in String := "");
    52.
    53.    not overriding
    54.    procedure show_line (logger : in out panel.display; message : in String := "");
    55.
    56.    not overriding
    57.    procedure interact (logger : in out panel.display; reason : in String := "Mode");
    58.
    59.    overriding
    60.    procedure open (logger : in out panel.display; logfile_name : in String) is null;
    61.
    62.    overriding
    63.    procedure close (logger : in out panel.display; logfile_name : in String) is null;
    64.
    65.    overriding
    66.    procedure flush (logger : in out panel.display; iff : in Boolean := True) is null;
    67.
    68. private
    69.
    70.    type display is new logging.output with
    71.       record
    72.          column_number : Positive := 1;
    73.       end record;
    74.
    75. end logging.panel;

 145 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-the_locker_of.adb
Source file time stamp: 2021-01-22 02:24:43
Compiled at: 2021-02-08 17:20:59

     1. -- Identify the buffer that caused a store lockout.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. function IOC.the_locker_of (address : KDF9.Q_part)
    18. return KDF9.Q_part is
    19.    candidate_time   : KDF9.us     := KDF9.us'Last;
    20.    candidate_number : KDF9.Q_part := 16;
    21. begin
    22.    -- Select the buffer actively doing DMA in the_group;
    23.    --    if there is more than one, choose the buffer with the earliest completion time.
    24.    -- The latter case should not arise in practice, but is allowed by the hardware.
    25.    for b in buffer'Range loop
    26.       if buffer(b) /= null                                               and then
    27.             buffer(b).is_busy                                            and then
    28.                buffer(b).operation in input_operation | output_operation and then
    29.                   buffer(b).completion_time < candidate_time             and then
    30.                      group(address) in group(buffer(b).control_word.I)
    31.                                     .. group(buffer(b).control_word.M)       then
    32.          candidate_number := b;
    33.          candidate_time   := buffer(b).completion_time;
    34.       end if;
    35.    end loop;
    36.    return candidate_number;
    37. end IOC.the_locker_of;

 37 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-cpu.adb
Source file time stamp: 2021-01-10 23:52:38
Compiled at: 2021-02-08 17:20:59

     1. -- Support for KDF9 CPU/ALU operations that are not automatically inherited from
     2. --   Ada types; and for types used in the internal functioning of the microcode.
     3. --
     4. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17. --
    18.
    19. with exceptions;
    20.
    21. use  exceptions;
    22.
    23. package body KDF9.CPU is
    24.
    25. --
    26. --
    27.    --
    28.    -- KDF9 Arithmetic Control (AC) primitives representing Shift Control and associated units.
    29.    -- These units implement shifting, multiplication, division, and floating-point arithmetic.
    30.    --
    31. --
    32. --
    33.
    34.    -- Count the leading zeros of the absolute value of y, omitting the sign bit.
    35.    -- If y is 0, return 47.
    36.    function nr_leading_zeros (y : KDF9.word)
    37.    return Natural is
    38.       x : CPU.u_64;
    39.       r : Natural;
    40.    begin
    41.       if y = 0 then return 47; end if;
    42.       if resign(y) < 0 then
    43.          x := CPU.u_64(16#FFFF_FFFF_FFFF# and not y);
    44.       else
    45.          x := CPU.u_64(y);
    46.       end if;
    47.       -- Only 48 bits of x need be tested.
    48.       if (x and 16#FFFF_0000_0000#) /= 0 then
    49.          r := 32; x := shift_right(x, 32);
    50.       elsif (x and 16#FFFF_0000#) /= 0 then
    51.          r := 16; x := shift_right(x, 16);
    52.       else
    53.          r := 0;
    54.       end if;
    55.       if (x and 16#FF00#) /= 0 then
    56.          r := r + 8; x := shift_right(x, 8);
    57.       end if;
    58.       if (x and 16#F0#) /= 0 then
    59.          r := r + 4; x := shift_right(x, 4);
    60.       end if;
    61.       if (x and 16#C#) /= 0 then
    62.          r := r + 2; x := shift_right(x, 2);
    63.       end if;
    64.       if (x and 16#2#) /= 0 then
    65.          r := r + 1;
    66.       end if;
    67.       r := 47 - r - 1;  -- -1 discounts the sign bit.
    68.       return r;
    69.    end nr_leading_zeros;
    70.
    71.    function nr_one_bits (u : CPU.u_64)
    72.    return CPU.u_64 is
    73.       n : CPU.u_64 := shift_right(u, 1) and 16#77_77_77_77_77_77_77_77#;
    74.       x : CPU.u_64 := u - n;
    75.    begin
    76.       n := shift_right(n, 1) and 16#77_77_77_77_77_77_77_77#;
    77.       x := x - n;
    78.       n := shift_right(n, 1) and 16#77_77_77_77_77_77_77_77#;
    79.       x := x - n;
    80.       x := (x + shift_right(x, 4)) and 16#0F_0F_0F_0F_0F_0F_0F_0F#;
    81.       x := x * 16#01_01_01_01_01_01_01_01#;
    82.       return shift_right(x, CPU.u_64'Size-8);
    83.    end nr_one_bits;
    84.
    85.    KDF9_max_signed : constant CPU.s_64 := CPU.s_64(CPU.signed'Last);
    86.    KDF9_min_signed : constant CPU.s_64 := CPU.s_64(CPU.signed'First);
    87.
    88.    function as_word (u : CPU.u_64)
    89.    return KDF9.word
    90.    is (KDF9.word(u and KDF9.word_mask));
    91.
    92.    function as_word (s : CPU.s_64)
    93.    return KDF9.word is
    94.    begin
    95.       if s > KDF9_max_signed or s < KDF9_min_signed then
    96.          the_V_bit_is_set := True;
    97.       end if;
    98.       return as_word(unsign(s));
    99.    end as_word;
   100.
   101.    function contracted (msw, lsw : KDF9.word)
   102.    return KDF9.word is
   103.    begin
   104.       if resign(lsw) < 0 or (msw+1) > 1 then
   105.          the_V_bit_is_set := True;
   106.       end if;
   107.       return (lsw and not_sign_bit) or (msw and sign_bit);
   108.    end contracted;
   109.
   110.    function contracted (P : KDF9.pair)
   111.    return KDF9.word
   112.    is (contracted(msw => P.msw, lsw => P.lsw));
   113.
   114.    function shift_time (amount : Natural)
   115.    return KDF9.us
   116.    is (KDF9.us(amount/16 + amount/8 mod 2 + (if amount mod 8 > 0 then 1 else 0)));
   117.
   118.    function normalize_time (amount : Natural)
   119.    return KDF9.us
   120.    is (KDF9.us(amount/8 + (if amount mod 8 > 0 then 1 else 0)));
   121.
   122.    function shift_word_left (W : KDF9.word; amount : word_shift_length)
   123.    return KDF9.word
   124.    is (as_word(shift_left(CPU.u_64(W), amount)));
   125.
   126.    function shift_word_right (W : KDF9.word; amount : word_shift_length)
   127.    return KDF9.word
   128.    is (KDF9.word(shift_right(CPU.u_64(W), amount)));  -- This cannot be out of range.
   129.
   130.    function rotate_word_left (W : KDF9.word; amount : word_shift_length)
   131.    return KDF9.word
   132.    is (shift_word_left(W, amount) or shift_word_right(W, 48-amount));
   133.
   134.    function rotate_word_right (W : KDF9.word; amount : word_shift_length)
   135.    return KDF9.word
   136.    is (shift_word_right(W, amount) or shift_word_left(W, 48-amount));
   137.
   138.    function shift_circular (W : KDF9.word; L : CPU.signed_Q_part)
   139.    return KDF9.word
   140.       -- The logic here conforms to ¶1.1 of EE Report K/GD.y.80, entitled
   141.       --    "KDF 9: SHIFTING AND SHIFT CONTROL".
   142.       -- Circular shifts were implemented by duplicating the operand, doing a double-length
   143.       --    shift of the two words, and selecting the appropriate word from the result.
   144.    is (
   145.        if abs L > 95 then 0
   146.        elsif L < -48 then shift_word_right(W, Natural(-L-48))
   147.        elsif L > +48 then shift_word_left(W, Natural(+L-48))
   148.        elsif L < 0   then rotate_word_right(W, Natural(-L))
   149.        else               rotate_word_left(W, Natural(L))
   150.       );
   151.
   152.    function shift_logical (W : KDF9.word; L : CPU.signed_Q_part)
   153.    return KDF9.word
   154.    is
   155.       (
   156.        if abs L > 47 then 0
   157.        elsif  L < 0  then shift_word_right(W, Natural(-L))
   158.        else               shift_word_left(W, Natural(L))
   159.       );
   160.
   161.    function shift_pair_left (P : KDF9.pair; L : Natural)
   162.    return KDF9.pair
   163.       with Inline;
   164.
   165.    function shift_pair_left (P : KDF9.pair; L : Natural)
   166.    return KDF9.pair is
   167.       result    : KDF9.pair;
   168.       crossover : KDF9.word;
   169.    begin
   170.       -- The logic here conforms to ¶3.2 of EE Report K/GD.y.80.
   171.       if L < 48 then
   172.          result.lsw := shift_word_left(P.lsw, L);
   173.          crossover  := shift_word_right(P.lsw, 48-L);
   174.          result.msw := shift_word_left(P.msw, L) or crossover;
   175.       else
   176.          result.lsw := 0;
   177.          result.msw := shift_word_left(P.lsw, L-48);
   178.       end if;
   179.       return result;
   180.    end shift_pair_left;
   181.
   182.    function shift_pair_right (P : KDF9.pair; L : Natural)
   183.    return KDF9.pair
   184.       with Inline;
   185.
   186.    function shift_pair_right (P : KDF9.pair; L : Natural)
   187.    return KDF9.pair is
   188.       result    : KDF9.pair;
   189.       crossover : KDF9.word;
   190.    begin
   191.       -- The logic here conforms to ¶3.2 of EE Report K/GD.y.80.
   192.       if L < 48 then
   193.          result.msw := shift_word_right(P.msw, L);
   194.          crossover  := shift_word_left(P.msw, 48-L);
   195.          result.lsw := shift_word_right(P.lsw, L) or crossover;
   196.       else
   197.          result.msw := 0;
   198.          result.lsw := shift_word_right(P.msw, L-48);
   199.       end if;
   200.       return result;
   201.    end shift_pair_right;
   202.
   203.    function shift_logical (P : KDF9.pair; L : CPU.signed_Q_part)
   204.    return KDF9.pair
   205.    is (
   206.        if    L > 0 then shift_pair_left(P, Natural(L))
   207.        elsif L < 0 then shift_pair_right(P, Natural(-L))
   208.        else        P
   209.       );
   210.
   211.    function scale_down (W : KDF9.word; amount : Natural)
   212.    return KDF9.word is
   213.       unrounded, clearing : CPU.u_64;
   214.    begin
   215.       if amount = 0 then
   216.          return W;
   217.       elsif amount > 46 then
   218.          if resign(W) < 0 then
   219.             return KDF9.all_one_bits;
   220.          else
   221.             return 0;
   222.          end if;
   223.       else
   224.          -- It is undefined whether the intrinsic shift_right_arithmetic function,
   225.          --    operating on CPU.u_64, yields a rounded result.
   226.          -- So, any rounding it might do is completely suppressed.
   227.          unrounded := shift_right_arithmetic(shift_left(CPU.u_64(W),16), 16);
   228.          clearing  := - shift_left(1, amount);
   229.          return as_word(shift_right_arithmetic(unrounded and clearing, amount));
   230.       end if;
   231.    end scale_down;
   232.
   233.    function scale_down_and_round (W : KDF9.word; amount : Natural)
   234.    return KDF9.word is
   235.       unrounded, clearing, rounding : CPU.u_64;
   236.    begin
   237.       if amount = 0 then
   238.          return W;
   239.       elsif amount > 46 then
   240.          if resign(W) < 0 then
   241.             return KDF9.all_one_bits;
   242.          else
   243.             return 0;
   244.          end if;
   245.       else
   246.          -- It is undefined whether the intrinsic shift_right_arithmetic,
   247.          --    operating on CPU.u_64, yields a rounded result.
   248.          -- So, any rounding it might do is suppressed,
   249.          --    and correct rounding is explicitly computed.
   250.          unrounded := shift_right_arithmetic(shift_left(CPU.u_64(W),16), 16);
   251.          rounding  := shift_right(unrounded, amount-1) and 1;
   252.          clearing  := - shift_left(1, amount);
   253.          unrounded := unrounded and clearing;
   254.          return as_word(shift_right_arithmetic(unrounded, amount) + rounding);
   255.       end if;
   256.    end scale_down_and_round;
   257.
   258.    function scale_up (W : KDF9.word; amount : Natural)
   259.    return KDF9.word is
   260.       M : constant Natural := Natural'Min(amount, 47);
   261.    begin
   262.       if resign(W) < 0 then
   263.          if scale_down(W, 47-M) /= all_one_bits or
   264.                resign(shift_word_left(W, M)) >= 0 then
   265.             -- See EE Report K/GD.y.80., ¶ 1.1.
   266.             the_V_bit_is_set := True;
   267.          end if;
   268.          return shift_word_left(W, M);
   269.       else
   270.          if shift_word_right(W, 47-M) /= all_zero_bits or
   271.                resign(shift_word_left(W, M)) < 0 then
   272.             -- See EE Report K/GD.y.80., ¶ 1.1.
   273.             the_V_bit_is_set := True;
   274.          end if;
   275.          return shift_word_left(W, M);
   276.       end if;
   277.    end scale_up;
   278.
   279.    function shift_arithmetic (I : KDF9.word; L : CPU.signed_Q_part)
   280.    return KDF9.word
   281.    is (
   282.        if L < 0 then scale_down_and_round(I, Natural(-L))
   283.        else          scale_up(I, Natural(L))
   284.       );
   285.
   286.    function scale_up (P : KDF9.pair; L : Natural)
   287.    return KDF9.pair is
   288.       result    : KDF9.pair;
   289.       crossover : KDF9.word;
   290.    begin
   291.       -- The logic here conforms to ¶3.2 of EE Report K/GD.y.80.
   292.       if L < 48 then
   293.          result.lsw := shift_word_left(P.lsw, L) and KDF9.max_word;
   294.          crossover  := shift_word_right(P.lsw and KDF9.max_word, 47-L);
   295.          result.msw := scale_up(P.msw, L) or crossover;
   296.       else
   297.          result.lsw := 0;
   298.          result.msw := scale_up(P.msw, 47) or P.lsw;
   299.          result.msw := scale_up(result.msw, Natural'Min(L, 94)-47);
   300.      end if;
   301.       return result;
   302.    end scale_up;
   303.
   304.    function scale_down (P : KDF9.pair; L : Natural)
   305.    return KDF9.pair is
   306.       result    : KDF9.pair;
   307.       crossover : KDF9.word;
   308.    begin
   309.       -- The logic here conforms to ¶3.2 of EE Report K/GD.y.80.
   310.       -- SHAD-n does NOT round, according to the Manual.
   311.       if L < 48 then
   312.          result.msw := scale_down(P.msw, L);
   313.          crossover  := shift_word_left(P.msw, 47-L) and KDF9.max_word;
   314.          -- It is not clear whether D0 of the lsw should be cleared before or after shifting.
   315.          -- I now clear it before shifting for compatibility with D. Holdsworth's "kdf9".
   316.          result.lsw := shift_word_right(P.lsw and KDF9.max_word, L) or crossover;
   317.       else
   318.          result.msw := scale_down(P.msw, 47);
   319.          result.lsw := shift_word_right(P.msw, Natural'Min(L, +94)-47) and KDF9.max_word;
   320.       end if;
   321.       return result;
   322.    end scale_down;
   323.
   324.    function shift_arithmetic (P : KDF9.pair; L : CPU.signed_Q_part)
   325.    return KDF9.pair
   326.    is (
   327.        if    L < 0 then scale_down(P, Natural(-L))
   328.        elsif L > 0 then scale_up(P, Natural(L))
   329.        else             P -- See ¶1.1 of EE Report K/GD.y.80: this avoids clearing D0 of P.lsw.
   330.       );
   331.
   332.    procedure normalize (fraction, exponent : in out KDF9.word) is
   333.       sign_flag  : constant KDF9.word := shift_word_right(fraction and sign_bit, 1);
   334.       normalizer : Natural;
   335.    begin
   336.       if fraction = 0 then
   337.          exponent := 2#10_000_000#;  -- This yields 0 when biased positive.
   338.          return;
   339.       end if;
   340.
   341.       normalizer := nr_leading_zeros(fraction);
   342.       exponent := exponent - KDF9.word(normalizer);
   343.
   344.       -- shift_word_left is used, not _arithmetic, as D[1..normalizer] = D0
   345.       fraction := shift_word_left(fraction, normalizer);
   346.
   347.       the_CPU_delta := the_CPU_delta + normalize_time(normalizer);
   348.
   349.       -- scale_down_and_round may round up and overflow the fraction bits ...
   350.       fraction := scale_down_and_round(fraction, 8);
   351.       if (fraction and overflow_mask) /= shift_word_right(sign_flag, 7) then
   352.           -- ... so re-normalize; scale_down cannot round here.
   353.          fraction := scale_down(fraction, 1);
   354.          the_CPU_delta := the_CPU_delta + normalize_time(1);
   355.          exponent := exponent + 1;
   356.          the_CPU_delta := the_CPU_delta + 1;
   357.       end if;
   358.       fraction := fraction and mantissa_mask;
   359.
   360.       if resign(exponent) < -128 then
   361.          -- Deal with underflow.
   362.          fraction := 0;
   363.          exponent := 2#10_000_000#;  -- This yields 0 when biased positive.
   364.       elsif resign(exponent) > +127 then
   365.          -- Deal with overflow.
   366.          the_V_bit_is_set := True;
   367.          exponent := 2#01_111_111#;
   368.       end if;
   369.    end normalize;
   370.
   371.    function fraction_word (mantissa : CPU.f48)
   372.    return KDF9.word
   373.     -- shift_word_left must be used instead of scale_up to avoid a spurious overflow.
   374.    is (
   375.        (shift_word_left(as_word(mantissa), 8) and KDF9.max_word)
   376.           or
   377.        (as_word(mantissa) and sign_bit)
   378.       );
   379.
   380.    function masked_mantissa (F : CPU.f48)
   381.    return CPU.f48
   382.    is (as_f48(as_word(F) and mantissa_mask));
   383.
   384.    function scaler (F : CPU.f48)
   385.    return KDF9.word
   386.    is ((shift_word_right(as_word(F), 39) and 2#11_111_111#) - 128);
   387.
   388.    function normalized (full_fraction, scaler : KDF9.word)
   389.    return CPU.f48 is
   390.       E : KDF9.word := scaler;
   391.       F : KDF9.word := full_fraction;
   392.    begin
   393.       normalize(fraction => F, exponent => E);
   394.       return CPU.f48(shift_word_left((E + 128) and 2#11_111_111#, 39) or F);
   395.    end normalized;
   396.
   397.    function normalized  (R : CPU.f48)
   398.    return CPU.f48
   399.    is (normalized(full_fraction => fraction_word(R), scaler => scaler(R)));
   400.
   401.    function cardinality (W : KDF9.word)
   402.    return KDF9.word
   403.    is (KDF9.word(nr_one_bits(CPU.u_64(W))));
   404.
   405.    function "-" (I : CPU.signed)
   406.    return KDF9.word
   407.    is (as_word(-CPU.s_64(I)));
   408.
   409.    function "abs" (I : CPU.signed)
   410.    return KDF9.word
   411.    is (as_word(abs CPU.s_64(I)));
   412.
   413.    function "+" (L, R : CPU.signed)
   414.    return KDF9.word
   415.    is (as_word(CPU.s_64(L) + CPU.s_64(R)));
   416.
   417.    function "-" (L, R : CPU.signed)
   418.    return KDF9.word
   419.    is (as_word(CPU.s_64(L) - CPU.s_64(R)));
   420.
   421.    function "*" (L, R : CPU.signed)
   422.    return KDF9.word
   423.    is (contracted(KDF9.pair'(unsign(L) * unsign(R))));
   424.
   425.    procedure do_DIVI (L : in KDF9.word;
   426.                       R : in KDF9.word;
   427.                       Quotient, Remainder : out KDF9.word) is
   428.    begin
   429.       if R /= 0 then
   430.          Remainder := as_word(CPU.s_64(resign(L)) mod CPU.s_64(resign(R)));
   431.          Quotient  :=
   432.             as_word((CPU.s_64(resign(L)) - CPU.s_64(resign(Remainder))) / CPU.s_64(resign(R)));
   433.       else
   434.          the_V_bit_is_set := True;
   435.          Quotient  := L;  -- ??
   436.          Remainder := R;  -- ??
   437.       end if;
   438.    end do_DIVI;
   439.
   440.    function "*" (L, R : KDF9.word)
   441.    return CPU.fraction is
   442.    begin
   443.       if L = sign_bit and R = sign_bit then
   444.          the_V_bit_is_set := True;
   445.          return as_fraction(sign_bit);  -- The only case is L = R = -1.0 = L*R.
   446.       else
   447.          return as_fraction(L) * as_fraction(R);
   448.       end if;
   449.    end "*";
   450.
   451.    function "/" (L, R : KDF9.word)
   452.    return CPU.fraction is
   453.    begin
   454.       if R = 0 or L = sign_bit then
   455.          the_V_bit_is_set := True;
   456.          return as_fraction(L); -- ??
   457.       elsif R = sign_bit then
   458.          return -as_fraction(L);
   459.       elsif abs as_fraction(L) < abs as_fraction(R) then  -- abs is safe now.
   460.          return as_fraction(L) / as_fraction(R);
   461.       else
   462.          the_V_bit_is_set := True;
   463.          return as_fraction(L); -- ??
   464.       end if;
   465.    end "/";
   466.
   467.    function "+" (L, R : KDF9.pair)
   468.    return KDF9.pair is
   469.       carry, sum : CPU.s_64;
   470.       result     : KDF9.pair;
   471.    begin
   472.       sum := CPU.s_64(L.lsw) + CPU.s_64(R.lsw);
   473.       if unsign(sum) > KDF9.max_word then -- carry into msw
   474.          carry := 1;
   475.          result.lsw := KDF9.word(unsign(sum) and KDF9.max_word);
   476.       else
   477.          carry := 0;
   478.          result.lsw := KDF9.word(sum);
   479.       end if;
   480.       sum := CPU.s_64(resign(L.msw)) + CPU.s_64(resign(R.msw)) + carry;
   481.       result.msw := as_word(sum);
   482.       return result;
   483.    end "+";
   484.
   485.    function "-" (J : KDF9.pair)
   486.    return KDF9.pair is
   487.       borrow,
   488.       negative : CPU.s_64;
   489.       result   : KDF9.pair;
   490.    begin
   491.       negative := - CPU.s_64(J.lsw);
   492.       if unsign(negative) > KDF9.max_word then -- borrow from msw
   493.          borrow := 1;
   494.          result.lsw := KDF9.word(unsign(negative) and KDF9.max_word);
   495.       else
   496.          borrow := 0;
   497.          result.lsw := KDF9.word(negative);
   498.       end if;
   499.       negative := - CPU.s_64(resign(J.msw)) - borrow;
   500.       result.msw := as_word(negative);
   501.       return result;
   502.    end "-";
   503.
   504.    function "-" (L, R : KDF9.pair)
   505.    return KDF9.pair is
   506.       borrow,
   507.       difference : CPU.s_64;
   508.       result     : KDF9.pair;
   509.    begin
   510.       difference := CPU.s_64(L.lsw) - CPU.s_64(R.lsw);
   511.       if unsign(difference) > KDF9.max_word then -- borrow from msw
   512.          borrow := 1;
   513.          result.lsw := KDF9.word(unsign(difference) and KDF9.max_word);
   514.       else
   515.          borrow := 0;
   516.          result.lsw := KDF9.word(difference);
   517.       end if;
   518.       difference := CPU.s_64(resign(L.msw)) - CPU.s_64(resign(R.msw)) - borrow;
   519.       result.msw := as_word(difference);
   520.       return result;
   521.    end "-";
   522.
   523.    function "*" (L, R : KDF9.word)
   524.    return KDF9.pair is
   525.       S, T, U, V, W : KDF9.word;
   526.       H, M, B       : KDF9.pair;
   527.    begin
   528.       if L = sign_bit then
   529.          if R = L then
   530.             -- L*R = (+1.0), which is not a valid fraction, so deal with overflow.
   531.             the_V_bit_is_set := True;
   532.             return (L, 0);
   533.          else
   534.             -- L*R = -R.
   535.             return - (R, 0);
   536.          end if;
   537.       end if;
   538.       if R = sign_bit then
   539.          -- L*R = -L.
   540.          return - (L, 0);
   541.       end if;
   542.       -- Now it is safe to take absolute values, as they cannot overflow.
   543.       S := scale_down(abs resign(L), 24);
   544.       T := abs resign(L) and halfword_mask;
   545.       U := scale_down(abs resign(R), 24);
   546.       V := abs resign(R) and halfword_mask;
   547.       H := ((S*U)*2, 0);
   548.       M := scale_down((KDF9.word'(S*V), 0), 1) + scale_down((KDF9.word'(T*U), 0), 1);
   549.       M := scale_down(M, 22);
   550.       W := rotate_word_left(KDF9.word'(T*V), 1);
   551.       B := (W and 1, shift_word_right(W, 1));
   552.       if resign(L xor R) < 0 then
   553.          return - (H + M + B);
   554.       else
   555.          return    H + M + B;
   556.       end if;
   557.    end "*";
   558.
   559.    f_64_small : constant := 2.0**(-63);
   560.    type f_64 is delta f_64_small range -1.0 .. +1.0 - f_64_small with Size => 64;
   561.
   562.    function scale_down (f : CPU.f_64; N : Natural)
   563.    return f_64
   564.    is (if N > 62 then 0.0 else f / 2**N);
   565.
   566.    function to_f_64 (w : KDF9.word)
   567.    return CPU.f_64
   568.    is (CPU.f_64(as_fraction(w)));
   569.
   570.    function to_word (f : CPU.f_64)
   571.    return KDF9.word
   572.    is (as_word(CPU.fraction(f)));
   573.
   574.    procedure do_DIVD (L : in KDF9.pair;
   575.                       R : in KDF9.word;
   576.                       Q : out KDF9.word
   577.                      ) is
   578.       to_normalize_L : Natural;
   579.       to_normalize_R : Natural;
   580.       to_normalize_Q : Integer;
   581.       N              : KDF9.pair;
   582.       D              : KDF9.word;
   583.       Ls, Rs, Qs     : CPU.f_64;
   584.    begin
   585.       -- Deal very quickly with a zero result.
   586.       if (L.msw or L.lsw) = 0 then
   587.          Q := 0;
   588.          return;
   589.       end if;
   590.
   591.       -- Deal with division by 0.
   592.       if R = 0 then
   593.          the_V_bit_is_set := True;
   594.          Q := L.msw;  -- This is a guess at the result for division by zero ?? !!
   595.          return;
   596.       end if;
   597.
   598.       -- Check for an invalid numerator; D0 of L.lsw must be 0.
   599.       if resign(L.lsw) < 0 then -- L is not a valid double-length number.
   600.          the_V_bit_is_set := True;
   601.          Q := L.msw;  -- This is a guess at the result for an invalid numerator ?? !!
   602.          return;
   603.       end if;
   604.
   605.       to_normalize_L := nr_leading_zeros(L.msw);
   606.       if to_normalize_L > 46 then -- insignificant top half
   607.          N := scale_up(L, 47);
   608.          to_normalize_L := nr_leading_zeros(N.msw);
   609.          N := scale_up(N, to_normalize_L);
   610.          to_normalize_L := to_normalize_L + 47;
   611.       else
   612.          N := scale_up(L, to_normalize_L);
   613.       end if;
   614.
   615.       to_normalize_R := nr_leading_zeros(R);
   616.       D := scale_up(R, to_normalize_R);
   617.
   618.       -- Scale Ls and Rs so that the Ada fractional division cannot overflow.
   619.       Ls := scale_down(to_f_64(N.msw), 2);
   620.       Rs := scale_down(to_f_64(D), 1);
   621.
   622.       Qs := Ls / Rs;  -- "/" cannot overflow here.
   623.
   624.       to_normalize_Q := 1 + to_normalize_R - to_normalize_L;
   625.
   626.       if to_normalize_Q <= 0 then
   627.          -- Overflow is impossible.
   628.          Qs := scale_down(Qs, -to_normalize_Q);
   629.          Q := to_word(Qs);
   630.       else
   631.          -- If Qs >= 0.5, then L/R >= 1.0 is not a representable result fraction.
   632.          -- If Qs < -0.5, then L/R < -1.0 is not a representable result fraction.
   633.          if Qs >= 0.5 or Qs < -0.5 then
   634.             the_V_bit_is_set := True;
   635.             Q := L.msw / R;  -- This is a guess at the result when it overflows ?? !!
   636.             return;
   637.          end if;
   638.          Q := scale_up(to_word(Qs), to_normalize_Q);
   639.       end if;
   640.    end do_DIVD;
   641.
   642.    procedure do_DIVR (L : in KDF9.pair;
   643.                       R : in KDF9.word;
   644.                       Quotient, Remainder : out KDF9.word
   645.                      ) is
   646.       correction_count_limit : constant := 3;
   647.       correction_count       : Natural  := 0;
   648.       V  : constant Boolean := the_V_bit_is_set;
   649.       N  : KDF9.pair := L;
   650.       D  : KDF9.word := R;
   651.       S  : KDF9.word := +1;
   652.       P,
   653.       T  : KDF9.pair;
   654.    begin
   655.       if (N.msw or N.lsw) = 0 then
   656.          Quotient  := 0;
   657.          Remainder := 0;
   658.          return;
   659.       end if;
   660.
   661.       if D = 0 then
   662.          the_V_bit_is_set := True;
   663.          Quotient  := L.msw;  -- This is a guess at the result for division by zero ?? !!
   664.          Remainder := L.lsw;  -- This is a guess at the result for division by zero ?? !!
   665.          return;
   666.       end if;
   667.
   668.       -- Check for an invalid numerator; D0 of N1 must be 0.
   669.       if resign(L.lsw) < 0 then -- L is not a valid double-length number.
   670.          the_V_bit_is_set := True;
   671.          Quotient  := L.msw;  -- This is a guess at the result for invalid numerator ?? !!
   672.          Remainder := L.lsw;  -- This is a guess at the result for invalid numerator ?? !!
   673.          return;
   674.       end if;
   675.
   676.       -- Convert to an unsigned division problem, and note whether it needs to be be converted back.
   677.       if resign(N.msw) < 0 then -- L is negative.
   678.          N := - N;
   679.          S := - S;
   680.       end if;
   681.
   682.       if resign(D) < 0 then  -- R is negative.
   683.          D := - D;
   684.          S := - S;
   685.       end if;
   686.
   687.       -- Check for inevitable overflow, and deal with it separately.
   688.       if N.msw > D then
   689.          Quotient := N.msw / D * S;  -- This is a guess at the result when it overflows ?? !!
   690.          T := L - (msw => Quotient*R, lsw => 0);
   691.          Remainder := T.msw;         -- This is a guess at the result when it overflows ?? !!
   692.          the_V_bit_is_set := True;
   693.          return;
   694.       end if;
   695.
   696.       -- Overflow should not now be possible.
   697.       -- Ensure that an overflow in DIVD is trapped as a failure
   698.       the_V_bit_is_set := False;
   699.       do_DIVD(N, D, Quotient);
   700.       if the_V_bit_is_set then
   701.          raise emulation_failure with "DIVR overflows in DIVD";
   702.       end if;
   703.       -- Restore the input value of the overflow register.
   704.       the_V_bit_is_set := V;
   705.
   706.       -- Adjust Quotient until the difference between N and Quotient*D fits in one word.
   707.       correction_count := 0;
   708.       loop
   709.          P := Quotient * D;
   710.          T := N - P;
   711.       exit when T.msw = 0;
   712.          correction_count := correction_count + 1;
   713.          if correction_count > correction_count_limit then
   714.              raise emulation_failure with "DIVR exceeds correction_count_limit A";
   715.          end if;
   716.          Quotient := Quotient + 1;
   717.       end loop;
   718.
   719.       Remainder := T.lsw;
   720.
   721.       -- Adjust Quotient and Remainder until Remainder is less than the divisor in absolute value.
   722.       correction_count := 0;
   723.       while Remainder >= D loop
   724.          correction_count := correction_count + 1;
   725.          if resign(Remainder) > 0 then
   726.             Remainder := Remainder - D;
   727.             Quotient := Quotient + 1;
   728.          else
   729.             Remainder := Remainder + D;
   730.             Quotient := Quotient - 1;
   731.          end if;
   732.          if correction_count > correction_count_limit then
   733.              raise emulation_failure with "DIVR exceeds correction_count_limit B";
   734.          end if;
   735.       end loop;
   736.
   737.       Quotient  := Quotient * S;
   738.       Remainder := contracted(L - Quotient*R);
   739.    end do_DIVR;
   740.
   741.    function host_float (X : CPU.f48)
   742.    return Long_Float is
   743.       -- Warn if Long_Float does not have at least the range of a KDF9 floating point number.
   744.       pragma Compile_Time_Warning(Long_Float'Last < 2.0**127,
   745.                                   "Long_Float does not have enough range for KDF9 f.p.");
   746.       -- Warn if Long_Float does not have at least the precision of a KDF9 floating point number.
   747.       pragma Compile_Time_Warning(Long_Float'Small > 1.0/2.0**39,
   748.                                   "Long_Float does not have enough precision for KDF9 f.p.");
   749.       W : constant KDF9.word  := fraction_word(masked_mantissa(X));
   750.       S : constant Long_Float := 2.0**Integer(resign(scaler(X)));
   751.    begin
   752.       return Long_Float(as_fraction(W)) * S;  -- Cannot overflow if warnings are absent.
   753.    end host_float;
   754.
   755.    -- Round a 48-bit floating-point number to 24-bit format.
   756.    function narrowed (R : CPU.f48)
   757.    return CPU.f48
   758.    is (normalized(fraction_word(R) + 2**23, scaler(R)));
   759.
   760.    overriding
   761.    function "-" (R : CPU.f48)
   762.    return CPU.f48 is
   763.       -- F is made half of a true fraction to prevent overflow when negating:
   764.       --    the result exponent is offset by 1, accordingly.
   765.       E : constant KDF9.word := scaler(R) + 1;
   766.       F : KDF9.word := scale_down_and_round(fraction_word(R), 1);
   767.    begin
   768.       F := as_word(CPU.u_64(-F));  -- "-" cannot overflow here.
   769.       return normalized(full_fraction => F, scaler => E);
   770.    end "-";
   771.
   772.    overriding
   773.    function "abs" (R : CPU.f48)
   774.    return CPU.f48
   775.    is (if resign(KDF9.word(R)) < 0 then - R else + R);
   776.
   777.    overriding
   778.    function "+" (L, R : CPU.f48)
   779.    return CPU.f48 is
   780.       -- B and D are made half of a true fraction to prevent overflow when
   781.       --    adding; the result exponent is offset by 1, accordingly.
   782.       A : constant KDF9.word := scaler(R);
   783.       B : KDF9.word := scale_down(fraction_word(R), 1);
   784.       C : constant KDF9.word := scaler(L);
   785.       D : KDF9.word := scale_down(fraction_word(L), 1);
   786.       E : KDF9.word;
   787.       F : KDF9.word;
   788.       N : Natural;
   789.    begin
   790.       if resign(A) >= resign(C) then
   791.          N := Natural'Min(Natural(resign(A-C)), 48);
   792.          D := scale_down_and_round(D, N);
   793.          E := A + 1;
   794.       else
   795.          N := Natural'Min(Natural(resign(C-A)), 48);
   796.          B := scale_down_and_round(B, N);
   797.          E := C + 1;
   798.       end if;
   799.       the_CPU_delta := the_CPU_delta + shift_time(N);
   800.       F := as_word(CPU.u_64(D + B));  -- "+" cannot overflow here.
   801.       return normalized(full_fraction => F, scaler => E);
   802.    end "+";
   803.
   804.    overriding
   805.    function "-" (L, R : CPU.f48)
   806.    return CPU.f48 is
   807.       -- See "+".
   808.       A : constant KDF9.word := scaler(R);
   809.       B : KDF9.word := scale_down(fraction_word(R), 1);
   810.       C : constant KDF9.word := scaler(L);
   811.       D : KDF9.word := scale_down(fraction_word(L), 1);
   812.       E : KDF9.word;
   813.       F : KDF9.word;
   814.       N : Natural;
   815.    begin
   816.       if resign(A) >= resign(C) then
   817.          N := Natural'Min(Natural(resign(A-C)), 48);
   818.          D := scale_down_and_round(D, N);
   819.          E := A + 1;
   820.       else
   821.          N := Natural'Min(Natural(resign(C-A)), 48);
   822.          B := scale_down_and_round(B, N);
   823.          E := C + 1;
   824.       end if;
   825.       the_CPU_delta := the_CPU_delta + shift_time(N);
   826.       F := as_word(CPU.u_64(D - B));  -- "-" cannot overflow here.
   827.       return normalized(full_fraction => F, scaler => E);
   828.    end "-";
   829.
   830.    overriding
   831.    function "*" (L, R : CPU.f48)
   832.    return CPU.f48 is
   833.       B, D, E, F : KDF9.word;
   834.    begin
   835.       if (KDF9.word(L) or KDF9.word(R)) = 0 then
   836.          return 0;
   837.       end if;
   838.       B := fraction_word(R);
   839.       D := fraction_word(L);
   840.       E := scaler(L) + scaler(R);
   841.       if (B = sign_bit) and (B = D) then
   842.           -- D*B = (+1), which is not a valid fraction, so treat specially.
   843.           B := B / 2;
   844.           D := D / 2;
   845.           E := E + 2;
   846.        end if;
   847.       F := as_word(as_fraction(D) * as_fraction(B));  -- "*" cannot overflow here.
   848.       return normalized(full_fraction => F, scaler => E);
   849.    end "*";
   850.
   851.    overriding
   852.    function "/" (L, R : CPU.f48)
   853.    return CPU.f48 is
   854.       D, N   : CPU.fraction;
   855.       Ls, Rs : KDF9.word;
   856.       E, F   : KDF9.word;
   857.    begin
   858.       if R = 0 then
   859.          the_V_bit_is_set := True;
   860.          return L;  -- ?? This result is not well defined in the Manual.
   861.       end if;
   862.       -- If L>=R, L/R>= 1, which is not a valid fraction; so Ls and Rs are
   863.       --    scaled so that the division cannot overflow.
   864.       Ls := scale_down(fraction_word(L), 3);
   865.       Rs := scale_down(fraction_word(R), 1);
   866.       N := abs as_fraction(Ls);  -- Ls is scaled down by 1/8, so "abs" cannot overflow.
   867.       D := abs as_fraction(Rs);  -- Rs is scaled down by 1/2, so "abs" cannot overflow.
   868.       -- E is increased by 2 to compensate the quotient's scaling by 1/4.
   869.       E := scaler(L) - scaler(R) + 2;
   870.       F := as_word(N / D);  -- "/" cannot overflow here.
   871.       if resign(KDF9.word(L) xor KDF9.word(R)) < 0 then
   872.          -- The result is negative.
   873.          F := -F;
   874.       end if;
   875.       return normalized(full_fraction => F, scaler => E);
   876.    end "/";
   877.
   878.    overriding
   879.    function "<" (L, R : CPU.f48)
   880.    return Boolean is
   881.       s : constant KDF9.word := KDF9.word(L) xor KDF9.word(R);
   882.    begin
   883.       if resign(s) < 0 then
   884.          -- The signs differ: L<R iff L is negative.
   885.          return resign(KDF9.word(L)) < 0;
   886.       elsif resign(KDF9.word(L)) < 0 then
   887.          -- L and R are both negative, so invert lexicographical order.
   888.          return not (KDF9.word(L) < KDF9.word(R));
   889.       else
   890.          -- L and R are both non-negative: so use lexicographical order.
   891.          return KDF9.word(L) < KDF9.word(R);
   892.       end if;
   893.    end "<";
   894.
   895.    function fraction_pair (DF : CPU.f96)
   896.    return KDF9.pair
   897.    is (scale_up((msw => scale_down(fraction_word(DF.msw), 8), lsw => fraction_word(DF.lsw)), 8));
   898.
   899.    function scaler (DF : CPU.f96)
   900.    return KDF9.word
   901.    is (scaler(DF.msw));
   902.
   903.    function narrowed (DF : CPU.f96)
   904.    return CPU.f48 is
   905.       fraction : KDF9.pair := fraction_pair(DF) + (0, 2**46);
   906.    begin
   907.       reconstruct(fraction, scaler(DF));
   908.       return CPU.f48(fraction.msw);
   909.    end narrowed;
   910.
   911.    procedure reconstruct (frac   : in out KDF9.pair;
   912.                           scaler : in KDF9.word) is
   913.       KDF9_exponent :  KDF9.word := scaler + 128;
   914.       normalizer    : Natural;
   915.    begin
   916.       if (frac.msw or frac.lsw) = 0 then
   917.          return; -- frac is already normalized.
   918.       end if;
   919.
   920.       normalizer := nr_leading_zeros(frac.msw);
   921.
   922.       if normalizer = 47 then  -- frac.msw is zero, so frac.lsw is non-zero.
   923.          normalizer := 47 + nr_leading_zeros(frac.lsw);
   924.       end if;
   925.
   926.       KDF9_exponent := KDF9_exponent - KDF9.word(normalizer);
   927.
   928.       frac := scale_up(frac, normalizer);
   929.       the_CPU_delta := the_CPU_delta + shift_time(normalizer);
   930.
   931.       -- 96-bit shift_arithmetic does not round and so cannot overflow here.
   932.       frac := scale_down(frac, 8);
   933.       frac.lsw := scale_down(frac.lsw, 8);
   934.       -- Clear both scaler fields.
   935.       frac.msw := frac.msw and mantissa_mask;
   936.       frac.lsw := frac.lsw and mantissa_mask;
   937.       if resign(KDF9_exponent) < 0 then
   938.          -- Deal with underflow.
   939.          frac := (0, 0);
   940.          return;
   941.       elsif KDF9_exponent > 255 then
   942.          -- Deal with overflow.
   943.          the_V_bit_is_set := True;
   944.          KDF9_exponent := 255;
   945.       end if;
   946.
   947.       frac.msw := frac.msw or shift_word_left(KDF9_exponent and 8#377#, 39);
   948.       if KDF9_exponent < 39 then
   949.          frac.lsw := 0;
   950.       else
   951.          frac.lsw := frac.lsw or shift_word_left((KDF9_exponent-39) and 8#377#, 39);
   952.       end if;
   953.    end reconstruct;
   954.
   955.    function "-" (R : CPU.f96)
   956.    return CPU.f96
   957.    is (CPU.f96'(0, 0) - R);
   958.
   959.    function "+" (L, R : CPU.f96)
   960.    return CPU.f96 is
   961.       -- Scale fractions to prevent overflow; must adjust exponent accordingly.
   962.       L_exponent : constant KDF9.word := scaler(L);
   963.       R_exponent : constant KDF9.word := scaler(R);
   964.       L_fraction : KDF9.pair := scale_down(fraction_pair(L), 1);
   965.       R_fraction : KDF9.pair := scale_down(fraction_pair(R), 1);
   966.       exponent   : KDF9.word;
   967.       the_result : KDF9.pair;
   968.       aligner    : Natural;
   969.    begin
   970.       if resign(R_exponent) >= resign(L_exponent) then
   971.          aligner := Natural(resign(R_exponent-L_exponent));
   972.          aligner := Natural'Min(95, aligner);
   973.          L_fraction := scale_down(L_fraction, aligner);
   974.          exponent := R_exponent + 1;
   975.       else
   976.          aligner := Natural(resign(L_exponent-R_exponent));
   977.          aligner := Natural'Min(95, aligner);
   978.          R_fraction := scale_down(R_fraction, aligner);
   979.          exponent := L_exponent + 1;
   980.       end if;
   981.       the_CPU_delta := the_CPU_delta + shift_time(aligner);
   982.       the_result := L_fraction + R_fraction;  -- "+" cannot overflow here.
   983.       reconstruct(the_result, scaler => exponent);
   984.       return as_f96(the_result);
   985.    end "+";
   986.
   987.    function "-" (L, R : CPU.f96)
   988.    return CPU.f96 is
   989.       -- See "+".
   990.       L_exponent : constant KDF9.word := scaler(L);
   991.       R_exponent : constant KDF9.word := scaler(R);
   992.       L_fraction : KDF9.pair := scale_down(fraction_pair(L), 1);
   993.       R_fraction : KDF9.pair := scale_down(fraction_pair(R), 1);
   994.       exponent   : KDF9.word;
   995.       the_result : KDF9.pair;
   996.       aligner    : Natural;
   997.    begin
   998.       if resign(R_exponent) >= resign(L_exponent) then
   999.          aligner := Natural(resign(R_exponent-L_exponent));
  1000.          aligner := Natural'Min(95, aligner);
  1001.          L_fraction := scale_down(L_fraction, aligner);
  1002.          exponent := R_exponent + 1;
  1003.       else
  1004.          aligner := Natural(resign(L_exponent-R_exponent));
  1005.          aligner := Natural'Min(95, aligner);
  1006.          R_fraction := scale_down(R_fraction, aligner);
  1007.          exponent := L_exponent + 1;
  1008.       end if;
  1009.       the_CPU_delta := the_CPU_delta + shift_time(aligner);
  1010.       the_result := L_fraction - R_fraction;  -- "-" cannot overflow here.
  1011.       reconstruct(the_result, scaler => exponent);
  1012.       return as_f96(the_result);
  1013.    end "-";
  1014.
  1015.    function "*" (L, R : CPU.f48)
  1016.    return CPU.f96 is
  1017.       V_was_set : constant Boolean := the_V_bit_is_set;
  1018.       LR        : KDF9.pair;
  1019.    begin
  1020.       the_V_bit_is_set := False;
  1021.       LR := fraction_word(L) * fraction_word(R);
  1022.       if the_V_bit_is_set then
  1023.          -- The product is not a valid fixed-point fraction, but is actually OK,
  1024.          --    so restore the orginal overflow state, and  ...
  1025.          the_V_bit_is_set := V_was_set;
  1026.          --  ... construct +1.0 in double-precision floating-point.
  1027.          return as_f96((shift_word_left(2#0_10_000_001_1#, 38), 0));
  1028.       end if;
  1029.       reconstruct(LR, scaler => scaler(L) + scaler(R));
  1030.       return as_f96(LR);
  1031.    end "*";
  1032.
  1033.    function "/" (L : CPU.f96;
  1034.                  R : CPU.f48)
  1035.    return CPU.f48 is  -- aka DIVDF
  1036.       -- If L>=R, L/R>= 1, which is not a valid fraction; so Ls and Rs are
  1037.       --    scaled so that the division cannot overflow.
  1038.       Ls     : constant KDF9.pair := scale_down(fraction_pair(L), 3);
  1039.       Rs     : constant KDF9.word := scale_down(fraction_word(R), 1);
  1040.       -- E is increased by 2 to compensate the quotient's scaling by 1/4.
  1041.       E      : constant KDF9.word := scaler(L) - scaler(R) + 2;
  1042.       F      : KDF9.word;
  1043.    begin
  1044.       if R = 0 then
  1045.          the_V_bit_is_set := True;
  1046.          return L.msw;  -- ?? This result is not well defined in the Manual.
  1047.       end if;
  1048.       do_DIVD(Ls, Rs, F);  -- Division cannot overflow here.
  1049.       return normalized(full_fraction => F, scaler => E);
  1050.    end "/";
  1051.
  1052.    procedure push (F : in CPU.f48) is
  1053.    begin
  1054.       push(KDF9.word(F));
  1055.    end push;
  1056.
  1057.    function pop
  1058.    return CPU.f48
  1059.    is (CPU.f48(KDF9.word'(pop)));
  1060.
  1061.    function read_top
  1062.    return CPU.f48
  1063.    is (CPU.f48(KDF9.word'(read_top)));
  1064.
  1065.    procedure write_top (F : in CPU.f48) is
  1066.    begin
  1067.       write_top(KDF9.word(F));
  1068.    end write_top;
  1069.
  1070.    procedure push (DF : in CPU.f96) is
  1071.       AB : constant KDF9.pair := as_pair(DF);
  1072.    begin
  1073.       push(AB);
  1074.    end push;
  1075.
  1076.    function pop
  1077.    return CPU.f96
  1078.    is (as_f96(pop));
  1079.
  1080.    function read_top
  1081.    return CPU.f96
  1082.    is (as_f96(read_top));
  1083.
  1084.    procedure write_top (DF : in CPU.f96) is
  1085.       AB : constant KDF9.pair := as_pair(DF);
  1086.    begin
  1087.       write_top(AB);
  1088.    end write_top;
  1089.
  1090. end KDF9.CPU;

Compiling: ../Source/kdf9-cpu.ads
Source file time stamp: 2021-01-10 23:52:38
Compiled at: 2021-02-08 17:20:59

     1. -- Support for KDF9 CPU/ALU operations that are not automatically inherited from
     2. --   Ada types; and for types used in the internal functioning of the microcode.
     3. --
     4. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with Ada.Unchecked_Conversion;
    19.
    20. package KDF9.CPU is
    21.
    22. --
    23. --
    24.    --
    25.    -- 48-bit integer and fractional ALU types and operations
    26.    --
    27. --
    28. --
    29.
    30.    type signed is range -2**47 .. +2**47 - 1 with Size => KDF9.word'Size;
    31.
    32.    function unsign is new Ada.Unchecked_Conversion (CPU.signed, KDF9.word);
    33.
    34.    function resign is new Ada.Unchecked_Conversion (KDF9.word, CPU.signed);
    35.
    36.    function "-" (I : CPU.signed)
    37.    return KDF9.word
    38.       with Inline;
    39.
    40.    function "abs" (I : CPU.signed)
    41.    return KDF9.word
    42.       with Inline;
    43.
    44.    function "+" (L, R : CPU.signed)
    45.    return KDF9.word
    46.       with Inline;
    47.
    48.    function "-" (L, R : CPU.signed)
    49.    return KDF9.word
    50.       with Inline;
    51.
    52.    function "*" (L, R : CPU.signed)
    53.    return KDF9.word;
    54.
    55.    -- Determine the Quotient and Remainder of L/R, where:
    56.    --    sign(Remainder) = sign(R) and |Remainder| < |R|, i.e. Remainder = L mod R;
    57.    --    Quotient = (L - Remainder) / R.
    58.
    59.    procedure do_DIVI (L : in KDF9.word;
    60.                       R : in KDF9.word;
    61.                       Quotient, Remainder : out KDF9.word);
    62.
    63.    -- Signed single-length integer substrate division is removed from consideration.
    64.
    65.    function "/" (L, R : CPU.signed)
    66.    return KDF9.word is abstract;
    67.
    68.    function "mod" (L, R : CPU.signed)
    69.    return KDF9.word is abstract;
    70.
    71.    -- Contract a double-word, setting the V bit if necessary.
    72.
    73.    function contracted (P : KDF9.pair)
    74.    return KDF9.word
    75.       with Inline;
    76.
    77.    -- Contract a double-word, represented by its components, setting the V bit if necessary.
    78.
    79.    function contracted (msw, lsw : KDF9.word)
    80.    return KDF9.word
    81.       with Inline;
    82.
    83. --
    84. --
    85.    -- Shifting operations with KDF9 semantics.
    86. --
    87. --
    88.
    89.    type signed_Q_part is range  -2**15 .. +2**15 - 1 with Size => KDF9.Q_part'Size;
    90.
    91.    function resign is new Ada.Unchecked_Conversion (KDF9.Q_part, CPU.signed_Q_part);
    92.
    93.    -- L>0 for left-shift, L<0 for right-shift.
    94.
    95.    function shift_logical (W : KDF9.word; L : CPU.signed_Q_part)
    96.    return KDF9.word
    97.       with Inline;
    98.
    99.    function shift_circular (W : KDF9.word; L : CPU.signed_Q_part)
   100.    return KDF9.word
   101.       with Inline;
   102.
   103.    -- shift_arithmetic rounds the result correctly.
   104.    function shift_arithmetic (I : KDF9.word; L : CPU.signed_Q_part)
   105.    return KDF9.word
   106.       with Inline;
   107.
   108.    -- cardinality yields the number of 1-bits in W.
   109.    function cardinality (W : KDF9.word)
   110.    return KDF9.word
   111.       with Inline;
   112.
   113. --
   114. --
   115.    -- A fraction is a word W interpreted as the value W / 2**47;
   116. --
   117. --
   118.
   119.    KDF9_small : constant := 2.0**(-47);
   120.
   121.    type fraction is delta KDF9_small range -1.0 .. +1.0 - KDF9_small with Size => KDF9.word'Size;
   122.
   123.    function as_fraction is new Ada.Unchecked_Conversion (KDF9.word, CPU.fraction);
   124.
   125.    function as_word     is new Ada.Unchecked_Conversion (CPU.fraction, KDF9.word);
   126.
   127.    -- These operations treat the KDF9.word operands as full-word fractions,
   128.
   129.    function "*" (L, R : KDF9.word)
   130.    return CPU.fraction;
   131.
   132.    function "/" (L, R : KDF9.word)
   133.    return CPU.fraction;
   134.
   135.
   136. --
   137. --
   138.    --
   139.    -- 48-bit integer and fractional ALU operations
   140.    --
   141. --
   142. --
   143.
   144.    function "+" (L, R : KDF9.pair)
   145.    return KDF9.pair
   146.       with Inline;
   147.
   148.    function "-" (J : KDF9.pair)
   149.    return KDF9.pair
   150.       with Inline;
   151.
   152.    function "-" (L, R : KDF9.pair)
   153.    return KDF9.pair
   154.       with Inline;
   155.
   156.    -- 48 * 48 -> 96-bit, for XD, etc.
   157.
   158.    function "*" (L, R : KDF9.word)
   159.    return KDF9.pair;
   160.
   161.    -- 96 / 48 -> 48-bit, for DIVD, DIVR and DIVDF.
   162.
   163.    procedure do_DIVD (L : in KDF9.pair;
   164.                       R : in KDF9.word;
   165.                       Q : out KDF9.word
   166.                      );
   167.
   168.    procedure do_DIVR (L : in KDF9.pair;
   169.                       R : in KDF9.word;
   170.                       Quotient,
   171.                       Remainder : out KDF9.word
   172.                      );
   173.
   174.    function shift_logical (P : KDF9.pair; L : CPU.signed_Q_part)
   175.    return KDF9.pair
   176.       with Inline;
   177.
   178.    function shift_arithmetic (P : KDF9.pair; L : CPU.signed_Q_part)
   179.    return KDF9.pair
   180.       with Inline;
   181.
   182.
   183. --
   184. --
   185.    --
   186.    -- 48-bit floating point ALU types and operations
   187.    --
   188. --
   189. --
   190.
   191.    -- This is a substrate for KDF9 floating point, not an Ada f.p. type.
   192.
   193.    type f48 is mod 2**48 with Size => KDF9.word'Size;
   194.
   195.    -- Remove useless substrate modular operations not, and, or, xor and mod.
   196.
   197.    overriding
   198.    function "not" (R : CPU.f48)
   199.    return CPU.f48 is abstract;
   200.
   201.    overriding
   202.    function "and" (L, R : CPU.f48)
   203.    return CPU.f48 is abstract;
   204.
   205.    overriding
   206.    function "or" (L, R : CPU.f48)
   207.    return CPU.f48 is abstract;
   208.
   209.    overriding
   210.    function "xor" (L, R : CPU.f48)
   211.    return CPU.f48 is abstract;
   212.
   213.    overriding
   214.    function "mod" (L, R : CPU.f48)
   215.    return CPU.f48 is abstract;
   216.
   217.    function as_word is new Ada.Unchecked_Conversion (CPU.f48, KDF9.word);
   218.
   219.    function as_f48  is new Ada.Unchecked_Conversion (KDF9.word, CPU.f48);
   220.
   221.    procedure push (F : in CPU.f48);
   222.
   223.    function pop
   224.    return CPU.f48
   225.       with Inline;
   226.
   227.    procedure write_top (F : in CPU.f48)
   228.       with Inline;
   229.
   230.    function read_top
   231.    return CPU.f48
   232.       with Inline;
   233.
   234.     -- Standardize a (possibly) non-normalized floating-point number.
   235.
   236.    function normalized  (R : CPU.f48)
   237.    return CPU.f48;
   238.
   239.    -- Convert a 47-bit fraction to a rounded, standardized 39-bit mantissa,
   240.    --    and adjust its exponent accordingly, setting overflow when necessary.
   241.
   242.    procedure normalize (fraction, exponent : in out KDF9.word)
   243.       with Inline;
   244.
   245.    -- Convert a 39-bit mantissa to a 47-bit fraction, preserving the sign.
   246.
   247.    function fraction_word (mantissa : CPU.f48)
   248.    return KDF9.word
   249.       with Inline;
   250.
   251.    -- The floating-point number with the exponent field set to 0.
   252.
   253.    function masked_mantissa (F : CPU.f48)
   254.    return CPU.f48
   255.       with Inline;
   256.
   257.    -- The algebraic scale-factor, not the hardware exponent, -128 <= scaler < +128.
   258.
   259.    function scaler (F : CPU.f48)
   260.    return KDF9.word
   261.       with Inline;
   262.
   263.     -- Synthesize a normalized floating-point number from its components.
   264.
   265.    function normalized (full_fraction, scaler : KDF9.word)
   266.    return CPU.f48
   267.       with Inline;
   268.
   269.    -- Round a 48-bit floating-point number to 24-bit format.
   270.
   271.    function narrowed (R : CPU.f48)
   272.    return CPU.f48;
   273.
   274.    overriding
   275.    function "-" (R : CPU.f48)
   276.    return CPU.f48;
   277.
   278.    overriding
   279.    function "abs" (R : CPU.f48)
   280.    return CPU.f48;
   281.
   282.    overriding
   283.    function "+" (L, R : CPU.f48)
   284.    return CPU.f48;
   285.
   286.    overriding
   287.    function "-" (L, R : CPU.f48)
   288.    return CPU.f48;
   289.
   290.    overriding
   291.    function "*" (L, R : CPU.f48)
   292.    return CPU.f48;
   293.
   294.    overriding
   295.    function "/" (L, R : CPU.f48)
   296.    return CPU.f48;
   297.
   298.    overriding
   299.    function "<" (L, R : CPU.f48)
   300.    return Boolean;
   301.
   302.    function host_float (X : CPU.f48)
   303.    return Long_Float;
   304.
   305.    exponent_mask : constant KDF9.word := KDF9.word'(2#11_111_111#) * 2**39;
   306.    mantissa_mask : constant KDF9.word := not exponent_mask;
   307.    frac_msb_mask : constant KDF9.word := 2**46;  -- M.S.B. of a 47-bit fraction
   308.    mant_msb_mask : constant KDF9.word := 2**38;  -- M.S.B. of a 39-bit mantissa
   309.    overflow_mask : constant KDF9.word := 2**39;  -- bit set on rounding overflow
   310.
   311.
   312. --
   313. --
   314.    --
   315.    -- 96-bit floating point ALU types and operations
   316.    --
   317. --
   318. --
   319.
   320.    type f96 is
   321.       record
   322.          msw, lsw : CPU.f48;
   323.       end record;
   324.
   325.    function as_pair is new Ada.Unchecked_Conversion (CPU.f96, KDF9.pair);
   326.
   327.    function as_f96  is new Ada.Unchecked_Conversion (KDF9.pair, CPU.f96);
   328.
   329.    procedure push (DF : in CPU.f96)
   330.       with Inline,
   331.            Pre => the_nest_depth < 15
   332.                or else the_CPU_state = Director_state;
   333.
   334.    function pop
   335.    return CPU.f96
   336.       with Inline;
   337.
   338.    procedure write_top (DF : in CPU.f96)
   339.       with Inline;
   340.
   341.    function read_top
   342.    return CPU.f96
   343.       with Inline;
   344.
   345.    -- The algebraic scale-factor, not the hardware exponent, -128 <= scaler < +128.
   346.
   347.    function scaler (DF : CPU.f96)
   348.    return KDF9.word
   349.       with Inline;
   350.
   351.    -- Round a 96-bit double-precision floating-point number to 48 bit format.
   352.
   353.    function narrowed (DF : CPU.f96)
   354.    return CPU.f48
   355.       with Inline;
   356.
   357.    -- Derive a 96-bit fraction from the double-precision floating-point number,
   358.    --    with the mantissa bits in D9-D47 and D49-D87,
   359.    --       and with D1-D8 copies of the sign, D48 zero, and D87-D95 zero.
   360.
   361.    function fraction_pair (DF : CPU.f96)
   362.    return KDF9.pair
   363.       with Inline;
   364.
   365.    -- Convert 96-bit fraction, and an algebraic scale-factor exponent,
   366.    --    into a 96-bit floating point number, setting overflow when necessary.
   367.
   368.    procedure reconstruct (frac   : in out KDF9.pair;
   369.                           scaler : in KDF9.word);
   370.
   371.    function "-" (R : CPU.f96)
   372.    return CPU.f96;
   373.
   374.    function "+" (L, R : CPU.f96)
   375.    return CPU.f96;
   376.
   377.    function "-" (L, R : CPU.f96)
   378.    return CPU.f96;
   379.
   380.    function "*" (L, R : CPU.f48)
   381.    return CPU.f96;
   382.
   383.    function "/" (L : CPU.f96;
   384.                  R : CPU.f48)
   385.    return CPU.f48;
   386.
   387. ------------------------------------------------------------------------------------------------
   388.
   389. --
   390. --
   391.    --
   392.    -- These are the emulation host's register types and their operations.
   393.    --
   394. --
   395. --
   396.
   397.    type u_64 is mod 2**64 with Size => 64;
   398.
   399.    pragma Provide_Shift_Operators (u_64);
   400.
   401.    function as_word (u : CPU.u_64)
   402.    return KDF9.word
   403.       with Inline;
   404.
   405.    type s_64 is range -2**63 .. +2**63-1 with Size => 64;
   406.
   407.    -- The signed as_word sets the V bit if necessary.
   408.
   409.    function as_word (s : CPU.s_64)
   410.    return KDF9.word
   411.       with Inline;
   412.
   413.    function unsign is new Ada.Unchecked_Conversion(CPU.s_64, CPU.u_64);
   414.
   415.    function resign is new Ada.Unchecked_Conversion(CPU.u_64, CPU.s_64);
   416.
   417. --
   418. --
   419.    --
   420.    -- These are the 48-bit primitive, fixed-direction, shift operations.
   421.    --
   422. --
   423. --
   424.
   425.    function shift_time (amount : Natural)
   426.    return KDF9.us
   427.       with Inline;
   428.
   429.    subtype word_shift_length is Natural range 0..48;
   430.
   431.    function shift_word_left (W : KDF9.word; amount : word_shift_length)
   432.    return KDF9.word
   433.       with Inline;
   434.
   435.    function shift_word_right (W : KDF9.word; amount : word_shift_length)
   436.    return KDF9.word
   437.       with Inline;
   438.
   439.    function rotate_word_left (W : KDF9.word; amount : word_shift_length)
   440.    return KDF9.word
   441.       with Inline;
   442.
   443.    function rotate_word_right (W : KDF9.word; amount : word_shift_length)
   444.    return KDF9.word
   445.       with Inline;
   446.
   447.    -- scale_up may set the V bit.
   448.
   449.    function scale_up (W : KDF9.word; amount : Natural)
   450.    return KDF9.word
   451.       with Inline;
   452.
   453.    -- scale_down_and_round rounds correctly.
   454.
   455.    function scale_down_and_round (W : KDF9.word; amount : Natural)
   456.    return KDF9.word
   457.       with Inline;
   458.
   459.    -- scale_down never rounds.
   460.
   461.    function scale_down (W : KDF9.word; amount : Natural)
   462.    return KDF9.word
   463.       with Inline;
   464.
   465. end KDF9.CPU;

 1090 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-phu_store.adb
Source file time stamp: 2021-01-10 23:52:38
Compiled at: 2021-02-08 17:20:59

     1. -- The K5 operation data formats.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Unchecked_Conversion;
    18. --
    19. with KDF9.CPU;
    20.
    21. package body KDF9.PHU_store is
    22.
    23.    function short_PHU (p : KDF9.priority)
    24.    return KDF9.word is
    25.
    26.       use type KDF9.store.group_address;
    27.
    28.       type PHU_as_6_bits is mod 2**6
    29.          with Size => 6;
    30.
    31.       function as_6_bits is new Ada.Unchecked_Conversion(Source => PHU_store.PHU_subset,
    32.                                                          Target => short_PHU.PHU_as_6_bits);
    33.
    34.       the_reason    : PHU_store.blockage_kind;
    35.       the_parameter : KDF9.buffer_number;
    36.
    37.    begin
    38.       if not PHU(p).is_held_up then
    39.          return 0;  -- All fields are non-significant.
    40.       end if;
    41.
    42.       -- PHU(p).is_held_up, so other fields are valid.
    43.       the_reason := PHU(p).blockage.reason;
    44.       if the_reason = buffer_busy then
    45.          the_parameter := PHU(p).blockage.buffer_nr;
    46.       else
    47.          -- This is next to useless, but is what the K5 order actually did.
    48.          the_parameter := KDF9.buffer_number(PHU(p).blockage.group_nr mod 2**4);
    49.       end if;
    50.
    51.       return KDF9.word(as_6_bits((the_parameter, the_reason, True)));
    52.    end short_PHU;
    53.
    54.    function K5_operand
    55.    return KDF9.word
    56.    is (
    57.        KDF9.CPU.shift_word_left(short_PHU(0), 48-06) or
    58.        KDF9.CPU.shift_word_left(short_PHU(1), 48-12) or
    59.        KDF9.CPU.shift_word_left(short_PHU(2), 48-18) or
    60.        KDF9.CPU.shift_word_left(short_PHU(3), 48-24)
    61.       );
    62.
    63. end KDF9.PHU_store;

Compiling: ../Source/kdf9-phu_store.ads
Source file time stamp: 2021-01-10 23:52:38
Compiled at: 2021-02-08 17:20:59

     1. -- The K5 operation data formats.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with System;
    18. --
    19. with KDF9.store;
    20.
    21. package KDF9.PHU_store is
    22.
    23.    -- PHU, the Program Hold-Up register is internal to I/O Control.
    24.    -- It has one element for each of the 4 program priority levels, 0..3.
    25.    -- A subset of its content is exposed to Director by means of the K5 order.
    26.
    27.    type blockage_kind is (buffer_busy, locked_core) with Size => 1;
    28.
    29.    type PHU_reason (reason : PHU_store.blockage_kind := buffer_busy) is
    30.       record
    31.          case reason is
    32.             when buffer_busy =>
    33.                buffer_nr : KDF9.buffer_number;
    34.                by_INTQq  : Boolean;
    35.             when locked_core =>
    36.                group_nr  : KDF9.store.group_address;
    37.          end case;
    38.       end record;
    39.
    40.    type PHU_register (is_held_up : Boolean := False) is
    41.       record
    42.          case is_held_up is
    43.             when False =>
    44.                null;
    45.             when True =>
    46.                blockage : PHU_reason;
    47.          end case;
    48.       end record;
    49.
    50.    idle_PHU : constant PHU_register := (is_held_up => False);
    51.
    52.    PHU : array (KDF9.priority) of PHU_store.PHU_register := (others => idle_PHU);
    53.
    54.    type PHU_subset is
    55.       record
    56.          parameter  : KDF9.buffer_number;
    57.          reason     : PHU_store.blockage_kind;
    58.          is_held_up : Boolean;
    59.       end record
    60.    with Size => 6, Bit_Order => System.Low_Order_First;
    61.
    62.    for  PHU_subset use
    63.       record
    64.          parameter  at 0 range 0 .. 3;
    65.          reason     at 0 range 4 .. 4;
    66.          is_held_up at 0 range 5 .. 5;
    67.       end record;
    68.
    69.    -- A K5_operand is a KDF9 word, D00-D47, with the content:
    70.    --    PHU_subset(0) in D00 .. D05
    71.    --    PHU_subset(1) in D06 .. D11
    72.    --    PHU_subset(2) in D12 .. D17
    73.    --    PHU_subset(3) in D18 .. D23
    74.    --    zeros         in D24 .. D47
    75.
    76.    function K5_operand
    77.    return KDF9.word;
    78.
    79. end KDF9.PHU_store;

 63 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/tracing.adb
Source file time stamp: 2021-01-21 00:39:36
Compiled at: 2021-02-08 17:20:59

     1. -- Provide diagnostic trace, breakpoint, and watchpoint support.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with exceptions;
    18. with formatting;
    19. with HCI;
    20. with KDF9.decoding;
    21. with KDF9.store;
    22. with state_display;
    23.
    24. use exceptions;
    25. use formatting;
    26. use HCI;
    27. use KDF9;
    28. use KDF9.decoding;
    29. use KDF9.store;
    30. use state_display;
    31.
    32. package body tracing is
    33.
    34.    procedure clear_the_histogram is
    35.    begin
    36.       the_histogram := (others => 0);
    37.    end clear_the_histogram;
    38.
    39.    procedure clear_the_profile is
    40.    begin
    41.       the_profile := (others => 0);
    42.    end clear_the_profile;
    43.
    44.    procedure set_breakpoints (first, last : in KDF9.order_word_number) is
    45.    begin
    46.       for p in first .. last loop
    47.          breakpoints(p) := True;
    48.       end loop;
    49.    end set_breakpoints;
    50.
    51.    procedure handle_breakpoint is
    52.    begin
    53.       short_witness;
    54.       interact;
    55.       quit_if_requested;
    56.       change_diagnostic_mode_if_requested;
    57.    end handle_breakpoint;
    58.
    59.    procedure clear_all_watchpoints is
    60.    begin
    61.       fetchpoints := (others => False);
    62.       storepoints := (others => False);
    63.    end clear_all_watchpoints;
    64.
    65.    procedure set_fetch_points (first, last : in KDF9.address) is
    66.    begin
    67.       for p in first .. last loop
    68.          fetchpoints(p) := True;
    69.       end loop;
    70.    end set_fetch_points;
    71.
    72.    procedure set_store_points (first, last : in KDF9.address) is
    73.    begin
    74.       for p in first .. last loop
    75.          storepoints(p) := True;
    76.       end loop;
    77.    end set_store_points;
    78.
    79.    procedure clear_retro_FIFO is
    80.    begin
    81.       retro_FIFO_count := 0; retro_FIFO_index := 0;
    82.    end clear_retro_FIFO;
    83.
    84.    procedure take_note_of (the_IAR   : in KDF9.syllable_address;
    85.                            the_value : in KDF9.word) is
    86.    begin
    87.       if the_retrospective_trace_is_enabled           and then
    88.             ICR in low_count .. high_count            and then
    89.                NIA_word_number in low_bound .. high_bound then
    90.          declare
    91.             the_note : constant retro_FIFO_entry
    92.                      := (
    93.                          location   => the_IAR,
    94.                          order      => INS.order,
    95.                          parameter  => the_value,
    96.                          ICR_value  => ICR,
    97.                          CPU_time   => the_CPU_time,
    98.                          nested     => the_nest_depth,
    99.                          called     => the_sjns_depth,
   100.                          V          => the_V_bit_is_set,
   101.                          T          => the_T_bit_is_set,
   102.                          D          => the_CPU_state = Director_state,
   103.                          level      => CPL
   104.                         );
   105.          begin
   106.             if retro_FIFO_count = 0 then
   107.                retro_FIFO(0) := the_note;
   108.                retro_FIFO_count := 1;
   109.             else
   110.                retro_FIFO_index := retro_FIFO_index + 1;
   111.                retro_FIFO(retro_FIFO_index) := the_note;
   112.                if retro_FIFO_count < FIFO_size then
   113.                   retro_FIFO_count := retro_FIFO_count + 1;
   114.                end if;
   115.             end if;
   116.          end;
   117.       end if;
   118.    end take_note_of;
   119.
   120.    procedure take_note_of (the_value : in KDF9.word) is
   121.    begin
   122.       take_note_of(CIA, the_value);
   123.    end take_note_of;
   124.
   125.    procedure clear_IOC_FIFO is
   126.    begin
   127.       IOC_FIFO_count := 0; IOC_FIFO_index := 0;
   128.    end clear_IOC_FIFO;
   129.
   130.    procedure register_IO_event (the_note : in IOC_FIFO_entry) is
   131.    begin
   132.       if the_peripheral_trace_is_enabled              and then
   133.             ICR in low_count .. high_count            and then
   134.                NIA_word_number in low_bound .. high_bound then
   135.          if IOC_FIFO_count = 0 then
   136.             IOC_FIFO(0) := the_note;
   137.             IOC_FIFO_count := 1;
   138.          else
   139.             IOC_FIFO_index := IOC_FIFO_index + 1;
   140.             IOC_FIFO(IOC_FIFO_index) := the_note;
   141.             if IOC_FIFO_count < FIFO_size then
   142.                IOC_FIFO_count := IOC_FIFO_count + 1;
   143.             end if;
   144.          end if;
   145.       end if;
   146.    end register_IO_event;
   147.
   148.    procedure take_note_of_IO_start (
   149.                                     device_name     : in IOC.device_name;
   150.                                     completion_time : in KDF9.us;
   151.                                     control_word    : in KDF9.Q_register;
   152.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   153.                                    )
   154.    is
   155.       the_note : constant  IOC_FIFO_entry
   156.                :=
   157.                 (
   158.                  kind            => start_transfer,
   159.                  ICR_value       => ICR,
   160.                  order_address   => CIA,
   161.                  decoded_order   => INS,
   162.                  initiation_time => the_clock_time,
   163.                  device_name     => take_note_of_IO_start.device_name,
   164.                  completion_time => take_note_of_IO_start.completion_time,
   165.                  is_for_Director => (the_CPU_state = Director_state),
   166.                  priority_level  => CPL,
   167.                  context         => the_context,
   168.                  control_word    => take_note_of_IO_start.control_word,
   169.                  operation       => take_note_of_IO_start.operation
   170.                 );
   171.    begin
   172.       register_IO_event(the_note);
   173.    end take_note_of_IO_start;
   174.
   175.    procedure take_note_of_IO_finis (
   176.                                     ICR_value       : in KDF9.order_counter;
   177.                                     order_address   : in KDF9.syllable_address;
   178.                                     decoded_order   : in KDF9.decoded_order;
   179.                                     initiation_time : in KDF9.us;
   180.                                     device_name     : in IOC.device_name;
   181.                                     is_for_Director : Boolean;
   182.                                     priority_level  : in KDF9.priority;
   183.                                     completion_time : in KDF9.us;
   184.                                     control_word    : in KDF9.Q_register;
   185.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   186.                                    )
   187.    is
   188.       the_note : constant  IOC_FIFO_entry
   189.                :=
   190.                 (
   191.                  kind            => finis_transfer,
   192.                  ICR_value       => take_note_of_IO_finis.ICR_value,
   193.                  order_address   => take_note_of_IO_finis.order_address,
   194.                  decoded_order   => take_note_of_IO_finis.decoded_order,
   195.                  initiation_time => take_note_of_IO_finis.initiation_time,
   196.                  device_name     => take_note_of_IO_finis.device_name,
   197.                  is_for_Director => take_note_of_IO_finis.is_for_Director,
   198.                  priority_level  => take_note_of_IO_finis.priority_level,
   199.                  context         => the_context,
   200.                  completion_time => take_note_of_IO_finis.completion_time,
   201.                  control_word    => take_note_of_IO_finis.control_word,
   202.                  operation       => take_note_of_IO_finis.operation
   203.                 );
   204.
   205.    begin
   206.       register_IO_event(the_note);
   207.    end take_note_of_IO_finis;
   208.
   209.    procedure take_note_of_store_lockout (device_name : in IOC.device_name) is
   210.       the_note : constant  IOC_FIFO_entry
   211.                :=
   212.                 (
   213.                  kind            => store_lockout,
   214.                  ICR_value       => ICR,
   215.                  order_address   => CIA,
   216.                  decoded_order   => INS,
   217.                  initiation_time => the_clock_time,
   218.                  device_name     => take_note_of_store_lockout.device_name,
   219.                  is_for_Director => False,
   220.                  priority_level  => CPL,
   221.                  context         => the_context,
   222.                  data_address    => the_locked_out_address,
   223.                  operation       => IOC.some_other_operation
   224.                 );
   225.    begin
   226.       register_IO_event(the_note);
   227.    end take_note_of_store_lockout;
   228.
   229.    procedure take_note_of_buffer_lockout (device_name : in IOC.device_name;
   230.                                           operation   : in IOC.transfer_kind := IOC.some_other_operation) is
   231.       the_note : constant  IOC_FIFO_entry
   232.                :=
   233.                 (
   234.                  kind            => buffer_lockout,
   235.                  ICR_value       => ICR,
   236.                  order_address   => CIA,
   237.                  decoded_order   => INS,
   238.                  initiation_time => the_clock_time,
   239.                  device_name     => take_note_of_buffer_lockout.device_name,
   240.                  is_for_Director => False,
   241.                  priority_level  => CPL,
   242.                  context         => the_context,
   243.                  operation       => take_note_of_buffer_lockout.operation
   244.                 );
   245.    begin
   246.       register_IO_event(the_note);
   247.    end take_note_of_buffer_lockout;
   248.
   249.    procedure take_note_of_test (
   250.                                 device_name : in IOC.device_name;
   251.                                 Q_register  : in KDF9.Q_register;
   252.                                 status      : in Boolean
   253.                                )
   254.    is
   255.       the_note : constant  IOC_FIFO_entry
   256.                :=
   257.                 (
   258.                  kind            => buffer_status,
   259.                  ICR_value       => ICR+1,  -- ICR is not incremented until the end of an order.
   260.                  order_address   => CIA,
   261.                  decoded_order   => INS,
   262.                  initiation_time => the_clock_time,
   263.                  device_name     => take_note_of_test.device_name,
   264.                  is_for_Director => (the_CPU_state = Director_state),
   265.                  priority_level  => CPL,
   266.                  context         => the_context,
   267.                  Q_register      => take_note_of_test.Q_register,
   268.                  status          => take_note_of_test.status,
   269.                  operation       => IOC.some_other_operation
   270.                 );
   271.    begin
   272.       register_IO_event(the_note);
   273.    end take_note_of_test;
   274.
   275.    procedure clear_interrupt_FIFO is
   276.    begin
   277.       interrupt_FIFO_count := 0; interrupt_FIFO_index := 0;
   278.    end clear_interrupt_FIFO;
   279.
   280.    procedure take_note_of_interrupt (interrupt_code : in KDF9.interrupt_number; message : in String)
   281.    is
   282.       length : constant Natural := message'Length;
   283.       memo   : String(1..max_interrupt_message_length) := (others => ' ');
   284.    begin
   285.       if length > max_interrupt_message_length then
   286.          raise emulation_failure with "interrupt message too long: '" & message & "'" & length'Image;
   287.       end if;
   288.       memo(1..length) := message;
   289.       declare
   290.          the_note : constant interrupt_FIFO_entry
   291.                   :=
   292.                    (
   293.                     interrupt_code => take_note_of_interrupt.interrupt_code,
   294.                     ICR_value      => ICR,
   295.                     order_address  => CIA,
   296.                     busy_time      => the_clock_time,
   297.                     priority_level => CPL,
   298.                     context        => the_context,
   299.                     message        => memo
   300.                    );
   301.       begin
   302.          if the_interrupt_trace_is_enabled               and then
   303.                ICR in low_count .. high_count            and then
   304.                   NIA_word_number in low_bound .. high_bound then
   305.             if interrupt_FIFO_count = 0 then
   306.                interrupt_FIFO(0) := the_note;
   307.                interrupt_FIFO_count := 1;
   308.             else
   309.                interrupt_FIFO_index := interrupt_FIFO_index + 1;
   310.                interrupt_FIFO(interrupt_FIFO_index) := the_note;
   311.                if interrupt_FIFO_count < FIFO_size then
   312.                   interrupt_FIFO_count := interrupt_FIFO_count + 1;
   313.                end if;
   314.             end if;
   315.          end if;
   316.       end;
   317.    end take_note_of_interrupt;
   318.
   319.    procedure add_INS_to_the_histogram is
   320.       syllable_0 : KDF9.syllable := INS.order.syllable_0;
   321.    begin
   322.       if INS.kind = normal_jump_order then
   323.          syllable_0 := (syllable_0 and 2#1111_0000#) or INS.Qq;
   324.       elsif INS.kind = data_access_order then
   325.          syllable_0 := (syllable_0 and 2#11_000_111#);
   326.       end if;
   327.       the_histogram(syllable_0) := the_histogram(syllable_0) + 1;
   328.    end add_INS_to_the_histogram;
   329.
   330.    procedure add_CIA_to_the_profile is
   331.    begin
   332.       the_profile(CIA.order_word_number) := the_profile(CIA.order_word_number) + 1;
   333.    end add_CIA_to_the_profile;
   334.
   335.    procedure preview_a_one_syllable_order is null;
   336.
   337.    procedure preview_a_two_syllable_order is
   338.    begin
   339.       case INS.compressed_opcode is
   340.          when TO_MkMq
   341.             | TO_MkMqQ
   342.             | TO_MkMqH
   343.             | TO_MkMqQH
   344.             | TO_MkMqN
   345.             | TO_MkMqQN
   346.             | TO_MkMqHN
   347.             | TO_MkMqQHN =>
   348.             the_trace_operand := read_top;
   349.          when others =>
   350.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   351.       end case;
   352.    end preview_a_two_syllable_order;
   353.
   354.    procedure preview_a_jump_order is
   355.    begin
   356.       case INS.compressed_opcode is
   357.          when JrEQ
   358.             | JrNE
   359.             | JrGTZ
   360.             | JrLTZ
   361.             | JrEQZ
   362.             | JrLEZ
   363.             | JrGEZ
   364.             | JrNEZ
   365.             | OS_OUT =>
   366.             if the_nest_depth > 0 then
   367.                the_trace_operand := read_top;
   368.             end if;
   369.          when JrEN
   370.             | JrNEN =>
   371.             the_trace_operand := KDF9.word(the_nest_depth);
   372.          when JrEJ
   373.             | JrNEJ =>
   374.             the_trace_operand := KDF9.word(the_sjns_depth);
   375.          when EXIT_n
   376.             | EXITD =>
   377.             if the_sjns_depth > 0 then
   378.                the_trace_operand := as_word(sjns_top);
   379.             else
   380.                the_trace_operand := -1;
   381.             end if;
   382.          when JrCqZ
   383.             | JrCqNZ =>
   384.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   385.          when JrV
   386.             | JrNV =>
   387.             the_trace_operand := (if the_V_bit_is_set then 1 else 0);
   388.          when JrTR
   389.             | JrNTR =>
   390.             the_trace_operand := (if the_T_bit_is_set then 1 else 0);
   391.          when others =>
   392.             null;
   393.       end case;
   394.    end preview_a_jump_order;
   395.
   396.    procedure preview_a_data_access_order is
   397.    begin
   398.       case INS.compressed_opcode is
   399.          when TO_EaMq
   400.             | TO_EaMqQ =>
   401.             the_trace_operand := read_top;
   402.          when others =>
   403.             null;
   404.       end case;
   405.    end preview_a_data_access_order;
   406.
   407.    procedure look_back_at_a_one_syllable_order is
   408.       AB : KDF9.pair;
   409.    begin
   410.       case INS.compressed_opcode is
   411.          when XDF
   412.             | XPLUSF
   413.             | MINUSDF
   414.             | PLUSDF
   415.             | FLOATD
   416.             | NEGDF
   417.             | MAXF
   418.             | PERM
   419.             | CAB
   420.             | MAX
   421.             | XD
   422.             | NEGD
   423.             | DUPD
   424.             | DIVI
   425.             | STR
   426.             | REVD
   427.             | MINUSD
   428.             | PLUSD
   429.             | DIVR =>
   430.             AB := read_top;
   431.             the_trace_operand := AB.msw;
   432.          when others =>
   433.             if the_nest_depth > 0 then
   434.                the_trace_operand := read_top;
   435.             end if;
   436.       end case;
   437.    end look_back_at_a_one_syllable_order;
   438.
   439.    procedure look_back_at_an_IO_order is null;
   440.
   441.    procedure look_back_at_a_two_syllable_order is
   442.       AB : KDF9.pair;
   443.    begin
   444.       case INS.compressed_opcode is
   445.          when MkMq
   446.             | MkMqQ
   447.             | MkMqH
   448.             | MkMqQH
   449.             | MkMqQN
   450.             | MkMqHN
   451.             | MkMqQHN
   452.             | QCIMq
   453.             | SHA
   454.             | SHL
   455.             | SHC
   456.             | TO_Kq
   457.             | Kk
   458.             | LINK =>
   459.             the_trace_operand := read_top;
   460.          when TO_MkMq
   461.             | TO_MkMqQ
   462.             | TO_MkMqH
   463.             | TO_MkMqQH
   464.             | TO_MkMqN
   465.             | TO_MkMqQN
   466.             | TO_MkMqHN
   467.             | TO_MkMqQHN =>
   468.             null;
   469.          when M_PLUS_Iq
   470.             | M_MINUS_Iq
   471.             | NCq
   472.             | DCq
   473.             | POS1_TO_Iq
   474.             | NEG1_TO_Iq
   475.             | POS2_TO_Iq
   476.             | NEG2_TO_Iq
   477.             | TO_RCIMq
   478.             | ADD_TO_QCIMq
   479.             | JCqNZS =>
   480.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   481.          when CqTOQk
   482.             | IqTOQk
   483.             | MqTOQk
   484.             | QqTOQk
   485.             | CIqTOQk
   486.             | IMqTOQk
   487.             | CMqTOQk =>
   488.             the_trace_operand := as_word(the_Q_store(INS.Qk));
   489.          when SHLD
   490.             | SHAD
   491.             | MACC =>
   492.             AB := read_top;
   493.             the_trace_operand := AB.msw;
   494.          when TO_LINK =>
   495.             the_trace_operand := as_word(sjns_top);
   496.          when others =>
   497.             look_back_at_an_IO_order;
   498.       end case;
   499.    end look_back_at_a_two_syllable_order;
   500.
   501.    procedure look_back_at_a_jump_order is
   502.       BA_image  : constant String := "BA #" & oct_of(BA);
   503.       NOL_image : constant String := "NOL"  & NOL'Image;
   504.    begin
   505.       case INS.compressed_opcode is
   506.          when Jr =>
   507.             the_trace_operand := as_word(sjns_link(NIA));
   508.          when JSr =>
   509.             the_trace_operand := as_word(sjns_top);
   510.          when EXITD =>
   511.             take_note_of_interrupt(EXITD_flag, BA_image & " " & NOL_image & " @ " & oct_of(NIA));
   512.          when others =>
   513.             null;
   514.       end case;
   515.    end look_back_at_a_jump_order;
   516.
   517.    procedure look_back_at_a_data_access_order is
   518.    begin
   519.       case INS.compressed_opcode is
   520.          when EaMq
   521.             | EaMqQ
   522.             | SET =>
   523.             the_trace_operand := read_top;
   524.          when others =>
   525.             null;
   526.       end case;
   527.    end look_back_at_a_data_access_order;
   528.
   529.    procedure act_on_any_fetchpoint is
   530.       use type watch_flags.set;
   531.    begin
   532.       if fetchpoints/the_trace_address then
   533.          log_new_line;
   534.          log("Fetch watchhpoint: N1 := [#" & oct_of(the_trace_address) & "]");
   535.          short_witness;
   536.          interact;
   537.          quit_if_requested;
   538.          change_diagnostic_mode_if_requested;
   539.       end if;
   540.    end act_on_any_fetchpoint;
   541.
   542.    procedure act_on_any_storepoint is
   543.       use type watch_flags.set;
   544.    begin
   545.       if storepoints/the_trace_address then
   546.          log_new_line;
   547.          log(
   548.              "Store watchpoint: #"
   549.            & oct_of(the_trace_address)
   550.            & " := [N1] = #"
   551.            & oct_of(the_trace_operand)
   552.             );
   553.          short_witness;
   554.          interact;
   555.          quit_if_requested;
   556.          change_diagnostic_mode_if_requested;
   557.       end if;
   558.    end act_on_any_storepoint;
   559.
   560.    procedure act_on_any_two_syllable_order_watchpoints is
   561.    begin
   562.       case INS.compressed_opcode is
   563.          when MkMq
   564.             | MkMqQ
   565.             | MkMqH
   566.             | MkMqQH
   567.             | MkMqQN
   568.             | MkMqHN
   569.             | MkMqQHN =>
   570.             act_on_any_fetchpoint;
   571.          when TO_MkMq
   572.             | TO_MkMqQ
   573.             | TO_MkMqH
   574.             | TO_MkMqQH
   575.             | TO_MkMqN
   576.             | TO_MkMqQN
   577.             | TO_MkMqHN
   578.             | TO_MkMqQHN =>
   579.             act_on_any_storepoint;
   580.          when others =>
   581.             null;
   582.       end case;
   583.    end act_on_any_two_syllable_order_watchpoints;
   584.
   585.    procedure act_on_any_data_access_order_watchpoints is
   586.    begin
   587.       case INS.compressed_opcode is
   588.          when EaMq
   589.             | EaMqQ =>
   590.             act_on_any_fetchpoint;
   591.          when TO_EaMq
   592.             | TO_EaMqQ =>
   593.             act_on_any_storepoint;
   594.          when others =>
   595.             null;
   596.       end case;
   597.    end act_on_any_data_access_order_watchpoints;
   598.
   599. end tracing;

Compiling: ../Source/tracing.ads
Source file time stamp: 2021-01-10 23:52:41
Compiled at: 2021-02-08 17:20:59

     1. -- Provide diagnostic trace, breakpoint, and watchpoint support.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with generic_sets;
    18. with IOC;
    19. with KDF9;
    20. with settings;
    21.
    22. use  settings;
    23.
    24. package tracing is
    25.
    26.    -- Support for significant-operand evaluation and tracing.
    27.
    28.    the_trace_operand : KDF9.word;
    29.    the_trace_address : KDF9.address;
    30.
    31.    procedure preview_a_one_syllable_order;
    32.
    33.    procedure preview_a_two_syllable_order;
    34.
    35.    procedure preview_a_jump_order;
    36.
    37.    procedure preview_a_data_access_order;
    38.
    39.    procedure look_back_at_a_one_syllable_order;
    40.
    41.    procedure look_back_at_a_two_syllable_order;
    42.
    43.    procedure look_back_at_a_jump_order;
    44.
    45.    procedure look_back_at_a_data_access_order;
    46.
    47.    -- Support for breakpoints.
    48.
    49.    package order_flags is new generic_sets(member => KDF9.order_word_number);
    50.
    51.    breakpoints : order_flags.set := order_flags.empty_set;
    52.
    53.    procedure set_breakpoints (first, last : in KDF9.order_word_number);
    54.
    55.    procedure handle_breakpoint;
    56.
    57.    -- Support for watchpoints.
    58.
    59.    package watch_flags is new generic_sets(member => KDF9.address);
    60.
    61.    fetchpoints : watch_flags.set := watch_flags.empty_set;
    62.    storepoints : watch_flags.set := watch_flags.empty_set;
    63.
    64.    procedure clear_all_watchpoints;
    65.
    66.    procedure set_fetch_points (first, last : in KDF9.address);
    67.
    68.    procedure set_store_points (first, last : in KDF9.address);
    69.
    70.    procedure act_on_any_two_syllable_order_watchpoints
    71.       with Pre => the_diagnostic_mode /= fast_mode;
    72.
    73.    procedure act_on_any_data_access_order_watchpoints
    74.       with Pre => the_diagnostic_mode /= fast_mode;
    75.
    76.
    77.    --
    78.    -- Retrospective tracing.
    79.    --
    80.
    81.    FIFO_size : constant := 256;
    82.
    83.    type FIFO_index is mod FIFO_size;
    84.
    85.    -- Support for all-instruction retrospective tracing.
    86.
    87.    type retro_FIFO_entry is
    88.       record
    89.          location  : KDF9.syllable_address;
    90.          order     : KDF9.syllable_group;
    91.          parameter : KDF9.word;
    92.          ICR_value : KDF9.order_counter;
    93.          CPU_time  : KDF9.us;
    94.          nested    : KDF9.nest_depth;
    95.          called    : KDF9.sjns_depth;
    96.          V, T, D   : Boolean;
    97.          level     : KDF9.priority;
    98.       end record;
    99.
   100.    retro_FIFO  : array (tracing.FIFO_index) of tracing.retro_FIFO_entry;
   101.
   102.    retro_FIFO_index : tracing.FIFO_index := 0;
   103.
   104.    retro_FIFO_count : Natural range 0 .. FIFO_size := 0;
   105.
   106.    procedure clear_retro_FIFO;
   107.
   108.    procedure take_note_of (the_value : in KDF9.word);
   109.
   110.    -- Support for retrospective peripheral I/O tracing.
   111.
   112.    type IOC_event_kind is (start_transfer,
   113.                            finis_transfer,
   114.                            buffer_lockout,
   115.                            store_lockout,
   116.                            buffer_status);
   117.
   118.
   119.    type IOC_FIFO_entry (kind : IOC_event_kind := start_transfer) is
   120.       record
   121.          ICR_value       : KDF9.order_counter;
   122.          order_address   : KDF9.syllable_address;
   123.          decoded_order   : KDF9.decoded_order;
   124.          initiation_time : KDF9.us;
   125.          device_name     : IOC.device_name;
   126.          is_for_Director : Boolean;
   127.          priority_level  : KDF9.priority;
   128.          context         : KDF9.context;
   129.          operation       : IOC.transfer_kind := IOC.some_other_operation;
   130.          case kind is
   131.             when start_transfer | finis_transfer =>
   132.                completion_time : KDF9.us;
   133.                control_word    : KDF9.Q_register;
   134.             when store_lockout =>
   135.                data_address : KDF9.Q_part;
   136.             when buffer_lockout =>
   137.                null;
   138.             when buffer_status =>
   139.                Q_register : KDF9.Q_register;
   140.                status     : Boolean;
   141.          end case;
   142.       end record;
   143.
   144.    IOC_FIFO  : array (tracing.FIFO_index) of tracing.IOC_FIFO_entry;
   145.
   146.    IOC_FIFO_index : tracing.FIFO_index := 0;
   147.
   148.    IOC_FIFO_count : Natural range 0 .. FIFO_size := 0;
   149.
   150.    procedure clear_IOC_FIFO;
   151.
   152.    procedure take_note_of_IO_start (
   153.                                     device_name     : in IOC.device_name;
   154.                                     completion_time : in KDF9.us;
   155.                                     control_word    : in KDF9.Q_register;
   156.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   157.                                    );
   158.
   159.    procedure take_note_of_IO_finis (
   160.                                     ICR_value       : in KDF9.order_counter;
   161.                                     order_address   : in KDF9.syllable_address;
   162.                                     decoded_order   : in KDF9.decoded_order;
   163.                                     initiation_time : in KDF9.us;
   164.                                     device_name     : in IOC.device_name;
   165.                                     is_for_Director : Boolean;
   166.                                     priority_level  : in KDF9.priority;
   167.                                     completion_time : in KDF9.us;
   168.                                     control_word    : in KDF9.Q_register;
   169.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   170.                                    );
   171.
   172.    procedure take_note_of_store_lockout  (device_name : in IOC.device_name);
   173.
   174.    procedure take_note_of_buffer_lockout (device_name : in IOC.device_name;
   175.                                           operation   : in IOC.transfer_kind := IOC.some_other_operation);
   176.
   177.    procedure take_note_of_test (
   178.                                 device_name : in IOC.device_name;
   179.                                 Q_register  : in KDF9.Q_register;
   180.                                 status      : in Boolean
   181.                                 );
   182.
   183.
   184.    -- Support for retrospective interrupt-request tracing.
   185.
   186.    max_interrupt_message_length : constant := 100;
   187.    type interrupt_FIFO_entry is
   188.       record
   189.          interrupt_code : KDF9.interrupt_number;
   190.          ICR_value      : KDF9.order_counter;
   191.          order_address  : KDF9.syllable_address;
   192.          busy_time      : KDF9.us;
   193.          priority_level : KDF9.priority;
   194.          context        : KDF9.context;
   195.          message        : String (1..max_interrupt_message_length);
   196.       end record;
   197.
   198.    interrupt_FIFO  : array (tracing.FIFO_index) of tracing.interrupt_FIFO_entry;
   199.
   200.    interrupt_FIFO_index : tracing.FIFO_index := 0;
   201.
   202.    interrupt_FIFO_count : Natural range 0 .. FIFO_size := 0;
   203.
   204.    procedure clear_interrupt_FIFO;
   205.
   206.    procedure take_note_of_interrupt (interrupt_code : in KDF9.interrupt_number; message : in String);
   207.
   208.
   209.    -- Support for the instruction-type and instruction-word frequency histograms.
   210.
   211.    the_histogram : array (KDF9.syllable) of KDF9.order_counter;
   212.
   213.    procedure clear_the_histogram;
   214.
   215.    procedure add_INS_to_the_histogram
   216.       with Inline;
   217.
   218.    the_profile   : array (KDF9.order_word_number) of KDF9.order_counter;
   219.
   220.    procedure clear_the_profile;
   221.
   222.    procedure add_CIA_to_the_profile
   223.       with Inline;
   224.
   225. end tracing;

 599 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/host_io.adb
Source file time stamp: 2021-02-07 23:23:20
Compiled at: 2021-02-08 17:20:59

     1. -- Buffered I/O streams to support KDF9 device I/O.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Latin_1;
    18. with Ada.Exceptions;
    19. --
    20. with exceptions;
    21. with OS_specifics;
    22.
    23. use  Ada.Characters.Latin_1;
    24. --
    25. use  exceptions;
    26. use  OS_specifics;
    27.
    28. package body host_IO is
    29.
    30.    function fd_of (the_stream : host_IO.stream)
    31.    return Natural
    32.    is (the_stream.fd);
    33.
    34.    NL : constant String := OS_specifics.EOL;
    35.
    36.    function image_of (the_stream : host_IO.stream;
    37.                       caption    : String := "")
    38.    return String
    39.    is (if the_stream.is_open then
    40.           caption
    41.         & ":"
    42.         & NL
    43.         & "base_name = "
    44.         & the_stream.base_name
    45.         & NL
    46.         & "is_open = "
    47.         & the_stream.is_open'Image
    48.         & NL
    49.         & "block_size ="
    50.         & the_stream.block_size'Image
    51.         & NL
    52.         & "bytes_moved ="
    53.         & the_stream.bytes_moved'Image
    54.         & NL
    55.         & "fd ="
    56.         & the_stream.fd'Image
    57.         & NL
    58.         & "IO_mode ="
    59.         & the_stream.IO_mode'Image
    60.         & NL
    61.         & "last_IO ="
    62.         & the_stream.last_IO'Image
    63.         & NL
    64.         & "next_byte ="
    65.         & the_stream.next_byte'Image
    66.         & NL
    67.         & "position ="
    68.         & the_stream.position'Image
    69.         & NL
    70.         & "column = "
    71.         & the_stream.column'Image
    72.        else
    73.           caption
    74.       );
    75.
    76.    procedure diagnose (the_stream : host_IO.stream;
    77.                        caption    : String := "")
    78.       with Inline => False;
    79.
    80.    procedure diagnose (the_stream : host_IO.stream;
    81.                        caption    : String := "") is
    82.    begin
    83.       raise stream_IO_error with image_of(the_stream, caption);
    84.    end diagnose;
    85.
    86.    procedure open (the_stream : in out host_IO.stream;
    87.                    file_name  : in String;
    88.                    mode       : in POSIX.access_mode;
    89.                    fd         : in Integer) is
    90.    begin
    91.       if fd >= 0 then
    92.          make_transparent(fd);
    93.          the_stream.base_name := file_name(file_name'First .. file_name'First+2);
    94.          the_stream.IO_mode := mode;
    95.          the_stream.last_IO := read_mode;
    96.          the_stream.fd := fd;
    97.          the_stream.is_open := True;
    98.       else
    99.          the_stream.is_open := False;
   100.       end if;
   101.    end open;
   102.
   103.    procedure open (the_stream : in out host_IO.stream;
   104.                    file_name  : in String;
   105.                    mode       : in POSIX.access_mode) is
   106.       fd : Integer;
   107.    begin -- open
   108.       fd := POSIX.open(file_name, mode);
   109.       open(the_stream, file_name, mode, fd);
   110.    exception
   111.       when POSIX_IO_error =>
   112.          trap_operator_error("'" & file_name & "' cannot be opened in " & mode'Image);
   113.    end open;
   114.
   115.    procedure truncate (the_stream : in out host_IO.stream;
   116.                        to_length  : in KDF9.word := 0) is
   117.    begin
   118.       truncate(the_stream.fd, POSIX.file_position(to_length));
   119.    end truncate;
   120.
   121.    procedure close (the_stream : in out host_IO.stream) is
   122.       response : Integer;
   123.    begin
   124.       if the_stream.is_open then
   125.          flush(the_stream);
   126.          response := close(the_stream.fd);
   127.          pragma Unreferenced(response);
   128.          the_stream.is_open := False;
   129.       end if;
   130.    end close;
   131.
   132.    procedure flush (the_stream  : in out host_IO.stream;
   133.                     a_byte_time : in KDF9.us := 0) is
   134.       response : Integer;
   135.    begin
   136.       if the_stream.is_open      and then
   137.             the_stream.next_byte > 0 then
   138.          if the_stream.IO_mode > read_mode and the_stream.last_IO = write_mode then
   139.             if a_byte_time = 0 then
   140.                response := write(the_stream.fd, the_stream.buffer, the_stream.next_byte);
   141.             else
   142.                for p in 1 .. the_stream.next_byte loop
   143.                   response := write(the_stream.fd, the_stream.buffer(p..p), 1);
   144.                   KDF9.delay_by(a_byte_time);
   145.                end loop;
   146.             end if;
   147.             pragma Unreferenced(response);
   148.          end if;
   149.          the_stream.next_byte := 0;
   150.          the_stream.block_size := 0;
   151.       end if;
   152.    exception
   153.       when error : others =>
   154.          diagnose(the_stream, "FLUSH: " & Ada.Exceptions.Exception_Message(error));
   155.    end flush;
   156.
   157.    function a_LF_was_just_read (the_stream : host_IO.stream)
   158.    return Boolean
   159.    is (
   160.        the_stream.is_open                   and then
   161.           the_stream.bytes_moved > 0        and then
   162.              the_stream.last_IO = read_mode and then
   163.                 the_stream.next_byte = 0    and then
   164.                    the_stream.block_size = 0
   165.       );
   166.
   167.    function a_LF_was_just_written (the_stream : host_IO.stream)
   168.    return Boolean
   169.    is (
   170.        the_stream.is_open                    and then
   171.           the_stream.bytes_moved > 0         and then
   172.              the_stream.last_IO /= read_mode and then
   173.                 the_stream.column = 0
   174.       );
   175.
   176.    procedure reattach (the_stream : in out host_IO.stream;
   177.                        file_name  : in String;
   178.                        mode       : in POSIX.access_mode) is
   179.       old_fd   : constant Integer := the_stream.fd;
   180.    begin
   181.       if mode /= the_stream.IO_mode      and then
   182.             the_stream.IO_mode /= rd_wr_mode then
   183.          diagnose(the_stream, "REATTACH: the new mode is incompatible");
   184.       end if;
   185.       close(the_stream);
   186.       open(the_stream, file_name, (if the_stream.IO_mode = rd_wr_mode then rd_wr_mode else mode));
   187.        if old_fd = 0 and the_stream.fd /= 0 then
   188.          diagnose(the_stream, "REATTACH: standard input cannot be reopened");
   189.       end if;
   190.       if the_stream.is_open then
   191.          the_stream.last_char := ' ';
   192.          the_stream.block_size := 0;
   193.          the_stream.next_byte := 0;
   194.          the_stream.position := 0;
   195.       end if;
   196.    exception
   197.       when stream_IO_error =>
   198.          raise;
   199.       when error : operator_error =>
   200.          raise operator_error with Ada.Exceptions.Exception_Information(error);
   201.       when error : others =>
   202.          diagnose(the_stream, "REATTACH: " & Ada.Exceptions.Exception_Information(error));
   203.    end reattach;
   204.
   205.    function is_open (the_stream : host_IO.stream)
   206.    return Boolean
   207.    is (the_stream.is_open);
   208.
   209.    function bytes_moved (the_stream : host_IO.stream)
   210.    return KDF9.word
   211.    is (the_stream.bytes_moved);
   212.
   213.    function file_size (the_stream : host_IO.stream)
   214.    return Natural is
   215.       here  : constant POSIX.file_position := seek(the_stream.fd, 0, from_here);
   216.       size  : constant POSIX.file_position := seek(the_stream.fd, 0, from_end);
   217.       there : constant POSIX.file_position := seek(the_stream.fd, here, from_start);
   218.    begin
   219.       if here /= there then
   220.          diagnose(the_stream, "FILE_SIZE: seek failure");
   221.       end if;
   222.       return Natural(size);
   223.    end file_size;
   224.
   225.    function column (the_stream : host_IO.stream)
   226.    return Natural
   227.    is (the_stream.column);
   228.
   229.    procedure get_position (position   : out Natural;
   230.                            the_stream : in out host_IO.stream) is
   231.    begin
   232.       flush(the_stream);
   233.       position := the_stream.position;
   234.    end get_position;
   235.
   236.    function buffer_is_empty (the_stream : host_IO.stream)
   237.    return Boolean
   238.    is (not the_stream.is_open or else the_stream.next_byte >= the_stream.block_size);
   239.
   240.    function buffer_is_full (the_stream : host_IO.stream)
   241.    return Boolean
   242.    is (the_stream.is_open and then the_stream.next_byte = the_stream.buffer'Last);
   243.
   244.    procedure set_position (position   : in Natural;
   245.                            the_stream : in out host_IO.stream;
   246.                            whence     : in POSIX.seek_origin := from_start) is
   247.       response : POSIX.file_position;
   248.    begin
   249.       flush(the_stream);
   250.       response := seek(the_stream.fd, POSIX.file_position(position), whence);
   251.       pragma Unreferenced(response);
   252.       the_stream.position := position;
   253.    exception
   254.       when error : others =>
   255.          diagnose(the_stream, "SET_POSITION: " & Ada.Exceptions.Exception_Message(error));
   256.    end set_position;
   257.
   258.    procedure clear (the_stream : in out host_IO.stream) is
   259.    begin
   260.       the_stream.next_byte := 0;
   261.       the_stream.block_size := 0;
   262.    end clear;
   263.
   264.    procedure reset (the_stream : in out host_IO.stream) is
   265.    begin
   266.       flush(the_stream);
   267.       if the_stream.is_open then
   268.          the_stream.last_IO := read_mode;
   269.          the_stream.position := 0;
   270.          the_stream.next_byte := 0;
   271.          the_stream.block_size := 0;
   272.       end if;
   273.    end reset;
   274.
   275.    procedure back_off (the_stream : in out host_IO.stream) is
   276.    begin
   277.       if the_stream.is_open                   and then
   278.             the_stream.next_byte > 0          and then
   279.                the_stream.last_IO = read_mode     then
   280.          the_stream.next_byte := the_stream.next_byte - 1;
   281.          the_stream.position := the_stream.position - 1;
   282.       else
   283.          diagnose(the_stream, "cannot back_off");
   284.       end if;
   285.    end back_off;
   286.
   287.    procedure get_byte (char       : out Character;
   288.                        the_stream : in out host_IO.stream) is
   289.       response : Integer;
   290.    begin
   291.       if not the_stream.is_open then
   292.          raise end_of_stream;
   293.       end if;
   294.       if buffer_is_empty(the_stream) then
   295.          response := read(the_stream.fd, the_stream.buffer, the_stream.buffer'Size);
   296.          the_stream.block_size := response;
   297.          if response <= 0 then
   298.             raise end_of_stream;
   299.          end if;
   300.          the_stream.next_byte := 0;
   301.       end if;
   302.       the_stream.next_byte := the_stream.next_byte + 1;
   303.       the_stream.position := the_stream.position + 1;
   304.       the_stream.bytes_moved := the_stream.bytes_moved + 1;
   305.       the_stream.last_IO := read_mode;
   306.       char := the_stream.buffer(the_stream.next_byte);
   307.       if char = LF then
   308.          the_stream.column := 0;
   309.       else
   310.          the_stream.column := the_stream.column + 1;
   311.       end if;
   312.    exception
   313.       when end_of_stream =>
   314.          raise;
   315.       when POSIX_IO_error =>
   316.          diagnose(the_stream, "GET_BYTE: POSIX_IO_error");
   317.       when error : others =>
   318.          diagnose(the_stream, Ada.Exceptions.Exception_Message(error));
   319.    end get_byte;
   320.
   321.    procedure get_bytes (the_string : out String;
   322.                         the_stream : in out host_IO.stream;
   323.                         uncounted  : in Boolean := True) is
   324.       old_bytes_moved : constant KDF9.word := the_stream.bytes_moved;
   325.    begin
   326.       for b of the_string loop
   327.          get_byte(b, the_stream);
   328.       end loop;
   329.       if uncounted then
   330.          the_stream.bytes_moved := old_bytes_moved;
   331.       end if;
   332.    end get_bytes;
   333.
   334.    procedure get_char (char       : out Character;
   335.                        the_stream : in out host_IO.stream) is
   336.    begin
   337.       get_byte(char, the_stream);
   338.       if char = CR then
   339.          char := LF;
   340.          the_stream.last_char := CR;
   341.       elsif char = LF and the_stream.last_char = CR then
   342.          the_stream.last_char := LF;
   343.          get_byte(char, the_stream);
   344.       else
   345.          the_stream.last_char := char;
   346.       end if;
   347.    end get_char;
   348.
   349.    procedure peek_at_char (char       : out Character;
   350.                            the_stream : in out host_IO.stream) is
   351.    begin
   352.       get_char(char, the_stream);
   353.       back_off(the_stream);
   354.    end peek_at_char;
   355.
   356.    -- put_escape_code writes directly to the stream's device, avoiding the stream's buffers.
   357.    procedure put_escape_code (the_string : in String;
   358.                               the_stream : in out host_IO.stream) is
   359.       response : Integer;
   360.    begin
   361.       if not the_stream.is_open then
   362.          raise end_of_stream;
   363.       end if;
   364.       response := write(the_stream.fd,
   365.                         the_string,
   366.                         the_string'Length);
   367.       if response <= 0 then
   368.          raise end_of_stream;
   369.       end if;
   370.    exception
   371.       when POSIX_IO_error =>
   372.          diagnose(the_stream, "PUT_ESCAPE_CODE: POSIX_IO_error");
   373.       when error : others =>
   374.          diagnose(the_stream, Ada.Exceptions.Exception_Message(error));
   375.    end put_escape_code;
   376.
   377.    procedure put_byte (char       : in Character;
   378.                        the_stream : in out host_IO.stream) is
   379.       response : Integer;
   380.    begin
   381.       if not the_stream.is_open then
   382.          raise end_of_stream;
   383.       end if;
   384.       if the_stream.buffer_is_full then
   385.          response := write(the_stream.fd,
   386.                            the_stream.buffer,
   387.                            the_stream.buffer'Size);
   388.          if response <= 0 then
   389.             raise end_of_stream;
   390.          end if;
   391.          the_stream.next_byte := 0;
   392.       end if;
   393.       the_stream.next_byte := the_stream.next_byte + 1;
   394.       the_stream.position := the_stream.position + 1;
   395.       the_stream.bytes_moved := the_stream.bytes_moved + 1;
   396.       the_stream.buffer(the_stream.next_byte) := char;
   397.       the_stream.last_IO := write_mode;
   398.       if char = LF then
   399.          the_stream.column := 0;
   400.       else
   401.          the_stream.column := the_stream.column + 1;
   402.       end if;
   403.    exception
   404.       when POSIX_IO_error =>
   405.          diagnose(the_stream, "PUT_BYTE: POSIX_IO_error");
   406.       when error : others =>
   407.          diagnose(the_stream, Ada.Exceptions.Exception_Message(error));
   408.    end put_byte;
   409.
   410.    procedure do_not_put_byte (char       : in Character;
   411.                               the_stream : in out host_IO.stream) is
   412.    begin
   413.       if not the_stream.is_open then
   414.          raise end_of_stream;
   415.       end if;
   416.       the_stream.bytes_moved := the_stream.bytes_moved + 1;
   417.       the_stream.last_IO := write_mode;
   418.       if char = LF then
   419.          the_stream.column := 0;
   420.       else
   421.          the_stream.column := the_stream.column + 1;
   422.       end if;
   423.    exception
   424.       when error : others =>
   425.          diagnose(the_stream, Ada.Exceptions.Exception_Message(error));
   426.    end do_not_put_byte;
   427.
   428.    procedure put_bytes (the_string : in String;
   429.                         the_stream : in out host_IO.stream;
   430.                         uncounted  : in Boolean := True) is
   431.       old_bytes_moved : constant KDF9.word := the_stream.bytes_moved;
   432.    begin
   433.       for c of the_string loop
   434.          put_byte(c, the_stream);
   435.       end loop;
   436.       if uncounted then
   437.          the_stream.bytes_moved := old_bytes_moved;
   438.       end if;
   439.    end put_bytes;
   440.
   441.    procedure put_EOL (the_stream : in out host_IO.stream;
   442.                       uncounted  : in Boolean := True) is
   443.    begin
   444.       put_bytes(NL, the_stream, uncounted);
   445.    end put_EOL;
   446.
   447.    procedure put_char (char       : in Character;
   448.                        the_stream : in out host_IO.stream) is
   449.    begin
   450.       if char = LF then
   451.          put_EOL(the_stream, uncounted => False);
   452.       else
   453.          put_byte(char, the_stream);
   454.       end if;
   455.    end put_char;
   456.
   457.    procedure put_chars (the_string : in String;
   458.                         the_stream : in out host_IO.stream) is
   459.    begin
   460.       for c of the_string loop
   461.          put_char(c, the_stream);
   462.       end loop;
   463.    end put_chars;
   464.
   465.    function contents (the_stream : host_IO.stream)
   466.    return String is
   467.    begin
   468.       return the_stream.buffer(1..the_stream.next_byte);
   469.    end contents;
   470.
   471.    procedure inject (the_string : in String;
   472.                      the_stream : in out host_IO.stream) is
   473.       the_length : constant Natural := the_string'Length;
   474.    begin
   475.       if not the_stream.is_open then
   476.          diagnose(the_stream,
   477.                   NL
   478.                 & "injecting:"
   479.                 & NL
   480.                 & the_string
   481.                 & NL
   482.                 & "into the closed "
   483.                 & the_stream.base_name
   484.                  );
   485.       end if;
   486.       if the_length + 1 > IO_buffer_size then
   487.          diagnose(the_stream,
   488.                   NL
   489.                 & "injecting a string of excessive length ="
   490.                 & the_length'Image
   491.                 & " into the stream "
   492.                 & the_stream.base_name
   493.                  );
   494.       elsif the_length > 0 then
   495.          the_stream.block_size := the_length + 1;
   496.          the_stream.buffer(1 .. the_length) := the_string;
   497.          the_stream.buffer(the_length + 1)  := LF;
   498.       else
   499.          diagnose(the_stream,
   500.                   NL
   501.                 & "injecting a string of length = 0 into the stream "
   502.                 & the_stream.base_name
   503.                  );
   504.       end if;
   505.    end inject;
   506.
   507. end host_IO;

Compiling: ../Source/host_io.ads
Source file time stamp: 2021-01-10 23:52:36
Compiled at: 2021-02-08 17:20:59

     1. -- Buffered I/O streams to support KDF9 device I/O.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18. with POSIX;
    19.
    20. use  KDF9;
    21. use  POSIX;
    22.
    23. package host_IO is
    24.
    25.    stream_IO_error, end_of_stream : exception;
    26.
    27.    type stream is tagged limited private;
    28.
    29.    function image_of (the_stream : host_IO.stream;
    30.                       caption    : String := "")
    31.    return String
    32.       with Inline => False;
    33.
    34.    function fd_of (the_stream : host_IO.stream)
    35.    return Natural;
    36.
    37.    -- Open a stream with an established fd.
    38.    procedure open (the_stream : in out host_IO.stream;
    39.                    file_name  : in String;
    40.                    mode       : in POSIX.access_mode;
    41.                    fd         : in Integer);
    42.
    43.    -- Open a base file then use its fd to open a stream.
    44.    procedure open (the_stream : in out host_IO.stream;
    45.                    file_name  : in String;
    46.                    mode       : in POSIX.access_mode);
    47.
    48.    procedure truncate (the_stream : in out host_IO.stream;
    49.                        to_length  : in KDF9.word := 0);
    50.
    51.    procedure close (the_stream : in out host_IO.stream);
    52.
    53.    procedure flush (the_stream  : in out host_IO.stream;
    54.                     a_byte_time : in KDF9.us := 0);
    55.
    56.    -- Reassign an open stream to another file.
    57.    procedure reattach (the_stream : in out host_IO.stream;
    58.                        file_name  : in String;
    59.                        mode       : in POSIX.access_mode);
    60.
    61.    function is_open(the_stream : host_IO.stream)
    62.    return Boolean;
    63.
    64.    function bytes_moved(the_stream : host_IO.stream)
    65.    return KDF9.word;
    66.
    67.    function file_size (the_stream : host_IO.stream)
    68.    return Natural;
    69.
    70.    function column (the_stream : host_IO.stream)
    71.    return Natural;
    72.
    73.    procedure get_position (position   : out Natural;
    74.                            the_stream : in out host_IO.stream);
    75.
    76.    procedure set_position (position   : in Natural;
    77.                            the_stream : in out host_IO.stream;
    78.                            whence     : in POSIX.seek_origin := from_start);
    79.
    80.    procedure clear (the_stream : in out host_IO.stream);
    81.
    82.    procedure reset (the_stream : in out host_IO.stream);
    83.
    84.    procedure back_off (the_stream : in out host_IO.stream)
    85.       with Inline;
    86.
    87.    procedure get_byte (char       : out Character;
    88.                        the_stream : in out host_IO.stream);
    89.
    90.    -- get_bytes iterates get_byte over the_string, for convenience.
    91.    -- If uncounted then the output is not included in the_stream.bytes_moved.
    92.    procedure get_bytes (the_string : out String;
    93.                         the_stream : in out host_IO.stream;
    94.                         uncounted  : in Boolean := True);
    95.
    96.    -- True iff the last get_byte obtained a LF.
    97.    function a_LF_was_just_read (the_stream : host_IO.stream)
    98.    return Boolean;
    99.
   100.    -- get_char differs from get_byte in the treatment of line terminators.
   101.    -- CR, LF, and CRLF are all returned as a single LF character, so catering
   102.    --    for old MacOS, MSDOS, and macOS/UNIX/Linux external text-file formats.
   103.    procedure get_char (char       : out Character;
   104.                        the_stream : in out host_IO.stream);
   105.
   106.    -- peek_at_char uses get_char to inspect the next char to be delivered,
   107.    --    then invokes back_off so that it is left in the input stream.
   108.    procedure peek_at_char (char       : out Character;
   109.                            the_stream : in out host_IO.stream);
   110.
   111.    -- do_not_put_byte does the same as put_byte, except for actually writing it to the_stream.
   112.    procedure do_not_put_byte (char       : in Character;
   113.                               the_stream : in out host_IO.stream);
   114.
   115.    procedure put_byte (char       : in Character;
   116.                        the_stream : in out host_IO.stream);
   117.
   118.    -- put_escape_code writes directly to the stream's device, avoiding the stream's buffers.
   119.    procedure put_escape_code (the_string : in String;
   120.                               the_stream : in out host_IO.stream);
   121.
   122.    -- put_bytes iterates put_byte over the_string, for convenience.
   123.    -- If uncounted then the output is not included in the_stream.bytes_moved.
   124.    procedure put_bytes (the_string : in String;
   125.                         the_stream : in out host_IO.stream;
   126.                         uncounted  : in Boolean := True);
   127.
   128.    -- put_EOL writes the host-appropriate line terminator (CRLF, or just LF)
   129.    procedure put_EOL (the_stream : in out host_IO.stream;
   130.                       uncounted  : in Boolean := True);
   131.
   132.    -- put_char differs from put_byte only in the treatment of line terminators.
   133.    -- If char is LF, then put_EOL is used to output a host-appropriate line terminator.
   134.    procedure put_char (char       : in Character;
   135.                        the_stream : in out host_IO.stream);
   136.
   137.    -- put_chars iterates put_bytes over the_string, for convenience.
   138.    procedure put_chars (the_string : in String;
   139.                         the_stream : in out host_IO.stream);
   140.
   141.    -- True iff the last put_byte wrote out a LF.
   142.    function a_LF_was_just_written (the_stream : host_IO.stream)
   143.    return Boolean;
   144.
   145.    function buffer_is_empty (the_stream : host_IO.stream)
   146.    return Boolean
   147.       with Inline;
   148.
   149.    function buffer_is_full (the_stream : host_IO.stream)
   150.    return Boolean
   151.       with Inline;
   152.
   153.    -- Return the currently buffered output as a single string.
   154.    function contents (the_stream : host_IO.stream)
   155.    return String;
   156.
   157.    -- Make the_string appear to be input for the_stream (which must be empty).
   158.    procedure inject (the_string : in String;
   159.                      the_stream : in out host_IO.stream);
   160.
   161. private
   162.
   163.    -- N.B. in host_IO the term 'buffer' is used conventionally.
   164.    -- It does NOT refer to a KDF9 DMA channel.
   165.
   166.    -- IO_buffer_size is enough for a complete FD sector, lacking any better criterion.
   167.    IO_buffer_size : constant Positive := 320;
   168.
   169.    type stream is tagged limited
   170.       record
   171.          base_name   : String (1 .. 3) := "???";
   172.          is_open     : Boolean := False;
   173.          last_char   : Character := ' ';
   174.          block_size,
   175.          next_byte,
   176.          saved_size,
   177.          position,
   178.          column      : Natural := 0;
   179.          bytes_moved : KDF9.word := 0;
   180.          fd          : Natural := Natural'Last;
   181.          IO_mode     : POSIX.access_mode range read_mode .. rd_wr_mode;
   182.          last_IO     : POSIX.access_mode range read_mode .. write_mode;
   183.          buffer,
   184.          look_behind : String(1 .. IO_buffer_size);
   185.       end record;
   186.
   187. end host_IO;

 507 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-store.adb
Source file time stamp: 2021-01-23 17:24:23
Compiled at: 2021-02-08 17:20:59

     1. -- KDF9 core store operations.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Unchecked_Conversion;
    18. --
    19. with formatting;
    20. with KDF9.CPU;
    21.
    22. use formatting;
    23. use  KDF9.CPU;
    24.
    25. package body KDF9.store is
    26.
    27.    -- diagnose_invalid_address avoids secondary stack usage in the address validation procedures.
    28.    procedure diagnose_invalid_address (message : in String; address : in KDF9.word)
    29.       with Inline => False;
    30.
    31.    procedure diagnose_invalid_address (message : in String; address : in KDF9.word) is
    32.    begin
    33.       trap_illegal_instruction(message & " =" & address'Image);
    34.    end diagnose_invalid_address;
    35.
    36.    -- Check that EA, EA+BA are valid; LIV if invalid.
    37.    procedure validate_virtual_and_real_addresses (EA : in KDF9.Q_part)
    38.       with Inline;
    39.
    40.    procedure validate_virtual_and_real_addresses (EA : in KDF9.Q_part) is
    41.       PA : constant KDF9.word := (KDF9.word(EA) + KDF9.word(BA)) and Q_part_mask;
    42.    begin
    43.       if EA > NOL and then the_CPU_state = program_state then
    44.          diagnose_invalid_address("NOL < virtual address", KDF9.word(EA));
    45.       end if;
    46.       if PA > max_address and then the_CPU_state = program_state then
    47.          diagnose_invalid_address("32K-1 < physical address", PA);
    48.       end if;
    49.    end validate_virtual_and_real_addresses;
    50.
    51.    procedure if_user_mode_then_LOV (address_1 : KDF9.Q_part;
    52.                                     address_2 : KDF9.Q_part := 0;
    53.                                     solo      : Boolean     := True) is
    54.    begin
    55.       LOV_if_user_mode(
    56.                        if solo
    57.                        then "at #" & oct_of(address_1) & " (E" & dec_of(address_1) & ")"
    58.                        else "in #" & oct_of(address_1) & "/#" & oct_of(address_2)
    59.                       );
    60.    end if_user_mode_then_LOV;
    61.
    62.    function group (PA : KDF9.Q_part)
    63.    return KDF9.Q_part
    64.    is (PA / group_size);
    65.
    66.    procedure check_address_and_lockout (EA : in KDF9.Q_part) is
    67.       PA : constant KDF9.Q_part := EA + BA;
    68.    begin
    69.       validate_virtual_and_real_addresses(EA);
    70.       if locked_out(group(PA)) then
    71.          the_locked_out_address := PA;
    72.          if the_CPU_state /= Director_state then
    73.             if_user_mode_then_LOV(PA);
    74.          end if;
    75.       end if;
    76.    end check_address_and_lockout;
    77.
    78.    procedure validate_address_range (EA1, EA2 : in KDF9.Q_part) is
    79.    begin
    80.       validate_virtual_and_real_addresses(EA1);
    81.       validate_virtual_and_real_addresses(EA2);
    82.       if EA1 > EA2 then
    83.          diagnose_invalid_address("initial address > final address", KDF9.word(EA2));
    84.       end if;
    85.    end validate_address_range;
    86.
    87.    procedure check_addresses_and_lockouts (EA1, EA2 : in KDF9.Q_part) is
    88.        PA1 : constant KDF9.Q_part := EA1 + BA;
    89.        PA2 : constant KDF9.Q_part := EA2 + BA;
    90.    begin
    91.       validate_address_range (EA1, EA2);
    92.
    93.       if there_are_locks_in_physical_addresses(KDF9.Q_register'(C => 0, I => PA1, M => PA2)) then
    94.          if the_CPU_state /= Director_state then
    95.             if_user_mode_then_LOV(PA1, PA2, solo => False);
    96.          end if;
    97.       end if;
    98.    end check_addresses_and_lockouts;
    99.
   100.    -- Check that A1+A2 is valid; trap if it is invalid.
   101.    function valid_word_address (A1, A2 : in KDF9.Q_part)
   102.    return KDF9.address is
   103.       V : constant KDF9.word := (KDF9.word(A1) + KDF9.word(A2)) and Q_part_mask;
   104.    begin
   105.       if V > max_address then
   106.          diagnose_invalid_address("32K-1 < virtual address", V);
   107.       end if;
   108.       return KDF9.address(V);
   109.    end valid_word_address;
   110.
   111.    function signed is new Ada.Unchecked_Conversion (KDF9.Q_part, CPU.signed_Q_part);
   112.    function design is new Ada.Unchecked_Conversion (CPU.signed_Q_part, KDF9.Q_part);
   113.
   114.    -- Check that A1+A2/2 is valid; trap if it is invalid.  A2 must be treated as a signed number.
   115.    function valid_halfword_address (A1, A2 : in KDF9.Q_part)
   116.    return KDF9.address is
   117.       V : constant KDF9.word := (KDF9.word(A1) + KDF9.word(design(signed(A2)/2))) and Q_part_mask;
   118.    begin
   119.       if V > max_address then
   120.          diagnose_invalid_address("32K-1 < virtual address", V);
   121.       end if;
   122.       return KDF9.address(V);
   123.    end valid_halfword_address;
   124.
   125.    function fetch_symbol (EA : KDF9.address; index : KDF9_char_sets.symbol_index)
   126.    return KDF9_char_sets.symbol
   127.    is (KDF9_char_sets.symbol(shift_word_right(core(EA+BA), 42 - 6*Natural(index)) and 8#77#));
   128.
   129.    procedure store_symbol (value : in KDF9_char_sets.symbol;
   130.                            EA    : in KDF9.address;
   131.                            index : in KDF9_char_sets.symbol_index) is
   132.       place  : constant Natural   := 42 - 6*Natural(index);
   133.       mask   : constant KDF9.word := not shift_word_left(8#77#, place);
   134.       symbol : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   135.    begin
   136.       core(EA+BA) := (core(EA+BA) and mask) or symbol;
   137.    end store_symbol;
   138.
   139.    function fetch_octet (EA : KDF9.address; index : KDF9_char_sets.octet_index)
   140.    return KDF9_char_sets.octet is
   141.       place : constant Natural := 40 - 8*Natural(index);
   142.    begin
   143.       return KDF9_char_sets.octet(shift_word_right(core(EA+BA), place) and 8#377#);
   144.    end fetch_octet;
   145.
   146.    procedure store_octet  (value : in KDF9_char_sets.octet;
   147.                            EA    : in KDF9.address;
   148.                            index : in KDF9_char_sets.octet_index) is
   149.       place : constant Natural   := 40 - 8*Natural(index);
   150.       octet : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   151.       mask  : constant KDF9.word := not shift_word_left(8#377#, place);
   152.    begin
   153.       core(EA+BA) := (core(EA+BA) and mask) or octet;
   154.    end store_octet;
   155.
   156.    function fetch_syllable (EA : KDF9.syllable_address)
   157.    return KDF9.syllable is
   158.       address : constant KDF9.address := Q_part(EA.order_word_number) + BA;
   159.       place   : constant Natural      := 40 - 8*Natural(EA.syllable_index);
   160.    begin
   161.       return KDF9.syllable(shift_word_right(core(address), place) and 8#377#);
   162.    end fetch_syllable;
   163.
   164.    procedure store_syllable (value : in KDF9.syllable;
   165.                              EA    : in KDF9.address;
   166.                              index : in KDF9.syllable_index) is
   167.       place    : constant Natural   := 40 - 8*Natural(index);
   168.       syllable : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   169.       mask     : constant KDF9.word := not shift_word_left(8#377#, place);
   170.    begin
   171.       core(EA+BA) := (core(EA+BA) and mask) or syllable;
   172.    end store_syllable;
   173.
   174.    function fetch_halfword (EA : KDF9.address; index : KDF9.halfword_number)
   175.    return KDF9.word
   176.    is (shift_word_left(shift_word_right(core(EA+BA), 24 - 24*Natural(index)), 24));
   177.
   178.    procedure store_halfword (value : in KDF9.word;
   179.                              EA    : in KDF9.address;
   180.                              index : in KDF9.halfword_number) is
   181.       place   : constant Natural   := 24 - 24*Natural(index);
   182.       half    : constant KDF9.word := shift_word_left(shift_word_right(value, 24), place);
   183.       mask    : constant KDF9.word := not shift_word_left(halfword_mask, place);
   184.    begin
   185.       core(EA+BA) := (core(EA+BA) and mask) or half;
   186.    end store_halfword;
   187.
   188.    function fetch_word (EA : KDF9.address)
   189.    return KDF9.word
   190.    is (core(EA+BA));
   191.
   192.    procedure store_word (value : in KDF9.word; EA : in KDF9.address) is
   193.    begin
   194.       core(EA+BA) := value;
   195.    end store_word;
   196.
   197.    function there_are_locks_in_relative_addresses (Q : KDF9.Q_register)
   198.    return Boolean is
   199.    begin
   200.       validate_address_range (Q.I, Q.M);
   201.       return there_are_locks_in_physical_addresses((0, Q.I+BA, Q.M+BA));
   202.    end there_are_locks_in_relative_addresses;
   203.
   204.    function there_are_locks_in_physical_addresses (Q : KDF9.Q_register)
   205.    return Boolean is
   206.    begin
   207.       for g in group(Q.I) .. group(Q.M) loop
   208.          if locked_out(g) then
   209.             the_locked_out_address := g * group_size;
   210.             return True;
   211.          end if;
   212.       end loop;
   213.       return False;
   214.    end there_are_locks_in_physical_addresses;
   215.
   216.    function is_unlocked (G : KDF9.store.group_address)
   217.    return Boolean is
   218.    begin
   219.       return not locked_out(KDF9.Q_part(G));
   220.    end is_unlocked;
   221.
   222.    procedure lock_out_relative_addresses (Q : in KDF9.Q_register) is
   223.    begin
   224.       validate_address_range (Q.I, Q.M);
   225.       lock_out_absolute_addresses((0, Q.I+BA, Q.M+BA));
   226.    end lock_out_relative_addresses;
   227.
   228.    procedure lock_out_absolute_addresses (Q : in KDF9.Q_register) is
   229.    begin
   230.       for g in group(Q.I) .. group(Q.M) loop
   231.          locked_out(g) := True;
   232.       end loop;
   233.    end lock_out_absolute_addresses;
   234.
   235.    procedure unlock_absolute_addresses (Q : in KDF9.Q_register) is
   236.    begin
   237.       for g in group(Q.I) .. group(Q.M) loop
   238.          locked_out(g) := False;
   239.       end loop;
   240.    end unlock_absolute_addresses;
   241.
   242. end KDF9.store;

Compiling: ../Source/kdf9-store.ads
Source file time stamp: 2021-01-10 23:52:38
Compiled at: 2021-02-08 17:20:59

     1. -- KDF9 core store operations.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18.
    19. use  KDF9_char_sets;
    20.
    21. package KDF9.store is
    22.
    23.    --
    24.    -- Relative addresses may be either virtual or physical.
    25.    -- Virtual addresses are generated by problem programs and must be relativized by adding BA.
    26.    -- These addresses must also be validated to ensure they do not breach store limits.
    27.    -- Physical "relative" addresses are generated by Director, when BA is guaranteed to be 0,
    28.    --   so it has no effect, thus allowing the relative address routines to be used.
    29.    --
    30.    -- Absolute addresses are generated by I/O Control, which may be doing a transfer for either
    31.    --   a Director or a problem program, and must therefore ensure that BA is not added.
    32.    --
    33.
    34.    --
    35.    -- Parameters named EA are Effective "relative" Addresses.
    36.    --
    37.
    38.    function fetch_symbol (EA : KDF9.address; index : KDF9_char_sets.symbol_index)
    39.    return KDF9_char_sets.symbol;
    40.
    41.    function fetch_octet (EA : KDF9.address; index : KDF9_char_sets.octet_index)
    42.    return KDF9_char_sets.octet
    43.       with Inline;
    44.
    45.    function fetch_syllable (EA : KDF9.syllable_address)
    46.    return KDF9.syllable
    47.       with Inline;
    48.
    49.    function fetch_halfword (EA : KDF9.address; index : KDF9.halfword_number)
    50.    return KDF9.word
    51.       with Inline;
    52.
    53.    function fetch_word (EA : KDF9.address)
    54.    return KDF9.word
    55.       with Inline;
    56.
    57.    procedure store_symbol (value : in KDF9_char_sets.symbol;
    58.                            EA    : in KDF9.address;
    59.                            index : in KDF9_char_sets.symbol_index)
    60.       with Inline;
    61.
    62.    procedure store_octet  (value : in KDF9_char_sets.octet;
    63.                            EA    : in KDF9.address;
    64.                            index : in KDF9_char_sets.octet_index)
    65.       with Inline;
    66.
    67.    procedure store_syllable (value : in KDF9.syllable;
    68.                              EA    : in KDF9.address;
    69.                              index : in KDF9.syllable_index)
    70.       with Inline;
    71.
    72.    procedure store_halfword (value : in KDF9.word;
    73.                              EA    : in KDF9.address;
    74.                              index : in KDF9.halfword_number)
    75.       with Inline;
    76.
    77.    procedure store_word (value : in KDF9.word; EA : in KDF9.address)
    78.       with Inline;
    79.
    80.    -- Check that A1+A2 is a valid word address; LIV if it is invalid.
    81.    function valid_word_address (A1, A2 : in KDF9.Q_part)
    82.    return KDF9.address
    83.       with Inline;
    84.
    85.    -- Check that A1+A2/2 is valid; LIV if it is invalid.  A2 is treated as a signed number.
    86.    function valid_halfword_address (A1, A2 : in KDF9.Q_part)
    87.    return KDF9.address
    88.       with Inline;
    89.
    90.    -- If a store access is locked out, its physical address is left here.
    91.    the_locked_out_address : KDF9.Q_part;
    92.
    93.    procedure if_user_mode_then_LOV (address_1 : KDF9.Q_part;
    94.                                     address_2 : KDF9.Q_part := 0;
    95.                                     solo      : Boolean     := True)
    96.       with Inline => False;
    97.
    98.    -- Check EA and lockout for EA.
    99.    procedure check_address_and_lockout (EA : in KDF9.Q_part)
   100.       with Inline;
   101.
   102.    -- Check that EA1, EA2, EA1+BA, EA2+BA are valid, and EA1 <= EA2.
   103.    --    LIV in any invalid case.
   104.    procedure validate_address_range (EA1, EA2 : in KDF9.Q_part);
   105.
   106.    -- Check EA1, EA2, and lockouts for EA1+BA .. EA2+BA.
   107.    procedure check_addresses_and_lockouts (EA1, EA2 : in KDF9.Q_part);
   108.
   109.    function there_are_locks_in_relative_addresses (Q : KDF9.Q_register)
   110.    return Boolean;
   111.
   112.    function there_are_locks_in_physical_addresses (Q : KDF9.Q_register)
   113.    return Boolean;
   114.
   115.    procedure lock_out_relative_addresses (Q : in KDF9.Q_register);
   116.
   117.    procedure lock_out_absolute_addresses (Q : in KDF9.Q_register);
   118.
   119.    procedure unlock_absolute_addresses (Q : in KDF9.Q_register);
   120.
   121.    -- The maximum size KDF9 core store has 32Kibiwords.
   122.    max_address   : constant := 2**15 - 1;
   123.
   124.    -- The group size of 32 words is 1 physical core allocation unit and physical lockout unit.
   125.    group_size : constant := 32;
   126.
   127.    type group_address is mod 1024;
   128.
   129.     -- is_unlocked yields True if the designated group is NOT locked out.
   130.    function is_unlocked (G : KDF9.store.group_address)
   131.    return Boolean;
   132.
   133.    function group (PA : KDF9.Q_part)
   134.    return KDF9.Q_part
   135.       with Inline;
   136.
   137. private
   138.
   139.    type word_array is array (KDF9.Q_part range <>) of KDF9.word
   140.       with Component_Size => 64, Convention => C;
   141.
   142.    -- The core store of KDF9.  Must be zeroized before loading any software.
   143.    core : word_array (KDF9.Q_part range 0 .. max_address) := (others => 0);
   144.
   145.    -- The lockout store has one bit for every group_size words.
   146.    last_lockout : constant := max_address / group_size;
   147.    locked_out   : array (KDF9.Q_part range 0 .. last_lockout) of Boolean := (others => False);
   148.
   149. end KDF9.store;

 242 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-absent.adb
Source file time stamp: 2021-02-07 23:50:40
Compiled at: 2021-02-08 17:20:59

     1. -- Handle attempted usage of a buffer with No Device attached.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with formatting;
    18.
    19. use formatting;
    20.
    21. package body IOC.absent is
    22.
    23.    procedure disavow (the_device  : in out absent.device;
    24.                       Q_operand   : in KDF9.Q_register;
    25.                       set_offline : in Boolean) is
    26.       pragma Unreferenced(the_device);
    27.       pragma Unreferenced(set_offline);
    28.    begin
    29.       trap_operator_error("buffer #" & oct_of(Q_operand.C and 8#17#, 2) & " has no I/O device");
    30.    end disavow;
    31.
    32.    overriding
    33.    procedure PIA (the_device  : in out absent.device;
    34.                   Q_operand   : in KDF9.Q_register;
    35.                   set_offline : in Boolean) is
    36.    begin disavow(the_device, Q_operand, set_offline); end PIA;
    37.
    38.    overriding
    39.    procedure PIB (the_device  : in out absent.device;
    40.                   Q_operand   : in KDF9.Q_register;
    41.                   set_offline : in Boolean) is
    42.    begin disavow(the_device, Q_operand, set_offline); end PIB;
    43.
    44.    overriding
    45.    procedure PIC (the_device  : in out absent.device;
    46.                   Q_operand   : in KDF9.Q_register;
    47.                   set_offline : in Boolean) is
    48.    begin disavow(the_device, Q_operand, set_offline); end PIC;
    49.
    50.    overriding
    51.    procedure PID (the_device  : in out absent.device;
    52.                   Q_operand   : in KDF9.Q_register;
    53.                   set_offline : in Boolean) is
    54.    begin disavow(the_device, Q_operand, set_offline); end PID;
    55.
    56.    overriding
    57.    procedure PIE (the_device  : in out absent.device;
    58.                   Q_operand   : in KDF9.Q_register;
    59.                   set_offline : in Boolean) is
    60.    begin disavow(the_device, Q_operand, set_offline); end PIE;
    61.
    62.    overriding
    63.    procedure PIF (the_device  : in out absent.device;
    64.                   Q_operand   : in KDF9.Q_register;
    65.                   set_offline : in Boolean) is
    66.    begin disavow(the_device, Q_operand, set_offline); end PIF;
    67.
    68.    overriding
    69.    procedure PIG (the_device  : in out absent.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean) is
    72.    begin disavow(the_device, Q_operand, set_offline); end PIG;
    73.
    74.    overriding
    75.    procedure PIH (the_device  : in out absent.device;
    76.                   Q_operand   : in KDF9.Q_register;
    77.                   set_offline : in Boolean) is
    78.    begin disavow(the_device, Q_operand, set_offline); end PIH;
    79.
    80.    overriding
    81.    procedure PMA (the_device  : in out absent.device;
    82.                   Q_operand   : in KDF9.Q_register;
    83.                   set_offline : in Boolean) is
    84.    begin disavow(the_device, Q_operand, set_offline); end PMA;
    85.
    86.    overriding
    87.    procedure PMB (the_device  : in out absent.device;
    88.                   Q_operand   : in KDF9.Q_register;
    89.                   set_offline : in Boolean) is
    90.    begin disavow(the_device, Q_operand, set_offline); end PMB;
    91.
    92.    overriding
    93.    procedure PMC (the_device  : in out absent.device;
    94.                   Q_operand   : in KDF9.Q_register;
    95.                   set_offline : in Boolean) is
    96.    begin disavow(the_device, Q_operand, set_offline); end PMC;
    97.    overriding
    98.    procedure PMD (the_device  : in out absent.device;
    99.                   Q_operand   : in KDF9.Q_register;
   100.                   set_offline : in Boolean) is
   101.    begin disavow(the_device, Q_operand, set_offline); end PMD;
   102.
   103.    overriding
   104.    procedure PME (the_device  : in out absent.device;
   105.                   Q_operand   : in KDF9.Q_register;
   106.                   set_offline : in Boolean) is
   107.    begin disavow(the_device, Q_operand, set_offline); end PME;
   108.
   109.    overriding
   110.    procedure PMF (the_device  : in out absent.device;
   111.                   Q_operand   : in KDF9.Q_register;
   112.                   set_offline : in Boolean) is
   113.    begin disavow(the_device, Q_operand, set_offline); end PMF;
   114.
   115.
   116.    overriding
   117.    procedure PMG (the_device  : in out absent.device;
   118.                   Q_operand   : in KDF9.Q_register;
   119.                   set_offline : in Boolean) is
   120.    begin disavow(the_device, Q_operand, set_offline); end PMG;
   121.
   122.    overriding
   123.    procedure PMK (the_device  : in out absent.device;
   124.                   Q_operand   : in KDF9.Q_register;
   125.                   set_offline : in Boolean) is
   126.    begin disavow(the_device, Q_operand, set_offline); end PMK;
   127.
   128.    overriding
   129.    procedure PML (the_device  : in out absent.device;
   130.                   Q_operand   : in KDF9.Q_register;
   131.                   set_offline : in Boolean) is
   132.    begin disavow(the_device, Q_operand, set_offline); end PML;
   133.
   134.    overriding
   135.    procedure POA (the_device  : in out absent.device;
   136.                   Q_operand   : in KDF9.Q_register;
   137.                   set_offline : in Boolean) is
   138.    begin disavow(the_device, Q_operand, set_offline); end POA;
   139.
   140.    overriding
   141.    procedure POB (the_device  : in out absent.device;
   142.                   Q_operand   : in KDF9.Q_register;
   143.                   set_offline : in Boolean) is
   144.    begin disavow(the_device, Q_operand, set_offline); end POB;
   145.
   146.    overriding
   147.    procedure POC (the_device  : in out absent.device;
   148.                   Q_operand   : in KDF9.Q_register;
   149.                   set_offline : in Boolean) is
   150.    begin disavow(the_device, Q_operand, set_offline); end POC;
   151.
   152.    overriding
   153.    procedure POD (the_device  : in out absent.device;
   154.                   Q_operand   : in KDF9.Q_register;
   155.                   set_offline : in Boolean) is
   156.    begin disavow(the_device, Q_operand, set_offline); end POD;
   157.
   158.    overriding
   159.    procedure POE (the_device  : in out absent.device;
   160.                   Q_operand   : in KDF9.Q_register;
   161.                   set_offline : in Boolean) is
   162.    begin disavow(the_device, Q_operand, set_offline); end POE;
   163.
   164.    overriding
   165.    procedure POF (the_device  : in out absent.device;
   166.                   Q_operand   : in KDF9.Q_register;
   167.                   set_offline : in Boolean) is
   168.    begin disavow(the_device, Q_operand, set_offline); end POF;
   169.
   170.    overriding
   171.    procedure POG (the_device  : in out absent.device;
   172.                   Q_operand   : in KDF9.Q_register;
   173.                   set_offline : in Boolean) is
   174.    begin disavow(the_device, Q_operand, set_offline); end POG;
   175.
   176.    overriding
   177.    procedure POH (the_device  : in out absent.device;
   178.                   Q_operand   : in KDF9.Q_register;
   179.                   set_offline : in Boolean) is
   180.    begin disavow(the_device, Q_operand, set_offline); end POH;
   181.
   182.    overriding
   183.    procedure POK (the_device  : in out absent.device;
   184.                   Q_operand   : in KDF9.Q_register;
   185.                   set_offline : in Boolean) is
   186.    begin disavow(the_device, Q_operand, set_offline); end POK;
   187.
   188.    overriding
   189.    procedure POL (the_device  : in out absent.device;
   190.                   Q_operand   : in KDF9.Q_register;
   191.                   set_offline : in Boolean) is
   192.    begin disavow(the_device, Q_operand, set_offline); end POL;
   193.
   194.
   195.    type AD_access is access absent.device;
   196.    AD_list         : array (IOC.unit_number) of AD_access with Warnings => Off;
   197.
   198.    unit : IOC.unit_number := 0;
   199.
   200.    procedure enable (b : in KDF9.buffer_number) is
   201.    begin
   202.       AD_list(unit) := new absent.device (number => b, kind => AD_kind, unit => unit, quantum => 0);
   203.       unit := unit + 1;
   204.    end enable;
   205.
   206. end IOC.absent;
   207.

Compiling: ../Source/ioc-absent.ads
Source file time stamp: 2021-01-11 02:50:01
Compiled at: 2021-02-08 17:20:59

     1. -- Handle attempted usage of a buffer with No Device attached.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.absent is
    18.
    19.    type device is new IOC.device with null record;
    20.
    21.    -- All the operations of an absent device terminate the run.
    22.
    23.    overriding
    24.    procedure PIA (the_device  : in out absent.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    overriding
    29.    procedure PIB (the_device  : in out absent.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    overriding
    34.    procedure PIC (the_device  : in out absent.device;
    35.                   Q_operand   : in KDF9.Q_register;
    36.                   set_offline : in Boolean);
    37.
    38.    overriding
    39.    procedure PID (the_device  : in out absent.device;
    40.                   Q_operand   : in KDF9.Q_register;
    41.                   set_offline : in Boolean);
    42.
    43.    overriding
    44.    procedure PIE (the_device  : in out absent.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    overriding
    49.    procedure PIF (the_device  : in out absent.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    overriding
    54.    procedure PIG (the_device  : in out absent.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    overriding
    59.    procedure PIH (the_device  : in out absent.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    overriding
    64.    procedure PMA (the_device  : in out absent.device;
    65.                   Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    overriding
    69.    procedure PMB (the_device  : in out absent.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean);
    72.
    73.    overriding
    74.    procedure PMC (the_device  : in out absent.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.    overriding
    78.    procedure PMD (the_device  : in out absent.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean);
    81.
    82.    overriding
    83.    procedure PME (the_device  : in out absent.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    overriding
    88.    procedure PMF (the_device  : in out absent.device;
    89.                   Q_operand   : in KDF9.Q_register;
    90.                   set_offline : in Boolean);
    91.
    92.    overriding
    93.    procedure PMG (the_device  : in out absent.device;
    94.                   Q_operand   : in KDF9.Q_register;
    95.                   set_offline : in Boolean);
    96.
    97.    overriding
    98.    procedure PMK (the_device  : in out absent.device;
    99.                   Q_operand   : in KDF9.Q_register;
   100.                   set_offline : in Boolean);
   101.
   102.    overriding
   103.    procedure PML (the_device  : in out absent.device;
   104.                   Q_operand   : in KDF9.Q_register;
   105.                   set_offline : in Boolean);
   106.
   107.    overriding
   108.    procedure POA (the_device  : in out absent.device;
   109.                   Q_operand   : in KDF9.Q_register;
   110.                   set_offline : in Boolean);
   111.
   112.    overriding
   113.    procedure POB (the_device  : in out absent.device;
   114.                   Q_operand   : in KDF9.Q_register;
   115.                   set_offline : in Boolean);
   116.
   117.    overriding
   118.    procedure POC (the_device  : in out absent.device;
   119.                   Q_operand   : in KDF9.Q_register;
   120.                   set_offline : in Boolean);
   121.
   122.    overriding
   123.    procedure POD (the_device  : in out absent.device;
   124.                   Q_operand   : in KDF9.Q_register;
   125.                   set_offline : in Boolean);
   126.
   127.    overriding
   128.    procedure POE (the_device  : in out absent.device;
   129.                   Q_operand   : in KDF9.Q_register;
   130.                   set_offline : in Boolean);
   131.
   132.    overriding
   133.    procedure POF (the_device  : in out absent.device;
   134.                   Q_operand   : in KDF9.Q_register;
   135.                   set_offline : in Boolean);
   136.
   137.    overriding
   138.    procedure POG (the_device  : in out absent.device;
   139.                   Q_operand   : in KDF9.Q_register;
   140.                   set_offline : in Boolean);
   141.
   142.    overriding
   143.    procedure POH (the_device  : in out absent.device;
   144.                   Q_operand   : in KDF9.Q_register;
   145.                   set_offline : in Boolean);
   146.
   147.    overriding
   148.    procedure POK (the_device  : in out absent.device;
   149.                   Q_operand   : in KDF9.Q_register;
   150.                   set_offline : in Boolean);
   151.
   152.    overriding
   153.    procedure POL (the_device  : in out absent.device;
   154.                   Q_operand   : in KDF9.Q_register;
   155.                   set_offline : in Boolean);
   156.
   157.    -- Register the absence of a device in case of future attempted access to buffer b.
   158.    procedure enable (b : in KDF9.buffer_number);
   159.
   160. end IOC.absent;

 207 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast.ads
Source file time stamp: 2021-01-10 23:52:37
Compiled at: 2021-02-08 17:20:59

     1. -- Emulation of the common functionality of a KDF9 "fast", i.e. word-by-word, devices.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast is
    18.
    19.    --
    20.    -- This is the root type for all fast I/O device types.
    21.    --
    22.
    23.    type device is abstract new IOC.device with private;
    24.
    25. private
    26.
    27.    type device is abstract new IOC.device with
    28.       record
    29.          switch_time,
    30.          latency_time,
    31.          elapsed_time  : KDF9.us := 0;
    32.          word_count,
    33.          switch_count,
    34.          latency_count : KDF9.word := 0;
    35.       end record;
    36.
    37. end IOC.fast;

 37 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-dr.adb
Source file time stamp: 2021-02-07 23:24:51
Compiled at: 2021-02-08 17:20:59

     1. -- Emulation of a drum store.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with formatting;
    18. with HCI;
    19.
    20. use  formatting;
    21. use  HCI;
    22.
    23. package body IOC.fast.DR is
    24.
    25.    use KDF9_char_sets;
    26.
    27.    function as_DR_command (Q_operand : KDF9.Q_register; for_OUT : Boolean := False)
    28.    return String is
    29.       C, sector, track, drive :KDF9.Q_part;
    30.    begin
    31.       if for_OUT then
    32.          -- There is no buffer number.
    33.          C := Q_operand.C;
    34.       else
    35.          -- Get rid of the buffer number.
    36.          C := Q_operand.C / 16;
    37.       end if;
    38.       drive := C mod drums_per_system;
    39.       C := C  /  drums_per_system;
    40.       sector := C mod sectors_per_track;
    41.       track  := C mod sectors_per_drum / sectors_per_track;
    42.       return "D"
    43.            & dec_of(drive)
    44.            & "T"
    45.            & dec_of(track)
    46.            & "S"
    47.            & dec_of(sector);
    48.    end as_DR_command;
    49.
    50.    -- The host_IO stream for DR0 is used only to open and close the file.
    51.    -- I/O operations for the DR0 file are done with unmediated POSIX system calls.
    52.
    53.    function file_offset (sector_number : DR.drum_index)
    54.    return POSIX.file_position
    55.    is (bytes_per_sector * POSIX.file_position(sector_number));
    56.
    57.    procedure get (the_DR : in out DR.device; s : out sector; the_index : in KDF9.word) is
    58.       byte_address : constant POSIX.file_position := file_offset(the_index);
    59.       result       : POSIX.file_position;
    60.    begin
    61.       result := seek(fd_of(the_DR.stream), file_offset(the_index));
    62.       if result /= byte_address then
    63.          raise emulation_failure
    64.             with "POSIX seek failure in DR.get";
    65.       end if;
    66.       result := POSIX.file_position(read(fd_of(the_DR.stream), s, bytes_per_sector));
    67.       if result /= bytes_per_sector then
    68.          raise emulation_failure
    69.             with "POSIX read failure in DR.get";
    70.       end if;
    71.    end get;
    72.
    73.    procedure put (the_DR : in out DR.device; s : in sector; the_index : in KDF9.word) is
    74.       byte_address : constant POSIX.file_position := file_offset(the_index);
    75.       result       : POSIX.file_position;
    76.    begin
    77.       result := seek(fd_of(the_DR.stream), file_offset(the_index));
    78.       if result /= byte_address then
    79.          raise emulation_failure
    80.             with "POSIX seek failure in DR.put";
    81.       end if;
    82.       result := POSIX.file_position(write(fd_of(the_DR.stream), s, bytes_per_sector));
    83.       if result /= bytes_per_sector then
    84.          raise emulation_failure
    85.             with "POSIX write failure in DR.put";
    86.       end if;
    87.    end put;
    88.
    89.    overriding
    90.    procedure Initialize (the_DR : in out DR.device) is
    91.    begin
    92.       open(IOC.device(the_DR), rd_wr_mode);
    93.    exception
    94.       when others =>
    95.          trap_operator_error(the_DR.device_name & " cannot be opened for reading and writing");
    96.    end Initialize;
    97.
    98.    procedure keep_house (the_DR        : in out DR.device;
    99.                          transfer_size : in KDF9.word;
   100.                          busy_time     : out KDF9.us;
   101.                          from_core     : Boolean := True) is
   102.       full_sectors  : constant KDF9.word := transfer_size / bytes_per_sector;
   103.       residue       : constant KDF9.word := transfer_size mod bytes_per_sector;
   104.       total_sectors : constant KDF9.word := (if residue /= 0 then 1 else 0) + full_sectors;
   105.       gapping_time  : constant KDF9.word := short_gap_time * (total_sectors-1)
   106.                                           + long_gap_time  * (total_sectors/sectors_per_track);
   107.    begin
   108.       the_DR.latency_count := the_DR.latency_count + 1;
   109.       the_DR.word_count := the_DR.word_count + transfer_size / 8;
   110.       if from_core then
   111.          add_in_the_IO_CPU_time(the_DR, bytes_moved => transfer_size);
   112.       end if;
   113.       busy_time :=  KDF9.us(gapping_time +transfer_size * us_per_char);
   114.    end keep_house;
   115.
   116.    procedure update_statistics (the_DR       : in out DR.device;
   117.                                 latency_time : in KDF9.us) is
   118.    begin
   119.       the_DR.latency_time := the_DR.latency_time + latency_time;
   120.    end update_statistics;
   121.
   122.    function angular_position (sector_number : sector_range)
   123.    return KDF9.us
   124.    is (KDF9.us(sector_number mod sectors_per_track * sector_time));
   125.
   126.    function latent_time (index : drum_index)
   127.    return KDF9.us is
   128.       sector_number : constant sector_range := sector_range(index mod sectors_per_track);
   129.       new_angle     : constant KDF9.us      := angular_position(sector_number);
   130.       old_angle     : constant KDF9.us      := the_clock_time mod track_time;
   131.       gap_time      : constant KDF9.us
   132.                     := (if old_angle > critical_time then short_gap_time else long_gap_time);
   133.       offset        : constant KDF9.us
   134.                     := (if   new_angle > old_angle
   135.                         then new_angle - old_angle
   136.                         else new_angle + track_time - old_angle);
   137.    begin
   138.       -- Hypothesis: we can pick up the next complete sector without a full latency delay,
   139.       --    if we are no closer to it than the start of its preceding inter-block gap.
   140.       return (if offset > gap_time then offset else track_time - offset);
   141.    end latent_time;
   142.
   143.    procedure validate_the_sector_number (the_DR : in out DR.device; sector_number : in KDF9.word) is
   144.    begin
   145.       if sector_number > sectors_per_system then
   146.          trap_failing_IO_operation(the_DR, "sector number too big =" & sector_number'Image);
   147.       end if;
   148.    end validate_the_sector_number;
   149.
   150.    function validated_drum_address (the_DR : in out DR.device; C_operand : KDF9.Q_part)
   151.    return KDF9.word is
   152.       result : constant KDF9.word := KDF9.word(C_operand / 16);
   153.    begin
   154.       -- We assume that the least significant 4 bits of the C operand are the buffer number,
   155.       --    that the next 2 bits specify one of 4 drums that can be fitted to the buffer,
   156.       --       and that the rest of the C operand is the sector number.
   157.       -- See the Drum Director KKT02E003UPU listing, routine P143 at label 1 et seq.
   158.       -- Returning C_operand / 16 treats the drums as consecutive sectors.
   159.       validate_the_sector_number(the_DR, result);
   160.       return result;
   161.    end validated_drum_address;
   162.
   163.    procedure increment (word_address : in out KDF9.address;
   164.                         symbol_nr    : in out KDF9_char_sets.symbol_index)
   165.       with Inline => True;
   166.
   167.    procedure increment (word_address : in out KDF9.address;
   168.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   169.    begin
   170.       if symbol_nr < 7 then
   171.          symbol_nr := symbol_nr + 1;
   172.       else
   173.          symbol_nr := 0;
   174.          word_address := word_address + 1;
   175.       end if;
   176.    end increment;
   177.
   178.    procedure read_drum (the_DR    : in out DR.device;
   179.                         Q_operand : in KDF9.Q_register) is
   180.       end_address  : constant KDF9.address := Q_operand.M;
   181.       next_address : KDF9.address := Q_operand.I;
   182.       the_sector   : DR.sector := (others => Character'Val(0));
   183.       symbol_nr    : KDF9_char_sets.symbol_index;
   184.       size         : KDF9.word := 0;
   185.       the_index    : KDF9.word;
   186.       latency,
   187.       busy_time    : KDF9.us;
   188.    begin
   189.       check_addresses_and_lockouts(next_address, end_address);
   190.       the_index := validated_drum_address(the_DR, Q_operand.C);
   191.       latency := latent_time(the_index);
   192.       get(the_DR, the_sector, the_index);
   193.    sector_loop:
   194.       loop
   195.          if the_index > DR.drum_index'Last then
   196.             trap_failing_IO_operation(the_DR, "reading more would exceed the storage available");
   197.          end if;
   198.          symbol_nr := 0;
   199.       byte_loop:
   200.          for i in 1 .. bytes_per_sector loop
   201.             if symbol_nr = 0 then
   202.                store_word(0, next_address);
   203.             end if;
   204.             store_symbol(CN_TR(the_sector(i)), next_address, symbol_nr);
   205.             size := size + 1;
   206.          exit byte_loop when next_address = end_address and symbol_nr = 7;
   207.             increment(next_address, symbol_nr);
   208.          end loop byte_loop;
   209.       exit sector_loop when next_address = end_address and symbol_nr = 7;
   210.          validate_the_sector_number(the_DR, the_index);
   211.          get(the_DR, the_sector, the_index);
   212.          the_index := the_index + 1;
   213.       end loop sector_loop;
   214.       keep_house(the_DR, size, busy_time);
   215.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, input_operation);
   216.       update_statistics(the_DR, latency);
   217.       lock_out_relative_addresses(Q_operand);
   218.    end read_drum;
   219.
   220.    overriding
   221.    procedure PIA (the_DR      : in out DR.device;
   222.                   Q_operand   : in KDF9.Q_register;
   223.                   set_offline : in Boolean) is
   224.       pragma Unreferenced(set_offline);
   225.    begin
   226.       validate_transfer(the_DR, Q_operand);
   227.       validate_parity(the_DR);
   228.       read_drum(the_DR, Q_operand);
   229.    end PIA;
   230.
   231.    procedure read_drum_to_EM (the_DR    : in out DR.device;
   232.                               Q_operand : in KDF9.Q_register) is
   233.       end_address  : constant KDF9.address := Q_operand.M;
   234.       next_address : KDF9.address := Q_operand.I;
   235.       the_sector   : DR.sector := (others => Character'Val(0));
   236.       at_EM     : Boolean := False;
   237.       symbol_nr : KDF9_char_sets.symbol_index;
   238.       size      : KDF9.word := 0;
   239.       the_index : KDF9.word;
   240.       latency,
   241.       busy_time : KDF9.us;
   242.    begin
   243.       check_addresses_and_lockouts(next_address, end_address);
   244.       the_index := validated_drum_address(the_DR, Q_operand.C);
   245.       latency := latent_time(the_index);
   246.       get(the_DR, the_sector, the_index);
   247.    sector_loop:
   248.       loop
   249.          if the_index > DR.drum_index'Last then
   250.             trap_failing_IO_operation(the_DR, "reading more would exceed the storage available");
   251.          end if;
   252.          symbol_nr := 0;
   253.       byte_loop:
   254.          for i in 1 .. bytes_per_sector loop
   255.             if symbol_nr = 0 then
   256.                store_word(0, next_address);
   257.             end if;
   258.             store_symbol(CN_TR(the_sector(i)), next_address, symbol_nr);
   259.             size := size + 1;
   260.          at_EM := the_sector(i) = KDF9_char_sets.E_M;
   261.          exit byte_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   262.             increment(next_address, symbol_nr);
   263.          end loop byte_loop;
   264.          exit sector_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   265.          validate_the_sector_number(the_DR, the_index);
   266.          get(the_DR, the_sector, the_index);
   267.          the_index := the_index + 1;
   268.       end loop sector_loop;
   269.       keep_house(the_DR, size, busy_time);
   270.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, input_operation);
   271.       lock_out_relative_addresses(Q_operand);
   272.       update_statistics(the_DR, latency);
   273.    end read_drum_to_EM;
   274.
   275.    overriding
   276.    procedure PIB (the_DR      : in out DR.device;
   277.                   Q_operand   : in KDF9.Q_register;
   278.                   set_offline : in Boolean) is
   279.        pragma Unreferenced(set_offline);
   280.   begin
   281.       validate_transfer(the_DR, Q_operand);
   282.       validate_parity(the_DR);
   283.       read_drum_to_EM(the_DR, Q_operand);
   284.    end PIB;
   285.
   286.    overriding
   287.    procedure PIC (the_DR      : in out DR.device;
   288.                   Q_operand   : in KDF9.Q_register;
   289.                   set_offline : in Boolean) is
   290.    begin
   291.       PIA(the_DR, Q_operand, set_offline);
   292.    end PIC;
   293.
   294.    overriding
   295.    procedure PID (the_DR      : in out DR.device;
   296.                   Q_operand   : in KDF9.Q_register;
   297.                   set_offline : in Boolean) is
   298.    begin
   299.       PIB(the_DR, Q_operand, set_offline);
   300.    end PID;
   301.
   302.    overriding
   303.    procedure PIE (the_DR      : in out DR.device;
   304.                   Q_operand   : in KDF9.Q_register;
   305.                   set_offline : in Boolean) is
   306.    begin
   307.       PIA(the_DR, Q_operand, set_offline);
   308.    end PIE;
   309.
   310.    overriding
   311.    procedure PIF (the_DR      : in out DR.device;
   312.                   Q_operand   : in KDF9.Q_register;
   313.                   set_offline : in Boolean) is
   314.    begin
   315.       PIB(the_DR, Q_operand, set_offline);
   316.    end PIF;
   317.
   318.    overriding
   319.    procedure PIG (the_DR      : in out DR.device;
   320.                   Q_operand   : in KDF9.Q_register;
   321.                   set_offline : in Boolean) is
   322.    begin
   323.       PIA(the_DR, Q_operand, set_offline);
   324.    end PIG;
   325.
   326.    overriding
   327.    procedure PIH (the_DR      : in out DR.device;
   328.                   Q_operand   : in KDF9.Q_register;
   329.                   set_offline : in Boolean) is
   330.    begin
   331.       PIB(the_DR, Q_operand, set_offline);
   332.    end PIH;
   333.
   334.    procedure write_drum (the_DR    : in out DR.device;
   335.                          Q_operand : in KDF9.Q_register) is
   336.       end_address  : constant KDF9.address := Q_operand.M;
   337.       next_address : KDF9.address := Q_operand.I;
   338.       the_sector   : DR.sector := (others => Character'Val(0));
   339.       symbol_nr : KDF9_char_sets.symbol_index;
   340.       size      : KDF9.word := 0;
   341.       the_index : KDF9.word;
   342.       latency,
   343.       busy_time : KDF9.us;
   344.    begin
   345.       check_addresses_and_lockouts(next_address, end_address);
   346.       the_index := validated_drum_address(the_DR, Q_operand.C);
   347.       latency := latent_time(the_index);
   348.    sector_loop:
   349.       loop
   350.          symbol_nr := 0;
   351.       byte_loop:
   352.          for i in 1 .. bytes_per_sector loop
   353.             the_sector(i) := TP_CN(fetch_symbol(next_address, symbol_nr));
   354.             size := size + 1;
   355.          exit byte_loop when next_address = end_address and symbol_nr = 7;
   356.             increment(next_address, symbol_nr);
   357.          end loop byte_loop;
   358.          validate_the_sector_number(the_DR, the_index);
   359.          put(the_DR, the_sector, the_index);
   360.       exit sector_loop when next_address = end_address and symbol_nr = 7;
   361.          if the_index = DR.drum_index'Last then
   362.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   363.          else
   364.             the_index := the_index + 1;
   365.          end if;
   366.       end loop sector_loop;
   367.       keep_house(the_DR, size, busy_time);
   368.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   369.       lock_out_relative_addresses(Q_operand);
   370.       update_statistics(the_DR, latency);
   371.    end write_drum;
   372.
   373.    overriding
   374.    procedure POA (the_DR      : in out DR.device;
   375.                   Q_operand   : in KDF9.Q_register;
   376.                   set_offline : in Boolean) is
   377.       pragma Unreferenced(set_offline);
   378.    begin
   379.       validate_transfer(the_DR, Q_operand);
   380.       validate_parity(the_DR);
   381.       write_drum(the_DR, Q_operand);
   382.    end POA;
   383.
   384.    procedure write_drum_to_EM (the_DR    : in out DR.device;
   385.                                Q_operand : in KDF9.Q_register) is
   386.       end_address  : constant KDF9.address := Q_operand.M;
   387.       next_address : KDF9.address := Q_operand.I;
   388.       the_sector   : DR.sector := (others => Character'Val(0));
   389.       at_EM     : Boolean := False;
   390.       size      : KDF9.word := 0;
   391.       symbol_nr : KDF9_char_sets.symbol_index;
   392.       the_index : KDF9.word;
   393.       latency,
   394.       busy_time : KDF9.us;
   395.    begin
   396.       check_addresses_and_lockouts(next_address, end_address);
   397.       the_index := validated_drum_address(the_DR, Q_operand.C);
   398.       latency := latent_time(the_index);
   399.    sector_loop:
   400.       loop
   401.          if the_index > DR.drum_index'Last then
   402.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   403.          end if;
   404.          symbol_nr := 0;
   405.       byte_loop:
   406.          for i in 1 .. bytes_per_sector loop
   407.             the_sector(i) := TP_CN(fetch_symbol(next_address, symbol_nr));
   408.             size := size + 1;
   409.          at_EM := the_sector(i) = KDF9_char_sets.E_M;
   410.          exit byte_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   411.             increment(next_address, symbol_nr);
   412.          end loop byte_loop;
   413.          validate_the_sector_number(the_DR, the_index);
   414.          put(the_DR, the_sector, the_index);
   415.          exit sector_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   416.          the_index := the_index + 1;
   417.       end loop sector_loop;
   418.       keep_house(the_DR, size, busy_time);
   419.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   420.       lock_out_relative_addresses(Q_operand);
   421.       update_statistics(the_DR, latency);
   422.    end write_drum_to_EM;
   423.
   424.    overriding
   425.    procedure POB (the_DR      : in out DR.device;
   426.                   Q_operand   : in KDF9.Q_register;
   427.                   set_offline : in Boolean) is
   428.       pragma Unreferenced(set_offline);
   429.    begin
   430.       validate_transfer(the_DR, Q_operand);
   431.       validate_parity(the_DR);
   432.       write_drum_to_EM(the_DR, Q_operand);
   433.    end POB;
   434.
   435.    overriding
   436.    procedure POC (the_DR      : in out DR.device;
   437.                   Q_operand   : in KDF9.Q_register;
   438.                   set_offline : in Boolean) is
   439.    begin
   440.       POA(the_DR, Q_operand, Set_offline);
   441.    end POC;
   442.
   443.    overriding
   444.    procedure POD (the_DR      : in out DR.device;
   445.                   Q_operand   : in KDF9.Q_register;
   446.                   set_offline : in Boolean) is
   447.    begin
   448.       POB(the_DR, Q_operand, Set_offline);
   449.    end POD;
   450.
   451.    procedure write_zeroes (the_DR      : in out DR.device;
   452.                            Q_operand   : in KDF9.Q_register;
   453.                            set_offline : in Boolean) is
   454.       pragma Unreferenced(set_offline);
   455.       start_address : constant KDF9.address := Q_operand.I;
   456.       end_address   : constant KDF9.address := Q_operand.M;
   457.       the_sector    : constant DR.sector := (others => Character'Val(0));
   458.       size      : KDF9.word := 0;
   459.       the_index : KDF9.word;
   460.       latency,
   461.       busy_time : KDF9.us;
   462.    begin
   463.       check_addresses_and_lockouts(start_address, end_address);
   464.       the_index := validated_drum_address(the_DR, Q_operand.C);
   465.       latency := latent_time(the_index);
   466.       for s in 1 .. (KDF9.word(end_address) - KDF9.word(start_address) + 128) / 128 loop
   467.          if the_index > DR.drum_index'Last then
   468.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   469.          end if;
   470.          validate_the_sector_number(the_DR, the_index);
   471.          put(the_DR, the_sector, the_index);
   472.          size := size + bytes_per_sector;
   473.          the_index := the_index + 1;
   474.       end loop;
   475.       keep_house(the_DR, size, busy_time, from_core => False);
   476.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   477.       lock_out_relative_addresses(Q_operand);
   478.       update_statistics(the_DR, latency);
   479.    end write_zeroes;
   480.
   481.    overriding
   482.    procedure POE (the_DR      : in out DR.device;
   483.                   Q_operand   : in KDF9.Q_register;
   484.                   set_offline : in Boolean) is
   485.    begin
   486.       validate_transfer(the_DR, Q_operand);
   487.       write_zeroes(the_DR, Q_operand, set_offline);
   488.    end POE;
   489.
   490.    overriding
   491.    procedure POF (the_DR      : in out DR.device;
   492.                   Q_operand   : in KDF9.Q_register;
   493.                   set_offline : in Boolean) is
   494.    begin
   495.       POE(the_DR, Q_operand, Set_offline);
   496.    end POF;
   497.
   498.    overriding
   499.    procedure Finalize (the_DR : in out DR.device) is
   500.       transfer_time : constant KDF9.us := KDF9.us(the_DR.word_count * 8 * us_per_char);
   501.    begin
   502.       if the_DR.is_open then
   503.
   504.          if (the_final_state_is_wanted and the_log_is_wanted)    and then
   505.                (the_DR.word_count /= 0 or the_DR.latency_count /= 0) then
   506.             log_line
   507.                 (
   508.                  the_DR.device_name
   509.                & " on buffer #"
   510.                & oct_of(KDF9.Q_part(the_DR.number), 2)
   511.                & " spent:"
   512.                 );
   513.             log_line
   514.                 (
   515.                  "    "
   516.                & just_right(KDF9.us'Image(transfer_time / 1_000), 6)
   517.                & " ms in"
   518.                & the_DR.latency_count'Image
   519.                & " data transfer" & plurality(the_DR.latency_count)
   520.                & " totalling"
   521.                & KDF9.word'Image(the_DR.word_count)
   522.                & " word" & plurality(the_DR.word_count)
   523.                & ", and"
   524.                 );
   525.             log_line
   526.                 (
   527.                  "    "
   528.                & just_right(KDF9.us'Image(the_DR.latency_time / 1_000), 6)
   529.                & " ms in"
   530.                & the_DR.latency_count'Image
   531.                & plurality(the_DR.latency_count, " rotational latency.", " rotational latencies.")
   532.                 );
   533.          end if;
   534.
   535.          close(IOC.device(the_DR));
   536.       end if;
   537.    end Finalize;
   538.
   539.    DR_quantum : constant := us_per_char;
   540.
   541.    type DR_access is access DR.device;
   542.
   543.    DR0 : DR_access with Warnings => Off;
   544.
   545.    procedure enable (b : in KDF9.buffer_number) is
   546.    begin
   547.       if DR0_is_enabled then
   548.          trap_operator_error("more than one DR control unit has been configured");
   549.       end if;
   550.       DR0 := new DR.device (number  => b,
   551.                             kind    => DR_kind,
   552.                             unit    => 0,
   553.                             quantum => DR_quantum);
   554.       DR0_is_enabled := True;
   555.       DR0_number := b;
   556.    end enable;
   557.
   558.    procedure re_enable (b : in KDF9.buffer_number) is
   559.    begin
   560.       if DR0_is_enabled and then
   561.          b = DR0.number     then
   562.          return;
   563.       end if;
   564.       buffer(b) := null;
   565.       enable(b);
   566.    end re_enable;
   567.
   568.    procedure disable (b : in KDF9.buffer_number) is
   569.    begin
   570.       if DR0_is_enabled and DR0_number = b then
   571.          buffer(b) := null;
   572.          DR0_is_enabled := False;
   573.       end if;
   574.    end disable;
   575.
   576. end IOC.fast.DR;

Compiling: ../Source/ioc-fast-dr.ads
Source file time stamp: 2021-02-04 01:25:29
Compiled at: 2021-02-08 17:20:59

     1. -- Emulation of a drum store buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.DR is
    18.
    19.    type device is new IOC.fast.device with private;
    20.
    21.    overriding
    22.    procedure PIA (the_DR      : in out DR.device;
    23.                   Q_operand   : in KDF9.Q_register;
    24.                   set_offline : in Boolean);
    25.
    26.    overriding
    27.    procedure PIB (the_DR      : in out DR.device;
    28.                   Q_operand   : in KDF9.Q_register;
    29.                   set_offline : in Boolean);
    30.
    31.    overriding
    32.    procedure PIC (the_DR      : in out DR.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    overriding
    37.    procedure PID (the_DR      : in out DR.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    overriding
    42.    procedure PIE (the_DR      : in out DR.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    overriding
    47.    procedure PIF (the_DR      : in out DR.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    overriding
    52.    procedure PIG (the_DR      : in out DR.device;
    53.                   Q_operand   : in KDF9.Q_register;
    54.                   set_offline : in Boolean);
    55.
    56.    overriding
    57.    procedure PIH (the_DR      : in out DR.device;
    58.                   Q_operand   : in KDF9.Q_register;
    59.                   set_offline : in Boolean);
    60.
    61. -- PMA-PML, and POG-POL are inherited, as they have no new semantics for the drum.
    62.
    63.    overriding
    64.    procedure POA (the_DR      : in out DR.device;
    65.                   Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    overriding
    69.    procedure POB (the_DR      : in out DR.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean);
    72.
    73.    overriding
    74.    procedure POC (the_DR      : in out DR.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.    overriding
    78.    procedure POD (the_DR      : in out DR.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean);
    81.
    82.    overriding
    83.    procedure POE (the_DR      : in out DR.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    overriding
    88.    procedure POF (the_DR      : in out DR.device;
    89.                   Q_operand   : in KDF9.Q_register;
    90.                   set_offline : in Boolean);
    91.
    92.    procedure enable (b : in KDF9.buffer_number);
    93.
    94.    procedure re_enable (b : in KDF9.buffer_number);
    95.
    96.    procedure disable (b : in KDF9.buffer_number);
    97.
    98.    DR0_is_enabled : Boolean := False;
    99.
   100.    function as_DR_command (Q_operand : KDF9.Q_register; for_OUT : Boolean := False)
   101.    return String;
   102.
   103. private
   104.
   105.    -- For what little we know from EE of the drum geometry, see the Manual, App. 6, §4.
   106.    -- An additional and more helpful source is the SRLM, §103, Appendix 2, p.10-59-0,
   107.    --   which describes the drum used with the non-Time Sharing Director.
   108.    -- It says:
   109.    --   Drum revolution time     = 20.4   ms
   110.    --   Transfer time per sector =  2.15  ms
   111.    --   Short gap time           =  0.034 ms between successive sectors
   112.    --   Long gap time            =  2.97  ms after every 8th sector
   113.    -- Hence: Mean time per sector = revolution time/8 - short gap time - long gap time/8
   114.    --                             = 20.4 ms / 8       - 0.034          - 2.970 / 8
   115.    --                             = 2.145 ms, rounding correctly to 2.15 ms
   116.    -- This confirms 8 sectors per track, or 8192 characters per track, for 40 tracks per drum.
   117.
   118.    bytes_per_sector   : constant := 1024;
   119.    subtype byte_range is KDF9.word range 0 .. bytes_per_sector - 1;
   120.    subtype sector     is String(1..bytes_per_sector);
   121.
   122.    sectors_per_track  : constant := 8;
   123.    subtype sector_range is KDF9.word range 0 .. sectors_per_track - 1;
   124.
   125.    sectors_per_drum   : constant := 320;
   126.    drums_per_system   : constant := 4;
   127.    sectors_per_system : constant := sectors_per_drum * drums_per_system;
   128.    subtype drum_index is KDF9.word range 0 .. sectors_per_system - 1;
   129.
   130.    tracks_per_system   : constant := sectors_per_system / sectors_per_track;
   131.    subtype track_range is KDF9.word range 0 .. tracks_per_system - 1;
   132.
   133.    data_rate      : constant := 477_445;         -- chars/s
   134.    us_per_char    : constant := 1E6 / data_rate; -- ~2.1 µs/char
   135.
   136.    -- The following times are in microseconds.
   137.    short_gap_time : constant := 34;
   138.    sector_time    : constant := bytes_per_sector * us_per_char + short_gap_time;
   139.    long_gap_time  : constant := 2_970;
   140.    track_time     : constant := sector_time * sectors_per_track + long_gap_time;
   141.    critical_time  : constant := sector_time * (sectors_per_track-1) - short_gap_time;
   142.
   143.    type drum is array (drum_index) of DR.sector;
   144.
   145.    type device is new IOC.fast.device with null record;
   146.
   147.    overriding
   148.    procedure Initialize (the_DR : in out DR.device);
   149.
   150.    overriding
   151.    procedure Finalize (the_DR : in out DR.device);
   152.
   153.    DR0_number : KDF9.buffer_number := 0;
   154.
   155. end IOC.fast.DR;

 576 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-fd.adb
Source file time stamp: 2021-02-07 23:25:05
Compiled at: 2021-02-08 17:20:59

     1. -- Emulation of a fixed disc drive.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. --
    19. with formatting;
    20. with HCI;
    21. with tracing;
    22.
    23. use formatting;
    24. use  HCI;
    25. use  tracing;
    26.
    27. package body IOC.fast.FD is
    28.
    29.    use KDF9_char_sets;
    30.
    31.    function as_FD_command (Q_operand : KDF9.Q_register; for_seek, for_FH : Boolean := False)
    32.    return String is
    33.       parameter : constant KDF9.Q_part := Q_operand.C / 16;
    34.       cylinder  : constant KDF9.Q_part := parameter mod seek_areas_per_platter;
    35.       residue   : constant KDF9.Q_part := parameter  /  seek_areas_per_platter;
    36.       platter   : constant KDF9.Q_part := residue mod main_discs_per_drive;
    37.       drive     : constant KDF9.Q_part := residue  /  main_discs_per_drive;
    38.    begin
    39.       -- The disc geometry and I/O command bits are as defined in the FD package.
    40.       if for_seek then
    41.          return "D" & dec_of(drive)
    42.               & "P" & dec_of(if for_FH then KDF9.Q_part'(the_fixed_head_platter) else platter)
    43.               & "C" & dec_of(cylinder);
    44.       else -- for data transfer, parameter is sector #, with maximum 96 sectors per track.
    45.          return " S" & (if parameter < 10 then "0" else "") & dec_of(parameter);
    46.       end if;
    47.    end as_FD_command;
    48.
    49.    overriding
    50.    procedure Initialize (the_FD : in out FD.device) is
    51.    begin
    52.       open(the_FD, rd_wr_mode);
    53.    exception
    54.       when others =>
    55.          trap_operator_error(the_FD.device_name & " cannot be opened for reading and writing");
    56.    end Initialize;
    57.
    58.    -- Hypothesis:
    59.    -- Where a specification of the Fixed Disc subsystem cannot be inferred from extant software,
    60.    -- such as the Eldon 2 Director, or the EE KDF9 Programming Manual,
    61.    -- then it is reasonable to extrapolate from the Data Products Corporation documents:
    62.    --    "SPECIFICATION FOR MODEL 5022 DISCfILE STORAGE SYSTEM", of December 1964, and
    63.    --    "GENERAL INFORMATION MANUAL dp/f-5022 DISCfILE STORAGE SYSTEM", of March 1965,
    64.    -- which describe an (at least) very similar model.
    65.    -- These document are referred to herein as "GIM".
    66.    -- Confirmation of much of this material has been gained from the ICT document:
    67.    --    "Data Disc Store 1956", of September 1964",
    68.    -- which describes the same device, offered as a fixed disc drive for the 1900 Series.
    69.    -- All three depict the drive as having a different division of tracks into sectors.
    70.
    71.    -- Hypothesis:
    72.    -- The locus is set by a PMA or PMD operation; the sector number is updated by a transfer.
    73.
    74.    -- Hypothesis:
    75.    -- A PMA or PMD command sets the sector number to 0.
    76.
    77.    -- Hypothesis:
    78.    -- If a transfer would increase the sector number past 95, the end-of-area flag is set,
    79.    --    and the sector number is set to 95.
    80.
    81.    function locus_from (Q_operand : KDF9.Q_register)
    82.    return FD.locus is
    83.       parameter : constant KDF9.Q_part := Q_operand.C / 16; -- remove the buffer number
    84.       seek_area : constant KDF9.Q_part := parameter mod seek_areas_per_platter;
    85.       platter   : constant KDF9.Q_part
    86.                 := parameter / seek_areas_per_platter mod platters_per_drive;
    87.       drive     : constant KDF9.Q_part
    88.                 := parameter / seek_areas_per_platter / platters_per_drive;
    89.    begin
    90.       -- Hypothesis:
    91.       -- Seeking to a new locus zeroizes the sector number and clears the end-of-area flag.
    92.       return (
    93.               drive_number      => drive,
    94.               platter_number    => platter,
    95.               seek_area_number  => seek_area,
    96.               sector_number     => 0,
    97.               has_fixed_heads   => False,
    98.               is_at_end_of_area => False
    99.              );
   100.    end locus_from;
   101.
   102.    function sector_span (Q_operand : KDF9.Q_register)
   103.    return KDF9.Q_part
   104.    is ((Q_operand.M - Q_operand.I + words_per_sector - 1) / words_per_sector);
   105.
   106.    procedure advance_the_sector_number (the_FD : in out FD.device) is
   107.    begin
   108.       if the_FD.locus.sector_number = FD.sector_range'Last then
   109.          the_FD.locus.is_at_end_of_area := True;
   110.       else
   111.          the_FD.locus.is_at_end_of_area := False;
   112.          the_FD.locus.sector_number := the_FD.locus.sector_number + 1;
   113.       end if;
   114.    end advance_the_sector_number;
   115.
   116.    procedure set_the_new_sector_number (the_FD    : in out FD.device;
   117.                                     Q_operand : in KDF9.Q_register) is
   118.       the_sector_number : constant KDF9.Q_part := (Q_operand.C / 16) and 8#177#;
   119.    begin
   120.       if the_sector_number in FD.sector_range then
   121.          the_FD.locus.is_at_end_of_area := False;
   122.          the_FD.locus.sector_number := the_sector_number;
   123.       else
   124.          the_FD.locus.is_at_end_of_area := True;
   125.          the_FD.locus.sector_number := FD.sector_range'Last;
   126.       end if;
   127.    end set_the_new_sector_number;
   128.
   129.    sectors_per_platter : constant := sectors_per_seek_area * seek_areas_per_platter;
   130.    sectors_per_drive   : constant := platters_per_drive  * sectors_per_platter;
   131.
   132.    function file_offset (locus : FD.locus)
   133.    return POSIX.file_position
   134.    is (
   135.        bytes_per_sector *
   136.                         ( POSIX.file_position(locus.drive_number)     * sectors_per_drive
   137.                         + POSIX.file_position(locus.platter_number)   * sectors_per_platter
   138.                         + POSIX.file_position(locus.seek_area_number) * sectors_per_seek_area
   139.                         + POSIX.file_position(locus.sector_number)    * 1
   140.                         )
   141.       );
   142.
   143.    function disc_busy_time (first : FD.sector_range; size : KDF9.word)
   144.    return KDF9.us is
   145.
   146.       function ceiling (first : FD.sector_range; size : KDF9.word)
   147.       return FD.sector_range is
   148.          length : constant KDF9.Q_part := sector_span((0, 1, KDF9.Q_part(size)));
   149.       begin
   150.          return FD.sector_range'Min(first + length - 1, FD.sector_range'Last);
   151.       end ceiling;
   152.
   153.       function time_for (bytes : KDF9.word; in_outer_zone : Boolean)
   154.       return KDF9.word
   155.       is (1E6 * bytes / (if in_outer_zone then outer_rate else inner_rate));
   156.
   157.       boundary   : constant := sectors_per_seek_area / 3 * 2;
   158.       last       : constant FD.sector_range := ceiling(first, size);
   159.       bytes_left : KDF9.word := size * 8;
   160.       total_time : KDF9.word := 0;
   161.
   162.    begin
   163.       for s in first .. last loop
   164.       exit when bytes_left < bytes_per_sector;
   165.          total_time := total_time + time_for(bytes_per_sector, in_outer_zone => s < boundary);
   166.          bytes_left := bytes_left - bytes_per_sector;
   167.       end loop;
   168.       if bytes_left /= 0 then
   169.          total_time := total_time + time_for(bytes_left, in_outer_zone => last < boundary);
   170.       end if;
   171.       return KDF9.us(total_time);
   172.    end disc_busy_time;
   173.
   174.    -- The rotational position of the disc is measured in term of the time,
   175.    --    in microseconds, taken to get to that position from sector 0.
   176.
   177.    rotation_time : constant := 60E3;  -- 1000 RPM => 60 ms = 60_000 KDF9.us
   178.    track_size    : constant := 16;    -- There are only 8 sectors per track in the inner zone.
   179.    sector_time   : constant := rotation_time / track_size;
   180.
   181.    function angular_position (sector_number : FD.sector_range)
   182.    return KDF9.us
   183.    is (-- This is <= rotation_time.
   184.        if sector_number < sectors_in_outer_zone then
   185.           KDF9.us(sector_number * sector_time)
   186.        else
   187.           -- Inner zone sectors are twice as long as in the outer zone.
   188.           -- Assumes (without evidence) that the inner zone is offset 1/2 sector from the outer.
   189.           KDF9.us((sector_number - sectors_in_outer_zone) * sector_time * 2 - sector_time/2)
   190.       );
   191.
   192.    function latent_time (the_FD : FD.device; latency_start_time : in KDF9.us)
   193.    return KDF9.us is
   194.       new_angle  : constant KDF9.us := angular_position(the_FD.locus.sector_number);
   195.       old_angle  : constant KDF9.us := latency_start_time mod rotation_time;
   196.       offset     : constant KDF9.us
   197.                  := (if   new_angle > old_angle
   198.                      then new_angle - old_angle
   199.                      else new_angle + rotation_time - old_angle);
   200.    begin
   201.       -- According to GIM, the minimum latency is one sector;
   202.       --    if less we have to go all the way around.
   203.       return (if offset > sector_time then offset else rotation_time - offset );
   204.    end latent_time;
   205.
   206.    -- These times come from the Manual, §6.1, and from GIM.
   207.    checking_time  : constant :=   47E3;
   208.    min_seek_time  : constant :=  109E3;
   209.    max_seek_time  : constant :=  321E3;
   210.    per_track_time : constant KDF9.us
   211.                   := KDF9.us(max_seek_time - min_seek_time) / seek_areas_per_platter;
   212.
   213.    -- A seek distance of 1 takes the minimum seek time: zero_seek_time + per_track_time.
   214.    zero_seek_time : constant KDF9.us := min_seek_time - per_track_time;
   215.
   216.    subtype seek_time_range is KDF9.us range 0 .. max_seek_time + checking_time;
   217.
   218.    function arm_seek_time (the_FD : FD.device)
   219.    return seek_time_range is
   220.       next   : FD.locus renames the_FD.target;
   221.       drive  : FD.drive_range renames next.drive_number;
   222.       here   : constant FD.seek_area_range := the_FD.comb(drive, next.platter_number);
   223.       there  : constant FD.seek_area_range := next.seek_area_number;
   224.       span   : constant FD.seek_area_range := (if here > there then here - there else there - here);
   225.       cost   : constant KDF9.us := KDF9.us(span) * per_track_time;
   226.    begin
   227.       if cost > 0 and next.platter_number /= the_fixed_head_platter then
   228.          -- Hypothesis:
   229.          return KDF9.us'Min(zero_seek_time + cost, max_seek_time) + checking_time;
   230.       else
   231.          -- Hypothesis:
   232.          -- A seek to the present position takes no time.
   233.          return 0;
   234.       end if;
   235.    end arm_seek_time;
   236.
   237.    -- These times come from GIM.
   238.    -- A switch to a different platter takes 26 ms on average, as specified in GIM.
   239.    -- This time is needed to power-down then power-up the arm actuators for the R/W heads.
   240.    drive_switch_time : constant :=  5_000;
   241.    arm_switch_time   : constant := 26_000;
   242.
   243.    function platter_switch_time (the_FD : FD.device)
   244.    return KDF9.us is
   245.       the_drive_time : KDF9.us;
   246.    begin
   247.       if the_FD.target.drive_number /= the_FD.locus.drive_number then
   248.          the_drive_time := drive_switch_time;
   249.       else
   250.          the_drive_time := 0;
   251.       end if;
   252.       -- Hypothesis:
   253.       -- Operating successively on the current platter, or working on the fixed-head platter,
   254.       --    incurs no arm switch time.
   255.       if the_FD.target.platter_number = the_FD.locus.platter_number or else
   256.             the_FD.target.platter_number = the_fixed_head_platter      then
   257.           return the_drive_time;
   258.        else
   259.           return the_drive_time + arm_switch_time;
   260.       end if;
   261.    end platter_switch_time;
   262.
   263.    procedure set_seek_target (the_FD       : in out FD.device;
   264.                               Q_operand    : in KDF9.Q_register;
   265.                               it_will_seek : out Boolean) is
   266.       here : FD.locus renames the_FD.locus;
   267.       next : FD.locus renames the_FD.target;
   268.    begin
   269.       it_will_seek := False;
   270.       next := locus_from(Q_operand);
   271.       next.has_fixed_heads := False;
   272.       if next.platter_number /= here.platter_number then
   273.          the_FD.switch_count := the_FD.switch_count +1;
   274.       end if;
   275.       if the_FD.comb(next.drive_number, here.platter_number) /= next.seek_area_number then
   276.          the_FD.seek_count := the_FD.seek_count + 1;
   277.          it_will_seek := True;
   278.       end if;
   279.     end set_seek_target;
   280.
   281.    procedure seek_to_the_target_area (the_FD      : in out FD.device;
   282.                                       seek_time,
   283.                                       switch_time : out seek_time_range) is
   284.       here : FD.locus renames the_FD.locus;
   285.       next : FD.locus renames the_FD.target;
   286.    begin
   287.       seek_time := arm_seek_time(the_FD);
   288.       switch_time := platter_switch_time(the_FD);
   289.       here := the_FD.target;
   290.       the_FD.comb(here.drive_number, here.platter_number) := next.seek_area_number;
   291.     end seek_to_the_target_area;
   292.
   293.    subtype sector_image is String(1 .. bytes_per_sector);
   294.
   295.    empty_sector : constant sector_image := (others => ' ');
   296.    this_sector  : sector_image;
   297.
   298.    procedure get_next_sector (the_FD : in out FD.device) is
   299.       byte_address : constant POSIX.file_position := file_offset(the_FD.locus);
   300.       byte_count   : Integer;
   301.    begin
   302.       if seek(fd_of(the_FD.stream), byte_address) /= byte_address then
   303.          raise emulation_failure with "POSIX seek failure in FD.get_next_sector";
   304.       end if;
   305.       byte_count := read(fd_of(the_FD.stream), this_sector, bytes_per_sector);
   306.       if byte_count /= bytes_per_sector and then  -- A short transfer ..
   307.             byte_count /= 0                 then  -- ... is OK at EOF with a 0 count.
   308.          raise emulation_failure with "POSIX read failure in FD.get_next_sector";
   309.       end if;
   310.       the_FD.sector_count := the_FD.sector_count + 1;
   311.       advance_the_sector_number(the_FD);
   312.
   313.    end get_next_sector;
   314.
   315.    procedure keep_house (the_FD        : in out FD.device;
   316.                          transfer_size : in KDF9.word;
   317.                          busy_time     : out KDF9.us) is
   318.    begin
   319.       the_FD.latency_count := the_FD.latency_count + 1;
   320.       the_FD.word_count := the_FD.word_count + transfer_size;
   321.       add_in_the_IO_CPU_time(the_FD, bytes_moved => transfer_size*8);
   322.       busy_time := disc_busy_time(the_FD.locus.sector_number, transfer_size);
   323.    end keep_house;
   324.
   325.    procedure update_statistics (the_FD        : in out FD.device;
   326.                                 switch_time,
   327.                                 seek_time,
   328.                                 latency_time,
   329.                                 data_time     : in KDF9.us := 0) is
   330.    begin
   331.       the_FD.switch_time := the_FD.switch_time + switch_time;
   332.       the_FD.seek_time := the_FD.seek_time + seek_time;
   333.       the_FD.latency_time := the_FD.latency_time + latency_time;
   334.       the_FD.data_time := the_FD.data_time + data_time;
   335.       the_FD.elapsed_time := the_FD.elapsed_time
   336.                                  + switch_time
   337.                                  + seek_time
   338.                                  + latency_time
   339.                                  + data_time;
   340.     end update_statistics;
   341.
   342.    procedure read (the_FD        : in out FD.device;
   343.                    start_address,
   344.                    end_address   : in  KDF9.address;
   345.                    busy_time     : out KDF9.us;
   346.                    reading_to_EM : in  Boolean := False) is
   347.       size : KDF9.word := 0;
   348.       next : Natural := 0;
   349.       char : Character;
   350.    begin
   351.       check_addresses_and_lockouts(start_address, end_address);
   352.    word_loop:
   353.       for w in start_address .. end_address loop
   354.          if size mod bytes_per_sector = 0 then
   355.             this_sector := empty_sector;
   356.             get_next_sector(the_FD);
   357.          exit word_loop when the_FD.locus.is_at_end_of_area;
   358.             next := 0;
   359.          end if;
   360.          for c in KDF9_char_sets.symbol_index'Range loop
   361.             next := next + 1;
   362.             char := this_sector(next);
   363.             store_symbol(CN_TR(char), w, c);
   364.             size := size + 1;
   365.          exit word_loop when reading_to_EM and char = E_M;
   366.          end loop;
   367.       end loop word_loop;
   368.       keep_house(the_FD, (size+7)/8, busy_time);
   369.    end read;
   370.
   371.    procedure PI_all (the_FD         : in out FD.device;
   372.                      Q_operand      : in KDF9.Q_register;
   373.                      transfer_to_EM : in Boolean := False) is
   374.       the_present_time   : constant KDF9.us := the_clock_time;
   375.       latency_start_time : KDF9.us;
   376.       seek_duration,
   377.       switch_duration,
   378.       latency_duration,
   379.       data_duration,
   380.       total_duration     : KDF9.us;
   381.    begin
   382.       validate_device(the_FD, Q_operand);
   383.       validate_parity(the_FD);
   384.       seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   385.       set_the_new_sector_number(the_FD, Q_operand);
   386.       latency_start_time := the_present_time + seek_duration + switch_duration;
   387.       latency_duration := latent_time(the_FD, latency_start_time);
   388.
   389.       if the_FD.locus.is_at_end_of_area then
   390.          -- Cannot transfer past the last sector in a seek area.
   391.          trap_failing_IO_operation(the_FD, "attempt to read FD at the end of a seek area");
   392.       end if;
   393.
   394.       -- Read from the newly established position.
   395.       read(
   396.            the_FD,
   397.            Q_operand.I, Q_operand.M,
   398.            data_duration,
   399.            reading_to_EM => transfer_to_EM
   400.           );
   401.
   402.       total_duration := seek_duration + switch_duration + latency_duration + data_duration;
   403.       start_data_transfer(the_FD, Q_operand, False, total_duration, input_operation);
   404.       lock_out_relative_addresses(Q_operand);
   405.       update_statistics(
   406.                         the_FD,
   407.                         switch_time  => switch_duration,
   408.                         seek_time    => seek_duration,
   409.                         latency_time => latency_duration,
   410.                         data_time    => data_duration
   411.                        );
   412.    end PI_all;
   413.
   414.    overriding
   415.    procedure PIA (the_FD      : in out FD.device;
   416.                   Q_operand   : in KDF9.Q_register;
   417.                   set_offline : in Boolean) is
   418.       pragma Unreferenced(set_offline);
   419.    begin
   420.       PI_all(the_FD, Q_operand);
   421.    end PIA;
   422.
   423.    overriding
   424.    procedure PIB (the_FD      : in out FD.device;
   425.                   Q_operand   : in KDF9.Q_register;
   426.                   set_offline : in Boolean) is
   427.       pragma Unreferenced(set_offline);
   428.    begin
   429.       PI_all(the_FD, Q_operand, transfer_to_EM => True);
   430.    end PIB;
   431.
   432.    -- Set up FD parameters for a transfer in the fixed-head platter.
   433.    procedure prepare_fixed_head_transfer (the_FD      : in out FD.device;
   434.                                           Q_operand   : in KDF9.Q_register) is
   435.    begin
   436.       the_FD.target := locus_from(Q_operand);
   437.       the_FD.target.has_fixed_heads := True;
   438.       the_FD.target.platter_number := 16;
   439.       the_FD.switch_time := platter_switch_time(the_FD);
   440.       the_FD.locus := the_FD.target;
   441.       the_FD.switch_count := the_FD.switch_count + (if the_FD.switch_time = 0 then 0 else 1);
   442.    end prepare_fixed_head_transfer;
   443.
   444.    overriding
   445.    procedure PIC (the_FD      : in out FD.device;
   446.                   Q_operand   : in KDF9.Q_register;
   447.                   set_offline : in Boolean) is
   448.       pragma Unreferenced(set_offline);
   449.    begin
   450.       prepare_fixed_head_transfer(the_FD, Q_operand);
   451.       PI_all(the_FD, Q_operand);
   452.    end PIC;
   453.
   454.    overriding
   455.    procedure PID (the_FD      : in out FD.device;
   456.                   Q_operand   : in KDF9.Q_register;
   457.                   set_offline : in Boolean) is
   458.       pragma Unreferenced(set_offline);
   459.    begin
   460.       prepare_fixed_head_transfer(the_FD, Q_operand);
   461.       PI_all(the_FD, Q_operand, transfer_to_EM => True);
   462.    end PID;
   463.
   464.    -- Find the number of the next (first) sector to rotate into an accessible position.
   465.    function next_sector_number (the_FD : FD.device)
   466.    return FD.sector_range is
   467.       now        : constant KDF9.us := the_clock_time;
   468.       best_time  : KDF9.us          := KDF9.us'Last;
   469.       the_sector : FD.sector_range  := FD.sector_range'Last;
   470.    begin
   471.       for s in FD.sector_range loop
   472.          if latent_time(the_FD, now) in sector_time+1 .. 2*sector_time then
   473.             if latent_time(the_FD, now) <= best_time then
   474.                the_sector := s;
   475.                best_time := latent_time(the_FD, now);
   476.             end if;
   477.          end if;
   478.       end loop;
   479.       return the_sector;
   480.    end next_sector_number;
   481.
   482.    -- Modify the given command to apply to the next sector to come under the heads.
   483.    function for_next_sector (the_FD : FD.device; Q : KDF9.Q_register)
   484.    return KDF9.Q_register
   485.    is (
   486.        C => (Q.C and 8#174000#) or (Q.C and 8#17#) or (next_sector_number(the_FD)*16),
   487.        I => Q.I,
   488.        M => Q.M
   489.       );
   490.
   491.    overriding
   492.    procedure PIE (the_FD      : in out FD.device;
   493.                   Q_operand   : in KDF9.Q_register;
   494.                   set_offline : in Boolean) is
   495.       pragma Unreferenced(set_offline);
   496.    begin
   497.       validate_transfer(the_FD, Q_operand);
   498.       PI_all(the_FD, for_next_sector(the_FD, Q_operand));
   499.    end PIE;
   500.
   501.    overriding
   502.    procedure PIF (the_FD      : in out FD.device;
   503.                   Q_operand   : in KDF9.Q_register;
   504.                   set_offline : in Boolean) is
   505.       pragma Unreferenced(set_offline);
   506.    begin
   507.       validate_transfer(the_FD, Q_operand);
   508.       PI_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   509.    end PIF;
   510.
   511.    overriding
   512.    procedure PIG (the_FD      : in out FD.device;
   513.                   Q_operand   : in KDF9.Q_register;
   514.                   set_offline : in Boolean) is
   515.       pragma Unreferenced(set_offline);
   516.    begin
   517.       validate_transfer(the_FD, Q_operand);
   518.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   519.       PI_all(the_FD, for_next_sector(the_FD, Q_operand));
   520.    end PIG;
   521.
   522.    overriding
   523.    procedure PIH (the_FD      : in out FD.device;
   524.                   Q_operand   : in KDF9.Q_register;
   525.                   set_offline : in Boolean) is
   526.       pragma Unreferenced(set_offline);
   527.    begin
   528.       validate_transfer(the_FD, Q_operand);
   529.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   530.       PI_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   531.    end PIH;
   532.
   533.    -- Set up, but do not yet effect, a seek to the locus specified by the Q_operand.
   534.    -- This follows advice from David Holdsworth that seeks were not effected
   535.    --    until a data transfer operation was obeyed.
   536.    -- PMA does not lockout for a busy device.  This may not be authentic.
   537.    overriding
   538.    procedure PMA (the_FD      : in out FD.device;
   539.                   Q_operand   : in KDF9.Q_register;
   540.                   set_offline : in Boolean) is
   541.       a_seek_is_needed : Boolean := False;
   542.    begin
   543.       validate_device(the_FD, Q_operand);
   544.       validate_parity(the_FD);
   545.       set_seek_target(the_FD, Q_operand, a_seek_is_needed);
   546.       deal_with_a_busy_device(the_FD, 19, set_offline);
   547.       take_note_of_test(the_FD.device_name, Q_operand, a_seek_is_needed);
   548.    end PMA;
   549.
   550.    overriding
   551.    procedure PMB (the_FD      : in out FD.device;
   552.                   Q_operand   : in KDF9.Q_register;
   553.                   set_offline : in Boolean) is
   554.       pragma Unreferenced(set_offline);
   555.    begin
   556.       validate_device(the_FD, Q_operand);
   557.       validate_parity(the_FD);
   558.       null;
   559.    end PMB;
   560.
   561.    overriding
   562.    procedure PMC (the_FD      : in out FD.device;
   563.                   Q_operand   : in KDF9.Q_register;
   564.                   set_offline : in Boolean) is
   565.       pragma Unreferenced(set_offline);
   566.    begin
   567.       validate_device(the_FD, Q_operand);
   568.       validate_parity(the_FD);
   569.       null;
   570.    end PMC;
   571.
   572.    overriding
   573.    procedure PMD (the_FD      : in out FD.device;
   574.                   Q_operand   : in KDF9.Q_register;
   575.                   set_offline : in Boolean) is
   576.       -- clear out seek area # and platter #, leaving buffer # and drive #
   577.       platter_0        : constant KDF9.Q_part := Q_operand.C and 16#C00F#;
   578.       control_word     : KDF9.Q_register;
   579.       a_seek_is_needed : Boolean;
   580.       seek_duration,
   581.       switch_duration  : KDF9.us;
   582.    begin
   583.       validate_device(the_FD, Q_operand);
   584.       -- Hypothesis: drive reset clears the parity flag.
   585.       the_FD.is_abnormal := False;
   586.       -- In effect, do 16 PMA operations, but treat them as a single operation.
   587.       for p in KDF9.Q_part range 0..15 loop -- p is platter #
   588.          control_word := (platter_0 + p*16#400#, Q_operand.I, Q_operand.M);
   589.          set_seek_target(the_FD, control_word, a_seek_is_needed);
   590.          seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   591.          update_statistics(
   592.                            the_FD,
   593.                            switch_time  => switch_duration,
   594.                            seek_time    => seek_duration
   595.                           );
   596.       end loop;
   597.       deal_with_a_busy_device(the_FD, 16, set_offline);
   598.    end PMD;
   599.
   600.    overriding
   601.    procedure PMF (the_FD      : in out FD.device;
   602.                   Q_operand   : in KDF9.Q_register;
   603.                   set_offline : in Boolean) is
   604.    begin
   605.       validate_device(the_FD, Q_operand);
   606.       validate_parity(the_FD);
   607.       deal_with_a_busy_device(the_FD, 13, set_offline);
   608.       the_T_bit_is_set := the_FD.locus.is_at_end_of_area;
   609.       take_note_of_test(the_FD.device_name, Q_operand, the_T_bit_is_set);
   610.    end PMF;
   611.
   612.    procedure put_next_sector (the_FD : in out FD.device) is
   613.       byte_address : constant POSIX.file_position := file_offset(the_FD.locus);
   614.    begin
   615.       if seek(fd_of(the_FD.stream), byte_address) /= byte_address then
   616.          raise emulation_failure with "POSIX seek failure in FD.put_next_sector";
   617.       end if;
   618.       if write(fd_of(the_FD.stream), this_sector, bytes_per_sector) /= bytes_per_sector then
   619.          raise emulation_failure with "POSIX write failure in FD.put_next_sector";
   620.       end if;
   621.       the_FD.sector_count := the_FD.sector_count + 1;
   622.       advance_the_sector_number(the_FD);
   623.       this_sector := empty_sector;
   624.    end put_next_sector;
   625.
   626.    procedure write (the_FD       : in out FD.device;
   627.                    start_address,
   628.                    end_address   : in KDF9.address;
   629.                    busy_time     : out KDF9.us;
   630.                    writing_to_EM : in  Boolean := False) is
   631.       size   : KDF9.word := 0;
   632.       next   : Natural := 0;
   633.       symbol : KDF9_char_sets.symbol;
   634.       char   : Character;
   635.    begin
   636.       check_addresses_and_lockouts(start_address, end_address);
   637.       this_sector := empty_sector;
   638.    word_loop:
   639.       for w in start_address .. end_address loop
   640.          for c in KDF9_char_sets.symbol_index'Range loop
   641.             symbol := fetch_symbol(w, c);
   642.             char := TP_CN(symbol);
   643.             next := next + 1;
   644.             this_sector(next) := char;
   645.             size := size + 1;
   646.             exit when writing_to_EM and char = E_M;
   647.          end loop;
   648.          if writing_to_EM and char = E_M then
   649.             put_next_sector(the_FD);
   650.             next := 0;
   651.             exit word_loop;
   652.          elsif size mod bytes_per_sector = 0 then
   653.             put_next_sector(the_FD);
   654.             next := 0;
   655.             exit word_loop when the_FD.locus.is_at_end_of_area;
   656.          end if;
   657.       end loop word_loop;
   658.       if next > 0 then
   659.          -- Write out any untransferred residue of less than a full sector.
   660.          put_next_sector(the_FD);
   661.       end if;
   662.       keep_house(the_FD, (size+7)/8, busy_time);
   663.    end write;
   664.
   665.    procedure PO_all (the_FD         : in out FD.device;
   666.                      Q_operand      : in KDF9.Q_register;
   667.                      transfer_to_EM : in Boolean := False) is
   668.       the_present_time   : constant KDF9.us := the_clock_time;
   669.       seek_duration,
   670.       switch_duration,
   671.       latency_duration,
   672.       data_duration,
   673.       total_duration     : KDF9.us;
   674.       latency_start_time : KDF9.us;
   675.    begin
   676.       validate_device(the_FD, Q_operand);
   677.       validate_parity(the_FD);
   678.       seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   679.       set_the_new_sector_number(the_FD, Q_operand);
   680.       latency_start_time := the_present_time + seek_duration + switch_duration;
   681.       latency_duration := latent_time(the_FD, latency_start_time);
   682.
   683.       if the_FD.locus.is_at_end_of_area then
   684.          -- Cannot transfer past the last sector in a seek area.
   685.          trap_failing_IO_operation(the_FD, "attempt to read FD at the end of a seek area");
   686.       end if;
   687.
   688.       -- Write to the newly established position.
   689.       write(
   690.             the_FD,
   691.             Q_operand.I, Q_operand.M,
   692.             data_duration,
   693.             writing_to_EM => transfer_to_EM
   694.            );
   695.
   696.       total_duration := seek_duration + switch_duration + latency_duration + data_duration;
   697.       start_data_transfer(the_FD, Q_operand, False, total_duration, output_operation);
   698.       lock_out_relative_addresses(Q_operand);
   699.       update_statistics(
   700.                         the_FD,
   701.                         seek_time    => seek_duration,
   702.                         switch_time  => switch_duration,
   703.                         latency_time => latency_duration,
   704.                         data_time    => data_duration
   705.                        );
   706.    end PO_all;
   707.
   708.    overriding
   709.    procedure POA (the_FD      : in out FD.device;
   710.                   Q_operand   : in KDF9.Q_register;
   711.                   set_offline : in Boolean) is
   712.       pragma Unreferenced(set_offline);
   713.    begin
   714.       PO_all(the_FD, Q_operand);
   715.    end POA;
   716.
   717.    overriding
   718.    procedure POB (the_FD      : in out FD.device;
   719.                   Q_operand   : in KDF9.Q_register;
   720.                   set_offline : in Boolean) is
   721.       pragma Unreferenced(set_offline);
   722.    begin
   723.       PO_all(the_FD, Q_operand, transfer_to_EM => True);
   724.    end POB;
   725.
   726.    overriding
   727.    procedure POC (the_FD      : in out FD.device;
   728.                   Q_operand   : in KDF9.Q_register;
   729.                   set_offline : in Boolean) is
   730.       pragma Unreferenced(set_offline);
   731.    begin
   732.       prepare_fixed_head_transfer(the_FD, Q_operand);
   733.       PO_all(the_FD, Q_operand);
   734.    end POC;
   735.
   736.    overriding
   737.    procedure POD (the_FD      : in out FD.device;
   738.                   Q_operand   : in KDF9.Q_register;
   739.                   set_offline : in Boolean) is
   740.       pragma Unreferenced(set_offline);
   741.    begin
   742.       prepare_fixed_head_transfer(the_FD, Q_operand);
   743.       PO_all(the_FD, Q_operand, transfer_to_EM => True);
   744.    end POD;
   745.
   746.    overriding
   747.    procedure POE (the_FD      : in out FD.device;
   748.                   Q_operand   : in KDF9.Q_register;
   749.                   set_offline : in Boolean) is
   750.    begin
   751.       POC(the_FD, Q_operand, set_offline);
   752.    end POE;
   753.
   754.    overriding
   755.    procedure POF (the_FD      : in out FD.device;
   756.                   Q_operand   : in KDF9.Q_register;
   757.                   set_offline : in Boolean) is
   758.    begin
   759.       POA(the_FD, Q_operand, set_offline);
   760.    end POF;
   761.
   762.    overriding
   763.    procedure POG (the_FD      : in out FD.device;
   764.                   Q_operand   : in KDF9.Q_register;
   765.                   set_offline : in Boolean) is
   766.       pragma Unreferenced(set_offline);
   767.    begin
   768.       validate_transfer(the_FD, Q_operand);
   769.       PO_all(the_FD, for_next_sector(the_FD, Q_operand));
   770.    end POG;
   771.
   772.    overriding
   773.    procedure POH (the_FD      : in out FD.device;
   774.                   Q_operand   : in KDF9.Q_register;
   775.                   set_offline : in Boolean) is
   776.       pragma Unreferenced(set_offline);
   777.    begin
   778.       validate_transfer(the_FD, Q_operand);
   779.       PO_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   780.    end POH;
   781.
   782.    overriding
   783.    procedure POK (the_FD      : in out FD.device;
   784.                   Q_operand   : in KDF9.Q_register;
   785.                   set_offline : in Boolean) is
   786.       pragma Unreferenced(set_offline);
   787.    begin
   788.       validate_transfer(the_FD, Q_operand);
   789.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   790.       PO_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   791.    end POK;
   792.
   793.    overriding
   794.    procedure POL (the_FD      : in out FD.device;
   795.                   Q_operand   : in KDF9.Q_register;
   796.                   set_offline : in Boolean) is
   797.       pragma Unreferenced(set_offline);
   798.    begin
   799.       validate_transfer(the_FD, Q_operand);
   800.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   801.       PO_all(the_FD, for_next_sector(the_FD, Q_operand));
   802.    end POL;
   803.
   804.    overriding
   805.    procedure Finalize (the_FD : in out FD.device) is
   806.       buffer : constant String := oct_of(KDF9.Q_part(the_FD.number), 2);
   807.    begin
   808.       if the_FD.is_open then
   809.          if (the_final_state_is_wanted and the_log_is_wanted)    and then
   810.                (the_FD.word_count /= 0 or the_FD.latency_count /= 0  or
   811.                 the_FD.seek_count /= 0 or the_FD.switch_time   /= 0) then
   812.             log_line
   813.                    (
   814.                     the_FD.device_name
   815.                   & " on buffer #"
   816.                   & buffer
   817.                   & " spent:"
   818.                    );
   819.             log_line
   820.                    (
   821.                     "    "
   822.                   & just_right(KDF9.us'Image(the_FD.data_time / 1_000), 6)
   823.                   & " ms in"
   824.                   & the_FD.latency_count'Image
   825.                   & " data transfer" & plurality(the_FD.latency_count)
   826.                   & " totalling"
   827.                   & KDF9.word'Image(the_FD.word_count)
   828.                   & " word" & plurality(the_FD.word_count)
   829.                   & ","
   830.                    );
   831.             log_line
   832.                    (
   833.                     "    "
   834.                   & just_right(KDF9.us'Image(the_FD.switch_time / 1_000), 6)
   835.                   & " ms in"
   836.                   & the_FD.switch_count'Image
   837.                   & plurality(the_FD.switch_count, " platter switch", " platter switches")
   838.                   & ","
   839.                    );
   840.             log_line
   841.                    (
   842.                     "    "
   843.                   & just_right(KDF9.us'Image(the_FD.latency_time / 1_000), 6)
   844.                   & " ms in"
   845.                   & the_FD.latency_count'Image
   846.                   & plurality(the_FD.latency_count, " rotational latency", " rotational latencies")
   847.                   & ", and"
   848.                    );
   849.             log_line
   850.                    (
   851.                     "    "
   852.                   & just_right(KDF9.us'Image(the_FD.seek_time / 1_000), 6)
   853.                   & " ms in"
   854.                   & the_FD.seek_count'Image
   855.                   & " seek" & plurality(the_FD.seek_count) & "."
   856.                    );
   857.          end if;
   858.          IOC.device(the_FD).Finalize;
   859.          close(the_FD);
   860.       end if;
   861.    exception
   862.       when error : others =>
   863.          raise emulation_failure
   864.             with "Finalizing FD buffer #" & buffer & "; " & Ada.Exceptions.Exception_Message(error);
   865.    end Finalize;
   866.
   867.    FD_quantum : constant := (1E6 + outer_rate - 1) / outer_rate;
   868.
   869.    type FD_access is access FD.device;
   870.
   871.    FD0 : FD_access with Warnings => Off;
   872.
   873.    procedure enable (b : in KDF9.buffer_number) is
   874.    begin
   875.       if FD0_is_enabled then
   876.          trap_operator_error("more than one FD control unit has been configured");
   877.       end if;
   878.       FD0 := new FD.device (number  => b,
   879.                             kind    => FD_kind,
   880.                             unit    => 0,
   881.                             quantum => FD_quantum);
   882.       FD0_is_enabled := True;
   883.       FD0_number := b;
   884.    end enable;
   885.
   886.    procedure re_enable (b : in KDF9.buffer_number) is
   887.    begin
   888.       if FD0 /= null    and then
   889.             b = FD0.number  then
   890.          return;
   891.       end if;
   892.       buffer(b) := null;
   893.       FD0 := null;
   894.       FD0_number := 0;
   895.       FD0_is_enabled := False;
   896.       enable(b);
   897.    end re_enable;
   898.
   899.    procedure disable (b : in KDF9.buffer_number) is
   900.    begin
   901.       if FD0 /= null    and then
   902.             b = FD0.number  then
   903.          buffer(b) := null;
   904.          FD0 := null;
   905.          FD0_number := 0;
   906.          FD0_is_enabled := False;
   907.       end if;
   908.    end disable;
   909.
   910. end IOC.fast.FD;

Compiling: ../Source/ioc-fast-fd.ads
Source file time stamp: 2021-02-04 14:32:01
Compiled at: 2021-02-08 17:20:59

     1. -- Emulation of a fixed disc drive.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.FD is
    18.
    19.    type device is new IOC.fast.device with private;
    20.
    21.    overriding
    22.    procedure PIA (the_FD      : in out FD.device;
    23.                   Q_operand   : in KDF9.Q_register;
    24.                   set_offline : in Boolean);
    25.
    26.    overriding
    27.    procedure PIB (the_FD      : in out FD.device;
    28.                   Q_operand   : in KDF9.Q_register;
    29.                   set_offline : in Boolean);
    30.
    31.    overriding
    32.    procedure PIC (the_FD      : in out FD.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    overriding
    37.    procedure PID (the_FD      : in out FD.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    overriding
    42.    procedure PIE (the_FD      : in out FD.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    overriding
    47.    procedure PIF (the_FD      : in out FD.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    overriding
    52.    procedure PIG (the_FD      : in out FD.device;
    53.                   Q_operand   : in KDF9.Q_register;
    54.                   set_offline : in Boolean);
    55.
    56.    overriding
    57.    procedure PIH (the_FD      : in out FD.device;
    58.                   Q_operand   : in KDF9.Q_register;
    59.                   set_offline : in Boolean);
    60.
    61.    overriding
    62.    procedure PMA (the_FD      : in out FD.device;
    63.                   Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean);
    65.
    66.    overriding
    67.    procedure PMB (the_FD      : in out FD.device;
    68.                   Q_operand   : in KDF9.Q_register;
    69.                   set_offline : in Boolean);
    70.
    71.    overriding
    72.    procedure PMC (the_FD      : in out FD.device;
    73.                   Q_operand   : in KDF9.Q_register;
    74.                   set_offline : in Boolean);
    75.
    76.    overriding
    77.    procedure PMD (the_FD      : in out FD.device;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    overriding
    82.    procedure PMF (the_FD      : in out FD.device;
    83.                   Q_operand   : in KDF9.Q_register;
    84.                   set_offline : in Boolean);
    85.
    86.    overriding
    87.    procedure POA (the_FD      : in out FD.device;
    88.                   Q_operand   : in KDF9.Q_register;
    89.                   set_offline : in Boolean);
    90.
    91.    overriding
    92.    procedure POB (the_FD      : in out FD.device;
    93.                   Q_operand   : in KDF9.Q_register;
    94.                   set_offline : in Boolean);
    95.
    96.    overriding
    97.    procedure POC (the_FD      : in out FD.device;
    98.                   Q_operand   : in KDF9.Q_register;
    99.                   set_offline : in Boolean);
   100.
   101.    overriding
   102.    procedure POD (the_FD      : in out FD.device;
   103.                   Q_operand   : in KDF9.Q_register;
   104.                   set_offline : in Boolean);
   105.
   106.    overriding
   107.    procedure POE (the_FD      : in out FD.device;
   108.                   Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean);
   110.
   111.    overriding
   112.    procedure POF (the_FD      : in out FD.device;
   113.                   Q_operand   : in KDF9.Q_register;
   114.                   set_offline : in Boolean);
   115.
   116.    overriding
   117.    procedure POG (the_FD      : in out FD.device;
   118.                   Q_operand   : in KDF9.Q_register;
   119.                   set_offline : in Boolean);
   120.
   121.    overriding
   122.    procedure POH (the_FD      : in out FD.device;
   123.                   Q_operand   : in KDF9.Q_register;
   124.                   set_offline : in Boolean);
   125.
   126.    overriding
   127.    procedure POK (the_FD      : in out FD.device;
   128.                   Q_operand   : in KDF9.Q_register;
   129.                   set_offline : in Boolean);
   130.
   131.    overriding
   132.    procedure POL (the_FD      : in out FD.device;
   133.                   Q_operand   : in KDF9.Q_register;
   134.                   set_offline : in Boolean);
   135.
   136.    FD0_is_enabled : Boolean := False;
   137.
   138.    procedure enable (b : in KDF9.buffer_number);
   139.
   140.    procedure re_enable (b : in KDF9.buffer_number);
   141.
   142.    procedure disable (b : in KDF9.buffer_number);
   143.
   144.    function as_FD_command (Q_operand : KDF9.Q_register; for_seek, for_FH : Boolean := False)
   145.    return String;
   146.
   147. private
   148.
   149.    words_per_sector      : constant := 40;
   150.    bytes_per_sector      : constant := 8 * words_per_sector;
   151.
   152.    type sector_data      is array (KDF9.address range 0 .. bytes_per_sector-1)
   153.                          of KDF9_char_sets.symbol;
   154.
   155.    sectors_per_seek_area  : constant := 96;
   156.    sectors_in_outer_zone  : constant := 64;
   157.
   158.    subtype sector_range  is KDF9.Q_part range 0 .. sectors_per_seek_area-1;
   159.
   160.    type sector_array     is array (KDF9.Q_part range <>) of FD.sector_data;
   161.
   162.    subtype head_range    is KDF9.Q_part range 0 .. 7;
   163.
   164.    subtype inner_track   is FD.sector_array(FD.sector_range range 0 ..  7);
   165.    subtype outer_track   is FD.sector_array(FD.sector_range range 0 .. 15);
   166.
   167.    last_sector_for_head  : constant array (FD.head_range) of FD.sector_range
   168.                          := (0 .. 3 => FD.outer_track'Last,
   169.                              4 .. 7 => FD.inner_track'Last);
   170.
   171.    type outer_data       is array (FD.head_range range 0 .. 3) of FD.outer_track;
   172.    type inner_data       is array (FD.head_range range 4 .. 7) of FD.inner_track;
   173.
   174.    -- These rates come from the Manual, §6.1.
   175.    outer_rate : constant := 84_800;          -- bytes per second in the outer zone
   176.    inner_rate : constant := outer_rate / 2;  -- bytes per second in the outer zone
   177.
   178.    type track_set is
   179.       record
   180.          outer_zone : FD.outer_data;
   181.          inner_zone : FD.inner_data;
   182.       end record;
   183.
   184.    seek_areas_per_platter  : constant := 64;
   185.    subtype seek_area_range is KDF9.Q_part range 0 .. seek_areas_per_platter-1;
   186.
   187.    main_discs_per_drive    : constant := 16;
   188.    the_fixed_head_platter  : constant := 16;
   189.    platters_per_drive      : constant := main_discs_per_drive + 1;
   190.
   191.    subtype platter_range   is KDF9.Q_part range 0 .. platters_per_drive-1;
   192.
   193.    -- The Eldon 2 KDF9 at Leeds University had a 2-drive disc system.
   194.    -- This allows for the maximum number of drives possible.
   195.    number_of_drives : constant := 4;
   196.
   197.    subtype drive_range is KDF9.Q_part range 0 .. number_of_drives-1;
   198.
   199.    type locus is
   200.       record
   201.          drive_number      : FD.drive_range     := 0;
   202.          platter_number    : FD.platter_range   := 0;
   203.          seek_area_number  : FD.seek_area_range := 0;
   204.          sector_number     : FD.sector_range    := 0;
   205.          has_fixed_heads,
   206.          is_at_end_of_area : Boolean            := False;
   207.       end record;
   208.
   209.    -- The disc storage is actually implemented in an external file.
   210.    -- The comb and locus variables shadow the physical state of the drives.
   211.    -- They are used to derive a file address from the position established
   212.    --    by seek and transfer operations.
   213.
   214.    type comb_data is array (FD.drive_range, FD.platter_range) of FD.seek_area_range;
   215.
   216.    type device is new IOC.fast.device with
   217.       record
   218.          comb         : FD.comb_data := (others => (others => 0));
   219.          locus,
   220.          target       : FD.locus;
   221.          data_time,
   222.          seek_time    : KDF9.us := 0;
   223.          seek_count,
   224.          sector_count : KDF9.word := 0;
   225.       end record;
   226.
   227.    overriding
   228.    procedure Initialize (the_FD : in out FD.device);
   229.
   230.    overriding
   231.    procedure Finalize (the_FD : in out FD.device);
   232.
   233.    FD0_number : KDF9.buffer_number := 0;
   234.
   235. end IOC.fast.FD;

 910 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-mt.adb
Source file time stamp: 2021-02-07 23:28:06
Compiled at: 2021-02-08 17:21:00

     1. -- Emulation of magnetic tape decks and buffers.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. with Ada.IO_Exceptions;
    19. --
    20. with HCI;
    21. with tracing;
    22.
    23. use  HCI;
    24. use  tracing;
    25.
    26. package body IOC.fast.MT is
    27.
    28.    --
    29.    -- Ada direct-access file management.
    30.    --
    31.
    32.    procedure open_RO (the_tape : in out MT.file; name : in String) is
    33.    begin
    34.       MT_slice_IO.Open(the_tape.reel, In_File, name);
    35.       the_tape.has_a_WP_ring := False;
    36.    exception
    37.       when others =>
    38.          trap_operator_error("'" & name & "' cannot be opened for reading or writing");
    39.    end open_RO;
    40.
    41.    procedure open_RW (the_tape : in out MT.file; name : in String) is
    42.    begin
    43.       MT_slice_IO.Open(the_tape.reel, Inout_File, name);
    44.       the_tape.has_a_WP_ring := True;
    45.    exception
    46.       when Ada.IO_Exceptions.Use_Error =>
    47.          the_tape.has_a_WP_ring := False;
    48.          open_RO(the_tape, name);
    49.       when Ada.IO_Exceptions.Name_Error =>
    50.          trap_operator_error("'" & name & "' cannot be found");
    51.       when error : others =>
    52.          trap_operator_error("'" & name & "' open failed: " &  Ada.Exceptions.Exception_Message(error));
    53.    end open_RW;
    54.
    55.    procedure close (the_tape : in out MT.file) is
    56.    begin
    57.       if the_tape.has_a_WP_ring then
    58.          MT_slice_IO.Flush(the_tape.reel);
    59.       end if;
    60.       MT_slice_IO.Close(the_tape.reel);
    61.    end close;
    62.
    63.    function is_open (the_tape : in MT.file)
    64.    return Boolean
    65.    is (Is_Open(the_tape.reel));
    66.
    67.    -- Slice management.
    68.
    69.    end_of_tape : exception;
    70.
    71.    procedure write_slice (the_tape : in out MT.file;
    72.                           slice    : in MT.slice) is
    73.    begin
    74.       the_tape.position := the_tape.position + 1;
    75.       MT_slice_IO.Write(the_tape.reel, slice, to => the_tape.position);
    76.       if slice.kind not in tape_gap_kind then
    77.          the_tape.last_data_index := Count'Max(the_tape.last_data_index, the_tape.position);
    78.       end if;
    79.    exception
    80.       when End_Error =>
    81.          raise emulation_failure with "End_Error writing MT slice";
    82.    end write_slice;
    83.
    84.    procedure read_next_slice (the_tape : in out MT.file;
    85.                               slice    : out MT.slice) is
    86.    begin
    87.       if the_tape.last_data_index > 0 then
    88.          the_tape.position := the_tape.position + 1;
    89.          MT_slice_IO.Read(the_tape.reel, slice, from => the_tape.position);
    90.       else
    91.          raise end_of_tape with "read_next_slice";
    92.       end if;
    93.     exception
    94.        when End_Error =>
    95.           raise emulation_failure with "End_Error reading MT slice";
    96.    end read_next_slice;
    97.
    98.    procedure read_prev_slice (the_tape : in out MT.file;
    99.                               slice    : out MT.slice) is
   100.    begin
   101.       if the_tape.position > 0 then
   102.          MT_slice_IO.Read(the_tape.reel, slice, from => the_tape.position);
   103.          the_tape.position := the_tape.position - 1;
   104.       else
   105.          raise end_of_tape with "read_prev_slice";
   106.       end if;
   107.     exception
   108.        when End_Error =>
   109.           raise end_of_tape with "End_Error reading MT slice number";
   110.    end read_prev_slice;
   111.
   112.    procedure bound_the_written_data (the_tape : in out MT.file) is
   113.       the_slice : MT.slice;
   114.    begin
   115.       the_tape.position := Size(the_tape.reel);
   116.       if the_tape.position = 0 then
   117.          -- There is no data in the file.
   118.          the_tape.last_data_index := 0;
   119.          return;
   120.       end if;
   121.       -- Locate the last data slice (if any).
   122.       while the_tape.position > 0 loop
   123.          read_prev_slice(the_tape, the_slice);
   124.       exit when the_slice.kind not in MT.tape_gap_kind;
   125.       end loop;
   126.       if the_slice.kind in MT.tape_gap_kind then
   127.          the_tape.last_data_index := 0;
   128.       else
   129.          the_tape.last_data_index := the_tape.position + 1;
   130.       end if;
   131.       the_tape.position := 0;
   132.    end bound_the_written_data;
   133.
   134.    procedure reset (the_deck : in out MT.deck) is
   135.     begin
   136.       bound_the_written_data(the_deck.tape);
   137.       the_deck.is_LBM_flagged := False;
   138.       the_deck.is_abnormal := False;
   139.       the_deck.unwound_frames := 0;
   140.    exception
   141.       when end_of_tape =>
   142.          the_deck.is_abnormal := True;
   143.          the_deck.is_LBM_flagged := False;
   144.          the_deck.unwound_frames := 0;
   145.    end reset;
   146.
   147.    -- Tape physical characteristics.
   148.
   149.    -- The physical end of tape (PET) is signalled one maximum block length before the tape runs out.
   150.    --  So PET is signalled at max_block_size before the absolute maximum position
   151.    --    to avoid running past the end of the tape when a very large block is written.
   152.
   153.    -- There could be as little as 60 inches of tape between the End of Tape Warning (ETW) and PET.
   154.    -- See the Manual, §22.1.3, p.182.
   155.
   156.    overriding
   157.    procedure Initialize (the_deck : in out MT.deck) is
   158.    begin
   159.       the_deck.device_name := device_name_of(the_deck);
   160.       open_RW(the_deck.tape, the_deck.device_name);
   161.       Initialize(IOC.device(the_deck));
   162.       if the_deck.kind = MT_kind then
   163.          the_deck.terminator        := End_Message;
   164.          the_deck.recording_density := max_bits_per_inch;  -- bits / inch
   165.          the_deck.max_reel_length   := max_reel_length;    -- inches
   166.       else
   167.          the_deck.terminator        := Group_Mark;
   168.          the_deck.recording_density := max_bits_per_inch/2;  -- bits / inch
   169.          the_deck.max_reel_length   := max_reel_length;      -- inches
   170.       end if;
   171.       the_deck.inter_block_gap := the_deck.recording_density / 3;
   172.       the_deck.tape_capacity   := the_deck.max_reel_length * the_deck.recording_density;
   173.       the_deck.PET_position    := the_deck.tape_capacity - max_block_size;
   174.       the_deck.ETW_position    := the_deck.PET_position - 60 * the_deck.recording_density;
   175.       reset(the_deck);
   176.    exception
   177.       when end_of_tape =>
   178.          the_deck.is_abnormal := True;
   179.    end Initialize;
   180.
   181.    function is_at_BTW (the_deck : MT.deck)
   182.    return Boolean
   183.    is (the_deck.is_open and then the_deck.tape.position = 0);
   184.
   185.    function holds_data (the_deck : MT.deck)
   186.    return Boolean
   187.    is (the_deck.is_open and then the_deck.tape.last_data_index > 0);
   188.
   189.    function is_at_ETW (the_deck : MT.deck)
   190.    return Boolean
   191.    is (the_deck.is_open and then the_deck.unwound_frames >= the_deck.ETW_position);
   192.
   193.    function is_at_PET (the_deck : MT.deck)
   194.    return Boolean
   195.    is (the_deck.is_open and then the_deck.unwound_frames >= the_deck.PET_position);
   196.
   197.    procedure deal_with_trying_to_pass_PET (the_deck : in out MT.deck;
   198.                                            do_this  : String) is
   199.    begin
   200.       if is_at_PET (the_deck) then
   201.          trap_failing_IO_operation(the_deck, "an attempt was made to " & do_this & " past PET");
   202.       end if;
   203.    end deal_with_trying_to_pass_PET;
   204.
   205.    -- There are cases that are invalid iff the tape is positioned beyond the last written block.
   206.    function is_at_EOD (the_deck : MT.deck)
   207.    return Boolean
   208.    is (the_deck.is_open and then the_deck.tape.position > the_deck.tape.last_data_index);
   209.
   210.    function tape_traversal_time (the_deck : MT.deck; tape_crossed : KDF9.word)
   211.    return KDF9.us
   212.    is (the_deck.quantum * KDF9.us(tape_crossed));
   213.
   214.    function data_transfer_time (the_deck   : MT.deck;
   215.                                 byte_count : KDF9.word)
   216.    return KDF9.us
   217.    is (the_deck.quantum * KDF9.us(byte_count));
   218.
   219.    -- This is the time the MT deck is busy traversing the interblock gap and the data block.
   220.    function MT_IO_time (the_deck  : MT.deck;
   221.                         Q_operand : in KDF9.Q_register)
   222.    return KDF9.us
   223.    is (KDF9.us(the_deck.inter_block_gap) + 8*KDF9.us(Q_operand.M-Q_operand.I+1) * the_deck.quantum);
   224.
   225.    overriding
   226.    function is_open (the_deck : MT.deck)
   227.    return Boolean
   228.    is (the_deck.tape.is_open);
   229.
   230.    overriding
   231.    function usage (the_deck : MT.deck)
   232.    return KDF9.word
   233.    is (the_deck.bytes_moved);
   234.
   235.    overriding
   236.    procedure close (the_deck : in out MT.deck) is
   237.    begin
   238.       the_deck.tape.close;
   239.    end close;
   240.
   241.    procedure update_statistics (the_deck    : in out MT.deck;
   242.                                 tape_crossed,
   243.                                 bytes_moved : in length_in_frames) is
   244.       real_time : KDF9.us;
   245.    begin
   246.       the_deck.bytes_moved := the_deck.bytes_moved + KDF9.word(bytes_moved);
   247.       real_time := tape_traversal_time(the_deck, KDF9.word(tape_crossed))
   248.                  + data_transfer_time (the_deck, KDF9.word(bytes_moved));
   249.       the_deck.elapsed_time := the_deck.elapsed_time + real_time;
   250.       add_in_the_IO_CPU_time(the_deck, KDF9.word(bytes_moved));
   251.       correct_transfer_time(the_deck, real_time);
   252.    end update_statistics;
   253.
   254.    type movement is (forwards, backwards);
   255.
   256.    procedure note_tape_position (the_deck    : in out MT.deck;
   257.                                  direction   : in MT.movement;
   258.                                  tape_crossed,
   259.                                  bytes_moved : in length_in_frames) is
   260.    begin
   261.       if direction = forwards then
   262.          the_deck.unwound_frames := the_deck.unwound_frames
   263.                                   + MT.length_in_frames(tape_crossed + bytes_moved);
   264.       elsif MT.length_in_frames(tape_crossed + bytes_moved) > the_deck.unwound_frames then
   265.          the_deck.unwound_frames := 0;
   266.       else
   267.          the_deck.unwound_frames := the_deck.unwound_frames
   268.                                   - MT.length_in_frames(tape_crossed + bytes_moved);
   269.       end if;
   270.    end note_tape_position;
   271.
   272.    -- KDF9 MT operations.
   273.
   274.    -- Skip back over erased tape, leaving the_slice containing the next preceding data.
   275.    -- Postcondition: the_deck.is_at_BTW or else the_slice.kind not in tape_gap_kind
   276.    procedure skip_back_over_erasure (the_deck  : in out MT.deck;
   277.                                      the_slice : in out MT.slice;
   278.                                      crossed   : in out length_in_frames) is
   279.    begin
   280.       if the_deck.is_at_BTW then
   281.          return; -- We are as far back as we can go;
   282.       end if;
   283.       if the_slice.kind in data_kind then
   284.          return;  -- We have already found the preceding data block.
   285.       end if;
   286.       loop
   287.          read_prev_slice(the_deck.tape, the_slice);
   288.       exit when the_deck.is_at_BTW or else the_slice.kind not in tape_gap_kind;
   289.          crossed := crossed + the_slice.size;
   290.       end loop;
   291.    end skip_back_over_erasure;
   292.
   293.    -- Skip forward over erased tape, leaving the_slice containing the next following data.
   294.    -- Postcondition: the_deck.is_at_EOD or else the_slice.kind not in tape_gap_kind
   295.    procedure skip_forward_over_erasure (the_deck  : in out MT.deck;
   296.                                         the_slice : in out MT.slice;
   297.                                         crossed   : in out length_in_frames) is
   298.    begin
   299.       if the_slice.kind in data_slice then
   300.          return;
   301.       end if;
   302.       loop
   303.          read_next_slice(the_deck.tape, the_slice);
   304.       exit when the_deck.is_at_EOD or else the_slice.kind not in MT.tape_gap_kind;
   305.          crossed := crossed + the_slice.size;
   306.       end loop;
   307.    exception
   308.       when end_of_tape =>
   309.          the_deck.is_abnormal := True;
   310.          raise end_of_tape with "in skip_forward_over_erasure";
   311.    end skip_forward_over_erasure;
   312.
   313.    -- Deal with blocks of invalid sizes.
   314.    -- 1081 buffers always write and read a whole number of words;
   315.    --    see Manual §22.1.5, p184, ¶2; and Appendix 7 ¶3, p318.
   316.    -- §3.4.7 of the EGDON 3 manual says that the 7-track tape buffer, due to a hardware
   317.    --    limitation, rejects blocks (other than tape marks) of less than 6 characters.
   318.    procedure handle_any_abnormality (the_deck : in out MT.deck;
   319.                                      the_size : in length_in_frames) is
   320.    begin
   321.       case the_deck.kind is
   322.          when MT_kind =>
   323.             the_deck.is_abnormal := the_deck.is_abnormal or (the_size mod 8 /= 0);
   324.          when ST_kind =>
   325.             the_deck.is_abnormal := the_deck.is_abnormal or (the_size < 6);
   326.          when others  =>
   327.             raise emulation_failure
   328.                with "handle_any_abnormality with a deck kind given as "
   329.                   & the_deck.kind'Image
   330.                   & " by "
   331.                   & the_deck.device_name
   332.                   & " with block size"
   333.                   & the_size'Image;
   334.       end case;
   335.    end handle_any_abnormality;
   336.
   337.    procedure read_block (the_deck  : in out MT.deck;
   338.                          the_data  : out MT.block_storage;
   339.                          the_size  : out length_in_frames;
   340.                          direction : in movement := forwards) is
   341.
   342.       left,
   343.       right      : length_in_frames := 1;
   344.       block_size,
   345.       crossed    : length_in_frames := 0;
   346.       is_last,
   347.       is_flagged : Boolean := False;
   348.       the_slice  : MT.slice := a_NULL_slice;
   349.    begin
   350.       the_deck.is_LBM_flagged := False;
   351.
   352.       skip_forward_over_erasure(the_deck, the_slice, crossed);
   353.
   354.       -- Ensure that we are not beyond the end of valid data.
   355.       if the_deck.is_at_EOD then
   356.          trap_failing_IO_operation(
   357.                                    the_deck,
   358.                                    "there is no data past slice" & the_deck.tape.position'Image
   359.                                   );
   360.       end if;
   361.
   362.       if the_slice.kind in MT.tape_mark_kind then
   363.          -- Deal with a tape mark block; according to the Maual, Appendix 7, §2, p.317,
   364.          --    it reads as a single character with value #17.
   365.          block_size := 8;
   366.          the_data(1)    := KDF9_char_sets.TP_CN(KDF9_char_sets.Tape_Mark);
   367.          the_data(2..8) := (others => KDF9_char_sets.TP_CN(KDF9_char_sets.Blank_Space));
   368.          the_deck.is_LBM_flagged := True;
   369.       else
   370.          -- We have a bona fide data block.
   371.          the_size := 0;
   372.          -- Accumulate a series of slicefuls.
   373.          loop
   374.             right := left + the_slice.size - 1;
   375.             the_data(left .. right) := the_slice.data(1..the_slice.size);
   376.             block_size := block_size + the_slice.size;
   377.             left := left + the_slice.size;
   378.             is_flagged := is_flagged or the_slice.is_LBM_flagged;
   379.             is_last  := the_slice.is_last;
   380.          exit when is_last or block_size = max_block_size;
   381.             read_next_slice(the_deck.tape, the_slice);
   382.          end loop;
   383.          the_deck.is_LBM_flagged := is_flagged;
   384.       end if;
   385.       the_size := block_size;
   386.
   387.       note_tape_position(the_deck, direction,
   388.                         crossed + the_deck.inter_block_gap, bytes_moved => the_size);
   389.       update_statistics(the_deck,
   390.                         crossed + the_deck.inter_block_gap, bytes_moved => the_size);
   391.
   392.      if not is_last and block_size = max_block_size then
   393.          raise emulation_failure with block_size'Image & " > max_block_size in MT read_block";
   394.       end if;
   395.       handle_any_abnormality(the_deck, block_size);
   396.    end read_block;
   397.
   398.    procedure increment (word_address : in out KDF9.address;
   399.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   400.    begin
   401.       if symbol_nr < 7 then
   402.          symbol_nr := symbol_nr + 1;
   403.       else
   404.          symbol_nr := 0;
   405.          word_address := word_address + 1;
   406.       end if;
   407.    end increment;
   408.
   409.    tape_mark_data_word : constant KDF9.word := 8#17_00_00_00_00_00_00_00#;
   410.
   411.    procedure read (the_deck       : in out MT.deck;
   412.                    Q_operand      : in KDF9.Q_register;
   413.                    to_terminator  : in Boolean := False) is
   414.       start_address : constant KDF9.address := Q_operand.I;
   415.       end_address   : constant KDF9.address := Q_operand.M;
   416.       the_data : MT.block_storage;
   417.       s        : KDF9_char_sets.symbol_index;
   418.       w        : KDF9.address;
   419.       stored   : KDF9.word := 0;
   420.       the_size : length_in_frames;
   421.    begin
   422.       validate_device(the_deck, Q_operand);
   423.       check_addresses_and_lockouts(start_address, end_address);
   424.
   425.       read_block(the_deck, the_data, the_size);
   426.
   427.       if the_size mod 8 /= 0 and the_deck.kind = MT_kind then
   428.          -- Disregard an incomplete final word; see Manual, §22.1.5, p184, ¶2.
   429.          the_deck.is_abnormal := True;
   430.          the_size := the_size - the_size mod 8;
   431.       end if;
   432.
   433.       -- Store the relevant words.
   434.       w := start_address;
   435.       s := 0;
   436.       for i in 1 .. the_size loop
   437.          if s = 0 then
   438.             store_word(0, w);
   439.          end if;
   440.          store_symbol(CN_TR(the_data(i)), w, s);
   441.          stored := stored + 1;
   442.       exit when (w = end_address) and (s = 7);
   443.       exit when to_terminator and CN_TR(the_data(i)) = the_deck.terminator;
   444.          increment(w, s);
   445.       end loop;
   446.       if to_terminator then
   447.          correct_transfer_time(the_deck, stored);
   448.       end if;
   449.    exception
   450.       when end_of_tape =>
   451.          deal_with_trying_to_pass_PET(the_deck, "reading");
   452.    end read;
   453.
   454.    procedure find_start_of_earlier_block (the_deck : in out MT.deck;
   455.                                           crossed  : in out length_in_frames) is
   456.       the_slice  : MT.slice := a_NULL_slice;
   457.       block_size : length_in_frames;
   458.    begin
   459.       if the_deck.is_at_BTW then
   460.          return; -- We have already gone as far back as possible.
   461.       end if;
   462.
   463.       -- Skip back over any erasures or tape marks.
   464.       skip_back_over_erasure(the_deck, the_slice, crossed);
   465.       crossed := crossed + the_deck.inter_block_gap;
   466.
   467.       if the_deck.is_at_BTW and the_slice.kind in tape_gap_kind then
   468.          the_deck.is_abnormal := True;
   469.          -- This cannot happen if the tape has (at least) a label.
   470.          raise emulation_failure with "no earlier block, at BTW on " & the_deck.device_name;
   471.       end if;
   472.
   473.       if not the_slice.is_last then
   474.          raise emulation_failure
   475.             with "find_start_of_earlier_block at slice "
   476.                & the_deck.tape.position'Image
   477.                & " of "
   478.                & the_deck.device_name
   479.                & " failed to locate the last slice of a block";
   480.       end if;
   481.
   482.       -- We have reached the last slice of the block.
   483.       if the_deck.kind = ST_kind and the_slice.kind in tape_mark_kind then
   484.          block_size := 1;
   485.       else
   486.          block_size := the_slice.size;
   487.          -- Jump backwards over data slices until we reach the first of the block.
   488.          while not the_slice.is_first and then the_deck.tape.position > 0 loop
   489.             read_prev_slice(the_deck.tape, the_slice);
   490.             block_size := block_size + the_slice.size;
   491.          end loop;
   492.          handle_any_abnormality(the_deck, block_size);
   493.       end if;
   494.
   495.       crossed := crossed + block_size;
   496.    end find_start_of_earlier_block;
   497.
   498.    procedure decrement (word_address : in out KDF9.address;
   499.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   500.    begin
   501.       if symbol_nr > 0 then
   502.          symbol_nr := symbol_nr - 1;
   503.       else
   504.          symbol_nr := 7;
   505.          word_address := word_address + 1;
   506.       end if;
   507.    end decrement;
   508.
   509.    procedure read_backwards (the_deck       : in out MT.deck;
   510.                              Q_operand      : in KDF9.Q_register;
   511.                              to_terminator  : in Boolean := False) is
   512.       start_address : constant KDF9.address := Q_operand.I;
   513.       end_address   : constant KDF9.address := Q_operand.M;
   514.       terminator    : constant KDF9_char_sets.symbol := the_deck.terminator;
   515.       the_data  : MT.block_storage;
   516.       s         : KDF9_char_sets.symbol_index;
   517.       w         : KDF9.address;
   518.       the_first,
   519.       the_last  : length_in_frames;
   520.       crossed   : length_in_frames := 0 with Warnings => Off;  -- Because its value is never used.
   521.    begin
   522.       validate_device(the_deck, Q_operand);
   523.       check_addresses_and_lockouts(start_address, end_address);
   524.
   525.       -- Locate the start of the previous block.
   526.       find_start_of_earlier_block(the_deck, crossed);
   527.
   528.       -- Read it normally, i.e. forwards.
   529.       read_block(the_deck, the_data, the_last, backwards);
   530.
   531.       -- And retrace our steps, to position the tape as if the block had been read backwards.
   532.       find_start_of_earlier_block(the_deck, crossed);
   533.
   534.       -- Disregard an incomplete first word; see Manual §22.1.5, p184, ¶2; and Appendix 7 ¶3, p318.
   535.       if the_last mod 8 = 0 or the_deck.kind = ST_kind then
   536.          the_first := the_data'First;
   537.       elsif the_last = 1 and the_deck.kind = ST_kind then
   538.          -- See Manual, Appendix 7 ¶2, p317.
   539.          store_word(tape_mark_data_word, start_address);
   540.       else
   541.          the_deck.is_abnormal := True;
   542.          the_first := the_data'First + the_last mod 8;
   543.       end if;
   544.
   545.       -- Store the relevant words.
   546.       w := start_address;
   547.       s := 7;
   548.       for i in reverse the_first .. the_last loop
   549.          if s = 7 then
   550.             store_word(0, w);
   551.          end if;
   552.          store_symbol(CN_TR(the_data(i)), w, s);
   553.       exit when to_terminator and CN_TR(the_data(i)) = terminator;
   554.          decrement(w, s);
   555.       end loop;
   556.    end read_backwards;
   557.
   558.    -- MFRQq
   559.    overriding
   560.    procedure PIA (the_deck    : in out MT.deck;
   561.                   Q_operand   : in KDF9.Q_register;
   562.                   set_offline : in Boolean) is
   563.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   564.    begin
   565.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   566.       read(the_deck, Q_operand, to_terminator => False);
   567.       lock_out_relative_addresses(Q_operand);
   568.    end PIA;
   569.
   570.    -- MFREQq
   571.    overriding
   572.    procedure PIB (the_deck    : in out MT.deck;
   573.                   Q_operand   : in KDF9.Q_register;
   574.                   set_offline : in Boolean) is
   575.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   576.    begin
   577.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   578.       read(the_deck, Q_operand, to_terminator => True);
   579.       lock_out_relative_addresses(Q_operand);
   580.    end PIB;
   581.
   582.    -- as PIA
   583.    overriding
   584.    procedure PIC (the_deck    : in out MT.deck;
   585.                   Q_operand   : in KDF9.Q_register;
   586.                   set_offline : in Boolean) is
   587.    begin
   588.       the_deck.PIA(Q_operand, set_offline);
   589.    end PIC;
   590.
   591.    -- as PIB
   592.    overriding
   593.    procedure PID (the_deck    : in out MT.deck;
   594.                   Q_operand   : in KDF9.Q_register;
   595.                   set_offline : in Boolean) is
   596.    begin
   597.       the_deck.PIB(Q_operand, set_offline);
   598.    end PID;
   599.
   600.    -- MBRQq
   601.    overriding
   602.    procedure PIE (the_deck    : in out MT.deck;
   603.                   Q_operand   : in KDF9.Q_register;
   604.                   set_offline : in Boolean) is
   605.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   606.    begin
   607.       if the_deck.is_at_BTW then
   608.          trap_illegal_instruction("MBRQq at BTW on " & the_deck.device_name);
   609.       end if;
   610.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   611.       read_backwards(the_deck, Q_operand, to_terminator => False);
   612.       if the_deck.kind = ST_kind then
   613.          the_deck.is_LBM_flagged := False;
   614.       end if;
   615.       lock_out_relative_addresses(Q_operand);
   616.    end PIE;
   617.
   618.    -- MBREQq
   619.    overriding
   620.    procedure PIF (the_deck    : in out MT.deck;
   621.                   Q_operand   : in KDF9.Q_register;
   622.                   set_offline : in Boolean) is
   623.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   624.    begin
   625.       if the_deck.is_at_BTW then
   626.          trap_illegal_instruction("MBREQq at BTW on " & the_deck.device_name);
   627.       end if;
   628.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   629.       read_backwards(the_deck, Q_operand, to_terminator => True);
   630.       if the_deck.kind = ST_kind then
   631.          the_deck.is_LBM_flagged := False;
   632.       end if;
   633.       lock_out_relative_addresses(Q_operand);
   634.    end PIF;
   635.
   636.    -- as PIE
   637.    overriding
   638.    procedure PIG (the_deck    : in out MT.deck;
   639.                   Q_operand   : in KDF9.Q_register;
   640.                   set_offline : in Boolean) is
   641.    begin
   642.       the_deck.PIE(Q_operand, set_offline);
   643.    end PIG;
   644.
   645.    -- as PIF
   646.    overriding
   647.    procedure PIH (the_deck    : in out MT.deck;
   648.                   Q_operand   : in KDF9.Q_register;
   649.                   set_offline : in Boolean) is
   650.    begin
   651.       the_deck.PIF(Q_operand, set_offline);
   652.    end PIH;
   653.
   654.    procedure find_start_of_later_block (the_deck : in out MT.deck;
   655.                                         crossed  : in out length_in_frames) is
   656.       the_slice  : MT.slice := a_NULL_slice;
   657.       block_size : length_in_frames := 0;
   658.    begin
   659.       -- Skip over any erasures or tape marks.
   660.       skip_forward_over_erasure(the_deck, the_slice, crossed);
   661.       crossed := crossed + the_deck.inter_block_gap;
   662.
   663.       if not the_slice.is_first then
   664.          raise emulation_failure
   665.             with "find_start_of_later_block at slice"
   666.                & the_deck.tape.position'Image
   667.                & " of "
   668.                & the_deck.device_name
   669.                & " failed to locate the first slice of a block";
   670.       end if;
   671.
   672.       -- We have reached the first slice of the block.
   673.       if the_deck.kind = ST_kind and the_slice.kind in tape_mark_kind then
   674.          block_size := 1;
   675.       else
   676.          block_size := the_slice.size;
   677.          -- Ignore data slices until we get to the last slice of the block.
   678.          while not the_slice.is_last loop
   679.             read_next_slice(the_deck.tape, the_slice);
   680.             block_size := block_size + the_slice.size;
   681.          end loop;
   682.          handle_any_abnormality(the_deck, block_size);
   683.       end if;
   684.
   685.       the_deck.is_LBM_flagged := the_slice.is_LBM_flagged;
   686.       crossed := crossed + block_size;
   687.    exception
   688.       when end_of_tape =>
   689.          the_deck.is_abnormal := True;
   690.          raise end_of_tape with "find_start_of_later_block";
   691.    end find_start_of_later_block;
   692.
   693.    procedure skip_forwards (the_deck       : in out MT.deck;
   694.                             blocks_skipped : in KDF9.word) is
   695.       crossed : length_in_frames := 0;
   696.    begin
   697.       for i in 1 .. blocks_skipped loop
   698.          find_start_of_later_block(the_deck, crossed);
   699.       -- MFSKQq stops at an LBM-flagged block, or on count expiry.
   700.       -- Unlike MBSKQq it does record having seen an LBM-flagged block during the skipping.
   701.       -- See the Manual, §22.1.3, p.183, ¶1 and §22.1.9, p.188, ¶-2.
   702.       exit when the_deck.is_LBM_flagged;
   703.       end loop;
   704.       note_tape_position(the_deck, forwards, crossed, bytes_moved => 0);
   705.       update_statistics(the_deck, crossed, bytes_moved => 0);
   706.    end skip_forwards;
   707.
   708.    -- MFSKQq
   709.    overriding
   710.    procedure PMA (the_deck    : in out MT.deck;
   711.                   Q_operand   : in KDF9.Q_register;
   712.                   set_offline : in Boolean) is
   713.    begin
   714.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   715.       if Q_operand.M = 0 then
   716.          skip_forwards(the_deck, 32768);  -- See Manual §22.1.9, p188, ¶1.
   717.       else
   718.          require_positive_count(Q_operand.M);
   719.          skip_forwards(the_deck, KDF9.word(Q_operand.M));
   720.       end if;
   721.    end PMA;
   722.
   723.    -- MBTQq
   724.    overriding
   725.    procedure PMB (the_deck    : in out MT.deck;
   726.                   Q_operand   : in KDF9.Q_register;
   727.                   set_offline : in Boolean) is
   728.    begin
   729.       validate_device(the_deck, Q_operand);
   730.       validate_parity(the_deck);
   731.       deal_with_a_busy_device(the_deck, 14, set_offline);
   732.       the_T_bit_is_set := the_deck.is_at_BTW and the_deck.holds_data;
   733.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   734.    end PMB;
   735.
   736.    -- MLBQq
   737.    overriding
   738.    procedure PMC (the_deck    : in out MT.deck;
   739.                   Q_operand   : in KDF9.Q_register;
   740.                   set_offline : in Boolean) is
   741.    begin
   742.       validate_device(the_deck, Q_operand);
   743.       validate_parity(the_deck);
   744.       deal_with_a_busy_device(the_deck, 14, set_offline);
   745.       the_T_bit_is_set := the_deck.is_LBM_flagged;
   746.       the_deck.is_LBM_flagged := False;
   747.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   748.    end PMC;
   749.
   750.    procedure skip_backwards (the_deck       : in out MT.deck;
   751.                              blocks_skipped : in KDF9.word) is
   752.       crossed : length_in_frames := 0;
   753.    begin
   754.       for i in 1 .. blocks_skipped loop
   755.       exit when the_deck.is_at_BTW;  -- I.e., the tape is fully rewound.
   756.          find_start_of_earlier_block(the_deck, crossed);
   757.       -- MBSKQq does not stop at an LBM-flagged block, only at BTW or count expiry.
   758.       -- It ignores LBM flags encountered during the skipping.
   759.       -- See the Manual, §22.1.3, p.183, ¶1 and §22.1.9, p.188, ¶-2.
   760.       end loop;
   761.       note_tape_position(the_deck, backwards, crossed, bytes_moved => 0);
   762.       update_statistics(the_deck, crossed, bytes_moved => 0);
   763.    end skip_backwards;
   764.
   765.    -- MRWDQq
   766.    overriding
   767.    procedure PMD (the_deck    : in out MT.deck;
   768.                   Q_operand   : in KDF9.Q_register;
   769.                   set_offline : in Boolean) is
   770.       byte_count,
   771.       tape_length : length_in_frames := 0;
   772.       the_slice   : MT.slice;
   773.    begin  -- PMD
   774.       the_deck.is_abnormal := False;  -- See Manual §22.1.9, p.189, ¶-2.
   775.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   776.       -- No motion takes place if the tape is at BTW; see Manual §22.1.9, p.190, ¶1.
   777.       if the_deck.tape.position > 0 then
   778.          -- Make sure we dont try to read past the end of data.
   779.          -- Spool back to the BTW, accumulating distances.
   780.          while the_deck.tape.position > 0 loop
   781.             read_prev_slice(the_deck.tape, the_slice);
   782.             case the_slice.kind is
   783.                when data_slice =>
   784.                   byte_count := byte_count + the_slice.size;
   785.                   if the_slice.is_first then
   786.                      tape_length := tape_length + the_deck.inter_block_gap;
   787.                   end if;
   788.                when GAP_slice
   789.                   | WIPE_slice =>
   790.                   tape_length := tape_length + the_slice.size;
   791.                when others =>
   792.                   null;
   793.             end case;
   794.          end loop;
   795.       else
   796.          -- No motion takes place; see Manual §22.1.9, p.190, ¶1.
   797.          null;
   798.       end if;
   799.
   800.       update_statistics(the_deck, tape_length + byte_count, bytes_moved => 0);
   801.
   802.       reset(the_deck);
   803.    end PMD;
   804.
   805.    -- MBSKQq
   806.    overriding
   807.    procedure PME (the_deck    : in out MT.deck;
   808.                   Q_operand   : in KDF9.Q_register;
   809.                   set_offline : in Boolean) is
   810.    begin
   811.       if the_deck.is_at_BTW then
   812.          trap_illegal_instruction("MBSKQq at BTW on " & the_deck.device_name);
   813.       end if;
   814.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   815.       if Q_operand.M = 0 then
   816.          skip_backwards(the_deck, 32768);  -- See Manual §22.1.9, p188, ¶1.
   817.       else
   818.          require_positive_count(Q_operand.M);
   819.          skip_backwards(the_deck, KDF9.word(Q_operand.M));
   820.       end if;
   821.    end PME;
   822.
   823.    -- METQq
   824.    overriding
   825.    procedure PMF (the_deck    : in out MT.deck;
   826.                   Q_operand   : in KDF9.Q_register;
   827.                   set_offline : in Boolean) is
   828.    begin
   829.       validate_device(the_deck, Q_operand);
   830.       validate_parity(the_deck);
   831.       deal_with_a_busy_device(the_deck, 13, set_offline);
   832.       the_T_bit_is_set := the_deck.is_at_ETW;
   833.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   834.    end PMF;
   835.
   836.    -- PMKQq, forward skip, even parity, for character data with "group mark" (8#77#)
   837.    overriding
   838.    procedure PMK (the_deck    : in out MT.deck;
   839.                   Q_operand   : in KDF9.Q_register;
   840.                   set_offline : in Boolean) is
   841.    begin
   842.       if the_deck.kind = MT_kind then
   843.          trap_illegal_instruction("PMKQq on 1081 deck " & the_deck.device_name);
   844.       else
   845.          the_deck.PMA(Q_operand, set_offline);
   846.       end if;
   847.    end PMK;
   848.
   849.    -- PMLQq, backward skip, even parity, for character data with "group mark" (8#77#)
   850.    overriding
   851.    procedure PML (the_deck    : in out MT.deck;
   852.                   Q_operand   : in KDF9.Q_register;
   853.                   set_offline : in Boolean) is
   854.    begin
   855.       if the_deck.kind = MT_kind then
   856.          trap_illegal_instruction("PMLQq on 1081 deck " & the_deck.device_name);
   857.       else
   858.          the_deck.PMB(Q_operand, set_offline);
   859.       end if;
   860.    end PML;
   861.
   862.    procedure put_data_slice (the_deck   : in out MT.deck;
   863.                              data       : in MT.data_storage;
   864.                              size       : in length_in_frames;
   865.                              is_first,
   866.                              is_last,
   867.                              is_flagged : in Boolean) is
   868.       the_slice : MT.slice;
   869.    begin
   870.       the_slice := (
   871.                     data_slice,
   872.                     is_LBM_flagged => is_flagged,
   873.                     is_first => put_data_slice.is_first,
   874.                     is_last  => put_data_slice.is_last,
   875.                     size     => put_data_slice.size,
   876.                     data     => erased_gap_data
   877.                    );
   878.       the_slice.data(1 .. put_data_slice.size) := put_data_slice.data;
   879.       write_slice(the_deck.tape, the_slice);
   880.    exception
   881.       when end_of_tape =>
   882.          deal_with_trying_to_pass_PET(the_deck, "write " & the_deck.device_name);
   883.    end put_data_slice;
   884.
   885.    procedure write_block (the_deck       : in out MT.deck;
   886.                           the_data       : in MT.data_storage;
   887.                           is_LBM_flagged : in Boolean) is
   888.       remnant  : length_in_frames := the_data'Length;
   889.       from     : length_in_frames;
   890.       the_size : length_in_frames;
   891.    begin
   892.       if not the_deck.tape.has_a_WP_ring then
   893.          trap_operator_error(the_deck.device_name & " does not have a Write Permit Ring");
   894.       end if;
   895.
   896.       deal_with_trying_to_pass_PET(the_deck, "write");
   897.
   898.       the_deck.is_LBM_flagged := False;
   899.
   900.       -- Write the first (and possibly final) slice of the block.
   901.       the_size := (if remnant > slice_size_limit then slice_size_limit else remnant);
   902.       remnant := remnant - the_size;
   903.       from := the_data'First;
   904.       put_data_slice (
   905.                       the_deck,
   906.                       the_data(from .. the_size),
   907.                       the_size,
   908.                       is_first   => True,
   909.                       is_last    => remnant = 0,
   910.                       is_flagged => write_block.is_LBM_flagged
   911.                      );
   912.
   913.       -- Write any full slices, the last of which may be final.
   914.       while remnant >= slice_size_limit loop
   915.          deal_with_trying_to_pass_PET(the_deck, "write");
   916.          remnant := remnant - slice_size_limit;
   917.          from := from + slice_size_limit;
   918.          put_data_slice (
   919.                          the_deck,
   920.                          the_data(from .. from+slice_size_limit-1),
   921.                          slice_size_limit,
   922.                          is_first   => False,
   923.                          is_last    => remnant = 0,
   924.                          is_flagged => write_block.is_LBM_flagged
   925.                         );
   926.       end loop;
   927.
   928.       -- Write the residue as a final slice of the block.
   929.       if remnant > 0 then
   930.          put_data_slice (
   931.                          the_deck,
   932.                          the_data(from+slice_size_limit .. the_data'Last),
   933.                          remnant,
   934.                          is_first   => False,
   935.                          is_last    => True,
   936.                          is_flagged => write_block.is_LBM_flagged
   937.                         );
   938.       end if;
   939.
   940.       note_tape_position(the_deck, forwards,
   941.                         the_deck.inter_block_gap, bytes_moved => the_data'Length);
   942.       update_statistics(the_deck,
   943.                         the_deck.inter_block_gap, bytes_moved => the_data'Length);
   944.
   945.    exception
   946.       when end_of_tape =>
   947.          deal_with_trying_to_pass_PET(the_deck, "write " & the_deck.device_name);
   948.    end write_block;
   949.
   950.    procedure write (the_deck       : in out MT.deck;
   951.                     Q_operand      : in KDF9.Q_register;
   952.                     is_LBM_flagged : in Boolean := False) is
   953.       start_address : constant KDF9.address := Q_operand.I;
   954.       end_address   : constant KDF9.address := Q_operand.M;
   955.    begin
   956.       validate_device(the_deck, Q_operand);
   957.       check_addresses_and_lockouts(start_address, end_address);
   958.       declare
   959.          next_byte : length_in_frames := 1;
   960.          the_data  : MT.data_storage(1 .. length_in_frames(end_address-start_address+1)*8);
   961.       begin
   962.       word_loop:
   963.          for w in start_address .. end_address loop
   964.             for c in KDF9_char_sets.symbol_index'Range loop
   965.                the_data(next_byte) := TP_CN(fetch_symbol(w, c));
   966.                next_byte := next_byte + 1;
   967.             end loop;
   968.          end loop word_loop;
   969.          write_block(the_deck, the_data, is_LBM_flagged);
   970.       end;
   971.    end write;
   972.
   973.    procedure write_to_terminator (the_deck       : in out MT.deck;
   974.                                   Q_operand      : in KDF9.Q_register;
   975.                                   is_LBM_flagged : in Boolean := False) is
   976.       start_address : constant KDF9.address := Q_operand.I;
   977.       end_address   : constant KDF9.address := Q_operand.M;
   978.    begin
   979.       validate_device(the_deck, Q_operand);
   980.       check_addresses_and_lockouts(start_address, end_address);
   981.       declare
   982.          next_byte : length_in_frames := 1;
   983.          the_data  : MT.data_storage(1 .. length_in_frames(end_address-start_address+1)*8);
   984.          symbol    : KDF9_char_sets.symbol;
   985.       begin
   986.       word_loop:
   987.          for w in start_address .. end_address loop
   988.             for c in KDF9_char_sets.symbol_index'Range loop
   989.                symbol := fetch_symbol(w, c);
   990.                the_data(next_byte) := TP_CN(symbol);
   991.                next_byte := next_byte + 1;
   992.          exit word_loop when symbol = the_deck.terminator;
   993.             end loop;
   994.          end loop word_loop;
   995.          if the_deck.kind = MT_kind then
   996.             -- Pad out the last word to a full 8 symbols; 7-track decks do not do this.
   997.             while next_byte mod 8 /= 1 loop
   998.                the_data(next_byte) := TP_CN(0);
   999.                next_byte := next_byte + 1;
  1000.             end loop;
  1001.          end if;
  1002.          write_block(the_deck, the_data(1 .. next_byte-1), is_LBM_flagged);
  1003.          correct_transfer_time(the_deck, KDF9.word(next_byte-1));
  1004.       end;
  1005.    end write_to_terminator;
  1006.
  1007.    -- MWQq
  1008.    overriding
  1009.    procedure POA (the_deck    : in out MT.deck;
  1010.                   Q_operand   : in KDF9.Q_register;
  1011.                   set_offline : in Boolean) is
  1012.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1013.    begin
  1014.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1015.       write(the_deck, Q_operand);
  1016.       lock_out_relative_addresses(Q_operand);
  1017.    end POA;
  1018.
  1019.    -- MWEQq
  1020.    overriding
  1021.    procedure POB (the_deck    : in out MT.deck;
  1022.                   Q_operand   : in KDF9.Q_register;
  1023.                   set_offline : in Boolean) is
  1024.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1025.    begin
  1026.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1027.       write_to_terminator(the_deck, Q_operand);
  1028.       lock_out_relative_addresses(Q_operand);
  1029.    end POB;
  1030.
  1031.    procedure put_ST_tapemark_slice (the_deck    : in out MT.deck;
  1032.                                     Q_operand   : in KDF9.Q_register;
  1033.                                     set_offline : in Boolean;
  1034.                                     the_slice   : in MT.slice) is
  1035.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, (Q_operand.C, 0, 0));
  1036.    begin
  1037.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1038.       write_slice(the_deck.tape, the_slice);
  1039.    exception
  1040.       when end_of_tape =>
  1041.          deal_with_trying_to_pass_PET(the_deck, "write " & the_deck.device_name);
  1042.    end put_ST_tapemark_slice;
  1043.
  1044.    -- MLWQq
  1045.    overriding
  1046.    procedure POC (the_deck    : in out MT.deck;
  1047.                   Q_operand   : in KDF9.Q_register;
  1048.                   set_offline : in Boolean) is
  1049.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1050.    begin
  1051.       if the_deck.kind = MT_kind then
  1052.          start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1053.          write(the_deck, Q_operand, is_LBM_flagged => True);
  1054.          lock_out_relative_addresses(Q_operand);
  1055.       else
  1056.          put_ST_tapemark_slice(the_deck, Q_operand, set_offline, odd_parity_tape_mark);
  1057.       end if;
  1058.    end POC;
  1059.
  1060.    -- MLWEQq
  1061.    overriding
  1062.    procedure POD (the_deck    : in out MT.deck;
  1063.                   Q_operand   : in KDF9.Q_register;
  1064.                   set_offline : in Boolean) is
  1065.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1066.    begin
  1067.       if the_deck.kind = MT_kind then
  1068.          start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1069.          write_to_terminator(the_deck, Q_operand, is_LBM_flagged => True);
  1070.          lock_out_relative_addresses(Q_operand);
  1071.       else
  1072.          put_ST_tapemark_slice(the_deck, Q_operand, set_offline, even_parity_tape_mark);
  1073.       end if;
  1074.    end POD;
  1075.
  1076.    procedure erase_tape_gap (the_deck   : in out MT.deck;
  1077.                              the_length : in KDF9.Q_part; -- the_length is a number of words.
  1078.                              gap_kind   : in tape_gap_kind) is
  1079.       crossing  : constant length_in_frames := length_in_frames(the_length) * 8;
  1080.       the_slice : MT.slice := (if gap_kind = GAP_slice then a_GAP_slice else a_WIPE_slice);
  1081.       remnant   : length_in_frames := crossing;
  1082.       old_slice : MT.slice;
  1083.       the_size  : length_in_frames;
  1084.    begin
  1085.       loop
  1086.          deal_with_trying_to_pass_PET(the_deck, "erase");
  1087.          the_size := length_in_frames'Min(remnant, slice_size_limit);
  1088.          remnant  := remnant - the_size;
  1089.
  1090.          the_slice.size := the_size;
  1091.
  1092.          if gap_kind = GAP_slice  and then
  1093.                not the_deck.is_at_EOD then
  1094.             -- Safety rules apply to erasing gaps; see the Manual, Appendix 6.8, p.314.
  1095.             read_next_slice(the_deck.tape, old_slice);
  1096.             if old_slice.kind /= WIPE_slice then
  1097.                trap_failing_IO_operation(
  1098.                                          the_deck,
  1099.                                          "a GAP of length"
  1100.                                        & the_length'Image
  1101.                                        & " words would overwrite data at slice"
  1102.                                        & the_deck.tape.position'Image
  1103.                                         );
  1104.             end if;
  1105.             -- Restore the writing position.
  1106.             read_prev_slice(the_deck.tape, old_slice);
  1107.          end if;
  1108.
  1109.          write_slice(the_deck.tape, the_slice);
  1110.       exit when remnant = 0;
  1111.       end loop;
  1112.
  1113.       the_deck.is_LBM_flagged := False;
  1114.       note_tape_position(the_deck, forwards, crossing, bytes_moved => 0);
  1115.       update_statistics(the_deck, crossing, bytes_moved => 0);
  1116.    exception
  1117.       when end_of_tape =>
  1118.          deal_with_trying_to_pass_PET(the_deck, "WIPE/GAP " & the_deck.device_name);
  1119.    end erase_tape_gap;
  1120.
  1121.    -- MGAPQq
  1122.    overriding
  1123.    procedure POE (the_deck    : in out MT.deck;
  1124.                   Q_operand   : in KDF9.Q_register;
  1125.                   set_offline : in Boolean) is
  1126.       time : constant KDF9.us := 19+IO_elapsed_time(the_deck, KDF9.word(Q_operand.M));
  1127.    begin
  1128.       if not the_deck.tape.has_a_WP_ring then
  1129.          trap_operator_error(the_deck.device_name & " does not have a Write Permit Ring");
  1130.       end if;
  1131.       require_positive_count(Q_operand.M);
  1132.       start_data_transfer(the_deck, Q_operand, set_offline, time);
  1133.       erase_tape_gap(the_deck, Q_operand.M, gap_kind => GAP_slice);
  1134.    end POE;
  1135.
  1136.    -- MWIPEQq
  1137.    overriding
  1138.    procedure POF (the_deck    : in out MT.deck;
  1139.                   Q_operand   : in KDF9.Q_register;
  1140.                   set_offline : in Boolean) is
  1141.       time : constant KDF9.us := 19+IO_elapsed_time(the_deck, KDF9.word(Q_operand.M));
  1142.    begin
  1143.       if not the_deck.tape.has_a_WP_ring then
  1144.          trap_operator_error(the_deck.device_name & " does not have a Write Permit Ring");
  1145.       end if;
  1146.       require_positive_count(Q_operand.M);
  1147.       start_data_transfer(the_deck, Q_operand, set_offline, time);
  1148.       erase_tape_gap(the_deck, Q_operand.M, gap_kind => WIPE_slice);
  1149.    end POF;
  1150.
  1151.    overriding
  1152.    procedure Finalize (the_deck : in out MT.deck) is
  1153.       the_deck_was_used : constant Boolean := the_deck.bytes_moved /= 0 or not the_deck.is_at_BTW;
  1154.       buffer            : constant String  := oct_of(KDF9.Q_part(the_deck.number), 2);
  1155.    begin
  1156.       if the_deck.is_open then
  1157.          if (the_final_state_is_wanted and the_log_is_wanted) and then
  1158.                the_deck_was_used                                  then
  1159.             log_line(
  1160.                      the_deck.device_name
  1161.                    & " on buffer #"
  1162.                    & buffer
  1163.                    & " transferred"
  1164.                    & the_deck.bytes_moved'Image
  1165.                    & " characters"
  1166.                    & (
  1167.                       if    the_deck.is_at_PET then ", and is now at PET."
  1168.                       elsif the_deck.is_at_ETW then ", and is now at ETW."
  1169.                       else                          "."
  1170.                      )
  1171.                    );
  1172.          end if;
  1173.          close(the_deck.tape);
  1174.       end if;
  1175.    exception
  1176.       when error : others =>
  1177.          raise emulation_failure
  1178.             with "Finalizing MT buffer #" & buffer & "; " & Ada.Exceptions.Exception_Message(error);
  1179.    end Finalize;
  1180.
  1181.    MT_quantum : constant := 1E6 / 40E3;  -- for 40_000 characters per second.
  1182.    ST_quantum : constant := 1E6 / 15E3;  -- for 15_000 characters per second.
  1183.
  1184.    type MT_access is access MT.deck;
  1185.    MT_deck         : array (IOC.unit_number range 0..8) of MT_access with Warnings => Off;
  1186.
  1187.    MT_units : IOC.unit_number := 0;
  1188.    ST_units : IOC.unit_number := 0;
  1189.
  1190.    procedure enable_MT_deck (b : in KDF9.buffer_number) is
  1191.    begin
  1192.       if MT_units+ST_units > MT_deck'Last then
  1193.          trap_operator_error("too many tape decks specified");
  1194.       end if;
  1195.       MT_deck(MT_units) := new deck (number  => b,
  1196.                                      kind    => MT_kind,
  1197.                                      unit    => MT_units,
  1198.                                      quantum => MT_quantum);
  1199.       MT_units := MT_units + 1;
  1200.    end enable_MT_deck;
  1201.
  1202.    procedure enable_ST_deck (b : in KDF9.buffer_number) is
  1203.    begin
  1204.       if ST_units >= 2 then
  1205.          trap_operator_error("more than 2 ST decks specified");
  1206.       end if;
  1207.       if MT_units+ST_units > MT_deck'Last then
  1208.          trap_operator_error("too many tape decks specified");
  1209.       end if;
  1210.       MT_deck(MT_units) := new deck (number  => b,
  1211.                                      kind    => ST_kind,
  1212.                                      unit    => ST_units,
  1213.                                      quantum => ST_quantum);
  1214.       ST_units := ST_units + 1;
  1215.       MT_units := MT_units + 1;
  1216.    end enable_ST_deck;
  1217.
  1218.    procedure find_tape (the_label  : in  MT.data_storage;
  1219.                         its_number : out KDF9.buffer_number;
  1220.                         its_serial : out KDF9.word) is
  1221.
  1222.       function as_word (the_serial : MT.data_storage)
  1223.       return KDF9.word is
  1224.          word : KDF9.word := 0;
  1225.       begin
  1226.          for b in the_serial'Range loop
  1227.             word := (word * 2**6) or KDF9.word(CN_TR(the_serial(b)));
  1228.          end loop;
  1229.          return word;
  1230.       end as_word;
  1231.
  1232.       the_block : MT.data_storage(1 .. max_block_size);
  1233.       the_size  : length_in_frames;
  1234.
  1235.    begin -- find_tape
  1236.       for t in KDF9.buffer_number loop
  1237.          if buffer(t) /= null                      and then
  1238.                buffer(t).kind in MT_kind | ST_kind and then
  1239.                    is_unallocated(buffer(t))           then
  1240.             declare
  1241.                the_deck : MT.deck renames MT.deck(buffer(t).all);
  1242.             begin
  1243.                if the_deck.holds_data  and then
  1244.                      the_deck.is_at_BTW    then
  1245.                   -- Read the label.
  1246.                   -- After reading the label the tape must be set back to BTW,
  1247.                   -- as is required to emulate Director; see the Manual, §22.1, Ex. 1.
  1248.                   read_block(the_deck, the_block, the_size);
  1249.                   reset(the_deck);
  1250.                   if the_size >= 8+the_label'Length                and then
  1251.                         the_block(9 .. 8+the_label'Length) = the_label then
  1252.                      its_number := t;
  1253.                      its_serial := as_word(the_block(1 .. 8));
  1254.                      return;
  1255.                   end if;
  1256.                end if;
  1257.             end;
  1258.          end if;
  1259.       end loop;
  1260.       trap_operator_error("'" & String(the_label) & "' has not been mounted");
  1261.    end find_tape;
  1262.
  1263.
  1264. end IOC.fast.MT;

Compiling: ../Source/ioc-fast-mt.ads
Source file time stamp: 2021-01-10 23:52:37
Compiled at: 2021-02-08 17:21:00

     1. -- Emulation of magnetic tape decks and buffers.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18.
    19. private with Ada.Direct_IO;
    20. --
    21. private with magtape_data;
    22.
    23. use  KDF9_char_sets;
    24.
    25. package IOC.fast.MT is
    26.
    27.    -- Both the EE 1081 and the Ampex TM-4 decks are emulated.
    28.    --
    29.    -- EE 1081, 16-track tape deck.
    30.       -- The physical characteristics of the deck are taken from the Manual, §22.1.2, i.e.:
    31.       -- 0.3 inch interblock gap, 400 ch/inch density, 100 inch/s tape speed,
    32.       --    full-reel rewind time ~3 minutes.
    33.    --
    34.    -- Ampex TM-4, 7-track IBM-compatible, tape deck.
    35.       -- The physical characteristics of the deck are taken from the Ampex document:
    36.       --    TECHNICAL MANUAL FOR SDSTM-4 TAPE TRANSPORT of 1963/2/15.
    37.       -- Where alternative characteristics are described, this code uses those considered to be of
    38.       --    greatest data interchange compatibility, as this is how the deck was used on KDF9, i.e.:
    39.       -- 0.3 inch interblock gap, 200 ch/inch density, 75 inch/s tape speed,
    40.       --    full-reel rewind time ~3 minutes.
    41.    --
    42.
    43.    type deck is new IOC.fast.device with private;
    44.
    45.    -- MRFQq
    46.    overriding
    47.    procedure PIA (the_deck    : in out MT.deck;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- MFREQq
    52.    overriding
    53.    procedure PIB (the_deck    : in out MT.deck;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- as PIA
    58.    overriding
    59.    procedure PIC (the_deck    : in out MT.deck;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    -- as PID
    64.    overriding
    65.    procedure PID (the_deck    : in out MT.deck;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    -- MBRQq
    70.    overriding
    71.    procedure PIE (the_deck    : in out MT.deck;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    -- MBREQq
    76.    overriding
    77.    procedure PIF (the_deck    : in out MT.deck;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    -- as PIE
    82.    overriding
    83.    procedure PIG (the_deck    : in out MT.deck;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    -- as PIF
    88.    overriding
    89.    procedure PIH (the_deck    : in out MT.deck;
    90.                   Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean);
    92.
    93.    -- MFSKQq, for odd parity on 7-track deck
    94.    overriding
    95.    procedure PMA (the_deck    : in out MT.deck;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean);
    98.
    99.    -- MBTQq
   100.    overriding
   101.    procedure PMB (the_deck    : in out MT.deck;
   102.                   Q_operand   : in KDF9.Q_register;
   103.                   set_offline : in Boolean);
   104.
   105.    -- MLBQq
   106.    overriding
   107.    procedure PMC (the_deck    : in out MT.deck;
   108.                   Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean);
   110.    -- MRWDQq
   111.    overriding
   112.    procedure PMD (the_deck    : in out MT.deck;
   113.                   Q_operand   : in KDF9.Q_register;
   114.                   set_offline : in Boolean);
   115.
   116.    -- MBSKQqMFSKQq, for odd parity on 7-track deck
   117.    overriding
   118.    procedure PME (the_deck    : in out MT.deck;
   119.                   Q_operand   : in KDF9.Q_register;
   120.                   set_offline : in Boolean);
   121.
   122.    -- METQq
   123.    overriding
   124.    procedure PMF (the_deck    : in out MT.deck;
   125.                   Q_operand   : in KDF9.Q_register;
   126.                   set_offline : in Boolean);
   127.
   128.    -- PMKQq, forward skip, even parity, for 7-track deck only
   129.    overriding
   130.    procedure PMK (the_deck    : in out MT.deck;
   131.                   Q_operand   : in KDF9.Q_register;
   132.                   set_offline : in Boolean);
   133.
   134.    -- PMLQq, backward skip, even parity, for 7-track deck only
   135.    overriding
   136.    procedure PML (the_deck    : in out MT.deck;
   137.                   Q_operand   : in KDF9.Q_register;
   138.                   set_offline : in Boolean);
   139.
   140.    -- MWQq
   141.    overriding
   142.    procedure POA (the_deck    : in out MT.deck;
   143.                   Q_operand   : in KDF9.Q_register;
   144.                   set_offline : in Boolean);
   145.
   146.    -- MWEQq
   147.    overriding
   148.    procedure POB (the_deck    : in out MT.deck;
   149.                   Q_operand   : in KDF9.Q_register;
   150.                   set_offline : in Boolean);
   151.
   152.    -- MLWQq
   153.    overriding
   154.    procedure POC (the_deck    : in out MT.deck;
   155.                   Q_operand   : in KDF9.Q_register;
   156.                   set_offline : in Boolean);
   157.
   158.    -- MLWEQq
   159.    overriding
   160.    procedure POD (the_deck    : in out MT.deck;
   161.                   Q_operand   : in KDF9.Q_register;
   162.                   set_offline : in Boolean);
   163.
   164.    -- MGAPQq
   165.    overriding
   166.    procedure POE (the_deck    : in out MT.deck;
   167.                   Q_operand   : in KDF9.Q_register;
   168.                   set_offline : in Boolean);
   169.
   170.    -- MWIPEQq
   171.    overriding
   172.    procedure POF (the_deck    : in out MT.deck;
   173.                   Q_operand   : in KDF9.Q_register;
   174.                   set_offline : in Boolean);
   175.
   176.    procedure enable_MT_deck (b : in KDF9.buffer_number);
   177.
   178.    procedure enable_ST_deck (b : in KDF9.buffer_number);
   179.
   180. private
   181.
   182.    use magtape_data;
   183.
   184.    -- slice_size_limit must be set so that the slice size field fits into 1 byte,
   185.    --    thus avoiding endian-ness and portability issues.
   186.    pragma Compile_Time_Error (slice_size_limit > 255, "magtape_data.slice_size_limit > 255");
   187.
   188.    -- I think that both types of tape for the KDF9 had a maximum reel length of 2400 feet.
   189.    -- I assume that the recording density of the 7-track deck was no greater than that of the 1081.
   190.
   191.    max_bits_per_inch      : constant := 400;
   192.    max_reel_length        : constant := 12 * 2400;
   193.    type length_in_frames is range 0 .. max_reel_length * max_bits_per_inch;
   194.    type data_storage     is array (MT.length_in_frames range <>) of Character;
   195.
   196.    -- Attempts to write a block of more than max_block_size/8 words will be rejected.
   197.    -- The largest recommended size, as stated in the Manual, §22.1.3, is 3000 words.
   198.    -- The present value cannot logically be exceeded, and so allows all possible usages.
   199.
   200.    max_block_size         : constant := 32768 * 8;
   201.    subtype block_range   is MT.length_in_frames range 0 .. max_block_size;
   202.    subtype block_storage is data_storage (MT.block_range range 1 .. max_block_size);
   203.
   204.    -- A data block consists of one or more slices:
   205.    --
   206.    -- 1. a block of data length <= slice_size_limit has 1 slice, with (is_last and is_first) = True;
   207.    --
   208.    -- 2. a longer block has 1 or more prior slices, which all have data length = slice_size_limit,
   209.    --       all of them having is_last = False, and the first of them having is_first = True;
   210.    --    and 1 final slice of data length <= slice_size_limit, with is_last = True.
   211.    --
   212.    -- The total data length of all the slices in a block is <= max_block_size.
   213.    --
   214.    -- GAP and WIPE slices represent erased lengths of tape.
   215.    -- They are implemented, in effect, as data slices with non-significant data.
   216.    --
   217.    -- Parity mark slices represent tape marks on IBM-compatible Ampex TM4 decks.
   218.    -- See Manual, Appendix 7, p.317.
   219.
   220.    type basis_kind is (data_slice,
   221.                        GAP_slice,
   222.                        NULL_slice,
   223.                        WIPE_slice,
   224.                        even_parity_mark,
   225.                        odd_parity_mark);
   226.
   227.    -- These representations make for easy inspection of a MT file (e.g. using the UNIX od command).
   228.    for basis_kind use (data_slice       => Character'Pos('D'),
   229.                        GAP_slice        => Character'Pos('G'),
   230.                        NULL_slice       => Character'Pos('N'),
   231.                        WIPE_slice       => Character'Pos('W'),
   232.                        even_parity_mark => Character'Pos('e'),
   233.                        odd_parity_mark  => Character'Pos('o'));
   234.
   235.    subtype tape_gap_kind is MT.basis_kind
   236.       with Static_Predicate => tape_gap_kind in GAP_slice | WIPE_slice;
   237.
   238.    subtype tape_mark_kind is MT.basis_kind
   239.       with Static_Predicate => tape_mark_kind in odd_parity_mark | even_parity_mark;
   240.
   241.    subtype data_kind is MT.basis_kind
   242.       with Static_Predicate => data_kind = data_slice;
   243.
   244.    subtype slice_range   is MT.block_range range 0 .. magtape_data.slice_size_limit;
   245.    subtype slice_storage is data_storage (1 .. slice_range'Last);
   246.
   247.    tape_mark_data  : constant MT.slice_storage := (1 => tape_mark_sign, others => block_padding);
   248.    erased_gap_data : constant MT.slice_storage := (others => block_padding);
   249.
   250.    type slice is
   251.       record
   252.          kind              : MT.basis_kind;
   253.          is_first, is_last : Boolean;
   254.          is_LBM_flagged    : Boolean;
   255.          size              : MT.slice_range;
   256.          data              : MT.slice_storage; -- Only data(1 .. size) are valid.
   257.       end record
   258.    with Size => 8 * MT_record_length;
   259.
   260.    -- These two representation specifications put the kind and is_* fields at convenient positions
   261.    --    for easy inspection in a legible print of a MT file (e.g. using the UNIX od command).
   262.
   263.    -- The first byte contains the initial letter of the slice type (see basis_kind).
   264.
   265.    -- The second byte takes the following octal/ASCII values for non-tape mark slices:
   266.    --    000 = NUL  => no flags
   267.    --    001 = SOH  => first slice of block
   268.    --    010 = BEL  => last slice of block
   269.    --    011 = HT   => only slice of block (first and last)
   270.    --    100 = @    => LBM flag
   271.    --    101 = A    => first slice of block with LBM flag
   272.    --    110 = H    => last slice of block with LBM flag
   273.    --    111 = I    => only slice of block with LBM flag
   274.
   275.    for slice use
   276.       record
   277.          kind           at 0 range  0..7;
   278.          is_first       at 1 range  0..2;
   279.          is_last        at 1 range  3..5;
   280.          is_LBM_flagged at 1 range  6..7;
   281.          size           at 2 range  0..7;
   282.          data           at 3 range  0..8*slice_size_limit - 1;
   283.       end record;
   284.
   285.    even_parity_tape_mark : constant MT.slice := (even_parity_mark,
   286.                                                  is_first       => True,
   287.                                                  is_last        => True,
   288.                                                  is_LBM_flagged => True,
   289.                                                  size           => 1,
   290.                                                  data           => tape_mark_data);
   291.
   292.    odd_parity_tape_mark  : constant MT.slice := (odd_parity_mark,
   293.                                                  is_first       => True,
   294.                                                  is_last        => True,
   295.                                                  is_LBM_flagged => True,
   296.                                                  size           => 1,
   297.                                                  data           => tape_mark_data);
   298.
   299.    a_NULL_slice          : constant MT.slice := (NULL_slice,
   300.                                                  is_first       => False,
   301.                                                  is_last        => False,
   302.                                                  is_LBM_flagged => False,
   303.                                                  size           => 0,
   304.                                                  data           => erased_gap_data);
   305.
   306.    a_WIPE_slice          : constant MT.slice := (WIPE_slice,
   307.                                                  is_first       => True,
   308.                                                  is_last        => True,
   309.                                                  is_LBM_flagged => False,
   310.                                                  size           => 0,
   311.                                                  data           => erased_gap_data);
   312.
   313.    a_GAP_slice           : constant MT.slice := (GAP_slice,
   314.                                                  is_first       => True,
   315.                                                  is_last        => True,
   316.                                                  is_LBM_flagged => False,
   317.                                                  size           => 0,
   318.                                                  data           => erased_gap_data);
   319.
   320.    package MT_slice_IO is new Ada.Direct_IO(MT.slice);
   321.    use MT_slice_IO;
   322.
   323.    type file is tagged limited
   324.       record
   325.          has_a_WP_ring   : Boolean := True;
   326.          last_data_index : Count   := 0;
   327.          position        : Count   := 0;
   328.          reel            : File_Type;
   329.       end record;
   330.
   331.    -- The complete deck type with its primitive operations.
   332.
   333.    type deck is new IOC.fast.device with
   334.       record
   335.          -- unwound_frames tallies the amount of tape wound from its spool to the takeup spool;
   336.          --    i.e. how much has to be wound back before being able to unload the tape.
   337.          unwound_frames    : MT.length_in_frames := 0;
   338.          bytes_moved       : KDF9.word := 0;
   339.          is_LBM_flagged    : Boolean   := False;
   340.          terminator        : KDF9_char_sets.symbol;
   341.          recording_density : MT.length_in_frames;
   342.          max_reel_length   : MT.length_in_frames;
   343.          inter_block_gap   : MT.length_in_frames;
   344.          tape_capacity     : MT.length_in_frames;
   345.          PET_position      : MT.length_in_frames;
   346.          ETW_position      : MT.length_in_frames;
   347.          tape              : MT.file;
   348.       end record;
   349.
   350.    overriding
   351.    function IO_elapsed_time_total (the_deck : MT.deck)
   352.    return KDF9.us
   353.    is (the_deck.elapsed_time);
   354.
   355.    overriding
   356.    procedure Initialize (the_deck : in out MT.deck);
   357.
   358.    overriding
   359.    procedure Finalize (the_deck : in out MT.deck);
   360.
   361.    procedure open (the_deck : in out MT.deck;
   362.                    the_mode : in POSIX.access_mode)
   363.    is null;
   364.
   365.    overriding
   366.    function is_open (the_deck : MT.deck)
   367.    return Boolean;
   368.
   369.    overriding
   370.    function usage (the_deck : MT.deck)
   371.    return KDF9.word;
   372.
   373.    overriding
   374.    procedure close (the_deck : in out MT.deck);
   375.
   376.    overriding
   377.    procedure flush(the_deck : in out MT.deck) is null;
   378.
   379.    procedure find_tape (the_label  : in  MT.data_storage;
   380.                         its_number : out KDF9.buffer_number;
   381.                         its_serial : out KDF9.word);
   382.
   383. end IOC.fast.MT;

 1264 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-fw.adb
Source file time stamp: 2021-02-07 23:17:22
Compiled at: 2021-02-08 17:21:00

     1. -- Emulation of the FlexoWriter buffer: monitor typewriter functionality.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received the copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. with Ada.Text_IO;
    19. --
    20. with HCI;
    21. with host_IO;
    22.
    23. use  Ada.Text_IO;
    24. --
    25. use  HCI;
    26. use  host_IO;
    27.
    28. package body IOC.slow.shift.FW is
    29.
    30.    use  KDF9_char_sets;
    31.    use  Ada.Characters.Latin_1;
    32.
    33.    function a_LF_was_just_read (the_FW : FW.device)
    34.    return Boolean
    35.    is (the_FW.mode = the_flexowriter_is_reading and then a_LF_was_just_read(the_FW.stream));
    36.
    37.    function a_LF_was_just_written (the_FW : FW.device)
    38.    return Boolean
    39.    is (the_FW.mode = the_flexowriter_is_writing and then a_LF_was_just_written(the_FW.stream));
    40.
    41.    max_text_length : constant Positive := 64;  -- This is arbitrary, but seems reasonable.
    42.    type interaction is
    43.       record
    44.          text           : String(1 .. max_text_length);
    45.          prompt_length,
    46.          total_length   : Positive range 1 .. max_text_length;
    47.       end record;
    48.
    49.    max_interactions : constant Positive := 16; -- This is arbitrary, but seems reasonable.
    50.    interactions     : array (1 .. max_interactions) of IOC.slow.shift.FW.interaction;
    51.    next_interaction : Positive := 1;
    52.    last_interaction : Natural  := 0;
    53.
    54.     -- A '®' denotes LF, and the '©' denotes FF in an interaction text input.
    55.    LF_surrogate     : constant Character := '®';
    56.    FF_surrogate     : constant Character := '©';
    57.
    58.    -- These are the ANSI SGR terminal escape codes for styling FW output.
    59.    red_font_code   : constant String := ESC & "[0m" & ESC & "[31m";
    60.    black_font_code : constant String := ESC & "[0m" & ESC & "[30m";
    61.    underline_code  : constant String := ESC & "[4m";
    62.    plain_font_code : constant String := ESC & "[0m";
    63.
    64.    procedure set_text_colour_to_red (the_flexowriter_output : in out host_IO.stream) is
    65.    begin
    66.       if the_terminal_is_ANSI_compatible and realistic_FW_output_is_wanted then
    67.          put_escape_code(red_font_code, the_flexowriter_output);
    68.       end if;
    69.    end set_text_colour_to_red;
    70.
    71.    procedure set_text_colour_to_black (the_flexowriter_output : in out host_IO.stream) is
    72.    begin
    73.       if the_terminal_is_ANSI_compatible then
    74.          put_escape_code(black_font_code, the_flexowriter_output);
    75.       end if;
    76.    end set_text_colour_to_black;
    77.
    78.    procedure set_text_style_to_underline (the_flexowriter_output : in out host_IO.stream) is
    79.    begin
    80.       if the_terminal_is_ANSI_compatible then
    81.          put_escape_code(underline_code, the_flexowriter_output);
    82.       end if;
    83.    end set_text_style_to_underline;
    84.
    85.    procedure set_text_style_to_plain (the_flexowriter_output : in out host_IO.stream) is
    86.    begin
    87.       if the_terminal_is_ANSI_compatible then
    88.          put_escape_code(plain_font_code, the_flexowriter_output);
    89.       end if;
    90.    end set_text_style_to_plain;
    91.
    92.    overriding
    93.    procedure Initialize (the_FW : in out FW.device) is
    94.       interaction_file : Ada.Text_IO.File_Type;
    95.    begin
    96.       ensure_UI_is_open;
    97.       the_FW.mode := the_flexowriter_is_writing;
    98.       the_FW.device_name := device_name_of(the_FW);
    99.       if the_FW.device_name = "FW0" then
   100.          -- Attempt to open the command file for the console the_FW.
   101.          begin
   102.             Open(interaction_file, In_File, "FW0");
   103.          response_list_loop:
   104.             while not End_of_file(interaction_file) loop
   105.                if last_interaction = max_interactions then
   106.                   log_line("The file FW0 contains too many interactions!");
   107.                   raise Ada.Text_IO.Data_Error;
   108.                end if;
   109.                last_interaction := last_interaction + 1;
   110.                declare
   111.                   interaction       : String  := Get_Line(interaction_file);
   112.                   the_prompt_length : Natural := 0;
   113.                begin
   114.                   if interaction'Length > max_text_length then
   115.                      log_line(
   116.                               "The file FW0 contains an overlong string: '"
   117.                             & interaction
   118.                             & "'!"
   119.                              );
   120.                      raise Ada.Text_IO.Data_Error;
   121.                   end if;
   122.
   123.                   exit response_list_loop when interaction'Length = 0;
   124.
   125.                   for p in 1 .. interaction'Length loop
   126.                      if interaction(p) = ';' then
   127.                         the_prompt_length := p;
   128.                      elsif interaction(p) = LF_surrogate then
   129.                         -- Convert '®' to LF to allow for multi-line prompts.
   130.                         interaction(p) := LF;
   131.                      elsif interaction(p) = FF_surrogate then
   132.                         -- Convert '©' to FF to allow for multi-line prompts.
   133.                         interaction(p) := FF;
   134.                      end if;
   135.                   end loop;
   136.
   137.                   if the_prompt_length = 0 then
   138.                      log_line(
   139.                               "The file FW0 contains the string: '"
   140.                             & interaction
   141.                             & "' without the semicolon!"
   142.                              );
   143.                      raise Ada.Text_IO.Data_Error;
   144.                   end if;
   145.
   146.                   interactions(last_interaction).text(1 .. interaction'Length) := interaction;
   147.                   interactions(last_interaction).prompt_length := the_prompt_length;
   148.                   interactions(last_interaction).total_length := interaction'Length;
   149.                end;
   150.             end loop response_list_loop;
   151.          exception
   152.             when Name_Error =>
   153.                null;
   154.             when Use_Error =>
   155.                log_line("The file FW0 exists, but cannot be read!");
   156.          end;
   157.       end if;
   158.       open(the_FW.stream, the_FW.device_name, read_mode, UI_in_FD);
   159.       open(the_FW.output, the_FW.device_name, write_mode, UI_out_FD);
   160.       IOC.device(the_FW).Initialize;
   161.       the_FW.current_case := KDF9_char_sets.Case_Normal;
   162.    end Initialize;
   163.
   164.    -- If authentic timing, the delay of length the_pause is inserted between characters output
   165.    --    to the Flexowriter, with the aim of approximating the actual speed of its typing.
   166.    the_pause  : KDF9.us := 0;
   167.
   168.    procedure set_the_duration_of_the_pause (the_FW : in FW.device) is
   169.    begin
   170.       if authentic_timing_is_enabled then
   171.          the_pause := the_FW.quantum;
   172.       else
   173.          the_pause := 0;
   174.       end if;
   175.    end set_the_duration_of_the_pause;
   176.
   177.    call_for_manual_input    : constant String (1..2) := (others => BEL);
   178.
   179.    procedure inject_a_response (the_FW     : in out FW.device;
   180.                                 the_prompt : in String;
   181.                                 the_size   : in out KDF9.word) is
   182.    begin
   183.       set_the_duration_of_the_pause(the_FW);
   184.       for t in next_interaction .. last_interaction loop
   185.          declare
   186.             the : interaction renames interactions(t);
   187.          begin
   188.             if the.prompt_length = the.total_length then
   189.                -- A null response, so terminate the program.
   190.                raise exceptions.quit_request with "at the prompt: '" & the_prompt & "'";
   191.             end if;
   192.             next_interaction := next_interaction + 1;
   193.             if the.text(1..the.prompt_length-1) = the_prompt and then
   194.                   the.text(the.prompt_length-0) = ';'            then
   195.                inject(the.text(the.prompt_length+1..the.total_length) & LF, the_FW.stream);
   196.                the_size := the_size + KDF9.word(the.total_length-the.prompt_length);
   197.                put_chars(the.text(the.prompt_length+1..the.total_length) & LF, the_FW.output);
   198.                -- Human operators type much more slowly than KDF9 buffers!
   199.                flush(the_FW.output, the_pause*10);
   200.                the_FW.mode := the_flexowriter_is_reading;
   201.                return;
   202.             end if;
   203.          end;
   204.       end loop;
   205.       -- No canned response is available, so control reverts to the terminal.
   206.       -- Output an audible signal to notify the operator.
   207.       if noninteractive_usage_is_enabled then
   208.          raise input_is_impossible;
   209.       end if;
   210.       put_bytes(call_for_manual_input, the_FW.output);
   211.       flush(the_FW.output, the_pause);
   212.       the_FW.mode := the_flexowriter_is_reading;
   213.    end inject_a_response;
   214.
   215.    -- TRQq
   216.    overriding
   217.    procedure PIA (the_FW      : in out FW.device;
   218.                   Q_operand   : in KDF9.Q_register;
   219.                   set_offline : in Boolean) is
   220.    begin
   221.       if noninteractive_usage_is_enabled then
   222.          raise input_is_impossible;
   223.       end if;
   224.       put_bytes(call_for_manual_input, the_FW.output);
   225.       flush(the_FW.output);
   226.       the_FW.mode := the_flexowriter_is_reading;
   227.       start_slow_transfer(the_FW, Q_operand, set_offline);
   228.       read(the_FW, Q_operand);
   229.       lock_out_relative_addresses(Q_operand);
   230.       reset(the_FW.stream);
   231.    end PIA;
   232.
   233.    -- TREQq
   234.    overriding
   235.    procedure PIB (the_FW      : in out FW.device;
   236.                   Q_operand   : in KDF9.Q_register;
   237.                   set_offline : in Boolean) is
   238.    begin
   239.       if noninteractive_usage_is_enabled then
   240.          raise input_is_impossible;
   241.       end if;
   242.       put_bytes(call_for_manual_input, the_FW.output);
   243.       flush(the_FW.output);
   244.       the_FW.mode := the_flexowriter_is_reading;
   245.       start_slow_transfer(the_FW, Q_operand, set_offline);
   246.       read_to_EM(the_FW, Q_operand);
   247.       lock_out_relative_addresses(Q_operand);
   248.       reset(the_FW.stream);
   249.    end PIB;
   250.
   251.    overriding
   252.    procedure PIC (the_FW      : in out FW.device;
   253.                   Q_operand   : in KDF9.Q_register;
   254.                   set_offline : in Boolean) is
   255.    begin
   256.       if noninteractive_usage_is_enabled then
   257.          raise input_is_impossible;
   258.       end if;
   259.       put_bytes(call_for_manual_input, the_FW.output);
   260.       flush(the_FW.output);
   261.       the_FW.mode := the_flexowriter_is_reading;
   262.       start_slow_transfer(the_FW, Q_operand, set_offline);
   263.       words_read(the_FW, Q_operand);
   264.       lock_out_relative_addresses(Q_operand);
   265.       reset(the_FW.stream);
   266.    end PIC;
   267.
   268.    overriding
   269.    procedure PID (the_FW      : in out FW.device;
   270.                   Q_operand   : in KDF9.Q_register;
   271.                   set_offline : in Boolean) is
   272.    begin
   273.       if noninteractive_usage_is_enabled then
   274.          raise input_is_impossible;
   275.       end if;
   276.       put_bytes(call_for_manual_input, the_FW.output);
   277.       flush(the_FW.output);
   278.       the_FW.mode := the_flexowriter_is_reading;
   279.       start_slow_transfer(the_FW, Q_operand, set_offline);
   280.       words_read_to_EM(the_FW, Q_operand);
   281.       lock_out_relative_addresses(Q_operand);
   282.       reset(the_FW.stream);
   283.    end PID;
   284.
   285.    overriding
   286.    procedure PIE (the_FW      : in out FW.device;
   287.                   Q_operand   : in KDF9.Q_register;
   288.                   set_offline : in Boolean) is
   289.    begin
   290.       PIA(the_FW, Q_operand, set_offline);
   291.    end PIE;
   292.
   293.    overriding
   294.    procedure PIF (the_FW      : in out FW.device;
   295.                   Q_operand   : in KDF9.Q_register;
   296.                   set_offline : in Boolean) is
   297.    begin
   298.       PIB(the_FW, Q_operand, set_offline);
   299.    end PIF;
   300.
   301.    overriding
   302.    procedure PIG (the_FW      : in out FW.device;
   303.                   Q_operand   : in KDF9.Q_register;
   304.                   set_offline : in Boolean) is
   305.    begin
   306.       PIC(the_FW, Q_operand, set_offline);
   307.    end PIG;
   308.
   309.    overriding
   310.    procedure PIH (the_FW      : in out FW.device;
   311.                   Q_operand   : in KDF9.Q_register;
   312.                   set_offline : in Boolean) is
   313.    begin
   314.       PID(the_FW, Q_operand, set_offline);
   315.    end PIH;
   316.
   317.    -- neat strips off any enclosing non-graphic characters from s.
   318.    function neat (s : String)
   319.    return String is
   320.       l : Positive := 1;
   321.       r : Natural  := 0;
   322.    begin
   323.       for i in s'Range loop
   324.          l := i;
   325.       exit when s(i) > ' ' and s(i) /= DEL;
   326.       end loop;
   327.       for i in reverse s'Range loop
   328.          r := i;
   329.       exit when s(i) > ' ' and s(i) /= DEL;
   330.       end loop;
   331.       return s(l..r);  -- s(1..0) yields the null string when s is the null string.
   332.    end neat;
   333.
   334.    overriding
   335.    procedure do_output_housekeeping (the_FW   : in out FW.device;
   336.                                      written,
   337.                                      fetched  : in KDF9.word) is
   338.    begin
   339.       flush(the_FW.stream);
   340.       add_in_the_IO_CPU_time(the_FW, fetched);
   341.       correct_transfer_time(the_FW, written);
   342.       the_FW.byte_count := the_FW.byte_count + fetched;
   343.    end do_output_housekeeping;
   344.
   345.    underlined : Boolean := False;
   346.
   347.    procedure put_symbols (the_FW         : in out FW.device;
   348.                           Q_operand      : in KDF9.Q_register;
   349.                           transfer_to_EM : in Boolean) is
   350.       start_address : constant KDF9.address := Q_operand.I;
   351.       end_address   : constant KDF9.address := Q_operand.M;
   352.       fill   : KDF9.word := 0;
   353.       size   : KDF9.word := 0;
   354.       symbol : KDF9_char_sets.symbol;
   355.       char   : Character;
   356.    begin
   357.       check_addresses_and_lockouts(start_address, end_address);
   358.       set_the_duration_of_the_pause(the_FW);
   359.       the_FW.mode := the_flexowriter_is_writing;
   360.       set_text_style_to_plain(the_FW.output);
   361.       set_text_colour_to_red(the_FW.output);
   362.
   363.       -- Ensure that any prompt occupies the buffer alone.
   364.       flush(the_FW.output);
   365.
   366.    word_loop:
   367.       for w in start_address .. end_address loop
   368.          for c in KDF9_char_sets.symbol_index'Range loop
   369.             case the_FW.mode is
   370.
   371.                when the_flexowriter_is_writing =>
   372.                   symbol := fetch_symbol(w, c);
   373.                   size := size + 1;
   374.
   375.                   if symbol = KDF9_char_sets.Word_Filler then
   376.                      fill := fill + 1;
   377.
   378.                   elsif symbol = KDF9_char_sets.Case_Shift then
   379.                      the_FW.current_case := KDF9_char_sets.Case_Shift;
   380.                      the_FW.shifts := the_FW.shifts + 1;
   381.
   382.                   elsif  symbol = KDF9_char_sets.Case_Normal then
   383.                      the_FW.current_case := KDF9_char_sets.Case_Normal;
   384.                      the_FW.shifts := the_FW.shifts + 1;
   385.
   386.                   else
   387.
   388.                      if the_FW.current_case = KDF9_char_sets.Case_Normal then
   389.                         char := TP_CN(symbol);
   390.                      else
   391.                         char := TP_CS(symbol);
   392.                      end if;
   393.
   394.                      if char = ';' then
   395.
   396.                         declare
   397.                            the_prompt : constant String := contents(the_FW.output);
   398.                         begin
   399.                            -- Must flush AFTER saving the prompt and BEFORE going black.
   400.                            flush(the_FW.output, the_pause);
   401.                            set_text_colour_to_black(the_FW.output);
   402.                            set_text_style_to_plain(the_FW.output);
   403.                            put_byte(';', the_FW.output);
   404.                            flush(the_FW.output, the_pause);
   405.
   406.                            inject_a_response(the_FW, neat(the_prompt), size);
   407.
   408.                            the_FW.mode := the_flexowriter_is_reading;
   409.                            set_text_style_to_plain(the_FW.output);
   410.                         end;
   411.
   412.                      elsif flexowriter_output_is_wanted then
   413.
   414.                         if char = '_' then
   415.                            underlined := True;
   416.                            do_not_put_byte(char, the_FW.output);
   417.                            flush(the_FW.output, the_pause);
   418.                         else
   419.                            if underlined then
   420.                               set_text_style_to_underline(the_FW.output);
   421.                            end if;
   422.                            put_char(char, the_FW.output);
   423.                            if underlined then
   424.                               flush(the_FW.output, the_pause);
   425.                               set_text_style_to_plain(the_FW.output);
   426.                               set_text_colour_to_red(the_FW.output);
   427.                               underlined := False;
   428.                            end if;
   429.                         end if;
   430.
   431.                      else
   432.                         do_not_put_byte(char, the_FW.output);
   433.                      end if;
   434.
   435.                      exit word_loop when transfer_to_EM and symbol = KDF9_char_sets.End_Message;
   436.                   end if;
   437.
   438.                when the_flexowriter_is_reading =>
   439.                   get_char(char, the_FW.stream);
   440.                   if case_of(char) /= both and case_of(char) /= the_FW.current_case then
   441.                      store_symbol(CN_TR(next_case(the_FW.current_case)), w, c);
   442.                      size := size + 1;
   443.                      the_FW.current_case := the_FW.current_case xor 1;
   444.                      back_off(the_FW.stream);
   445.                   else
   446.                      if the_FW.current_case = KDF9_char_sets.Case_Normal then
   447.                         symbol := CN_TR(char);
   448.                      else
   449.                         symbol := CS_TR(char);
   450.                      end if;
   451.                      store_symbol(symbol, w, c);
   452.                      size := size + 1;
   453.                      if transfer_to_EM and symbol = KDF9_char_sets.End_Message then
   454.                         for d in 1 .. 7-c loop
   455.                            store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
   456.                         end loop;
   457.                         exit word_loop;
   458.                      end if;
   459.                   end if;
   460.
   461.             end case;
   462.          end loop;
   463.       end loop word_loop;
   464.
   465.       flush(the_FW.output, the_pause);
   466.       set_text_style_to_plain(the_FW.output);
   467.       set_text_colour_to_black(the_FW.output);
   468.       do_output_housekeeping(the_FW, written => size-fill, fetched => size);
   469.       flush(the_FW.output);
   470.
   471.    exception
   472.
   473.       when end_of_stream =>
   474.          flush(the_FW.output);
   475.          set_text_colour_to_black(the_FW.output);
   476.          set_text_style_to_plain(the_FW.output);
   477.          do_output_housekeeping(the_FW, written => size-fill, fetched => size);
   478.    end put_symbols;
   479.
   480.    overriding
   481.    procedure write (the_FW    : in out FW.device;
   482.                     Q_operand : in KDF9.Q_register) is
   483.    begin
   484.       put_symbols(the_FW, Q_operand, transfer_to_EM => False);
   485.    end write;
   486.
   487.    overriding
   488.    procedure write_to_EM (the_FW    : in out FW.device;
   489.                           Q_operand : in KDF9.Q_register) is
   490.    begin
   491.       put_symbols(the_FW, Q_operand, transfer_to_EM => True);
   492.    end write_to_EM;
   493.
   494.    -- TWQq
   495.    overriding
   496.    procedure POA (the_FW      : in out FW.device;
   497.                   Q_operand   : in KDF9.Q_register;
   498.                   set_offline : in Boolean) is
   499.    begin
   500.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   501.       write(the_FW, Q_operand);
   502.       lock_out_relative_addresses(Q_operand);
   503.       reset(the_FW.stream);
   504.    end POA;
   505.
   506.    -- TWEQq
   507.    overriding
   508.    procedure POB (the_FW      : in out FW.device;
   509.                   Q_operand   : in KDF9.Q_register;
   510.                   set_offline : in Boolean) is
   511.    begin
   512.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   513.       write_to_EM(the_FW, Q_operand);
   514.       lock_out_relative_addresses(Q_operand);
   515.       -- reset(the_FW.stream);
   516.    end POB;
   517.
   518.    procedure put_words (the_FW         : in out FW.device;
   519.                         Q_operand      : in KDF9.Q_register;
   520.                         transfer_to_EM : in Boolean := False) is
   521.       start_address : constant KDF9.address := Q_operand.I;
   522.       end_address   : constant KDF9.address := Q_operand.M;
   523.       size : KDF9.word := 0;
   524.       word : KDF9.word;
   525.       char : Character;
   526.    begin
   527.       check_addresses_and_lockouts(start_address, end_address);
   528.       set_the_duration_of_the_pause(the_FW);
   529.       the_FW.mode := the_flexowriter_is_writing;
   530.       set_text_style_to_plain(the_FW.output);
   531.       set_text_colour_to_red(the_FW.output);
   532.    word_loop:
   533.       for w in start_address .. end_address loop
   534.          case the_FW.mode is
   535.
   536.             when the_flexowriter_is_writing =>
   537.                word := fetch_word(w) and 8#377#;
   538.                size := size + 1;
   539.                char := Character'Val(word);
   540.
   541.                if word = KDF9_char_sets.Semi_Colon_tape_bits then
   542.                   -- Hypothesis: POC and POD act like POA and POB with respect to prompting;
   543.                   --    and change from writing to reading after the output of any word that has
   544.                   --       the KDF9 FW tape code for a semicolon in its least significant 8 bits.
   545.                   declare
   546.                      the_prompt : constant String := contents(the_FW.output);
   547.                   begin
   548.                      -- Must flush AFTER saving the prompt and BEFORE going black.
   549.                      flush(the_FW.output, the_pause);
   550.                      set_text_colour_to_black(the_FW.output);
   551.                      set_text_style_to_plain(the_FW.output);
   552.                      put_byte(';', the_FW.output);
   553.                      flush(the_FW.output, the_pause);
   554.
   555.                      inject_a_response(the_FW, neat(the_prompt), size);
   556.
   557.                      the_FW.mode := the_flexowriter_is_reading;
   558.                      set_text_style_to_plain(the_FW.output);
   559.                   end;
   560.                elsif flexowriter_output_is_wanted then
   561.
   562.                         if char = '_' then
   563.                            underlined := True;
   564.                            do_not_put_byte(char, the_FW.output);
   565.                            flush(the_FW.output, the_pause);
   566.                         else
   567.                            if underlined then
   568.                               set_text_style_to_underline(the_FW.output);
   569.                            end if;
   570.                            put_char(char, the_FW.output);
   571.                            if underlined then
   572.                               flush(the_FW.output, the_pause);
   573.                               set_text_style_to_plain(the_FW.output);
   574.                               set_text_colour_to_red(the_FW.output);
   575.                               underlined := False;
   576.                            end if;
   577.                         end if;
   578.       exit word_loop when transfer_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   579.                end if;
   580.
   581.             when the_flexowriter_is_reading =>
   582.                get_char(char, the_FW.stream);
   583.                size := size + 1;
   584.                word := KDF9.word(Character'Pos(char));
   585.                store_word(word, w);
   586.       exit word_loop when transfer_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   587.
   588.          end case;
   589.       end loop word_loop;
   590.
   591.       flush(the_FW.output);
   592.       set_text_colour_to_black(the_FW.output);
   593.       set_text_style_to_plain(the_FW.output);
   594.       do_output_housekeeping(the_FW, written => size, fetched => size);
   595.
   596.    exception
   597.
   598.       when end_of_stream =>
   599.          flush(the_FW.output);
   600.          set_text_colour_to_black(the_FW.output);
   601.          set_text_style_to_plain(the_FW.output);
   602.          do_output_housekeeping(the_FW, written => size, fetched => size);
   603.    end put_words;
   604.
   605.    overriding
   606.    procedure words_write (the_FW    : in out FW.device;
   607.                           Q_operand : in KDF9.Q_register) is
   608.    begin
   609.       put_words(the_FW, Q_operand, transfer_to_EM => False);
   610.    end words_write;
   611.
   612.    overriding
   613.    procedure words_write_to_EM (the_FW    : in out FW.device;
   614.                                 Q_operand : in KDF9.Q_register) is
   615.    begin
   616.       put_words(the_FW, Q_operand, transfer_to_EM => True);
   617.    end words_write_to_EM;
   618.
   619.    -- TWCQq
   620.    overriding
   621.    procedure POC (the_FW      : in out FW.device;
   622.                   Q_operand   : in KDF9.Q_register;
   623.                   set_offline : in Boolean) is
   624.    begin
   625.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   626.       words_write(the_FW, Q_operand);
   627.       lock_out_relative_addresses(Q_operand);
   628.    end POC;
   629.
   630.    -- TWECQq
   631.    overriding
   632.    procedure POD (the_FW      : in out FW.device;
   633.                   Q_operand   : in KDF9.Q_register;
   634.                   set_offline : in Boolean) is
   635.    begin
   636.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   637.       words_write_to_EM(the_FW, Q_operand);
   638.       lock_out_relative_addresses(Q_operand);
   639.    end POD;
   640.
   641.    overriding
   642.    procedure Finalize (the_FW : in out FW.device) is
   643.       total : constant KDF9.word := the_FW.output.bytes_moved+the_FW.stream.bytes_moved + the_FW.shifts;
   644.    begin
   645.       close(
   646.            the_FW,
   647.            "transferred",
   648.            total,
   649.            "character" & plurality(total)
   650.           );
   651.    end Finalize;
   652.
   653.    -- This is the monitor console Flexowriter.
   654.
   655.    FW_quantum : constant := 1E6 / 10;  -- 10 characters per second.
   656.
   657.    type FW_access is access FW.device;
   658.
   659.    FW0 : FW_access with Warnings => Off;
   660.
   661.    already_enabled : Boolean := False;
   662.
   663.    procedure enable (b : in KDF9.buffer_number) is
   664.    begin
   665.       if already_enabled then
   666.          trap_operator_error("more than one FW unit has been configured");
   667.       end if;
   668.       if b /= 0 then
   669.          trap_operator_error("FW0 must be on buffer 0");
   670.       end if;
   671.       FW0 := new FW.device (number  => b,
   672.                             kind    => FW_kind,
   673.                             unit    => 0,
   674.                             quantum => FW_quantum);
   675.       already_enabled := True;
   676.    end enable;
   677.
   678. end IOC.slow.shift.FW;
   679.

Compiling: ../Source/ioc-slow-shift-fw.ads
Source file time stamp: 2021-01-10 23:52:37
Compiled at: 2021-02-08 17:21:00

     1. -- Emulation of a FlexoWriter buffer: monitor typewriter functionality.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.FW is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    function a_LF_was_just_read (the_FW : FW.device)
    22.    return Boolean;
    23.
    24.    function a_LF_was_just_written (the_FW : FW.device)
    25.    return Boolean;
    26.
    27.    -- TRQq
    28.    overriding
    29.    procedure PIA (the_FW      : in out FW.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    -- TREQq
    34.    overriding
    35.    procedure PIB (the_FW      : in out FW.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    -- TRCQq character read
    40.    overriding
    41.    procedure PIC (the_FW      : in out FW.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    -- TRECQq character read to End_Message
    46.    overriding
    47.    procedure PID (the_FW      : in out FW.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- as PIA
    52.    overriding
    53.    procedure PIE (the_FW      : in out FW.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- as PIB
    58.    overriding
    59.    procedure PIF (the_FW      : in out FW.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    -- as PIC
    64.    overriding
    65.    procedure PIG (the_FW      : in out FW.device;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    -- as PID
    70.    overriding
    71.    procedure PIH (the_FW      : in out FW.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    -- TWQq
    76.    overriding
    77.    procedure POA (the_FW      : in out FW.device;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    -- TWEQq
    82.    overriding
    83.    procedure POB (the_FW      : in out FW.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    -- NB the following assumes that page 285 of the Manual is erroneous,
    88.    -- and that POC and POD for the Flexowriter are analogous to the tape punch,
    89.    -- as other sources, such as the "Usecode Digest", do in fact indicate.
    90.
    91.    -- TWCQq character write
    92.    overriding
    93.    procedure POC (the_FW      : in out FW.device;
    94.                   Q_operand   : in KDF9.Q_register;
    95.                   set_offline : in Boolean);
    96.
    97.    -- TWECQq character write to End_Message
    98.    overriding
    99.    procedure POD (the_FW      : in out FW.device;
   100.                   Q_operand   : in KDF9.Q_register;
   101.                   set_offline : in Boolean);
   102.
   103.    procedure enable (b : in KDF9.buffer_number);
   104.
   105. private
   106.
   107.    type flexowriter_mode is
   108.       (the_flexowriter_is_reading, the_flexowriter_is_writing);
   109.
   110.    -- The Flexowriter has separate input and output streams, to accommodate the console I/O API
   111.    --    of MS Windows, which requires separate pseudo-devices for input and output.
   112.    type device is new IOC.slow.shift.device with
   113.       record
   114.          output : host_IO.stream;
   115.          mode   : FW.flexowriter_mode;
   116.          shifts : KDF9.word := 0;
   117.       end record;
   118.
   119.    overriding
   120.    procedure Initialize (the_FW : in out FW.device);
   121.
   122.    overriding
   123.    procedure Finalize (the_FW : in out FW.device);
   124.
   125.    overriding
   126.    procedure write (the_FW    : in out FW.device;
   127.                     Q_operand : in KDF9.Q_register);
   128.
   129.    overriding
   130.    procedure write_to_EM (the_FW    : in out FW.device;
   131.                           Q_operand : in KDF9.Q_register);
   132.    overriding
   133.    procedure words_write (the_FW    : in out FW.device;
   134.                           Q_operand : in KDF9.Q_register);
   135.
   136.    overriding
   137.    procedure words_write_to_EM (the_FW    : in out FW.device;
   138.                                 Q_operand : in KDF9.Q_register);
   139.
   140.    overriding
   141.    procedure do_output_housekeeping (the_FW   : in out FW.device;
   142.                                      written,
   143.                                      fetched  : in KDF9.word);
   144.
   145. end IOC.slow.shift.FW;

 679 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-gp.adb
Source file time stamp: 2021-02-08 01:19:09
Compiled at: 2021-02-08 17:21:00

     1. -- Emulation of a Calcomp 564 graph plotter, switched to a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16. with formatting;
    17. with HCI;
    18. with IOC.equipment;
    19. with plotter;
    20. with postscript;
    21. with settings;
    22. with tracing;
    23.
    24. use  formatting;
    25. use  HCI;
    26. use  IOC.equipment;
    27. use  plotter;
    28. use  postscript;
    29. use  settings;
    30. use  tracing;
    31.
    32. package body IOC.slow.shift.GP is
    33.
    34.    overriding
    35.    procedure Initialize (the_GP : in out GP.device) is
    36.    begin
    37.       -- Ready the graph plotter driver and PostScript output file.
    38.       the_GP.device_name := device_name_of(the_GP);
    39.       open(the_GP.stream, the_GP.device_name, write_mode);
    40.       IOC.device(the_GP).Initialize;
    41.       if the_GP.is_open then
    42.          truncate(the_GP.stream, to_length => 0);
    43.          initialize_PS_output(the_GP.stream);
    44.          open_the_plot_file(the_GP.stream);
    45.       end if;
    46.    end Initialize;
    47.
    48.    overriding
    49.    procedure Finalize (the_GP : in out GP.device) is
    50.    begin
    51.       if the_GP.is_open           and then
    52.             the_GP.byte_count /= 0    then
    53.          if the_final_state_is_wanted then
    54.             log_line(
    55.                      the_GP.device_name
    56.                    & " on buffer #"
    57.                    & oct_of(KDF9.Q_part(the_GP.number), 2)
    58.                    & " made"
    59.                    & the_GP.byte_count'Image
    60.                    & " plotting steps."
    61.                     );
    62.          end if;
    63.          the_GP.byte_count := 0;
    64.          close_the_plot_file(the_GP.stream);
    65.          finalize_PS_output(the_GP.stream);
    66.       end if;
    67.    end Finalize;
    68.
    69.    -- the_T_bit_is_set (the buffer has been switched from a tape punch to a graph plotter)
    70.    overriding
    71.    procedure PMB (the_GP      : in out GP.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean) is
    74.    begin
    75.       validate_device(the_GP, Q_operand);
    76.       validate_parity(the_GP);
    77.       deal_with_a_busy_device(the_GP, 13, set_offline);
    78.       the_T_bit_is_set := True;
    79.       take_note_of_test(the_GP.device_name, Q_operand, the_T_bit_is_set);
    80.    end PMB;
    81.
    82.    GP_quantum   : constant := 1E6 / 200;  -- 200 plotting movements per second.
    83.    GP_lift_time : constant := 1E6 /  10;  -- 10 pen up/down movements per second.
    84.    lift_ratio   : constant := GP_lift_time / GP_quantum;
    85.
    86.    overriding
    87.    procedure do_output_housekeeping (the_GP      : in out GP.device;
    88.                                      size, lifts : in     KDF9.word) is
    89.    begin
    90.       add_in_the_IO_CPU_time(the_GP, size);
    91.       correct_transfer_time(the_GP, size - lifts + lifts * lift_ratio);
    92.    end do_output_housekeeping;
    93.
    94.    procedure put_symbols (the_GP    : in out GP.device;
    95.                           Q_operand : in KDF9.Q_register) is
    96.       start_address : constant KDF9.address := Q_operand.I;
    97.       end_address   : constant KDF9.address := Q_operand.M;
    98.       size    : KDF9.word := 0;
    99.       lifts   : KDF9.word := 0;
   100.       command : plotter.command;
   101.    begin
   102.       check_addresses_and_lockouts(start_address, end_address);
   103.    word_loop:
   104.       for w in start_address .. end_address loop
   105.          for c in KDF9_char_sets.symbol_index'Range loop
   106.             command := plotter.command(fetch_symbol(w, c));
   107.             perform(command, the_GP.stream);
   108.             size := size + 1;
   109.             the_GP.byte_count := the_GP.byte_count + 1;
   110.             if command in pen_up | pen_down then
   111.                -- These actions are much slower than plotting movements.
   112.                lifts := lifts + 1;
   113.             end if;
   114.          end loop;
   115.       end loop word_loop;
   116.       do_output_housekeeping (the_GP, size, lifts);
   117.    end put_symbols;
   118.
   119.    overriding
   120.    procedure POA (the_GP      : in out GP.device;
   121.                   Q_operand   : in KDF9.Q_register;
   122.                   set_offline : in Boolean) is
   123.    begin
   124.       start_slow_transfer(the_GP, Q_operand, set_offline, output_operation);
   125.       put_symbols(the_GP, Q_operand);
   126.       lock_out_relative_addresses(Q_operand);
   127.    end POA;
   128.
   129.    overriding
   130.    procedure POB (the_GP      : in out GP.device;
   131.                   Q_operand   : in KDF9.Q_register;
   132.                   set_offline : in Boolean) is
   133.    begin
   134.       -- See the Manual Appendix 6, §5.2, p.303.
   135.       POA(the_GP, Q_operand, set_offline);
   136.    end POB;
   137.
   138.    procedure put_words (the_GP    : in out GP.device;
   139.                         Q_operand : in KDF9.Q_register) is
   140.       start_address : constant KDF9.address := Q_operand.I;
   141.       end_address   : constant KDF9.address := Q_operand.M;
   142.       size    : KDF9.word := 0;
   143.       lifts   : KDF9.word := 0;
   144.       command : plotter.command;
   145.    begin
   146.       check_addresses_and_lockouts(start_address, end_address);
   147.       for w in start_address .. end_address loop
   148.          -- Ony the last 6 bits (character 7) of each word are used.
   149.          command := plotter.command(fetch_symbol(w, 7));
   150.          perform(command, the_GP.stream);
   151.          size := size + 1;
   152.          the_GP.byte_count := the_GP.byte_count + 1;
   153.          if command in pen_up | pen_down then
   154.             -- These actions are much slower than plotting movements.
   155.             lifts := lifts + 1;
   156.          end if;
   157.       end loop;
   158.       do_output_housekeeping (the_GP, size, lifts);
   159.    end put_words;
   160.
   161.    overriding
   162.    procedure POC (the_GP      : in out GP.device;
   163.                   Q_operand   : in KDF9.Q_register;
   164.                   set_offline : in Boolean) is
   165.    begin
   166.       start_slow_transfer(the_GP, Q_operand, set_offline, output_operation);
   167.       put_words(the_GP, Q_operand);
   168.       lock_out_relative_addresses(Q_operand);
   169.    end POC;
   170.
   171.    overriding
   172.    procedure POD (the_GP      : in out GP.device;
   173.                   Q_operand   : in KDF9.Q_register;
   174.                   set_offline : in Boolean) is
   175.    begin
   176.       -- See the Manual Appendix 6, §5.2, p.303.
   177.       POC(the_GP, Q_operand, set_offline);
   178.    end POD;
   179.
   180.
   181.    type GP_access is access GP.device;
   182.
   183.    GP0 : GP_access with Warnings => Off;
   184.
   185.    procedure enable (b : in KDF9.buffer_number) is
   186.    begin
   187.       GP0 := new GP.device (number  => b,
   188.                             kind    => GP_kind,
   189.                             unit    => 0,
   190.                             quantum => GP_quantum);
   191.       GP0_number := b;
   192.    end enable;
   193.
   194.    procedure notify_invalid_movement (from_x, from_y, step_x, step_y : in Integer) is
   195.    begin
   196.       trap_failing_IO_operation(
   197.                                 GP0.all,
   198.                                 "cannot move from <"
   199.                               & trimmed(from_x'Image)
   200.                               & ", "
   201.                               & trimmed(from_y'Image)
   202.                               & "> by <"
   203.                               & trimmed(step_x'Image)
   204.                               & ", "
   205.                               & trimmed(step_y'Image)
   206.                               & ">"
   207.                                );
   208.    end notify_invalid_movement;
   209.
   210. end IOC.slow.shift.GP;

Compiling: ../Source/ioc-slow-shift-gp.ads
Source file time stamp: 2021-01-10 23:52:37
Compiled at: 2021-02-08 17:21:00

     1. -- Emulation of a Calcomp 564 graph plotter, switched to a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.GP is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    overriding
    22.    procedure POA (the_GP      : in out GP.device;
    23.                   Q_operand   : in KDF9.Q_register;
    24.                   set_offline : in Boolean);
    25.
    26.    overriding
    27.    procedure POB (the_GP      : in out GP.device;
    28.                   Q_operand   : in KDF9.Q_register;
    29.                   set_offline : in Boolean);
    30.
    31.    overriding
    32.    procedure POC (the_GP      : in out GP.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    overriding
    37.    procedure POD (the_GP      : in out GP.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    -- the_T_bit_is_set (buffer is switched to graph plotter)
    42.    overriding
    43.    procedure PMB (the_GP      : in out GP.device;
    44.                   Q_operand   : in KDF9.Q_register;
    45.                   set_offline : in Boolean);
    46.
    47.    procedure enable (b : in KDF9.buffer_number);
    48.
    49.    procedure notify_invalid_movement (from_x, from_y, step_x, step_y : in Integer)
    50.       with Inline => False;
    51.
    52. private
    53.
    54.    type device is new IOC.slow.shift.device with null record;
    55.
    56.    overriding
    57.    procedure Initialize (the_GP : in out GP.device);
    58.
    59.    overriding
    60.    procedure Finalize (the_GP : in out GP.device);
    61.
    62.    overriding
    63.    procedure do_output_housekeeping (the_GP      : in out GP.device;
    64.                                      size, lifts : in     KDF9.word);
    65.
    66. end IOC.slow.shift.GP;

 210 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-si.adb
Source file time stamp: 2021-02-07 23:16:54
Compiled at: 2021-02-08 17:21:00

     1. -- Emulation of a standard interface buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. --
    19. with IOC.equipment;
    20. with tracing;
    21.
    22. use  IOC.equipment;
    23. use  tracing;
    24.
    25. package body IOC.slow.shift.SI is
    26.
    27.    use KDF9_char_sets;
    28.
    29.    overriding
    30.    procedure Initialize (the_SI : in out SI.device) is
    31.    begin
    32.       -- Open the associated file.
    33.       open(IOC.device(the_SI), rd_wr_mode);
    34.    end Initialize;
    35.
    36.    overriding
    37.    procedure PIA (the_SI      : in out SI.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean) is
    40.    begin
    41.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    42.       read(the_SI, Q_operand);
    43.       lock_out_relative_addresses(Q_operand);
    44.    end PIA;
    45.
    46.    overriding
    47.    procedure PIB (the_SI      : in out SI.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean) is
    50.    begin
    51.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    52.       read_to_EM(the_SI, Q_operand);
    53.       lock_out_relative_addresses(Q_operand);
    54.    end PIB;
    55.
    56.    overriding
    57.    procedure PIC (the_SI      : in out SI.device;
    58.                   Q_operand   : in KDF9.Q_register;
    59.                   set_offline : in Boolean) is
    60.    begin
    61.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    62.       words_read(the_SI, Q_operand);
    63.       lock_out_relative_addresses(Q_operand);
    64.    end PIC;
    65.
    66.    overriding
    67.    procedure PID (the_SI      : in out SI.device;
    68.                   Q_operand   : in KDF9.Q_register;
    69.                   set_offline : in Boolean) is
    70.    begin
    71.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    72.       words_read_to_EM(the_SI, Q_operand);
    73.       lock_out_relative_addresses(Q_operand);
    74.    end PID;
    75.
    76.    overriding
    77.    procedure PIE (the_SI      : in out SI.device;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean) is
    80.    begin
    81.       -- as PIA: "parity off" has no effect on the data read in
    82.       PIA(the_SI, Q_operand, set_offline);
    83.    end PIE;
    84.
    85.    overriding
    86.    procedure PIF (the_SI      : in out SI.device;
    87.                   Q_operand   : in KDF9.Q_register;
    88.                   set_offline : in Boolean) is
    89.    begin
    90.       -- as PIB: "parity off" has no effect on the data read in
    91.       PIB(the_SI, Q_operand, set_offline);
    92.    end PIF;
    93.
    94.    overriding
    95.    procedure PIG (the_SI      : in out SI.device;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean) is
    98.    begin
    99.       PIC(the_SI, Q_operand, set_offline);
   100.    end PIG;
   101.
   102.    overriding
   103.    procedure PIH (the_SI      : in out SI.device;
   104.                   Q_operand   : in KDF9.Q_register;
   105.                   set_offline : in Boolean) is
   106.    begin
   107.       PID(the_SI, Q_operand, set_offline);
   108.    end PIH;
   109.
   110.    overriding
   111.    procedure PMB (the_SI      : in out SI.device;
   112.                   Q_operand   : in KDF9.Q_register;
   113.                   set_offline : in Boolean) is
   114.    begin
   115.       -- ee9's SI0 always asserts 8 channel mode.
   116.       validate_device(the_SI, Q_operand);
   117.       validate_parity(the_SI);
   118.       deal_with_a_busy_device(the_SI, 13, set_offline);
   119.       the_T_bit_is_set := True;
   120.       take_note_of_test(the_SI.device_name, Q_operand, the_T_bit_is_set);
   121.    end PMB;
   122.
   123.    overriding
   124.    procedure PMC (the_SI      : in out SI.device;
   125.                   Q_operand   : in KDF9.Q_register;
   126.                   set_offline : in Boolean) is
   127.    begin
   128.       PMB(the_SI, Q_operand, set_offline);
   129.    end PMC;
   130.
   131.    overriding
   132.    procedure POA (the_SI      : in out SI.device;
   133.                   Q_operand   : in KDF9.Q_register;
   134.                   set_offline : in Boolean) is
   135.    begin
   136.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   137.       write(the_SI, Q_operand);
   138.       lock_out_relative_addresses(Q_operand);
   139.    end POA;
   140.
   141.    overriding
   142.    procedure POB (the_SI      : in out SI.device;
   143.                   Q_operand   : in KDF9.Q_register;
   144.                   set_offline : in Boolean) is
   145.    begin
   146.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   147.       write_to_EM(the_SI, Q_operand);
   148.       lock_out_relative_addresses(Q_operand);
   149.    end POB;
   150.
   151.    overriding
   152.    procedure POC (the_SI      : in out SI.device;
   153.                   Q_operand   : in KDF9.Q_register;
   154.                   set_offline : in Boolean) is
   155.    begin
   156.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   157.       words_write(the_SI, Q_operand);
   158.       lock_out_relative_addresses(Q_operand);
   159.    end POC;
   160.
   161.    overriding
   162.    procedure POD (the_SI      : in out SI.device;
   163.                   Q_operand   : in KDF9.Q_register;
   164.                   set_offline : in Boolean) is
   165.    begin
   166.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   167.       words_write_to_EM(the_SI, Q_operand);
   168.       lock_out_relative_addresses(Q_operand);
   169.    end POD;
   170.
   171.    overriding
   172.    procedure POE (the_SI      : in out SI.device;
   173.                   Q_operand   : in KDF9.Q_register;
   174.                   set_offline : in Boolean) is
   175.    begin
   176.       require_nonnegative_count(Q_operand.M);
   177.       output_a_gap(the_SI, Q_operand, set_offline, word_mode => False, text_mode => False);
   178.    end POE;
   179.
   180.    overriding
   181.    procedure POF (the_SI      : in out SI.device;
   182.                   Q_operand   : in KDF9.Q_register;
   183.                   set_offline : in Boolean) is
   184.    begin
   185.       require_nonnegative_count(Q_operand.M);
   186.       output_a_gap(the_SI, Q_operand, set_offline, word_mode => True, text_mode => False);
   187.    end POF;
   188.
   189.    overriding
   190.    procedure Finalize (the_SI : in out SI.device) is
   191.    begin
   192.       close(
   193.             the_SI,
   194.             "transferred",
   195.             the_SI.byte_count,
   196.             "character" & plurality(the_SI.byte_count)
   197.            );
   198.    end Finalize;
   199.
   200.    type SI_access is access SI.device;
   201.
   202.    SI0 : SI_access with Warnings => Off;
   203.    SI1 : SI_access with Warnings => Off;
   204.
   205.    unit : IOC.unit_number := 0;
   206.
   207.    SI_quantum : constant := 1E6 / 50E3;  -- for 50_000 characters per second (a guess) !!
   208.
   209.    procedure enable (b : in KDF9.buffer_number) is
   210.    begin
   211.       case unit is
   212.          when 0 =>
   213.             SI0 := new SI.device (number  => b,
   214.                                   kind    => SI_kind,
   215.                                   unit    => 0,
   216.                                   quantum => SI_quantum);
   217.             SI0_number := b;
   218.          when 1 =>
   219.             SI1 := new SI.device (number  => b,
   220.                                   kind    => SI_kind,
   221.                                   unit    => 1,
   222.                                   quantum => SI_quantum);
   223.             SI1_number := b;
   224.          when others =>
   225.             trap_operator_error("more than two SI units have been configured");
   226.       end case;
   227.       unit := unit + 1;
   228.    end enable;
   229.
   230.    procedure re_enable (b : in KDF9.buffer_number) is
   231.    begin
   232.       if SI0 /= null   and then
   233.             SI0.number = b then
   234.          return;
   235.       end if;
   236.       if SI1 /= null   and then
   237.             SI1.number = b then
   238.          return;
   239.       end if;
   240.       buffer(b) := null;
   241.       enable(b);
   242.    end re_enable;
   243.
   244.    function SI0_is_enabled
   245.    return Boolean
   246.    is (SI0 /= null or SI1 /= null);
   247.
   248. end IOC.slow.shift.SI;

Compiling: ../Source/ioc-slow-shift-si.ads
Source file time stamp: 2021-01-10 23:52:37
Compiled at: 2021-02-08 17:21:00

     1. -- Emulation of a standard interface buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.SI is
    18.
    19.    -- The Standard Interface Buffer is the KDF9 device about which least is presently known.
    20.    -- Anecdotal evidence suggests it is an implementation of the British Standard Interface (BSIF).
    21.    -- ee9 implements a best guess as to its functionality, based on the following considerations.
    22.
    23.    -- According to the Manual, Appendix 6.1, p.296,
    24.    --    the Standard Interface Buffer has orders that look very like the union of a TR and a TP.
    25.
    26.    -- However:
    27.
    28.    -- (a) PIE and PIF do a read with "parity off".
    29.    --     I think this relates to a feature of the BSIF,
    30.    --        whereby a source device can omit parity if it de-asserts its "parity valid" signal.
    31.    --     With such a device the KDF9 would need a way of ignoring spurious parity errors.
    32.    -- PIE/PIF act in exactly the same way as PIA/PIB as there will be no such error under ee9.
    33.
    34.    -- (b) PMB and PMC set the Test Register "if 8 channel set".  The BSIF is 8 data bits wide.
    35.    --     I think this signals that the KDF9 should use "character" orders to access all 8 bits,
    36.    --        and I think that the other orders access only the low-order 6 bits of the interface.
    37.    -- ee9 always asserts "8 channel set", as it is always capable of providing 8-bit bytes.
    38.
    39.    -- In any case, 6-bit transfers work in the same way as for paper tape readers and punches.
    40.
    41.    type device is new IOC.slow.shift.device with private;
    42.
    43.    overriding
    44.    procedure PIA (the_SI      : in out SI.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    overriding
    49.    procedure PIB (the_SI      : in out SI.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    overriding
    54.    procedure PIC (the_SI      : in out SI.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    overriding
    59.    procedure PID (the_SI      : in out SI.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    overriding
    64.    procedure PIE (the_SI      : in out SI.device;
    65.                   Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    overriding
    69.    procedure PIF (the_SI      : in out SI.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean);
    72.
    73.    overriding
    74.    procedure PIG (the_SI      : in out SI.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.
    78.    overriding
    79.    procedure PIH (the_SI      : in out SI.device;
    80.                   Q_operand   : in KDF9.Q_register;
    81.                   set_offline : in Boolean);
    82.
    83.    overriding
    84.    procedure PMB (the_SI      : in out SI.device;
    85.                   Q_operand   : in KDF9.Q_register;
    86.                   set_offline : in Boolean);
    87.
    88.    overriding
    89.    procedure PMC (the_SI      : in out SI.device;
    90.                   Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean);
    92.
    93.    overriding
    94.    procedure POA (the_SI      : in out SI.device;
    95.                   Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean);
    97.
    98.    overriding
    99.    procedure POB (the_SI      : in out SI.device;
   100.                   Q_operand   : in KDF9.Q_register;
   101.                   set_offline : in Boolean);
   102.
   103.    overriding
   104.    procedure POC (the_SI      : in out SI.device;
   105.                   Q_operand   : in KDF9.Q_register;
   106.                   set_offline : in Boolean);
   107.
   108.    overriding
   109.    procedure POD (the_SI      : in out SI.device;
   110.                   Q_operand   : in KDF9.Q_register;
   111.                   set_offline : in Boolean);
   112.
   113.    overriding
   114.    procedure POE (the_SI      : in out SI.device;
   115.                   Q_operand   : in KDF9.Q_register;
   116.                   set_offline : in Boolean);
   117.
   118.    overriding
   119.    procedure POF (the_SI      : in out SI.device;
   120.                   Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean);
   122.
   123.    procedure enable (b : in KDF9.buffer_number);
   124.
   125.    procedure re_enable (b : in KDF9.buffer_number);
   126.
   127.    function SI0_is_enabled
   128.    return Boolean;
   129.
   130. private
   131.
   132.    type device is new IOC.slow.shift.device with null record;
   133.
   134.    overriding
   135.    procedure Initialize (the_SI : in out SI.device);
   136.
   137.    overriding
   138.    procedure Finalize (the_SI : in out SI.device);
   139.
   140. end IOC.slow.shift.SI;

 248 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-unit.adb
Source file time stamp: 2021-01-10 23:52:38
Compiled at: 2021-02-08 17:21:00

     1. -- Emulation of the common functionality of "unit record" (i.e. LP, CP or CR) devices.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.unit is
    18.
    19.    overriding
    20.    function IO_elapsed_time_total (the_buffer : unit.device)
    21.    return KDF9.us is
    22.    begin
    23.       return IO_elapsed_time(the_buffer, the_buffer.unit_count);
    24.    end IO_elapsed_time_total;
    25.
    26.    overriding
    27.    function atomic_item_count (the_buffer : unit.device;
    28.                                Q_operand  : KDF9.Q_register)
    29.    return KDF9.word is
    30.       pragma Unreferenced(the_buffer);
    31.       pragma Unreferenced(Q_operand);
    32.    begin
    33.       return 1;
    34.    end atomic_item_count;
    35.
    36. end IOC.slow.unit;

Compiling: ../Source/ioc-slow-unit.ads
Source file time stamp: 2021-01-10 23:52:38
Compiled at: 2021-02-08 17:21:00

     1. -- Emulation of the common functionality of "unit record" (i.e. LP, CP or CR) devices.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.unit is
    18.
    19.    --
    20.    -- This is the root type for all unit-record I/O device types.
    21.    --
    22.
    23.    type device is abstract new IOC.slow.device with private;
    24.
    25. private
    26.
    27.    type device is abstract new IOC.slow.device with
    28.       record
    29.          unit_count : KDF9.word := 0;
    30.       end record;
    31.
    32.    overriding
    33.    function IO_elapsed_time_total (the_buffer : unit.device)
    34.    return KDF9.us;
    35.
    36.    overriding
    37.    function atomic_item_count (the_buffer : unit.device;
    38.                                Q_operand  : KDF9.Q_register)
    39.    return KDF9.word;
    40.
    41. end IOC.slow.unit;

 36 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-unit-cp.adb
Source file time stamp: 2021-02-07 23:16:54
Compiled at: 2021-02-08 17:21:00

     1. -- Emulation of a card punch buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.equipment;
    18.
    19. use  IOC.equipment;
    20.
    21. package body IOC.slow.unit.CP is
    22.
    23.    use KDF9_char_sets;
    24.
    25.    overriding
    26.    procedure Initialize (the_CP : in out CP.device) is
    27.    begin
    28.       open(the_CP, write_mode);
    29.    end Initialize;
    30.
    31.    procedure do_output_housekeeping (the_CP     : in out CP.device;
    32.                                      fetched    : in KDF9.word) is
    33.    begin
    34.       flush(the_CP.stream);
    35.       correct_transfer_time(the_CP, actual_length => 1);
    36.       add_in_the_IO_CPU_time(the_CP, fetched);
    37.    end do_output_housekeeping;
    38.
    39.    procedure write_card (the_CP        : in out CP.device;
    40.                          Q_operand     : in KDF9.Q_register;
    41.                          max_words     : in KDF9.address;
    42.                          writing_to_EM : in Boolean := False) is
    43.       start_address : constant KDF9.address := Q_operand.I;
    44.       end_address   : constant KDF9.address := Q_operand.M;
    45.       size : KDF9.word := 0;
    46.       char : Character;
    47.       byte : KDF9_char_sets.symbol;
    48.    begin
    49.       check_addresses_and_lockouts(start_address, end_address);
    50.    word_loop:
    51.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    52.          for c in KDF9_char_sets.symbol_index'Range loop
    53.             byte := fetch_symbol(w, c);
    54.             size := size + 1;
    55.             char := to_CP(byte);
    56.             put_byte(char, the_CP.stream);
    57.             exit word_loop when writing_to_EM and char = KDF9_char_sets.E_M;
    58.          end loop;
    59.       end loop word_loop;
    60.       put_EOL(the_CP.stream);
    61.       the_CP.unit_count := the_CP.unit_count + 1;
    62.       do_output_housekeeping(the_CP, fetched => size);
    63.    end write_card;
    64.
    65.    procedure words_write_card (the_CP        : in out CP.device;
    66.                                Q_operand     : in KDF9.Q_register;
    67.                                max_words     : in KDF9.address;
    68.                                writing_to_EM : in Boolean := False) is
    69.
    70.       start_address : constant KDF9.address := Q_operand.I;
    71.       end_address   : constant KDF9.address := Q_operand.M;
    72.       size : KDF9.word := 0;
    73.       char : Character;
    74.       byte : KDF9_char_sets.symbol;
    75.    begin
    76.       check_addresses_and_lockouts(start_address, end_address);
    77.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    78.          byte := KDF9_char_sets.symbol(fetch_word(w) and 8#77#);
    79.          size := size + 1;
    80.          char := to_CP(byte);
    81.          put_byte(char, the_CP.stream);
    82.       exit when writing_to_EM and char = KDF9_char_sets.E_M;
    83.       end loop;
    84.       put_EOL(the_CP.stream);
    85.       the_CP.unit_count := the_CP.unit_count + 1;
    86.       do_output_housekeeping(the_CP, fetched => size);
    87.    end words_write_card;
    88.
    89.    overriding
    90.    procedure POA (the_CP      : in out CP.device;
    91.                   Q_operand   : in KDF9.Q_register;
    92.                   set_offline : in Boolean) is
    93.    begin
    94.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
    95.       write_card(the_CP, Q_operand, max_words => 20);
    96.       lock_out_relative_addresses(Q_operand);
    97.    end POA;
    98.
    99.    overriding
   100.    procedure POB (the_CP      : in out CP.device;
   101.                   Q_operand   : in KDF9.Q_register;
   102.                   set_offline : in Boolean) is
   103.    begin
   104.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   105.       write_card(the_CP, Q_operand, max_words => 20, writing_to_EM => True);
   106.       lock_out_relative_addresses(Q_operand);
   107.    end POB;
   108.
   109.    overriding
   110.    procedure POC (the_CP      : in out CP.device;
   111.                   Q_operand   : in KDF9.Q_register;
   112.                   set_offline : in Boolean) is
   113.    begin
   114.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   115.       words_write_card(the_CP, Q_operand, max_words => 160);
   116.       lock_out_relative_addresses(Q_operand);
   117.    end POC;
   118.
   119.    overriding
   120.    procedure POD (the_CP      : in out CP.device;
   121.                   Q_operand   : in KDF9.Q_register;
   122.                   set_offline : in Boolean) is
   123.    begin
   124.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   125.       words_write_card(the_CP, Q_operand, max_words => 160, writing_to_EM => True);
   126.       lock_out_relative_addresses(Q_operand);
   127.    end POD;
   128.
   129.    overriding
   130.    procedure POE (the_CP      : in out CP.device;
   131.                   Q_operand   : in KDF9.Q_register;
   132.                   set_offline : in Boolean) is
   133.    begin
   134.       POC(the_CP, Q_operand, set_offline);
   135.    end POE;
   136.
   137.    overriding
   138.    procedure POF (the_CP      : in out CP.device;
   139.                   Q_operand   : in KDF9.Q_register;
   140.                   set_offline : in Boolean) is
   141.    begin
   142.       POA(the_CP, Q_operand, set_offline);
   143.    end POF;
   144.
   145.    overriding
   146.    procedure POG (the_CP      : in out CP.device;
   147.                   Q_operand   : in KDF9.Q_register;
   148.                   set_offline : in Boolean) is
   149.    begin
   150.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   151.       write_card(the_CP, Q_operand, max_words => 10, writing_to_EM => False);
   152.       lock_out_relative_addresses(Q_operand);
   153.    end POG;
   154.
   155.    overriding
   156.    procedure POH (the_CP      : in out CP.device;
   157.                   Q_operand   : in KDF9.Q_register;
   158.                   set_offline : in Boolean) is
   159.    begin
   160.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   161.       write_card(the_CP, Q_operand, max_words => 10, writing_to_EM => True);
   162.       lock_out_relative_addresses(Q_operand);
   163.    end POH;
   164.
   165.    overriding
   166.    procedure POK (the_CP      : in out CP.device;
   167.                   Q_operand   : in KDF9.Q_register;
   168.                   set_offline : in Boolean) is
   169.    begin
   170.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   171.       -- See the Manual, p289.
   172.       words_write_card(the_CP, Q_operand, max_words => 80, writing_to_EM => True);
   173.       lock_out_relative_addresses(Q_operand);
   174.    end POK;
   175.
   176.    overriding
   177.    procedure POL (the_CP      : in out CP.device;
   178.                   Q_operand   : in KDF9.Q_register;
   179.                   set_offline : in Boolean) is
   180.    begin
   181.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   182.       -- See the Manual, p289.
   183.       words_write_card(the_CP, Q_operand, max_words => 80, writing_to_EM => False);
   184.       lock_out_relative_addresses(Q_operand);
   185.    end POL;
   186.
   187.    overriding
   188.    procedure Finalize (the_CP : in out CP.device) is
   189.    begin
   190.       close(
   191.             the_CP,
   192.             "punched",
   193.             the_CP.unit_count,
   194.             "card" & plurality(the_CP.unit_count)
   195.            );
   196.    end Finalize;
   197.
   198.    CP_quantum : constant := 1E6 / (300 / 60); -- 300 cards per minute.
   199.
   200.    type CP_access is access CP.device;
   201.
   202.    CP0 : CP_access with Warnings => Off;
   203.    CP1 : CP_access with Warnings => Off;
   204.
   205.    unit : IOC.unit_number := 0;
   206.
   207.    procedure enable (b : in KDF9.buffer_number) is
   208.    begin
   209.       case unit is
   210.          when 0 =>
   211.             CP0 := new CP.device (number  => b,
   212.                                   kind    => CP_kind,
   213.                                   unit    => 0,
   214.                                   quantum => CP_quantum);
   215.             CP0_number := b;
   216.          when 1 =>
   217.             CP1 := new CP.device (number  => b,
   218.                                   kind    => CP_kind,
   219.                                   unit    => 1,
   220.                                   quantum => CP_quantum);
   221.             CP1_number := b;
   222.          when others =>
   223.             trap_operator_error("more than two CP units have been configured");
   224.       end case;
   225.       unit := unit + 1;
   226.    end enable;
   227.
   228. end IOC.slow.unit.CP;

Compiling: ../Source/ioc-slow-unit-cp.ads
Source file time stamp: 2021-01-10 23:52:37
Compiled at: 2021-02-08 17:21:00

     1. -- Emulation of a card punch buffer.
     2. -- Card punches are "unit record" devices: they cannot transfer less than a whole card.
     3. --
     4. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package IOC.slow.unit.CP is
    19.
    20.    type device is new IOC.slow.unit.device with private;
    21.
    22.    -- Punch binary mode.
    23.    overriding
    24.    procedure POA (the_CP      : in out CP.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    -- Punch binary mode to End Message.
    29.    overriding
    30.    procedure POB (the_CP      : in out CP.device;
    31.                   Q_operand   : in KDF9.Q_register;
    32.                   set_offline : in Boolean);
    33.
    34.    -- Punch binary character mode.
    35.    overriding
    36.    procedure POC (the_CP      : in out CP.device;
    37.                   Q_operand   : in KDF9.Q_register;
    38.                   set_offline : in Boolean);
    39.
    40.    -- Punch binary character mode to End Message.
    41.    overriding
    42.    procedure POD (the_CP      : in out CP.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    -- As POC.
    47.    overriding
    48.    procedure POE (the_CP      : in out CP.device;
    49.                   Q_operand   : in KDF9.Q_register;
    50.                   set_offline : in Boolean);
    51.
    52.    -- As POA.
    53.    overriding
    54.    procedure POF (the_CP      : in out CP.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    -- Punch alphanumeric mode.
    59.    overriding
    60.    procedure POG (the_CP      : in out CP.device;
    61.                   Q_operand   : in KDF9.Q_register;
    62.                   set_offline : in Boolean);
    63.
    64.    -- Punch alphanumeric mode to End Message.
    65.    overriding
    66.    procedure POH (the_CP      : in out CP.device;
    67.                   Q_operand   : in KDF9.Q_register;
    68.                   set_offline : in Boolean);
    69.
    70.    -- Punch alphanumeric character mode to End Message.
    71.    overriding
    72.    procedure POK (the_CP      : in out CP.device;
    73.                   Q_operand   : in KDF9.Q_register;
    74.                   set_offline : in Boolean);
    75.
    76.    -- Punch alphanumeric character mode.
    77.    overriding
    78.    procedure POL (the_CP      : in out CP.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean);
    81.
    82.    procedure enable (b : in KDF9.buffer_number);
    83.
    84. private
    85.
    86.    type device is new IOC.slow.unit.device with null record;
    87.
    88.    overriding
    89.    procedure Initialize (the_CP : in out CP.device);
    90.
    91.    overriding
    92.    procedure Finalize (the_CP : in out CP.device);
    93.
    94. end IOC.slow.unit.CP;

 228 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-unit-cr.adb
Source file time stamp: 2021-02-07 23:16:54
Compiled at: 2021-02-08 17:21:01

     1. -- Emulation of a card reader buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.equipment;
    18. with tracing;
    19.
    20. use  IOC.equipment;
    21. use  tracing;
    22.
    23. package body IOC.slow.unit.CR is
    24.
    25.    use KDF9_char_sets;
    26.
    27.    overriding
    28.    procedure Initialize (the_CR : in out CR.device) is
    29.    begin
    30.       open(the_CR, read_mode);
    31.    end Initialize;
    32.
    33.    blank_card : constant String(max_card_columns) := (others => SP);
    34.
    35.    procedure get_card_image (the_CR         : in out CR.device;
    36.                               size          : in out KDF9.word;
    37.                               max_columns   : in KDF9.address;
    38.                               reading_to_EM : in Boolean := False) is
    39.       max  : constant Positive := Positive(max_columns);
    40.       char : Character;
    41.    begin
    42.       -- Clear out the card image field.
    43.       the_CR.card_image(1..max) := blank_card(1..max);
    44.       -- Fill as much of the card image as possible with the next data line, padded out with
    45.       --    blanks, so that it is unnecessary to type all 80 or 160 characters.
    46.       -- For transfers to End Message, a line terminator must follow the E_M.
    47.       for i in 1 .. max loop
    48.          get_char_from_stream (char, the_CR);
    49.          size := size + 1;
    50.       exit when char = LF;
    51.          the_CR.card_image(i) := char;
    52.       exit when reading_to_EM and char = KDF9_char_sets.E_M;
    53.       end loop;
    54.       if char /= KDF9_char_sets.E_M then  -- The whole card was read.
    55.          size := KDF9.word(max);
    56.       end if;
    57.       the_CR.unit_count := the_CR.unit_count + 1;
    58.       -- Discard excess characters in the current data line.
    59.       while char /= LF loop
    60.          get_char_from_stream (char, the_CR);  -- N.B. do not update size for discards.
    61.       end loop;
    62.    exception
    63.       when end_of_stream =>
    64.          flush(the_CR.stream);
    65.          the_CR.is_abnormal := True;
    66.          raise;
    67.    end get_card_image;
    68.
    69.    procedure do_input_housekeeping (the_CR  : in out CR.device;
    70.                                     fetched : in KDF9.word) is
    71.    begin
    72.       add_in_the_IO_CPU_time(the_CR, fetched);
    73.       correct_transfer_time(the_CR, actual_length => 1);
    74.    end do_input_housekeeping;
    75.
    76.    procedure read_card (the_CR        : in out CR.device;
    77.                         Q_operand     : in KDF9.Q_register;
    78.                         max_words     : in KDF9.address;
    79.                         reading_to_EM : in Boolean := False) is
    80.       start_address : constant KDF9.address := Q_operand.I;
    81.       end_address   : constant KDF9.address := Q_operand.M;
    82.       size : KDF9.word := 0;
    83.       next : Natural := 0;
    84.       char : Character;
    85.       byte : KDF9_char_sets.symbol;
    86.    begin
    87.       check_addresses_and_lockouts(start_address, end_address);
    88.       get_card_image(the_CR, size, max_columns => max_words*8);
    89.    word_loop:
    90.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    91.          for c in KDF9_char_sets.symbol_index'Range loop
    92.             next := next + 1;
    93.             char := the_CR.card_image(next);
    94.             byte := CR_in(char);
    95.             store_symbol(byte, w, c);
    96.             if reading_to_EM and byte = KDF9_char_sets.End_Message then
    97.                for d in 1 .. 7-c loop
    98.                   store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
    99.                end loop;
   100.                exit word_loop;
   101.             end if;
   102.          end loop;
   103.       end loop word_loop;
   104.       do_input_housekeeping(the_CR, size);
   105.    exception
   106.       when end_of_stream =>
   107.          do_input_housekeeping(the_CR, size);
   108.    end read_card;
   109.
   110.    procedure words_read_card (the_CR        : in out CR.device;
   111.                               Q_operand     : in KDF9.Q_register;
   112.                               max_words     : in KDF9.address;
   113.                               reading_to_EM : in Boolean := False) is
   114.       start_address : constant KDF9.address := Q_operand.I;
   115.       end_address   : constant KDF9.address := Q_operand.M;
   116.       size : KDF9.word := 0;
   117.       next : Natural := 0;
   118.       char : Character;
   119.       word : KDF9.word;
   120.    begin
   121.       check_addresses_and_lockouts(start_address, end_address);
   122.       get_card_image(the_CR, size, max_columns => max_words);
   123.       if the_CR.is_abnormal then return; end if;
   124.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
   125.          next := next + 1;
   126.          char := the_CR.card_image(next);
   127.          word := KDF9.word(CR_in(char));
   128.          store_word(word, w);
   129.       exit when reading_to_EM and char = KDF9_char_sets.E_M;
   130.       end loop;
   131.       add_in_the_IO_CPU_time(the_CR, size);
   132.       correct_transfer_time(the_CR, actual_length => 1);
   133.    exception
   134.       when end_of_stream =>
   135.          flush(the_CR.stream);
   136.          add_in_the_IO_CPU_time(the_CR, size);
   137.          correct_transfer_time(the_CR, actual_length => 1);
   138.    end words_read_card;
   139.
   140.    overriding
   141.    procedure PIA (the_CR      : in out CR.device;
   142.                   Q_operand   : in KDF9.Q_register;
   143.                   set_offline : in Boolean) is
   144.    begin
   145.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   146.       read_card(the_CR, Q_operand, max_words => 20);
   147.       lock_out_relative_addresses(Q_operand);
   148.    end PIA;
   149.
   150.    overriding
   151.    procedure PIB (the_CR      : in out CR.device;
   152.                   Q_operand   : in KDF9.Q_register;
   153.                   set_offline : in Boolean) is
   154.    begin
   155.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   156.       read_card(the_CR, Q_operand, max_words => 20, reading_to_EM => True);
   157.       lock_out_relative_addresses(Q_operand);
   158.    end PIB;
   159.
   160.    overriding
   161.    procedure PIC (the_CR      : in out CR.device;
   162.                   Q_operand   : in KDF9.Q_register;
   163.                   set_offline : in Boolean) is
   164.    begin
   165.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   166.       words_read_card(the_CR, Q_operand, max_words => 160);
   167.       lock_out_relative_addresses(Q_operand);
   168.    end PIC;
   169.
   170.    overriding
   171.    procedure PID (the_CR      : in out CR.device;
   172.                   Q_operand   : in KDF9.Q_register;
   173.                   set_offline : in Boolean) is
   174.    begin
   175.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   176.       words_read_card(the_CR, Q_operand, max_words => 160, reading_to_EM => True);
   177.       lock_out_relative_addresses(Q_operand);
   178.    end PID;
   179.
   180.    overriding
   181.    procedure PIE (the_CR      : in out CR.device;
   182.                   Q_operand   : in KDF9.Q_register;
   183.                   set_offline : in Boolean) is
   184.    begin
   185.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   186.       read_card(the_CR, Q_operand, max_words => 10);
   187.       lock_out_relative_addresses(Q_operand);
   188.    end PIE;
   189.
   190.    overriding
   191.    procedure PIF (the_CR      : in out CR.device;
   192.                   Q_operand   : in KDF9.Q_register;
   193.                   set_offline : in Boolean) is
   194.    begin
   195.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   196.       read_card(the_CR, Q_operand, max_words => 10, reading_to_EM => True);
   197.       lock_out_relative_addresses(Q_operand);
   198.    end PIF;
   199.
   200.    overriding
   201.    procedure PIG (the_CR      : in out CR.device;
   202.                   Q_operand   : in KDF9.Q_register;
   203.                   set_offline : in Boolean) is
   204.    begin
   205.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   206.       words_read_card(the_CR, Q_operand, max_words => 80);
   207.       lock_out_relative_addresses(Q_operand);
   208.    end PIG;
   209.
   210.    overriding
   211.    procedure PIH (the_CR      : in out CR.device;
   212.                   Q_operand   : in KDF9.Q_register;
   213.                   set_offline : in Boolean) is
   214.    begin
   215.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   216.       words_read_card(the_CR, Q_operand, max_words => 80, reading_to_EM => True);
   217.       lock_out_relative_addresses(Q_operand);
   218.    end PIH;
   219.
   220.    -- the_T_bit_is_set := (RECHECK switch is OFF). {It always is nowadays!}
   221.    overriding
   222.    procedure PMB (the_CR      : in out CR.device;
   223.                   Q_operand   : in KDF9.Q_register;
   224.                   set_offline : in Boolean) is
   225.    begin
   226.       validate_device(the_CR, Q_operand);
   227.       validate_parity(the_CR);
   228.       deal_with_a_busy_device(the_CR, 13, set_offline);
   229.       the_T_bit_is_set := True;
   230.       take_note_of_test(the_CR.device_name, Q_operand, the_T_bit_is_set);
   231.    end PMB;
   232.
   233.    overriding
   234.    procedure Finalize (the_CR : in out CR.device) is
   235.    begin
   236.       close(
   237.             the_CR,
   238.             "read",
   239.             the_CR.unit_count,
   240.             "card" & plurality(the_CR.unit_count)
   241.            );
   242.    end Finalize;
   243.
   244.    CR_quantum : constant := 1E6 / (600 / 60); -- 600 cards per minute.
   245.
   246.    type CR_access is access CR.device;
   247.
   248.    CR0 : CR_access with Warnings => Off;
   249.    CR1 : CR_access with Warnings => Off;
   250.
   251.    unit : IOC.unit_number := 0;
   252.
   253.    procedure enable (b : in KDF9.buffer_number) is
   254.    begin
   255.       case unit is
   256.          when 0 =>
   257.             CR0 := new CR.device (number  => b,
   258.                                   kind    => CR_kind,
   259.                                   unit    => 0,
   260.                                   quantum => CR_quantum);
   261.             CR0_number := b;
   262.          when 1 =>
   263.             CR1 := new CR.device (number  => b,
   264.                                   kind    => CR_kind,
   265.                                   unit    => 1,
   266.                                   quantum => CR_quantum);
   267.             CR1_number := b;
   268.          when others =>
   269.             trap_operator_error("more than two CR units have been configured");
   270.       end case;
   271.       unit := unit + 1;
   272.    end enable;
   273.
   274. end IOC.slow.unit.CR;

Compiling: ../Source/ioc-slow-unit-cr.ads
Source file time stamp: 2021-01-10 23:52:37
Compiled at: 2021-02-08 17:21:01

     1. -- Emulation of a card reader buffer.
     2. -- Card readers are "unit record" devices: they cannot transfer less than a whole card.
     3. --
     4. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package IOC.slow.unit.CR is
    19.
    20.    type device is new IOC.slow.unit.device with private;
    21.
    22.    -- Binary (undecoded) read
    23.    overriding
    24.    procedure PIA (the_CR      : in out CR.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    -- Binary (undecoded) read to End_Message
    29.    overriding
    30.    procedure PIB (the_CR      : in out CR.device;
    31.                   Q_operand   : in KDF9.Q_register;
    32.                   set_offline : in Boolean);
    33.
    34.    -- Binary (undecoded) character read
    35.    overriding
    36.    procedure PIC (the_CR      : in out CR.device;
    37.                   Q_operand   : in KDF9.Q_register;
    38.                   set_offline : in Boolean);
    39.
    40.    -- Binary (undecoded) character read to End_Message
    41.    overriding
    42.    procedure PID (the_CR      : in out CR.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    -- Alphanumeric (decoded) read
    47.    overriding
    48.    procedure PIE (the_CR      : in out CR.device;
    49.                   Q_operand   : in KDF9.Q_register;
    50.                   set_offline : in Boolean);
    51.
    52.    -- Alphanumeric (decoded) read to End_Message
    53.    overriding
    54.    procedure PIF (the_CR      : in out CR.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    -- Alphanumeric (decoded) character read
    59.    overriding
    60.    procedure PIG (the_CR      : in out CR.device;
    61.                   Q_operand   : in KDF9.Q_register;
    62.                   set_offline : in Boolean);
    63.
    64.    -- Alphanumeric (decoded) character read to End_Message
    65.    overriding
    66.    procedure PIH (the_CR      : in out CR.device;
    67.                   Q_operand   : in KDF9.Q_register;
    68.                   set_offline : in Boolean);
    69.
    70.    -- the_T_bit_is_set := (RECHECK switch is OFF)
    71.    overriding
    72.    procedure PMB (the_CR      : in out CR.device;
    73.                   Q_operand   : in KDF9.Q_register;
    74.                   set_offline : in Boolean);
    75.
    76.    procedure enable (b : in KDF9.buffer_number);
    77.
    78. private
    79.
    80.    subtype max_card_columns is Positive range 1 .. 160;
    81.
    82.    type device is new IOC.slow.unit.device with
    83.       record
    84.          card_image : String(max_card_columns);
    85.       end record;
    86.
    87.    overriding
    88.    procedure Initialize (the_CR : in out CR.device);
    89.
    90.    overriding
    91.    procedure Finalize (the_CR : in out CR.device);
    92.
    93. end IOC.slow.unit.CR;

 274 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-unit-lp.adb
Source file time stamp: 2021-02-07 23:16:54
Compiled at: 2021-02-08 17:21:01

     1. -- Emulation of a lineprinter buffer.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.equipment;
    18.
    19. use  IOC.equipment;
    20.
    21. package body IOC.slow.unit.LP is
    22.
    23.    use KDF9_char_sets;
    24.
    25.    overriding
    26.    procedure Initialize (the_LP : in out LP.device) is
    27.    begin
    28.       open(the_LP, write_mode);
    29.    end Initialize;
    30.
    31.    max_LP_line_length : constant := 160;  -- This is a hardware limit.
    32.    max_LP_page_length : constant :=  66;  -- This is the length of a page of standard stationery.
    33.
    34.    -- The number of lines traversed by paper motion with a standard control loop.
    35.    function skip_length (the_LP : LP.device; symbol : KDF9_char_sets.symbol)
    36.    return KDF9.word
    37.    is (
    38.        if symbol = KDF9_char_sets.Page_Change
    39.        then max_LP_page_length - the_LP.unit_count mod max_LP_page_length
    40.        else 1
    41.       );
    42.
    43.    procedure do_output_housekeeping (the_LP   : in out LP.device;
    44.                                      old_count,
    45.                                      fetched  : in KDF9.word) is
    46.    begin
    47.       flush(the_LP.stream);
    48.       correct_transfer_time(the_LP, IO_elapsed_time(the_LP, the_LP.unit_count-old_count));
    49.       add_in_the_IO_CPU_time(the_LP, fetched);
    50.    end do_output_housekeeping;
    51.
    52.    next_column : Natural := 0;
    53.
    54.    procedure print (symbol : in KDF9_char_sets.symbol; the_LP : in out LP.device) is
    55.       char : constant Character := to_LP(symbol);
    56.    begin
    57.       if char /= KDF9_char_sets.W_F then
    58.          if symbol in KDF9_char_sets.Line_Shift | KDF9_char_sets.Page_Change then
    59.             the_LP.unit_count := the_LP.unit_count + skip_length(the_LP, symbol);
    60.             put_char(char, the_LP.stream);
    61.             next_column := 0;
    62.          elsif next_column < max_LP_line_length then
    63.             next_column := next_column + 1;
    64.             put_char(char, the_LP.stream);
    65.          end if;
    66.       end if;
    67.    end print;
    68.
    69.    -- It is unclear what should happen if more than max_LP_line_length printable characters
    70.    --    are sent to the printer before a LS or PC character, which empties the print matrix.
    71.    -- ee9 simply ignores the excess.
    72.
    73.    procedure put_symbols (the_LP        : in out LP.device;
    74.                           Q_operand     : in KDF9.Q_register;
    75.                           writing_to_EM : in Boolean) is
    76.       start_address : constant KDF9.address := Q_operand.I;
    77.       end_address   : constant KDF9.address := Q_operand.M;
    78.       count         : constant KDF9.word := the_LP.unit_count;
    79.       size   : KDF9.word := 0;
    80.       symbol : KDF9_char_sets.symbol;
    81.    begin
    82.       check_addresses_and_lockouts(start_address, end_address);
    83.    word_loop:
    84.       for w in start_address .. end_address loop
    85.          for c in KDF9_char_sets.symbol_index'Range loop
    86.             symbol := fetch_symbol(w, c);
    87.             size := size + 1;
    88.       -- Is this what should happen transfers on EM, leaving the print matrix ready for more data ??
    89.       exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
    90.             print(symbol, the_LP);
    91.          end loop;
    92.       end loop word_loop;
    93.       do_output_housekeeping(the_LP, old_count => count, fetched => size);
    94.    end put_symbols;
    95.
    96.    -- LPQq
    97.    overriding
    98.    procedure POA (the_LP      : in out LP.device;
    99.                   Q_operand   : in KDF9.Q_register;
   100.                   set_offline : in Boolean) is
   101.    begin
   102.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   103.       put_symbols(the_LP, Q_operand, writing_to_EM => False);
   104.       lock_out_relative_addresses(Q_operand);
   105.    end POA;
   106.
   107.    -- LPEQq
   108.    overriding
   109.    procedure POB (the_LP      : in out LP.device;
   110.                   Q_operand   : in KDF9.Q_register;
   111.                   set_offline : in Boolean) is
   112.    begin
   113.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   114.       put_symbols(the_LP, Q_operand, writing_to_EM => True);
   115.       lock_out_relative_addresses(Q_operand);
   116.    end POB;
   117.
   118.    procedure put_words (the_LP        : in out LP.device;
   119.                         Q_operand     : in KDF9.Q_register;
   120.                         writing_to_EM : in Boolean) is
   121.       start_address : constant KDF9.address := Q_operand.I;
   122.       end_address   : constant KDF9.address := Q_operand.M;
   123.       count         : constant KDF9.word := the_LP.unit_count;
   124.       size   : KDF9.word := 0;
   125.       symbol : KDF9_char_sets.symbol;
   126.    begin
   127.       check_addresses_and_lockouts(start_address, end_address);
   128.       for w in start_address .. end_address loop
   129.          symbol := KDF9_char_sets.symbol(fetch_word(w) and 8#77#);
   130.          size := size + 1;
   131.       -- Is this what should happen transfers on EM, leaving the print matrix ready for more data ??
   132.       exit when writing_to_EM and symbol = KDF9_char_sets.End_Message;
   133.          print(symbol, the_LP);
   134.       end loop;
   135.       do_output_housekeeping(the_LP, old_count => count, fetched => size);
   136.    end put_words;
   137.
   138.    -- Character write ?? Usercode Digest and Manual conflict!
   139.    overriding
   140.    procedure POC (the_LP      : in out LP.device;
   141.                   Q_operand   : in KDF9.Q_register;
   142.                   set_offline : in Boolean) is
   143.    begin
   144.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   145.       put_words(the_LP, Q_operand, writing_to_EM => False);
   146.       lock_out_relative_addresses(Q_operand);
   147.    end POC;
   148.
   149.    -- Character write to End_Message ?? Usercode Digest and Manual conflict!
   150.    overriding
   151.    procedure POD (the_LP      : in out LP.device;
   152.                   Q_operand   : in KDF9.Q_register;
   153.                   set_offline : in Boolean) is
   154.    begin
   155.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   156.       put_words(the_LP, Q_operand, writing_to_EM => True);
   157.       lock_out_relative_addresses(Q_operand);
   158.    end POD;
   159.
   160.    overriding
   161.    procedure Finalize (the_LP : in out LP.device) is
   162.    begin
   163.       close(
   164.             the_LP,
   165.             "printed",
   166.             the_LP.unit_count,
   167.             "line" & plurality(the_LP.unit_count)
   168.            );
   169.    end Finalize;
   170.
   171.    LP_quantum : constant := 1E6 / (900 / 60);  -- 900 lines per minute.
   172.
   173.    type LP_access is access LP.device;
   174.
   175.    LP0 : LP_access with Warnings => Off;
   176.    LP1 : LP_access with Warnings => Off;
   177.
   178.    unit : IOC.unit_number := 0;
   179.
   180.    procedure enable (b : in KDF9.buffer_number) is
   181.    begin
   182.       case unit is
   183.          when 0 =>
   184.             LP0 := new LP.device (number  => b,
   185.                                   kind    => LP_kind,
   186.                                   unit    => 0,
   187.                                   quantum => LP_quantum);
   188.             LP0_number := b;
   189.          when 1 =>
   190.             LP1 := new LP.device (number  => b,
   191.                                   kind    => LP_kind,
   192.                                   unit    => 1,
   193.                                   quantum => LP_quantum);
   194.             LP1_number := b;
   195.          when others =>
   196.             trap_operator_error("more than two LP units have been configured");
   197.       end case;
   198.       unit := unit + 1;
   199.    end enable;
   200.
   201. end IOC.slow.unit.LP;

Compiling: ../Source/ioc-slow-unit-lp.ads
Source file time stamp: 2021-01-10 23:52:37
Compiled at: 2021-02-08 17:21:01

     1. -- Emulation of a lineprinter buffer.
     2. -- Lineprinters are "unit record" devices: they cannot transfer less than a whole line.
     3. --
     4. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package IOC.slow.unit.LP is
    19.
    20.    type device is new IOC.slow.unit.device with private;
    21.
    22.    -- LPQq
    23.    overriding
    24.    procedure POA (the_LP      : in out LP.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    -- LPEQq
    29.    overriding
    30.    procedure POB (the_LP      : in out LP.device;
    31.                   Q_operand   : in KDF9.Q_register;
    32.                   set_offline : in Boolean);
    33.
    34.    -- Character write ??
    35.    overriding
    36.    procedure POC (the_LP      : in out LP.device;
    37.                   Q_operand   : in KDF9.Q_register;
    38.                   set_offline : in Boolean);
    39.
    40.    -- Character write to End_Message ??
    41.    overriding
    42.    procedure POD (the_LP      : in out LP.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    procedure enable (b : in KDF9.buffer_number);
    47.
    48. private
    49.
    50.    type device is new IOC.slow.unit.device with null record;
    51.
    52.    overriding
    53.    procedure Initialize (the_LP : in out LP.device);
    54.
    55.    overriding
    56.    procedure Finalize (the_LP : in out LP.device);
    57.
    58. end IOC.slow.unit.LP;

 201 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/environmental_value_of.adb
Source file time stamp: 2021-01-10 23:52:35
Compiled at: 2021-02-08 17:21:01

     1. -- Get the value of an environment variable.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Environment_Variables;
    18.
    19. function environmental_value_of (name, default : String)
    20. return String is
    21.    value : constant String := Ada.Environment_Variables.Value(name, "");
    22. begin
    23.    return (if value = "" then default else value);
    24. end environmental_value_of;

 24 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tod_clock.adb
Source file time stamp: 2021-01-11 00:01:02
Compiled at: 2021-02-08 17:21:01

     1. -- functions that implement timing for Director emulation.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Calendar;
    18. with Ada.Calendar.Time_Zones;
    19. with Ada.Calendar.Formatting;
    20.
    21. use  Ada.Calendar;
    22. use  Ada.Calendar.Time_Zones;
    23. use  Ada.Calendar.Formatting;
    24.
    25. package body KDF9.TOD_clock is
    26.
    27.    function todays_date_28n_years_ago
    28.    return KDF9.word is
    29.
    30.       zero  : constant KDF9.word := 8#20#;  -- in KDF9 internal code
    31.       slash : constant KDF9.word := 8#17#;  -- in KDF9 internal code
    32.       today : constant Ada.Calendar.Time := Ada.Calendar.Clock;
    33.
    34.       year, month, day, hour, minute, second, sub_second : KDF9.word;
    35.
    36.       -- For values of i in 0..99, return two 6-bit decimal digits in KDF9 internal code.
    37.       function as_2_digits (i : KDF9.word)
    38.       return KDF9.word
    39.       is ((i/10 + zero)*64 or (i mod 10 + zero));
    40.
    41.    begin  -- todays_date_28n_years_ago
    42.       Split(today,
    43.             Year_Number(year),
    44.             Month_Number(month),
    45.             Day_Number(day),
    46.             Hour_Number(hour),
    47.             Minute_Number(minute),
    48.             Second_Number(second),
    49.             Second_Duration(sub_second),
    50.             Time_Zone => UTC_Time_Offset(today)
    51.            );
    52.       loop  -- Repeat n > 0 times, assuming no time travel into the past!
    53.          year := year - 28;
    54.       exit when year < 2000;
    55.       end loop;
    56.       return (as_2_digits(day)*64   or slash) * 64**5  -- DD/.....
    57.           or (as_2_digits(month)*64 or slash) * 64**2  --    MM/..
    58.           or (as_2_digits((year) mod 100));            --       YY
    59.    end todays_date_28n_years_ago;
    60.
    61.    function the_time_of_day
    62.    return KDF9.us is
    63.       today : constant Ada.Calendar.Time := Ada.Calendar.Clock;
    64.       year, month, day, hour, minute, second, sub_second : KDF9.word;
    65.    begin
    66.       Split(today,
    67.             Year_Number(year),
    68.             Month_Number(month),
    69.             Day_Number(day),
    70.             Hour_Number(hour),
    71.             Minute_Number(minute),
    72.             Second_Number(second),
    73.             Second_Duration(sub_second),
    74.             Time_Zone => UTC_Time_Offset(today)
    75.            );
    76.       return KDF9.us(hour*3600 + minute*60 + second) * 1_000_000;
    77.    end the_time_of_day;
    78.
    79. end KDF9.TOD_clock;

Compiling: ../Source/kdf9-tod_clock.ads
Source file time stamp: 2021-01-10 23:52:39
Compiled at: 2021-02-08 17:21:01

     1. -- functions that implement timing for Director emulation.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TOD_clock is
    18.
    19.    -- The date a multiple of 28 years ago has the same day/date correspondence as today.
    20.    -- To avoid exposing KDF9's lack of Y2K compliance, ee9 uses such a date before 2000.
    21.    -- 8-)
    22.    -- todays_date_28n_years_ago returns a word of 8 KDF9 characters in the format DD/MM/YY.
    23.
    24.    function todays_date_28n_years_ago
    25.    return KDF9.word;
    26.
    27.    -- The time in microseconds since midnight.
    28.    function the_time_of_day
    29.    return KDF9.us;
    30.
    31. end KDF9.TOD_clock;

 79 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd.adb
Source file time stamp: 2021-01-28 23:45:36
Compiled at: 2021-02-08 17:21:01

     1. -- Implement the API (OUTs) of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.fast.DR.TSD_OUTs;
    18. with IOC.fast.FD.TSD_OUTs;
    19. with IOC.fast.MT.TSD_OUTs;
    20. with KDF9.TSD.peripherals;
    21. with KDF9.TSD.processes;
    22. with KDF9.TSD.spooling;
    23. with KDF9.TSD.timing;
    24. with settings;
    25. with tracing;
    26.
    27. use  IOC.fast.DR.TSD_OUTs;
    28. use  IOC.fast.FD.TSD_OUTs;
    29. use  IOC.fast.MT.TSD_OUTs;
    30. use  KDF9.TSD.peripherals;
    31. use  KDF9.TSD.processes;
    32. use  KDF9.TSD.spooling;
    33. use  KDF9.TSD.timing;
    34. use  settings;
    35. use  tracing;
    36.
    37. package body KDF9.TSD is
    38.
    39.    procedure restore_the_IO_OUT_operands (OUT_number, parameter : KDF9.word) is
    40.    begin
    41.       push(parameter);
    42.       push(OUT_number);
    43.    end restore_the_IO_OUT_operands;
    44.
    45.    procedure remove_the_IO_OUT_operands renames pop_pair;
    46.
    47.    -- Emulate a subset of the Time Sharing Director's OUT API.
    48.    procedure do_a_TSD_OUT (OUT_number : in KDF9.word) is
    49.    begin
    50.       -- Dismiss the OUT number in N1, allowing for an empty NEST, treated as OUT 0.
    51.       if the_nest_depth > 0 then
    52.          pop;
    53.       end if;
    54.
    55.       case OUT_number is
    56.
    57.          when 0 =>
    58.             do_OUT_0;
    59.
    60.          when 1 =>
    61.             do_OUT_1;
    62.
    63.          when 2 =>
    64.             do_OUT_2;
    65.
    66.          when 3 =>
    67.             do_OUT_3;
    68.
    69.          when 4 =>
    70.             do_OUT_4;
    71.
    72.          when 5 =>
    73.             do_OUT_5;
    74.
    75.          when 6 =>
    76.             do_OUT_6;
    77.
    78.          when 7 =>
    79.             do_OUT_7;
    80.
    81.          when 8 =>
    82.             do_OUT_8;
    83.
    84.          when 9 =>
    85.             do_OUT_9;
    86.
    87.          when 10 =>
    88.             do_OUT_10;
    89.
    90.          when 11 =>
    91.             do_OUT_11;
    92.
    93.          when 12 =>
    94.             do_OUT_12;
    95.
    96.          when 13 =>
    97.             do_OUT_13;
    98.
    99.          when 14 =>
   100.             do_OUT_14;
   101.
   102.          when 16 =>
   103.             do_OUT_16;
   104.
   105.          when 17 =>
   106.             do_OUT_17;
   107.
   108.          when 41 =>
   109.             do_OUT_41;
   110.
   111.          when 42 =>
   112.             do_OUT_42;
   113.
   114.          when 43 =>
   115.             do_OUT_43;
   116.
   117.          when 44 =>
   118.             do_OUT_44;
   119.
   120.          when 45 =>
   121.             do_OUT_45;
   122.
   123.          when 47 =>
   124.             do_OUT_47;
   125.
   126.          when 70 =>
   127.             -- This is not a genuine TSD OUT, it is an expedient for debugging KAlgol,
   128.             --   so ee9 simply erases its parameters from N1 and N2.
   129.             ensure_that_the_nest_holds_2_operands;
   130.             pop_pair;
   131.
   132.          when 97 =>
   133.             -- This is not a genuine TSD OUT, it gets an integer value from the command line.
   134.             -- The operand is the name of an environment variable.
   135.             -- The result is the numerical value of that variable.
   136.             ensure_that_the_nest_holds_an_operand;
   137.             do_OUT_97;
   138.
   139.          when 98 =>
   140.             -- This is not a genuine TSD OUT, it is an ee9 'OUT' for setting FW output format.
   141.             ensure_that_the_nest_holds_an_operand;
   142.             the_trace_operand := pop;
   143.             realistic_FW_output_is_wanted := the_trace_operand /= 0;
   144.
   145.          when 99 =>
   146.             -- This is not a genuine TSD OUT, it is an ee9 'OUT' for program instrumentation.
   147.             -- Get present value of the Instruction Count Register (ICR) from within ee9.
   148.             push(KDF9.word(ICR));
   149.             the_trace_operand := KDF9.word(ICR);
   150.
   151.          when others =>
   152.             push(OUT_number);
   153.             trap_failing_OUT(OUT_number, "is not yet implemented");
   154.
   155.       end case;
   156.    end do_a_TSD_OUT;
   157.
   158. end KDF9.TSD;

Compiling: ../Source/kdf9-tsd.ads
Source file time stamp: 2021-01-28 23:43:00
Compiled at: 2021-02-08 17:21:01

     1. -- Implement the API (OUTs) of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD is
    18.
    19.    procedure do_a_TSD_OUT (OUT_number : in KDF9.word);
    20.
    21.    -- Put the parameters of an I/O OUT back into the NEST in case the I/O order causes a lockout.
    22.    procedure restore_the_IO_OUT_operands (OUT_number, parameter : KDF9.word);
    23.
    24.    -- Remove the OUT parameters from the NEST after the I/O order completes without interrupting.
    25.    procedure remove_the_IO_OUT_operands;
    26.
    27. end KDF9.TSD;

 158 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd-timing.adb
Source file time stamp: 2021-01-19 10:59:08
Compiled at: 2021-02-08 17:21:01

     1. -- Implement the timing OUTs of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with exceptions;
    18. with tracing;
    19.
    20. use exceptions;
    21. use tracing;
    22.
    23. package body KDF9.TSD.timing is
    24.
    25.    -- This is the actual wall clock time at which the program was loaded.
    26.    -- If signature hashing is enabled, it stays at zero to get a repeatable hash.
    27.    the_time_of_loading : KDF9.us := 0;
    28.
    29.    -- Set the base for virtual elapsed time reckoning.
    30.    procedure set_the_time_of_loading (the_time : in KDF9.us) is
    31.    begin
    32.       the_time_of_loading := the_time;
    33.    end set_the_time_of_loading;
    34.
    35.    -- Return a time in µs as 48-bit seconds to 23 integral places.
    36.    function OUT_time (microseconds : KDF9.us)
    37.    return KDF9.word is
    38.       -- The time was recorded by the hardware in units of 32 us, not 1 us.
    39.       truncated_time : constant KDF9.us := microseconds and not 31;
    40.    begin
    41.       if truncated_time < 2**23 * 1E6 then
    42.          -- 2**18 / 15625 = 2**24 / 1E6, with no risk of overflow in 64 bits.
    43.          return KDF9.word(truncated_time * 2**18 / 15625);
    44.       else
    45.          -- The virtual elapsed time overflows the 23-bit seconds field.
    46.          -- This would never have happened to a real KDF9, as 2**23 seconds is over three months.
    47.          -- No KDF9 could stay up that long!
    48.          -- However 2**23 KDF9 seconds pass in about 5 hours of ee9 real time,
    49.          --    so precautions have to be taken.
    50.          raise program_exit with "the KDF9 has been running too long, time > 2**23 seconds";
    51.       end if;
    52.    end OUT_time;
    53.
    54.    procedure do_OUT_3 is
    55.    begin
    56.       push(OUT_time(the_CPU_time));
    57.       the_trace_operand := read_top;
    58.    end do_OUT_3;
    59.
    60.    procedure do_OUT_9 is
    61.    begin
    62.       -- A TOD clock is simulated using the real TOD at which the program was
    63.       --    loaded, and the virtual time that has elapsed since.
    64.       push(OUT_time(the_time_of_loading + the_clock_time));
    65.       the_trace_operand := read_top;
    66.    end do_OUT_9;
    67.
    68.    procedure do_OUT_17 is
    69.    begin
    70.       ensure_that_the_nest_has_room_for_2_results;
    71.       -- In program mode, the Elapsed Time is the same thing as the_clock_time.
    72.       push(OUT_time(the_clock_time));
    73.       push(OUT_time(the_CPU_time));
    74.       the_trace_operand := read_top;
    75.    end do_OUT_17;
    76.
    77. end KDF9.TSD.timing;

Compiling: ../Source/kdf9-tsd-timing.ads
Source file time stamp: 2021-01-10 23:52:39
Compiled at: 2021-02-08 17:21:01

     1. -- Implement the timing OUTs of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.timing is
    18.
    19.    procedure do_OUT_3;
    20.
    21.    procedure do_OUT_9;
    22.
    23.    procedure do_OUT_17;
    24.
    25.    -- Set the base for virtual elapsed time reckoning.
    26.    procedure set_the_time_of_loading (the_time : in KDF9.us);
    27.
    28. end KDF9.TSD.timing;

 77 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/finalize_ee9.adb
Source file time stamp: 2021-01-10 23:52:35
Compiled at: 2021-02-08 17:21:01

     1. -- Shut down processing in preparation for a dignified exit.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. --
    19. with HCI;
    20. with IOC;
    21. with state_display;
    22.
    23. use  HCI;
    24. use  IOC;
    25. use  state_display;
    26.
    27. procedure finalize_ee9 (because : in String) is
    28. begin
    29.    show_final_state(because);
    30.    finalize_all_KDF9_buffers;
    31. exception
    32.    when error : others =>
    33.       log_line("Failure: " & Ada.Exceptions.Exception_Information(error));
    34. end finalize_ee9;

 34 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/postscript.adb
Source file time stamp: 2021-01-10 23:52:40
Compiled at: 2021-02-08 17:21:01

     1. -- Elementary Encapsulated PostScript (EPS) line drawing.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. --
    19. with exceptions;
    20.
    21. use  Ada.Exceptions;
    22. --
    23. use  exceptions;
    24.
    25. package body postscript is
    26.
    27.    use host_IO;
    28.
    29.    -- A path is a series of vectors v1, v2, ..., vn such that the last point
    30.    --    of vi is the same as the first point of v(i+1),
    31.    --       and v1, ..., vn are all drawn in the same colour.
    32.    -- A new path is started by a jump to a non-contiguous point or by a change of pen colour.
    33.
    34.    there_is_an_open_path      : Boolean := False;
    35.    the_last_point_in_the_path : postscript.point := (0, 0);
    36.
    37.    -- The bounding box limits are set from the value of maximum_offset at the end of the plot.
    38.    maximum_offset             : postscript.point := (0, 0);
    39.
    40.    procedure ensure_separation (stream : in out host_IO.stream) is
    41.    begin
    42.       if column(stream) > 0 then
    43.          put_byte(' ', stream);
    44.       end if;
    45.    end ensure_separation;
    46.
    47.    procedure put (stream : in out host_IO.stream; PS_text : String) is
    48.    begin
    49.       put_bytes(PS_text, stream);
    50.    end put;
    51.
    52.    procedure put_unit (stream : in out host_IO.stream; PS_text : String) is
    53.    begin
    54.       ensure_separation(stream);
    55.       put(stream, PS_text);
    56.    end put_unit;
    57.
    58.    procedure put_line (stream : in out host_IO.stream; PS_text : String) is
    59.    begin
    60.       put(stream, PS_text);
    61.       put_EOL(stream);
    62.    end put_line;
    63.
    64.    procedure put_unit_line (stream : in out host_IO.stream; PS_text : String) is
    65.    begin
    66.       put_unit(stream, PS_text);
    67.       put_EOL(stream);
    68.    end put_unit_line;
    69.
    70.    procedure put_integer (stream : in out host_IO.stream; i : Integer) is
    71.       integer_image  : constant String := i'Image;
    72.    begin
    73.       ensure_separation(stream);
    74.       if integer_image(integer_image'First) /= ' ' then
    75.          put(stream, integer_image);
    76.       else  -- Suppress the nuisance blank character.
    77.          put(stream, integer_image(integer_image'First+1..integer_image'Last));
    78.       end if;
    79.    end put_integer;
    80.
    81.    procedure terminate_any_open_path (stream : in out host_IO.stream) is
    82.    begin
    83.       if there_is_an_open_path then
    84.          -- Draw the accumulated strokes.
    85.          put_unit_line(stream, "s");
    86.       end if;
    87.       there_is_an_open_path := False;
    88.    end terminate_any_open_path;
    89.
    90.    procedure draw_a_PS_vector (stream : in out host_IO.stream;
    91.                                initial,
    92.                                final  : in postscript.point) is
    93.
    94.       function largest_of (a, b, c : Natural)
    95.       return Natural
    96.       is (Natural'Max(a, Natural'Max(b, c)));
    97.
    98.    begin -- draw_a_PS_vector
    99.       if initial /= the_last_point_in_the_path then
   100.          -- This vector is not contiguous with the previous one.
   101.          terminate_any_open_path(stream);
   102.       end if;
   103.       if initial = final then
   104.          -- This vector is of length 0.
   105.          return;
   106.       end if;
   107.       maximum_offset.x := largest_of(maximum_offset.x, initial.x, final.x);
   108.       maximum_offset.y := largest_of(maximum_offset.y, initial.y, final.y);
   109.       if there_is_an_open_path then
   110.          -- Draw a line to the final point, extending the current path.
   111.          put_integer(stream, final.x);
   112.          put_integer(stream, final.y);
   113.          put_unit_line(stream, "l");
   114.       else
   115.          -- Move to the initial point, opening a fresh path, and draw a line to the final point.
   116.          put_integer(stream, final.x);
   117.          put_integer(stream, final.y);
   118.          put_integer(stream, initial.x);
   119.          put_integer(stream, initial.y);
   120.          put_unit_line(stream, "n");
   121.          there_is_an_open_path := True;
   122.       end if;
   123.       the_last_point_in_the_path := final;
   124.    exception
   125.       when error : others =>
   126.          close(stream);
   127.          raise emulation_failure with "drawing a PostScript vector: " & Exception_Information(error);
   128.    end draw_a_PS_vector;
   129.
   130.    subtype RGB is String(1..11);
   131.    gamut : constant array (pen_colour) of RGB
   132.          := (
   133.                Black          => ".00 .00 .00",
   134.                Blue           => ".00 .00 1.0",
   135.                Brown          => ".60 .20 .00",
   136.                Cyan           => ".00 1.0 1.0",
   137.                Dark_Blue      => ".10 .10 .80",
   138.                Dark_Cyan      => ".20 .80 1.0",
   139.                Dark_Green     => ".00 .60 .40",
   140.                Dark_Grey      => ".50 .50 .50",
   141.                Dark_Magenta   => ".75 .25 .75",
   142.                Dark_Red       => ".75 .00 .00",
   143.                Green          => ".00 1.0 .00",
   144.                Grey           => ".80 .80 .80",
   145.                Magenta        => "1.0 .00 1.0",
   146.                Red            => "1.0 .00 .00",
   147.                White          => "1.0 1.0 1.0",
   148.                Yellow         => "1.0 1.0 .00"
   149.             );
   150.
   151.    subtype tip_breadth is String(1..4);
   152.    breadth : constant array (pen_tip_size) of tip_breadth
   153.            := (
   154.                Extra_Extra_Fine => "1.00",
   155.                Extra_Fine       => "2.00",
   156.                Fine             => "4.00",
   157.                Medium           => "6.00",
   158.                Medium_Broad     => "8.00",
   159.                Broad            => "10.0",
   160.                Extra_Broad      => "12.0"
   161.               );
   162.
   163.    the_colour   : pen_colour   := the_default_colour;
   164.    the_pen_size : pen_tip_size := the_default_tip_size;
   165.
   166.    procedure put_the_pen_settings (stream : in out host_IO.Stream) is
   167.    begin -- put_the_pen_settings
   168.       terminate_any_open_path(stream);
   169.       put_unit(stream, gamut(the_colour));
   170.       put_unit_line(stream, "setrgbcolor");
   171.       put_unit(stream, breadth(the_pen_size));
   172.       put_unit_line(stream, "setlinewidth");
   173.    end put_the_pen_settings;
   174.
   175.    procedure set_the_pen_properties (this_colour   : in pen_colour   := the_default_colour;
   176.                                      this_pen_size : in pen_tip_size := the_default_tip_size) is
   177.    begin -- set_the_pen_properties
   178.       the_colour := this_colour;
   179.       the_pen_size := this_pen_size;
   180.    end set_the_pen_properties;
   181.
   182.    -- We eventually seek back to the bounding box parametsrs using this, their file offset.
   183.    the_position_of_the_placeholders : Natural;
   184.
   185.    procedure initialize_PS_output (stream : in out host_IO.Stream) is
   186.
   187.    begin -- initialize_PS_output
   188.       put_line(stream, "%!PS-Adobe-3.0 EPSF-1.0");
   189.       put_unit(stream, "%%BoundingBox: ");
   190.
   191.       -- Note the file offset of the bounding box placeholders.
   192.       get_position(the_position_of_the_placeholders, stream);
   193.
   194.       -- Write the 10-column placeholders.
   195.       put_line(stream, "xxxxxxxxxx|yyyyyyyyyy");
   196.
   197.       put_line(stream, "% This graph was plotted by ee9, the GNU Ada KDF9 emulator.");
   198.       put_line(stream, "% For more information, see <http://www.findlayw.plus.com/KDF9>.");
   199.       put_line(stream, "save");
   200.
   201.       put_line(stream, "1 setlinecap");
   202.       put_line(stream, "1 setlinejoin");
   203.
   204.       put_the_pen_settings(stream);
   205.
   206.       put_line(stream, "0 792 translate");  -- Assumes a page of length 11"!
   207.
   208.       -- The plotter step was 0.005", which is the same as 0.36 PostScript points.
   209.       -- The scaling factor is set here to make the wabbit example fit an A4 page.
   210.       put_line(stream, "0.12 -0.12 scale");
   211.
   212.       put_line(stream, "/l { lineto } bind def");
   213.       put_line(stream, "/n { newpath moveto lineto } bind def");
   214.       put_line(stream, "/s { stroke } bind def");
   215.
   216.       put_line(stream, "save");
   217.    exception
   218.       when error : others =>
   219.          close(stream);
   220.          raise emulation_failure with "initializing PostScript: " & Exception_Information(error);
   221.    end initialize_PS_output;
   222.
   223.    procedure finalize_PS_output (stream : in out host_IO.Stream) is
   224.
   225.       subtype bound_string is String(1..10);
   226.
   227.       function bound_image (n : in Natural)
   228.       return bound_string is
   229.          n_image : constant String := n'Image;
   230.          b : bound_string := (others => ' ');
   231.       begin
   232.          if n_image'Length > bound_string'Length then
   233.             raise emulation_failure with "infeasible PostScript bounding box size: " & n_image;
   234.          else
   235.             b(b'Last-n_image'Length+b'First .. b'Last) := n_image;
   236.             return b;
   237.          end if;
   238.       end bound_image;
   239.
   240.    begin -- finalize_PS_output
   241.       terminate_any_open_path(stream);
   242.       put_line(stream, "showpage");
   243.       put_line(stream, "restore");
   244.       put_line(stream, "restore");
   245.       put_line(stream, "% End of plot");
   246.
   247.       -- Go back to the bounding box placeholders in the output file.
   248.       set_position(the_position_of_the_placeholders, stream);
   249.
   250.       -- Overwrite them with the actual x and y co-ordinate bounds.
   251.       put(stream, bound_image(maximum_offset.x));
   252.       put(stream, " ");
   253.       put(stream, bound_image(maximum_offset.y));
   254.
   255.       close(stream);
   256.    exception
   257.       when error : others =>
   258.          close(stream);
   259.          raise emulation_failure with "closing PostScript output: " & Exception_Information(error);
   260.    end finalize_PS_output;
   261.
   262. end postscript;
   263.

Compiling: ../Source/postscript.ads
Source file time stamp: 2021-01-10 23:52:40
Compiled at: 2021-02-08 17:21:01

     1. -- Elementary Encapsulated PostScript (EPS) line drawing.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with host_IO;
    18.
    19. package postscript is
    20.
    21.    type pen_colour is (
    22.                        Black,
    23.                        Blue,
    24.                        Brown,
    25.                        Cyan,
    26.                        Dark_Blue,
    27.                        Dark_Cyan,
    28.                        Dark_Green,
    29.                        Dark_Grey,
    30.                        Dark_Magenta,
    31.                        Dark_Red,
    32.                        Green,
    33.                        Grey,
    34.                        Magenta,
    35.                        Red,
    36.                        White,
    37.                        Yellow
    38.                       );
    39.
    40.    the_default_colour : constant pen_colour := Black;
    41.
    42.    type pen_tip_size is (
    43.                          Extra_Extra_Fine,
    44.                          Extra_Fine,
    45.                          Fine,
    46.                          Medium,
    47.                          Medium_Broad,
    48.                          Broad,
    49.                          Extra_Broad
    50.                         );
    51.
    52.    the_default_tip_size : constant pen_tip_size := Extra_Extra_Fine;
    53.
    54.    -- Choose the pen's colour and tip size.
    55.
    56.    procedure set_the_pen_properties (this_colour   : in pen_colour   := the_default_colour;
    57.                                      this_pen_size : in pen_tip_size := the_default_tip_size);
    58.
    59.    -- Drawing is done in terms of the plotter's co-ordinate system.
    60.    -- (0, 0) is the top left point of the drawing,
    61.    -- The x axis increases down the plot (long axis, direction of paper movement),
    62.    --    and the y axis increases across the plot (short axis, direction of pen movement).
    63.
    64.    type point is
    65.      record
    66.         x, y : Natural;  -- All physically possible co-ordinates are non-negative.
    67.      end record;
    68.
    69.    -- Draw a straight line from initial to final.
    70.    procedure draw_a_PS_vector (stream : in out host_IO.stream;
    71.                                initial,
    72.                                final  : in postscript.point);
    73.
    74.    -- Open the PostScript file and write the prelude, with a placeholder for the bounds.
    75.    procedure initialize_PS_output (stream : in out host_IO.Stream);
    76.
    77.    -- Close the PostScript file, having gone back to overwrite the bounding box placeholders.
    78.    procedure finalize_PS_output (stream : in out host_IO.Stream);
    79.
    80. end postscript;

 263 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/settings-io.adb
Source file time stamp: 2021-01-10 23:52:40
Compiled at: 2021-02-08 17:21:01

     1. -- Settings-reader I/O support.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Latin_1;
    18. --
    19. with file_interfacing;
    20. with KDF9;
    21.
    22. use  Ada.Characters.Latin_1;
    23.
    24. package body settings.IO is
    25.
    26.    procedure open_options_file (file : in out File_Type; name : in String) is
    27.    begin
    28.       file_interfacing.initialize(file, in_file, name);
    29.       line_number := 1;
    30.    exception
    31.       when others =>
    32.          raise Status_Error with name;
    33.    end open_options_file;
    34.
    35.    procedure close_options_file (file : in out File_Type; name : in String) is
    36.    begin
    37.       file_interfacing.finalize(file, name);
    38.    end close_options_file;
    39.
    40.    comment_flag_character : constant Character := '|';
    41.
    42.    procedure skip_to_next_non_blank (file : File_Type) is
    43.       next_char : Character := ' ';
    44.       end_line  : Boolean;
    45.    begin
    46.       loop
    47.         look_ahead(file, next_char, end_line);
    48.       exit when end_line or else
    49.                   (next_char /= ' ' and next_char /= HT);
    50.          get(file, next_char);
    51.       end loop;
    52.       if next_char = comment_flag_character then
    53.          while not end_of_line(file) loop
    54.             get(file, next_char);
    55.          end loop;
    56.       end if;
    57.    end skip_to_next_non_blank;
    58.
    59.    procedure ensure_not_at_end_of_line (file : File_Type) is
    60.    begin
    61.       skip_to_next_non_blank (file);
    62.       if end_of_line(file) then
    63.          raise Data_Error;
    64.       end if;
    65.    end ensure_not_at_end_of_line;
    66.
    67.    procedure skip_to_next_nonempty_line (file : in File_Type) is
    68.       flag     : Character;
    69.       end_line : Boolean;
    70.    begin
    71.       loop
    72.          look_ahead(file, flag, end_line);
    73.          if end_line                      or else
    74.                flag = comment_flag_character then
    75.             Skip_Line(file);
    76.             line_number := line_number + 1;
    77.          else
    78.             exit;
    79.          end if;
    80.       end loop;
    81.       if flag = comment_flag_character then
    82.          raise Data_Error;
    83.       end if;
    84.    end skip_to_next_nonempty_line;
    85.
    86.    digit_offset : constant := Character'Pos('0');
    87.
    88.    procedure get_octal (file : in File_Type; value : out KDF9.word) is
    89.       next_char : Character;
    90.       last_char : Character := '_';
    91.       place     : Natural   := 0;
    92.       end_line  : Boolean   := False;
    93.    begin
    94.       value := 0;
    95.       ensure_not_at_end_of_line(file);
    96.       get(file, next_char);
    97.       if next_char = '#' then
    98.          get(file, next_char);
    99.       else
   100.          raise Data_Error;
   101.       end if;
   102.       loop
   103.          if next_char in '0' .. '7' then
   104.             value := value*8 + KDF9.word(Character'Pos(next_char)-digit_offset);
   105.             place := place + 1;
   106.             if place > 16 then
   107.                raise Data_Error;
   108.             end if;
   109.          elsif next_char = '_' then
   110.             if place = 0 then
   111.                raise Data_Error;
   112.             end if;
   113.          else
   114.             if last_char = '_' or place = 0 then
   115.                raise Data_Error;
   116.             end if;
   117.             exit;
   118.          end if;
   119.          last_char := next_char;
   120.          look_ahead(file, next_char, end_line);
   121.       exit when end_line;
   122.          if next_char in '0' .. '7' or next_char = '_' then
   123.             get(file, next_char);
   124.          else
   125.             if last_char = '_' or place = 0 then
   126.                raise Data_Error;
   127.             end if;
   128.             exit;
   129.          end if;
   130.       end loop;
   131.    end get_octal;
   132.
   133.    procedure get_decimal (file : in File_Type; value : out KDF9.word) is
   134.       next_char : Character;
   135.       last_char : Character := '_';
   136.       place     : Natural   := 0;
   137.       end_line  : Boolean   := False;
   138.    begin
   139.       value := 0;
   140.       ensure_not_at_end_of_line(file);
   141.       get(file, next_char);
   142.       if next_char not in '0' .. '9' then
   143.          raise Program_Error with "get_decimal " & next_char;
   144.       end if;
   145.       loop
   146.          if next_char in '0' .. '9' then
   147.             value := value*10 + KDF9.word(Character'Pos(next_char)-digit_offset);
   148.             place := place + 1;
   149.             if place > 15 then
   150.                raise Data_Error;
   151.             end if;
   152.          elsif next_char = '_' then
   153.             if place = 0 then
   154.                raise Data_Error;
   155.             end if;
   156.          else
   157.             if last_char = '_' or place = 0 then
   158.                raise Data_Error;
   159.             end if;
   160.       exit;
   161.          end if;
   162.          last_char := next_char;
   163.          look_ahead(file, next_char, end_line);
   164.       exit when end_line;
   165.          if next_char in '0' .. '9' or next_char = '_' then
   166.             get(file, next_char);
   167.          else
   168.             if last_char = '_' or place = 0 then
   169.                raise Data_Error;
   170.             end if;
   171.       exit;
   172.          end if;
   173.       end loop;
   174.    end get_decimal;
   175.
   176.    procedure get_word (file : in File_Type; value : out KDF9.word) is
   177.       next_char : Character;
   178.       end_line  : Boolean;
   179.    begin
   180.       ensure_not_at_end_of_line(file);
   181.       look_ahead(file, next_char, end_line);
   182.       pragma Unreferenced(end_line);
   183.       if next_char = '#' then
   184.          get_octal(file, value);
   185.       else
   186.          get_decimal(file, value);
   187.       end if;
   188.    end get_word;
   189.
   190.    procedure get_char (file : in File_Type; value : out Character) is
   191.       end_line : Boolean;
   192.       char     : Character;
   193.    begin
   194.       ensure_not_at_end_of_line(file);
   195.       look_ahead(file, char, end_line);
   196.       if end_line then
   197.          raise Data_Error;
   198.       end if;
   199.       if char /= ' ' then
   200.          get(file, value);
   201.       end if;
   202.    end get_char;
   203.
   204. end settings.IO;
   205.

Compiling: ../Source/settings-io.ads
Source file time stamp: 2021-01-10 23:52:40
Compiled at: 2021-02-08 17:21:01

     1. -- Settings-reader I/O support.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18. --
    19. with postscript;
    20.
    21. use  Ada.Text_IO;
    22.
    23. package settings.IO is
    24.
    25.    line_number : Natural := 0;
    26.
    27.    procedure open_options_file (file : in out File_Type; name : in String);
    28.
    29.    procedure close_options_file (file : in out File_Type; name : in String);
    30.
    31.    -- Check that the end of the line has not yet been reached, else raise Data_Error.
    32.    procedure ensure_not_at_end_of_line (file : in File_Type);
    33.
    34.    -- Move the reading position to the next non-blank or EOL, skipping comment.
    35.    procedure skip_to_next_non_blank (file : in File_Type);
    36.
    37.    -- Discard input until a non-empty line is reached,
    38.    --    leaving the reading position at the start of that line,
    39.    --    and incrementing line_number for each line terminator passed.
    40.    procedure skip_to_next_nonempty_line (file : in File_Type);
    41.
    42.    -- Read octal digits string as KDF9.word,
    43.    --    raising Data_Error on overflow or bad syntax.
    44.    procedure get_octal (file : in File_Type; value : out KDF9.word);
    45.
    46.    -- Read decimal digits string as KDF9.word,
    47.    --    raising Data_Error on overflow or bad syntax.
    48.    procedure get_decimal (file  : in File_Type; value : out KDF9.word);
    49.
    50.    -- Read an address as a KDF9.word in either octal or decimal,
    51.    --    using get_octal or get_decimal as indicated by the syntax.
    52.    procedure get_word (file : in File_Type; value : out KDF9.word);
    53.
    54.    -- Read the character value immediately following an octal or decimal number,
    55.    --    if it is not a space character; if it is a space, leave value unchanged.
    56.    procedure get_char (file : in File_Type; value : out Character);
    57.
    58.    package colour_IO is new Ada.Text_IO.Enumeration_IO(postscript.pen_colour);
    59.    package  width_IO is new Ada.Text_IO.Enumeration_IO(postscript.pen_tip_size);
    60.
    61. end settings.IO;

 205 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/generic_sets.adb
Source file time stamp: 2021-01-22 02:48:38
Compiled at: 2021-02-08 17:21:01

     1. -- Powersets of a discrete member type.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. -- generic
    18. --    type member is (<>);
    19. package body generic_sets is
    20.
    21.    function "/" (set : generic_sets.set; member : generic_sets.member)
    22.    return Boolean
    23.    is (set(member));
    24.
    25.    function "or" (set : generic_sets.set; member : generic_sets.member)
    26.    return generic_sets.set is
    27.    begin
    28.       return result : generic_sets.set := set do
    29.          result(member) := True;
    30.       end return;
    31.    end "or";
    32.
    33.    function "-" (set1, set2 : generic_sets.set)
    34.    return generic_sets.set is
    35.    begin -- Compute (set1 and not set2), avoiding need for a potentially large workspace.
    36.       return result : generic_sets.set := set1 do
    37.          for m in generic_sets.member loop
    38.             if set2(m) then
    39.                result(m) := False;
    40.             end if;
    41.          end loop;
    42.       end return;
    43.    end "-";
    44.
    45. end generic_sets;

Compiling: ../Source/generic_sets.ads
Source file time stamp: 2021-01-22 02:47:42
Compiled at: 2021-02-08 17:21:01

     1. -- Powersets of a discrete member type.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. generic
    18.    type member is (<>);
    19. package generic_sets is
    20.
    21.    pragma Preelaborate;
    22.
    23. --
    24. -- This package implements only those set operations that are needed by ee9.
    25. --
    26.
    27.    type set is array (generic_sets.member) of Boolean
    28.       with Component_Size => 1, Convention => C;
    29.
    30.    empty_set : constant generic_sets.set := (others => False);
    31.
    32.    -- Test for membership of the set.
    33.    function "/" (set : generic_sets.set; member : generic_sets.member)
    34.    return Boolean with Inline;
    35.
    36.    -- Union of a set and a singleton.
    37.    function "or"  (set : generic_sets.set; member : generic_sets.member)
    38.    return generic_sets.set;
    39.
    40.    -- Computes (set1 and not set2).
    41.    function "-" (set1, set2 : generic_sets.set)
    42.    return generic_sets.set;
    43.
    44. end generic_sets;

 45 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-decoding.ads
Source file time stamp: 2021-01-10 23:52:38
Compiled at: 2021-02-08 17:21:01

     1. -- The "compressed_opcode" values are effective opcodes, partially decoded from the first syllable,
     2. --   and combined with opcode bits of the second syllable, where appropriate (e.g. in jumps).
     3. --
     4. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package KDF9.decoding is
    19.
    20.    -- The compressed_opcode values for 1-syllable orders are equal to their full codes.
    21.
    22.    ALL_0    : constant KDF9.compressed_opcode := 2#000_000#;
    23.    VR       : constant KDF9.compressed_opcode := 2#000_001#;
    24.    TO_TR    : constant KDF9.compressed_opcode := 2#000_010#;
    25.    BITS     : constant KDF9.compressed_opcode := 2#000_011#;
    26.    XF       : constant KDF9.compressed_opcode := 2#000_100#;
    27.    XDF      : constant KDF9.compressed_opcode := 2#000_101#;
    28.    INV006   : constant KDF9.compressed_opcode := 2#000_110#;
    29.    XPLUSF   : constant KDF9.compressed_opcode := 2#000_111#;
    30.    NEGD     : constant KDF9.compressed_opcode := 2#001_000#;
    31.    OR_9     : constant KDF9.compressed_opcode := 2#001_001#;
    32.    PERM     : constant KDF9.compressed_opcode := 2#001_010#;
    33.    TOB      : constant KDF9.compressed_opcode := 2#001_011#;
    34.    ROUNDH   : constant KDF9.compressed_opcode := 2#001_100#;
    35.    NEV      : constant KDF9.compressed_opcode := 2#001_101#;
    36.    ROUND    : constant KDF9.compressed_opcode := 2#001_110#;
    37.    DUMMY    : constant KDF9.compressed_opcode := 2#001_111#;
    38.    ROUNDF   : constant KDF9.compressed_opcode := 2#010_000#;
    39.    ROUNDHF  : constant KDF9.compressed_opcode := 2#010_001#;
    40.    MINUSDF  : constant KDF9.compressed_opcode := 2#010_010#;
    41.    PLUSDF   : constant KDF9.compressed_opcode := 2#010_011#;
    42.    FLOAT_9  : constant KDF9.compressed_opcode := 2#010_100#;
    43.    FLOATD   : constant KDF9.compressed_opcode := 2#010_101#;
    44.    ABS_9    : constant KDF9.compressed_opcode := 2#010_110#;
    45.    NEG      : constant KDF9.compressed_opcode := 2#010_111#;
    46.    ABSF     : constant KDF9.compressed_opcode := 2#011_000#;
    47.    NEGF     : constant KDF9.compressed_opcode := 2#011_001#;
    48.    MAX      : constant KDF9.compressed_opcode := 2#011_010#;
    49.    NOT_9    : constant KDF9.compressed_opcode := 2#011_011#;
    50.    XD       : constant KDF9.compressed_opcode := 2#011_100#;
    51.    X_frac   : constant KDF9.compressed_opcode := 2#011_101#;
    52.    MINUS    : constant KDF9.compressed_opcode := 2#011_110#;
    53.    SIGN     : constant KDF9.compressed_opcode := 2#011_111#;
    54.    INV040   : constant KDF9.compressed_opcode := 2#100_000#;
    55.    ZERO     : constant KDF9.compressed_opcode := 2#100_001#;
    56.    DUP      : constant KDF9.compressed_opcode := 2#100_010#;
    57.    DUPD     : constant KDF9.compressed_opcode := 2#100_011#;
    58.    DIVI     : constant KDF9.compressed_opcode := 2#100_100#;
    59.    FIX      : constant KDF9.compressed_opcode := 2#100_101#;
    60.    INV046   : constant KDF9.compressed_opcode := 2#100_110#;
    61.    STR      : constant KDF9.compressed_opcode := 2#100_111#;
    62.    CONT     : constant KDF9.compressed_opcode := 2#101_000#;
    63.    REVD     : constant KDF9.compressed_opcode := 2#101_001#;
    64.    ERASE    : constant KDF9.compressed_opcode := 2#101_010#;
    65.    MINUSD   : constant KDF9.compressed_opcode := 2#101_011#;
    66.    AND_9    : constant KDF9.compressed_opcode := 2#101_100#;
    67.    INV055   : constant KDF9.compressed_opcode := 2#101_101#;
    68.    PLUS     : constant KDF9.compressed_opcode := 2#101_110#;
    69.    PLUSD    : constant KDF9.compressed_opcode := 2#101_111#;
    70.    DIV      : constant KDF9.compressed_opcode := 2#110_000#;
    71.    DIVD     : constant KDF9.compressed_opcode := 2#110_001#;
    72.    DIVF     : constant KDF9.compressed_opcode := 2#110_010#;
    73.    DIVDF    : constant KDF9.compressed_opcode := 2#110_011#;
    74.    DIVR     : constant KDF9.compressed_opcode := 2#110_100#;
    75.    REV      : constant KDF9.compressed_opcode := 2#110_101#;
    76.    CAB      : constant KDF9.compressed_opcode := 2#110_110#;
    77.    FRB      : constant KDF9.compressed_opcode := 2#110_111#;
    78.    STAND    : constant KDF9.compressed_opcode := 2#111_000#;
    79.    NEGDF    : constant KDF9.compressed_opcode := 2#111_001#;
    80.    MAXF     : constant KDF9.compressed_opcode := 2#111_010#;
    81.    INV073   : constant KDF9.compressed_opcode := 2#111_011#;
    82.    PLUSF    : constant KDF9.compressed_opcode := 2#111_100#;
    83.    MINUSF   : constant KDF9.compressed_opcode := 2#111_101#;
    84.    INV076   : constant KDF9.compressed_opcode := 2#111_110#;
    85.    SIGNF    : constant KDF9.compressed_opcode := 2#111_111#;
    86.
    87.
    88.    -- compressed_opcode values for 2-syllable indirect fetch and store orders
    89.
    90.    MkMq       : constant KDF9.compressed_opcode := 2#000_000#;
    91.    MkMqQ      : constant KDF9.compressed_opcode := 2#000_010#;
    92.    MkMqH      : constant KDF9.compressed_opcode := 2#000_100#;
    93.    MkMqQH     : constant KDF9.compressed_opcode := 2#000_110#;
    94.    MkMqN      : constant KDF9.compressed_opcode := 2#001_000#;
    95.    MkMqQN     : constant KDF9.compressed_opcode := 2#001_010#;
    96.    MkMqHN     : constant KDF9.compressed_opcode := 2#001_100#;
    97.    MkMqQHN    : constant KDF9.compressed_opcode := 2#001_110#;
    98.
    99.    TO_MkMq    : constant KDF9.compressed_opcode := 2#000_001#;
   100.    TO_MkMqQ   : constant KDF9.compressed_opcode := 2#000_011#;
   101.    TO_MkMqH   : constant KDF9.compressed_opcode := 2#000_101#;
   102.    TO_MkMqQH  : constant KDF9.compressed_opcode := 2#000_111#;
   103.    TO_MkMqN   : constant KDF9.compressed_opcode := 2#001_001#;
   104.    TO_MkMqQN  : constant KDF9.compressed_opcode := 2#001_011#;
   105.    TO_MkMqHN  : constant KDF9.compressed_opcode := 2#001_101#;
   106.    TO_MkMqQHN : constant KDF9.compressed_opcode := 2#001_111#;
   107.
   108.
   109.    -- compressed_opcode values for 2-syllable Q store orders
   110.
   111.    M_PLUS_Iq    : constant KDF9.compressed_opcode := 2#100_000#;
   112.    M_MINUS_Iq   : constant KDF9.compressed_opcode := 2#100_001#;
   113.    NCq          : constant KDF9.compressed_opcode := 2#100_010#;
   114.    DCq          : constant KDF9.compressed_opcode := 2#100_011#;
   115.    POS1_TO_Iq   : constant KDF9.compressed_opcode := 2#100_100#;
   116.    NEG1_TO_Iq   : constant KDF9.compressed_opcode := 2#100_101#;
   117.    POS2_TO_Iq   : constant KDF9.compressed_opcode := 2#100_110#;
   118.    NEG2_TO_Iq   : constant KDF9.compressed_opcode := 2#100_111#;
   119.
   120.    MqTOQk       : constant KDF9.compressed_opcode := 2#101_001#;
   121.    IqTOQk       : constant KDF9.compressed_opcode := 2#101_010#;
   122.    IMqTOQk      : constant KDF9.compressed_opcode := 2#101_011#;
   123.    CqTOQk       : constant KDF9.compressed_opcode := 2#101_100#;
   124.    CMqTOQk      : constant KDF9.compressed_opcode := 2#101_101#;
   125.    CIqTOQk      : constant KDF9.compressed_opcode := 2#101_110#;
   126.    QqTOQk       : constant KDF9.compressed_opcode := 2#101_111#;
   127.
   128.    SHA          : constant KDF9.compressed_opcode := 2#110_001#;
   129.    SHAD         : constant KDF9.compressed_opcode := 2#110_010#;
   130.    MACC         : constant KDF9.compressed_opcode := 2#110_011#;
   131.    SHL          : constant KDF9.compressed_opcode := 2#110_100#;
   132.    SHLD         : constant KDF9.compressed_opcode := 2#110_110#;
   133.    SHC          : constant KDF9.compressed_opcode := 2#110_111#;
   134.    constant_bit : constant := 1;
   135.
   136.    TO_RCIMq     : constant KDF9.compressed_opcode := 2#111_000#;
   137.    QCIMq        : constant KDF9.compressed_opcode := 2#111_001#;
   138.    ADD_TO_QCIMq : constant KDF9.compressed_opcode := 2#111_010#;
   139.
   140.    -- masks for Q store Qk bits
   141.
   142.    reset_choice  : constant := 2#0001#;
   143.    C_part_choice : constant := 2#1000#;
   144.    I_part_choice : constant := 2#0100#;
   145.    M_part_choice : constant := 2#0010#;
   146.    all_Q_choice  : constant := C_part_choice + I_part_choice + M_part_choice;
   147.
   148.
   149.    -- compressed_opcode values for 2-syllable SJNS orders
   150.
   151.    LINK    : constant KDF9.compressed_opcode := 2#111_011#;
   152.    TO_LINK : constant KDF9.compressed_opcode := 2#111_100#;
   153.
   154.
   155.    -- compressed_opcode values for 2-syllable Director-only orders
   156.
   157.    TO_Kq : constant KDF9.compressed_opcode := 2#111_101#;
   158.    K0    : constant := 2#1000#;
   159.    K1    : constant := 2#0100#;
   160.    K2    : constant := 2#0010#;
   161.    K3    : constant := 2#0001#;
   162.    Kk    : constant KDF9.compressed_opcode := 2#111_110#;
   163.    K4    : constant := 2#1000#;
   164.    K5    : constant := 2#0100#;
   165.    K7    : constant := 2#0001#;
   166.
   167.
   168.    -- compressed_opcode value for 2-syllable short-loop jump order
   169.
   170.    JCqNZS : constant KDF9.compressed_opcode := 2#111_111#;
   171.
   172.
   173.    -- compressed_opcode values for 2-syllable I/O orders
   174.
   175.    CT_PMB_PMC_BUSY_Qq     : constant KDF9.compressed_opcode := 2#010_000#;
   176.    PAR_Qq                 : constant KDF9.compressed_opcode := 2#010_001#;
   177.    PMF_PMG_Qq             : constant KDF9.compressed_opcode := 2#010_010#;
   178.    PIA_PIC_CLO_TLO_Qq     : constant KDF9.compressed_opcode := 2#010_100#;
   179.    PIB_PID_Qq             : constant KDF9.compressed_opcode := 2#010_101#;
   180.    PIE_PIG_Qq             : constant KDF9.compressed_opcode := 2#010_110#;
   181.    PIF_PIH_Qq             : constant KDF9.compressed_opcode := 2#010_111#;
   182.
   183.    POA_POC_POE_POF_PMH_Qq : constant KDF9.compressed_opcode := 2#011_000#;
   184.    POB_POD_Qq             : constant KDF9.compressed_opcode := 2#011_001#;
   185.    POG_POL_Qq             : constant KDF9.compressed_opcode := 2#011_010#;
   186.    POH_POK_Qq             : constant KDF9.compressed_opcode := 2#011_011#;
   187.    PMA_PMK_INT_Qq         : constant KDF9.compressed_opcode := 2#011_100#;
   188.    PMD_PME_PML_Qq         : constant KDF9.compressed_opcode := 2#011_110#;
   189.
   190.    -- masks for I/O opcode extension bits (Qk field)
   191.
   192.    PAR_bits  : constant := 2#0000#;
   193.
   194.    -- PIA_PIC_CLO_TLO_Qq:
   195.    PIA_bits  : constant := 2#0000#;
   196.    PIC_bits  : constant := 2#1000#;
   197.    CLO_bits  : constant := 2#0010#;
   198.    TLO_bits  : constant := 2#0100#;
   199.
   200.    -- PIB_PID_Qq:
   201.    PIB_bits  : constant := 2#0000#;
   202.    PID_bits  : constant := 2#1000#;
   203.
   204.    -- PIE_PIG_Qq:
   205.    PIE_bits  : constant := 2#0000#;
   206.    PIG_bits  : constant := 2#1000#;
   207.
   208.    -- PIF_PIH_Qq:
   209.    PIF_bits  : constant := 2#0000#;
   210.    PIH_bits  : constant := 2#1000#;
   211.
   212.    -- PMA_PMK_INT_Qq:
   213.    PMA_bits  : constant := 2#0000#;
   214.    PMK_bits  : constant := 2#0100#;
   215.    INT_bits  : constant := 2#0010#;
   216.
   217.    -- CT_PMB_PMC_BUSY_Qq:
   218.    CTQ_bits   : constant := 2#0000#;
   219.    PMB_bits   : constant := 2#1000#;
   220.    PMC_bits   : constant := 2#0100#;
   221.    BUSY_bits  : constant := 2#0010#;
   222.    manual_bit : constant := 2#0001#;
   223.
   224.    -- PMD_PME_PML_Qq:
   225.    PME_bits  : constant := 2#0000#;
   226.    PMD_bits  : constant := 2#1000#;
   227.    PML_bits  : constant := 2#0100#;
   228.
   229.    -- PMF_PMG_Qq:
   230.    PMF_bits  : constant := 2#0000#;
   231.    PMG_bits  : constant := 2#0100#;
   232.
   233.    -- POA_POC_POE_POF_PMH_Qq:
   234.    POA_bits  : constant := 2#0000#;
   235.    POC_bits  : constant := 2#1000#;
   236.    POE_bits  : constant := 2#1100#;
   237.    POF_bits  : constant := 2#0100#;
   238.    PMH_bits  : constant := 2#0010#;
   239.
   240.    -- POB_POD_Qq:
   241.    POB_bits  : constant := 2#0000#;
   242.    POD_bits  : constant := 2#1000#;
   243.
   244.    -- POG_POL_Qq:
   245.    POG_bits  : constant := 2#0000#;
   246.    POL_bits  : constant := 2#1000#;
   247.
   248.    -- POH_POK_Qq:
   249.    POH_bits  : constant := 2#0000#;
   250.    POK_bits  : constant := 2#1000#;
   251.
   252.
   253.    -- compressed_opcode values for normal jump orders
   254.
   255.    JrNE   : constant KDF9.compressed_opcode := 2#000_001#;
   256.    JrGEZ  : constant KDF9.compressed_opcode := 2#000_010#;
   257.    JrLEZ  : constant KDF9.compressed_opcode := 2#000_100#;
   258.    JrNEZ  : constant KDF9.compressed_opcode := 2#000_110#;
   259.    JrNV   : constant KDF9.compressed_opcode := 2#001_000#;
   260.    OS_OUT : constant KDF9.compressed_opcode := 2#001_001#;
   261.    JrNEN  : constant KDF9.compressed_opcode := 2#001_010#;
   262.    Jr     : constant KDF9.compressed_opcode := 2#001_011#;
   263.    JrNEJ  : constant KDF9.compressed_opcode := 2#001_100#;
   264.    JSr    : constant KDF9.compressed_opcode := 2#001_101#;
   265.    JrNTR  : constant KDF9.compressed_opcode := 2#001_110#;
   266.    EXIT_n : constant KDF9.compressed_opcode := 2#001_111#;  -- 0h0 in bits 5-7
   267.    JrEQ   : constant KDF9.compressed_opcode := 2#010_001#;
   268.    JrLTZ  : constant KDF9.compressed_opcode := 2#010_010#;
   269.    JrGTZ  : constant KDF9.compressed_opcode := 2#010_100#;
   270.    JrEQZ  : constant KDF9.compressed_opcode := 2#010_110#;
   271.    JrV    : constant KDF9.compressed_opcode := 2#011_000#;
   272.    JrEN   : constant KDF9.compressed_opcode := 2#011_010#;
   273.    JrEJ   : constant KDF9.compressed_opcode := 2#011_100#;
   274.    JrTR   : constant KDF9.compressed_opcode := 2#011_110#;
   275.    EXITD  : constant KDF9.compressed_opcode := 2#011_111#;  -- 010 in bits 5-7
   276.    JrCqZ  : constant KDF9.compressed_opcode := 2#100_000#;
   277.    JrCqNZ : constant KDF9.compressed_opcode := 2#110_000#;
   278.
   279.    EXIT_1_bit : constant := 2#010#;  -- 0h0 in bits 5-7 of EXIT syllable_0
   280.
   281.
   282.    -- compressed_opcode values for directly-addressed data access orders
   283.
   284.    EaMq     : constant KDF9.compressed_opcode := 2#000_000#;
   285.    TO_EaMq  : constant KDF9.compressed_opcode := 2#000_001#;
   286.    EaMqQ    : constant KDF9.compressed_opcode := 2#000_010#;
   287.    TO_EaMqQ : constant KDF9.compressed_opcode := 2#000_011#;
   288.    SET      : constant KDF9.compressed_opcode := 2#000_100#;
   289.
   290.
   291. end KDF9.decoding;

 291 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-dispatcher.adb
Source file time stamp: 2021-01-10 23:52:36
Compiled at: 2021-02-08 17:21:01

     1. -- CPU I/O orders are dispatched here to device-specific handlers within the IOC type hierarchy.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9.PHU_store;
    18. with tracing;
    19.
    20. use  tracing;
    21.
    22. package body IOC.dispatcher is
    23.
    24.    --
    25.    --
    26.    -- CLO, SLO and TLO do not operate on a buffer, and so can be fully implemented here.
    27.    --
    28.    --
    29.
    30.    procedure CLO (Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean) is
    32.       pragma Unreferenced(set_offline);
    33.       use  KDF9.PHU_store;
    34.    begin
    35.       -- This is a Director-only instruction.
    36.       take_note_of_test("   ", Q_operand, False);
    37.       unlock_absolute_addresses(Q_operand);
    38.       -- CLO also clears PHU[CPL].
    39.       PHU(CPL) := idle_PHU;
    40.       add_in_the_IO_lockout_CPU_time(Q_operand);
    41.    end CLO;
    42.
    43.    procedure SLO (Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean) is
    45.       pragma Unreferenced(set_offline);
    46.    begin
    47.       -- This is a Director-only instruction.
    48.       take_note_of_test("   ", Q_operand, False);
    49.       lock_out_absolute_addresses(Q_operand);
    50.       add_in_the_IO_lockout_CPU_time(Q_operand);
    51.    end SLO;
    52.
    53.    procedure TLO (Q_operand   : in KDF9.Q_register;
    54.                   result      : out Boolean) is
    55.    begin
    56.       -- This is NOT Director-only.
    57.       result := there_are_locks_in_relative_addresses(Q_operand);
    58.       take_note_of_test("   ", Q_operand, result);
    59.       add_in_the_IO_lockout_CPU_time(Q_operand);
    60.    end TLO;
    61.
    62.    --
    63.    --
    64.    -- All other I/O orders do access a buffer, and so dispatch to the relevant device driver.
    65.    --
    66.    --
    67.
    68.    procedure BUSY (Q_operand   : in KDF9.Q_register;
    69.                    set_offline : in Boolean;
    70.                    result      : out Boolean) is
    71.    begin
    72.       buffer(Q_operand.C and buffer_number_mask).BUSY(Q_operand, set_offline, result);
    73.    end BUSY;
    74.
    75.    procedure PAR (Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean;
    77.                   result      : out Boolean) is
    78.    begin
    79.       buffer(Q_operand.C and buffer_number_mask).PAR(Q_operand, set_offline, result);
    80.    end PAR;
    81.
    82.    procedure MANUAL_CT (Q_operand   : in KDF9.Q_register;
    83.                         set_offline : in Boolean) is
    84.    begin
    85.       buffer(Q_operand.C and buffer_number_mask).MANUAL_CT(Q_operand, set_offline);
    86.    end MANUAL_CT;
    87.
    88.    procedure INT (Q_operand   : in KDF9.Q_register;
    89.                   set_offline : in Boolean) is
    90.    begin
    91.       buffer(Q_operand.C and buffer_number_mask).INT(Q_operand, set_offline);
    92.    end INT;
    93.
    94.    procedure PIA (Q_operand   : in KDF9.Q_register;
    95.                   set_offline : in Boolean) is
    96.    begin
    97.       buffer(Q_operand.C and buffer_number_mask).PIA(Q_operand, set_offline);
    98.       add_in_the_IO_lockout_CPU_time(Q_operand);
    99.    end PIA;
   100.
   101.    procedure PIB (Q_operand   : in KDF9.Q_register;
   102.                   set_offline : in Boolean) is
   103.    begin
   104.       buffer(Q_operand.C and buffer_number_mask).PIB(Q_operand, set_offline);
   105.       add_in_the_IO_lockout_CPU_time(Q_operand);
   106.    end PIB;
   107.
   108.    procedure PIC (Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean) is
   110.    begin
   111.       buffer(Q_operand.C and buffer_number_mask).PIC(Q_operand, set_offline);
   112.       add_in_the_IO_lockout_CPU_time(Q_operand);
   113.    end PIC;
   114.
   115.    procedure PID (Q_operand   : in KDF9.Q_register;
   116.                   set_offline : in Boolean) is
   117.    begin
   118.       buffer(Q_operand.C and buffer_number_mask).PID(Q_operand, set_offline);
   119.       add_in_the_IO_lockout_CPU_time(Q_operand);
   120.    end PID;
   121.
   122.    procedure PIE (Q_operand   : in KDF9.Q_register;
   123.                   set_offline : in Boolean) is
   124.    begin
   125.       buffer(Q_operand.C and buffer_number_mask).PIE(Q_operand, set_offline);
   126.       add_in_the_IO_lockout_CPU_time(Q_operand);
   127.    end PIE;
   128.
   129.    procedure PIF (Q_operand   : in KDF9.Q_register;
   130.                   set_offline : in Boolean) is
   131.    begin
   132.       buffer(Q_operand.C and buffer_number_mask).PIF(Q_operand, set_offline);
   133.       add_in_the_IO_lockout_CPU_time(Q_operand);
   134.    end PIF;
   135.
   136.    procedure PIG (Q_operand   : in KDF9.Q_register;
   137.                   set_offline : in Boolean) is
   138.    begin
   139.       buffer(Q_operand.C and buffer_number_mask).PIG(Q_operand, set_offline);
   140.       add_in_the_IO_lockout_CPU_time(Q_operand);
   141.    end PIG;
   142.
   143.    procedure PIH (Q_operand   : in KDF9.Q_register;
   144.                   set_offline : in Boolean) is
   145.    begin
   146.       buffer(Q_operand.C and buffer_number_mask).PIH(Q_operand, set_offline);
   147.       add_in_the_IO_lockout_CPU_time(Q_operand);
   148.    end PIH;
   149.
   150.    procedure PMA (Q_operand   : in KDF9.Q_register;
   151.                   set_offline : in Boolean) is
   152.    begin
   153.       buffer(Q_operand.C and buffer_number_mask).PMA(Q_operand, set_offline);
   154.    end PMA;
   155.
   156.    procedure PMB (Q_operand   : in KDF9.Q_register;
   157.                   set_offline : in Boolean) is
   158.    begin
   159.       buffer(Q_operand.C and buffer_number_mask).PMB(Q_operand, set_offline);
   160.    end PMB;
   161.
   162.    procedure PMC (Q_operand   : in KDF9.Q_register;
   163.                   set_offline : in Boolean) is
   164.    begin
   165.       buffer(Q_operand.C and buffer_number_mask).PMC(Q_operand, set_offline);
   166.    end PMC;
   167.
   168.    procedure PMD (Q_operand   : in KDF9.Q_register;
   169.                   set_offline : in Boolean) is
   170.    begin
   171.       buffer(Q_operand.C and buffer_number_mask).PMD(Q_operand, set_offline);
   172.    end PMD;
   173.
   174.    procedure PME (Q_operand   : in KDF9.Q_register;
   175.                   set_offline : in Boolean) is
   176.    begin
   177.       buffer(Q_operand.C and buffer_number_mask).PME(Q_operand, set_offline);
   178.    end PME;
   179.
   180.    procedure PMF (Q_operand   : in KDF9.Q_register;
   181.                   set_offline : in Boolean) is
   182.    begin
   183.       buffer(Q_operand.C and buffer_number_mask).PMF(Q_operand, set_offline);
   184.    end PMF;
   185.
   186.    procedure PMG (Q_operand   : in KDF9.Q_register;
   187.                   set_offline : in Boolean) is
   188.    begin
   189.       buffer(Q_operand.C and buffer_number_mask).PMG(Q_operand, set_offline);
   190.    end PMG;
   191.
   192.    procedure PMK (Q_operand   : in KDF9.Q_register;
   193.                   set_offline : in Boolean) is
   194.    begin
   195.       buffer(Q_operand.C and buffer_number_mask).PMK(Q_operand, set_offline);
   196.    end PMK;
   197.
   198.    procedure PML (Q_operand   : in KDF9.Q_register;
   199.                   set_offline : in Boolean) is
   200.    begin
   201.       buffer(Q_operand.C and buffer_number_mask).PML(Q_operand, set_offline);
   202.    end PML;
   203.
   204.    procedure POA (Q_operand   : in KDF9.Q_register;
   205.                   set_offline : in Boolean) is
   206.    begin
   207.       buffer(Q_operand.C and buffer_number_mask).POA(Q_operand, set_offline);
   208.       add_in_the_IO_lockout_CPU_time(Q_operand);
   209.    end POA;
   210.
   211.    procedure POB (Q_operand   : in KDF9.Q_register;
   212.                   set_offline : in Boolean) is
   213.    begin
   214.       buffer(Q_operand.C and buffer_number_mask).POB(Q_operand, set_offline);
   215.       add_in_the_IO_lockout_CPU_time(Q_operand);
   216.    end POB;
   217.
   218.    procedure POC (Q_operand   : in KDF9.Q_register;
   219.                   set_offline : in Boolean) is
   220.    begin
   221.       buffer(Q_operand.C and buffer_number_mask).POC(Q_operand, set_offline);
   222.       add_in_the_IO_lockout_CPU_time(Q_operand);
   223.    end POC;
   224.
   225.    procedure POD (Q_operand   : in KDF9.Q_register;
   226.                   set_offline : in Boolean) is
   227.    begin
   228.       buffer(Q_operand.C and buffer_number_mask).POD(Q_operand, set_offline);
   229.       add_in_the_IO_lockout_CPU_time(Q_operand);
   230.    end POD;
   231.
   232.    procedure POE (Q_operand   : in KDF9.Q_register;
   233.                   set_offline : in Boolean) is
   234.    begin
   235.       buffer(Q_operand.C and buffer_number_mask).POE(Q_operand, set_offline);
   236.    end POE;
   237.
   238.    procedure POF (Q_operand   : in KDF9.Q_register;
   239.                   set_offline : in Boolean) is
   240.    begin
   241.       buffer(Q_operand.C and buffer_number_mask).POF(Q_operand, set_offline);
   242.    end POF;
   243.
   244.    procedure POG (Q_operand   : in KDF9.Q_register;
   245.                   set_offline : in Boolean) is
   246.    begin
   247.       buffer(Q_operand.C and buffer_number_mask).POG(Q_operand, set_offline);
   248.    end POG;
   249.
   250.    procedure POH (Q_operand   : in KDF9.Q_register;
   251.                   set_offline : in Boolean) is
   252.    begin
   253.       buffer(Q_operand.C and buffer_number_mask).POH(Q_operand, set_offline);
   254.    end POH;
   255.
   256.    procedure POK (Q_operand   : in KDF9.Q_register;
   257.                   set_offline : in Boolean) is
   258.    begin
   259.       buffer(Q_operand.C and buffer_number_mask).POK(Q_operand, set_offline);
   260.    end POK;
   261.
   262.    procedure POL (Q_operand   : in KDF9.Q_register;
   263.                   set_offline : in Boolean) is
   264.    begin
   265.       buffer(Q_operand.C and buffer_number_mask).POL(Q_operand, set_offline);
   266.    end POL;
   267.
   268. end IOC.dispatcher;

Compiling: ../Source/ioc-dispatcher.ads
Source file time stamp: 2021-01-10 23:52:36
Compiled at: 2021-02-08 17:21:01

     1. -- CPU I/O orders are dispatched here to device-specific handlers within the IOC type hierarchy.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.dispatcher is
    18.
    19.    procedure MANUAL_CT (Q_operand   : in KDF9.Q_register;
    20.                         set_offline : in Boolean);
    21.
    22.    procedure BUSY (Q_operand   : in KDF9.Q_register;
    23.                    set_offline : in Boolean;
    24.                    result      : out Boolean);
    25.
    26.    procedure PAR (Q_operand   : in KDF9.Q_register;
    27.                   set_offline : in Boolean;
    28.                   result      : out Boolean);
    29.
    30.    procedure TLO (Q_operand   : in KDF9.Q_register;
    31.                   result      : out Boolean);
    32.
    33.    procedure CLO (Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    procedure SLO (Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    procedure INT (Q_operand   : in KDF9.Q_register;
    40.                   set_offline : in Boolean);
    41.
    42.    procedure PIA (Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    procedure PIB (Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    procedure PIC (Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    procedure PID (Q_operand   : in KDF9.Q_register;
    52.                   set_offline : in Boolean);
    53.
    54.    procedure PIE (Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    procedure PIF (Q_operand   : in KDF9.Q_register;
    58.                   set_offline : in Boolean);
    59.
    60.    procedure PIG (Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    procedure PIH (Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean);
    65.
    66.    procedure PMA (Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    procedure PMB (Q_operand   : in KDF9.Q_register;
    70.                   set_offline : in Boolean);
    71.
    72.    procedure PMC (Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    procedure PMD (Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.
    78.    procedure PME (Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    procedure PMF (Q_operand   : in KDF9.Q_register;
    82.                   set_offline : in Boolean);
    83.
    84.    procedure PMG (Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    procedure PMK (Q_operand   : in KDF9.Q_register;
    88.                   set_offline : in Boolean);
    89.
    90.    procedure PML (Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean);
    92.
    93.    procedure POA (Q_operand   : in KDF9.Q_register;
    94.                   set_offline : in Boolean);
    95.
    96.    procedure POB (Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean);
    98.
    99.    procedure POC (Q_operand   : in KDF9.Q_register;
   100.                   set_offline : in Boolean);
   101.
   102.    procedure POD (Q_operand   : in KDF9.Q_register;
   103.                   set_offline : in Boolean);
   104.
   105.    procedure POE (Q_operand   : in KDF9.Q_register;
   106.                   set_offline : in Boolean);
   107.
   108.    procedure POF (Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean);
   110.
   111.    procedure POG (Q_operand   : in KDF9.Q_register;
   112.                   set_offline : in Boolean);
   113.
   114.    procedure POH (Q_operand   : in KDF9.Q_register;
   115.                   set_offline : in Boolean);
   116.
   117.    procedure POK (Q_operand   : in KDF9.Q_register;
   118.                   set_offline : in Boolean);
   119.
   120.    procedure POL (Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean);
   122.
   123. end IOC.dispatcher;
   124.

 268 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-egdon.adb
Source file time stamp: 2021-01-24 01:11:36
Compiled at: 2021-02-08 17:21:01

     1. -- Implement the API (OUTs) of the EGDON Director.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body KDF9.EGDON is
    18.
    19.    procedure do_an_EGDON_OUT (OUT_number : in KDF9.word) is
    20.    begin
    21.       trap_failing_OUT(OUT_number, "EGDON OUTs are not yet implemented");
    22.    end do_an_EGDON_OUT;
    23.
    24. end KDF9.EGDON;

Compiling: ../Source/kdf9-egdon.ads
Source file time stamp: 2021-01-10 23:52:38
Compiled at: 2021-02-08 17:21:01

     1. -- Implement the API (OUTs) of the EGDON Director.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.EGDON is
    18.
    19.    procedure do_an_EGDON_OUT (OUT_number : in KDF9.word);
    20.
    21. end KDF9.EGDON;

 24 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd-processes.adb
Source file time stamp: 2021-02-08 00:24:00
Compiled at: 2021-02-08 17:21:01

     1. -- Implement OUTs 0, 1 and 2 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with dumping;
    18. with exceptions;
    19. with formatting;
    20. with HCI;
    21. with IOC;
    22. with IOC.fast.DR.TSD_OUTs;
    23. with IOC.fast.FD.TSD_OUTs;
    24. with IOC.slow.shift.TR;
    25. with KDF9_char_sets;
    26. with KDF9.CPU;
    27. with KDF9.store;
    28. with KDF9.TSD.peripherals;
    29. with settings;
    30. with state_display;
    31. with tracing;
    32.
    33. with environmental_value_of;
    34.
    35. use  dumping;
    36. use  exceptions;
    37. use  formatting;
    38. use  HCI;
    39. use  IOC;
    40. use  IOC.fast.DR.TSD_OUTs;
    41. use  IOC.fast.FD.TSD_OUTs;
    42. use  IOC.slow.shift.TR;
    43. use  KDF9_char_sets;
    44. use  KDF9.store;
    45. use  KDF9.TSD.peripherals;
    46. use  settings;
    47. use  state_display;
    48. use  tracing;
    49.
    50. package body KDF9.TSD.processes is
    51.
    52. --
    53. -- OUTs 0, 1 and 2 terminate execution in various ways and call for appropriate finalization.
    54. --
    55.
    56.    procedure free_any_allocated_tapes (OUT_number : in KDF9.word) is
    57.    begin
    58.       for b in KDF9.buffer_number loop
    59.          if buffer(b) /= null                      and then
    60.                buffer(b).kind in MT_kind | ST_kind and then
    61.                   is_allocated(buffer(b))              then
    62.             free_the_device_on_buffer(b, OUT_number);
    63.          end if;
    64.       end loop;
    65.    end free_any_allocated_tapes;
    66.
    67.
    68. --
    69. -- OUT 0: terminate the run.
    70. --
    71.
    72.    procedure do_OUT_0 is
    73.    begin
    74.       free_any_allocated_tapes(OUT_number => 0);
    75.       notify_state_display_of_final_ICR;
    76.       log_API_message("OUT 0: end of run");
    77.       raise program_exit;
    78.    end do_OUT_0;
    79.
    80.
    81. --
    82. -- OUT 1: terminate the run and overlay another program in a fresh start.
    83. --
    84.
    85.    procedure finalize_interim_diagnostics (OUT_number : in KDF9.word) is
    86.    begin
    87.       if the_log_is_wanted and pre_overlay_state_is_enabled then
    88.          show_final_state("before overlay by OUT" & OUT_number'Image);
    89.       end if;
    90.
    91.       -- Deal with any dump requests.
    92.       if the_log_is_wanted and nr_of_post_dumping_areas /= 0 then
    93.          log_new_line;
    94.          log_rule;
    95.          log_title("Post-run Dump:");
    96.          print_postrun_dump_areas;
    97.       end if;
    98.       remove_prerun_dump_areas;
    99.       remove_postrun_dump_areas;
   100.
   101.       -- Restart tracing.
   102.       clear_retro_FIFO;
   103.       clear_IOC_FIFO;
   104.       clear_the_histogram;
   105.       clear_the_profile;
   106.       the_profile_is_wanted := False;
   107.       the_INS_plot_is_wanted := False;
   108.       if the_external_trace_is_enabled then
   109.          log_an_external_trace_header("ee9: Restarting the run for OUT" & OUT_number'Image);
   110.       end if;
   111.    end finalize_interim_diagnostics;
   112.
   113.    procedure prepare_successor (new_limits : in KDF9.word; new_program_name : in String := "" ) is
   114.    begin
   115.       -- Set up any new options.
   116.       get_settings_from_file("2");
   117.       display_execution_modes(new_program_name);
   118.
   119.       -- Complete the core image.
   120.       poke_all_amendments;
   121.       save_the_initial_jump;
   122.       store_word(new_limits, 1);
   123.
   124.       -- Display initial dumps.
   125.       the_program_has_been_analysed := False;
   126.       show_all_prerun_dump_areas;
   127.
   128.       -- Establish the new CPU state.
   129.       reset_V_and_T;
   130.       set_NIA_to((0, 0));
   131.    end prepare_successor;
   132.
   133.    procedure do_OUT_1 is
   134.       P : KDF9.pair;
   135.       W : KDF9.word;
   136.    begin
   137.       -- Get the program name.
   138.       ensure_that_the_nest_holds_2_operands;
   139.       P := pop;
   140.       P := KDF9.CPU.shift_logical(P, 24);
   141.
   142.       declare
   143.          program_name : constant String := trimmed(to_string(P));
   144.          overlay_name : constant String := environmental_value_of("KDF9_BINARY", default => "Binary")
   145.                                          & "/"
   146.                                          & program_name;
   147.       begin
   148.          if program_name = "" then
   149.             trap_failing_OUT(1, "the given program name is an empty string");
   150.          end if;
   151.
   152.          if program_name = "KMW0201--UPU" then
   153.             -- The Whetstone Controller is trying to overlay itself with the Translator.
   154.             -- This is so inconvenient in practice that I simply prevent it.
   155.             notify_state_display_of_final_ICR;
   156.             log_API_message("OUT 1: ee9 will not return to the Whetstone Translator", skip => 2);
   157.             raise program_exit;
   158.          end if;
   159.
   160.          -- Tidy up the running program.
   161.          free_all_devices;
   162.          complete_all_extant_transfers;
   163.          notify_state_display_of_final_ICR;
   164.          finalize_interim_diagnostics(OUT_number => 1);
   165.          log_API_message("OUT 1: ICR ="
   166.                        & ICR'Image
   167.                        & "; RAN/EL ="
   168.                        & the_CPU_time'Image
   169.                        & " /"
   170.                        & KDF9.us'Image(the_clock_time)
   171.                        & " KDF9 us"
   172.                         );
   173.
   174.          -- The overlaid program inherits the predecessor's time and store limits.
   175.          W := fetch_word(1);
   176.          load_a_program(overlay_name);
   177.          prepare_successor(new_limits => W, new_program_name => overlay_name);
   178.
   179.          raise mode_change_request;
   180.       end;
   181.    end do_OUT_1;
   182.
   183.
   184. --
   185. -- OUT 2: terminate the run and then restart it with a program already in core.
   186. -- complete_TSD_OUT_2 is called by KDF9.microcode after it has finalized the OUT instruction.
   187. --
   188.
   189.    time_limit : KDF9.word;
   190.
   191.    procedure do_OUT_2 is
   192.    begin
   193.       ensure_that_the_nest_holds_an_operand;
   194.       time_limit := pop;
   195.       the_trace_operand := time_limit;
   196.
   197.       -- Tidy up the running program.
   198.       free_any_allocated_tapes(OUT_number => 2);
   199.       free_any_reserved_disc_space;
   200.       free_any_reserved_drum_space;
   201.       notify_state_display_of_final_ICR;
   202.
   203.       raise OUT_2_restart;
   204.    end do_OUT_2;
   205.
   206.    procedure complete_TSD_OUT_2 is
   207.    begin
   208.       finalize_interim_diagnostics(OUT_number => 2);
   209.       if time_limit >= 2**24 then
   210.          trap_failing_OUT(2, "the new time limit =" & time_limit'Image & "s is too big");
   211.       end if;
   212.
   213.       log_API_message("OUT 2: ICR ="
   214.                     & ICR'Image
   215.                     & "; RAN/EL ="
   216.                     & the_CPU_time'Image
   217.                     & " /"
   218.                     & KDF9.us'Image(the_clock_time)
   219.                     & " KDF9 us"
   220.                     & "; new time limit = "
   221.                     & time_limit'Image &"s"
   222.                      );
   223.
   224.       --The successor has a new time limit and inherits the predecessor's store limit.
   225.       prepare_successor(new_limits => time_limit * 2**24 + fetch_halfword(1, 1) / 2**24);
   226.
   227.       reset_the_program_state;
   228.    end complete_TSD_OUT_2;
   229.
   230.
   231. --
   232. -- OUT 97: this not a genuine TSD OUT.
   233. --
   234.
   235.    procedure do_OUT_97 is
   236.       P      : constant KDF9.word := pop;
   237.       name   : constant String    := trimmed(to_string(P));
   238.       value  : constant String    := environmental_value_of(name, "0");
   239.       number : KDF9.word;
   240.    begin
   241.       number := KDF9.word'Value(value);
   242.       the_trace_operand := number;
   243.       push(number);
   244.    exception
   245.       when others =>
   246.          trap_failing_OUT(97, name & " = '" & value & "', not a valid integer");
   247.    end do_OUT_97;
   248.
   249. end KDF9.TSD.processes;

Compiling: ../Source/kdf9-tsd-processes.ads
Source file time stamp: 2021-01-23 00:21:20
Compiled at: 2021-02-08 17:21:01

     1. -- Implement OUTs 0.. 2 and 5..7 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.processes is
    18.
    19.    procedure do_OUT_0 with No_Return;
    20.
    21.    procedure do_OUT_1 with No_Return;
    22.
    23.    procedure do_OUT_2 with No_Return;
    24.
    25.    procedure complete_TSD_OUT_2;
    26.
    27.    procedure do_OUT_97;
    28.
    29.
    30. end KDF9.TSD.processes;

 249 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/disassembly.adb
Source file time stamp: 2021-01-10 23:52:34
Compiled at: 2021-02-08 17:21:01

     1. -- Produce dis-assembled instructions in an approximation to KDF9 Usercode.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with formatting;
    18. with KDF9.CPU;
    19. with KDF9.decoding;
    20.
    21. use  formatting;
    22. use  KDF9.CPU;
    23. use  KDF9.decoding;
    24.
    25. package body disassembly is
    26.
    27.    function flagged (flag : String; s : KDF9.syllable)
    28.    return String
    29.    is (flag & oct_of(s));
    30.
    31.    function machine_code (decoded : KDF9.decoded_order)
    32.    return String
    33.    is (
    34.        case decoded.kind is
    35.           when one_syllable_order => flagged("#", decoded.order.syllable_0),
    36.
    37.           when two_syllable_order => flagged("#", decoded.order.syllable_0)
    38.                                    & flagged(":", decoded.order.syllable_1),
    39.           when normal_jump_order
    40.              | data_access_order  => flagged("#", decoded.order.syllable_0)
    41.                                    & flagged(":", decoded.order.syllable_1)
    42.                                    & flagged(":", decoded.order.syllable_2)
    43.       );
    44.
    45.    function one_syllable_order_name (decoded : KDF9.decoded_order)
    46.    return String
    47.    is (
    48.        case decoded.compressed_opcode is
    49.           when ABS_9   => "ABS",
    50.           when ABSF    => "ABSF",
    51.           when AND_9   => "AND",
    52.           when BITS    => "BITS",
    53.           when CAB     => "CAB",
    54.           when CONT    => "CONT",
    55.           when DIV     => "/",
    56.           when DIVD    => "/D",
    57.           when DIVDF   => "/DF",
    58.           when DIVF    => "/F",
    59.           when DIVI    => "/I",
    60.           when DIVR    => "/R",
    61.           when DUMMY   => "DUMMY",
    62.           when DUP     => "DUP",
    63.           when DUPD    => "DUPD",
    64.           when ERASE   => "ERASE",
    65.           when FIX     => "FIX",
    66.           when FLOAT_9 => "FLOAT",
    67.           when FLOATD  => "FLOATD",
    68.           when FRB     => "FRB",
    69.           when MAX     => "MAX",
    70.           when MAXF    => "MAXF",
    71.           when MINUS   => "-",
    72.           when MINUSD  => "-D",
    73.           when MINUSDF => "-DF",
    74.           when MINUSF  => "-F",
    75.           when NEG     => "NEG",
    76.           when NEGD    => "NEGD",
    77.           when NEGDF   => "NEGDF",
    78.           when NEGF    => "NEGF",
    79.           when NEV     => "NEV",
    80.           when NOT_9   => "NOT",
    81.           when OR_9    => "OR",
    82.           when PERM    => "PERM",
    83.           when PLUS    => "+",
    84.           when PLUSD   => "+D",
    85.           when PLUSDF  => "+DF",
    86.           when PLUSF   => "+F",
    87.           when REV     => "REV",
    88.           when REVD    => "REVD",
    89.           when ROUND   => "ROUND",
    90.           when ROUNDF  => "ROUNDF",
    91.           when ROUNDH  => "ROUNDH",
    92.           when ROUNDHF => "ROUNDHF",
    93.           when SIGN    => "SIGN",
    94.           when SIGNF   => "SIGNF",
    95.           when STAND   => "STAND",
    96.           when STR     => "STR",
    97.           when TO_TR   => "=TR",
    98.           when TOB     => "TOB",
    99.           when VR      => "VR",
   100.           when X_frac  => "×",
   101.           when XD      => "×D",
   102.           when XDF     => "×DF",
   103.           when XF      => "×F",
   104.           when XPLUSF  => "×+F",
   105.           when ZERO    => "ZERO",
   106.           when 0       => "DUMMY0",
   107.           when others  =>  machine_code(decoded)
   108.        );
   109.
   110.    function two_syllable_order_name (decoded : KDF9.decoded_order)
   111.    return String is
   112.
   113.       default : constant String := machine_code(decoded);
   114.       invalid : constant String := "";
   115.       k       : constant String := trimmed(decoded.Qk'Image);
   116.       q       : constant String := trimmed(decoded.Qq'Image);
   117.       opcode  : constant KDF9.compressed_opcode := (decoded.Qk and not manual_bit);
   118.       CT      : constant Boolean := (decoded.Qk and manual_bit) = 0;
   119.
   120.       function IO_order (stem : String)
   121.       return String
   122.       is (if stem = invalid then default else stem & "Q" & q);
   123.
   124.       function IO_order_name
   125.       return String
   126.       is (
   127.           case decoded.compressed_opcode is
   128.                when PIA_PIC_CLO_TLO_Qq =>
   129.                                    IO_order(case opcode is
   130.                                                when PIA_bits => "PIA",
   131.                                                when PIC_bits => "PIC",
   132.                                                when CLO_bits => "CLO",
   133.                                                when TLO_bits => "TLO",
   134.                                                when others   => invalid),
   135.                when PIB_PID_Qq =>
   136.                                    IO_order(case opcode is
   137.                                                when PIB_bits => "PIB",
   138.                                                when PID_bits => "PID",
   139.                                                when others   => invalid),
   140.                when PIE_PIG_Qq =>
   141.                                    IO_order(case opcode is
   142.                                                when PIE_bits => "PIE",
   143.                                                when PIG_bits => "PIG",
   144.                                                when others   => invalid),
   145.                when PIF_PIH_Qq =>
   146.                                    IO_order(case opcode is
   147.                                                when PIF_bits => "PIF",
   148.                                                when PIH_bits => "PIH",
   149.                                                when others   => invalid),
   150.                when PMA_PMK_INT_Qq =>
   151.                                    IO_order(case opcode is
   152.                                                when PMA_bits => "PMA",
   153.                                                when PMK_bits => "PMK",
   154.                                                when INT_bits => "INT",
   155.                                                when others   => invalid),
   156.                when CT_PMB_PMC_BUSY_Qq =>
   157.                                    IO_order(case opcode is
   158.                                                when PMB_bits  => "PMB",
   159.                                                when PMC_bits  => "PMC",
   160.                                                when BUSY_bits => "BUSY",
   161.                                                when CTQ_bits => (if CT then "CT" else "MANUAL"),
   162.                                                when others    => invalid),
   163.                when PMD_PME_PML_Qq =>
   164.                                    IO_order(case opcode is
   165.                                                when PMD_bits => "PMD",
   166.                                                when PME_bits => "PME",
   167.                                                when PML_bits => "PML",
   168.                                                when others   => invalid),
   169.                when PMF_PMG_Qq =>
   170.                                    IO_order(case opcode is
   171.                                                when PMF_bits => "PMF",
   172.                                                when PMG_bits => "PMG",
   173.                                                when others   => invalid),
   174.                when POA_POC_POE_POF_PMH_Qq =>
   175.                                    IO_order(case opcode is
   176.                                                when POA_bits => "POA",
   177.                                                when POC_bits => "POC",
   178.                                                when POE_bits => "POE",
   179.                                                when POF_bits => "POF",
   180.                                                when PMH_bits => "PMH",
   181.                                                when others   => invalid),
   182.                when POB_POD_Qq =>
   183.                                    IO_order(case opcode is
   184.                                                when POB_bits => "POB",
   185.                                                when POD_bits => "POD",
   186.                                                when others   => invalid),
   187.                when POG_POL_Qq =>
   188.                                    IO_order(case opcode is
   189.                                                when POG_bits => "POG",
   190.                                                when POL_bits => "POL",
   191.                                                when others   => invalid),
   192.                when POH_POK_Qq =>
   193.                                    IO_order(case opcode is
   194.                                                when POH_bits => "POH",
   195.                                                when POL_bits => "POK",
   196.                                                when others   => invalid),
   197.                when PAR_Qq =>      IO_order("PAR"),
   198.                when others =>      IO_order(invalid)
   199.          );
   200.
   201.       function indirect_store_order_name (suffix : String := "")
   202.       return String
   203.       is ("=M" & k & "M" & q & suffix);
   204.
   205.       function indirect_fetch_order_name (suffix : String := "")
   206.       return String
   207.       is ("M" & k & "M" & q & suffix);
   208.
   209.       function Qq_to_Qk_name (part : String)
   210.       return String
   211.       is (part & q & " TO Q" & k);
   212.
   213.       function Qq_order_name (action : String; suffix : String := "")
   214.       return String
   215.       is (action & q & suffix);
   216.
   217.       function shift_count
   218.       return String is
   219.          constant_flag : constant := 1;
   220.          fixed_shift   : CPU.signed_Q_part;
   221.       begin
   222.          if (decoded.order.syllable_1 and constant_flag) /= 0  then
   223.             fixed_shift := resign(KDF9.Q_part(decoded.order.syllable_1/2));
   224.             if fixed_shift > 63 then
   225.                fixed_shift := fixed_shift - 128;
   226.             end if;
   227.             return (if fixed_shift < 0 then "" else "+") & trimmed(fixed_shift'Image);
   228.          else
   229.             return "C" & q;
   230.          end if;
   231.       end shift_count;
   232.
   233.       function shift_order_name (action : String)
   234.       return String
   235.       is (action & shift_count);
   236.
   237.    begin -- two_syllable_order_name
   238.       return
   239.          (
   240.           case decoded.compressed_opcode is
   241.              when MkMq       => indirect_fetch_order_name,
   242.              when MkMqQ      => indirect_fetch_order_name(suffix => "Q"),
   243.              when MkMqH      => indirect_fetch_order_name(suffix => "H"),
   244.              when MkMqQH     => indirect_fetch_order_name(suffix => "QH"),
   245.              when MkMqN      => indirect_fetch_order_name(suffix => "N"),
   246.              when MkMqQN     => indirect_fetch_order_name(suffix => "QN"),
   247.              when MkMqHN     => indirect_fetch_order_name(suffix => "HN"),
   248.              when MkMqQHN    => indirect_fetch_order_name(suffix => "QHN"),
   249.
   250.              when TO_MkMq    => indirect_store_order_name,
   251.              when TO_MkMqQ   => indirect_store_order_name(suffix => "Q"),
   252.              when TO_MkMqH   => indirect_store_order_name(suffix => "H"),
   253.              when TO_MkMqQH  => indirect_store_order_name(suffix => "QH"),
   254.              when TO_MkMqN   => indirect_store_order_name(suffix => "N"),
   255.              when TO_MkMqQN  => indirect_store_order_name(suffix => "QN"),
   256.              when TO_MkMqHN  => indirect_store_order_name(suffix => "HN"),
   257.              when TO_MkMqQHN => indirect_store_order_name(suffix => "QHN"),
   258.
   259.              when M_PLUS_Iq  => Qq_order_name("M+I"),
   260.              when M_MINUS_Iq => Qq_order_name("M-I"),
   261.              when NCq        => Qq_order_name("NC"),
   262.              when DCq        => Qq_order_name("DC"),
   263.              when POS1_TO_Iq => Qq_order_name("I",  suffix => "=+1"),
   264.              when NEG1_TO_Iq => Qq_order_name("I",  suffix => "=-1"),
   265.              when POS2_TO_Iq => Qq_order_name("I",  suffix => "=+2"),
   266.              when NEG2_TO_Iq => Qq_order_name("I",  suffix => "=+2"),
   267.              when JCqNZS     => Qq_order_name("JC", suffix => "NZS"),
   268.
   269.              when MqTOQk     => Qq_to_Qk_name("M"),
   270.              when IqTOQk     => Qq_to_Qk_name("I"),
   271.              when IMqTOQk    => Qq_to_Qk_name("IM"),
   272.              when CqTOQk     => Qq_to_Qk_name("C"),
   273.              when CMqTOQk    => Qq_to_Qk_name("CM"),
   274.              when CIqTOQk    => Qq_to_Qk_name("CI"),
   275.              when QqTOQk     => Qq_to_Qk_name("Q"),
   276.              when QCIMq =>
   277.                 (
   278.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then  Qq_order_name("Q")
   279.                  elsif (decoded.Qk and M_part_choice) /= 0       then  Qq_order_name("M")
   280.                  elsif (decoded.Qk and C_part_choice) /= 0       then  Qq_order_name("C")
   281.                  elsif (decoded.Qk and I_part_choice) /= 0       then  Qq_order_name("I")
   282.                  else  default
   283.                 ),
   284.              when TO_RCIMq =>
   285.                 (
   286.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then Qq_order_name("=Q")
   287.                  elsif (decoded.Qk and M_part_choice) /= 0 then
   288.                     Qq_order_name(if (decoded.Qk and reset_choice) /= 0 then "=RM" else "=M")
   289.                  elsif (decoded.Qk and C_part_choice) /= 0 then
   290.                     Qq_order_name(if (decoded.Qk and reset_choice) /= 0 then "=RC" else "=C")
   291.                  elsif (decoded.Qk and I_part_choice) /= 0 then
   292.                     Qq_order_name(if (decoded.Qk and reset_choice) /= 0 then "=RI" else "=I")
   293.                  else default
   294.                 ),
   295.              when ADD_TO_QCIMq =>
   296.                 (
   297.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then Qq_order_name("=+Q")
   298.                  elsif (decoded.Qk and M_part_choice) /= 0       then Qq_order_name("=+M")
   299.                  elsif (decoded.Qk and C_part_choice) /= 0       then Qq_order_name("=+C")
   300.                  elsif (decoded.Qk and I_part_choice) /= 0       then Qq_order_name("=+I")
   301.                  else  default
   302.                 ),
   303.
   304.              when SHA   => shift_order_name("SHA"),
   305.              when SHAD  => shift_order_name("SHAD"),
   306.              when MACC  => shift_order_name("×+"),
   307.              when SHL   => shift_order_name("SHL"),
   308.              when SHLD  => shift_order_name("SHLD"),
   309.              when SHC   => shift_order_name("SHC"),
   310.
   311.              when TO_Kq =>
   312.                 (
   313.                  case decoded.Qq is
   314.                     when K0 => "=K0",
   315.                     when K1 => "=K1",
   316.                     when K2 => "=K2",
   317.                     when K3 => "=K3",
   318.                     when others => default
   319.                 ),
   320.              when Kk =>
   321.                 (
   322.                  case decoded.Qk is
   323.                    when K4 => "K4",
   324.                    when K5 => "K5",
   325.                    when K7 => "K7",
   326.                    when others => default
   327.                 ),
   328.
   329.              when LINK    => "LINK",
   330.              when TO_LINK => "=LINK",
   331.
   332.              when others  => IO_order_name
   333.           );
   334.    end two_syllable_order_name;
   335.
   336.    function normal_jump_order_name (decoded      : KDF9.decoded_order;
   337.                                     octal_option : Boolean := True;
   338.                                     both_bases   : Boolean := True)
   339.    return String is
   340.
   341.       the_target  : syllable_address renames decoded.target;
   342.       the_address : constant String := oct_or_dec_of(the_target, octal_option);
   343.       remark      : constant String
   344.                   := ";("
   345.                    & (if   octal_option
   346.                       then dec_of(KDF9.Q_part(the_target.order_word_number))
   347.                       else "#" & oct_of(the_target.order_word_number))
   348.                    & ")";
   349.
   350.       function jump (on_condition : String)
   351.       return String
   352.       is ("JE" & the_address & on_condition & (if both_bases then remark else ""));
   353.
   354.       function leave (and_how : String)
   355.       return String
   356.       is ("EXIT" & and_how & remark);
   357.
   358.    begin  -- normal_jump_order_name
   359.       return (
   360.               case decoded.compressed_opcode is
   361.                  when JrEQ   => jump("EQ"),
   362.                  when JrGTZ  => jump("GTZ"),
   363.                  when JrLTZ  => jump("LTZ"),
   364.                  when JrEQZ  => jump("EQZ"),
   365.                  when JrV    => jump("V"),
   366.                  when JrEN   => jump("EN"),
   367.                  when Jr     => jump(""),
   368.                  when JrEJ   => jump("EJ"),
   369.                  when JrTR   => jump("TR"),
   370.                  when JrNE   => jump("NE"),
   371.                  when JrLEZ  => jump("LEZ"),
   372.                  when JrGEZ  => jump("GEZ"),
   373.                  when JrNEZ  => jump("NEZ"),
   374.                  when JrNV   => jump("NV"),
   375.                  when JrNEN  => jump("NEN"),
   376.                  when JrNEJ  => jump("NEJ"),
   377.                  when JrNTR  => jump("NTR"),
   378.
   379.                  when JrCqZ  => jump("C" & trimmed(decoded.Qq'Image) & "Z"),
   380.                  when JrCqNZ => jump("C" & trimmed(decoded.Qq'Image) & "NZ"),
   381.
   382.                  when JSr    => "JSE" & the_address,
   383.                  when OS_OUT => "OUT",
   384.
   385.                  when EXITD  => leave("D"),
   386.                  when EXIT_n =>
   387.                     -- Try to give the most helpful interpretation of the operand.
   388.                     (
   389.                      if the_target.syllable_index = 0 then  -- c.f. decode_a_jump_order.
   390.                         -- No halfword offset applies.
   391.                         (
   392.                          if the_target.order_word_number < 4 then
   393.                            leave(
   394.                                  if the_target.order_word_number = 0
   395.                                  then ""
   396.                                  else oct_of(KDF9.Q_part(2*the_target.order_word_number), 1)
   397.                                 )
   398.                          else
   399.                            leave("AE" & oct_or_dec_of((the_target.order_word_number, 0), octal_option))
   400.                         )
   401.                      elsif the_target.order_word_number < 4 then
   402.                         leave(oct_of(KDF9.Q_part(2*the_target.order_word_number + 1), 1))
   403.                      else
   404.                         leave("AE" & oct_or_dec_of((the_target.order_word_number, 3), octal_option))
   405.                     ),
   406.
   407.                  when others =>  machine_code(decoded)
   408.              );
   409.    end normal_jump_order_name;
   410.
   411.    function data_access_order_name (decoded      : KDF9.decoded_order;
   412.                                     octal_option : Boolean;
   413.                                     both_bases   : Boolean := True)
   414.    return String is
   415.
   416.       operand      : KDF9.Q_part   renames decoded.operand;
   417.       Qq           : KDF9.Q_number renames decoded.Qq;
   418.       the_address  : constant String
   419.                    := (if octal_option then "#" & oct_of(operand, 1) else dec_of(operand));
   420.       remark       : constant String
   421.                    := ";(" & (if octal_option then dec_of(operand) else "#" & oct_of(operand, 1)) & ")";
   422.       any_modifier : constant String
   423.                    := (if Qq /= 0 then "M" & trimmed(Qq'Image) else "");
   424.    begin
   425.       return (
   426.               case decoded.compressed_opcode is
   427.                  when EaMq     => "E"   & the_address & any_modifier & remark,
   428.                  when TO_EaMq  => "=E"  & the_address & any_modifier & remark,
   429.                  when EaMqQ    => "E"   & the_address & any_modifier & "Q" & remark,
   430.                  when TO_EaMqQ => "=E"  & the_address & any_modifier & "Q" & remark,
   431.                  when SET      => "SET" & (
   432.                                            if octal_option
   433.                                            then "B" & oct_of(operand, 2)
   434.                                               & (
   435.                                                  if operand > 7 and both_bases
   436.                                                  then ";(" & signed_dec_of(operand) & ")"
   437.                                                  else ""
   438.                                                 )
   439.                                            else signed_dec_of(operand)
   440.                                               & (
   441.                                                  if operand > 9 and both_bases
   442.                                                  then ";(B" & oct_of(operand, 2) & ")"
   443.                                                  else ""
   444.                                                 )
   445.                                           ),
   446.                  when others   => "?"
   447.              );
   448.    end data_access_order_name;
   449.
   450.    function the_full_name_of (order        : KDF9.decoded_order;
   451.                               octal_option : Boolean := True;
   452.                               both_bases   : Boolean := True)
   453.    return String is
   454.       result : constant String
   455.          := (
   456.              case order.kind is
   457.                 when one_syllable_order => one_syllable_order_name(order),
   458.                 when two_syllable_order => two_syllable_order_name(order),
   459.                 when normal_jump_order  => normal_jump_order_name(order, octal_option, both_bases),
   460.                 when data_access_order  => data_access_order_name(order, octal_option, both_bases)
   461.             );
   462.    begin
   463.       return (if result(1) /= '?' then result else "an INVALID order");
   464.    end the_full_name_of;
   465.
   466.    function the_code_and_name_of_INS
   467.    return String
   468.    is (machine_code(INS) & ", i.e. " & the_full_name_of(INS));
   469.
   470.    function two_syllable_skeleton (encoding : KDF9.syllable)
   471.    return String is
   472.
   473.       function IO_skeleton
   474.       return String
   475.       is (
   476.           case encoding and 8#77# is
   477.              when POA_POC_POE_POF_PMH_Qq => "{POA|POC|POE|POF|PMH}Qq",
   478.              when PIA_PIC_CLO_TLO_Qq     => "{PIA|PIC|CLO|TLO}Qq",
   479.              when CT_PMB_PMC_BUSY_Qq     => "{BUSY|CT|MANUAL|PMB|PMC}Qq",
   480.              when PAR_Qq                 => "PARQq",
   481.              when PIB_PID_Qq             => "{PIB|PID}Qq",
   482.              when PIE_PIG_Qq             => "{PIE|PIG}Qq",
   483.              when PIF_PIH_Qq             => "{PIF|PIH}Qq",
   484.              when PMA_PMK_INT_Qq         => "{INT|PMA|PMK}Qq",
   485.              when PMD_PME_PML_Qq         => "{PMD|PME}Qq",
   486.              when PMF_PMG_Qq             => "{PMF|PMG}Qq",
   487.              when POB_POD_Qq             => "{POB|POD}Qq",
   488.              when POG_POL_Qq             => "{POG|POL}Qq",
   489.              when POH_POK_Qq             => "{POH|POK}Qq",
   490.              when others                 => "invalid IO group syllable #" & oct_of(encoding)
   491.          );
   492.
   493.    begin  -- two_syllable_skeleton
   494.       return
   495.          (
   496.           case encoding and 8#77# is
   497.              when MkMq         => "MkMq",
   498.              when MkMqQ        => "MkMqQ",
   499.              when MkMqH        => "MkMqH",
   500.              when MkMqQH       => "MkMqQH",
   501.              when MkMqN        => "MkMqN",
   502.              when MkMqQN       => "MkMqQN",
   503.              when MkMqHN       => "MkMqHN",
   504.              when MkMqQHN      => "MkMqQHN",
   505.
   506.              when TO_MkMq      => "=MkMq",
   507.              when TO_MkMqQ     => "=MkMqQ",
   508.              when TO_MkMqH     => "=MkMqH",
   509.              when TO_MkMqQH    => "=MkMqQH",
   510.              when TO_MkMqN     => "=MkMqN",
   511.              when TO_MkMqQN    => "=MkMqQN",
   512.              when TO_MkMqHN    => "=MkMqHN",
   513.              when TO_MkMqQHN   => "=MkMqQHN",
   514.
   515.              when JCqNZS       => "JCqNZS",
   516.              when M_PLUS_Iq    => "M+Iq",
   517.              when M_MINUS_Iq   => "M-Iq",
   518.              when NCq          => "NCq",
   519.              when DCq          => "DCq",
   520.              when POS1_TO_Iq   => "Iq=+1",
   521.              when NEG1_TO_Iq   => "Iq=-1",
   522.              when POS2_TO_Iq   => "Iq=+2",
   523.              when NEG2_TO_Iq   => "Iq=-2",
   524.
   525.              when MqTOQk       => "MqTOQk",
   526.              when IqTOQk       => "IqTOQk",
   527.              when IMqTOQk      => "IMqTOQk",
   528.              when CqTOQk       => "CqTOQk",
   529.              when CMqTOQk      => "CMqTOQk",
   530.              when CIqTOQk      => "CIqTOQk",
   531.              when QqTOQk       => "QqTOQk",
   532.
   533.              when QCIMq        => "{Q|C|I|M}q",
   534.              when TO_RCIMq     => "=[R]{Q|C|I|M}q",
   535.              when ADD_TO_QCIMq => "=+{Q|C|I|M}q",
   536.
   537.              when SHA          => "SHA",
   538.              when SHAD         => "SHAD",
   539.              when MACC         => "×+",
   540.              when SHL          => "SHL",
   541.              when SHLD         => "SHLD",
   542.              when SHC          => "SHC",
   543.
   544.              when TO_Kq =>
   545.                 (
   546.                  case encoding / 16 mod 16 is
   547.                     when K0 => "=K0",
   548.                     when K1 => "=K1",
   549.                     when K2 => "=K2",
   550.                     when K3 => "=K3",
   551.                     when others => "=K?"
   552.                 ),
   553.              when Kk =>
   554.                 (
   555.                  case encoding mod 16 is
   556.                     when K4 => "K4",
   557.                     when K5 => "K5",
   558.                     when K7 => "K7",
   559.                     when others => "K?"
   560.                 ),
   561.
   562.              when LINK =>    "LINK",
   563.              when TO_LINK => "=LINK",
   564.
   565.              when others =>  IO_skeleton
   566.          );
   567.    end two_syllable_skeleton;
   568.
   569.    function normal_jump_skeleton (encoding : KDF9.syllable)
   570.    return String
   571.    is (
   572.        case encoding and 8#77# is
   573.           when JrCqZ  .. JrCqZ+2#1111#  => "JrCqZ",
   574.           when JrCqNZ .. JrCqNZ+2#1111# => "JrCqNZ",
   575.           when JrEQ   => "JrEQ",
   576.           when JrGTZ  => "JrGTZ",
   577.           when JrLTZ  => "JrLTZ",
   578.           when JrEQZ  => "JrEQZ",
   579.           when JrV    => "JrV",
   580.           when JrEN   => "JrEN",
   581.           when Jr     => "Jr",
   582.           when JrEJ   => "JrEJ",
   583.           when JSr    => "JSr",
   584.           when JrTR   => "JrTR",
   585.           when EXIT_n => "EXIT",
   586.           when JrNE   => "JrNE",
   587.           when JrLEZ  => "JrLEZ",
   588.           when JrGEZ  => "JrGEZ",
   589.           when JrNEZ  => "JrNEZ",
   590.           when JrNV   => "JrNV",
   591.           when JrNEN  => "JrNEN",
   592.           when JrNEJ  => "JrNEJ",
   593.           when JrNTR  => "JrNTR",
   594.           when OS_OUT => "OUT",
   595.           when EXITD  => "EXITD",
   596.           when others => "invalid jump group syllable #" & oct_of(encoding)
   597.       );
   598.
   599.    function data_access_skeleton (compressed_opcode : KDF9.compressed_opcode)
   600.    return String
   601.    is (
   602.        case compressed_opcode is
   603.           when EaMq     => "EeMq",
   604.           when TO_EaMq  => "=EeMq",
   605.           when EaMqQ    => "EeMqQ",
   606.           when TO_EaMqQ => "=EeMqQ",
   607.           when SET      => "SET",
   608.           when others   => "invalid data access compressed opcode #" & oct_of(compressed_opcode)
   609.       );
   610.
   611.    function the_short_name_of (syllable_0 : KDF9.syllable)
   612.    return String is
   613.       its_INS : KDF9.decoded_order := (order => (syllable_0, 0, 0), others => <>);
   614.    begin
   615.       decode(its_INS);
   616.       return
   617.          (
   618.           case KDF9.INS_kind(syllable_0 / 2**6) is
   619.              when one_syllable_order   => one_syllable_order_name(its_INS),
   620.              when two_syllable_order   => two_syllable_skeleton(syllable_0),
   621.              when normal_jump_order    => normal_jump_skeleton(syllable_0),
   622.              when data_access_order    => data_access_skeleton(its_INS.compressed_opcode)
   623.          );
   624.    end the_short_name_of;
   625.
   626. end disassembly;

Compiling: ../Source/disassembly.ads
Source file time stamp: 2021-01-10 23:52:35
Compiled at: 2021-02-08 17:21:01

     1. -- Produce dis-assembled instructions in an approximation to KDF9 Usercode.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18.
    19. use  KDF9;
    20.
    21. package disassembly is
    22.
    23.    function the_code_and_name_of_INS
    24.    return String;
    25.
    26.    function the_full_name_of (order        : KDF9.decoded_order;
    27.                               octal_option : Boolean := True;
    28.                               both_bases   : Boolean := True)
    29.    return String;
    30.
    31.    function the_short_name_of (syllable_0 : KDF9.syllable)
    32.    return String;
    33.
    34. end disassembly;

 626 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-diagnostics.adb
Source file time stamp: 2021-01-10 23:52:36
Compiled at: 2021-02-08 17:21:02

     1. -- Provide diagnostic output of the state of all the buffers.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with disassembly;
    18.
    19. with IOC.the_locker_of;
    20.
    21. procedure IOC.diagnostics is
    22.    Q : KDF9.Q_register;
    23.    B : KDF9.Q_part;
    24. begin
    25.    if not debugging_is_enabled then return; end if;
    26.    for g in Q_part'(0) .. 100 loop
    27.       if there_are_locks_in_physical_addresses(KDF9.Q_register'(0, 32*g, 32*g + 31)) then
    28.          output("there are locks in group" & g'Image & " PHY" & Q_part'(32*g)'Image);
    29.          B := the_locker_of(32*g);
    30.          output(", locked by" & B'Image & ":");
    31.          if B /= 16 then output_line(buffer(B).device_name); else output_line(""); end if;
    32.       end if;
    33.    end loop;
    34.    for the_buffer of buffer loop
    35.       if the_buffer /= null                        and then
    36.          the_buffer.initiation_time /= KDF9.us'Last    then
    37.          output_line;
    38.          output_line("Current state of buffer #" & oct_of(the_buffer.number, 2));
    39.          output_line(
    40.                      "   device: " & the_buffer.device_name
    41.                    & "     kind: " & the_buffer.kind'Image
    42.                    & "     unit:"  & the_buffer.unit'Image
    43.                     );
    44.          output_line("  is_busy: " & the_buffer.is_busy'Image);
    45.          output_line("operation: " & the_buffer.operation'Image);
    46.          output_line(" off_line: " & the_buffer.is_offline'Image);
    47.          output_line(" abnormal: " & the_buffer.is_abnormal'Image);
    48.          output_line(" Director: " & the_buffer.is_for_Director'Image);
    49.          output_line(" priority:"  & the_buffer.priority_level'Image);
    50.          output_line("initiated:"  & the_buffer.initiation_time'Image);
    51.          output_line("xfer_time:"  & the_buffer.transfer_time'Image);
    52.          output_line("completes:"  & the_buffer.completion_time'Image);
    53.          Q := the_buffer.control_word;
    54.          output_line(
    55.                      "  control: "
    56.                    & "Q"
    57.                    & Q.C'Image
    58.                    &"/"
    59.                    & Q.I'Image
    60.                    & "/"
    61.                    & Q.M'Image
    62.                     );
    63.          if Q.I <= max_address               and then
    64.              Q.M <= max_address              and then
    65.                 Q.I <= the_buffer.control_word.M then
    66.             output_line(
    67.                         "locked in:"
    68.                       & group(Q.I)'Image
    69.                       & ".."
    70.                       & group(Q.M)'Image
    71.                       & " is "
    72.                       & there_are_locks_in_physical_addresses(Q)'Image
    73.                        );
    74.          end if;
    75.          output_line("order ICR:"  & the_buffer.order_count'Image);
    76.          output_line("    order: " & disassembly.the_full_name_of(the_buffer.decoded_order));
    77.          output_line("@ address: " & oct_of(the_buffer.order_address));
    78.       end if;
    79.    end loop;
    80. end IOC.diagnostics;

 80 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/file_interfacing.adb
Source file time stamp: 2021-01-10 23:52:35
Compiled at: 2021-02-08 17:21:02

     1. -- Provide an Ada.Text_IO interface to the file system of the real OS.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body file_interfacing is
    18.
    19.    procedure initialize (some_file : in out File_Type;
    20.                          mode      : in File_Mode;
    21.                          file_name : in String) is
    22.    begin
    23.       Open(some_file, mode, file_name);
    24.    exception
    25.       when others =>
    26.          if mode = Out_File then
    27.             Create(some_file, Out_File, file_name);
    28.          else
    29.             raise;
    30.          end if;
    31.    end initialize;
    32.
    33.    procedure finalize (some_file : in out File_Type;
    34.                        file_name : in String) is
    35.       pragma Unreferenced(file_name);
    36.    begin
    37.       Close(some_file);
    38.    end finalize;
    39.
    40. end file_interfacing;

Compiling: ../Source/file_interfacing.ads
Source file time stamp: 2021-01-10 23:52:35
Compiled at: 2021-02-08 17:21:02

     1. -- Provide an Ada.Text_IO interface to the file system of the real OS.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18.
    19. use  Ada.Text_IO;
    20.
    21. package file_interfacing is
    22.
    23.    procedure initialize (some_file : in out File_Type;
    24.                          mode      : in File_Mode;
    25.                          file_name : in String);
    26.
    27.    procedure finalize (some_file : in out File_Type;
    28.                        file_name : in String);
    29.
    30. end file_interfacing;

 40 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/plotter.adb
Source file time stamp: 2021-01-10 23:52:40
Compiled at: 2021-02-08 17:21:02

     1. -- Emulation of the plotting commands of the Calcomp 564 graph plotter.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.slow.shift.GP;
    18. with postscript;
    19.
    20. use  IOC.slow.shift.GP;
    21. use  postscript;
    22.
    23. package body plotter is
    24.
    25.    -- The plotter made equal movements in the x and y directions, in steps of 0.005 inches.
    26.    -- Each command moves the plotting position by at most 1 step,
    27.    --   in either the positive or negative direction of each axis.
    28.
    29.    type step is
    30.      record
    31.         dx, dy : Integer range -1 .. +1;
    32.      end record;
    33.
    34.    null_step : constant plotter.step := (0, 0);
    35.
    36.    function "+" (p : postscript.point; s : plotter.step)
    37.    return postscript.point
    38.    is ((p.x + s.dx, p.y + s.dy));
    39.
    40.    function "-" (p, q : postscript.point)
    41.    return plotter.step
    42.    is ((p.x - q.x, p.y - q.y));
    43.
    44.    -- The plotter drew on a roll of paper 29.5 inches wide and 120 feet long.
    45.    -- 29.5" is   5900 steps at 200 steps per inch = 59 * 100
    46.    -- 120'  is 288000 steps  = 200 per inch * 12 inches per foot * 120 feet.
    47.    -- This sets the boundaries of the plot.
    48.    -- It was physically impossible to move to a point beyond these limits.
    49.
    50.    plot_limit : constant postscript.point := (120*12*200, 59*100);
    51.
    52.    -- A vector is represented by a series of consecutive colinear plotter movements.
    53.    -- For better efficiency, the steps of a vector are accumulated until there is
    54.    --    a change of direction, a pen lift, or the need to close the plotter file.
    55.    -- On these events, any vector thus defined is drawn via a single PostScript command.
    56.
    57.    the_origin      : constant postscript.point := (0, 0);
    58.
    59.    plot_position,
    60.    start_position  : postscript.point := the_origin;
    61.
    62.    -- last_step retains the direction of the previous plotter step.
    63.    last_step       : plotter.step := null_step;
    64.
    65.    the_pen_is_down : Boolean := False;
    66.
    67.    procedure ensure_the_validity_of (from  : in postscript.point;
    68.                                      step  : in plotter.step) is
    69.    begin
    70.      if from.x + step.dx < 0                     or else
    71.            from.y + step.dy < 0                  or else
    72.               from.x + step.dx > plot_limit.x    or else
    73.                  from.y + step.dy > plot_limit.y    then
    74.         notify_invalid_movement(from.x, from.y, step.dx, step.dy);
    75.      end if;
    76.    end ensure_the_validity_of;
    77.
    78.    procedure jump_to (p : in postscript.point)
    79.      with Inline;
    80.
    81.    procedure jump_to (p : in postscript.point) is
    82.    begin
    83.      -- Posit a new vector starting at p.
    84.      last_step := null_step;
    85.      plot_position := p;
    86.      start_position := p;
    87.    end;
    88.
    89.    procedure jump_by (this_step : in plotter.step)
    90.      with Inline;
    91.
    92.    procedure jump_by (this_step : in plotter.step) is
    93.    begin
    94.      ensure_the_validity_of(from => plot_position, step => this_step);
    95.      jump_to(plot_position + this_step);
    96.    end jump_by;
    97.
    98.    procedure close_any_open_vector (stream : in out host_IO.stream) is
    99.    begin
   100.      if the_pen_is_down                and then
   101.            start_position /= plot_position then
   102.         draw_a_PS_vector(stream, start_position, plot_position);
   103.         start_position := plot_position;
   104.      end if;
   105.    end close_any_open_vector;
   106.
   107.    procedure perform (action : in plotter.command; stream : in out host_IO.stream) is
   108.
   109.      procedure draw_to (p : in postscript.point)
   110.         with Inline;
   111.
   112.      procedure draw_to (p : in postscript.point) is
   113.      begin
   114.         if (plot_position - p) = last_step then
   115.            -- p is colinear with the previous step, so merely extend the vector to p.
   116.            plot_position := p;
   117.         else
   118.            -- Draw the whole vector and start a new one.
   119.            draw_a_PS_vector(stream, start_position, plot_position);
   120.            last_step := plot_position - p;
   121.            start_position := plot_position;
   122.            plot_position := p;
   123.         end if;
   124.      end draw_to;
   125.
   126.      procedure draw_by (this_step : in plotter.step)
   127.         with Inline;
   128.
   129.      procedure draw_by (this_step : in plotter.step) is
   130.      begin
   131.         ensure_the_validity_of(from => plot_position, step => this_step);
   132.         draw_to(plot_position + this_step);
   133.      end draw_by;
   134.
   135.      procedure move_by (this_step : in plotter.step)
   136.         with Inline;
   137.
   138.      procedure move_by (this_step : in plotter.step) is
   139.      begin
   140.         -- Convert from natural orientation of X axis to PostScript direction.
   141.         if the_pen_is_down then
   142.            draw_by((-this_step.dx, +this_step.dy));
   143.         else
   144.            jump_by((-this_step.dx, +this_step.dy));
   145.         end if;
   146.      end move_by;
   147.
   148.    begin -- perform
   149.      case action is
   150.         when dummy =>
   151.            null;
   152.         when pen_up =>
   153.            close_any_open_vector(stream);
   154.            the_pen_is_down := False;
   155.         when pen_down =>
   156.            the_pen_is_down := True;
   157.         when go_pY =>
   158.            move_by((+0, +1));
   159.         when go_nY =>
   160.            move_by((+0, -1));
   161.         when go_pX =>
   162.            move_by((+1, +0));
   163.         when go_nX =>
   164.            move_by((-1, +0));
   165.         when go_pXpY =>
   166.            move_by((+1, +1));
   167.         when go_nXnY =>
   168.            move_by((-1, -1));
   169.         when go_pXnY =>
   170.            move_by((+1, -1));
   171.         when go_nXpY =>
   172.            move_by((-1, +1));
   173.         when others =>
   174.            -- EM causes a 'peculiar' motion, according to the Manual, Appendix 5.2, p.303,
   175.            --    and other codes cause 'unpredictable' effects.
   176.            -- ee9 therefore performs an arbitrary, but safe, operation: moving to the origin.
   177.            close_any_open_vector(stream);
   178.            plot_position := the_origin;
   179.      end case;
   180.    end perform;
   181.
   182.    a_plot_is_open : Boolean := False;
   183.
   184.    procedure open_the_plot_file (stream : in out host_IO.stream) is
   185.    begin
   186.      if a_plot_is_open then
   187.         close_the_plot_file(stream);
   188.      end if;
   189.      plot_position := (0,0);
   190.      a_plot_is_open := True;
   191.    end open_the_plot_file;
   192.
   193.    procedure close_the_plot_file (stream : in out host_IO.stream) is
   194.    begin
   195.      if not a_plot_is_open then
   196.         return;
   197.      end if;
   198.      close_any_open_vector(stream);
   199.      a_plot_is_open := False;
   200.    end close_the_plot_file;
   201.
   202. end plotter;

Compiling: ../Source/plotter.ads
Source file time stamp: 2021-01-10 23:52:40
Compiled at: 2021-02-08 17:21:02

     1. -- Emulation of the plotting commands of the Calcomp 564 graph plotter.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with host_IO;
    18. with KDF9_char_sets;
    19.
    20. use  host_IO;
    21.
    22. package plotter is
    23.
    24.    procedure open_the_plot_file (stream : in out host_IO.stream);
    25.
    26.    procedure close_the_plot_file (stream : in out host_IO.stream);
    27.
    28.    type command is new KDF9_char_sets.symbol;
    29.
    30.    -- The KDF9 plotting commands are defined in the Manual, Appendix 6, §5.3, pp. 303-304.
    31.
    32.    -- BUT there is obviously an error in the Manual, as only 9 of the claimed 11 command
    33.    --    codes are listed, and the last, go_nXnY, is coded inconsistently with the others.
    34.
    35.    -- Hypothesis: the table should read as follows:
    36.
    37.    dummy    : constant plotter.command := 2#000_000#;
    38.
    39.    pen_up   : constant plotter.command := 2#100_000#;
    40.    pen_down : constant plotter.command := 2#010_000#;
    41.
    42.    go_pY    : constant plotter.command := 2#001_000#;
    43.    go_nY    : constant plotter.command := 2#000_100#;
    44.    go_pX    : constant plotter.command := 2#000_010#;
    45.    go_nX    : constant plotter.command := 2#000_001#;
    46.
    47.    go_nXnY  : constant plotter.command := go_nX + go_nY;
    48.    go_pXnY  : constant plotter.command := go_pX + go_nY;
    49.    go_nXpY  : constant plotter.command := go_nX + go_pY;
    50.    go_pXpY  : constant plotter.command := go_pX + go_pY;
    51.
    52.    -- These encodings are consistent with the Calcomp plotter command codes used here:
    53.    --     ub.fnwi.uva.nl/computermuseum//calcomp565.html
    54.    -- which defines a full set of 11 commands, two of which are missing from the KDF9 list.
    55.
    56.    is_valid : constant array (plotter.command) of Boolean
    57.             := (dummy    |
    58.                 pen_up   |
    59.                 pen_down |
    60.                 go_pY    |
    61.                 go_nY    |
    62.                 go_pX    |
    63.                 go_nX    |
    64.                 go_pXnY  |
    65.                 go_nXpY  |
    66.                 go_pXpY  |
    67.                 go_nXnY  => True,
    68.                 others   => False
    69.                );
    70.
    71.    procedure perform (action : in plotter.command; stream : in out host_IO.stream);
    72.
    73. end plotter;

 202 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-dr-tsd_outs.adb
Source file time stamp: 2021-01-30 01:39:36
Compiled at: 2021-02-08 17:21:02

     1. -- Implement the drum API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with HCI;
    18. with IOC.dispatcher;
    19. with KDF9.TSD;
    20. with tracing;
    21.
    22. use  HCI;
    23. use  IOC.dispatcher;
    24. use  KDF9.TSD;
    25. use  tracing;
    26.
    27. package body IOC.fast.DR.TSD_OUTs is
    28.
    29.    OUT13_was_done          : Boolean   := False;
    30.    last_reserved_DR_sector : KDF9.word := -1;
    31.
    32.    procedure free_any_reserved_drum_space is
    33.    begin
    34.       OUT13_was_done := False;
    35.       last_reserved_DR_sector := -1;
    36.    end free_any_reserved_drum_space;
    37.
    38.    Q : KDF9.Q_register;
    39.    W : KDF9.word;
    40.
    41.    procedure access_the_OUT_operand is
    42.    begin
    43.       ensure_that_the_nest_holds_an_operand;
    44.       W := pop;
    45.       Q := as_Q(W);
    46.       the_trace_operand := W;
    47.     end access_the_OUT_operand;
    48.
    49.    procedure ensure_that_DR0_is_enabled (OUT_number : in KDF9.word) is
    50.    begin
    51.       if not DR0_is_enabled then
    52.          trap_failing_OUT(OUT_number, "there is no drum in this configuration");
    53.       end if;
    54.    end ensure_that_DR0_is_enabled;
    55.
    56.    procedure formulate_the_drum_transfer_operand (OUT_number : in KDF9.word) is
    57.       S : KDF9.word;
    58.    begin
    59.       ensure_that_DR0_is_enabled(OUT_number);
    60.       if not OUT13_was_done then
    61.          trap_failing_OUT(OUT_number, "obeyed before OUT 13");
    62.       end if;
    63.       S := KDF9.word(Q.C + (Q.M - Q.I + bytes_per_sector/2) / bytes_per_sector);
    64.       if S > last_reserved_DR_sector then
    65.          trap_failing_OUT(OUT_number, "too many drum sectors would be transferred");
    66.       end if;
    67.       Q := (Q.C*16 + DR0_number, Q.I, Q.M);
    68.       the_trace_operand := as_word(Q);
    69.    end formulate_the_drum_transfer_operand;
    70.
    71.    procedure do_OUT_11 is
    72.    begin
    73.       access_the_OUT_operand;
    74.       formulate_the_drum_transfer_operand(11);
    75.       restore_the_IO_OUT_operands(11, W);
    76.          POA(Q, False);
    77.       remove_the_IO_OUT_operands;
    78.    end do_OUT_11;
    79.
    80.    procedure do_OUT_12 is
    81.    begin
    82.       access_the_OUT_operand;
    83.       formulate_the_drum_transfer_operand(12);
    84.       restore_the_IO_OUT_operands(12, W);
    85.          PIA(Q, False);
    86.       remove_the_IO_OUT_operands;
    87.    end do_OUT_12;
    88.
    89.    procedure do_OUT_13 is
    90.    begin
    91.       access_the_OUT_operand;
    92.       ensure_that_DR0_is_enabled(13);
    93.       if OUT13_was_done then
    94.          trap_failing_OUT(13, "obeyed a second time");
    95.       end if;
    96.       if W > sectors_per_system or else
    97.             W = 0                  then
    98.          trap_failing_OUT(13, "demands an impossible number of drum sectors");
    99.       end if;
   100.       last_reserved_DR_sector := W - 1;
   101.       OUT13_was_done := True;
   102.       set_state_of(buffer(DR0_number), allocated => True);
   103.       log_API_message("OUT 13: allocated" & W'Image & " drum sectors");
   104.    end do_OUT_13;
   105.
   106.    procedure do_OUT_14 is
   107.    begin
   108.       -- I assume that the drum never experiences a parity error in ee9.
   109.       ensure_that_DR0_is_enabled(14);
   110.       if OUT13_was_done then
   111.          the_trace_operand := (sectors_per_system - last_reserved_DR_sector - 1) or 2**47;
   112.       else
   113.          the_trace_operand := sectors_per_system;
   114.       end if;
   115.       push(the_trace_operand);
   116.    end do_OUT_14;
   117.
   118. end IOC.fast.DR.TSD_OUTs;

Compiling: ../Source/ioc-fast-dr-tsd_outs.ads
Source file time stamp: 2021-01-15 23:39:18
Compiled at: 2021-02-08 17:21:02

     1. -- Implement the drum API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.DR.TSD_OUTs is
    18.
    19.    procedure do_OUT_11;
    20.
    21.    procedure do_OUT_12;
    22.
    23.    procedure do_OUT_13;
    24.
    25.    procedure do_OUT_14;
    26.
    27.    procedure free_any_reserved_drum_space;
    28.
    29. end IOC.fast.DR.TSD_OUTs;

 118 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-fd-tsd_outs.adb
Source file time stamp: 2021-02-04 01:26:44
Compiled at: 2021-02-08 17:21:02

     1. -- Implement the fixed disc API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with HCI;
    18. with IOC.dispatcher;
    19. with KDF9.TSD;
    20. with tracing;
    21.
    22. use  HCI;
    23. use  IOC.dispatcher;
    24. use  KDF9.TSD;
    25. use  tracing;
    26.
    27. package body IOC.fast.FD.TSD_OUTs is
    28.
    29.    -- See the Manual, Appendix 6, §2 for the TSD FD OUTs.
    30.
    31.    claimable_discs              : constant := 8;
    32.    sectors_per_logical_block    : constant := 16;
    33.    logical_blocks_per_seek_area : constant := sectors_per_seek_area / sectors_per_logical_block;
    34.    logical_blocks_per_platter   : constant := seek_areas_per_platter * logical_blocks_per_seek_area;
    35.    sectors_per_platter          : constant := sectors_per_logical_block * logical_blocks_per_platter;
    36.
    37.    type reserved_disc_set is
    38.       record
    39.          claimed : Boolean := False;
    40.          size    : KDF9.Q_part range 0 .. claimable_discs;
    41.          sectors : KDF9.Q_part range 0 .. claimable_discs * sectors_per_platter;
    42.          start   : KDF9.Q_part range 0 .. claimable_discs;
    43.       end record;
    44.
    45.    disc_set             : array (KDF9.Q_part range 1 .. 2) of reserved_disc_set;
    46.    disc_sets_claimed    : KDF9.Q_part range 0 .. 2 := 0;
    47.    current_disc_set     : KDF9.Q_part range 1 .. 2;
    48.    discs_claimed_so_far : KDF9.Q_part := 0;
    49.
    50.    procedure free_any_reserved_disc_space is
    51.    begin
    52.       disc_sets_claimed := 0;
    53.       discs_claimed_so_far := 0;
    54.    end free_any_reserved_disc_space;
    55.
    56.    function FD_seek_parameter (OUT_number: KDF9.word; Q : KDF9.Q_register)
    57.    return KDF9.Q_register is
    58.       current_set : reserved_disc_set renames disc_set(current_disc_set);
    59.       block       : constant KDF9.Q_part := Q.C / sectors_per_logical_block;
    60.       seek_area   : constant KDF9.Q_part := block  /  (6 * current_set.size);
    61.       residue     : constant KDF9.Q_part := block mod (6 * current_set.size);
    62.       disc        : constant KDF9.Q_part := residue / 6 + current_set.start;
    63.       drive       : constant KDF9.Q_part := 0;  -- ee9 will reserve discs on drive 0 only.
    64.       parameter   : constant KDF9.Q_part
    65.                   := drive * seek_areas_per_platter * main_discs_per_drive
    66.                    + disc  * seek_areas_per_platter
    67.                    + seek_area;
    68.    begin
    69.       if Q.C >= disc_set(current_disc_set).sectors then
    70.          trap_failing_OUT(OUT_number, Q.C'Image & " exceeds the sector capacity of the selected set");
    71.       end if;
    72.       return (parameter * 16 + FD0_number,  Q.I, Q.M);
    73.    end FD_seek_parameter;
    74.
    75.    function FD_xfer_parameter (Q : KDF9.Q_register)
    76.    return KDF9.Q_register is
    77.       sector : constant KDF9.Q_part := Q.C mod 96;
    78.    begin
    79.       return (sector * 16 + FD0_number, Q.I, Q.M);
    80.    end FD_xfer_parameter;
    81.
    82.    Q : KDF9.Q_register;
    83.    W : KDF9.word;
    84.
    85.    procedure ensure_that_FD0_is_enabled (OUT_number : in KDF9.word) is
    86.    begin
    87.       if not FD0_is_enabled then
    88.          trap_failing_OUT(OUT_number, "there is no disc in this configuration");
    89.       end if;
    90.    end ensure_that_FD0_is_enabled;
    91.
    92.    procedure access_the_operand is
    93.    begin
    94.       ensure_that_the_nest_holds_an_operand;
    95.       W := pop;
    96.       Q := as_Q(W);
    97.       the_trace_operand := W;
    98.    end access_the_operand;
    99.
   100.    procedure do_OUT_41 is
   101.       F       : KDF9.Q_part;
   102.       seek_Q,
   103.       write_Q : KDF9.Q_register;
   104.    begin
   105.       access_the_operand;
   106.       ensure_that_FD0_is_enabled(41);
   107.       if disc_sets_claimed = 0 then
   108.          trap_failing_OUT(41, "tries to write to FD0 with no discs reserved");
   109.       end if;
   110.       W := KDF9.word(Q.C) / 16;
   111.       F := Q.C mod 16 + (Q.M - Q.I + words_per_sector - 1)/words_per_sector;
   112.       if F >= sectors_per_logical_block then
   113.          trap_failing_OUT(41, "tries to write past the end of a logical block on FD0");
   114.       end if;
   115.       seek_Q  := FD_seek_parameter(41, Q);
   116.       write_Q := FD_xfer_parameter(Q);
   117.       the_trace_operand := as_word(write_Q);
   118.       restore_the_IO_OUT_operands(42, W);
   119.          PMA(seek_Q, False);
   120.          POA(write_Q, False);
   121.       remove_the_IO_OUT_operands;
   122.    end do_OUT_41;
   123.
   124.    procedure do_OUT_42 is
   125.       F      : KDF9.Q_part;
   126.       seek_Q,
   127.       read_Q : KDF9.Q_register;
   128.    begin
   129.       access_the_operand;
   130.       ensure_that_FD0_is_enabled(42);
   131.       if disc_sets_claimed = 0 then
   132.          trap_failing_OUT(42, "tries to read from FD0 with no discs reserved");
   133.       end if;
   134.       W := KDF9.word(Q.C) / 16;
   135.       F := Q.C mod 16 + (Q.M - Q.I + words_per_sector - 1)/words_per_sector;
   136.       if F >= sectors_per_logical_block then
   137.          trap_failing_OUT(42, "tries to read past the end of a logical block on FD0");
   138.       end if;
   139.       seek_Q := FD_seek_parameter(41, Q);
   140.       read_Q := FD_xfer_parameter(Q);
   141.       the_trace_operand := as_word(read_Q);
   142.       restore_the_IO_OUT_operands(42, W);
   143.          PMA(seek_Q, False);
   144.          PIA(read_Q, False);
   145.       remove_the_IO_OUT_operands;
   146.    end do_OUT_42;
   147.
   148.    procedure do_OUT_43 is
   149.       F : KDF9.Q_part;
   150.    begin
   151.       access_the_operand;
   152.       ensure_that_FD0_is_enabled(43);
   153.       if disc_sets_claimed = 0 then
   154.          trap_failing_OUT(43, "no FD0 discs have been reserved yet");
   155.       end if;
   156.       if W not in 0 | -1 then
   157.          trap_failing_OUT(43, "tries to select an impossible set of discs");
   158.       end if;
   159.       F := as_Q(-W).M + 1;
   160.       if F > disc_sets_claimed then
   161.          trap_failing_OUT(43, "tries to select an unreserved FD0 disc set");
   162.       end if;
   163.       current_disc_set := as_Q(-the_trace_operand).M + 1;
   164.    end do_OUT_43;
   165.
   166.    procedure do_OUT_44 is
   167.       F : KDF9.Q_part;
   168.    begin
   169.       access_the_operand;
   170.       ensure_that_FD0_is_enabled(44);
   171.       if disc_sets_claimed = 2 then
   172.          trap_failing_OUT(44, "tries to reserve more than two sets of FD0 discs");
   173.       end if;
   174.       F := as_Q(W).M;
   175.       if W not in 1..claimable_discs                        or else
   176.             discs_claimed_so_far + F not in 1..claimable_discs then
   177.          trap_failing_OUT(44, "tries to reserve more than 8 FD0 discs");
   178.       end if;
   179.       current_disc_set := disc_sets_claimed + 1;
   180.       disc_set(current_disc_set).claimed := True;
   181.       disc_set(current_disc_set).size := F;
   182.       disc_set(current_disc_set).sectors := F * sectors_per_platter;
   183.       disc_set(current_disc_set).start := discs_claimed_so_far;
   184.       discs_claimed_so_far := discs_claimed_so_far + F;
   185.       disc_sets_claimed := disc_sets_claimed + 1;
   186.       log_API_message(
   187.                       "OUT 44: reserved"
   188.                     & F'Image
   189.                     & " FD0 disc"
   190.                     & plurality(KDF9.word(F))
   191.                     & " in set"
   192.                     & current_disc_set'Image
   193.                      );
   194.       set_state_of(buffer(FD0_number), allocated => True);
   195.    end do_OUT_44;
   196.
   197.    procedure do_OUT_45 is
   198.       F : KDF9.Q_part;
   199.    begin
   200.       access_the_operand;
   201.       ensure_that_FD0_is_enabled(45);
   202.       if disc_sets_claimed = 0 then
   203.          trap_failing_OUT(45, "tries to release an unreserved set of FD0 discs");
   204.       end if;
   205.       if W not in 0 | -1 then
   206.          trap_failing_OUT(45, "tries to release an unknown set of FD0 discs");
   207.       end if;
   208.       F := as_Q(-W).M + 1;
   209.       if F > disc_sets_claimed then
   210.          trap_failing_OUT(45, "tries to release more FD0 disc sets than are reserved");
   211.       end if;
   212.       log_API_message(
   213.                       "OUT 45: released"
   214.                     & disc_set(F).size'Image
   215.                     & " FD0 disc"
   216.                     & plurality(KDF9.word(disc_set(F).size))
   217.                     & " from set"
   218.                     & F'Image
   219.                      );
   220.       discs_claimed_so_far := discs_claimed_so_far - disc_set(F).size;
   221.       current_disc_set := 1;
   222.       disc_sets_claimed := disc_sets_claimed - 1;
   223.       if F = 1 then
   224.          disc_set(1) := disc_set(2);
   225.          disc_set(2).claimed := False;
   226.       end if;
   227.    end do_OUT_45;
   228.
   229.    procedure do_OUT_47 is
   230.    begin
   231.       the_trace_operand := pop;
   232.       -- I assume that disc transfer parity errors never occur under ee9.
   233.       ensure_that_FD0_is_enabled(47);
   234.       if disc_sets_claimed = 0 then
   235.          trap_failing_OUT(47, "tries to check a transfer on unreserved FD0 discs");
   236.       end if;
   237.    end do_OUT_47;
   238.
   239. end IOC.fast.FD.TSD_OUTs;

Compiling: ../Source/ioc-fast-fd-tsd_outs.ads
Source file time stamp: 2021-01-15 23:38:42
Compiled at: 2021-02-08 17:21:02

     1. -- Implement the fixed disc API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.FD.TSD_OUTs is
    18.
    19.    -- See the Manual, Appendix 6, §2 for the TSD FD OUTs.
    20.
    21.    procedure do_OUT_41;
    22.
    23.    procedure do_OUT_42;
    24.
    25.    procedure do_OUT_43;
    26.
    27.    procedure do_OUT_44;
    28.
    29.    procedure do_OUT_45;
    30.
    31.    procedure do_OUT_47;
    32.
    33.    procedure free_any_reserved_disc_space;
    34.
    35. end IOC.fast.FD.TSD_OUTs;

 239 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-mt-tsd_outs.adb
Source file time stamp: 2021-01-10 23:52:36
Compiled at: 2021-02-08 17:21:02

     1. -- Emulation of magnetic tape decks and buffers.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with HCI;
    18. with tracing;
    19.
    20. use  HCI;
    21. use  tracing;
    22.
    23. package body IOC.fast.MT.TSD_OUTs is
    24.
    25.    type short_label is new String(1 .. 8);
    26.    type long_label  is new String(1 .. 16);
    27.
    28.    function needs_rewinding (b : KDF9.buffer_number)
    29.    return Boolean is
    30.       the_deck : MT.deck renames MT.deck(buffer(b).all);
    31.    begin
    32.       return the_deck.is_open and then the_deck.tape.position > 0;
    33.    end needs_rewinding;
    34.
    35.    procedure do_OUT_4 is
    36.       B : KDF9.Q_part;
    37.       W : KDF9.word;
    38.    begin
    39.       ensure_that_the_nest_holds_an_operand;
    40.       W := pop;
    41.       declare
    42.          label : constant short_label := short_label(to_string(W));
    43.       begin
    44.          find_tape(MT.data_storage(label), B, W);  -- W is not actually used in OUT 4
    45.          push(KDF9.word(B));
    46.          the_trace_operand := KDF9.word(B);
    47.          if W = 0 then
    48.             log_API_message("OUT 4: requested a scratch tape and got '"
    49.                           & device_name_of(buffer(B).all)
    50.                           & "' with TSN '"
    51.                           & to_string(W)
    52.                           & "'"
    53.                            );
    54.          else
    55.             log_API_message("OUT 4: requested a tape labelled '"
    56.                           & String(label)
    57.                           & "' and got "
    58.                           & device_name_of(buffer(B).all)
    59.                           & " with TSN '"
    60.                           & to_string(W)
    61.                           & "'"
    62.                            );
    63.          end if;
    64.       end;
    65.       set_state_of(buffer(B), allocated => True);
    66.    end do_OUT_4;
    67.
    68.    procedure do_OUT_10 is
    69.       B : KDF9.Q_part;
    70.       P : KDF9.pair;
    71.       W : KDF9.word;
    72.    begin
    73.       ensure_that_the_nest_holds_2_operands;
    74.       P := pop;
    75.       declare
    76.          label : constant long_label := long_label(to_string(P));
    77.       begin
    78.          find_tape(MT.data_storage(label), B, W);
    79.          push(W);
    80.          push(KDF9.word(B));
    81.          the_trace_operand := KDF9.word(B);
    82.          log_API_message("OUT 10: requested a tape labelled '"
    83.                        & String(label)
    84.                        & "' and got "
    85.                        & device_name_of(buffer(B).all)
    86.                        & " with TSN '"
    87.                        & to_string(W)
    88.                        & "'"
    89.                         );
    90.       end;
    91.       set_state_of(buffer(B), allocated => True);
    92.    end do_OUT_10;
    93.
    94. end IOC.fast.MT.TSD_OUTs;

Compiling: ../Source/ioc-fast-mt-tsd_outs.ads
Source file time stamp: 2021-01-10 23:52:36
Compiled at: 2021-02-08 17:21:02

     1. -- Implement the magnetic tape API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.MT.TSD_OUTs is
    18.
    19.    procedure do_OUT_4;
    20.
    21.    procedure do_OUT_10;
    22.
    23.    function needs_rewinding (b : KDF9.buffer_number)
    24.    return Boolean;
    25.
    26. end IOC.fast.MT.TSD_OUTs;

 94 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd-peripherals.adb
Source file time stamp: 2021-02-08 01:19:15
Compiled at: 2021-02-08 17:21:02

     1. -- Implement OUTs 5, 6 and 7 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with exceptions;
    18. with formatting;
    19. with HCI;
    20. with IOC;
    21. with IOC.equipment;
    22. with IOC.fast.MT.TSD_OUTs;
    23. with IOC.slow.shift.SI;
    24. with IOC.slow.shift.TR;
    25. with KDF9_char_sets;
    26. with KDF9.store;
    27. with settings;
    28. with state_display;
    29. with tracing;
    30.
    31. use  exceptions;
    32. use  formatting;
    33. use  HCI;
    34. use  IOC;
    35. use  IOC.equipment;
    36. use  IOC.fast.MT.TSD_OUTs;
    37. use  IOC.slow.shift.SI;
    38. use  IOC.slow.shift.TR;
    39. use  KDF9_char_sets;
    40. use  KDF9.store;
    41. use  settings;
    42. use  state_display;
    43. use  tracing;
    44.
    45. package body KDF9.TSD.peripherals is
    46.
    47.    -- is_free_for_explicit_allocation keeps a note of explicitly requested allocations by OUT 5.
    48.    -- Implicit allocations by OUT 8 are done to prevent spurious LIVs on the output devices,
    49.    --    but they must not cause explicit reservations by OUT 5 to fail.
    50.
    51.    is_free_for_explicit_allocation : array(KDF9.buffer_number) of Boolean := (others => True);
    52.    is_implicitly_allocated_to_OUT8 : array(KDF9.buffer_number) of Boolean := (others => False);
    53.
    54.    procedure free_all_devices is
    55.    begin
    56.       is_free_for_explicit_allocation := (others => True);
    57.       is_implicitly_allocated_to_OUT8 := (others => False);
    58.       for b in KDF9.buffer_number loop
    59.          set_state_of(buffer(b), allocated => False);
    60.       end loop;
    61.       --  Keep FW0 online.
    62.       set_state_of(buffer(0), allocated => True);
    63.    end free_all_devices;
    64.
    65.    procedure let_OUT_8_use_the_device_on_buffer (B : in KDF9.buffer_number) is
    66.    begin
    67.       is_implicitly_allocated_to_OUT8(B) := True;
    68.       set_state_of(buffer(B), allocated => True);
    69.    end let_OUT_8_use_the_device_on_buffer;
    70.
    71.    -- These are the device-type codes to be given when requesting
    72.    --    the allocation of a peripheral with TSD OUT 5,
    73.    --       according to the Manual and the document:
    74.    --          "Service Routine Library Manual" §22.13, p22-28-0.
    75.
    76.    FW_OUT5_code : constant := 0;
    77.    TP_OUT5_code : constant := 1;
    78.    TR_OUT5_code : constant := 2;
    79.    LP_OUT5_code : constant := 3;
    80.    CR_OUT5_code : constant := 4;
    81.    FP_OUT5_code : constant := 5;      -- Ferranti 5-channel Tape punch
    82.    CP_OUT5_code : constant := 7;
    83.    GP_OUT5_code : constant := 8#20#;
    84.    SI_OUT5_code : constant := 8#21#;  -- Standard Interface, "Data Link, N.P.L. Special Buffer"
    85.    FE_OUT5_code : constant := 8#65#;  -- Tape buffer link for PDP-8 on Eldon2, and perhaps COTAN
    86.    UT_OUT5_code : constant := 8#67#;  -- Unlabelled Tape
    87.
    88.    procedure select_the_next_device_from_among
    89.       (device_A, device_B : in  KDF9.buffer_number;
    90.        chosen_device      : out KDF9.buffer_number;
    91.        wanted_type        : in String := "") is
    92.    begin
    93.       if device_A /= 0                            and then
    94.             is_free_for_explicit_allocation(device_A) then
    95.          chosen_device := device_A;
    96.       elsif device_B /= 0                         and then
    97.             is_free_for_explicit_allocation(device_B) then
    98.          chosen_device := device_B;
    99.       else
   100.          trap_failing_OUT(5, "there is no available device of type " & wanted_type);
   101.       end if;
   102.    end select_the_next_device_from_among;
   103.
   104.    procedure allocate_a_device is
   105.       B : KDF9.buffer_number;
   106.       W : KDF9.word;
   107.    begin
   108.       ensure_that_the_nest_holds_an_operand;
   109.       W := read_top;
   110.
   111.       case W is
   112.          -- 8 was added to the code to pre-allocate a device.
   113.          -- I treat pre-allocating and allocating the same way here.
   114.          when FW_OUT5_code
   115.             | FW_OUT5_code+8 =>
   116.             B := 0;  -- Always allowed, no checking performed.
   117.          when TP_OUT5_code
   118.             | TP_OUT5_code+8
   119.             | FP_OUT5_code
   120.             | FP_OUT5_code+8 =>
   121.             select_the_next_device_from_among(TP0_number, TP1_number, B, "TP");
   122.          when TR_OUT5_code
   123.             | TR_OUT5_code+8 =>
   124.             -- TR0 is used for reading the bootstrap/problem program in KDF9 code.
   125.             -- When there is Latin-1 data it therefore needs to go in via TR1.
   126.             -- N.B. the TR devices must appear in this order.
   127.             select_the_next_device_from_among(TR1_number, TR0_number, B, "TR");
   128.             set_case(IOC.slow.shift.TR.device(buffer(B).all));
   129.          when LP_OUT5_code
   130.             | LP_OUT5_code+8 =>
   131.             select_the_next_device_from_among(LP0_number, LP1_number, B, "LP");
   132.          when CR_OUT5_code
   133.             | CR_OUT5_code+8 =>
   134.             select_the_next_device_from_among(CR0_number, CR1_number, B, "CR");
   135.          when CP_OUT5_code
   136.             | CP_OUT5_code+8 =>
   137.             select_the_next_device_from_among(CP0_number, CP1_number, B, "CP");
   138.          when GP_OUT5_code
   139.             | GP_OUT5_code+8 =>
   140.             -- There is only 1 graph plotter.
   141.             select_the_next_device_from_among(GP0_number, GP0_number, B, "GP");
   142.          when SI_OUT5_code =>
   143.             if SI0_is_enabled then
   144.                select_the_next_device_from_among(SI0_number, SI1_number, B, "SI");
   145.             else
   146.                trap_failing_OUT(5, "the SI buffer has not been enabled");
   147.             end if;
   148.          when FE_OUT5_code =>
   149.             trap_unimplemented_feature("PDP-8 Front End Tape buffers");
   150.          when UT_OUT5_code =>
   151.             trap_unimplemented_feature("Unlabelled Tape buffers");
   152.          when others =>
   153.             trap_failing_OUT(5, "unknown device type #" & oct_of(W));
   154.       end case;
   155.
   156.       is_free_for_explicit_allocation(B) := False;
   157.       set_state_of(buffer(B), allocated => True);
   158.
   159.       pop;
   160.       push(KDF9.word(B));
   161.       the_trace_operand := KDF9.word(B);
   162.
   163.       if buffer(B).all in IOC.slow.shift.device'Class and then
   164.             buffer(B).kind /= GP_kind                     then
   165.          log_API_message("OUT 5: requested a device of type #"
   166.                        & oct_of(KDF9.Q_part(W), 2)
   167.                        & " and got "
   168.                        & device_name_of(buffer(B).all)
   169.                        & " on buffer #"
   170.                        & oct_of(B, 2)
   171.                        & ", using "
   172.                        & (
   173.                           if IOC.slow.shift.device(buffer(B).all).uses_Latin_1 then
   174.                              "Latin-1"
   175.                           else
   176.                              "KDF9"
   177.                          )
   178.                        & " code"
   179.                         );
   180.       else
   181.          log_API_message("OUT 5: requested a device of type #"
   182.                        & oct_of(KDF9.Q_part(W), 2)
   183.                        & " and got "
   184.                        & device_name_of(buffer(B).all)
   185.                        & " on buffer #"
   186.                        & oct_of(B, 2)
   187.                         );
   188.       end if;
   189.    end allocate_a_device;
   190.
   191.    procedure free_the_device_on_buffer (B : in KDF9.buffer_number; OUT_number : in KDF9.word) is
   192.    begin
   193.       if buffer(B).kind in MT_kind | ST_kind then
   194.          if needs_rewinding(b) then
   195.             PMD(buffer(B).all, KDF9.Q_register'(B, 0, 0), set_offline => (OUT_number = 6));
   196.          end if;
   197.       elsif OUT_number = 7 then
   198.          trap_failing_OUT(7, "device #" & oct_of(B, 2) & ", is not a tape deck");
   199.       end if;
   200.       is_free_for_explicit_allocation(B) := True;
   201.       set_state_of(buffer(B), allocated => is_implicitly_allocated_to_OUT8(B));
   202.       log_API_message("OUT" & OUT_number'Image & ": released " & device_name_of(buffer(B).all));
   203.    end free_the_device_on_buffer;
   204.
   205.    procedure deallocate_a_device (OUT_number : in KDF9.word) is
   206.       B : KDF9.Q_part;
   207.    begin
   208.       ensure_that_the_nest_holds_an_operand;
   209.       the_trace_operand := pop;
   210.       if the_trace_operand > 15 then
   211.          notify_state_display_of_final_ICR;
   212.          trap_failing_OUT(OUT_number, "#" & oct_of(the_trace_operand) & " is not a valid buffer number");
   213.       end if;
   214.       B := KDF9.buffer_number(the_trace_operand);
   215.       if is_unallocated(buffer(B)) then
   216.          trap_failing_OUT(OUT_number, "device #" & oct_of(B, 2) & " is not allocated to this program");
   217.       end if;
   218.       free_the_device_on_buffer(B, OUT_number);
   219.    end deallocate_a_device;
   220.
   221.    procedure do_OUT_5 is
   222.    begin
   223.       allocate_a_device;
   224.    end do_OUT_5;
   225.
   226.    procedure do_OUT_6 is
   227.    begin
   228.       deallocate_a_device(OUT_number => 6);
   229.    end do_OUT_6;
   230.
   231.    procedure do_OUT_7 is
   232.    begin
   233.       deallocate_a_device(OUT_number => 7);
   234.    end do_OUT_7;
   235.
   236.
   237. end KDF9.TSD.peripherals;

Compiling: ../Source/kdf9-tsd-peripherals.ads
Source file time stamp: 2021-01-19 10:26:59
Compiled at: 2021-02-08 17:21:02

     1. -- Implement 5, 6 and 7 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.peripherals is
    18.
    19.    procedure do_OUT_5;
    20.
    21.    procedure do_OUT_6;
    22.
    23.    procedure do_OUT_7;
    24.
    25.    procedure let_OUT_8_use_the_device_on_buffer (B : in KDF9.buffer_number);
    26.
    27.    procedure free_all_devices;
    28.
    29.    procedure free_the_device_on_buffer (B : in KDF9.buffer_number; OUT_number : in KDF9.word);
    30.
    31. end KDF9.TSD.peripherals;

 237 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd-spooling.adb
Source file time stamp: 2021-02-07 23:40:19
Compiled at: 2021-02-08 17:21:02

     1. -- Implement a subset of the Time Sharing Director's OUT 8 / OUT 16 spooling API.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with formatting;
    18. with IOC;
    19. with IOC.dispatcher;
    20. with IOC.equipment;
    21. with IOC.slow.shift.FW;
    22. with KDF9_char_sets;
    23. with KDF9.store;
    24. with KDF9.TSD.peripherals;
    25. with tracing;
    26.
    27. use  formatting;
    28. use  IOC;
    29. use  IOC.dispatcher;
    30. use  IOC.equipment;
    31. use  IOC.slow.shift.FW;
    32. use  KDF9_char_sets;
    33. use  KDF9.store;
    34. use  KDF9.TSD.peripherals;
    35. use  tracing;
    36.
    37. package body KDF9.TSD.spooling is
    38.
    39.    procedure do_IO (this_OUT : in KDF9.word) is
    40.
    41.       function destination_device_for (the_stream : KDF9.word)
    42.       return IOC.device_number is
    43.          data_word  : constant String(1..16) := oct_of(the_stream);
    44.          the_device : IOC.device_number;
    45.          the_type   : String(1..2);
    46.       begin
    47.          case the_stream is
    48.             when 8#00# =>
    49.                return 0;
    50.             when 8#10# |8#12# |8#14# | 8#16# =>
    51.                the_device := TP0_number; the_type := "TP";
    52.             when 8#11# |8#13# |8#15# | 8#17# =>
    53.                the_device := TP1_number; the_type := "TP";
    54.             when 8#30#..8#37# =>
    55.                the_device := LP0_number; the_type := "LP";
    56.             when 8#50#..8#57# =>
    57.                the_device := TP1_number; the_type := "TP";
    58.             when 8#70#..8#77# =>
    59.                the_device := LP0_number; the_type := "LP";
    60.             when others =>
    61.                trap_failing_OUT(8, "invalid stream #" & data_word);
    62.          end case;
    63.          if the_device = 0 then
    64.             trap_operator_error("OUT 8 needs a " & the_type & " for stream #" & data_word(15..16));
    65.          end if;
    66.          return the_device;
    67.       end destination_device_for;
    68.
    69.       W, the_stream : KDF9.word;
    70.       Q, G    : KDF9.Q_register;
    71.
    72.       procedure prepare_output_to_FW0 is
    73.          message_prefix  : constant KDF9.word := 8#02_06_21_55_22_00_07_77#; -- LS CS [ m ] SP CN Ø
    74.          prompt_prefix   : constant KDF9.word := 8#02_06_21_61_22_00_07_77#; -- LS CS [ q ] SP CN Ø
    75.          OUT_16_prefix   : constant KDF9.word := 8#02_07_56_33_00_77_77_77#; -- LS CN N º SP Ø  Ø Ø
    76.          filler_in_D0_D5 : constant KDF9.word := 8#77_00_00_00_00_00_00_00#; -- Ø
    77.          S               : KDF9_char_sets.symbol := KDF9_char_sets.Word_Filler;
    78.          the_prefix      : KDF9.word;
    79.       begin  -- prepare_output_to_FW0
    80.          -- The logic of FW streams is rather complex, to preserve the layout of the typescript.
    81.          -- There are three significant aspects.
    82.
    83.          -- 1. The message is truncated if longer than 8 words.
    84.          if Q.M - Q.I > 8 then
    85.             Q.M := Q.I + 8;
    86.          end if;
    87.
    88.          -- 2. It must not contain LS or HT;
    89.          --       nor ';' in the last word;
    90.          --          nor ';' other than in character position 7;
    91.          --    but anything after an End Message can safely be ignored.
    92.          word_loop: for w in Q.I+1 .. Q.M loop
    93.              for c in KDF9_char_sets.symbol_index'Range loop
    94.                 S := fetch_symbol(w, c);
    95.                 if S = KDF9_char_sets.Line_Shift                                 or else
    96.                       S = KDF9_char_sets.Tabulation                              or else
    97.                          ((S = KDF9_char_sets.Semi_Colon) and (c /= 7 or  w = Q.M)) then
    98.                    trap_failing_OUT(this_OUT, "invalid data for OUT 8 to FW");
    99.                 end if;
   100.          exit word_loop when S = KDF9_char_sets.Semi_Colon or S = KDF9_char_sets.End_Message;
   101.              end loop;
   102.          end loop word_loop;
   103.
   104.          the_prefix := (if S = KDF9_char_sets.Semi_Colon then prompt_prefix else message_prefix);
   105.          the_prefix := (if this_OUT = 16                 then OUT_16_prefix else the_prefix);
   106.
   107.          -- 3. Take a new line for each OUT 8 message to the FW.
   108.          --    Set up the format effector(s) in the first word of the OUT 8 area.
   109.          declare
   110.             package FW renames IOC.slow.shift.FW;
   111.             the_FW : FW.device renames FW.device(buffer(0).all);
   112.          begin
   113.             if a_LF_was_just_read(the_FW) then
   114.                -- Replace the redundant Line Shift with a Word Filler character.
   115.                store_word(the_prefix or filler_in_D0_D5, Q.I);
   116.             else
   117.                -- The initial Line Shift is needed.
   118.                store_word(the_prefix, Q.I);
   119.             end if;
   120.          end;
   121.       end prepare_output_to_FW0;
   122.
   123.       page_change : constant := 8#77_77_77_77_77_77_77_03#;  --  LP Page Change character
   124.
   125.    begin  -- do_IO
   126.       ensure_that_the_nest_holds_an_operand;
   127.       W := pop;
   128.       Q := as_Q(W);
   129.       the_trace_operand := W;
   130.
   131.       -- A FW query has (only) D0 of the control word set.
   132.       if (Q.C and 8#1_00000#) /= 0 then
   133.          Q.C := 0;
   134.       end if;
   135.
   136.       if Q.C = Q.I and Q.I = Q.M then
   137.          -- The N2 parameter specifies stream closure.
   138.          flush(buffer(destination_device_for(KDF9.word(Q.C))).all);
   139.          return;
   140.       end if;
   141.
   142.       --
   143.       -- This must precede anything that might LOV, e.g. store accesses and I/O orders.
   144.       --
   145.       restore_the_IO_OUT_operands(this_OUT, W);
   146.       --
   147.       --
   148.       --
   149.
   150.       -- The (Q, from N2) parameter specifies a block starting with the stream number.
   151.       check_address_and_lockout(Q.I);
   152.       the_stream := fetch_word(Q.I);
   153.
   154.       Q.C := destination_device_for(the_stream);
   155.       let_OUT_8_use_the_device_on_buffer(Q.C);
   156.
   157.       check_address_and_lockout(Q.I+1);
   158.       G := as_Q(fetch_word(Q.I+1));
   159.
   160.       -- See the Manual, §12.6.1.
   161.       if G.C = 4095 and then G.I = 8#177777# then
   162.          -- The G parameter specifies output of a 'gap' suitable for the device.
   163.          if G.M = 0 then
   164.             -- Do nothing.
   165.             the_trace_operand := as_word(G);
   166.          elsif destination_device_for(the_stream) in TP0_number | TP1_number then
   167.             -- Write runout according to the character set mode of the punch.
   168.             G.M := (if G.M in 1 .. 511 then G.M else 120);
   169.             Q := (Q.C, 0, G.M);
   170.             the_trace_operand := as_word(Q);
   171.             POE(Q, False);
   172.          elsif destination_device_for(the_stream) = LP0_number then
   173.              -- Write a Page Change.
   174.             store_word(page_change, Q.I);
   175.             Q := (Q.C, Q.I, Q.I);
   176.             the_trace_operand := as_word(Q);
   177.             POA(Q, False);
   178.          end if;
   179.
   180.          --
   181.          --
   182.          remove_the_IO_OUT_operands;
   183.          --
   184.          --
   185.
   186.          return;
   187.       end if;
   188.
   189.       if Q.M <= Q.I then
   190.          trap_failing_OUT(8, "invalid end-address #" & oct_of(Q.M));
   191.       end if;
   192.
   193.       if Q.C = 0 then
   194.          -- The logic for FW streams is more complex, to preserve the layout of the typescript.
   195.          prepare_output_to_FW0;
   196.       else
   197.          -- For non-FW streams, the first word of the OUT 8 area is not transferred.
   198.          Q.I := Q.I + 1;
   199.       end if;
   200.       the_trace_operand := as_word(Q);
   201.
   202.       POB(Q, False);
   203.
   204.       --
   205.       --
   206.       remove_the_IO_OUT_operands;
   207.       --
   208.       --
   209.
   210.    end do_IO;
   211.
   212.    procedure do_OUT_8 is
   213.    begin
   214.       do_IO(this_OUT => 8);
   215.    end do_OUT_8;
   216.
   217.    procedure do_OUT_16 is
   218.    begin
   219.       do_IO(this_OUT => 16);
   220.    end do_OUT_16;
   221.
   222. end KDF9.TSD.spooling;

Compiling: ../Source/kdf9-tsd-spooling.ads
Source file time stamp: 2021-01-19 10:07:30
Compiled at: 2021-02-08 17:21:02

     1. -- Implement a subset of the Time Sharing Director's OUT 8 / OUT 16 spooling API.
     2. --
     3. -- This file is part of ee9 (6.0a), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.spooling is
    18.
    19.    procedure do_OUT_8;
    20.
    21.    procedure do_OUT_16;
    22.
    23. end KDF9.TSD.spooling;

 222 lines: No errors
