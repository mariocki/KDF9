Version V8p0k of ee9 for Linux, built on Mon 28 Jun 2021 07:31:50 PM BST.
mk9 'ee9' build: optimised and with full language checks, using configuration options:

pragma Unsuppress(All_Checks);
pragma Optimize_Alignment(Time);
pragma Assertion_Policy(Ignore);
pragma Check_Policy(Debug, Off);
pragma Validity_Checks(Off);
pragma Restrictions(Max_Asynchronous_Select_Nesting => 0);
pragma Restrictions(Max_Tasks => 0);
pragma Restrictions(No_Abort_Statements);
pragma Restrictions(No_Implementation_Attributes);
pragma Restrictions(No_Obsolescent_Features);

Using the build command:
gnatmake -aI../Source -aO../Build -funwind-tables -gnatl12j96 -gnatw.e -gnatwD -gnatwH -gnatwP -gnatwT -gnatw.W -gnatw.B -gnatwC -gnatw.u -gnatyO -gnatw.Y -gnatw.N -fdata-sections -ffunction-sections -gnatf -mtune=native -O3 -flto -j0 ee9 -bargs -static -largs -Wl,--gc-sections -Wl,--as-needed -flto

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ee9.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:50

     1. -- This is the "main program" for the entire emulator.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with GNAT.Source_Info;
    18. --
    19. with Ada.Text_IO;
    20. with Ada.Command_Line;
    21. with Ada.Exceptions;
    22. --
    23. with exceptions;
    24. with HCI;
    25. with IOC.equipment;
    26. with IOC.slow.shift.TP;
    27. with IOC.slow.shift.TR;
    28. with settings;
    29.
    30. with execute;
    31. with say_goodbye;
    32.
    33. use  Ada.Text_IO;
    34. use  Ada.Exceptions;
    35. --
    36. use  exceptions;
    37. use  HCI;
    38. use  IOC.equipment;
    39. use  settings;
    40.
    41. procedure ee9 is
    42.
    43.    package CLI renames Ada.Command_Line;
    44.
    45.    the_log_file_name : constant String := "KDF9_log.txt";
    46.
    47.    a_command_line_error_is_detected : exception;
    48.
    49.    procedure show_proper_usage (message : in String := "") is
    50.    begin
    51.       if message /= "" then
    52.          log_line(message);
    53.       end if;
    54.       log_line(
    55.                "usage: ee9 { [ -s{b|p|t} ] | [ -d{f|p|t|x|-} ] | [ -m"
    56.              & miscellany_prompt
    57.              & " ] [ -TP{k|l}{k|l} ] [ -TR{k|l}{k|l} ] } +program_file_name"
    58.               );
    59.       CLI.Set_Exit_Status(CLI.Failure);
    60.       raise a_command_line_error_is_detected;
    61.    end show_proper_usage;
    62.
    63.    procedure complain (about : in String; because : in String := "") is
    64.    begin
    65.       show_proper_usage(
    66.                         "Parameter «" & about & "» is not valid"
    67.                       & (if because = "" then "." else " because " & because & ".")
    68.                        );
    69.    end complain;
    70.
    71.    the_program_name_position : Natural := 0;
    72.
    73.    procedure check_all_flag_settings is
    74.
    75.       procedure check_flag_setting (i : in Positive) is
    76.
    77.          subtype tape_code_flags is Character
    78.             with Predicate => tape_code_flags in 'K' | 'L' | 'k' | 'l';
    79.
    80.          subtype tape_device_flags is Character
    81.             with Predicate => tape_device_flags in 'P' | 'R' |'p' | 'r';
    82.
    83.          argument : constant String   := CLI.Argument(i);
    84.          index    : constant Positive := argument'First;
    85.
    86.       begin
    87.          -- Ignore an empty parameter.
    88.          if argument'Length = 0 then
    89.             return;
    90.          end if;
    91.
    92.          -- Take note of a program name parameter.
    93.          if argument(index) = '+' then
    94.             if the_program_name_position /= 0 then
    95.                complain(about   => argument,
    96.                         because => "more than one program has been specified");
    97.             end if;
    98.             if argument'Length < 3 then
    99.                complain(about   => argument,
   100.                         because => "it is too short for a program file name");
   101.             end if;
   102.             the_program_name_position := i;
   103.             return;
   104.          end if;
   105.
   106.          -- Fail any non-flag parameter.
   107.          if argument(index) /= '-'  then
   108.             complain(about => argument);
   109.          end if;
   110.
   111.          -- Fail a too-short flag parameter.
   112.          if argument'Length < 2 then
   113.             complain(about   => argument,
   114.                      because => "it is too short");
   115.          end if;
   116.
   117.          -- Check for a miscellany parameter.
   118.          if argument'Length in 2 .. miscellany_flags'Length+2 and then
   119.                argument(index..index+1) = "-m"                    then
   120.             for i in index+2 .. argument'Last loop
   121.                if is_invalid_miscellany_flag(argument(i)) then
   122.                   complain(about => argument);
   123.                end if;
   124.             end loop;
   125.             return;
   126.          end if;
   127.
   128.          -- Check for a state or diagnostic parameter.
   129.          if argument in "-sb" | "-sp" | "-st" | "-df" | "-dt" | "-dp" | "-dx" | "-d-" then
   130.             return;
   131.          end if;
   132.
   133.          -- Check for a Tape Punch/Reader parameter.
   134.          if argument'Length in 4 .. 5                    and then
   135.                argument(index+1) in 'T' | 't'            and then
   136.                   argument(index+2) in tape_device_flags and then
   137.                      argument(index+3) in tape_code_flags    then
   138.             if argument'Length = 4                  or else
   139.                   argument(index+4) in tape_code_flags then
   140.                return;
   141.             end if;
   142.          end if;
   143.
   144.          complain(about => argument);
   145.
   146.       end check_flag_setting;
   147.
   148.    begin -- check_all_flag_settings
   149.       for i in 1..CLI.Argument_Count loop
   150.          check_flag_setting(i);
   151.       end loop;
   152.       if the_program_name_position = 0 then
   153.          show_proper_usage("No program name parameter was given.");
   154.       end if;
   155.    end check_all_flag_settings;
   156.
   157.    procedure impose_all_flag_settings is
   158.
   159.       procedure impose_flag_setting (i : in Positive) is
   160.
   161.          subtype Latin_1_code_flags is Character
   162.             with Predicate => Latin_1_code_flags in 'L' | 'l';
   163.
   164.          subtype punch_device_flags is Character
   165.             with Predicate => punch_device_flags in 'P' |'p';
   166.
   167.          argument : constant String   := CLI.Argument(i);
   168.          index    : constant Positive := argument'First;
   169.
   170.       begin -- impose_flag_setting
   171.          -- Ignore an empty parameter.
   172.          if argument'Length = 0 then
   173.             return;
   174.          end if;
   175.
   176.          -- Ignore a program_file_name parameter.
   177.          if argument(index) = '+'  then
   178.             return;
   179.          end if;
   180.
   181.          -- Impose a miscellany parameter.
   182.          if argument'Length in 2 .. miscellany_flags'Length+2 and then
   183.                argument(index..index+1) = "-m"  then
   184.             for i in index+2 .. argument'Last loop
   185.                set_this_miscellany_flag(argument(i));
   186.             end loop;
   187.             return;
   188.          end if;
   189.
   190.          -- Impose  a Tape Punch/Reader parameter.
   191.          if argument'Length in 4 .. 5 then
   192.             -- Set the code for the first device.
   193.             if argument(index+2) in punch_device_flags then
   194.                IOC.slow.shift.TP.set_unit_code(0, argument(index+3) in Latin_1_code_flags);
   195.             else
   196.                IOC.slow.shift.TR.set_unit_code(0, argument(index+3) in Latin_1_code_flags);
   197.             end if;
   198.          end if;
   199.          if argument'Length = 5 then
   200.             -- Set the code for the second device.
   201.             if argument(index+2) in punch_device_flags then
   202.                IOC.slow.shift.TP.set_unit_code(1, argument(index+4) in Latin_1_code_flags);
   203.             else
   204.                IOC.slow.shift.TR.set_unit_code(1, argument(index+4) in Latin_1_code_flags);
   205.             end if;
   206.          end if;
   207.
   208.          -- Impose a state or diagnostic parameter; argument is known to be 3 characters long.
   209.          if    argument = "-sb" then
   210.             set_execution_mode(boot_mode);
   211.          elsif argument = "-sp" then
   212.             set_execution_mode(program_mode);
   213.          elsif argument = "-st" then
   214.             set_execution_mode(privileged_mode);
   215.          elsif argument = "-d-" then
   216.             set_diagnostic_mode(fast_mode);
   217.          elsif argument = "-df" then
   218.             set_diagnostic_mode(fast_mode);
   219.          elsif argument = "-dt" then
   220.             set_diagnostic_mode(trace_mode);
   221.          elsif argument = "-dp" then
   222.             set_diagnostic_mode(pause_mode);
   223.          elsif argument = "-dx" then
   224.             set_diagnostic_mode(external_mode);
   225.          end if;
   226.       end impose_flag_setting;
   227.
   228.    begin -- impose_all_flag_settings
   229.       if CLI.Argument_Count = 0 then
   230.          return;
   231.       end if;
   232.       for i in 1..CLI.Argument_Count loop
   233.          impose_flag_setting(i);
   234.       end loop;
   235.    end impose_all_flag_settings;
   236.
   237.    function name_part_of (f : String)
   238.    return String
   239.    is (f(f'First+1 .. f'Last));
   240.
   241.    function the_program_name
   242.    return String
   243.    is (name_part_of(CLI.Argument(the_program_name_position)));
   244.
   245. begin -- ee9
   246.
   247.    check_all_flag_settings;
   248.    open(the_log_file_name);
   249.    get_settings_from_file("1");
   250.    configure_the_IOC;
   251.    impose_all_flag_settings;
   252.    revise_the_IOC_configuration;
   253.    log_line(
   254.             "This is ee9 8.0k, compiled by "
   255.           & Standard'Compiler_Version
   256.           & " on "
   257.           & GNAT.Source_Info.Compilation_ISO_Date
   258.           & ".",
   259.             iff => the_log_is_wanted
   260.            );
   261.
   262.    display_execution_modes(the_program_name);
   263.    execute(the_program_name);
   264.
   265.    close(the_log_file_name);
   266.
   267. exception
   268.
   269.    when a_command_line_error_is_detected =>
   270.       close(the_log_file_name);
   271.
   272.    when diagnostic : operator_error =>
   273.       say_goodbye("The KDF9 operator has made a mistake", Exception_Message(diagnostic));
   274.
   275.    when error : others =>
   276.       Put_Line(Standard_Error, "Failure in ee9: " & Exception_Information(error) & ".");
   277.       close(the_log_file_name);
   278.       CLI.Set_Exit_Status(CLI.Failure);
   279.
   280. end ee9;

 280 lines: No errors


GNAT 8.3.0
GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/exceptions.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:50

     1. -- Declare the exceptions used in emulation-mode control.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package exceptions is
    18.
    19.    -- program_exit is raised when a KDF9 program terminates normally.
    20.    program_exit : exception;
    21.
    22.   -- OUT_2_restart is raised when a KDF9 program terminates by means of OUT 2.
    23.    OUT_2_restart : exception;
    24.
    25.    -- time_expired is raised when a KDF9 program executes too many instructions.
    26.    time_expired : exception;
    27.
    28.    -- quit_request is raised when the user requests a quit at a break-in.
    29.    quit_request : exception;
    30.
    31.    -- input_is_impossible is raised when an attempt is made to read from the terminal in
    32.    --    noninteractive mode.  This prevents absent-user scripted usage from hanging.
    33.    input_is_impossible : exception;
    34.
    35.    -- operator_error is raised when the operating context is invalid; e.g. labelled tape not mounted.
    36.    operator_error : exception;
    37.
    38.    -- OUT_error is raised when an impossible OUT action is requested in problem program state.
    39.    OUT_error : exception;
    40.
    41.    -- IO_error is raised when an impossible I/O operation is attempted in problem program state.
    42.    IO_error : exception;
    43.
    44.    -- Director_IO_error when an impossible I/O operation is attempted in Director state.
    45.    Director_IO_error : exception;
    46.
    47.    -- Director_failure is raised for an instruction that would LIV in problem program state.
    48.    Director_failure : exception;
    49.
    50.    -- invalid_paper_tape_file is raised when given invalid data for a KDF9-code paper tape file.
    51.    invalid_paper_tape_file : exception;
    52.
    53.    -- not_yet_implemented is raised by an incomplete emulation.
    54.    not_yet_implemented : exception;
    55.
    56.    -- emulation_failure is raised when an emulator self-check fails.
    57.    emulation_failure : exception;
    58.
    59.    -- debugging_stop is raised when a debugging run needs to halt at once.
    60.    debugging_stop : exception;
    61.
    62. end exceptions;

 62 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/hci.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:50

     1. -- Provide operations supporting replicated human-readable output:
     2. --    1: to an interactive user interface for transient display, and
     3. --    2: to a file for persistent storage.
     4. -- If no file has been opened, or if it has been explicitly closed,
     5. --    output is to the interactive interface only.
     6. --
     7. -- Also provide operations allowing synchronization with the user.
     8. --
     9. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
    10. -- Copyright (C) 2021, W. Findlay; all rights reserved.
    11. --
    12. -- The ee9 program is free software; you can redistribute it and/or
    13. -- modify it under terms of the GNU General Public License as published
    14. -- by the Free Software Foundation; either version 3, or (at your option)
    15. -- any later version. This program is distributed in the hope that it
    16. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    17. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    18. -- See the GNU General Public License for more details. You should have
    19. -- received a copy of the GNU General Public License distributed with
    20. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    21. --
    22.
    23. with generic_logger;
    24. with settings;
    25.
    26. use  settings;
    27.
    28. package body HCI is
    29.
    30.    package log_manager is new generic_logger(max_logger_list_size => 2);
    31.
    32.    cc_list : log_manager.replicator;
    33.
    34.    procedure tab_log (at_least : in Natural;
    35.                       spacing  : in Positive := 6;
    36.                       iff      : in Boolean := True) is
    37.    begin
    38.       cc_list.tab_log(at_least, spacing, iff);
    39.    end tab_log;
    40.
    41.    procedure tab_log_to (column : in Positive;
    42.                          iff    : in Boolean := True) is
    43.    begin
    44.       cc_list.tab_log_to(column, iff);
    45.    end tab_log_to;
    46.
    47.    procedure log (char : in Character;
    48.                   iff  : in Boolean := True) is
    49.    begin
    50.       cc_list.log(char, iff);
    51.    end log;
    52.
    53.    procedure log (text : in String;
    54.                   iff  : in Boolean := True) is
    55.    begin
    56.       cc_list.log(text, iff);
    57.    end log;
    58.
    59.    procedure log_line (text : in String;
    60.                        iff  : in Boolean := True) is
    61.    begin
    62.       if text /= "" then
    63.          cc_list.log(text, iff);
    64.       end if;
    65.       log_new_line(iff);
    66.    end log_line;
    67.
    68.    procedure log_new_line (iff : in Boolean := True) is
    69.    begin
    70.       cc_list.log_new_line(iff);
    71.    end log_new_line;
    72.
    73.    procedure log_rule (start_a_new_line : in Boolean := False;
    74.                        iff              : in Boolean := True) is
    75.    begin
    76.        if start_a_new_line then
    77.           cc_list.log_new_line(iff);
    78.        end if;
    79.        log_line(String'(1..80 => '_'), iff);
    80.    end log_rule;
    81.
    82.    procedure log_message (message : in String) is
    83.    begin
    84.       cc_list.log(message);
    85.       cc_list.log_new_line;
    86.    end log_message;
    87.
    88.    procedure log_title (message : in String) is
    89.    begin
    90.       cc_list.log_new_line;
    91.       cc_list.log(message);
    92.       cc_list.log_new_line;
    93.    end log_title;
    94.
    95.    procedure log_ee9_status (message  : in String;
    96.                              skip     : in Natural := 0;
    97.                              complete : in Boolean := True;
    98.                              iff      : in Boolean := True) is
    99.    begin
   100.       if not iff then return; end if;
   101.       panel_logger.tab_log_to(1);
   102.       for i in 1 .. skip loop
   103.          log_new_line;
   104.       end loop;
   105.       if complete then
   106.          log_line("ee9: " & message & ".");
   107.       else
   108.          log("ee9: " & message);
   109.       end if;
   110.    end log_ee9_status;
   111.
   112.    procedure log_API_message (message  : in String;
   113.                               skip     : in Natural := 1) is
   114.    begin
   115.       if API_logging_is_wanted then
   116.          log_ee9_status(message, skip, True);
   117.       end if;
   118.    end log_API_message;
   119.
   120.    procedure show_line (message : in String) is
   121.    begin
   122.       if debugging_is_enabled then
   123.          panel_logger.show_line(message);
   124.          flush;
   125.       end if;
   126.    end show_line;
   127.
   128.    procedure interact (reason : in String := "Mode") is
   129.    begin
   130.       panel_logger.interact(reason);
   131.    end interact;
   132.
   133.    procedure open (logfile_name : in String) is
   134.    begin
   135.       cc_list.open(logfile_name);
   136.    end open;
   137.
   138.    procedure close (logfile_name : in String) is
   139.    begin
   140.       cc_list.close(logfile_name);
   141.    end close;
   142.
   143.    procedure flush (iff : in Boolean := True) is
   144.    begin
   145.       cc_list.flush(iff);
   146.    end flush;
   147.
   148.    procedure log_to_file (message : in String) is
   149.    begin
   150.       file_logger.log(message);
   151.       file_logger.log_new_line;
   152.    end log_to_file;
   153.
   154. begin
   155.    cc_list.set_logger_list((file_logger'Access, panel_logger'Access));
   156. end HCI;

Compiling: ../Source/hci.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:50

     1. -- Provide operations supporting replicated human-readable output:
     2. --    1: to an interactive user interface for transient display, and
     3. --    2: to a file for persistent storage.
     4. -- If no file has been opened, or if it has been explicitly closed,
     5. --    output is to the interactive interface only.
     6. --
     7. -- Also provide operations allowing synchronization with the user.
     8. --
     9. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
    10. -- Copyright (C) 2021, W. Findlay; all rights reserved.
    11. --
    12. -- The ee9 program is free software; you can redistribute it and/or
    13. -- modify it under terms of the GNU General Public License as published
    14. -- by the Free Software Foundation; either version 3, or (at your option)
    15. -- any later version. This program is distributed in the hope that it
    16. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    17. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    18. -- See the GNU General Public License for more details. You should have
    19. -- received a copy of the GNU General Public License distributed with
    20. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    21. --
    22.
    23. with logging.file;
    24. with logging.panel;
    25.
    26. use  logging.file;
    27. use  logging.panel;
    28.
    29. package HCI is
    30.
    31.    file_logger  : aliased logging.file.output;
    32.    panel_logger : aliased logging.panel.display;
    33.
    34.    procedure tab_log (at_least : in Natural;
    35.                       spacing  : in Positive := 6;
    36.                       iff      : in Boolean := True);
    37.
    38.    procedure tab_log_to (column : in Positive;
    39.                          iff    : in Boolean := True);
    40.
    41.    procedure log (char : in Character;
    42.                   iff  : in Boolean := True);
    43.
    44.    procedure log (text : in String;
    45.                   iff  : in Boolean := True);
    46.
    47.    procedure log_line (text : in String;
    48.                        iff  : in Boolean := True);
    49.
    50.    procedure log_new_line (iff : in Boolean := True);
    51.
    52.    procedure log_rule (start_a_new_line : in Boolean := False;
    53.                        iff              : in Boolean := True);
    54.
    55.    procedure log_message (message : in String);
    56.
    57.    procedure log_title (message : in String);
    58.
    59.    procedure log_ee9_status (message  : in String;
    60.                              skip     : in Natural := 0;
    61.                              complete : in Boolean := True;
    62.                              iff      : in Boolean := True);
    63.
    64.    procedure log_API_message (message  : in String;
    65.                               skip     : in Natural := 1);
    66.
    67.    procedure show_line (message : in String);
    68.
    69.    procedure interact (reason : in String := "Mode");
    70.
    71.    procedure open  (logfile_name : in String);
    72.
    73.    procedure close (logfile_name : in String);
    74.
    75.    procedure flush (iff : in Boolean := True);
    76.
    77.    procedure log_to_file (message : in String);
    78.
    79. end HCI;

 156 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/execute.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:50

     1. -- This is the emulation-mode coordinate module.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with GNAT.Ctrl_C;
    18. --
    19. with Ada.Command_Line;
    20. with Ada.Exceptions;
    21. --
    22. with break_in;
    23. with dumping;
    24. with exceptions;
    25. with HCI;
    26. with IOC.slow.shift.TR;
    27. with KDF9;
    28. with KDF9.microcode;
    29. with settings;
    30. with state_display;
    31.
    32. with say_goodbye;
    33.
    34. use  Ada.Command_Line;
    35. use  Ada.Exceptions;
    36. --
    37. use  dumping;
    38. use  exceptions;
    39. use  HCI;
    40. use  IOC.slow.shift.TR;
    41. use  KDF9;
    42. use  KDF9.microcode;
    43. use  settings;
    44. use  state_display;
    45.
    46. procedure execute (program_name : in String) is
    47.
    48.    procedure check_times_and_modes
    49.       with Inline;
    50.
    51.    pause_count : KDF9.order_counter := 0;
    52.
    53.    procedure check_times_and_modes is
    54.    begin
    55.       if ICR > pause_count then
    56.          if ICR >= time_limit then
    57.             raise time_expired;
    58.          end if;
    59.          pause_count := pause_count + time_slice;
    60.          change_diagnostic_mode_if_requested;
    61.       end if;
    62.    end check_times_and_modes;
    63.
    64. begin  -- execute
    65.    GNAT.Ctrl_C.Install_Handler(break_in.note_user_interrupt'Access);
    66.
    67.    if the_external_trace_is_enabled then
    68.       log_an_external_trace_header;
    69.    end if;
    70.
    71.    case the_execution_mode is
    72.       when boot_mode =>
    73.          reset_the_internal_registers(Director_state);
    74.       when privileged_mode=>
    75.          reset_the_internal_registers(Director_state);
    76.       when program_mode =>
    77.          reset_the_internal_registers(program_state);
    78.    end case;
    79.
    80.    case the_execution_mode is
    81.       when boot_mode =>
    82.          if this_is_a_bare_Director then
    83.             load_a_bare_Director(program_name);
    84.          else
    85.             boot_the_KDF9(program_name);
    86.          end if;
    87.       when privileged_mode=>
    88.          load_a_program(program_name);
    89.       when program_mode =>
    90.          load_a_program(program_name);
    91.    end case;
    92.
    93.    case the_execution_mode is
    94.       when boot_mode =>
    95.          if this_is_a_bare_Director then
    96.             reset_the_CPU_state((4, 0));
    97.          else
    98.             reset_the_CPU_state((0, 0));
    99.          end if;
   100.       when others =>
   101.          reset_the_CPU_state((0, 0));
   102.    end case;
   103.
   104.    if not loading_was_successful then
   105.       say_goodbye("Could not load the specified program.");
   106.       return;
   107.    end if;
   108.
   109.    poke_all_amendments;
   110.    show_all_prerun_dump_areas;
   111.
   112.    if do_not_execute then
   113.       log_new_line;
   114.       log_line("Run abandoned as requested.");
   115.       return;
   116.    end if;
   117.
   118. execution_loop:
   119.    loop
   120.
   121.       begin
   122.
   123.          check_times_and_modes;
   124.          if the_diagnostic_mode /= fast_mode then
   125.             -- Do a single, traced instruction, breaking-in conditionally.
   126.             do_a_traced_instruction_cycle;
   127.          else
   128.             -- Fast mode is designed for minimal overhead;
   129.             --    it interacts with the user only at the end of a time slice.
   130.             loop
   131.                do_a_fast_time_slice;
   132.                check_times_and_modes;
   133.             end loop;
   134.          end if;
   135.
   136.       exception  -- handler for execution_loop
   137.
   138.          when mode_change_request =>
   139.             quit_if_requested;
   140.             if do_not_execute then
   141.                log_new_line;
   142.                log_line("Run abandoned as requested.");
   143.                return;
   144.             end if;
   145.
   146.          when abandon_this_order =>
   147.             null;  -- Just get on with it after an interrupt or nullified order.
   148.
   149.          when LOV_exception =>
   150.             IOC.handle_a_main_store_lockout;
   151.
   152.          when program_exit =>
   153.             say_goodbye("", status => Success);
   154.             exit execution_loop;
   155.
   156.          when time_expired =>
   157.             say_goodbye("Infinite loop? Run failed by exceeding the time limit");
   158.             exit execution_loop;
   159.
   160.          when diagnostic : NOUV_exception =>
   161.             say_goodbye("NOUV interrupt", Exception_Message(diagnostic));
   162.             exit execution_loop;
   163.
   164.          when input_is_impossible =>
   165.             say_goodbye("Noninteractive mode; cannot respond to a prompt");
   166.             exit execution_loop;
   167.
   168.          when diagnostic : not_yet_implemented =>
   169.             say_goodbye("Not yet implemented", Exception_Message(diagnostic));
   170.             exit execution_loop;
   171.
   172.          when diagnostic : RESET_exception =>
   173.             say_goodbye("RESET interrupt", Exception_Message(diagnostic));
   174.             exit execution_loop;
   175.
   176.          when diagnostic : LIV_exception =>
   177.             say_goodbye( "LIV interrupt", Exception_Message(diagnostic));
   178.             exit execution_loop;
   179.
   180.          when diagnostic : Director_failure =>
   181.             say_goodbye("LIV interrupt in Director", Exception_Message(diagnostic));
   182.             exit execution_loop;
   183.
   184.          when diagnostic : OUT_error =>
   185.             say_goodbye("Failure in OUT", Exception_Message(diagnostic));
   186.             exit execution_loop;
   187.
   188.          when diagnostic : IO_error =>
   189.             say_goodbye("Impossible I/O operation", Exception_Message(diagnostic));
   190.             exit execution_loop;
   191.
   192.          when diagnostic : Director_IO_error =>
   193.             say_goodbye("Impossible I/O operation in Director", Exception_Message(diagnostic));
   194.             exit execution_loop;
   195.
   196.       end;
   197.
   198.    end loop execution_loop;
   199.
   200. exception  -- handler for execute
   201.
   202.    when diagnostic : debugging_stop =>
   203.       say_goodbye("Debugging stop requested", Exception_Message(diagnostic));
   204.
   205.    when diagnostic : invalid_paper_tape_file =>
   206.       say_goodbye("Invalid paper tape file supplied", Exception_Message(diagnostic));
   207.
   208.    when diagnostic : operator_error =>
   209.       say_goodbye("The KDF9 operator has made a mistake", Exception_Message(diagnostic));
   210.
   211.    when diagnostic : quit_request =>
   212.       say_goodbye("Run stopped by the user", Exception_Message(diagnostic), status => Success);
   213.
   214.    when diagnostic : others =>
   215.       say_goodbye("Apologies for this dismal failure", Exception_Message(diagnostic));
   216.
   217. end execute;

 217 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:50

     1. -- Emulation of the common functionality of a KDF9 IOC "buffer" (DMA channel),
     2. --    with fail-stop stubs for operations having device-specific behaviour.
     3. --
     4. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with KDF9.CPU;
    19. with KDF9.PHU_store;
    20. with tracing;
    21.
    22. with IOC.the_locker_of;
    23.
    24. use  KDF9.CPU;
    25. use  KDF9.PHU_store;
    26. use  tracing;
    27.
    28. package body IOC is
    29.
    30.    procedure set_state_of (the_buffer : in device_class_access;
    31.                            allocated  : in Boolean) is
    32.    begin
    33.       if the_buffer /= null then
    34.          if the_buffer.is_allocated = allocated then
    35.             -- Allocating an already allocated device, or deallocating an unallocated device.
    36.             -- Both are benign, so ignore.
    37.             return;
    38.          else
    39.             the_buffer.is_allocated := allocated;
    40.             the_CPDAR(the_buffer.number) := allocated;
    41.          end if;
    42.       end if;
    43.     end set_state_of;
    44.
    45.    function is_allocated (the_buffer : device_class_access)
    46.    return Boolean
    47.    is (the_buffer.is_allocated);
    48.
    49.    function is_unallocated (the_buffer : device_class_access)
    50.    return Boolean
    51.    is (not the_buffer.is_allocated);
    52.
    53.    hex : constant String := "0123456789ABCDEF";
    54.
    55.    function device_name_of (the_buffer : IOC.device)
    56.    return IOC.device_name is
    57.       its : IOC.device'Class renames IOC.device'Class(the_buffer);
    58.    begin
    59.       return IOC.device_kind'Image(its.kind)(1..2) & hex(Natural(its.unit)+1);
    60.    end device_name_of;
    61.
    62.    function device_name_of (the_number : IOC.device_number)
    63.    return IOC.device_name
    64.    is (device_name_of(buffer(the_number).all));
    65.
    66.    function device_kind_of (the_number : IOC.device_number)
    67.    return IOC.device_kind
    68.    is (buffer(the_number).kind);
    69.
    70.    procedure install (the_device : in out IOC.device'Class) is
    71.    begin
    72.       buffer(the_device.number) := the_device'Unchecked_Access;
    73.    end install;
    74.
    75.    overriding
    76.    procedure Initialize (the_buffer : in out IOC.device) is
    77.    begin
    78.       if not IOC.device'Class(the_buffer).is_open then
    79.          the_buffer.is_abnormal := True;
    80.          the_buffer.is_offline  := True;
    81.       end if;
    82.       install(the_buffer);
    83.    end Initialize;
    84.
    85.    procedure open (the_buffer : in out IOC.device'Class;
    86.                    the_mode   : in POSIX.access_mode) is
    87.    begin
    88.       the_buffer.device_name := device_name_of(the_buffer);
    89.       host_IO.open(the_buffer.stream, the_buffer.device_name, the_mode);
    90.       if the_buffer.is_open then
    91.          if the_mode = write_mode then
    92.             truncate(the_buffer.stream);
    93.          end if;
    94.       else
    95.          trap_operator_error(the_buffer.device_name & " cannot be found");
    96.       end if;
    97.       IOC.device(the_buffer).Initialize;
    98.    end open;
    99.
   100.    overriding
   101.    procedure Finalize (the_buffer : in out IOC.device) is
   102.    begin
   103.       if IOC.device'Class(the_buffer).is_open   and then
   104.             IOC.device'Class(the_buffer).usage /= 0 then
   105.          IOC.device'Class(the_buffer).close;
   106.       end if;
   107.    end Finalize;
   108.
   109.    function usage (the_buffer : IOC.device)
   110.    return KDF9.word is
   111.    begin
   112.       return the_buffer.stream.bytes_moved;
   113.    end usage;
   114.
   115.    procedure flush (the_buffer : in out IOC.device) is
   116.    begin
   117.       flush(the_buffer.stream);
   118.    end flush;
   119.
   120.    procedure close (the_buffer : in out IOC.device) is
   121.    begin
   122.       close(the_buffer.stream);
   123.       IOC.buffer(the_buffer.number) := null;
   124.    end close;
   125.
   126.    procedure finalize_all_KDF9_buffers is
   127.    begin
   128.       for b in IOC.buffer'Range loop
   129.          if IOC.buffer(b) /= null then
   130.             Finalize(IOC.buffer(b).all);
   131.          end if;
   132.       end loop;
   133.    end finalize_all_KDF9_buffers;
   134.
   135.    procedure add_in_the_IO_lockout_CPU_time (Q_operand : in KDF9.Q_register) is
   136.       IO_size : constant KDF9.Q_part := Q_operand.M - Q_operand.I;
   137.    begin
   138.       the_CPU_delta := the_CPU_delta + KDF9.us(IO_size + group_size - 1) / group_size;
   139.    end add_in_the_IO_lockout_CPU_time;
   140.
   141.    function IO_elapsed_time (the_buffer   : IOC.device;
   142.                              atomic_items : KDF9.word)
   143.    return KDF9.us
   144.    is (
   145.        if IOC.device'Class(the_buffer).is_open then
   146.           KDF9.us(atomic_items) * IOC.device'Class(the_buffer).quantum
   147.        else
   148.           0
   149.       );
   150.
   151.    function IO_elapsed_time_total (the_buffer : IOC.device)
   152.    return KDF9.us
   153.    is (IO_elapsed_time(IOC.device'Class(the_buffer), IOC.device'Class(the_buffer).usage));
   154.
   155.    procedure validate_device (the_buffer : in IOC.device'Class) is
   156.    begin
   157.       if not the_CPDAR(the_buffer.number) and then
   158.             the_CPU_state /= Director_state   then
   159.          trap_illegal_instruction("unallocated I/O device " & the_buffer.device_name);
   160.       end if;
   161.    end validate_device;
   162.
   163.    procedure validate_bounds (Q_operand : in KDF9.Q_register) is
   164.    begin
   165.       if Q_operand.I > Q_operand.M then
   166.          trap_illegal_instruction("invalid I/O Q operand: I > M");
   167.       end if;
   168.       validate_address_range(Q_operand.I, Q_operand.M);
   169.    end validate_bounds;
   170.
   171.    procedure validate_transfer (the_buffer : in IOC.device'Class;
   172.                                 Q_operand  : in KDF9.Q_register) is
   173.    begin
   174.       validate_device(the_buffer);
   175.       validate_bounds(Q_operand);
   176.    end validate_transfer;
   177.
   178.    procedure validate_parity (the_buffer : in IOC.device'Class) is
   179.    begin
   180.       if the_buffer.is_abnormal then
   181.          trap_illegal_instruction(the_buffer.device_name & " is abnormal (parity error or EOF)");
   182.       end if;
   183.    end validate_parity;
   184.
   185.    procedure require_positive_count (count : in KDF9.Q_part) is
   186.    begin
   187.       if resign(count) <= 0 then
   188.          trap_illegal_instruction("I/O repetition count <= 0");
   189.       end if;
   190.    end require_positive_count;
   191.
   192.    procedure require_nonnegative_count (count : in KDF9.Q_part) is
   193.    begin
   194.       if resign(count) < 0 then
   195.          trap_illegal_instruction("I/O repetition count < 0");
   196.       end if;
   197.    end require_nonnegative_count;
   198.
   199.    function control_word_image (the_buffer : in IOC.device'Class)
   200.    return String
   201.    is (
   202.        the_buffer.device_name
   203.      & " Q"  & the_buffer.control_word.C'Image
   204.      & "/#"  & oct_of(the_buffer.control_word.I)
   205.      & "/#"  & oct_of(the_buffer.control_word.M)
   206.       );
   207.
   208.    -- In boot mode, punt the LOV interrupt to Director.
   209.    -- In other modes, advance the elapsed time to the next-interrupt time,
   210.    --    and suppress the LOV by simulating an earlier end of transfer.
   211.    procedure handle_a_buffer_lockout (the_buffer : in IOC.device'Class) is
   212.    begin
   213.       PHU(CPL) := (
   214.                    is_held_up => True,
   215.                    blockage   => (buffer_busy, the_buffer.number, by_INTQq => False)
   216.                   );
   217.       take_note_of_buffer_lockout(the_buffer.device_name, the_buffer.operation);
   218.       if the_execution_mode = boot_mode then
   219.          LOV_if_user_mode(the_buffer.device_name & " is busy");
   220.       else
   221.          advance_the_clock(the_buffer.completion_time);
   222.          act_on_pending_interrupts;
   223.       end if;
   224.    end handle_a_buffer_lockout;
   225.
   226.    procedure deal_with_a_busy_device (the_buffer  : in out IOC.device'Class;
   227.                                       order_time  : in KDF9.us;
   228.                                       set_offline : in Boolean) is
   229.    begin
   230.       advance_the_clock(the_clock_time+order_time);
   231.       if the_buffer.is_busy then
   232.          handle_a_buffer_lockout(the_buffer);
   233.       end if;
   234.       the_buffer.is_offline := set_offline;
   235.    end deal_with_a_busy_device;
   236.
   237.    procedure finalize_transfer (the_buffer : in out IOC.device'Class;
   238.                                 need_EDT,
   239.                                 need_PR    : out Boolean);
   240.
   241.    procedure start_data_transfer (the_buffer   : in out IOC.device'Class;
   242.                                   Q_operand    : in KDF9.Q_register;
   243.                                   set_offline  : in Boolean;
   244.                                   busy_time    : in KDF9.us;
   245.                                   operation    : in IOC.transfer_kind := some_other_operation) is
   246.       pragma Unreferenced(set_offline);
   247.       transferring_data : constant Boolean := operation in input_operation | output_operation;
   248.       time_now          : constant KDF9.us := the_clock_time;
   249.       real_Q            : KDF9.Q_register := Q_operand;
   250.       EDT_needed,
   251.       PR_needed         : Boolean;
   252.    begin
   253.       -- Check the IO parameters and the buffer state, and handle any lockout set by another device.
   254.       validate_device(the_buffer);
   255.
   256.       if transferring_data then
   257.          validate_bounds(real_Q);
   258.          real_Q := (real_Q.C, real_Q.I+BA, real_Q.M+BA);
   259.       else
   260.          require_nonnegative_count(real_Q.M);
   261.       end if;
   262.
   263.       validate_parity(the_buffer);
   264.
   265.       if the_buffer.is_busy then
   266.          handle_a_buffer_lockout(the_buffer);
   267.          if the_execution_mode = boot_mode then
   268.             finalize_transfer (the_buffer, EDT_needed, PR_needed);
   269.             if the_next_interrupt_time > time_now + 1_024_000 then
   270.                the_next_interrupt_time := time_now + 1_024_000;
   271.             end if;
   272.             if EDT_needed then
   273.                effect_interrupt(caused_by_EDT, the_buffer.control_word_image);
   274.             elsif PR_needed then
   275.                effect_interrupt(caused_by_PR, the_buffer.control_word_image);
   276.             end if;
   277.          end if;
   278.       end if;
   279.
   280.       if transferring_data                            and then
   281.             there_are_locks_in_physical_addresses(real_Q) then
   282.          LOV_if_user_mode(
   283.                           "in "
   284.                        &  "#"   & oct_of(the_buffer.control_word.I)
   285.                        &  "/#"  & oct_of(the_buffer.control_word.M)
   286.                        &  " for "
   287.                        &  the_buffer.device_name
   288.                          );
   289.       end if;
   290.
   291.       -- Set up the transfer parameters.
   292.       the_buffer.is_for_Director := (the_CPU_state = Director_state);
   293.       the_buffer.priority_level  := CPL;
   294.       the_buffer.control_word    := real_Q;
   295.       the_buffer.operation       := operation;
   296.       the_buffer.order_count     := ICR+1;
   297.       the_buffer.order_address   := CIA;
   298.       the_buffer.decoded_order   := INS;
   299.       the_buffer.initiation_time := time_now;
   300.       the_buffer.transfer_time   := busy_time;
   301.       the_buffer.completion_time := the_buffer.initiation_time + busy_time;
   302.
   303.       if busy_time > 0 or transferring_data then
   304.          if the_buffer.completion_time < the_next_interrupt_time then
   305.             the_next_interrupt_time := the_buffer.completion_time;
   306.          end if;
   307.          the_buffer.is_busy := True;
   308.          take_note_of_IO_start(
   309.                                the_buffer.device_name,
   310.                                the_buffer.completion_time,
   311.                                the_buffer.control_word,
   312.                                the_buffer.operation
   313.                               );
   314.       else
   315.          the_buffer.is_busy := False;
   316.          take_note_of_IO_finis (
   317.                                 the_buffer.order_count,
   318.                                 the_buffer.order_address,
   319.                                 the_buffer.decoded_order,
   320.                                 the_buffer.initiation_time,
   321.                                 the_buffer.device_name,
   322.                                 the_buffer.is_for_Director,
   323.                                 the_buffer.priority_level,
   324.                                 the_buffer.completion_time,
   325.                                 the_buffer.control_word,
   326.                                 the_buffer.operation
   327.                                );
   328.       end if;
   329.       PHU(CPL) := idle_PHU;
   330.    end start_data_transfer;
   331.
   332.    -- start_slow_transfer takes a pessimistic view of transfers-to-End_Message.
   333.    -- When the actual transfer length is known, the end-of-transfer time can be
   334.    --    made more realistic by specifying its real length to correct_transfer_time.
   335.    -- correct_transfer_time must be called before finalize_transfer is called.
   336.
   337.    procedure correct_transfer_time (the_buffer  : in out IOC.device'Class;
   338.                                     actual_time : in KDF9.us) is
   339.    begin
   340.       the_buffer.transfer_time :=  actual_time;
   341.       the_buffer.completion_time := the_buffer.initiation_time + the_buffer.transfer_time;
   342.       if the_buffer.completion_time < the_next_interrupt_time then
   343.          the_next_interrupt_time := the_buffer.completion_time;
   344.       end if;
   345.    end correct_transfer_time;
   346.
   347.    procedure correct_transfer_time (the_buffer    : in out IOC.device'Class;
   348.                                     actual_length : in KDF9.word) is
   349.    begin
   350.       the_buffer.transfer_time := IO_elapsed_time(the_buffer, actual_length);
   351.       the_buffer.completion_time := the_buffer.initiation_time + the_buffer.transfer_time;
   352.       if the_buffer.completion_time < the_next_interrupt_time then
   353.          the_next_interrupt_time := the_buffer.completion_time;
   354.       end if;
   355.    end correct_transfer_time;
   356.
   357.    -- If the buffer has a terminated transfer, clear its lockouts, reset its state,
   358.    --    update the PHUs, and demand an EDT or PR interrupt as needed.
   359.    procedure finalize_transfer (the_buffer : in out IOC.device'Class;
   360.                                 need_EDT,
   361.                                 need_PR    : out Boolean) is
   362.       the_PHU : KDF9.PHU_store.PHU_register renames KDF9.PHU_store.PHU(the_buffer.priority_level);
   363.       blocked : PHU_reason;
   364.    begin
   365.       if the_buffer.transfer_time /= 0 then
   366.          take_note_of_IO_finis (
   367.                                 the_buffer.order_count,
   368.                                 the_buffer.order_address,
   369.                                 the_buffer.decoded_order,
   370.                                 the_buffer.initiation_time,
   371.                                 the_buffer.device_name,
   372.                                 the_buffer.is_for_Director,
   373.                                 the_buffer.priority_level,
   374.                                 the_buffer.completion_time,
   375.                                 the_buffer.control_word,
   376.                                 the_buffer.operation
   377.                                );
   378.       end if;
   379.
   380.       need_EDT := the_buffer.is_for_Director;
   381.
   382.       -- Clear down the transfer and idle the buffer.
   383.       if the_buffer.operation in input_operation | output_operation then
   384.          unlock_absolute_addresses(the_buffer.control_word);
   385.       end if;
   386.       the_buffer.is_busy := False;
   387.       the_buffer.is_for_Director := False;
   388.
   389.       -- The following code is somewhat redundant, but written like this to exactly mirror the
   390.       -- logic stated in the KDF9 TIME-SHARING DIRECTOR SUPPORT DOCUMENTATION of 1-May-1965.
   391.       need_PR := False;
   392.       if the_PHU.is_held_up then
   393.          blocked := the_PHU.blockage;
   394.          if (blocked.reason = buffer_busy and then blocked.by_INTQq)                      or else
   395.             (blocked.reason = buffer_busy and then not buffer(blocked.buffer_nr).is_busy) or else
   396.             (blocked.reason = locked_core and then is_unlocked(blocked.group_nr))            then
   397.             the_PHU := idle_PHU;
   398.             need_PR := the_buffer.priority_level < CPL;
   399.          end if;
   400.       end if;
   401.
   402.       -- A PR interrupt may be wanted, BUT not if an EDT interrupt is wanted.
   403.       -- EDT is wanted if the transfer was for Director OR another program awaits the same buffer.
   404.
   405.       -- Check the rest of the PHU stores for an EDT interrupt.
   406.       -- This is needed only when running a Director.
   407.       if the_execution_mode = boot_mode then
   408.          -- Test for possible priority inversion, i.e. other program(s) blocked on this buffer.
   409.          for p of PHU loop
   410.             if p.is_held_up                               and then
   411.                   p.blockage.reason = buffer_busy         and then
   412.                      p.blockage.buffer_nr = the_buffer.number then
   413.                -- The KDF9 TIME-SHARING DIRECTOR SUPPORT DOCUMENTATION of 1-May-1965
   414.                --   says such a PHU is NOT cleared, but EDT is requested INSTEAD of PR,
   415.                --   so Director can take action according to what it finds there.
   416.                need_EDT := True;
   417.             end if;
   418.          end loop;
   419.       end if;
   420.       if need_EDT then
   421.          need_PR := False;
   422.       end if;
   423.    end finalize_transfer;
   424.
   425.    procedure act_on_pending_interrupts is
   426.       time_now   : constant KDF9.us := the_clock_time;
   427.       EDT_needed,
   428.       PR_needed  : Boolean := False;
   429.       number     : IOC.device_number;
   430.    begin
   431.       advance_the_clock(the_next_interrupt_time);
   432.       -- Predict another interrupt (at most 2**20 seconds in the future in boot mode).
   433.       the_next_interrupt_time := KDF9.us'Last;
   434.       for b of buffer loop
   435.          if b /= null and then
   436.                b.is_busy  then
   437.             if time_now >= b.completion_time then
   438.                finalize_transfer(b.all, EDT_needed, PR_needed);
   439.                if EDT_needed or PR_needed then
   440.                   number := b.number;
   441.                end if;
   442.             elsif the_next_interrupt_time > b.completion_time then
   443.                the_next_interrupt_time := b.completion_time;
   444.             end if;
   445.          end if;
   446.       end loop;
   447.       -- Prevent an inadvertant double clock interrupt.
   448.       if the_execution_mode = boot_mode                and then
   449.             the_next_interrupt_time > time_now + 2**24 - 1 then
   450.          the_next_interrupt_time := time_now + 2**24 - 1;
   451.       end if;
   452.       if EDT_needed then
   453.          effect_interrupt(caused_by_EDT, buffer(number).control_word_image);
   454.       elsif PR_needed then
   455.          effect_interrupt(caused_by_PR, buffer(number).control_word_image);
   456.       end if;
   457.    end act_on_pending_interrupts;
   458.
   459.    -- Advance the time to a point after all extant transfer have terminated,
   460.    --    finalizing all extant transfer in temporal order in the process.
   461.    procedure complete_all_extant_transfers is
   462.       EDT_needed,
   463.       PR_needed      : Boolean := False;
   464.       last_time      : KDF9.us := 0;
   465.       next_time      : KDF9.us;
   466.    begin
   467.       -- At least one transfer should be terminated each time around outer_loop,
   468.       --    if not, outer_loop is exited.
   469.    outer_loop:
   470.       for c in buffer'Range loop
   471.          -- Find the earliest transfer termination time.
   472.          next_time := KDF9.us'Last;
   473.          for b of buffer loop
   474.             if b /= null                       and then
   475.                   b.is_busy                    and then
   476.                      b.completion_time < next_time then
   477.                next_time := b.completion_time;
   478.             end if;
   479.          end loop;
   480.
   481.          if next_time = KDF9.us'Last then
   482.             -- All the buffers are quiescent.
   483.             exit outer_loop;
   484.          else
   485.             -- At least one transfer remains to be finalized.
   486.             advance_the_clock(next_time);
   487.             last_time := KDF9.us'Max(last_time, next_time);
   488.          end if;
   489.
   490.          -- Finalize all transfers with completion time <= next_time.
   491.          for b of buffer loop
   492.             if b /= null                        and then
   493.                   b.is_busy                     and then
   494.                      b.completion_time <= next_time then
   495.                finalize_transfer(b.all, EDT_needed, PR_needed);
   496.             end if;
   497.          end loop;
   498.
   499.       end loop outer_loop;
   500.    end complete_all_extant_transfers;
   501.
   502.    procedure handle_a_main_store_lockout is
   503.       the_locker : KDF9.buffer_number;
   504.       found      : Boolean;
   505.    begin
   506.       PHU(CPL) := (
   507.                    is_held_up => True,
   508.                    blockage   => (locked_core, group_address(group(the_locked_out_address)))
   509.                   );
   510.       -- Store access LOV interrupts invoke instruction restart outside Director.
   511.       the_locker := the_locker_of(the_locked_out_address, found);
   512.       if not found then
   513.          raise emulation_failure with "cannot find a buffer responsible for this store lockout";
   514.       end if;
   515.       take_note_of_store_lockout(device_name_of(buffer(the_locker).all));
   516.       if the_execution_mode = boot_mode then
   517.          if_user_mode_then_LOV(the_locked_out_address);
   518.       else
   519.          set_NIA_to(CIA);
   520.          advance_the_clock(buffer(the_locker).completion_time);
   521.          act_on_pending_interrupts;
   522.       end if;
   523.       ICR := ICR + 1;
   524.    end handle_a_main_store_lockout;
   525.
   526.    procedure MANUAL_CT (the_buffer  : in out IOC.device'Class;
   527.                         Q_operand   : in KDF9.Q_register;
   528.                         set_offline : in Boolean) is
   529.       EDT_needed, PR_needed : Boolean := False;
   530.    begin
   531.       validate_device(the_buffer);
   532.       take_note_of_test(the_buffer.device_name, Q_operand, the_buffer.is_busy);
   533.       -- ee9 allows the transfer to terminate normally, as if MANUALQ with set_offline = True;
   534.       --    even when set_offline = False, i.e. CTQ, which aborted any residual I/O on the KDF9.
   535.       if the_buffer.is_busy then
   536.          the_buffer.completion_time := KDF9.us'Min(the_buffer.completion_time, the_clock_time);
   537.          finalize_transfer(the_buffer, EDT_needed, PR_needed);
   538.       end if;
   539.       the_buffer.is_busy     := False;
   540.       the_buffer.operation   := some_other_operation;
   541.       the_buffer.is_abnormal := False;
   542.       the_buffer.is_offline  := set_offline;
   543.    end MANUAL_CT;
   544.
   545.    procedure INT (the_buffer  : in out IOC.device'Class;
   546.                   Q_operand   : in KDF9.Q_register;
   547.                   set_offline : in Boolean) is
   548.       now  : constant KDF9.us := the_clock_time;
   549.       step : KDF9.us;
   550.    begin
   551.       validate_device(the_buffer);
   552.       if the_buffer.is_busy then
   553.          PHU(CPL) := (
   554.                       is_held_up => True,
   555.                       blockage   => (buffer_busy, the_buffer.number, by_INTQq => True)
   556.                      );
   557.          take_note_of_buffer_lockout(the_buffer.device_name, the_buffer.operation);
   558.          if the_execution_mode = boot_mode then
   559.             step := KDF9.us'Max((the_buffer.completion_time - now) / 16, 1);
   560.             advance_the_clock(KDF9.us'Min(the_buffer.completion_time, now + step));
   561.             effect_interrupt(caused_by_PR, control_word_image(the_buffer));
   562.          else
   563.             advance_the_clock(the_buffer.completion_time);
   564.             act_on_pending_interrupts;
   565.          end if;
   566.       else
   567.          take_note_of_test(the_buffer.device_name, Q_operand, False);
   568.       end if;
   569.       the_buffer.is_offline := set_offline;
   570.    end INT;
   571.
   572.    procedure BUSY (the_buffer  : in out IOC.device'Class;
   573.                    Q_operand   : in KDF9.Q_register;
   574.                    set_offline : in Boolean;
   575.                    result      : out Boolean) is
   576.    begin
   577.       validate_device(the_buffer);
   578.       result := the_buffer.is_busy;
   579.       take_note_of_test(the_buffer.device_name, Q_operand, result);
   580.       if the_buffer.is_busy and then
   581.             (the_execution_mode /= boot_mode or the_CPU_state = Director_state) then
   582.          act_on_pending_interrupts;
   583.       end if;
   584.       the_buffer.is_offline := set_offline;
   585.    end BUSY;
   586.
   587.    procedure PAR (the_buffer  : in out IOC.device'Class;
   588.                   Q_operand   : in KDF9.Q_register;
   589.                   set_offline : in Boolean;
   590.                   result      : out Boolean) is
   591.    begin
   592.       validate_device(the_buffer);
   593.       deal_with_a_busy_device(the_buffer, 13, set_offline);
   594.       result := the_buffer.is_abnormal;
   595.       take_note_of_test(the_buffer.device_name, Q_operand, result);
   596.       the_buffer.is_abnormal := False;
   597.       the_buffer.is_offline := set_offline;
   598.    end PAR;
   599.
   600.    subtype IO_mnemonic is String(1 .. 5);
   601.    type synonyms       is array (1 .. 2) of IO_mnemonic;
   602.    type synonym_list   is array (Positive range <>) of synonyms;
   603.
   604.    FW_synonyms  : constant synonym_list
   605.                 := (
   606.                     ("POA  ", "TW   "), ("POB  ", "TWE  "),
   607.                     ("PIA  ", "TR   "), ("PIB  ", "TRE  ")
   608.                    );
   609.
   610.    TR_synonyms  : constant synonym_list
   611.                 := (
   612.                     ("PIA  ", "PR   "), ("PIB  ", "PRE  "),
   613.                     ("PIC  ", "PRC  "), ("PID  ", "PRCE ")
   614.                    );
   615.
   616.    TP_synonyms  : constant synonym_list
   617.                 := (
   618.                     ("POA  ", "PW   "), ("POB  ", "PWE  "),
   619.                     ("POC  ", "PWC  "), ("POD  ", "PWCE "),
   620.                     ("POE  ", "PGAP ")
   621.                    );
   622.
   623.    LP_synonyms  : constant synonym_list
   624.                 := (
   625.                     ("POA  ", "LP   "), ("POB  ", "LPE  ")
   626.                    );
   627.
   628.    MT_synonyms  : constant synonym_list
   629.                 := (
   630.                     ("PIA  ", "MFR  "), ("PIB  ", "MFRE "),
   631.                     ("PIE  ", "MBR  "), ("PIF  ", "MBRE "),
   632.                     ("POA  ", "MW   "), ("POB  ", "MWE  "),
   633.                     ("POC  ", "MLW  "), ("POD  ", "MLWE "),
   634.                     ("POE  ", "MGAP "), ("POF  ", "MWIPE"),
   635.                     ("PMA  ", "MFSK "), ("PMB  ", "MBT  "),
   636.                     ("PMC  ", "MLB  "), ("PMD  ", "MRWD "),
   637.                     ("PME  ", "MBSK "), ("PMF  ", "MET  ")
   638.                    );
   639.
   640.    function mnemonic (order : in String; class : in IOC.device_name)
   641.    return String is
   642.
   643.       key : constant IO_mnemonic := just_left(order(order'First..order'First+2), 5);
   644.       Qij : constant String      := order(order'First+3..order'Last);
   645.
   646.       function choose (synonyms : synonym_list)
   647.       return String is
   648.       begin
   649.          for s of synonyms loop
   650.             if s(1) = key then return trimmed(s(2)) & Qij; end if;
   651.          end loop;
   652.          return order;
   653.       end choose;
   654.
   655.       XY : constant String(1..2) := class(class'First..class'First+1);
   656.
   657.    begin
   658.       if key(1..3) in "TLO" | "CLO" | "PMH" | "SLO" then
   659.          -- These orders do not necessarily involve a device.
   660.          return order;
   661.       end if;
   662.       if XY in "AD" | "CP" | "CR" | "DR" | "FD" | "GP" | "ST" | "SI" then
   663.          return order;
   664.       elsif XY = "FW" then -- FlexoWriter
   665.          return choose(FW_synonyms);
   666.       elsif XY = "LP" then -- Line Printer
   667.          return choose(LP_synonyms);
   668.       elsif XY = "MT" then -- Magnetic Tape
   669.          return choose(MT_synonyms);
   670.       elsif XY = "TP" then -- Tape Punch
   671.          return choose(TP_synonyms);
   672.       elsif XY = "TR" then -- Tape Reader
   673.          return choose(TR_synonyms);
   674.       else
   675.          return "??";
   676.       end if;
   677.    end mnemonic;
   678.
   679.    procedure trap_failing_IO_operation (the_culprit : in String; the_message : in String) is
   680.       the_diagnostic : constant String := "%" & the_message & " on " & the_culprit;
   681.    begin
   682.       if the_execution_mode in program_mode | privileged_mode then
   683.          raise IO_error with the_diagnostic;
   684.       elsif the_CPU_state = program_state then
   685.          raise abandon_this_order with the_diagnostic;
   686.       else
   687.          raise Director_IO_error with the_diagnostic;
   688.       end if;
   689.    end trap_failing_IO_operation;
   690.
   691.    procedure trap_failing_IO_operation (the_buffer : in out IOC.device; the_message : in String) is
   692.    begin
   693.       if the_CPU_state = program_state then
   694.          the_buffer.is_abnormal := True;
   695.       end if;
   696.       trap_failing_IO_operation(the_buffer.device_name, the_message);
   697.    end trap_failing_IO_operation;
   698.
   699.    procedure trap_illegal_IO_operation (order       : in String;
   700.                                         buffer      : in IOC.device;
   701.                                         Q_operand   : in KDF9.Q_register;
   702.                                         set_offline : in Boolean) is
   703.       pragma Unreferenced(Q_operand);
   704.       pragma Unreferenced(set_offline);
   705.    begin
   706.       trap_illegal_instruction(order & " cannot be used on " & buffer.device_name);
   707.    end trap_illegal_IO_operation;
   708.
   709.    --
   710.    -- The following bodies provide inheritable default actions for
   711.    -- operations that are not implemented by specific device types.
   712.    --
   713.
   714.    procedure PIA (the_buffer  : in out IOC.device;
   715.                   Q_operand   : in KDF9.Q_register;
   716.                   set_offline : in Boolean) is
   717.    begin
   718.       trap_illegal_IO_operation("PIA", the_buffer, Q_operand, set_offline);
   719.    end PIA;
   720.
   721.    procedure PIB (the_buffer  : in out IOC.device;
   722.                   Q_operand   : in KDF9.Q_register;
   723.                   set_offline : in Boolean) is
   724.    begin
   725.       trap_illegal_IO_operation("PIB", the_buffer, Q_operand, set_offline);
   726.    end PIB;
   727.
   728.    procedure PIC (the_buffer  : in out IOC.device;
   729.                   Q_operand   : in KDF9.Q_register;
   730.                   set_offline : in Boolean) is
   731.    begin
   732.       trap_illegal_IO_operation("PIC", the_buffer, Q_operand, set_offline);
   733.    end PIC;
   734.
   735.    procedure PID (the_buffer  : in out IOC.device;
   736.                   Q_operand   : in KDF9.Q_register;
   737.                   set_offline : in Boolean) is
   738.    begin
   739.       trap_illegal_IO_operation("PID", the_buffer, Q_operand, set_offline);
   740.    end PID;
   741.
   742.    procedure PIE (the_buffer  : in out IOC.device;
   743.                   Q_operand   : in KDF9.Q_register;
   744.                   set_offline : in Boolean) is
   745.    begin
   746.       trap_illegal_IO_operation("PIE", the_buffer, Q_operand, set_offline);
   747.    end PIE;
   748.
   749.    procedure PIF (the_buffer  : in out IOC.device;
   750.                   Q_operand   : in KDF9.Q_register;
   751.                   set_offline : in Boolean) is
   752.    begin
   753.       trap_illegal_IO_operation("PIF", the_buffer, Q_operand, set_offline);
   754.    end PIF;
   755.
   756.    procedure PIG (the_buffer  : in out IOC.device;
   757.                   Q_operand   : in KDF9.Q_register;
   758.                   set_offline : in Boolean) is
   759.    begin
   760.       trap_illegal_IO_operation("PIG", the_buffer, Q_operand, set_offline);
   761.    end PIG;
   762.
   763.    procedure PIH (the_buffer  : in out IOC.device;
   764.                   Q_operand   : in KDF9.Q_register;
   765.                   set_offline : in Boolean) is
   766.    begin
   767.       trap_illegal_IO_operation("PIH", the_buffer, Q_operand, set_offline);
   768.    end PIH;
   769.
   770.    procedure PMA (the_buffer  : in out IOC.device;
   771.                   Q_operand   : in KDF9.Q_register;
   772.                   set_offline : in Boolean) is
   773.    begin
   774.       trap_illegal_IO_operation("PMA", the_buffer, Q_operand, set_offline);
   775.    end PMA;
   776.
   777.    procedure PMB (the_buffer  : in out IOC.device;
   778.                   Q_operand   : in KDF9.Q_register;
   779.                   set_offline : in Boolean)
   780.    is null;
   781.
   782.    procedure PMC (the_buffer  : in out IOC.device;
   783.                   Q_operand   : in KDF9.Q_register;
   784.                   set_offline : in Boolean)
   785.    is null;
   786.
   787.    procedure PMD (the_buffer  : in out IOC.device;
   788.                   Q_operand   : in KDF9.Q_register;
   789.                   set_offline : in Boolean) is
   790.    begin
   791.       trap_illegal_IO_operation("PMD", the_buffer, Q_operand, set_offline);
   792.    end PMD;
   793.
   794.    procedure PME (the_buffer  : in out IOC.device;
   795.                   Q_operand   : in KDF9.Q_register;
   796.                   set_offline : in Boolean) is
   797.    begin
   798.       trap_illegal_IO_operation("PME", the_buffer, Q_operand, set_offline);
   799.    end PME;
   800.
   801.    procedure PMF (the_buffer  : in out IOC.device;
   802.                   Q_operand   : in KDF9.Q_register;
   803.                   set_offline : in Boolean)
   804.    is null;
   805.
   806.    procedure PMG (the_buffer  : in out IOC.device;
   807.                   Q_operand   : in KDF9.Q_register;
   808.                   set_offline : in Boolean) is
   809.    begin
   810.       trap_illegal_IO_operation("PMG", the_buffer, Q_operand, set_offline);
   811.    end PMG;
   812.
   813. -- procedure PMH is subsumed by SLOC.
   814.
   815.    procedure PMK (the_buffer  : in out IOC.device;
   816.                   Q_operand   : in KDF9.Q_register;
   817.                   set_offline : in Boolean) is
   818.    begin
   819.       trap_illegal_IO_operation("PMK", the_buffer, Q_operand, set_offline);
   820.    end PMK;
   821.
   822.    procedure PML (the_buffer  : in out IOC.device;
   823.                   Q_operand   : in KDF9.Q_register;
   824.                   set_offline : in Boolean) is
   825.    begin
   826.       trap_illegal_IO_operation("PML", the_buffer, Q_operand, set_offline);
   827.    end PML;
   828.
   829.    procedure POA (the_buffer  : in out IOC.device;
   830.                   Q_operand   : in KDF9.Q_register;
   831.                   set_offline : in Boolean) is
   832.    begin
   833.       trap_illegal_IO_operation("POA", the_buffer, Q_operand, set_offline);
   834.    end POA;
   835.
   836.    procedure POB (the_buffer  : in out IOC.device;
   837.                   Q_operand   : in KDF9.Q_register;
   838.                   set_offline : in Boolean) is
   839.    begin
   840.       trap_illegal_IO_operation("POB", the_buffer, Q_operand, set_offline);
   841.    end POB;
   842.
   843.    procedure POC (the_buffer  : in out IOC.device;
   844.                   Q_operand   : in KDF9.Q_register;
   845.                   set_offline : in Boolean) is
   846.    begin
   847.       trap_illegal_IO_operation("POC", the_buffer, Q_operand, set_offline);
   848.    end POC;
   849.
   850.    procedure POD (the_buffer  : in out IOC.device;
   851.                   Q_operand   : in KDF9.Q_register;
   852.                   set_offline : in Boolean) is
   853.    begin
   854.       trap_illegal_IO_operation("POD", the_buffer, Q_operand, set_offline);
   855.    end POD;
   856.
   857.    procedure POE (the_buffer  : in out IOC.device;
   858.                   Q_operand   : in KDF9.Q_register;
   859.                   set_offline : in Boolean) is
   860.    begin
   861.       trap_illegal_IO_operation("POE", the_buffer, Q_operand, set_offline);
   862.    end POE;
   863.
   864.    procedure POF (the_buffer  : in out IOC.device;
   865.                   Q_operand   : in KDF9.Q_register;
   866.                   set_offline : in Boolean) is
   867.    begin
   868.       trap_illegal_IO_operation("POF", the_buffer, Q_operand, set_offline);
   869.    end POF;
   870.
   871.    procedure POG (the_buffer  : in out IOC.device;
   872.                   Q_operand   : in KDF9.Q_register;
   873.                   set_offline : in Boolean) is
   874.    begin
   875.       trap_illegal_IO_operation("POG", the_buffer, Q_operand, set_offline);
   876.    end POG;
   877.
   878.    procedure POH (the_buffer  : in out IOC.device;
   879.                   Q_operand   : in KDF9.Q_register;
   880.                   set_offline : in Boolean) is
   881.    begin
   882.       trap_illegal_IO_operation("POH", the_buffer, Q_operand, set_offline);
   883.    end POH;
   884.
   885.    procedure POK (the_buffer  : in out IOC.device;
   886.                   Q_operand   : in KDF9.Q_register;
   887.                   set_offline : in Boolean) is
   888.    begin
   889.       trap_illegal_IO_operation("POK", the_buffer, Q_operand, set_offline);
   890.    end POK;
   891.
   892.    procedure POL (the_buffer  : in out IOC.device;
   893.                   Q_operand   : in KDF9.Q_register;
   894.                   set_offline : in Boolean) is
   895.    begin
   896.       trap_illegal_IO_operation("POL", the_buffer, Q_operand, set_offline);
   897.    end POL;
   898.
   899. end IOC;

Compiling: ../Source/ioc.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:50

     1. -- Emulation of the common functionality of a KDF9 IOC "buffer" (DMA channel),
     2. --    with fail-stop stubs for operations having device-specific behaviour.
     3. --
     4. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with Ada.Finalization;
    19. --
    20. with KDF9;
    21.
    22. private with Ada.Exceptions;
    23. --
    24. private with exceptions;
    25. private with formatting;
    26. private with HCI;
    27. private with host_IO;
    28. private with KDF9_char_sets;
    29. private with KDF9.store;
    30. private with POSIX;
    31. private with settings;
    32.
    33. use  Ada.Finalization;
    34. --
    35. use  KDF9;
    36.
    37. package IOC is
    38.
    39.    -- N.B. the KDF9 'buffer' is a DMA controller in more modern terminology.
    40.
    41.    -- Each KDF9 buffer is externally characterized by:
    42.    --    its (absolute) number,
    43.    --    its (attached-device) kind, and
    44.    --    its unit (the number of that device within its kind).
    45.
    46.    -- A device of AD_kind is attached to a buffer with No Device connected.
    47.    -- If commanded, it performs a basic default action,
    48.    --    which is to cause a LIV interrupt in the case of transfers,
    49.    --       but is both benign and appropriate for all other operations.
    50.
    51.    type device_kind is
    52.       (CP_kind,  -- Card Punch
    53.        CR_kind,  -- Card Reader
    54.        DR_kind,  -- Drum
    55.        FD_kind,  -- Fixed Disc
    56.        FW_kind,  -- FlexoWriter (monitor typewriter)
    57.        GP_kind,  -- Graph Plotter (Calcomp 120' by 29.5" model)
    58.        LP_kind,  -- Line Printer
    59.        MT_kind,  -- Magnetic Tape
    60.        SI_kind,  -- Standard Interface buffer
    61.        ST_kind,  -- Seven Track (IBM) magnetic Tape
    62.        TP_kind,  -- Tape Punch
    63.        TR_kind,  -- Tape Reader
    64.        AD_kind   -- Absent Device
    65.       );
    66.
    67.    -- This is the number of the buffer a device is connected to.
    68.    subtype device_number is KDF9.Q_part range 0 .. 15;
    69.
    70.    -- This is the index of a device within devices of the type in the configuration.
    71.    subtype unit_number   is KDF9.Q_part range 0 .. 15;
    72.
    73.    -- An IOC.device_name is of the form XYu, where XY is a two-letter device-type code
    74.    --    and u is the logical unit number, in the range 0..F, of the device within its type.
    75.
    76.    subtype device_name is String(1..3);
    77.
    78. --
    79. --
    80.    -- This is the root for all I/O device types.
    81. --
    82. --
    83.
    84.    type device (number : IOC.device_number; unit : IOC.unit_number)
    85.    is abstract new Limited_Controlled with private;
    86.
    87.    -- The quantum is the time, in µs, taken to transfer a basic datum.
    88.    -- For unit-record devices (CR, CP, LP) this is the card/line.
    89.    -- For other devices it is the KDF9 character.
    90.    function quantum (the_buffer : IOC.device)
    91.    return KDF9.us
    92.    is abstract;
    93.
    94.    function kind (the_buffer : IOC.device)
    95.    return IOC.device_kind
    96.    is abstract;
    97.
    98.    -- This is overridden separately for fast and slow devices.
    99.    procedure add_in_the_IO_CPU_time (the_buffer  : in IOC.device;
   100.                                      bytes_moved : in KDF9.word)
   101.    is abstract;
   102.
   103.    -- True iff the_buffer has been opened but not yet closed.
   104.    -- It is overridden separately for magnetic tapes and all other devices.
   105.    function is_open (the_buffer : IOC.device)
   106.    return Boolean
   107.    is abstract;
   108.
   109.    -- A measure of the I/O volume transferred by the_buffer, so far.
   110.    function usage (the_buffer : IOC.device)
   111.    return KDF9.word;
   112.
   113.    -- Ensure that all output to the_buffer has been transmitted.
   114.    procedure flush (the_buffer : in out IOC.device);
   115.
   116.    -- Make the_buffer unavailable for further I/O use, after flushing if necessary.
   117.    procedure close (the_buffer : in out IOC.device);
   118.
   119.    -- A IOC.device_name is of the form XYn, where XY is a two-letter device-type
   120.    --    code (e.g., "LP" or "CR"); and n is the one-digit logical unit number
   121.    --       of a device within its category (n may be in hexadecimal).
   122.
   123.    function device_name_of (the_buffer : IOC.device)
   124.    return IOC.device_name;
   125.
   126.    function device_name_of (the_number : IOC.device_number)
   127.    return IOC.device_name;
   128.
   129.    function device_kind_of (the_number : IOC.device_number)
   130.    return IOC.device_kind;
   131.
   132.    -- Get the device-specific name of the I/O order, or the generic name if there isn't one.
   133.    function mnemonic (order : in String; class : in IOC.device_name)
   134.    return String;
   135.
   136.    -- An I/O operation may fail for two distict reasons:
   137.    -- 1. the order is illegal per se
   138.    -- 2. the order is legal, but is attempting an impossible effect.
   139.
   140.    -- trap_illegal_IO_operation fails the run because of an attempt to use an I/O order
   141.    --   that is illegal or undefined for the device concerned.
   142.    procedure trap_illegal_IO_operation (order       : in String;
   143.                                         buffer      : in IOC.device;
   144.                                         Q_operand   : in KDF9.Q_register;
   145.                                         set_offline : in Boolean)
   146.       with Inline => False;
   147.
   148.    -- trap_failing_IO_operation fails the run iff either:
   149.    -- 1. ee9 is running in a non-boot mode, because nothing more can usefully be done
   150.    -- OR
   151.    -- 2. Director is running, because an impossible operation implies a serious failure in Director.
   152.    --
   153.    -- In boot mode, when Director is not running, it sets the buffer abnormal and abandons the order.
   154.    -- It is then up to the problem program to act accordingly.  Failure to do so may LIV.
   155.
   156.    procedure trap_failing_IO_operation (the_buffer : in out IOC.device; the_message : in String)
   157.       with Inline => False;
   158.
   159.    procedure trap_failing_IO_operation (the_culprit : in String; the_message : in String)
   160.       with Inline => False;
   161.
   162.    -- The elapsed time for the I/O of the given number of atomic_items
   163.    --    which may be, e.g., bytes, or card images, or printer lines.
   164.    function IO_elapsed_time (the_buffer   : IOC.device;
   165.                              atomic_items : KDF9.word)
   166.    return KDF9.us;
   167.
   168.    -- The total elapsed time taken, so far, by transfers on the attached device.
   169.    function IO_elapsed_time_total (the_buffer : IOC.device)
   170.    return KDF9.us;
   171.
   172.
   173.    --
   174.    -- The CLOQq, SLOQq and TLOQq operations do NOT address a buffer,
   175.    --    and so are fully implemented elsewhere.
   176.    --
   177.
   178.    --
   179.    -- The INTQq, BUSYQq, PARQq and MANUALQq/CTQq operations DO address a buffer,
   180.    --    but do NOT initiate an I/O transfer, and are common to all devices,
   181.    --       so they operate on a class-wide parameter.
   182.    --
   183.
   184.    procedure INT (the_buffer  : in out IOC.device'Class;
   185.                   Q_operand   : in KDF9.Q_register;
   186.                   set_offline : in Boolean);
   187.
   188.    procedure BUSY (the_buffer  : in out IOC.device'Class;
   189.                    Q_operand   : in KDF9.Q_register;
   190.                    set_offline : in Boolean;
   191.                    result      : out Boolean);
   192.
   193.    procedure PAR (the_buffer   : in out IOC.device'Class;
   194.                    Q_operand   : in KDF9.Q_register;
   195.                    set_offline : in Boolean;
   196.                    result      : out Boolean);
   197.
   198.    procedure MANUAL_CT (the_buffer  : in out IOC.device'Class;
   199.                         Q_operand   : in KDF9.Q_register;
   200.                         set_offline : in Boolean);
   201.
   202.    -- These KDF9 data-transfer operations must be overridden for non-trivial functionality.
   203.    -- Invoking any of them raises a LIV exception. This exactly mirrors the action of the
   204.    --    KDF9 in causing a LIV interrupt when an invalid operation was applied to a device.
   205.    -- A device without some of these operations inherits them from this list and so
   206.    --    implements correctly the original semantics of the KDF9.
   207.
   208.    --
   209.    -- The PI* are input operations.
   210.    --
   211.
   212.    procedure PIA (the_buffer  : in out IOC.device;
   213.                   Q_operand   : in KDF9.Q_register;
   214.                   set_offline : in Boolean);
   215.
   216.    procedure PIB (the_buffer  : in out IOC.device;
   217.                   Q_operand   : in KDF9.Q_register;
   218.                   set_offline : in Boolean);
   219.
   220.    procedure PIC (the_buffer  : in out IOC.device;
   221.                   Q_operand   : in KDF9.Q_register;
   222.                   set_offline : in Boolean);
   223.
   224.    procedure PID (the_buffer  : in out IOC.device;
   225.                   Q_operand   : in KDF9.Q_register;
   226.                   set_offline : in Boolean);
   227.
   228.    procedure PIE (the_buffer  : in out IOC.device;
   229.                   Q_operand   : in KDF9.Q_register;
   230.                   set_offline : in Boolean);
   231.
   232.    procedure PIF (the_buffer  : in out IOC.device;
   233.                   Q_operand   : in KDF9.Q_register;
   234.                   set_offline : in Boolean);
   235.
   236.    procedure PIG (the_buffer  : in out IOC.device;
   237.                   Q_operand   : in KDF9.Q_register;
   238.                   set_offline : in Boolean);
   239.
   240.    procedure PIH (the_buffer  : in out IOC.device;
   241.                   Q_operand   : in KDF9.Q_register;
   242.                   set_offline : in Boolean);
   243.
   244.    --
   245.    -- The PM* are device-status operations.
   246.    --
   247.
   248.    procedure PMA (the_buffer  : in out IOC.device;
   249.                   Q_operand   : in KDF9.Q_register;
   250.                   set_offline : in Boolean);
   251.
   252.    procedure PMB (the_buffer  : in out IOC.device;
   253.                   Q_operand   : in KDF9.Q_register;
   254.                   set_offline : in Boolean);
   255.
   256.    procedure PMC (the_buffer  : in out IOC.device;
   257.                   Q_operand   : in KDF9.Q_register;
   258.                   set_offline : in Boolean);
   259.
   260.    procedure PMD (the_buffer  : in out IOC.device;
   261.                   Q_operand   : in KDF9.Q_register;
   262.                   set_offline : in Boolean);
   263.
   264.    procedure PME (the_buffer  : in out IOC.device;
   265.                   Q_operand   : in KDF9.Q_register;
   266.                   set_offline : in Boolean);
   267.
   268.    procedure PMF (the_buffer  : in out IOC.device;
   269.                   Q_operand   : in KDF9.Q_register;
   270.                   set_offline : in Boolean);
   271.
   272.    -- This is the mysterious "read C store" order.
   273.    procedure PMG (the_buffer  : in out IOC.device;
   274.                   Q_operand   : in KDF9.Q_register;
   275.                   set_offline : in Boolean);
   276.
   277. -- procedure PMH is implemented by SLO
   278.
   279.    procedure PMK (the_buffer  : in out IOC.device;
   280.                   Q_operand   : in KDF9.Q_register;
   281.                   set_offline : in Boolean);
   282.
   283.    procedure PML (the_buffer  : in out IOC.device;
   284.                   Q_operand   : in KDF9.Q_register;
   285.                   set_offline : in Boolean);
   286.
   287.    --
   288.    -- The PO* are output operations.
   289.    --
   290.
   291.    procedure POA (the_buffer  : in out IOC.device;
   292.                   Q_operand   : in KDF9.Q_register;
   293.                   set_offline : in Boolean);
   294.
   295.    procedure POB (the_buffer  : in out IOC.device;
   296.                   Q_operand   : in KDF9.Q_register;
   297.                   set_offline : in Boolean);
   298.
   299.    procedure POC (the_buffer  : in out IOC.device;
   300.                   Q_operand   : in KDF9.Q_register;
   301.                   set_offline : in Boolean);
   302.
   303.    procedure POD (the_buffer  : in out IOC.device;
   304.                   Q_operand   : in KDF9.Q_register;
   305.                   set_offline : in Boolean);
   306.
   307.    procedure POE (the_buffer  : in out IOC.device;
   308.                   Q_operand   : in KDF9.Q_register;
   309.                   set_offline : in Boolean);
   310.
   311.    procedure POF (the_buffer  : in out IOC.device;
   312.                   Q_operand   : in KDF9.Q_register;
   313.                   set_offline : in Boolean);
   314.
   315.    procedure POG (the_buffer  : in out IOC.device;
   316.                   Q_operand   : in KDF9.Q_register;
   317.                   set_offline : in Boolean);
   318.
   319.    procedure POH (the_buffer  : in out IOC.device;
   320.                   Q_operand   : in KDF9.Q_register;
   321.                   set_offline : in Boolean);
   322.
   323.    procedure POK (the_buffer  : in out IOC.device;
   324.                   Q_operand   : in KDF9.Q_register;
   325.                   set_offline : in Boolean);
   326.
   327.    procedure POL (the_buffer  : in out IOC.device;
   328.                   Q_operand   : in KDF9.Q_register;
   329.                   set_offline : in Boolean);
   330.
   331.
   332. --
   333. --
   334.    -- The buffer_configuration type enables the dynamic setting-up of a complement of I/O devices.
   335. --
   336. --
   337.
   338.    type device_class_access  is access all IOC.device'Class;
   339.
   340.    type buffer_configuration is array (KDF9.buffer_number) of IOC.device_class_access;
   341.
   342.    -- These are the I/O devices installed in this configuration.
   343.    -- Each device installs itself into the configuration when the device is initialized.
   344.
   345.    buffer : buffer_configuration;
   346.
   347. --
   348.    -- These operations are used by Directors to manage device allocation to problem programs.
   349. --
   350.
   351.    procedure set_state_of (the_buffer : in device_class_access;
   352.                            allocated  : in Boolean);
   353.
   354.    function is_allocated (the_buffer : device_class_access)  -- N.B. IS_allocated.
   355.    return Boolean;
   356.
   357.    function is_unallocated (the_buffer : device_class_access)  -- N.B. is_UNallocated.
   358.    return Boolean;
   359.
   360. --
   361.    -- These buffer-implementation operations are used outside IOC and apply to all device types.
   362. --
   363.
   364.    -- Complete all extant transfers, then Finalize each buffer.
   365.    procedure finalize_all_KDF9_buffers;
   366.
   367.    -- Advance the elapsed time to a point after all extant transfer have terminated.
   368.    procedure complete_all_extant_transfers;
   369.
   370.    -- Complete any terminated transfer operations and take any needed interrupts.
   371.    procedure act_on_pending_interrupts;
   372.
   373.    -- Handle non-data transfer operations on busy device.
   374.    procedure deal_with_a_busy_device (the_buffer  : in out IOC.device'Class;
   375.                                       order_time  : in KDF9.us;
   376.                                       set_offline : in Boolean);
   377.
   378.    -- A LOV interupt caused by an attempted store access must arrange
   379.    --    for the interrupted instruction to be resumed.
   380.    -- In boot mode, effect the LOV interrupt to Director.
   381.    -- In other modes, advance the elapsed time to the end-of-transfer time
   382.    --    for the_locked_out_address, then act on pending interrupts.
   383.    procedure handle_a_main_store_lockout;
   384.
   385.    type transfer_kind  is (input_operation,
   386.                            output_operation,
   387.                            control_operation,
   388.                            some_other_operation);
   389.
   390.    -- Take note of the start of a transfer.
   391.    -- For I/O operations that do not entail an actual data transfer,
   392.    --    such as testing a buffer for a graph plotter,
   393.    --    set the busy time to the order's MC execution time.
   394.    -- This keeps elapsed time in sync with CPU time,
   395.    --    and ensures that the operation waits for any preceding transfer
   396.    --    on the same buffer to complete before the test is actioned.
   397.    procedure start_data_transfer (the_buffer  : in out IOC.device'Class;
   398.                                   Q_operand   : in KDF9.Q_register;
   399.                                   set_offline : in Boolean;
   400.                                   busy_time   : in KDF9.us;
   401.                                   operation   : in IOC.transfer_kind := IOC.some_other_operation);
   402.
   403. private
   404.
   405.    use Ada.Exceptions; pragma Warnings(Off, Ada.Exceptions);
   406.    --
   407.    use exceptions;     pragma Warnings(Off, exceptions);
   408.    use formatting;     pragma Warnings(Off, formatting);
   409.    use HCI;            pragma Warnings(Off, HCI);
   410.    use host_IO;        pragma Warnings(Off, host_IO);
   411.    use KDF9_char_sets; pragma Warnings(Off, KDF9_char_sets);
   412.    use KDF9.store;     pragma Warnings(Off, KDF9.store);
   413.    use settings;       pragma Warnings(Off, settings);
   414.
   415.    use POSIX;          -- Used here, so no need to suppress warnings.
   416.
   417.    type device (number : IOC.device_number; unit : IOC.unit_number)
   418.    is abstract new Limited_Controlled with
   419.       record
   420.          is_abnormal,
   421.          is_busy,
   422.          is_offline,
   423.          is_allocated,
   424.          is_for_Director : Boolean := False;
   425.          operation       : IOC.transfer_kind := IOC.some_other_operation;
   426.          initiation_time : KDF9.us := KDF9.us'Last;
   427.          transfer_time   : KDF9.us := KDF9.us'Last;
   428.          completion_time : KDF9.us := KDF9.us'Last;
   429.          priority_level  : KDF9.priority;
   430.          control_word    : KDF9.Q_register;
   431.          decoded_order   : KDF9.decoded_order;
   432.          device_name     : IOC.device_name;
   433.          order_address   : KDF9.syllable_address;
   434.          order_count     : KDF9.order_counter;
   435.          stream          : host_IO.stream;
   436.       end record;
   437.
   438.    overriding
   439.    procedure Initialize (the_buffer : in out IOC.device);
   440.
   441.    procedure open (the_buffer : in out IOC.device'Class;
   442.                    the_mode   : in POSIX.access_mode);
   443.
   444.    overriding
   445.    procedure Finalize (the_buffer : in out IOC.device)
   446.       with Inline => False;
   447.
   448.    -- Operations, used only within the IOC hierarchy, that apply to all device types.
   449.
   450.    -- Check that the buffer for the_device is unused, then set it to the_device.
   451.    procedure install (the_device : in out IOC.device'Class);
   452.
   453.    -- LIV if the_buffer is in the abnormal state.
   454.    procedure validate_parity (the_buffer : in IOC.device'Class)
   455.       with Inline => False;
   456.
   457.    -- Check that the_buffer is online, and that access to it is permitted; LIV if not.
   458.    procedure validate_device (the_buffer : in IOC.device'Class)
   459.       with Inline => False;
   460.
   461.    -- Check that the device and the transfer address bounds are valid;
   462.    --    LIV if not.
   463.    procedure validate_transfer (the_buffer : in IOC.device'Class;
   464.                                 Q_operand  : in KDF9.Q_register);
   465.
   466.    -- When the real duration of a variable-length transfer is known,
   467.    --    its completion time can be made accurate by giving its actual_time.
   468.    -- correct_transfer_time must be called before finalize_transfer is called.
   469.    procedure correct_transfer_time (the_buffer  : in out IOC.device'Class;
   470.                                     actual_time : in KDF9.us);
   471.
   472.    procedure correct_transfer_time (the_buffer    : in out IOC.device'Class;
   473.                                     actual_length : in KDF9.word);
   474.
   475.    -- LIV if the repetition count is negative.
   476.    procedure require_nonnegative_count (count : in KDF9.Q_part);
   477.
   478.    -- LIV if the repetition count is negative or zero.
   479.    procedure require_positive_count (count : in KDF9.Q_part);
   480.
   481.    -- Account for the CPU time taken by the buffer in setting store lockouts.
   482.    procedure add_in_the_IO_lockout_CPU_time (Q_operand : in KDF9.Q_register);
   483.
   484.    -- These are handy to have in the child packages.
   485.    NUL : constant Character := Character'Val(0);
   486.    BEL : constant Character := Character'Val(7);
   487.    HT  : constant Character := Character'Val(9);
   488.    LF  : constant Character := Character'Val (10);
   489.    FF  : constant Character := Character'Val (12);
   490.    ESC : constant Character := Character'Val (27);
   491.    SP  : constant Character := ' ';
   492.    DEL : constant Character := Character'Val (127);
   493.
   494. end IOC;

 899 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-equipment.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:50

     1. -- Data supporting the definition of a KDF9 I/O equipment configuration.
     2. --
     3. --
     4. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with IOC.absent;
    19. with IOC.fast.DR;
    20. with IOC.fast.FD;
    21. with IOC.fast.tape;
    22. with IOC.slow.shift.FW;
    23. with IOC.slow.shift.GP;
    24. with IOC.slow.shift.SI;
    25. with IOC.slow.shift.TP;
    26. with IOC.slow.shift.TR;
    27. with IOC.slow.unit.CP;
    28. with IOC.slow.unit.CR;
    29. with IOC.slow.unit.LP;
    30. with settings;
    31.
    32. package body IOC.equipment is
    33.
    34.    procedure configure_the_IOC is
    35.    begin
    36.       for b in KDF9.buffer_number loop
    37.          case equipment.choice(b) is
    38.             when AD => IOC.absent.enable(b);
    39.             when CP => IOC.slow.unit.CP.enable(b);
    40.             when CR => IOC.slow.unit.CR.enable(b);
    41.             when DR => IOC.fast.DR.enable(b);
    42.             when FD => IOC.fast.FD.enable(b);
    43.             when FW => IOC.slow.shift.FW.enable(b);
    44.             when GP => IOC.slow.shift.TP.remove_from_buffer(b);
    45.                        IOC.slow.shift.GP.enable(b);
    46.             when LP => IOC.slow.unit.LP.enable(b);
    47.             when MT => IOC.fast.tape.enable_MT_deck(b);
    48.             when SI => IOC.slow.shift.SI.enable(b);
    49.             when ST => IOC.fast.tape.enable_ST_deck(b);
    50.             when TP => IOC.slow.shift.TP.enable(b);
    51.             when TR => IOC.slow.shift.TR.enable(b);
    52.          end case;
    53.          if buffer(b) = null then
    54.             IOC.absent.enable(b);
    55.          end if;
    56.       end loop;
    57.       -- By this point every buffer must have an attached device.
    58.       if IOC.buffer(0).kind /= IOC.FW_kind then
    59.          trap_operator_error("buffer #00 must be a FW");
    60.       end if;
    61.       if IOC.buffer(1).kind /= IOC.TR_kind then
    62.          trap_operator_error("buffer #01 must be a TR");
    63.       end if;
    64.    end configure_the_IOC;
    65.
    66.    procedure revise_the_IOC_configuration is
    67.    begin
    68.       -- By this point every buffer has a device which should be removed before it is replaced.
    69.       for b in equipment.choice'Range loop
    70.          case equipment.choice(b) is
    71.             when DR => IOC.fast.FD.remove_from_buffer(b);
    72.                        IOC.fast.DR.replace_on_buffer(b);
    73.             when FD => IOC.fast.DR.remove_from_buffer(b);
    74.                        IOC.fast.FD.replace_on_buffer(b);
    75.             when GP => if buffer(b).device_name = "TP1" then
    76.                           IOC.slow.shift.TP.remove_from_buffer(b);
    77.                           IOC.slow.shift.GP.replace_on_buffer(b);
    78.                        end if;
    79.             when SI => IOC.slow.shift.SI.replace_on_buffer(b);
    80.             when others => null;
    81.          end case;
    82.       end loop;
    83.    end revise_the_IOC_configuration;
    84.
    85. end IOC.equipment;

Compiling: ../Source/ioc-equipment.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:50

     1. -- Enable the devices included in the chosen KDF9 I/O configuration.
     2. --
     3. --
     4. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with KDF9;
    19.
    20. package IOC.equipment is
    21.
    22.    -- These variables are used in the emulation of OUT 5.
    23.    -- They are set to the device buffer number at the start of each run by configure_the_IOC.
    24.    -- A value of 0 indicates that the device is not included in the configuration for the run.
    25.    -- Fast devices are not allocated by this mechanism and so do not appear here.
    26.
    27.    CP0_number  : KDF9.buffer_number := 0;
    28.    CP1_number  : KDF9.buffer_number := 0;
    29.    CR0_number  : KDF9.buffer_number := 0;
    30.    CR1_number  : KDF9.buffer_number := 0;
    31.    GP0_number  : KDF9.buffer_number := 0;
    32.    LP0_number  : KDF9.buffer_number := 0;
    33.    LP1_number  : KDF9.buffer_number := 0;
    34.    SI0_number  : KDF9.buffer_number := 0;
    35.    SI1_number  : KDF9.buffer_number := 0;
    36.    TP0_number  : KDF9.buffer_number := 0;
    37.    TP1_number  : KDF9.buffer_number := 0;
    38.    TR0_number  : KDF9.buffer_number := 0;
    39.    TR1_number  : KDF9.buffer_number := 0;
    40.
    41.    type kind   is (AD, CP, CR, DR, FD, FW, GP, LP, MT, SI, ST, TP, TR);
    42.
    43.    type setup  is array (KDF9.buffer_number) of equipment.kind;
    44.
    45.    -- These are the buffer numbers for the devices in the default configuration.
    46.    -- The Fixed Disc drive was on buffer 14 (#16) of Eldon 2 KDF9s, so I adopt that here.
    47.
    48.    FW0_default : constant KDF9.buffer_number := 0;
    49.    TR0_default : constant KDF9.buffer_number := 1;
    50.    TR1_default : constant KDF9.buffer_number := 2;
    51.    TP0_default : constant KDF9.buffer_number := 3;
    52.    TP1_default : constant KDF9.buffer_number := 4;
    53.    LP0_default : constant KDF9.buffer_number := 5;
    54.    CR0_default : constant KDF9.buffer_number := 6;
    55.    CP0_default : constant KDF9.buffer_number := 7;
    56.    MT0_default : constant KDF9.buffer_number := 8;
    57.    MT1_default : constant KDF9.buffer_number := 9;
    58.    MT2_default : constant KDF9.buffer_number := 10;
    59.    MT3_default : constant KDF9.buffer_number := 11;
    60.    MT4_default : constant KDF9.buffer_number := 12;
    61.    MT5_default : constant KDF9.buffer_number := 13;
    62.    DR0_default : constant KDF9.buffer_number := 14;
    63.    FD0_default : constant KDF9.buffer_number := 14;
    64.    ST0_default : constant KDF9.buffer_number := 15;
    65.
    66.    default : constant equipment.setup
    67.            := (
    68.                CP0_default => CP,
    69.                CR0_default => CR,
    70.                FD0_default => FD,
    71.                FW0_default => FW,
    72.                LP0_default => LP,
    73.                MT0_default => MT,
    74.                MT1_default => MT,
    75.                MT2_default => MT,
    76.                MT3_default => MT,
    77.                MT4_default => MT,
    78.                MT5_default => MT,
    79.                ST0_default => ST,
    80.                TP0_default => TP,
    81.                TP1_default => TP,
    82.                TR0_default => TR,
    83.                TR1_default => TR
    84.               );
    85.
    86.    choice  : equipment.setup := default;
    87.
    88.    -- Attach the chosen devices to their buffers.
    89.    procedure configure_the_IOC;
    90.
    91.    -- If a drum, disc or BSI has been enabled on the command line, make sure it is installed.
    92.    procedure revise_the_IOC_configuration;
    93.
    94. end IOC.equipment;

 85 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of the common functionality of a KDF9 "slow", byte-by-byte, devices.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with HCI;
    18. with OS_specifics;
    19. with imported_value_of;
    20.
    21. use HCI;
    22.
    23. package body IOC.slow is
    24.
    25.    overriding
    26.    function is_open (the_buffer : slow.device)
    27.    return Boolean
    28.    is (the_buffer.stream.is_open);
    29.
    30.    overriding
    31.    procedure add_in_the_IO_CPU_time (the_buffer  : in slow.device;
    32.                                      bytes_moved : in KDF9.word) is
    33.       pragma Unreferenced(the_buffer);
    34.    begin
    35.       the_CPU_delta := the_CPU_delta + KDF9.us(bytes_moved) * 6; -- 6µs/char
    36.    end add_in_the_IO_CPU_time;
    37.
    38.    procedure display_device_usage (the_buffer  : in slow.device;
    39.                                    the_action  : in String;
    40.                                    the_amount  : in KDF9.word;
    41.                                    the_quantum : in String) is
    42.    begin
    43.          if the_final_state_is_wanted and then
    44.                the_log_is_wanted      and then
    45.                   the_buffer.is_open  and then
    46.                the_amount /= 0            then
    47.          if (the_buffer.number = 0) and not (API_logging_is_wanted or the_log_is_wanted) then
    48.             -- Take a new line at the head of the list, for low-visibility modes.
    49.             log_new_line;
    50.          end if;
    51.          log_line(
    52.                   the_buffer.device_name
    53.                 & " on buffer #"
    54.                 & oct_of(KDF9.Q_part(the_buffer.number), 2)
    55.                 & " "
    56.                 & the_action
    57.                 & the_amount'Image
    58.                 & " "
    59.                 & the_quantum
    60.                 & "."
    61.                  );
    62.       end if;
    63.    end display_device_usage;
    64.
    65.    procedure close (the_buffer  : in out slow.device;
    66.                     the_action  : in String;
    67.                     the_amount  : in KDF9.word;
    68.                     the_quantum : in String) is
    69.    begin
    70.       display_device_usage (the_buffer, the_action, the_amount, the_quantum);
    71.       IOC.device(the_buffer).close;
    72.    end close;
    73.
    74.    function atomic_item_count (the_buffer : slow.device;
    75.                                Q_operand  : KDF9.Q_register)
    76.    return KDF9.word is
    77.       words : constant KDF9.Q_part := Q_operand.M - Q_operand.I + 1;
    78.    begin
    79.       if the_buffer.is_open then
    80.          return KDF9.word(words) * 8;
    81.       else
    82.          return 0;
    83.       end if;
    84.    end atomic_item_count;
    85.
    86.    procedure reattach (the_buffer   : in out slow.device;
    87.                        the_file     : in String) is
    88.    begin
    89.       reattach(the_buffer.stream, the_file, read_mode);
    90.    end reattach;
    91.
    92.    procedure deal_with_end_of_data (the_buffer : in out slow.device) is
    93.
    94.       procedure reattach_the_text_file (name : in String) is
    95.       begin
    96.          if name = "" then
    97.             the_buffer.is_abnormal := True;
    98.             raise end_of_stream;
    99.          elsif exists(name) then
   100.             reattach(the_buffer, name);
   101.             return;
   102.          elsif exists(name & ".txt") then
   103.             reattach(the_buffer, name & ".txt");
   104.             return;
   105.          else
   106.             raise operator_error;
   107.          end if;
   108.       end reattach_the_text_file;
   109.
   110.       response : response_kind;
   111.
   112.    begin
   113.       output_line(BEL & "");
   114.       output_line("ee9: End of given data for " & the_buffer.device_name & ".");
   115.       loop
   116.          POSIX.data_prompt(
   117.                            noninteractive_usage_is_enabled,
   118.                            "Type @ or / to name a file, = to type the data, ENTER key for EOF, Q or q to quit",
   119.                            response
   120.                           );
   121.          case response is
   122.             when wrong_response =>
   123.                null;  -- repeat the prompt
   124.             when LF_response
   125.                | EOF_response =>
   126.                if response = EOF_response then
   127.                   -- Need to take a new line after ^D to preserve the format.
   128.                   output_line;
   129.                end if;
   130.                the_buffer.is_abnormal := True;
   131.                raise end_of_stream;
   132.             when quit_response =>
   133.                raise quit_request with "quit requested";
   134.             when here_response =>
   135.                reattach(the_buffer, OS_specifics.UI_in_name);
   136.                the_buffer.is_reading_a_file := False;
   137.                return;
   138.             when at_response =>
   139.                declare
   140.                   here : constant String := imported_value_of("KDF9_DATA", default => "Data") & "/";
   141.                   next : constant String := next_file_name(BEL & "Give the name of a file in " & here);
   142.                begin
   143.                   reattach_the_text_file(here & next);
   144.                   return;
   145.                exception
   146.                   when operator_error =>
   147.                      output_line(BEL & "ee9: The file «"& here & next & "» could not be found");
   148.                end;
   149.             when name_response =>
   150.                declare
   151.                   next : constant String := next_file_name(BEL & "Give the pathname of the file");
   152.                begin
   153.                   reattach_the_text_file(next);
   154.                   return;
   155.                exception
   156.                   when operator_error =>
   157.                      output_line(BEL & "ee9: The file «"& next & "» could not be found");
   158.                end;
   159.          end case;
   160.       end loop;
   161.    end deal_with_end_of_data;
   162.
   163.    procedure start_slow_transfer (the_buffer   : in out slow.device;
   164.                                   Q_operand    : in KDF9.Q_register;
   165.                                   set_offline  : in Boolean;
   166.                                   operation    : in IOC.transfer_kind := some_other_operation) is
   167.       atomic_items : constant KDF9.word := atomic_item_count(the_buffer, Q_operand);
   168.       time_needed  : constant KDF9.us := IO_elapsed_time(the_buffer, atomic_items);
   169.    begin
   170.       start_data_transfer(the_buffer, Q_operand, set_offline,
   171.                           busy_time => time_needed,
   172.                           operation => start_slow_transfer.operation);
   173.    end start_slow_transfer;
   174.
   175.    procedure get_char_from_stream (char       : out Character;
   176.                                    the_buffer : in out slow.device) is
   177.    begin
   178.       loop
   179.          begin
   180.             get_char(char, the_buffer.stream);
   181.             return;
   182.          exception
   183.             when end_of_stream =>
   184.                deal_with_end_of_data(the_buffer);
   185.          end;
   186.       end loop;
   187.    end get_char_from_stream;
   188.
   189. end IOC.slow;

Compiling: ../Source/ioc-slow.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of the common functionality of a KDF9 "slow", i.e. byte-by-byte, devices.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. private with IOC.equipment;
    18. private with tracing;
    19.
    20. package IOC.slow is
    21.
    22.    --
    23.    -- This is the root type for all slow I/O device types.
    24.    --
    25.
    26.    type device is abstract new IOC.device with private;
    27.
    28.    -- Log the usage statistics for the device on the buffer.
    29.    procedure display_device_usage (the_buffer  : in slow.device;
    30.                                    the_action  : in String;
    31.                                    the_amount  : in KDF9.word;
    32.                                    the_quantum : in String);
    33.
    34.    -- Change the file associated with a device.
    35.    procedure reattach (the_buffer : in out slow.device;
    36.                        the_file   : in String);
    37.
    38. private
    39.
    40.    use IOC.equipment; pragma Warnings(Off, IOC.equipment);
    41.    use tracing;       pragma Warnings(Off, tracing);
    42.
    43.    type device is abstract new IOC.device with
    44.       record
    45.          is_transcribing   : Boolean := True;
    46.          is_reading_a_file : Boolean := True;
    47.          byte_count        : KDF9.word := 0;
    48.       end record;
    49.
    50.    overriding
    51.    function is_open (the_buffer : slow.device)
    52.    return Boolean;
    53.
    54.    overriding
    55.    procedure add_in_the_IO_CPU_time (the_buffer  : in slow.device;
    56.                                      bytes_moved : in KDF9.word);
    57.
    58.    -- Optionally log an activity message for the device; close its I/O stream.
    59.    procedure close (the_buffer  : in out slow.device;
    60.                     the_action  : in String;
    61.                     the_amount  : in KDF9.word;
    62.                     the_quantum : in String);
    63.
    64.    -- The number of timed transfer units in the designated core-store area.
    65.    -- In the case of unit-record devices, such as card readers and line printers,
    66.    --    this is the number of unit records (cards, or lines, respectively).
    67.    -- In all other cases it is the number of characters in the designated core-store area.
    68.    function atomic_item_count (the_buffer : slow.device;
    69.                                Q_operand  : KDF9.Q_register)
    70.    return KDF9.word;
    71.
    72.    -- Check the IO parameters and the buffer state, and handle any old lockout.
    73.    -- Set the new buffer state, and project the next interrupt time.
    74.    procedure start_slow_transfer (the_buffer   : in out slow.device;
    75.                                   Q_operand    : in KDF9.Q_register;
    76.                                   set_offline  : in Boolean;
    77.                                   operation    : in IOC.transfer_kind := some_other_operation);
    78.
    79.    procedure deal_with_end_of_data (the_buffer : in out slow.device);
    80.
    81.    -- Read a raw byte from the stream and deal with any input file concatenation.
    82.    procedure get_char_from_stream (char       : out Character;
    83.                                    the_buffer : in out slow.device);
    84.
    85. end IOC.slow;

 189 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-slow-shift.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of the common functionality of a 2-case (Normal/Shift) buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets.framed;
    18.
    19. package body IOC.slow.shift is
    20.
    21.    use KDF9_char_sets;
    22.
    23.    overriding
    24.    procedure Initialize (the_device : in out shift.device) is
    25.    begin
    26.       -- Open the associated file.
    27.       open(the_device, read_mode);
    28.    end Initialize;
    29.
    30.    procedure do_input_housekeeping (the_device : in out shift.device;
    31.                                     read_in,
    32.                                     stored     : in KDF9.word) is
    33.    begin
    34.       add_in_the_IO_CPU_time(the_device, stored);
    35.       correct_transfer_time(the_device, read_in);
    36.       the_device.byte_count := the_device.byte_count + read_in;
    37.    end do_input_housekeeping;
    38.
    39.    procedure get_symbols (the_device    : in out shift.device;
    40.                           Q_operand     : in KDF9.Q_register;
    41.                           reading_to_EM : in Boolean) is
    42.       start_address : constant KDF9.address := Q_operand.I;
    43.       end_address   : constant KDF9.address := Q_operand.M;
    44.       fill   : KDF9.word := 0;
    45.       size   : KDF9.word := 0;
    46.       symbol : KDF9_char_sets.symbol;
    47.       char   : Character;
    48.    begin
    49.       check_addresses_and_lockouts(start_address, end_address);
    50.    word_loop:
    51.       for w in start_address .. end_address loop
    52.          store_word(0, w);
    53.          for c in KDF9_char_sets.symbol_index'Range loop
    54.             get_char_from_stream(char, the_device);
    55.             size := size + 1;
    56.             if char = KDF9_char_sets.W_F then
    57.                -- Filler was suppressed on normal input from the slow devices.
    58.                fill := fill + 1;
    59.             elsif case_of(char) /= both                   and then
    60.                      case_of(char) /= the_device.current_case then
    61.                store_symbol(CN_TR(next_case(the_device.current_case)), w, c);
    62.                the_device.current_case := the_device.current_case xor 1;
    63.                back_off(the_device.stream);
    64.             else
    65.                symbol := CN_TR(char) or CS_TR(char);
    66.                store_symbol(symbol, w, c);
    67.                if reading_to_EM and symbol = KDF9_char_sets.End_Message then
    68.                   for d in 1 .. 7-c loop
    69.                      store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
    70.                   end loop;
    71.                   exit word_loop;
    72.                end if;
    73.             end if;
    74.          end loop;
    75.       end loop word_loop;
    76.       do_input_housekeeping(the_device, read_in => size, stored => size-fill);
    77.    exception
    78.       when end_of_stream =>
    79.          flush(the_device.stream);
    80.          do_input_housekeeping(the_device, read_in => size, stored => size-fill);
    81.    end get_symbols;
    82.
    83.    procedure read (the_device : in out shift.device;
    84.                    Q_operand  : in KDF9.Q_register) is
    85.    begin
    86.       get_symbols(the_device, Q_operand, reading_to_EM => False);
    87.    end read;
    88.
    89.    procedure read_to_EM (the_device : in out shift.device;
    90.                          Q_operand  : in KDF9.Q_register) is
    91.    begin
    92.       get_symbols(the_device, Q_operand, reading_to_EM => True);
    93.    end read_to_EM;
    94.
    95.    procedure get_frame_from_stream (frame      : out Character;
    96.                                     the_device : in out shift.device) is
    97.    begin
    98.       loop
    99.          begin
   100.             get_byte(frame, the_device.stream);
   101.             if the_device.is_reading_a_file then
   102.                -- Assume file, in KDF9 paper tape code, contains all needed shift characters.
   103.                return;
   104.             end if;
   105.             -- Reading from the terminal, the frame is in Latin-1 and must be converted.
   106.             -- This may entail interpolating a shift character.
   107.             if case_of(frame) not in both | the_device.current_case then
   108.                frame := framed(CN_TR(next_case(the_device.current_case)));
   109.                the_device.current_case := the_device.current_case xor 1;
   110.                back_off(the_device.stream);
   111.             elsif the_device.current_case = KDF9_char_sets.Case_Normal then
   112.                frame := framed(CN_TR(frame));
   113.             else
   114.                frame := framed(CS_TR(frame));
   115.             end if;
   116.             return;
   117.          exception
   118.             when end_of_stream =>
   119.                deal_with_end_of_data(the_device);
   120.          end;
   121.       end loop;
   122.    end get_frame_from_stream;
   123.
   124.    procedure get_words (the_device    : in out shift.device;
   125.                         Q_operand     : in KDF9.Q_register;
   126.                         reading_to_EM : in Boolean) is
   127.
   128.       function deframed (byte : Character)
   129.       return KDF9.word is
   130.          data : KDF9.word;
   131.       begin -- deframed
   132.          -- Permute the paper tape frame bits, see the Manual, § 17.7, pp. 137-138.
   133.          data := KDF9.word(Character'Pos(byte));
   134.          return  (data and 2#0000_1111#)    -- D44-D47 -> D44-D47
   135.               or (data and 2#0110_0000#)/2  -- D41-D42 -> D42-D43
   136.               or (data and 2#0001_0000#)*4  -- D43     -> D41
   137.               or (data and 2#1000_0000#);   -- D40     -> D40
   138.       end deframed;
   139.
   140.       start_address : constant KDF9.address := Q_operand.I;
   141.       end_address : constant KDF9.address := Q_operand.M;
   142.       size        : KDF9.word := 0;
   143.       word        : KDF9.word;
   144.       done        : Boolean;
   145.       char        : Character;
   146.
   147.    begin -- get_words
   148.       check_addresses_and_lockouts(start_address, end_address);
   149.       for w in start_address .. end_address loop
   150.          if the_device.is_transcribing then
   151.             -- "transcribing" actually means "transparent" for character mode input.
   152.             get_char_from_stream(char, the_device);
   153.             word := KDF9.word(Character'Pos(char));
   154.             done := char = E_M;
   155.          else
   156.             -- KDF9 mode.
   157.             get_frame_from_stream(char, the_device);
   158.             word := deframed(char);
   159.             done := KDF9_char_sets.symbol(word and 8#77#) = End_Message;
   160.          end if;
   161.          store_word(word, w);
   162.          size := size + 1;
   163.       exit when reading_to_EM and done;
   164.       end loop;
   165.       do_input_housekeeping(the_device, read_in => size, stored => size);
   166.    exception
   167.       when end_of_stream =>
   168.          flush(the_device.stream);
   169.          do_input_housekeeping(the_device, read_in => size, stored => size);
   170.    end get_words;
   171.
   172.    procedure words_read (the_device : in out shift.device;
   173.                          Q_operand  : in KDF9.Q_register) is
   174.    begin
   175.       get_words(the_device, Q_operand, reading_to_EM => False);
   176.    end words_read;
   177.
   178.    procedure words_read_to_EM (the_device : in out shift.device;
   179.                                Q_operand  : in KDF9.Q_register) is
   180.    begin
   181.       get_words(the_device, Q_operand, reading_to_EM => True);
   182.    end words_read_to_EM;
   183.
   184.    procedure put_symbols (the_device    : in out shift.device;
   185.                           Q_operand     : in KDF9.Q_register;
   186.                           writing_to_EM : in Boolean) is
   187.       start_address : constant KDF9.address := Q_operand.I;
   188.       end_address   : constant KDF9.address := Q_operand.M;
   189.       fill   : KDF9.word := 0;
   190.       size   : KDF9.word := 0;
   191.       symbol : KDF9_char_sets.symbol;
   192.       char   : Character;
   193.    begin
   194.       check_addresses_and_lockouts(start_address, end_address);
   195.    word_loop:
   196.       for w in start_address .. end_address loop
   197.          for c in KDF9_char_sets.symbol_index'Range loop
   198.             symbol := fetch_symbol(w, c);
   199.             size := size + 1;
   200.             if symbol = KDF9_char_sets.Word_Filler then
   201.                -- Filler was suppressed on normal output to the slow devices.
   202.                fill := fill + 1;
   203.             elsif symbol = KDF9_char_sets.Case_Shift then
   204.                the_device.current_case := KDF9_char_sets.Case_Shift;
   205.             elsif  symbol = KDF9_char_sets.Case_Normal then
   206.                the_device.current_case := KDF9_char_sets.Case_Normal;
   207.             else
   208.                if the_device.current_case = KDF9_char_sets.Case_Normal then
   209.                   char := TP_CN(symbol);
   210.                else
   211.                   char := TP_CS(symbol);
   212.                end if;
   213.                put_char(char, the_device.stream);
   214.                exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
   215.             end if;
   216.          end loop;
   217.       end loop word_loop;
   218.       do_output_housekeeping(the_device, written => size-fill, fetched => size);
   219.    exception
   220.       when end_of_stream =>
   221.          do_output_housekeeping(the_device, written => size-fill, fetched => size);
   222.    end put_symbols;
   223.
   224.    procedure write (the_device : in out shift.device;
   225.                     Q_operand  : in KDF9.Q_register) is
   226.    begin
   227.       put_symbols(the_device, Q_operand, writing_to_EM => False);
   228.    end write;
   229.
   230.    procedure write_to_EM (the_device : in out shift.device;
   231.                           Q_operand  : in KDF9.Q_register) is
   232.    begin
   233.       put_symbols(the_device, Q_operand, writing_to_EM => True);
   234.    end write_to_EM;
   235.
   236.    procedure put_words (the_device    : in out shift.device;
   237.                         Q_operand     : in KDF9.Q_register;
   238.                         writing_to_EM : in Boolean) is
   239.
   240.       function reframed (byte : Character)
   241.       return Character is
   242.          data : KDF9.word:= KDF9.word(Character'Pos(byte));
   243.       begin -- reframed
   244.          -- Permute the paper tape frame bits, see the Manual, § 17.7, pp. 137-138.
   245.          data := (data and 2#0000_1111#)    -- D44-D47 -> D44-D47
   246.               or (data and 2#0011_0000#)*2  -- D42-D43 -> D41-D42
   247.               or (data and 2#0100_0000#)/4  -- D41     -> D43
   248.               or (data and 2#1000_0000#);   -- D40     -> D40
   249.          return Character'Val(Natural(data));
   250.       end reframed;
   251.
   252.       start_address : constant KDF9.address := Q_operand.I;
   253.       end_address   : constant KDF9.address := Q_operand.M;
   254.       size : KDF9.word := 0;
   255.       done : Boolean;
   256.       char : Character;
   257.
   258.    begin -- put_words
   259.       check_addresses_and_lockouts(start_address, end_address);
   260.       for w in start_address .. end_address loop
   261.          char := Character'Val(fetch_word(w) and 8#377#);
   262.          if the_device.is_transcribing then
   263.             -- "transcribing" actually means "transparent Latin-1" for character mode transfers.
   264.             done := char = E_M;
   265.          else
   266.             -- KDF9 mode.
   267.             char := reframed(char);
   268.             done := KDF9_char_sets.symbol(Character'Pos(char) mod 64) = End_Message;
   269.          end if;
   270.          put_byte(char, the_device.stream);
   271.          size := size + 1;
   272.       exit when writing_to_EM and done;
   273.       end loop;
   274.       do_output_housekeeping(the_device, written => size, fetched => size);
   275.    end put_words;
   276.
   277.    procedure words_write (the_device : in out shift.device;
   278.                           Q_operand  : in KDF9.Q_register) is
   279.    begin
   280.       put_words(the_device, Q_operand, writing_to_EM => False);
   281.    end words_write;
   282.
   283.    procedure words_write_to_EM (the_device : in out shift.device;
   284.                                 Q_operand  : in KDF9.Q_register) is
   285.    begin
   286.       put_words(the_device, Q_operand, writing_to_EM => True);
   287.    end words_write_to_EM;
   288.
   289.    procedure output_a_gap (the_device   : in out shift.device;
   290.                            Q_operand    : in KDF9.Q_register;
   291.                            set_offline  : in Boolean;
   292.                            word_mode    : in Boolean := False;
   293.                            text_mode    : in Boolean := False) is
   294.       length : constant KDF9.word :=  KDF9.word(Q_operand.M) * (if word_mode then 8 else 1);
   295.       char   : constant Character := Character'Val(0);
   296.       size   : KDF9.word := 0;
   297.    begin
   298.       require_positive_count(Q_operand.M);
   299.       for i in 1 .. length loop
   300.          size := size + 1;
   301.          if text_mode then
   302.             do_not_put_byte(char, the_device.stream);
   303.          else
   304.             put_byte(char, the_device.stream);
   305.          end if;
   306.       end loop;
   307.       start_data_transfer(
   308.                           the_device,
   309.                           (Q_operand.C, 0, Q_operand.M),
   310.                           set_offline,
   311.                           busy_time => IO_elapsed_time(the_device, length)
   312.                          );
   313.       do_output_housekeeping(the_device, written => length, fetched => 0);
   314.    exception
   315.       when end_of_stream =>
   316.          do_output_housekeeping(the_device, written => size, fetched => 0);
   317.    end output_a_gap;
   318.
   319.    procedure do_output_housekeeping (the_device : in out shift.device;
   320.                                      written,
   321.                                      fetched    : in KDF9.word) is
   322.    begin
   323.       flush(the_device.stream);
   324.       add_in_the_IO_CPU_time(the_device, fetched);
   325.       correct_transfer_time(the_device, written);
   326.       the_device.byte_count := the_device.byte_count + fetched;
   327.    end do_output_housekeeping;
   328.
   329.    procedure set_case (the_device  : in out shift.device;
   330.                        the_setting : in KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal) is
   331.    begin
   332.       the_device.current_case := the_setting;
   333.    end set_case;
   334.
   335.    function uses_Latin_1 (the_device : in shift.device)
   336.    return Boolean
   337.    is (the_device.is_transcribing);
   338.
   339.    overriding
   340.    procedure Finalize (the_device : in out shift.device) is
   341.    begin
   342.       close(
   343.             the_device,
   344.             "transferred",
   345.             the_device.byte_count,
   346.             "character" & plurality(the_device.byte_count)
   347.            );
   348.    end Finalize;
   349.
   350. end IOC.slow.shift;

Compiling: ../Source/ioc-slow-shift.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of the common functionality of a 2-case (Normal/Shift) buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18.
    19. use  KDF9_char_sets;
    20.
    21. package IOC.slow.shift is
    22.
    23.    --
    24.    -- Abstract common functionality of Case Normal / Case Shift devices, i.e.,
    25.    --    the BSI interface (SI) paper tape reader (TR), punch (TP) and console Flexowriter (FW).
    26.    --
    27.
    28.    type device is abstract new IOC.slow.device with private;
    29.
    30.    procedure set_case (the_device  : in out shift.device;
    31.                        the_setting : in KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal);
    32.
    33.    function uses_Latin_1 (the_device : in shift.device)
    34.    return Boolean;
    35.
    36.    -- Read a character from the stream and deal with any input file concatenation.
    37.    -- If the buffer is reading from a file, deliver the character found; otherwise:
    38.    --    convert the character from Latin-1 to the corresponding paper tape 8-bit code frame.
    39.    procedure get_frame_from_stream (frame      : out Character;
    40.                                     the_device : in out shift.device);
    41.
    42. private
    43.
    44.    type device is abstract new IOC.slow.device with
    45.       record
    46.          current_case : KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal;
    47.       end record;
    48.
    49.    overriding
    50.    procedure Finalize (the_device : in out shift.device);
    51.
    52.    overriding
    53.    procedure Initialize (the_device : in out shift.device);
    54.
    55.    procedure do_input_housekeeping (the_device : in out shift.device;
    56.                                     read_in,
    57.                                     stored     : in KDF9.word);
    58.
    59.    procedure do_output_housekeeping (the_device : in out shift.device;
    60.                                      written,
    61.                                      fetched    : in KDF9.word);
    62.
    63.    procedure write (the_device : in out shift.device;
    64.                     Q_operand  : in KDF9.Q_register);
    65.
    66.    procedure read (the_device : in out shift.device;
    67.                    Q_operand  : in KDF9.Q_register);
    68.
    69.    procedure write_to_EM (the_device : in out shift.device;
    70.                           Q_operand  : in KDF9.Q_register);
    71.
    72.    procedure read_to_EM (the_device : in out shift.device;
    73.                          Q_operand  : in KDF9.Q_register);
    74.
    75.    procedure words_write (the_device : in out shift.device;
    76.                           Q_operand  : in KDF9.Q_register);
    77.
    78.    procedure words_read (the_device : in out shift.device;
    79.                          Q_operand  : in KDF9.Q_register);
    80.
    81.    procedure words_write_to_EM (the_device : in out shift.device;
    82.                                 Q_operand  : in KDF9.Q_register);
    83.
    84.    procedure words_read_to_EM (the_device : in out shift.device;
    85.                                Q_operand  : in KDF9.Q_register);
    86.
    87.    procedure output_a_gap (the_device   : in out shift.device;
    88.                            Q_operand    : in KDF9.Q_register;
    89.                            set_offline  : in Boolean;
    90.                            word_mode    : in Boolean := False;
    91.                            text_mode    : in Boolean := False);
    92.
    93. end IOC.slow.shift;

 350 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-tp.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets.framed;
    18.
    19. package body IOC.slow.shift.TP is
    20.
    21.    use KDF9_char_sets;
    22.
    23.    overriding
    24.    procedure Initialize (the_TP : in out TP.device) is
    25.    begin
    26.       open(the_TP, write_mode);
    27.    end Initialize;
    28.
    29.    -- the_T_bit_is_set := (the buffer has been switched from a tape punch to a graph plotter)
    30.    overriding
    31.    procedure PMB (the_TP      : in out TP.device;
    32.                   Q_operand   : in KDF9.Q_register;
    33.                   set_offline : in Boolean) is
    34.    begin
    35.       validate_device(the_TP);
    36.       validate_parity(the_TP);
    37.       deal_with_a_busy_device(the_TP, 13, set_offline);
    38.       the_T_bit_is_set := False;  -- We never get here if GP0 is enabled.
    39.       take_note_of_test(the_TP.device_name, Q_operand, the_T_bit_is_set);
    40.    end PMB;
    41.
    42. --
    43. --
    44.    --
    45.    -- See Manual, §17.4 for paper tape 8-bit frame format.
    46.    --
    47. --
    48. --
    49.
    50.    procedure write_KDF9_tape_code (the_TP        : in out TP.device;
    51.                                    Q_operand     : in KDF9.Q_register;
    52.                                    writing_to_EM : in Boolean := False) is
    53.       start_address : constant KDF9.address := Q_operand.I;
    54.       end_address   : constant KDF9.address := Q_operand.M;
    55.       size   : KDF9.word := 0;
    56.       symbol : KDF9_char_sets.symbol;
    57.       char   : Character;
    58.
    59.    begin -- write_KDF9_tape_code
    60.       check_addresses_and_lockouts(start_address, end_address);
    61.    word_loop:
    62.       for w in start_address .. end_address loop
    63.          for c in KDF9_char_sets.symbol_index'Range loop
    64.             symbol := fetch_symbol(w, c);
    65.             size := size + 1;
    66.             char := framed(symbol);
    67.             put_byte(char, the_TP.stream);
    68.          exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
    69.          end loop;
    70.       end loop word_loop;
    71.       do_output_housekeeping(the_TP, written => size, fetched => size);
    72.    exception
    73.       when end_of_stream =>
    74.          do_output_housekeeping(the_TP, written => size, fetched => size);
    75.    end write_KDF9_tape_code;
    76.
    77.    -- PWQq
    78.    overriding
    79.    procedure POA (the_TP      : in out TP.device;
    80.                   Q_operand   : in KDF9.Q_register;
    81.                   set_offline : in Boolean) is
    82.    begin
    83.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
    84.       if the_TP.is_transcribing then
    85.          write(the_TP, Q_operand);
    86.       else
    87.          write_KDF9_tape_code(the_TP, Q_operand);
    88.       end if;
    89.       lock_out_relative_addresses(Q_operand);
    90.    end POA;
    91.
    92.    -- PWEQq
    93.    overriding
    94.    procedure POB (the_TP      : in out TP.device;
    95.                   Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean) is
    97.    begin
    98.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
    99.       if the_TP.is_transcribing then
   100.          write_to_EM(the_TP, Q_operand);
   101.       else
   102.          write_KDF9_tape_code(the_TP, Q_operand, writing_to_EM => True);
   103.       end if;
   104.       lock_out_relative_addresses(Q_operand);
   105.    end POB;
   106.
   107.    -- PWCQq
   108.    overriding
   109.    procedure POC (the_TP      : in out TP.device;
   110.                   Q_operand   : in KDF9.Q_register;
   111.                   set_offline : in Boolean) is
   112.    begin
   113.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   114.       words_write(the_TP, Q_operand);
   115.       lock_out_relative_addresses(Q_operand);
   116.    end POC;
   117.
   118.    -- PWCEQq
   119.    overriding
   120.    procedure POD (the_TP      : in out TP.device;
   121.                   Q_operand   : in KDF9.Q_register;
   122.                   set_offline : in Boolean) is
   123.    begin
   124.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   125.       words_write_to_EM(the_TP, Q_operand);
   126.       lock_out_relative_addresses(Q_operand);
   127.    end POD;
   128.
   129.    -- PGAPQq
   130.    overriding
   131.    procedure POE (the_TP      : in out TP.device;
   132.                   Q_operand   : in KDF9.Q_register;
   133.                   set_offline : in Boolean) is
   134.    begin
   135.       require_nonnegative_count(Q_operand.M);
   136.       output_a_gap(
   137.                    the_TP,
   138.                    Q_operand,
   139.                    set_offline,
   140.                    word_mode => False,
   141.                    text_mode => the_TP.is_transcribing
   142.                   );
   143.    end POE;
   144.
   145.    -- "word gap"
   146.    overriding
   147.    procedure POF (the_TP      : in out TP.device;
   148.                   Q_operand   : in KDF9.Q_register;
   149.                   set_offline : in Boolean) is
   150.    begin
   151.       require_nonnegative_count(Q_operand.M);
   152.       output_a_gap(
   153.                    the_TP,
   154.                    Q_operand,
   155.                    set_offline,
   156.                    word_mode => True,
   157.                    text_mode => the_TP.is_transcribing
   158.                   );
   159.    end POF;
   160.
   161.    overriding
   162.    procedure Finalize (the_TP : in out TP.device) is
   163.    begin
   164.       close(
   165.             the_TP,
   166.             "punched",
   167.             the_TP.byte_count,
   168.             "character" & plurality(the_TP.byte_count)
   169.           & " in "
   170.           & (if the_TP.is_transcribing then "Latin-1" else "KDF9")
   171.           & " code"
   172.            );
   173.    end Finalize;
   174.
   175.    type TP_access is access TP.device;
   176.
   177.    TP0  : TP_access with Warnings => Off;
   178.    TP1  : TP_access with Warnings => Off;
   179.
   180.    unit : IOC.unit_number := 0;
   181.
   182.    procedure enable (b : in KDF9.buffer_number) is
   183.    begin
   184.       case unit is
   185.          when 0 =>
   186.             TP0 := new TP.device (number => b, unit => 0);
   187.             TP0_number := b;
   188.          when 1 =>
   189.             TP1 := new TP.device (number => b, unit => 1);
   190.             TP1_number := b;
   191.          when others =>
   192.             trap_operator_error("more than two TP units have been configured");
   193.       end case;
   194.       unit := unit + 1;
   195.    end enable;
   196.
   197.    procedure remove_from_buffer (b : in KDF9.buffer_number) is
   198.    begin
   199.       if TP1 /= null   and then
   200.             TP1.number = b then
   201.          Finalize(TP1.all);
   202.          TP1 := null;
   203.       else
   204.          trap_operator_error("GP0 cannot be configured. TP1 is not on buffer #" & oct_of(b, 2));
   205.       end if;
   206.    end remove_from_buffer;
   207.
   208.    -- Set the character code to be used by the designated TP.
   209.    procedure set_unit_code (unit : in Natural; is_transcribing : in Boolean) is
   210.    begin
   211.       if unit = 0 and then TP0 /= null then
   212.          TP0.is_transcribing := set_unit_code.is_transcribing;
   213.       elsif unit = 1 and then TP1 /= null then
   214.          TP1.is_transcribing := set_unit_code.is_transcribing;
   215.       end if;
   216.    end set_unit_code;
   217.
   218. end IOC.slow.shift.TP;

Compiling: ../Source/ioc-slow-shift-tp.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.TP is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    -- PWQq
    22.    overriding
    23.    procedure POA (the_TP      : in out TP.device;
    24.                   Q_operand   : in KDF9.Q_register;
    25.                   set_offline : in Boolean);
    26.
    27.    -- PWEQq
    28.    overriding
    29.    procedure POB (the_TP      : in out TP.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    -- PWCQq
    34.    overriding
    35.    procedure POC (the_TP      : in out TP.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    -- PWCEQq
    40.    overriding
    41.    procedure POD (the_TP      : in out TP.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    -- PGAPQq
    46.    overriding
    47.    procedure POE (the_TP      : in out TP.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- This is called "word gap" in the Manual, but never defined.
    52.    overriding
    53.    procedure POF (the_TP      : in out TP.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- the_T_bit_is_set (the buffer has been switched from a tape punch to a graph plotter)
    58.    overriding
    59.    procedure PMB (the_TP      : in out TP.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    procedure enable (b : in KDF9.buffer_number);
    64.
    65.    -- Finalize TP1 if necessary and remove it from the configuration, to allow GP0 to be attached.
    66.    procedure remove_from_buffer (b : in KDF9.buffer_number);
    67.
    68.    -- Set the character code to be used by the TP unit.
    69.    procedure set_unit_code(unit : in Natural; is_transcribing : in Boolean);
    70.
    71. private
    72.
    73.    type device is new IOC.slow.shift.device with null record;
    74.
    75.    overriding
    76.    procedure Initialize (the_TP : in out TP.device);
    77.
    78.    overriding
    79.    procedure Finalize (the_TP : in out TP.device);
    80.
    81.    overriding
    82.    function kind (the_TP : TP.device)
    83.    return IOC.device_kind
    84.    is (TP_kind);
    85.
    86.    overriding
    87.    function quantum (the_TP : TP.device)
    88.    return KDF9.us
    89.    is (1E6 / 110);
    90.
    91. end IOC.slow.shift.TP;

 218 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-tr.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a paper tape reader buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9.TOD_clock;
    18. with KDF9.TSD.timing;
    19.
    20. use  KDF9.TOD_clock;
    21.
    22. package body IOC.slow.shift.TR is
    23.
    24.    use KDF9_char_sets;
    25.
    26.    overriding
    27.    procedure Initialize (the_TR : in out TR.device) is
    28.    begin
    29.       -- Open the associated file.
    30.       open(IOC.device(the_TR), read_mode);
    31.    end Initialize;
    32.
    33.    --
    34.    -- See Manual, §17.4 for paper tape 8-bit frame format.
    35.    --
    36.
    37.    function has_even_parity (octet : KDF9.syllable)
    38.    return Boolean is
    39.       frame  : KDF9.syllable := octet;
    40.       parity : KDF9.syllable := 0;
    41.    begin
    42.       while frame /= 0 loop
    43.          parity := parity xor (frame and 1);
    44.          frame  := frame / 2;
    45.       end loop;
    46.       return parity = 0;
    47.    end has_even_parity;
    48.
    49.    function symbol_from (octet : KDF9.syllable)
    50.    return KDF9_char_sets.symbol
    51.    is (KDF9_char_sets.symbol((octet and 2#01_100_000#)/2 or (octet and 2#00_001_111#)));
    52.
    53.    DEL_frame : constant := 8#377#;
    54.    NUL_frame : constant := 8#000#;
    55.
    56.    -- Read 8-bit paper tape frames, compress to 6-bit byteacters, and pack into words.
    57.    procedure read_KDF9_tape_code (the_TR        : in out TR.device;
    58.                                   Q_operand     : in KDF9.Q_register;
    59.                                   reading_to_EM,
    60.                                   loading_code  : in Boolean := False) is
    61.       c      : KDF9_char_sets.symbol_index := 0;
    62.       w      : KDF9.Q_part := Q_operand.I;
    63.       size   : KDF9.word := 0;
    64.       octet  : KDF9.syllable;
    65.       symbol : KDF9_char_sets.symbol;
    66.       byte   : Character;
    67.    begin
    68.       check_addresses_and_lockouts(Q_operand.I, Q_operand.M);
    69.    word_loop:
    70.       loop
    71.          loop
    72.             get_frame_from_stream(byte, the_TR);
    73.             octet := KDF9.syllable(Character'Pos(byte));
    74.          exit when octet not in NUL_frame | DEL_frame;
    75.          end loop;
    76.          if has_even_parity(octet) then
    77.             symbol := symbol_from(octet);
    78.          else
    79.             trap_invalid_paper_tape("probably not in KDF9 code (parity error detected)");
    80.          end if;
    81.          store_symbol(symbol, w, c);
    82.          size := size + 1;
    83.          c := c + 1;
    84.          if c = 0 then
    85.       exit word_loop when reading_to_EM and symbol = KDF9_char_sets.End_Message;
    86.             w := w + 1;
    87.       exit word_loop when w > Q_operand.M;
    88.          end if;
    89.          if reading_to_EM and then symbol = KDF9_char_sets.End_Message then
    90.             for d in c .. 7 loop
    91.                store_symbol(KDF9_char_sets.Blank_Space, w, d);
    92.             end loop;
    93.       exit word_loop;
    94.          end if;
    95.       exit word_loop when w > Q_operand.M;
    96.       end loop word_loop;
    97.       if not loading_code then
    98.          do_input_housekeeping(the_TR, read_in => size, stored => size);
    99.       end if;
   100.    exception
   101.       when end_of_stream =>
   102.          if size = 0 then
   103.             trap_invalid_paper_tape("there was no data on the tape");
   104.          end if;
   105.          if not loading_code then
   106.             do_input_housekeeping(the_TR, read_in => size, stored => size);
   107.          end if;
   108.          the_TR.is_abnormal := True;
   109.          if not reading_to_EM and c /= 0 then
   110.             trap_invalid_paper_tape("the last word on the tape was incomplete");
   111.          end if;
   112.    end read_KDF9_tape_code;
   113.
   114.    -- PRQq
   115.    overriding
   116.    procedure PIA (the_TR      : in out TR.device;
   117.                   Q_operand   : in KDF9.Q_register;
   118.                   set_offline : in Boolean) is
   119.    begin
   120.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   121.       if the_TR.is_transcribing then
   122.          read(the_TR, Q_operand);
   123.       else
   124.          read_KDF9_tape_code(the_TR, Q_operand);
   125.       end if;
   126.       lock_out_relative_addresses(Q_operand);
   127.    end PIA;
   128.
   129.    -- PREQq
   130.    overriding
   131.    procedure PIB (the_TR      : in out TR.device;
   132.                   Q_operand   : in KDF9.Q_register;
   133.                   set_offline : in Boolean) is
   134.    begin
   135.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   136.       if the_TR.is_transcribing then
   137.          read_to_EM(the_TR, Q_operand);
   138.       else
   139.          read_KDF9_tape_code(the_TR, Q_operand, reading_to_EM => True);
   140.       end if;
   141.       lock_out_relative_addresses(Q_operand);
   142.    end PIB;
   143.
   144.    -- PRCQq
   145.    overriding
   146.    procedure PIC (the_TR      : in out TR.device;
   147.                   Q_operand   : in KDF9.Q_register;
   148.                   set_offline : in Boolean) is
   149.    begin
   150.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   151.       words_read(the_TR, Q_operand);
   152.       lock_out_relative_addresses(Q_operand);
   153.    end PIC;
   154.
   155.    -- PRCEQq
   156.    overriding
   157.    procedure PID (the_TR      : in out TR.device;
   158.                   Q_operand   : in KDF9.Q_register;
   159.                   set_offline : in Boolean) is
   160.    begin
   161.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   162.       words_read_to_EM(the_TR, Q_operand);
   163.       lock_out_relative_addresses(Q_operand);
   164.    end PID;
   165.
   166.    -- as PIA
   167.    overriding
   168.    procedure PIE (the_TR      : in out TR.device;
   169.                   Q_operand   : in KDF9.Q_register;
   170.                   set_offline : in Boolean) is
   171.    begin
   172.       PIA(the_TR, Q_operand, set_offline);
   173.    end PIE;
   174.
   175.    -- as PIB
   176.    overriding
   177.    procedure PIF (the_TR      : in out TR.device;
   178.                   Q_operand   : in KDF9.Q_register;
   179.                   set_offline : in Boolean) is
   180.    begin
   181.       PIB(the_TR, Q_operand, set_offline);
   182.    end PIF;
   183.
   184.    -- as PIC
   185.    overriding
   186.    procedure PIG (the_TR      : in out TR.device;
   187.                   Q_operand   : in KDF9.Q_register;
   188.                   set_offline : in Boolean) is
   189.    begin
   190.       PIC(the_TR, Q_operand, set_offline);
   191.    end PIG;
   192.
   193.    -- as PID
   194.    overriding
   195.    procedure PIH (the_TR      : in out TR.device;
   196.                   Q_operand   : in KDF9.Q_register;
   197.                   set_offline : in Boolean) is
   198.    begin
   199.       PID(the_TR, Q_operand, set_offline);
   200.    end PIH;
   201.
   202.    -- the_T_bit_is_set := (the reader is set to 8-track mode);
   203.    --    it is always in 8-track mode, as 5-track input is not supported by ee9.
   204.    overriding
   205.    procedure PMB (the_TR      : in out TR.device;
   206.                   Q_operand   : in KDF9.Q_register;
   207.                   set_offline : in Boolean) is
   208.    begin
   209.       validate_device(the_TR);
   210.       validate_parity(the_TR);
   211.       deal_with_a_busy_device(the_TR, 13, set_offline);
   212.       the_T_bit_is_set := True;
   213.       take_note_of_test(the_TR.device_name, Q_operand, the_T_bit_is_set);
   214.    end PMB;
   215.
   216.    overriding
   217.    procedure Finalize (the_TR : in out TR.device) is
   218.    begin
   219.       close(
   220.             the_TR,
   221.             "read",
   222.             the_TR.byte_count,
   223.             "character" & plurality(the_TR.byte_count)
   224.           & " in "
   225.           & (if the_TR.is_transcribing then "Latin-1" else "KDF9")
   226.           & " code"
   227.            );
   228.    end Finalize;
   229.
   230.    type TR_access is access TR.device;
   231.
   232.    TR0  : TR_access with Warnings => Off;
   233.    TR1  : TR_access with Warnings => Off;
   234.
   235.    unit : IOC.unit_number := 0;
   236.
   237.    procedure enable (b : in KDF9.buffer_number) is
   238.    begin
   239.       case unit is
   240.          when 0 =>
   241.             TR0 := new TR.device (number => b, unit => 0);
   242.             TR0_number := b;
   243.          when 1 =>
   244.             TR1 := new TR.device (number => b, unit => 1);
   245.             TR1_number := b;
   246.          when others =>
   247.             trap_operator_error("more than two TR units have been configured");
   248.       end case;
   249.       unit := unit + 1;
   250.    end enable;
   251.
   252.    -- Set the character code to be used by the designated TR.
   253.    procedure set_unit_code (unit : in Natural; is_transcribing : in Boolean) is
   254.    begin
   255.       if unit = 0 then
   256.          TR0.is_transcribing := set_unit_code.is_transcribing;
   257.       elsif TR1 /= null then
   258.          TR1.is_transcribing := set_unit_code.is_transcribing;
   259.       end if;
   260.    end set_unit_code;
   261.
   262.    --
   263.    -- Support for loading programs and for bootstrapping the KDF9.
   264.    --
   265.
   266.    procedure reattach (unit : in Natural; next_file_name : in String) is
   267.       the_reader  : constant TR_access := (if unit = 0 then TR0 else TR1);
   268.    begin
   269.       reattach(the_reader.all, next_file_name);
   270.       if the_reader.is_open then
   271.          the_reader.current_case := KDF9_char_sets.Case_Normal;
   272.       else
   273.          trap_operator_error("«" & next_file_name & "» cannot be found");
   274.       end if;
   275.    end reattach;
   276.
   277.    procedure reset_loader_usage (unit : in Natural) is
   278.       the_reader  : constant TR_access := (if unit = 0 then TR0 else TR1);
   279.    begin
   280.       correct_transfer_time(the_reader.all, KDF9.us(0));
   281.       the_reader.byte_count := 0;
   282.       unlock_absolute_addresses((0, 0, 32767));
   283.    end reset_loader_usage;
   284.
   285.    -- This emulates the Director's program load from a designated  paper tape reader.
   286.    -- Once the loading is done, the tape reader is reattached to TR0.
   287.    procedure load_a_program (program_file_name : in String) is
   288.
   289.       -- This is the call sign for a program on Disc or Drum.
   290.       CN_LS_D_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   291.                                       or (KDF9.word(Line_Shift)   * 2**12)
   292.                                       or (KDF9.word(Upper_Case_D) * 2** 6)
   293.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   294.
   295.       -- This is the call sign for a program on Magnetic Tape.
   296.       CN_LS_M_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   297.                                       or (KDF9.word(Line_Shift)   * 2**12)
   298.                                       or (KDF9.word(Upper_Case_M) * 2** 6)
   299.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   300.
   301.       -- This is the call sign for a program on Paper Tape.
   302.       CN_LS_P_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   303.                                       or (KDF9.word(Line_Shift)   * 2**12)
   304.                                       or (KDF9.word(Upper_Case_P) * 2** 6)
   305.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   306.
   307.       threshold  : constant KDF9.word := 32767 * 2**24;
   308.       substitute : constant KDF9.word := 32736 * 2**24;
   309.       get_a_word : constant KDF9.Q_register := (TR0.number, 0, 0);
   310.
   311.       descriptor : KDF9.Q_register := (TR0.number, 1, 7);
   312.       word_count : Positive := 2;
   313.
   314.    begin -- load_a_program
   315.
   316.       loading_was_successful := False;
   317.
   318.       -- Access the program file as TR0.
   319.       reattach(0, program_file_name);
   320.
   321.       --
   322.       -- For the structure of a compiled program, see Manual §26.3.
   323.       --
   324.
   325.       -- Get the first word of the file into E0: it may start an A block or a B block.
   326.       read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True);
   327.
   328.       -- Check for an A block.  If one is found, check its validity, but otherwise ignore it.
   329.       if fetch_halfword(0, 0)/2**24 in CN_LS_D_LS | CN_LS_M_LS | CN_LS_P_LS then
   330.          -- We have an A block.
   331.          -- The next word completes the program name used by Director.  Ignore it.
   332.          read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True);
   333.
   334.       block_loop:
   335.          -- An A block is at most 8 words long but can end sooner with a word containing EM.
   336.          loop
   337.             word_count := word_count + 1;
   338.          exit block_loop when word_count > 8;
   339.             read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True, reading_to_EM => True);
   340.             for c in KDF9_char_sets.symbol_index loop
   341.          exit block_loop when fetch_symbol(0, c) = End_Message;
   342.             end loop;
   343.          end loop block_loop;
   344.
   345.          if word_count > 8 then
   346.             -- The file is not a valid program tape.
   347.             trap_invalid_paper_tape("excessively long A block");
   348.          end if;
   349.
   350.          -- Read the first word of the following B block.
   351.          read_KDF9_tape_code(TR0.all, (TR0.number, 0, 0), loading_code => True);
   352.       end if;
   353.
   354.       -- Check for an unconditional jump at the start of the B block.
   355.       if (fetch_word(0)/ 2**32 and 2#1111_0000_1111_0000#) /= 2#1000_0000_1011_0000# then
   356.          -- The file is not a valid program tape.
   357.          trap_invalid_paper_tape("no jump was found in E0U: " & oct_of(fetch_word(0)));
   358.       else
   359.          -- Preserve the initial jump in case of corruption by a buggy program.
   360.          save_the_initial_jump;
   361.       end if;
   362.
   363.       -- At this point, E0 contains the first word of the B block, so get the rest of it in E1-E7.
   364.       read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   365.
   366.       descriptor := as_Q(fetch_word(descriptor.M));
   367.       -- Read the non-final C blocks; the validity of the designated descriptors cannot be assumed.
   368.       while descriptor.C /= 0 loop
   369.          validate_address_range(descriptor.I, descriptor.M);
   370.          read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   371.          descriptor := as_Q(fetch_word(descriptor.M));
   372.       end loop;
   373.
   374.       -- Read the final C block.
   375.       validate_address_range(descriptor.I, descriptor.M);
   376.       read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   377.
   378.       -- Set up the rest of the stored image.
   379.
   380.       -- Set the (virtual) date in E7.
   381.       store_word(todays_date_28n_years_ago, 7);
   382.
   383.       -- Ensure valid parameters in E1 (some binaries may have invalid entries).
   384.       if fetch_halfword(1, 0) > threshold or else fetch_halfword(1, 0) = 0 then
   385.          store_halfword(substitute, 1, 0);
   386.       end if;
   387.       if fetch_halfword(1, 1) > threshold or else fetch_halfword(1, 1) = 0 then
   388.          store_halfword(substitute, 1, 1);
   389.       end if;
   390.
   391.       -- Do not set the time if we are computing a signature, so as to get a repeatable hash.
   392.       if not the_signature_is_enabled then
   393.          KDF9.TSD.timing.set_the_time_of_loading(the_time_of_day);
   394.       end if;
   395.
   396.       loading_was_successful := True;
   397.
   398.       -- Clear up the I/O system.
   399.       reattach(0, "TR0");
   400.       clear_IOC_FIFO;
   401.       reset_loader_usage(0);
   402.    end load_a_program;
   403.
   404.    -- This emulates action of a Director call program, including:
   405.    --    1. Moving the JP0 order from E0U to E2U.
   406.    --    2. Inserting the interrupt handling code into E0 and E1, and
   407.    --    3. setting NIA to (4, 0) instead of (0, 0).
   408.    procedure load_a_bare_Director (program_file_name : in String) is
   409.
   410.    begin -- load_a_bare_Director
   411.       load_a_program(program_file_name);
   412.       store_halfword(fetch_halfword(0, index => 0), 2, index => 0);
   413.       store_word(8#3620716437675016#, 0); -- #171 #016 #164 #177 #172 #016: Q0; SHL+63; =+Q0;
   414.       store_word(8#6114000037240052#, 1); -- #304 #300 #000 #175 #100 #052: SETB140000;; =K1; ERASE
   415.       set_NIA_to((4, 0));
   416.    end load_a_bare_Director;
   417.
   418.    -- TR0 is the hardware bootstrap device for reading initial orders.
   419.    procedure boot_the_KDF9 (program_file_name : in String) is
   420.       boot_descriptor : constant KDF9.Q_register := (C => TR0.number, I => 0, M => 8);
   421.    begin
   422.       loading_was_successful := False;
   423.       reattach(0, program_file_name);
   424.
   425.       -- The bootstrap is 9 words of instruction code, which reads in the rest of its file.
   426.       -- The validity of the bootstrap descriptor is hardware defined.
   427.       read_KDF9_tape_code(TR0.all, boot_descriptor, loading_code => True);
   428.
   429.       -- Reset the I/O system for execution of the Director.
   430.       clear_IOC_FIFO;
   431.       reset_loader_usage(0);
   432.       loading_was_successful := True;
   433.    end boot_the_KDF9;
   434.
   435. end IOC.slow.shift.TR;

Compiling: ../Source/ioc-slow-shift-tr.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a paper tape reader buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.TR is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    -- PRQq
    22.    overriding
    23.    procedure PIA (the_TR      : in out TR.device;
    24.                   Q_operand   : in KDF9.Q_register;
    25.                   set_offline : in Boolean);
    26.
    27.    -- PREQq
    28.    overriding
    29.    procedure PIB (the_TR      : in out TR.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    --PRCQq
    34.    overriding
    35.    procedure PIC (the_TR      : in out TR.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    -- PRCEQq
    40.    overriding
    41.    procedure PID (the_TR      : in out TR.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    -- as PIA
    46.    overriding
    47.    procedure PIE (the_TR      : in out TR.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- as PIB
    52.    overriding
    53.    procedure PIF (the_TR      : in out TR.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- as PIC
    58.    overriding
    59.    procedure PIG (the_TR      : in out TR.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    -- as PID
    64.    overriding
    65.    procedure PIH (the_TR      : in out TR.device;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    -- the_T_bit_is_set (the reader is set to 8-track mode)
    70.    overriding
    71.    procedure PMB (the_TR      : in out TR.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    procedure enable (b : in KDF9.buffer_number);
    76.
    77.    -- Reattach the designated TR to the specified file and set CASE NORMAL (may be irrelevant).
    78.    -- This is done after loading a binary program, to allow access any TR data file(s);
    79.    --    also to access a binary program for loading as an overlay.
    80.    procedure reattach (unit : in Natural; next_file_name : in String);
    81.
    82.    -- Read the 9-word bootstrap.
    83.    procedure boot_the_KDF9 (program_file_name : in String);
    84.
    85.    -- Read a binary program.
    86.    procedure load_a_program (program_file_name : in String);
    87.
    88.    -- This emulates action of a Director call program, including:
    89.    --    1. Moving the JP0 order from E0U to E2U.
    90.    --    2. Inserting the interrupt handling code into E0 and E1, and
    91.    --    3. setting NIA to (4, 0) instead of (0, 0).
    92.    procedure load_a_bare_Director (program_file_name : in String);
    93.
    94.    -- Set the character code to be used by the TR unit.
    95.    procedure set_unit_code(unit : in Natural; is_transcribing : in Boolean);
    96.
    97. private
    98.
    99.    type device is new IOC.slow.shift.device with null record;
   100.
   101.    overriding
   102.    procedure Initialize (the_TR : in out TR.device);
   103.
   104.    overriding
   105.    procedure Finalize (the_TR : in out TR.device);
   106.
   107.    overriding
   108.    function kind (the_TR : TR.device)
   109.    return IOC.device_kind
   110.    is (TR_kind);
   111.
   112.    overriding
   113.    function quantum (the_TR : TR.device)
   114.    return KDF9.us
   115.    is (1_000);
   116.
   117. end IOC.slow.shift.TR;

 435 lines: No errors


Compiling: /home/parallels/emulation/Source/say_goodbye.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Finalize emulation with a helpful message derived from exception information.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Command_Line;
    18. with Ada.Strings.Fixed;
    19. with finalize_ee9;
    20. with HCI;
    21. with settings;
    22.
    23. use  Ada.Command_Line;
    24. use  Ada.Strings.Fixed;
    25.
    26. use  HCI;
    27. use  settings;
    28.
    29. procedure say_goodbye (
    30.                        reason : in String;
    31.                        cause  : in String := "";
    32.                        status : in Exit_Status := Failure
    33.                       ) is
    34.
    35.    function explanation
    36.    return String is
    37.       CR   : constant Character := Character'Val(16#D#);
    38.       LF   : constant Character := Character'Val(16#A#);
    39.       L, R : Natural;
    40.    begin  -- explanation
    41.       if cause'Length < 3 then
    42.          return cause;
    43.       end if;
    44.       L := Index(cause, "%", from => cause'First) + 1;
    45.       if cause(cause'Last-1) = CR then
    46.          R := cause'Last - 2;
    47.       elsif cause(cause'Last) in LF | CR then
    48.          R := cause'Last - 1;
    49.       else
    50.          R := cause'Last;
    51.       end if;
    52.       return cause(L .. R);
    53.    end explanation;
    54.
    55. begin  -- say_goodbye
    56.    if the_log_is_wanted then
    57.       log_new_line;
    58.    end if;
    59.    if reason = "" then
    60.       finalize_ee9("Normal end of run");
    61.    elsif reason'Length > 2 and then
    62.          reason(reason'Last-2..reason'Last) = "OUT" then
    63.       finalize_ee9(reason & " " & explanation);
    64.    elsif reason'Length = 0 then
    65.       finalize_ee9(explanation);
    66.    elsif explanation'Length = 0 then
    67.       finalize_ee9(reason);
    68.    else
    69.       finalize_ee9(reason & ": " & explanation);
    70.    end if;
    71.    if the_log_is_wanted then
    72.       log_new_line;
    73.    end if;
    74.    Set_Exit_Status(status);
    75. end say_goodbye;

 75 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/generic_logger.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Provide operations supporting replicated output to a list of logging interfaces.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. -- generic
    18. --    max_logger_list_size : in Positive;
    19. package body generic_logger is
    20.
    21.    not overriding
    22.    procedure set_logger_list (logger : in out replicator; list : in distribution_list) is
    23.    begin
    24.       logger.data := (list'Length, list);
    25.    end set_logger_list;
    26.
    27.    overriding
    28.    procedure tab_log (logger   : in out replicator;
    29.                       at_least : in Natural;
    30.                       spacing  : in Positive;
    31.                       iff      : in Boolean := True) is
    32.    begin
    33.       for l in logger.data.list'Range loop
    34.          logger.data.list(l).tab_log(at_least, spacing, iff);
    35.       end loop;
    36.    end tab_log;
    37.
    38.    overriding
    39.    procedure tab_log_to (logger : in out replicator;
    40.                          column : in Positive;
    41.                          iff    : in Boolean := True) is
    42.    begin
    43.       for l in logger.data.list'Range loop
    44.          logger.data.list(l).tab_log_to(column, iff);
    45.       end loop;
    46.    end tab_log_to;
    47.
    48.    overriding
    49.    procedure log (logger : in out replicator;
    50.                   char   : in Character;
    51.                   iff    : in Boolean := True) is
    52.    begin
    53.       for l in logger.data.list'Range loop
    54.          logger.data.list(l).log(char, iff);
    55.       end loop;
    56.    end log;
    57.
    58.    overriding
    59.    procedure log (logger : in out replicator;
    60.                   text   : in String;
    61.                   iff    : in Boolean := True) is
    62.    begin
    63.       for l in logger.data.list'Range loop
    64.          logger.data.list(l).log(text, iff);
    65.       end loop;
    66.    end log;
    67.
    68.    overriding
    69.    procedure log_new_line (logger : in out replicator;
    70.                            iff    : in Boolean := True) is
    71.    begin
    72.       for l in logger.data.list'Range loop
    73.          logger.data.list(l).log_new_line(iff);
    74.       end loop;
    75.    end log_new_line;
    76.
    77.    overriding
    78.    procedure open (logger : in out replicator; log_name : in String) is
    79.    begin
    80.       for l in logger.data.list'Range loop
    81.          logger.data.list(l).open(log_name);
    82.       end loop;
    83.    end open;
    84.
    85.    overriding
    86.    procedure close (logger : in out replicator; log_name : in String) is
    87.    begin
    88.       for l in logger.data.list'Range loop
    89.          logger.data.list(l).close(log_name);
    90.       end loop;
    91.    end close;
    92.
    93.    overriding
    94.    procedure flush (logger : in out replicator; iff : in Boolean := True) is
    95.    begin
    96.       for l in logger.data.list'Range loop
    97.          logger.data.list(l).flush(iff);
    98.       end loop;
    99.    end flush;
   100.
   101. end generic_logger;

Compiling: ../Source/generic_logger.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Provide operations supporting replicated output to a list of logging interfaces.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with logging;
    18.
    19. generic
    20.    max_logger_list_size : in Positive;
    21. package generic_logger is
    22.
    23.    type distribution_list is array (Positive range <>) of access logging.output'Class;
    24.
    25.    type replicator is new logging.output with private;
    26.
    27.    not overriding
    28.    procedure set_logger_list (logger : in out replicator; list : in distribution_list);
    29.
    30.    overriding
    31.    procedure tab_log (logger   : in out replicator;
    32.                       at_least : in Natural;
    33.                       spacing  : in Positive;
    34.                       iff      : in Boolean := True);
    35.
    36.    overriding
    37.    procedure tab_log_to (logger : in out replicator;
    38.                          column : in Positive;
    39.                          iff    : in Boolean := True);
    40.
    41.    overriding
    42.    procedure log (logger : in out replicator;
    43.                   char   : in Character;
    44.                   iff    : in Boolean := True);
    45.
    46.    overriding
    47.    procedure log (logger : in out replicator;
    48.                   text   : in String;
    49.                   iff    : in Boolean := True);
    50.
    51.    overriding
    52.    procedure log_new_line (logger : in out replicator;
    53.                            iff    : in Boolean := True);
    54.
    55.    overriding
    56.    procedure open  (logger : in out replicator; log_name : in String);
    57.
    58.    overriding
    59.    procedure close (logger : in out replicator; log_name : in String);
    60.
    61.    overriding
    62.    procedure flush (logger : in out replicator; iff : in Boolean := True);
    63.
    64. private
    65.
    66.    subtype logger_list_size is Natural range 0 .. max_logger_list_size;
    67.
    68.    -- This type is needed because tagged types cannot have discriminants.
    69.    type replica_list (length : logger_list_size := 0) is
    70.       record
    71.          list : distribution_list(1 .. length);
    72.       end record;
    73.
    74.    type replicator is new logging.output with
    75.       record
    76.          data : replica_list;
    77.       end record;
    78.
    79. end generic_logger;

 101 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/logging.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Define an abstract log output device.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package logging is
    18.
    19.    type output is interface;
    20.
    21.    procedure tab_log (logger   : in out logging.output;
    22.                       at_least : in Natural;
    23.                       spacing  : in Positive;
    24.                       iff      : in Boolean := True) is abstract;
    25.
    26.    procedure tab_log_to (logger : in out logging.output;
    27.                          column : in Positive;
    28.                          iff    : in Boolean := True) is abstract;
    29.
    30.    procedure log (logger : in out logging.output;
    31.                   char   : in Character;
    32.                   iff    : in Boolean := True) is abstract;
    33.
    34.    procedure log (logger : in out logging.output;
    35.                   text   : in String;
    36.                   iff    : in Boolean := True) is abstract;
    37.
    38.    procedure log_new_line (logger : in out logging.output;
    39.                            iff    : in Boolean := True) is abstract;
    40.
    41.    procedure open  (logger : in out logging.output; log_name : in String) is abstract;
    42.
    43.    procedure close (logger : in out logging.output; log_name : in String) is abstract;
    44.
    45.    procedure flush (logger : in out logging.output; iff : in Boolean := True) is abstract;
    46.
    47. end logging;

 47 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/logging-file.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Provide logging output to a named text file.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18. with Ada.Unchecked_Deallocation;
    19. --
    20. with file_interfacing;
    21.
    22. use  Ada.Text_IO;
    23. --
    24. use  file_interfacing;
    25.
    26. package body logging.file is
    27.
    28.    overriding
    29.    procedure tab_log (logger   : in out file.output;
    30.                       at_least : in Natural;
    31.                       spacing  : in Positive;
    32.                       iff      : in Boolean := True) is
    33.       column_nr : constant Positive_Count := Col(logger.the_log.all) + Count(at_least);
    34.       excess    : constant Count          := column_nr mod Count(spacing);
    35.    begin
    36.       if not iff or logger.log_file_is_shut then return; end if;
    37.       Set_Col(logger.the_log.all, column_nr);
    38.       if excess /= 0 then
    39.          Set_Col(logger.the_log.all, column_nr + Count(spacing) - excess);
    40.       end if;
    41.    end tab_log;
    42.
    43.    overriding
    44.    procedure tab_log_to (logger : in out file.output;
    45.                          column : in Positive;
    46.                          iff    : in Boolean := True) is
    47.    begin
    48.       if not iff or logger.log_file_is_shut then return; end if;
    49.       Set_Col(logger.the_log.all, Positive_Count(column));
    50.    end tab_log_to;
    51.
    52.    overriding
    53.    procedure log_new_line (logger : in out file.output;
    54.                            iff    : in Boolean := True) is
    55.    begin
    56.       if not iff or logger.log_file_is_shut then return; end if;
    57.       New_Line(logger.the_log.all);
    58.    end log_new_line;
    59.
    60.    overriding
    61.    procedure log (logger : in out file.output;
    62.                   char   : in Character;
    63.                   iff    : in Boolean := True) is
    64.    begin
    65.       if not iff or logger.log_file_is_shut then return; end if;
    66.       Put(logger.the_log.all, char);
    67.    end log;
    68.
    69.    overriding
    70.    procedure log (logger : in out file.output;
    71.                   text   : in String;
    72.                   iff    : in Boolean := True) is
    73.    begin
    74.       if not iff or logger.log_file_is_shut then return; end if;
    75.       Put(logger.the_log.all, text);
    76.    end log;
    77.
    78.    overriding
    79.    procedure open (logger : in out file.output; logfile_name : in String) is
    80.    begin
    81.       if logger.log_file_is_shut then
    82.          logger.the_log := new Ada.Text_IO.File_Type;
    83.          file_interfacing.initialize(logger.the_log.all, out_file, logfile_name);
    84.          logger.log_file_is_shut := False;
    85.       end if;
    86.    end open;
    87.
    88.    overriding
    89.    procedure close (logger : in out file.output; logfile_name : in String) is
    90.
    91.       procedure free_log_file is
    92.          new Ada.Unchecked_Deallocation(Ada.Text_IO.File_Type, File_Type_access);
    93.
    94.    begin
    95.       if logger.log_file_is_shut then return; end if;
    96.       file_interfacing.finalize(logger.the_log.all, logfile_name);
    97.       free_log_file(logger.the_log);
    98.       logger.log_file_is_shut := True;
    99.    end close;
   100.
   101.    overriding
   102.    procedure flush (logger : in out file.output; iff : in Boolean := True) is
   103.    begin
   104.       if not iff or logger.log_file_is_shut then return; end if;
   105.       Flush(logger.the_log.all);
   106.    end flush;
   107.
   108. end logging.file;

Compiling: ../Source/logging-file.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Provide logging output to a named text file.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. private with Ada.Text_IO;
    18.
    19. package logging.file is
    20.
    21.    type output is new logging.output with private;
    22.
    23.    overriding
    24.    procedure tab_log (logger   : in out file.output;
    25.                       at_least : in Natural;
    26.                       spacing  : in Positive;
    27.                       iff      : in Boolean := True);
    28.
    29.    overriding
    30.    procedure tab_log_to (logger : in out file.output;
    31.                          column : in Positive;
    32.                          iff    : in Boolean := True);
    33.
    34.    overriding
    35.    procedure log (logger : in out file.output;
    36.                   char   : in Character;
    37.                   iff    : in Boolean := True);
    38.
    39.    overriding
    40.    procedure log (logger : in out file.output;
    41.                   text   : in String;
    42.                   iff    : in Boolean := True);
    43.
    44.    overriding
    45.    procedure log_new_line (logger : in out file.output;
    46.                            iff    : in Boolean := True);
    47.
    48.    overriding
    49.    procedure open  (logger : in out file.output; logfile_name : in String);
    50.
    51.    overriding
    52.    procedure close (logger : in out file.output; logfile_name : in String);
    53.
    54.    overriding
    55.    procedure flush (logger : in out file.output; iff    : in Boolean := True);
    56.
    57. private
    58.
    59.    type File_Type_access is access Ada.Text_IO.File_Type;
    60.
    61.    type output is new logging.output with
    62.       record
    63.          log_file_is_shut : Boolean := True;
    64.          the_log          : file.File_Type_access;
    65.       end record;
    66.
    67. end logging.file;

 108 lines: No errors


Compiling: /home/parallels/emulation/Source/settings.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- execution mode, diagnostic mode, and other emulation-control settings
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. with Ada.Long_Float_Text_IO;
    19. with Ada.Text_IO;
    20. --
    21. with dumping;
    22. with exceptions;
    23. with formatting;
    24. with HCI;
    25. with IOC.equipment;
    26. with KDF9.store;
    27. with postscript;
    28. with settings.IO;
    29. with disassembly.symbols;
    30. with tracing;
    31.
    32. use  Ada.Exceptions;
    33. use  Ada.Long_Float_Text_IO;
    34. use  Ada.Text_IO;
    35. --
    36. use  dumping;
    37. use  exceptions;
    38. use  formatting;
    39. use  HCI;
    40. use  KDF9.store;
    41. use  settings.IO;
    42. use  disassembly.symbols;
    43. use  tracing;
    44.
    45. package body settings is
    46.
    47.    procedure reset_default_visibility_options is
    48.    begin
    49.       API_logging_is_wanted            := True;
    50.       flexowriter_output_is_wanted     := True;
    51.       histogramming_is_wanted          := True;
    52.       interrupt_tracing_is_wanted      := True;
    53.       peripheral_tracing_is_wanted     := True;
    54.       realistic_FW_output_is_wanted    := True;
    55.       retrospective_tracing_is_wanted  := True;
    56.       the_final_state_is_wanted        := True;
    57.       the_log_is_wanted                := True;
    58.       the_signature_is_wanted          := True;
    59.       authentic_timing_is_enabled      := False;
    60.       debugging_is_enabled             := False;
    61.       histogramming_is_enabled         := False;
    62.       interrupt_tracing_is_enabled     := False;
    63.       peripheral_tracing_is_enabled    := False;
    64.       retrospective_tracing_is_enabled := False;
    65.       the_signature_is_enabled         := False;
    66.    end reset_default_visibility_options;
    67.
    68.    function is_invalid_miscellany_flag (option : in Character)
    69.    return Boolean is
    70.    begin
    71.       for f of miscellany_flags loop
    72.          if f = option then
    73.             return False;
    74.          end if;
    75.       end loop;
    76.       if option = '-' then  -- Ignore hyphens to make the calling scripts easier.
    77.          return False;
    78.       end if;
    79.       return True;
    80.    end is_invalid_miscellany_flag;
    81.
    82.    procedure set_this_miscellany_flag (option : in Character) is
    83.       use IOC.equipment;
    84.    begin
    85.       if is_invalid_miscellany_flag(option) then
    86.          log_line(
    87.                   "***** Error in a miscellany specification: «"
    88.                 & option
    89.                 & "»."
    90.                  );
    91.          return;
    92.       end if;
    93.       case option is
    94.          when '-'        =>
    95.             null;  -- Ignore hyphens, to make the calling scripts easier.
    96.          when '.'        =>
    97.             time_limit := 1_000_000;
    98.          when '0' .. '9' =>
    99.             time_limit := (Character'Pos(option) - Character'Pos('0') + 1) * 100_000_000;
   100.          when 'a' | 'A' =>
   101.             API_logging_is_wanted := False;
   102.          when 'b' | 'B' =>
   103.             choice(KDF9.buffer_number'(15)) := SI;
   104.          when 'd' | 'D' =>
   105.             debugging_is_enabled := True;
   106.          when 'e' | 'E' =>
   107.             the_log_is_wanted := False;
   108.          when 'f' | 'F' =>
   109.             the_final_state_is_wanted := False;
   110.          when 'g' | 'G' =>
   111.             choice(if TP1_number = 0 then TP1_default else TP1_number) := GP;
   112.          when 'h' | 'H' =>
   113.             histogramming_is_wanted := False;
   114.          when 'i' | 'I' =>
   115.             interrupt_tracing_is_wanted := False;
   116.          when 'k' | 'K' =>
   117.             choice(DR0_default) := DR;
   118.          when 'n' | 'N' =>
   119.             noninteractive_usage_is_enabled := True;
   120.             time_limit := offline_time_limit;
   121.           when 'o' |'O' =>
   122.             pre_overlay_state_is_enabled := True;
   123.          when 'p' |'P' =>
   124.             peripheral_tracing_is_wanted := False;
   125.          when 'q' | 'Q' =>
   126.             do_not_execute := True;
   127.          when 'r' | 'R' =>
   128.             retrospective_tracing_is_wanted := False;
   129.          when 's' | 'S' =>
   130.             the_signature_is_wanted := False;
   131.          when 't' | 'T' =>
   132.             authentic_timing_is_enabled := True;
   133.          when 'w' | 'W' =>
   134.             flexowriter_output_is_wanted := False;
   135.          when 'x' | 'X' =>
   136.             only_signature_tracing := True;
   137.          when 'y' | 'Y' =>
   138.             this_is_a_bare_Director := True;
   139.          when 'z' | 'Z' =>
   140.             API_logging_is_wanted           := False;
   141.             debugging_is_enabled            := False;
   142.             histogramming_is_wanted         := False;
   143.             interrupt_tracing_is_wanted     := False;
   144.             peripheral_tracing_is_wanted    := False;
   145.             retrospective_tracing_is_wanted := False;
   146.             the_final_state_is_wanted       := False;
   147.             the_log_is_wanted               := False;
   148.             the_signature_is_wanted         := False;
   149.          when others =>
   150.             null;
   151.       end case;
   152.       set_diagnostic_mode(the_diagnostic_mode);
   153.    end set_this_miscellany_flag;
   154.
   155.    procedure display_execution_modes (for_this : in String := "") is
   156.       needs_comma : Boolean := False;
   157.
   158.       procedure append_option (flag : in Boolean; name : in String) is
   159.       begin
   160.          if flag then
   161.             if needs_comma then
   162.                log(", ");
   163.             end if;
   164.             log(name);
   165.             needs_comma := True;
   166.          end if;
   167.       end append_option;
   168.
   169.       function run_type (type_of_run : String)
   170.       return String
   171.       is (if for_this = "" then type_of_run else type_of_run & " " & for_this);
   172.
   173.    begin -- display_execution_modes
   174.       if not the_log_is_wanted then return; end if;
   175.       log_new_line;
   176.       if for_this = "" then
   177.          log("Resuming the run");
   178.       else
   179.          log(
   180.              case the_execution_mode is
   181.                when boot_mode        => (if this_is_a_bare_Director then
   182.                                             "Running the bare " & run_type("Director")
   183.                                          else
   184.                                             "Booting the KDF9 " & run_type("Director")
   185.                                         ),
   186.                when program_mode     => "Running the KDF9 " & run_type("problem program"),
   187.                when privileged_mode  => "Running the KDF9 " & run_type("privileged program")
   188.             );
   189.       end if;
   190.       log(" in ");
   191.       log(
   192.           case the_diagnostic_mode is
   193.              when trace_mode    =>
   194.                 (if the_external_trace_is_enabled then "external trace mode" else "trace mode"),
   195.              when fast_mode     => "fast mode",
   196.              when pause_mode    => "pause mode",
   197.              when external_mode => "external trace mode"
   198.          );
   199.
   200.       if authentic_timing_is_enabled      or else
   201.          debugging_is_enabled             or else
   202.          histogramming_is_enabled         or else
   203.          interrupt_tracing_is_enabled     or else
   204.          noninteractive_usage_is_enabled  or else
   205.          peripheral_tracing_is_enabled    or else
   206.          retrospective_tracing_is_enabled or else
   207.          the_external_trace_is_enabled    or else
   208.          the_signature_is_enabled            then
   209.
   210.          log_line(", with option(s):");
   211.          log("   ");
   212.          append_option(authentic_timing_is_enabled,      "authentic timing");
   213.          append_option(debugging_is_enabled,             "debugging output");
   214.          append_option(histogramming_is_enabled,         "histogram(s)");
   215.          append_option(interrupt_tracing_is_enabled,     "interrupt trace");
   216.          append_option(noninteractive_usage_is_enabled,  "noninteractive");
   217.          append_option(peripheral_tracing_is_enabled,    "peripheral trace");
   218.          append_option(retrospective_tracing_is_enabled, "retro trace");
   219.          append_option(the_external_trace_is_enabled,    "external trace");
   220.          append_option(the_signature_is_enabled,         "signature hash");
   221.       end if;
   222.       log_line(".");
   223.       log_rule;
   224.    end display_execution_modes;
   225.
   226.    procedure quit_if_requested is
   227.    begin
   228.       if quit_was_requested then
   229.          raise quit_request with ""; -- "" suppresses the default message.
   230.       end if;
   231.    end quit_if_requested;
   232.
   233.    procedure change_diagnostic_mode_if_requested is
   234.    begin
   235.       if the_diagnostic_mode_changed then
   236.          the_diagnostic_mode_changed := False;
   237.          raise mode_change_request;
   238.       end if;
   239.    end change_diagnostic_mode_if_requested;
   240.
   241.    procedure set_diagnostic_mode (a_diagnostic_mode : in settings.diagnostic_mode) is
   242.       tracing_is_allowed    : constant Boolean := a_diagnostic_mode /= fast_mode;
   243.       interrupts_can_happen : constant Boolean := the_execution_mode = boot_mode and tracing_is_allowed;
   244.    begin
   245.       if a_diagnostic_mode = external_mode then
   246.          if (the_diagnostic_mode /= external_mode) and (not the_external_trace_is_enabled) then
   247.             open(the_external_trace_file, the_external_trace_file_name);
   248.          end if;
   249.          the_diagnostic_mode := trace_mode;
   250.          the_external_trace_is_enabled := True;
   251.       else
   252.          the_diagnostic_mode := a_diagnostic_mode;
   253.       end if;
   254.       histogramming_is_enabled         := histogramming_is_wanted         and tracing_is_allowed;
   255.       interrupt_tracing_is_enabled     := interrupt_tracing_is_wanted     and interrupts_can_happen;
   256.       peripheral_tracing_is_enabled    := peripheral_tracing_is_wanted    and tracing_is_allowed;
   257.       retrospective_tracing_is_enabled := retrospective_tracing_is_wanted and tracing_is_allowed;
   258.       the_signature_is_enabled         := the_signature_is_wanted         and tracing_is_allowed;
   259.    end set_diagnostic_mode;
   260.
   261.    procedure set_execution_mode (an_execution_mode : in settings.execution_mode) is
   262.    begin
   263.       the_execution_mode := an_execution_mode;
   264.    end set_execution_mode;
   265.
   266.    package diagnostic_mode_IO   is new Ada.Text_IO.Enumeration_IO(settings.diagnostic_mode);
   267.
   268.    package execution_mode_IO    is new Ada.Text_IO.Enumeration_IO(settings.execution_mode);
   269.
   270.    package authenticity_mode_IO is new Ada.Text_IO.Enumeration_IO(KDF9.authenticity_mode);
   271.
   272.    package equipment_IO         is new Ada.Text_IO.Enumeration_IO(IOC.equipment.kind);
   273.
   274.    procedure get_settings_from_file (version : in String) is
   275.
   276.       the_settings_file_name : constant String := "settings_" & version & ".txt";
   277.       HT                     : constant Character := Character'Val(9);
   278.       counts_are_set : Boolean := False;
   279.       settings_file  : File_Type;
   280.       flag           : Character;
   281.
   282.       procedure set_the_miscellany_flags is
   283.          c  : Character := ' ';
   284.       begin
   285.          skip_to_next_non_blank(settings_file);
   286.          if End_Of_Line(settings_file) then
   287.             reset_default_visibility_options;
   288.             return;
   289.          end if;
   290.          loop
   291.             get(settings_file, c);
   292.             if is_invalid_miscellany_flag(c) then
   293.                if c not in  ' ' | HT  then
   294.                   raise Data_Error;
   295.                end if;
   296.             else
   297.                set_this_miscellany_flag(c);
   298.             end if;
   299.          exit when End_Of_Line(settings_file);
   300.          end loop;
   301.       exception
   302.          when Data_Error =>
   303.             if not End_Of_Line(settings_file) then
   304.                Skip_Line(settings_file);
   305.             end if;
   306.             log_new_line;
   307.             log_line(
   308.                      "***** Error in a miscellany specification: "
   309.                    & (if c = ' ' then "no option was given." else "invalid data «"& c & "».")
   310.                     );
   311.       end set_the_miscellany_flags;
   312.
   313.       procedure set_breakpoints is
   314.          start, end_point : KDF9.code_address;
   315.       begin
   316.          begin
   317.             get_word(settings_file, KDF9.word(start));
   318.          exception
   319.             when others =>
   320.                log_new_line;
   321.                log_line("***** Error in lower address; no breakpoint set.");
   322.                return;
   323.          end;
   324.
   325.          log_new_line;
   326.          log_line(
   327.                   "Lower breakpoint: "
   328.                 & oct_of(KDF9.syllable_address'(start, 0))
   329.                 & " ("
   330.                 & dec_of(KDF9.syllable_address'(start, 0))
   331.                 & ")",
   332.                   iff => the_log_is_wanted
   333.                  );
   334.          breakpoints(start) := True;
   335.
   336.          begin
   337.             get_word(settings_file, KDF9.word(end_point));
   338.          exception
   339.             when Data_Error =>
   340.                log_line("      No upper address: one breakpoint set.", iff => the_log_is_wanted);
   341.                set_breakpoints(start, start);
   342.                return;
   343.          end;
   344.          log_line(
   345.                   "Upper breakpoint: "
   346.                 & oct_of(KDF9.syllable_address'(end_point, 5))
   347.                 & " (" & dec_of(KDF9.syllable_address'(end_point, 5))
   348.                 & ")",
   349.                   iff => the_log_is_wanted
   350.                  );
   351.          set_breakpoints(start, end_point);
   352.       exception
   353.          when others =>
   354.             log_line("***** Error setting breakpoints; ignored.");
   355.       end set_breakpoints;
   356.
   357.       procedure set_store_points is
   358.          start, end_point : KDF9.address;
   359.       begin
   360.          begin
   361.             get_word(settings_file, KDF9.word(start));
   362.          exception
   363.             when others =>
   364.                log_new_line;
   365.                log_line("***** Error in lower address; no storepoint set.");
   366.                return;
   367.          end;
   368.          log_new_line;
   369.          log_line(
   370.                   "Lower storepoint: #"
   371.                 & oct_of(start)
   372.                 & " ("
   373.                 & dec_of(start)
   374.                 & ")",
   375.                   iff => the_log_is_wanted
   376.                  );
   377.          begin
   378.             get_word(settings_file, KDF9.word(end_point));
   379.          exception
   380.             when Data_Error =>
   381.                log_line("      No upper address: one storepoint set.", iff => the_log_is_wanted);
   382.                set_store_points(start, start);
   383.                return;
   384.          end;
   385.          log_line(
   386.                   "Upper storepoint: #"
   387.                 & oct_of(end_point)
   388.                 & " ("
   389.                 & dec_of(end_point)
   390.                 & ")",
   391.                   iff => the_log_is_wanted
   392.                  );
   393.          set_store_points(start, end_point);
   394.       exception
   395.          when others =>
   396.             log_line("***** Error setting storepoints; ignored.");
   397.       end set_store_points;
   398.
   399.       procedure set_watchpoints is
   400.          start, end_point : KDF9.address;
   401.       begin
   402.          begin
   403.             get_word(settings_file, KDF9.word(start));
   404.          exception
   405.             when others =>
   406.                log_new_line;
   407.                log_line("***** Error in lower address; no watchpoint set.");
   408.                return;
   409.          end;
   410.          log_new_line;
   411.          log_line(
   412.                   "Lower watchpoint: #"
   413.                 & oct_of(start)
   414.                 & " ("
   415.                 & dec_of(start)
   416.                 & ")",
   417.                   iff => the_log_is_wanted
   418.                  );
   419.          begin
   420.             get_word(settings_file, KDF9.word(end_point));
   421.          exception
   422.             when Data_Error =>
   423.                log_line("      No upper address: one watchpoint set.", iff => the_log_is_wanted);
   424.                set_store_points(start, start);
   425.                set_fetch_points(start, start);
   426.                return;
   427.          end;
   428.          log_line("Upper watchpoint: #" & oct_of(end_point) & " (" & dec_of(end_point) & ")",
   429.                   iff => the_log_is_wanted);
   430.          set_fetch_points(start, end_point);
   431.          set_store_points(start, end_point);
   432.       exception
   433.          when others =>
   434.             log_line("***** Error setting watchpoints; ignored.");
   435.       end set_watchpoints;
   436.
   437.       procedure set_specified_dumping_ranges (epoch : in dumping.flag) is
   438.          use dumping.flag_support;
   439.          epoch_flag   : constant Character := (if epoch = initial_flag then 'I' else 'F');
   440.          format       : dumping.format_set := no_dumping_flags or epoch;
   441.          first_address,
   442.          last_address : KDF9.address := 0;
   443.          bad_range    : Boolean := False;
   444.          data         : KDF9.word;
   445.          c            : Character;
   446.          OK           : Boolean;
   447.       begin
   448.          log("Dump: format " & epoch_flag, iff => the_log_is_wanted);
   449.          while not End_Of_Line(settings_file) loop
   450.             get(settings_file, c);
   451.             log(c, iff => the_log_is_wanted);
   452.          exit when c = ' ';
   453.             if is_parameter_flag/dumping_flag(to_upper(c)) then
   454.                format := format or dumping_flag(to_upper(c));
   455.             else
   456.                if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   457.                log_new_line;
   458.                log_line("***** Error: «"& c & "» is not a valid dump type.");
   459.                return;
   460.             end if;
   461.          end loop;
   462.          log_new_line;
   463.
   464.          if (format and is_parameter_flag) /= no_dumping_flags then
   465.             get_word(settings_file, data);
   466.             if data > max_address                     or else
   467.                   (format/Usercode_flag and data > 8191) then
   468.                log_line(
   469.                         "***** Error: Lower dump address  = #"
   470.                       & oct_of(data)
   471.                       & " =" & data'Image
   472.                       & " is too large for this option."
   473.                        );
   474.                bad_range := True;
   475.             else
   476.                first_address := KDF9.address(data);
   477.                last_address  := KDF9.address(data);
   478.                log_line(
   479.                         "      Lower dump address: #"
   480.                       & oct_of(first_address)
   481.                       & " (" & dec_of(first_address)
   482.                       & ")",
   483.                         iff => the_log_is_wanted
   484.                        );
   485.             end if;
   486.
   487.            skip_to_next_non_blank (settings_file);
   488.
   489.             if not end_of_line(settings_file) then
   490.                get_word(settings_file, data);
   491.                if data > max_address                     or else
   492.                   (format/Usercode_flag and data > 8191) then
   493.                   log_line(
   494.                            "***** Error: Upper dump address: #"
   495.                          & oct_of(data)
   496.                          & " =" & data'Image
   497.                          & " is too large for this option."
   498.                           );
   499.                   bad_range := True;
   500.                else
   501.                   last_address := KDF9.address(data);
   502.                   log_line(
   503.                            "      Upper dump address: #"
   504.                          & oct_of(last_address)
   505.                          & " ("
   506.                          & dec_of(last_address)
   507.                          & ")",
   508.                            iff => the_log_is_wanted
   509.                           );
   510.                end if;
   511.             end if;
   512.
   513.             if first_address > last_address then
   514.                log_line(
   515.                         "***** Error: Upper dump address: #"
   516.                       & oct_of(last_address)
   517.                       & " =" & last_address'Image
   518.                       & " is less than lower dump address: #"
   519.                       & oct_of(first_address)
   520.                       & " =" & first_address'Image
   521.                       & "."
   522.                        );
   523.                bad_range := True;
   524.             end if;
   525.          end if;
   526.
   527.          if not bad_range then
   528.             request_a_dumping_area(format, first_address, last_address, OK);
   529.             if not OK then
   530.                log_line("***** Error: Too many dump specifications (ignored).");
   531.             end if;
   532.          end if;
   533.
   534.          if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   535.       exception
   536.          when others =>
   537.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   538.             log_new_line;
   539.             log_line("***** Error in a dump area specification (ignored)." );
   540.       end set_specified_dumping_ranges;
   541.
   542.       procedure set_initial_dumping_ranges is
   543.       begin
   544.          set_specified_dumping_ranges(initial_flag);
   545.       end set_initial_dumping_ranges;
   546.
   547.       procedure set_final_dumping_ranges is
   548.       begin
   549.          set_specified_dumping_ranges(final_flag);
   550.       end set_final_dumping_ranges;
   551.
   552.       procedure set_histogram_options is
   553.          c : Character;
   554.       begin
   555.          while not End_Of_Line(settings_file) loop
   556.             get(settings_file, c);
   557.          exit when c = ' ';
   558.             if c not in 'P' | 'p' | 'T' | 't' then
   559.                raise Data_Error;
   560.             end if;
   561.             if c in 'P' | 'p' then
   562.                the_profile_is_wanted  := True;
   563.                clear_the_profile;
   564.             elsif c in  'T' | 't' then
   565.                the_INS_plot_is_wanted := True;
   566.                clear_the_histogram;
   567.             end if;
   568.          end loop;
   569.          ensure_not_at_end_of_line(settings_file);
   570.          get(settings_file, histogram_cutoff);
   571.          if histogram_cutoff >= 100.0 or histogram_cutoff < 0.0 then
   572.             raise Data_Error;
   573.          end if;
   574.          get(settings_file, c);
   575.          if c /= '%' then
   576.             raise Data_Error;
   577.          end if;
   578.       exception
   579.          when others =>
   580.             histogram_cutoff := cutoff_default;
   581.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   582.             log_new_line;
   583.             log_line("***** Error in the histogram option; default used.");
   584.       end set_histogram_options;
   585.
   586.       procedure set_time_limit is
   587.          begin
   588.             begin
   589.             get_decimal(settings_file, KDF9.word(time_limit));
   590.          exception
   591.             when others =>
   592.                if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   593.                time_limit := offline_time_limit;
   594.          end;
   595.
   596.          if not counts_are_set then
   597.             high_count := time_limit;
   598.          end if;
   599.
   600.          log_new_line;
   601.          log_line("Time limit (in instructions) =" & time_limit'Image,
   602.                   iff => the_log_is_wanted);
   603.       end set_time_limit;
   604.
   605.       procedure set_tracing_counts is
   606.
   607.          procedure show_counts is
   608.          begin
   609.             if not the_log_is_wanted then return; end if;
   610.             log_new_line;
   611.             log_line("Lower tracing count:" & low_count'Image);
   612.             log_line("Upper tracing count:" & high_count'Image);
   613.          end show_counts;
   614.
   615.       begin
   616.          get_decimal(settings_file, KDF9.word(low_count));
   617.          get_decimal(settings_file, KDF9.word(high_count));
   618.          show_counts;
   619.          if low_count > high_count then
   620.             log_new_line;
   621.             log_line("***** Error: Low count > high count.");
   622.             raise Data_Error;
   623.          end if;
   624.          counts_are_set := True;
   625.       exception
   626.          when others =>
   627.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   628.             low_count  := low_count_default;
   629.             high_count := high_count_default;
   630.             log_new_line;
   631.             log_line("***** Error in a tracing count; defaults used.");
   632.             show_counts;
   633.       end set_tracing_counts;
   634.
   635.       procedure set_tracing_range is
   636.
   637.          procedure show_range is
   638.          begin
   639.             if not the_log_is_wanted then return; end if;
   640.             log_new_line;
   641.             log_line(
   642.                      "Lower trace address: #"
   643.                    & oct_of(KDF9.syllable_address'(low_bound, 0))
   644.                    & " ("
   645.                    & dec_of(KDF9.syllable_address'(low_bound, 0))
   646.                    & ")"
   647.                     );
   648.             log_line(
   649.                      "Upper trace address: #"
   650.                    & oct_of(KDF9.syllable_address'(high_bound, 5))
   651.                    & " ("
   652.                    & dec_of(KDF9.syllable_address'(high_bound, 5))
   653.                    & ")"
   654.                     );
   655.          end show_range;
   656.
   657.       begin
   658.          get_word(settings_file, KDF9.word(low_bound));
   659.          get_word(settings_file, KDF9.word(high_bound));
   660.          if low_bound > high_bound then
   661.             log_new_line;
   662.             log_line("***** Error: Low bound > high bound.");
   663.             raise Data_Error;
   664.          end if;
   665.          show_range;
   666.       exception
   667.          when others =>
   668.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   669.             low_bound  := low_bound_default;
   670.             high_bound := high_bound_default;
   671.             log_new_line;
   672.             log_line("***** Error in a tracing address; defaults used.");
   673.             show_range;
   674.       end set_tracing_range;
   675.
   676.       procedure set_diagnostic_mode is
   677.          use diagnostic_mode_IO;
   678.          the_diagnostic_mode : settings.diagnostic_mode;
   679.       begin
   680.          ensure_not_at_end_of_line(settings_file);
   681.          get(settings_file, the_diagnostic_mode);
   682.          set_diagnostic_mode(the_diagnostic_mode);
   683.       exception
   684.          when others =>
   685.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   686.             set_diagnostic_mode(the_diagnostics_default);
   687.             log_new_line;
   688.             log_line("***** Error in the diagnostic mode; default used.");
   689.       end set_diagnostic_mode;
   690.
   691.       procedure set_execution_mode is
   692.          use execution_mode_IO;
   693.       begin
   694.          ensure_not_at_end_of_line(settings_file);
   695.          get(settings_file, the_execution_mode);
   696.       exception
   697.          when others =>
   698.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   699.             the_execution_mode := the_execution_default;
   700.             log_new_line;
   701.             log_line("***** Error in the testing mode; default used.");
   702.       end set_execution_mode;
   703.
   704.       procedure set_authenticity is
   705.          use authenticity_mode_IO;
   706.       begin
   707.          ensure_not_at_end_of_line(settings_file);
   708.          get(settings_file, the_authenticity_mode);
   709.          if the_authenticity_mode = authentic_time_mode then
   710.             authentic_timing_is_enabled := True;
   711.          end if;
   712.       exception
   713.          when others =>
   714.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   715.             the_authenticity_mode := the_authenticity_default;
   716.             log_new_line;
   717.             log_line("***** Error in the authenticity mode; default used.");
   718.       end set_authenticity;
   719.
   720.       procedure set_graph_plotting_pen is
   721.          use postscript;
   722.          use colour_IO;
   723.          use  width_IO;
   724.          the_colour   : pen_colour   := the_default_colour;
   725.          the_pen_size : pen_tip_size := the_default_tip_size;
   726.
   727.          procedure show_pen_options is
   728.          begin
   729.             if not the_log_is_wanted then return; end if;
   730.             log_new_line;
   731.             if the_colour /= the_default_colour then
   732.                log_line("The graph plotter pen colour is " & the_colour'Image & ".");
   733.             end if;
   734.             if the_pen_size /= the_default_tip_size then
   735.                log_line("The graph plotter pen tip is " & the_pen_size'Image & ".");
   736.             end if;
   737.          end show_pen_options;
   738.
   739.          procedure configure_the_plotter is
   740.          begin
   741.             if the_colour /= the_default_colour or the_pen_size /= the_default_tip_size then
   742.                set_the_pen_properties(the_colour, the_pen_size);
   743.                show_pen_options;
   744.             end if;
   745.          end configure_the_plotter;
   746.
   747.       begin  -- set_graph_plotting_pen
   748.          ensure_not_at_end_of_line(settings_file);
   749.          begin
   750.             Get(settings_file, the_colour);
   751.          exception
   752.             when others =>
   753.                log_new_line;
   754.                log_line("***** Error in the plotter pen the_colour; default used.");
   755.          end;
   756.          ensure_not_at_end_of_line(settings_file);
   757.          begin
   758.             Get(settings_file, the_pen_size);
   759.          exception
   760.             when others =>
   761.                log_new_line;
   762.                log_line("***** Error in the plotter pen tip; default used.");
   763.          end;
   764.          configure_the_plotter;
   765.       exception
   766.          when Data_Error =>
   767.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   768.             configure_the_plotter;
   769.       end set_graph_plotting_pen;
   770.
   771.       procedure set_non_interactivity is
   772.       begin
   773.          noninteractive_usage_is_enabled := True;
   774.          set_time_limit;
   775.       end set_non_interactivity;
   776.
   777.       procedure save_poke_value is
   778.          -- W: full Word, U: Upper halfword, L: Lower halfword, S: Syllable, C: Character
   779.          address  : KDF9.address;
   780.          sub_word : Character;
   781.          position : KDF9.address;
   782.          value    : KDF9.word;
   783.          OK       : Boolean;
   784.       begin
   785.          begin
   786.             get_word(settings_file, KDF9.word(address));
   787.          exception
   788.             when others =>
   789.                log_line("***** Error in poke word address.");
   790.                Skip_Line(settings_file);
   791.                return;
   792.          end;
   793.
   794.          get_char(settings_file, sub_word);
   795.          if sub_word not in 'S' | 's' | 'C' | 'c' | 'L' | 'l' | 'U' | 'u' | 'W' | 'w' then
   796.             log_line(
   797.                      "***** Error in (sub)word indicator; "
   798.                    & sub_word
   799.                    & " should be W, L, U, S, or C."
   800.                     );
   801.             Skip_Line(settings_file);
   802.             return;
   803.          end if;
   804.
   805.          if sub_word in 'S' | 's' | 'C' | 'c' then
   806.             begin
   807.                get_word(settings_file, KDF9.word(position));
   808.                if (sub_word in 'S' | 's' and position > 5) or else
   809.                   (sub_word in 'C' | 'c' and position > 7)    then
   810.                   log_line(
   811.                            "***** Error in position given for a "
   812.                          & (if sub_word in 'S' | 's' then "syllable:" else "character:")
   813.                          & position'Image
   814.                          & " is too large, poke request ignored."
   815.                           );
   816.                   Skip_Line(settings_file);
   817.                   return;
   818.                end if;
   819.             exception
   820.                when others =>
   821.                   log_line(
   822.                            "***** Error in position given for a "
   823.                          & (if sub_word in 'S' | 's' then "syllable" else "character")
   824.                          & ", poke request ignored."
   825.                           );
   826.                   Skip_Line(settings_file);
   827.                   return;
   828.             end;
   829.          else
   830.             position := 0;
   831.          end if;
   832.
   833.          begin
   834.             get_word(settings_file, value);
   835.          exception
   836.             when others =>
   837.                log_line("***** Error in poked value.");
   838.                Skip_Line(settings_file);
   839.                return;
   840.          end;
   841.
   842.          if (sub_word in 'L' | 'l' | 'U' | 'u' and value > 2**24-1) or else
   843.                (sub_word in 'S' | 's'          and value > 255)     or else
   844.                   (sub_word in 'C' | 'c'       and value > 63)      then
   845.             log_line(
   846.                      "***** Error in poked value #"
   847.                    & oct_of(value)
   848.                    & ": out of range for a "
   849.                    & (case sub_word is
   850.                          when 'L' | 'l' | 'U' | 'u' => "halfword",
   851.                          when 'S' | 's'             => "syllable",
   852.                          when 'C' | 'c'             => "character",
   853.                          when others                => "word")
   854.                    & ", poke request ignored."
   855.                     );
   856.             Skip_Line(settings_file);
   857.             return;
   858.          end if;
   859.
   860.          add_to_poke_list(address, sub_word, position, value, OK);
   861.
   862.          if not OK then
   863.             log_line("***** Error setting up a poke: poke list full; request ignored.");
   864.          end if;
   865.
   866.       exception
   867.
   868.          when others =>
   869.             null;  -- to skip line at end of input loop
   870.
   871.       end save_poke_value;
   872.
   873.       procedure set_KDF9_configuration is
   874.          use equipment_IO;
   875.          use IOC.equipment;
   876.          d : IOC.equipment.kind := AD;
   877.          b : KDF9.buffer_number;
   878.       begin
   879.          if version = "1" then
   880.             for i in IOC.equipment.setup'Range loop
   881.             exit when end_of_line(settings_file);
   882.                get_word(settings_file, KDF9.word(b));
   883.                ensure_not_at_end_of_line(settings_file);
   884.                get(settings_file, d);
   885.                IOC.equipment.choice(b) := d;
   886.             end loop;
   887.          else
   888.             log_new_line;
   889.             log_line("The previous KDF9 configuration is still being used.");
   890.          end if;
   891.          if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   892.       exception
   893.          when others =>
   894.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   895.             IOC.equipment.choice := IOC.equipment.default;
   896.             log_new_line;
   897.             log_line("***** Error in the device configuration; defaults used.");
   898.       end set_KDF9_configuration;
   899.
   900.       procedure set_symbols is
   901.          c : Character := ' ';
   902.          w : KDF9.word;
   903.          a : KDF9.address;
   904.          v : KDF9.address;
   905.          p : Natural;
   906.       begin
   907.          if End_Of_Line(settings_file) then
   908.             clear_all_symbol_definitions;
   909.             return;
   910.          end if;
   911.          get(settings_file, c);
   912.          if    c = '#' then
   913.             get(settings_file, c);
   914.             get_word(settings_file, KDF9.word(a));
   915.             if c = 'V' then
   916.                declare_P0(a);
   917.             elsif c = 'Y' then
   918.                define_Y_size(if a = KDF9.address'Last then 0 else a);
   919.             else
   920.                raise Data_Error;
   921.             end if;
   922.          elsif c = 'W' then
   923.             get_word(settings_file, KDF9.word(a));
   924.             define_W0(a);
   925.          elsif c = 'Y' then
   926.             get_word(settings_file, KDF9.word(a));
   927.             define_Y0(a);
   928.          elsif c = 'Z' then
   929.             get_word(settings_file, KDF9.word(a));
   930.             define_Z0(a);
   931.          elsif c = 'P' then
   932.             loop
   933.                skip_to_next_non_blank(settings_file);
   934.                if End_Of_Line(settings_file) then
   935.                   return;
   936.                end if;
   937.                get_word(settings_file, KDF9.word(p));
   938.                skip_to_next_non_blank(settings_file);
   939.                get(settings_file, c);
   940.             exit when c /= '#';
   941.                get_decimal(settings_file, w);
   942.                v := KDF9.address(w+1);
   943.                skip_to_next_non_blank(settings_file);
   944.                get(settings_file, c);
   945.             exit when c /= '@';
   946.                get_word(settings_file, KDF9.word(a));
   947.                declare_Pp(p, v, a);
   948.             end loop;
   949.          elsif c = ' ' then
   950.             loop
   951.                skip_to_next_non_blank(settings_file);
   952.                if End_Of_Line(settings_file) then
   953.                   return;
   954.                end if;
   955.                get(settings_file, c);
   956.                if c not in 'A' .. 'Z'  then
   957.                      raise Data_Error;
   958.                end if;
   959.                get_word(settings_file, KDF9.word(a));
   960.                define_Yy0(c, a);
   961.             end loop;
   962.          else
   963.             raise Data_Error;
   964.          end if;
   965.       exception
   966.          when Data_Error =>
   967.             if not End_Of_Line(settings_file) then
   968.                Skip_Line(settings_file);
   969.             end if;
   970.             log_new_line;
   971.             log_line(
   972.                      "***** Error in a Y flag specification: "
   973.                    & "invalid data after «"
   974.                    & c
   975.                    & "»."
   976.                     );
   977.       end set_symbols;
   978.
   979.       error_count : Natural := 0;
   980.
   981.    begin -- get_settings_from_file
   982.
   983.       do_not_execute := False;
   984.       high_count := time_limit;
   985.       open_options_file(settings_file, the_settings_file_name);
   986.       if End_of_File(settings_file) then
   987.          raise End_Error;
   988.       end if;
   989.
   990.       loop
   991.          skip_to_next_nonempty_line(settings_file);
   992.          get(settings_file, flag);
   993.          case flag is
   994.             when 'A' | 'a' =>
   995.                set_authenticity;
   996.             when 'B' | 'b' =>
   997.                set_breakpoints;
   998.             when 'C' | 'c' =>
   999.                set_tracing_counts;
  1000.             when 'D' | 'd' =>
  1001.                set_diagnostic_mode;
  1002.             when 'F' | 'f' =>
  1003.                set_final_dumping_ranges;
  1004.             when 'G' | 'g' =>
  1005.                set_graph_plotting_pen;
  1006.             when 'H' | 'h' =>
  1007.                set_histogram_options;
  1008.             when 'I' | 'i' =>
  1009.                set_initial_dumping_ranges;
  1010.             when 'K' | 'k' =>
  1011.                set_KDF9_configuration;
  1012.             when 'L' | 'l' =>
  1013.                set_time_limit;
  1014.             when 'N' | 'n' =>
  1015.                set_non_interactivity;
  1016.                time_limit := offline_time_limit;
  1017.             when 'O' |'o' =>
  1018.                set_this_miscellany_flag(flag);
  1019.             when 'P' | 'p' =>
  1020.                save_poke_value;
  1021.             when 'Q' | 'q' =>
  1022.                do_not_execute := True;
  1023.             when 'R' | 'r' =>
  1024.                set_tracing_range;
  1025.             when 'S' | 's' =>
  1026.                set_store_points;
  1027.             when 'T' | 't' =>
  1028.                set_execution_mode;
  1029.             when 'V' | 'v' =>
  1030.                set_the_miscellany_flags;
  1031.             when 'W' | 'w' =>
  1032.                set_watchpoints;
  1033.             when 'X' | 'x' =>
  1034.                only_signature_tracing := True;
  1035.             when 'Y' | 'y' =>
  1036.                set_symbols;
  1037.             when '-' | '/' =>
  1038.                Skip_Line(settings_file);
  1039.             when others =>
  1040.                if error_count > 10 then
  1041.                   log_new_line;
  1042.                   log_line("There are too many invalid flags in " & the_settings_file_name & ".");
  1043.                   raise operator_error;
  1044.                end if;
  1045.                error_count := error_count + 1;
  1046.                log_line(
  1047.                         "Invalid flag: """
  1048.                       & flag
  1049.                       & """ at line "
  1050.                       & line_number'Image
  1051.                       & " of the settings file!"
  1052.                        );
  1053.                log_line("The valid flags are A,B,C,D,F,G,I,K,L,N,O,P,Q,R,S,T,V,W,X, -, and /");
  1054.                Skip_Line(settings_file);
  1055.                line_number := line_number + 1;
  1056.          end case;
  1057.       end loop;
  1058.
  1059.    exception
  1060.
  1061.       when Status_Error =>
  1062.          log_line("***** Error: " & the_settings_file_name & " was not found; defaults used.");
  1063.          log_new_line;
  1064.
  1065.       when End_Error =>
  1066.          close_options_file(settings_file, the_settings_file_name);
  1067.
  1068.       when operator_error  =>
  1069.          trap_operator_error("Abandoning the run");
  1070.
  1071.       when Data_Error =>
  1072.          close_options_file(settings_file, the_settings_file_name);
  1073.          if error_count < 10 then
  1074.             log_new_line;
  1075.             log_line("***** Error: invalid data in the settings file.");
  1076.             log_line(
  1077.                      "Reading of settings abandoned at line "
  1078.                    & line_number'Image
  1079.                    & " of "
  1080.                    & the_settings_file_name
  1081.                    & "."
  1082.                     );
  1083.          else
  1084.             raise;
  1085.          end if;
  1086.
  1087.       when error : others =>
  1088.          close_options_file(settings_file, the_settings_file_name);
  1089.          log_new_line;
  1090.          log_line(
  1091.                   "Failure in ee9; unexpected exception: "
  1092.                 & Exception_Information(error)
  1093.                 & " in get_settings_from_file!"
  1094.                  );
  1095.          log_line(
  1096.                   "Reading of settings abandoned at line "
  1097.                 & line_number'Image
  1098.                 & " of "
  1099.                 & the_settings_file_name
  1100.                 & "!"
  1101.                  );
  1102.          log_rule;
  1103.          raise;
  1104.
  1105.    end get_settings_from_file;
  1106.
  1107. end settings;

Compiling: ../Source/settings.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- execution mode, diagnostic mode, and other emulation-control settings
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18. with logging.file;
    19.
    20. use  KDF9;
    21. use  logging.file;
    22.
    23. package settings is
    24.
    25. --
    26.    -- In fast mode: code runs as efficiently as possible, without diagnostics.
    27.
    28.    -- In trace mode: breakpoints, watchpoints, tracing address bounds and
    29.    --    tracing instruction count bounds are all honoured;
    30.    --       entries may be made in all the retrospective trace logs;
    31.    --          a digital execution signature may be computed,
    32.    --             and an instruction-frequency histogram may be generated.
    33.
    34.    -- In pause mode: execution proceeds as in trace mode;
    35.    --    additionally, breakpoints occur on every order executed within trace bounds.
    36.
    37.    -- The external mode is a user-interface value only. It requests the trace mode,
    38.    --    combined with the logging of a running trace to an external file.
    39. --
    40.
    41.    type diagnostic_mode is (fast_mode,
    42.                             trace_mode,
    43.                             pause_mode,
    44.                             external_mode);
    45.
    46.    procedure set_diagnostic_mode (a_diagnostic_mode : in settings.diagnostic_mode);
    47.
    48.    procedure change_diagnostic_mode_if_requested;
    49.
    50.    the_diagnostics_default  : constant settings.diagnostic_mode := fast_mode;
    51.    the_diagnostic_mode      : settings.diagnostic_mode := the_diagnostics_default;
    52.
    53.    the_external_trace_file_name : constant String := "trace.txt";
    54.    only_signature_tracing       : Boolean := False;
    55.    the_external_trace_file      : logging.file.output;
    56.
    57.    -- The diagnostic generation and display controls, inter alia.
    58.    -- The *_trace_is_wanted flags are set to True iff
    59.    --    they are both requested, and offered by the_diagnostic_mode.
    60.    -- These requests may be set by the miscellany and visibilty options.
    61.
    62.    miscellany_flags  : constant String := "abdefghiknopqrstwxyz.0123456789ABDEFGHIKMNOPQRSTWXYZ";
    63.    miscellany_prompt : constant String := "{a|b|d|e|f|g|h|i|k|n|o|p|q|r|s|t|w|x|z|.|0..9}";
    64.
    65.    -- *_is_wanted  iff the facility is provided by default.
    66.    -- *_is_enabled iff the facility is wanted and not suppressed by other considerations,
    67.    --    such as the diagnostic mode (e.g. fast mode suppresses all tracing).
    68.
    69.    API_logging_is_wanted,
    70.    flexowriter_output_is_wanted,
    71.    histogramming_is_wanted,
    72.    interrupt_tracing_is_wanted,
    73.    peripheral_tracing_is_wanted,
    74.    realistic_FW_output_is_wanted,
    75.    retrospective_tracing_is_wanted,
    76.    the_final_state_is_wanted,
    77.    the_log_is_wanted,
    78.    the_signature_is_wanted         : Boolean := True;
    79.
    80.    authentic_timing_is_enabled,
    81.    debugging_is_enabled,
    82.    do_not_execute,
    83.    histogramming_is_enabled,
    84.    interrupt_tracing_is_enabled,
    85.    noninteractive_usage_is_enabled,
    86.    peripheral_tracing_is_enabled,
    87.    pre_overlay_state_is_enabled,
    88.    retrospective_tracing_is_enabled,
    89.    the_external_trace_is_enabled,
    90.    the_signature_is_enabled        : Boolean := False;
    91.
    92.    procedure reset_default_visibility_options;
    93.
    94.    -- In boot_mode: a Director program is read from TR0 and executed
    95.    --    in Director state, with full use of the emulated hardware.
    96.    -- In program_mode: a user program is read from TR0 and executed
    97.    --    in program state, with basic OUTs implemented by the emulator.
    98.    -- In privileged_mode: a user program is read from TR0 and executed
    99.    --    as in program state, but allowing orders that should LIV to succeed,
   100.    --    this being useful for executing "hardware test" programs.
   101.
   102.    type execution_mode is (boot_mode, program_mode, privileged_mode);
   103.
   104.    procedure set_execution_mode (an_execution_mode : in settings.execution_mode);
   105.
   106.    the_execution_default   : constant settings.execution_mode := program_mode;
   107.    the_execution_mode      :          settings.execution_mode := the_execution_default;
   108.
   109.    this_is_a_bare_Director : Boolean := False;
   110.
   111.    --
   112.    -- Tracing bound settings.
   113.    --
   114.
   115.    -- time_limit bounds the number of KDF9 instructions executed.
   116.
   117.    time_limit_default : constant KDF9.order_counter := KDF9.order_counter'Last;
   118.    time_slice         : constant KDF9.order_counter := 10_000;
   119.    offline_time_limit : constant KDF9.order_counter := 10_000 * time_slice;
   120.    time_limit         :          KDF9.order_counter := time_limit_default;
   121.
   122.
   123.    -- low_bound and high_bound bound the static scope of tracing.
   124.
   125.    low_bound_default  : constant KDF9.code_address := 0;
   126.    high_bound_default : constant KDF9.code_address := KDF9.code_address'Last;
   127.    low_bound          :          KDF9.code_address := low_bound_default;
   128.    high_bound         :          KDF9.code_address := high_bound_default;
   129.
   130.    -- low_count and high_count bound the dynamic scope of tracing.
   131.
   132.    low_count_default  : constant KDF9.order_counter := 0;
   133.    high_count_default : constant KDF9.order_counter := time_limit_default;
   134.    low_count          :          KDF9.order_counter := low_count_default;
   135.    high_count         :          KDF9.order_counter := high_count_default;
   136.
   137.    -- Histogram bin frequencies less than histogram_cutoff are not logged.
   138.    the_profile_is_wanted  :          Boolean := False;
   139.    the_INS_plot_is_wanted :          Boolean := False;
   140.    cutoff_default         : constant Long_Float := 0.0;
   141.    histogram_cutoff       :          Long_Float := cutoff_default;
   142.
   143.    function is_invalid_miscellany_flag (option : in Character)
   144.    return Boolean;
   145.
   146.    procedure set_this_miscellany_flag (option : in Character);
   147.
   148.    procedure get_settings_from_file (version : in String);
   149.
   150.    procedure display_execution_modes (for_this : in String := "");
   151.
   152.    procedure quit_if_requested;
   153.
   154.    quit_was_requested          : Boolean := False;
   155.
   156.    the_diagnostic_mode_changed : Boolean := False;
   157.
   158.    loading_was_successful      : Boolean := False;
   159.
   160.    mode_change_request         : exception;
   161.
   162. end settings;

 1107 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/logging-panel.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Provide logging output to an interactive terminal/control panel.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with POSIX;
    18. with settings;
    19.
    20. use  POSIX;
    21. use  settings;
    22.
    23. package body logging.panel is
    24.
    25.    not overriding
    26.    function column (logger : panel.display)
    27.    return Positive
    28.    is (logger.column_number);
    29.
    30.    overriding
    31.    procedure tab_log (logger   : in out panel.display;
    32.                       at_least : in Natural;
    33.                       spacing  : in Positive;
    34.                       iff      : in Boolean := True) is
    35.       new_col : constant Natural := logger.column_number + at_least;
    36.       deficit : constant Natural := (spacing - new_col mod spacing) mod spacing;
    37.    begin
    38.       if not iff then return; end if;
    39.       for i in logger.column_number .. (new_col + deficit) loop
    40.          POSIX.output(' ');
    41.       end loop;
    42.       logger.column_number := new_col + deficit;
    43.    end tab_log;
    44.
    45.    overriding
    46.    procedure tab_log_to (logger : in out panel.display;
    47.                          column : in Positive;
    48.                          iff    : in Boolean := True) is
    49.    begin
    50.       if not iff then return; end if;
    51.       if column < logger.column_number then
    52.          logger.log_new_line;
    53.       end if;
    54.       for i in logger.column_number .. column-1 loop
    55.          POSIX.output(' ');
    56.       end loop;
    57.       logger.column_number := column;
    58.    end tab_log_to;
    59.
    60.    overriding
    61.    procedure log (logger : in out panel.display;
    62.                   char   : in Character;
    63.                   iff    : in Boolean := True) is
    64.    begin
    65.       if not iff then return; end if;
    66.       POSIX.output(char);
    67.       logger.column_number := logger.column_number + 1;
    68.    end log;
    69.
    70.    overriding
    71.    procedure log (logger : in out panel.display;
    72.                   text   : in String;
    73.                   iff    : in Boolean := True) is
    74.    begin
    75.       if not iff then return; end if;
    76.       if text /= "" then
    77.          POSIX.output(text);
    78.       end if;
    79.       logger.column_number := logger.column_number + text'Length;
    80.    end log;
    81.
    82.    overriding
    83.    procedure log_new_line (logger : in out panel.display;
    84.                            iff    : in Boolean := True) is
    85.    begin
    86.       if not iff then return; end if;
    87.       POSIX.output_line;
    88.       logger.column_number := 1;
    89.    end log_new_line;
    90.
    91.    not overriding
    92.    procedure show_line (logger : in out panel.display; message : in String := "") is
    93.    begin
    94.       if message /= "" then
    95.          logger.log(message);
    96.       end if;
    97.       logger.log_new_line;
    98.    end show_line;
    99.
   100.    not overriding
   101.    procedure interact (logger : in out panel.display; reason : in String := "Mode") is
   102.       old_mode : constant settings.diagnostic_mode := the_diagnostic_mode;
   103.       response : response_kind;
   104.       choice   : Character;
   105.    begin
   106.    interaction_loop:
   107.       loop
   108.          logger.column_number := 1;
   109.          POSIX.debug_prompt(noninteractive_usage_is_enabled, reason, response, choice);
   110.          if response = name_response then
   111.             case choice is
   112.                when 'q' | 'Q' =>
   113.                   quit_was_requested := True;
   114.                   exit interaction_loop;
   115.                when 'd' | 'D' =>
   116.                   debugging_is_enabled := not debugging_is_enabled;
   117.                   exit interaction_loop;
   118.                when 'f' | 'F' =>
   119.                   set_diagnostic_mode(fast_mode);
   120.                   exit interaction_loop;
   121.                when 'p' | 'P' =>
   122.                   set_diagnostic_mode(pause_mode);
   123.                   exit interaction_loop;
   124.                when 't' | 'T' =>
   125.                   set_diagnostic_mode(trace_mode);
   126.                   exit interaction_loop;
   127.                when others =>
   128.                   null; -- An invalid choice, try again.
   129.             end case;
   130.          elsif response = EOF_response then
   131.             exit;
   132.          end if;
   133.       end loop interaction_loop;
   134.       the_diagnostic_mode_changed := (the_diagnostic_mode /= old_mode) or quit_was_requested;
   135.    end interact;
   136.
   137. end logging.panel;

Compiling: ../Source/logging-panel.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Provide logging output to an interactive terminal/control panel.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package logging.panel is
    18.
    19.    type display is new logging.output with private;
    20.
    21.    not overriding
    22.    function column (logger : panel.display)
    23.    return Positive;
    24.
    25.    overriding
    26.    procedure tab_log (logger   : in out panel.display;
    27.                       at_least : in Natural;
    28.                       spacing  : in Positive;
    29.                       iff      : in Boolean := True);
    30.
    31.    overriding
    32.    procedure tab_log_to (logger : in out panel.display;
    33.                          column : in Positive;
    34.                          iff    : in Boolean := True);
    35.
    36.    overriding
    37.    procedure log (logger : in out panel.display;
    38.                   char   : in Character;
    39.                   iff    : in Boolean := True);
    40.
    41.    overriding
    42.    procedure log (logger : in out panel.display;
    43.                   text   : in String;
    44.                   iff    : in Boolean := True);
    45.
    46.    overriding
    47.    procedure log_new_line (logger : in out panel.display;
    48.                            iff    : in Boolean := True);
    49.
    50.    not overriding
    51.    procedure show_line (logger : in out panel.display; message : in String := "");
    52.
    53.    not overriding
    54.    procedure interact (logger : in out panel.display; reason : in String := "Mode");
    55.
    56.    overriding
    57.    procedure open (logger : in out panel.display; logfile_name : in String) is null;
    58.
    59.    overriding
    60.    procedure close (logger : in out panel.display; logfile_name : in String) is null;
    61.
    62.    overriding
    63.    procedure flush (logger : in out panel.display; iff : in Boolean := True) is null;
    64.
    65. private
    66.
    67.    type display is new logging.output with
    68.       record
    69.          column_number : Positive := 1;
    70.       end record;
    71.
    72. end logging.panel;

 137 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/break_in.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- This communicates a break-in to the microcode.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with exceptions;
    18. with HCI;
    19. with KDF9;
    20. with POSIX;
    21. with finalize_ee9;
    22. with settings;
    23. with state_display;
    24.
    25. use  exceptions;
    26. use  HCI;
    27. use  KDF9;
    28. use  settings;
    29. use  state_display;
    30.
    31. package body break_in is
    32.
    33.    requested : Boolean := False
    34.       with Atomic, Volatile;
    35.
    36.    procedure note_user_interrupt is
    37.    begin
    38.       requested := True;
    39.    end note_user_interrupt;
    40.
    41.    function has_been_requested
    42.    return Boolean is
    43.    begin
    44.       return requested;
    45.    end has_been_requested;
    46.
    47.    procedure handler is
    48.    begin
    49.       requested := False;
    50.       interact("Break-in");
    51.       quit_if_requested;
    52.       if the_execution_mode = boot_mode then
    53.          effect_interrupt(caused_by_FLEX, "the operator interrupts");
    54.       else
    55.          show_current_state;
    56.       end if;
    57.       flush;
    58.    exception
    59.       when quit_request =>
    60.          finalize_ee9("Quit requested by the user");
    61.          POSIX.exit_program(0);
    62.    end handler;
    63.
    64. end break_in;

Compiling: ../Source/break_in.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- This conveys a break-in to the microcode.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package break_in is
    18.
    19.    function has_been_requested
    20.    return Boolean
    21.       with Inline;
    22.
    23.    procedure note_user_interrupt;
    24.
    25.    procedure handler;
    26.
    27. end break_in;

 64 lines: No errors


Compiling: /home/parallels/emulation/Source/dumping.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Provide support for diagnostic core-dumping area descriptions.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with formatting;
    18. with state_display;
    19.
    20. use  formatting;
    21. use  state_display;
    22.
    23. package body dumping is
    24.
    25.    type poke_list_entry is
    26.       record
    27.          address  : KDF9.address;
    28.          sub_word : sub_word_flag;
    29.          position : KDF9.address;
    30.          value    : KDF9.word;
    31.       end record;
    32.
    33.    length_of_poke_list : constant := 100;
    34.    poke_list_count     : Natural range 0 .. length_of_poke_list := 0;
    35.    poke_list           : array (Positive range 1 .. length_of_poke_list) of poke_list_entry;
    36.
    37.    use dumping.flag_support;
    38.
    39.    function dumping_flag (c : Character)
    40.    return dumping.flag
    41.    is (dumping.flag(to_upper(c)));
    42.
    43.    type area is
    44.       record
    45.          format_set  : dumping.format_set := no_dumping_flags;
    46.          first, last : KDF9.address;
    47.       end record;
    48.
    49.    no_dumping_area : constant dumping.area := (no_dumping_flags, 0, 0);
    50.
    51.    dumping_areas : array (dumping.area_number) of dumping.area := (others => no_dumping_area);
    52.
    53.    pre_dumping_area_count  : area_count := 0;
    54.    post_dumping_area_count : area_count := 0;
    55.
    56.    function nr_of_pre_dumping_areas
    57.    return dumping.area_count
    58.    is (pre_dumping_area_count);
    59.
    60.    function nr_of_post_dumping_areas
    61.    return dumping.area_count
    62.    is (post_dumping_area_count);
    63.
    64.    procedure request_a_dumping_area (
    65.                                      format_set  : in dumping.format_set;
    66.                                      first, last : in KDF9.address;
    67.                                      was_stored  : out Boolean
    68.                                     ) is
    69.    begin
    70.       was_stored := False;
    71.       if pre_dumping_area_count+post_dumping_area_count = nr_of_dumping_areas then
    72.          return;
    73.       end if;
    74.       for d of dumping_areas loop
    75.          if d = (format_set, first, last) then
    76.             was_stored := True;
    77.             return;
    78.          end if;
    79.       end loop;
    80.       for d of dumping_areas loop
    81.          if d.format_set = no_dumping_flags then
    82.             d := (format_set, first, last);
    83.             was_stored := True;
    84.             if format_set/initial_flag then
    85.                pre_dumping_area_count := pre_dumping_area_count + 1;
    86.             end if;
    87.             if format_set/final_flag then
    88.                post_dumping_area_count := post_dumping_area_count + 1;
    89.             end if;
    90.             return;
    91.          end if;
    92.       end loop;
    93.    end request_a_dumping_area;
    94.
    95.    procedure print_formatted_area (d : in dumping.area) is
    96.       format_set  : constant dumping.format_set := d.format_set;
    97.       first       : constant KDF9.address := d.first;
    98.       last        : constant KDF9.address := d.last;
    99.    begin
   100.       if format_set/tape_code_flag then
   101.          show_core_in_tape_code(first, last);
   102.       end if;
   103.       if format_set/normal_flag then
   104.          show_core_in_case_normal(first, last);
   105.       end if;
   106.       if format_set/shift_flag then
   107.          show_core_in_case_shift(first, last);
   108.       end if;
   109.       if format_set/ card_code_flag then
   110.          show_core_in_card_code(first, last);
   111.       end if;
   112.       if format_set/printer_flag then
   113.          show_core_in_print_code(first, last);
   114.       end if;
   115.       if format_set/ASCII_flag then
   116.          show_core_in_Latin_1(first, last);
   117.       end if;
   118.       if format_set/word_flag then
   119.          show_core_as_word_forms(first, last);
   120.       end if;
   121.       if format_set/Usercode_flag then
   122.          show_core_as_Usercode(
   123.                                (KDF9.code_address(first), 0),
   124.                                (KDF9.code_address(last),  0),
   125.                                 octal_option => not format_set/decimal_flag
   126.                               );
   127.       end if;
   128.       if format_set/orders_flag then
   129.          show_core_as_syllables((KDF9.code_address(first), 0),
   130.                                 (KDF9.code_address(last),  0));
   131.       end if;
   132.    end print_formatted_area;
   133.
   134.    procedure print_dump_areas (flag : in dumping.flag; count : in dumping.area_count) is
   135.       Usercode_wanted : Boolean := False;
   136.    begin
   137.       if count = 0 then
   138.          return;
   139.       end if;
   140.       for d of dumping_areas loop
   141.          Usercode_wanted := Usercode_wanted or d.format_set/Usercode_flag;
   142.       end loop;
   143.       if Usercode_wanted then
   144.          mark_all_code_blocks_and_data_blocks(pre_run => flag = initial_flag);
   145.       end if;
   146.       for d of dumping_areas loop
   147.          if d.format_set/flag then
   148.             print_formatted_area(d);
   149.          end if;
   150.       end loop;
   151.    end print_dump_areas;
   152.
   153.    procedure print_prerun_dump_areas is
   154.    begin
   155.       print_dump_areas(initial_flag, pre_dumping_area_count);
   156.    end print_prerun_dump_areas;
   157.
   158.    procedure print_postrun_dump_areas is
   159.    begin
   160.       print_dump_areas(final_flag, post_dumping_area_count);
   161.    end print_postrun_dump_areas;
   162.
   163.    procedure remove_dump_areas (flag : in dumping.flag; count : in out dumping.area_count) is
   164.    begin
   165.       if count = 0 then
   166.          return;
   167.       end if;
   168.       for d of dumping_areas loop
   169.          if d.format_set/flag then
   170.             d := no_dumping_area;
   171.          end if;
   172.       end loop;
   173.       count := 0;
   174.    end remove_dump_areas;
   175.
   176.    procedure remove_prerun_dump_areas is
   177.    begin
   178.       remove_dump_areas(initial_flag, pre_dumping_area_count);
   179.    end remove_prerun_dump_areas;
   180.
   181.    procedure remove_postrun_dump_areas is
   182.    begin
   183.       remove_dump_areas(final_flag, post_dumping_area_count);
   184.    end remove_postrun_dump_areas;
   185.
   186.    procedure add_to_poke_list (address    : in KDF9.address;
   187.                                sub_word   : in sub_word_flag;
   188.                                position   : in KDF9.address;
   189.                                value      : in KDF9.word;
   190.                                was_stored : out Boolean) is
   191.    begin
   192.       if poke_list_count < length_of_poke_list then
   193.          poke_list_count := poke_list_count + 1;
   194.          poke_list(poke_list_count) := (address, sub_word, position, value);
   195.          was_stored := True;
   196.       else
   197.          was_stored := False;
   198.       end if;
   199.    end add_to_poke_list;
   200.
   201.    procedure poke_all_amendments is
   202.    begin
   203.       for p in 1..poke_list_count loop
   204.          poke(poke_list(p).address, poke_list(p).sub_word, poke_list(p).position, poke_list(p).value);
   205.       end loop;
   206.       poke_list_count := 0;
   207.    end poke_all_amendments;
   208.
   209. end dumping;

Compiling: ../Source/dumping.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Provide support for diagnostic core-dumping area descriptions.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with generic_sets;
    18. with KDF9;
    19.
    20. use  KDF9;
    21.
    22. package dumping is
    23.
    24.    type flag is new Character range '@' .. 'Z';
    25.
    26.    no_flag        : constant dumping.flag := '@';
    27.    ASCII_flag     : constant dumping.flag := 'A';
    28.    card_code_flag : constant dumping.flag := 'C';
    29.    decimal_flag   : constant dumping.flag := 'D';
    30.    single_flag    : constant dumping.flag := 'E';
    31.    final_flag     : constant dumping.flag := 'F';
    32.    half_flag      : constant dumping.flag := 'H';
    33.    initial_flag   : constant dumping.flag := 'I';
    34.    normal_flag    : constant dumping.flag := 'N';
    35.    orders_flag    : constant dumping.flag := 'O';
    36.    printer_flag   : constant dumping.flag := 'L';
    37.    shift_flag     : constant dumping.flag := 'S';
    38.    tape_code_flag : constant dumping.flag := 'T';
    39.    Usercode_flag  : constant dumping.flag := 'U';
    40.    word_flag      : constant dumping.flag := 'W';
    41.
    42.    function dumping_flag (c : Character)
    43.    return dumping.flag;
    44.
    45.    package flag_support is new generic_sets(member => dumping.flag);
    46.
    47.    subtype format_set is flag_support.set;
    48.    use type format_set;
    49.
    50.    is_parameter_flag : constant dumping.format_set
    51.                      := (  decimal_flag
    52.                          | single_flag
    53.                          | half_flag
    54.                          | ASCII_flag
    55.                          | orders_flag
    56.                          | printer_flag
    57.                          | tape_code_flag
    58.                          | Usercode_flag
    59.                          | card_code_flag
    60.                          | normal_flag
    61.                          | shift_flag
    62.                          | word_flag     => True,
    63.                            others        => False
    64.                         );
    65.
    66.
    67.    is_epoch_flag : constant dumping.format_set
    68.                  := (  initial_flag
    69.                      | final_flag => True,
    70.                        others     => False
    71.                     );
    72.
    73.    is_dumping_flag  : constant dumping.format_set
    74.                     := is_parameter_flag or is_epoch_flag;
    75.
    76.    no_dumping_flags : constant dumping.format_set
    77.                     := flag_support.empty_set;
    78.
    79.    nr_of_dumping_areas : constant := 100;
    80.    subtype area_count  is Natural  range 0 .. nr_of_dumping_areas;
    81.    subtype area_number is Positive range 1 .. nr_of_dumping_areas;
    82.
    83.    procedure request_a_dumping_area (
    84.                                      format_set  : in dumping.format_set;
    85.                                      first, last : in KDF9.address;
    86.                                      was_stored  : out Boolean
    87.                                     );
    88.
    89.    procedure print_prerun_dump_areas;
    90.
    91.    procedure remove_prerun_dump_areas;
    92.
    93.    procedure print_postrun_dump_areas;
    94.
    95.    procedure remove_postrun_dump_areas;
    96.
    97.    function nr_of_pre_dumping_areas
    98.    return dumping.area_count;
    99.
   100.    function nr_of_post_dumping_areas
   101.    return dumping.area_count;
   102.
   103.    no_specification : constant String := "";
   104.
   105.    subtype sub_word_flag is Character
   106.       with Static_Predicate =>
   107.          sub_word_flag in 'S' | 's' | 'C' | 'c' | 'L' | 'l' | 'U' | 'u' | 'W' | 'w';
   108.
   109.    -- poke support is in dumping because it is needed at the same time during initialization.
   110.    procedure add_to_poke_list (
   111.                                address    : in KDF9.address;
   112.                                sub_word   : in sub_word_flag;
   113.                                position   : in KDF9.address;
   114.                                value      : in KDF9.word;
   115.                                was_stored : out Boolean
   116.                               );
   117.
   118.    -- poke_all_amendments effects all stored pokes and then clears the poke list for reuse.
   119.    procedure poke_all_amendments;
   120.
   121. end dumping;

 209 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- The machine-state manipulations used by the CPU microcode.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Unchecked_Conversion;
    18. --
    19. with exceptions;
    20. with KDF9.CPU;
    21. with KDF9.decoding;
    22. with KDF9.PHU_store;
    23. with KDF9.store;
    24. with settings;
    25. with tracing;
    26.
    27. use  exceptions;
    28. use  KDF9.CPU;
    29. use  KDF9.decoding;
    30. use  KDF9.PHU_store;
    31. use  KDF9.store;
    32. use  settings;
    33. use  tracing;
    34.
    35. package body KDF9 is
    36.
    37.    C_part_scale : constant := 2**32;
    38.    I_part_scale : constant := 2**16;
    39.
    40.    function as_Q (the_word : KDF9.word)
    41.    return KDF9.Q_register
    42.    is (
    43.        (C => KDF9.Q_part(KDF9.word'(the_word / C_part_scale)),
    44.         I => KDF9.Q_part(KDF9.word'(the_word / I_part_scale) and Q_part_mask),
    45.         M => KDF9.Q_part(the_word and Q_part_mask)
    46.        )
    47.       );
    48.
    49.    function as_word (the_Q : KDF9.Q_register)
    50.    return KDF9.word
    51.    is (KDF9.word(the_Q.C)*C_part_scale + KDF9.word(the_Q.I)*I_part_scale + KDF9.word(the_Q.M));
    52.
    53.    function sign_extended (Q : KDF9.Q_part)
    54.    return KDF9.word
    55.    is (unsign(CPU.signed(resign(Q))));
    56.
    57.    function as_word (the_link : KDF9.SJNS_link)
    58.    return KDF9.word is
    59.       function link_Q_part is new Ada.Unchecked_Conversion(KDF9.SJNS_link, KDF9.Q_part);
    60.    begin
    61.       return KDF9.word(link_Q_part(the_link));
    62.    end as_word;
    63.
    64.    function as_link (the_word : KDF9.word)
    65.    return KDF9.SJNS_link is
    66.       function Q_part_link is new Ada.Unchecked_Conversion(KDF9.Q_part, KDF9.SJNS_link);
    67.    begin
    68.       return Q_part_link(KDF9.Q_part(the_word and Q_part_mask));
    69.    end as_link;
    70.
    71.    procedure ensure_that_the_SJNS_is_not_empty is
    72.    begin
    73.       if the_SJNS_depth > 0             or else
    74.             the_CPU_state = Director_state then
    75.          return;
    76.       end if;
    77.       effect_interrupt(caused_by_NOUV, "empty SJNS");
    78.    end ensure_that_the_SJNS_is_not_empty;
    79.
    80.    procedure ensure_that_the_SJNS_is_not_full is
    81.    begin
    82.       if the_SJNS_depth < 16             or else
    83.             the_CPU_state = Director_state  then
    84.          return;
    85.       end if;
    86.       effect_interrupt(caused_by_NOUV, "full SJNS");
    87.    end ensure_that_the_SJNS_is_not_full;
    88.
    89.    procedure push (the_link : in KDF9.syllable_address) is
    90.    begin
    91.       the_SJNS(the_SJNS_depth) := KDF9.SJNS_link(the_link);
    92.       the_SJNS_depth := the_SJNS_depth + 1;
    93.    end push;
    94.
    95.    function pop
    96.    return KDF9.syllable_address is
    97.    begin
    98.       the_SJNS_depth := the_SJNS_depth - 1;
    99.       return KDF9.syllable_address(the_SJNS(the_SJNS_depth));
   100.    end pop;
   101.
   102.    function SJNS_top
   103.    return KDF9.SJNS_link
   104.    is (the_SJNS(the_SJNS_depth-1));
   105.
   106.    function operand_words_needed (need : KDF9.NEST_depth)
   107.    return String
   108.    is ("NEST lacks" & need'Image & " operand" & (if need > 1 then "s" else ""));
   109.
   110.    procedure ensure_that_the_NEST_holds (at_least : in KDF9.NEST_depth) is
   111.    begin
   112.       if the_NEST_depth >= at_least          or else
   113.             the_CPU_state = Director_state      then
   114.          return;
   115.       end if;
   116.       effect_interrupt(caused_by_NOUV, operand_words_needed(need => at_least-the_NEST_depth));
   117.    end ensure_that_the_NEST_holds;
   118.
   119.    procedure ensure_that_the_NEST_holds_an_operand is
   120.    begin
   121.       ensure_that_the_NEST_holds (at_least => 1);
   122.    end ensure_that_the_NEST_holds_an_operand;
   123.
   124.    procedure ensure_that_the_NEST_holds_2_operands is
   125.    begin
   126.       ensure_that_the_NEST_holds (at_least => 2);
   127.    end ensure_that_the_NEST_holds_2_operands;
   128.
   129.    function result_space_needed (need : KDF9.NEST_depth)
   130.    return String
   131.       with Inline => False;
   132.
   133.    function result_space_needed (need : KDF9.NEST_depth)
   134.    return String
   135.    is (if need = 1 then "full NEST" else "NEST too full for" & need'Image & " operands");
   136.
   137.    procedure ensure_that_the_NEST_has_room_for (at_least : in KDF9.NEST_depth) is
   138.    begin
   139.       if the_NEST_depth <= 16-at_least     or else
   140.             the_CPU_state = Director_state    then
   141.          return;
   142.       end if;
   143.       effect_interrupt(caused_by_NOUV, result_space_needed(need => at_least - (16-the_NEST_depth)));
   144.    end ensure_that_the_NEST_has_room_for;
   145.
   146.    procedure ensure_that_the_NEST_has_room_for_a_result is
   147.    begin
   148.       ensure_that_the_NEST_has_room_for (at_least => 1);
   149.    end ensure_that_the_NEST_has_room_for_a_result;
   150.
   151.    procedure ensure_that_the_NEST_has_room_for_2_results is
   152.    begin
   153.       ensure_that_the_NEST_has_room_for (at_least => 2);
   154.    end ensure_that_the_NEST_has_room_for_2_results;
   155.
   156.    procedure push (the_word : in KDF9.word) is
   157.    begin
   158.       the_NEST(the_NEST_depth) := the_word;
   159.       the_NEST_depth := the_NEST_depth + 1;
   160.    end push;
   161.
   162.    function pop
   163.    return KDF9.word is
   164.    begin
   165.       return result : constant KDF9.word := the_NEST(the_NEST_depth - 1) do
   166.          the_NEST(the_NEST_depth - 1) := 0;
   167.          the_NEST_depth := the_NEST_depth - 1;
   168.       end return;
   169.    end pop;
   170.
   171.    procedure pop is
   172.    begin
   173.       the_NEST(the_NEST_depth - 1) := 0;
   174.       the_NEST_depth := the_NEST_depth - 1;
   175.    end pop;
   176.
   177.    function read_top
   178.    return KDF9.word
   179.    is (the_NEST(the_NEST_depth-1));
   180.
   181.    procedure write_top (the_word : in KDF9.word) is
   182.    begin
   183.       the_NEST(the_NEST_depth-1) := the_word;
   184.    end write_top;
   185.
   186.    procedure push (the_pair : in KDF9.pair) is
   187.    begin
   188.       the_NEST(the_NEST_depth+0) := the_pair.lsw;
   189.       the_NEST(the_NEST_depth+1) := the_pair.msw;
   190.       the_NEST_depth := the_NEST_depth + 2;
   191.    end push;
   192.
   193.    function pop
   194.    return KDF9.pair is
   195.    begin
   196.       return result : constant KDF9.pair := (msw => the_NEST(the_NEST_depth-1),
   197.                                              lsw => the_NEST(the_NEST_depth-2)) do
   198.          the_NEST(the_NEST_depth-1) := 0;
   199.          the_NEST(the_NEST_depth-2) := 0;
   200.          the_NEST_depth := the_NEST_depth - 2;
   201.       end return;
   202.    end pop;
   203.
   204.    procedure pop_pair is
   205.    begin
   206.       the_NEST(the_NEST_depth-1) := 0;
   207.       the_NEST(the_NEST_depth-2) := 0;
   208.       the_NEST_depth := the_NEST_depth - 2;
   209.    end pop_pair;
   210.
   211.    function read_top
   212.    return KDF9.pair
   213.    is ((msw => the_NEST(the_NEST_depth-1), lsw => the_NEST(the_NEST_depth-2)));
   214.
   215.    procedure write_top (the_pair : in KDF9.pair) is
   216.    begin
   217.       the_NEST(the_NEST_depth-1) := the_pair.msw;
   218.       the_NEST(the_NEST_depth-2) := the_pair.lsw;
   219.    end write_top;
   220.
   221.
   222. --
   223.    -- Support for Director-only operations.
   224. --
   225.
   226.    -- Set BA (bits D38:47), CPL (D34:35) and NOL (D24:33).
   227.
   228.    procedure set_K1_register (setting : in KDF9.word) is
   229.    begin
   230.       BA  := KDF9.address(setting mod 2**10) * 2**5;
   231.       CPL := KDF9.priority((setting / 2**12) and 2#11#);
   232.       NOL := KDF9.address((setting / 2**14) mod 2**10) * 2**5 + 31;
   233.    end set_K1_register;
   234.
   235.    -- Set CPDAR (bits D32:47).
   236.
   237.    procedure set_K2_register (setting : in KDF9.word) is
   238.       CPDAR_Q : KDF9.Q_part := as_Q(setting).M;
   239.    begin
   240.       for i in KDF9.buffer_number loop
   241.          the_CPDAR(i) := (CPDAR_Q mod 2) = 1;
   242.          CPDAR_Q := CPDAR_Q / 2;
   243.       end loop;
   244.    end set_K2_register;
   245.
   246.    -- Set context (bits D0:1), NEST_depth (D2:6) and SJNS_depth (D7:11).
   247.
   248.    procedure set_K3_register (setting : in KDF9.word) is
   249.    begin
   250.       -- Save the current register values in the register bank.
   251.       register_bank(the_context).NEST := the_NEST;
   252.       register_bank(the_context).SJNS := the_SJNS;
   253.       register_bank(the_context).Q_store := the_Q_store;
   254.       -- Set the new context.
   255.       the_context := KDF9.context(KDF9.word'(setting / 2**46));
   256.       the_NEST_depth := KDF9.NEST_depth(setting / 2**41 mod 2**5);
   257.       the_SJNS_depth := KDF9.SJNS_depth(setting / 2**36 mod 2**5);
   258.       -- Restore the register values for the new context.
   259.       the_NEST := register_bank(the_context).NEST;
   260.       the_SJNS := register_bank(the_context).SJNS;
   261.       the_Q_store := register_bank(the_context).Q_store;
   262.    end set_K3_register;
   263.
   264.    a_microsecond : constant := 1.0 / 2.0**20;
   265.
   266.    type seconds is delta a_microsecond range 0.0 .. 1000.0*365.2425*24.0*3600.0;  -- 1000 years!
   267.
   268.    procedure update_the_elapsed_time;
   269.
   270.    -- Let the real elapsed time catch up with the_real_time virtual seconds.
   271.
   272.    procedure delay_until (the_real_time : in KDF9.us) is
   273.       a_jiffy : constant seconds := seconds(2**10) * a_microsecond;  -- ca. TR character-read time of 1ms
   274.       the_lag : seconds;
   275.    begin
   276.        if the_real_time < the_last_delay_time then
   277.           the_last_delay_time := the_real_time;
   278.        end if;
   279.       the_lag := seconds(the_real_time - the_last_delay_time) * a_microsecond;
   280.       if the_lag >= a_jiffy then  -- More than a a_jiffy of virtual elapsed time has passed.
   281.          delay Duration(the_lag);
   282.          the_last_delay_time := the_real_time;
   283.       end if;
   284.      -- the_elapsed_time := the_real_time;
   285.       update_the_elapsed_time;
   286.    end delay_until;
   287.
   288.    procedure delay_by (the_delay_time : in KDF9.us) is
   289.    begin
   290.       if authentic_timing_is_enabled then
   291.          delay_until(the_clock_time + the_delay_time);
   292.       end if;
   293.    end delay_by;
   294.
   295.    -- Advance to the larger of the_CPU_time, the_elapsed_time, and the_last_delay_time.
   296.    -- Cap the increase to prevent a spurious double-clock (RESET) interrupt in Director.
   297.
   298.    procedure update_the_elapsed_time is
   299.       max_elapsed_time : constant KDF9.us := the_last_K4_time + 2**20 - 1;
   300.    begin
   301.       the_elapsed_time := KDF9.us'Max(the_elapsed_time, the_last_delay_time);
   302.       the_elapsed_time := KDF9.us'Max(the_elapsed_time, the_CPU_time);
   303.       if the_execution_mode = boot_mode and the_CPU_state = Director_state then
   304.          the_elapsed_time := KDF9.us'Min(the_elapsed_time, max_elapsed_time);
   305.       end if;
   306.    end update_the_elapsed_time;
   307.
   308.    -- The virtual elapsed time.
   309.
   310.    function the_clock_time
   311.    return KDF9.us is
   312.    begin
   313.       update_the_elapsed_time;
   314.       return the_elapsed_time;
   315.    end the_clock_time;
   316.
   317.    procedure advance_the_clock (past : in KDF9.us) is
   318.    begin
   319.       the_elapsed_time := KDF9.us'Max(the_elapsed_time, past);
   320.       update_the_elapsed_time;
   321.       if authentic_timing_is_enabled then
   322.          delay_until(the_elapsed_time);
   323.       end if;
   324.    end advance_the_clock;
   325.
   326.    procedure synchronize_the_real_and_virtual_times is
   327.    begin
   328.       if authentic_timing_is_enabled then
   329.          update_the_elapsed_time;
   330.          delay_until(the_elapsed_time);
   331.       end if;
   332.    end synchronize_the_real_and_virtual_times;
   333.
   334.    -- Get clock (bits D0:15) and RFIR (D16:31).
   335.
   336.    function get_K4_operand
   337.    return KDF9.word is
   338.
   339.       function RFIR_in_a_word
   340.       return KDF9.word is
   341.          result : KDF9.word := 0;
   342.       begin
   343.          for r of the_RFIR loop
   344.             result := result*2;
   345.             if r then
   346.                result := result or 1;
   347.             end if;
   348.          end loop;
   349.          return result;
   350.       end RFIR_in_a_word;
   351.
   352.       -- The KDF9's interval timing clock ticks once per 32 µs;
   353.       --    the emulator virtual time has a resolution of 1 µs.
   354.
   355.       time_now : constant KDF9.us := the_clock_time;
   356.       interval : constant KDF9.us := (time_now - the_last_K4_time);
   357.
   358.    begin
   359.       the_last_K4_time := time_now;
   360.       if interval / 32 >= 2**16 then
   361.          effect_interrupt(caused_by_RESET, "double clock");
   362.          the_RFIR(caused_by_RESET ) := True;
   363.       elsif interval / 32 >= 2**15 then
   364.          effect_interrupt(caused_by_CLOCK, "time since a K4" & interval'Image & "us");
   365.          the_RFIR(caused_by_CLOCK ) := True;  --?? why is this needed?
   366.       end if;
   367.       return (KDF9.word(interval / 32) * 2**32) or (RFIR_in_a_word * 2**16);
   368.    end get_K4_operand;
   369.
   370.    -- Get PHUi (bits D6i:6i+5, i = 0 .. 3).
   371.
   372.    function get_K5_operand
   373.    return KDF9.word
   374.    is (K5_operand);
   375.
   376.    -- Get context (bits D0:1), NEST_depth (D2:6) and SJNS_depth (D7:11).
   377.
   378.    function get_K7_operand
   379.    return KDF9.word
   380.    is (
   381.        (KDF9.word(the_context)    * 2**46) or
   382.        (KDF9.word(the_NEST_depth) * 2**41) or
   383.        (KDF9.word(the_SJNS_depth) * 2**36)
   384.       );
   385.
   386.    procedure reset_V_and_T is
   387.    begin
   388.       the_V_bit_is_set := False;
   389.       the_T_bit_is_set := False;
   390.    end reset_V_and_T;
   391.
   392.    procedure reset_the_internal_registers (the_new_state : in CPU_state) is
   393.    begin
   394.       -- Set the state of a newly bootstrapped CPU.
   395.       reset_V_and_T;
   396.       CIA := (0, 0);
   397.       CPL := 0;
   398.       BA  := 0;
   399.       NOL := max_address;
   400.       the_RFIR := (others => False);
   401.       ICR := 0;
   402.       the_CPU_time := 0;
   403.       the_elapsed_time := 0;
   404.       the_last_delay_time := 0;
   405.       the_last_K4_time := 0;
   406.       the_CPU_state := the_new_state;
   407.       the_CPDAR := (0 => True, others => False);  -- FW0 is always allocated.
   408.    end reset_the_internal_registers;
   409.
   410.    empty_NEST : constant NEST := (others => 0);
   411.    empty_SJNS : constant SJNS := (others => (0, 0));
   412.    empty_Q_s  : constant Q_store := (others => (0, 0, 0));
   413.
   414.    procedure reset_the_CPU_state (initial_entry : KDF9.syllable_address) is
   415.    begin
   416.       the_context := 0;
   417.       for bank of register_bank loop
   418.          bank := (NEST => empty_NEST, SJNS => empty_SJNS, Q_store => empty_Q_s);
   419.       end loop;
   420.       the_NEST_depth := 0;
   421.       the_NEST       := empty_NEST;
   422.       the_SJNS_depth := 0;
   423.       the_SJNS       := empty_SJNS;
   424.       the_Q_store    := empty_Q_s;
   425.       if the_execution_mode = program_mode then
   426.          reset_the_internal_registers(program_state);
   427.       else
   428.          reset_the_internal_registers(Director_state);
   429.       end if;
   430.       -- Setting NIA must follow program loading, as it fetches E0 into the IWBs.
   431.       set_NIA_to(initial_entry);
   432.    end reset_the_CPU_state;
   433.
   434.    procedure reset_the_program_state is
   435.    begin
   436.       the_NEST_depth := 0;
   437.       the_NEST       := empty_NEST;
   438.       the_SJNS_depth := 0;
   439.       the_SJNS       := empty_SJNS;
   440.       reset_V_and_T;
   441.       the_CPDAR := (0 => True, others => False);  -- FW0 is always allocated.
   442.       -- Setting NIA must follow program loading, as it fetches E0 into the IWBs.
   443.       set_NIA_to((0, 0));
   444.    end reset_the_program_state;
   445.
   446.    procedure effect_interrupt (caused_by_this : in KDF9.interrupt_number; message : in String) is
   447.       return_address : KDF9.syllable_address;
   448.    begin
   449.       take_note_of_interrupt(caused_by_this, message);
   450.       the_RFIR(caused_by_this) := True;
   451.       case the_execution_mode is
   452.          when boot_mode =>
   453.             -- Interrupts are either actioned or deferred to Director.
   454.             if the_CPU_state = program_state or else caused_by_this = caused_by_RESET  then
   455.                -- Action an actual interrupt into Director.
   456.                if caused_by_this in caused_by_LOV  | caused_by_OUT then
   457.                   return_address := CIA;  -- Restart the interrupted instruction.
   458.                else
   459.                   return_address := NIA;  -- Proceed after the interrupted instruction.
   460.                end if;
   461.                if the_SJNS_depth < 16 then
   462.                   push(return_address);                  -- The program link fits into the SJNS.
   463.                else
   464.                   JB := KDF9.SJNS_link(return_address);  -- The program link overwrites JB.
   465.                end if;
   466.                BA := 0;
   467.                fetching_normally := True;
   468.                set_NIA_to((0, 0));
   469.                the_CPU_state := Director_state;
   470.                raise abandon_this_order;
   471.             else
   472.                -- Defer: Director will eventually find any request left in the_RFIR.
   473.                -- NOUV is completely suppressed in Director state.
   474.                the_RFIR(caused_by_NOUV) := False;
   475.             end if;
   476.
   477.          when privileged_mode =>
   478.             -- Interrupts other than LOV and RESET are ignored.
   479.             -- There is no need to accurately emulate the address placed by the hardware in JB.
   480.             case caused_by_this is
   481.                when caused_by_LOV  =>
   482.                   raise LOV_exception with message;
   483.                when caused_by_RESET  =>
   484.                   raise RESET_exception with message;
   485.                when others =>
   486.                   null;
   487.             end case;
   488.
   489.          when program_mode =>
   490.             -- Interrupts other than LOV are treated as failures.
   491.             -- There is no need to accurately emulate the address placed by the hardware in JB.
   492.             case caused_by_this is
   493.                when caused_by_PR =>
   494.                   raise PR_exception with message;
   495.                when caused_by_FLEX =>
   496.                   raise FLEX_exception with message;
   497.                when caused_by_LIV =>
   498.                   raise LIV_exception with message;
   499.                when caused_by_NOUV =>
   500.                   raise NOUV_exception with message;
   501.                when caused_by_EDT =>
   502.                   raise EDT_exception with message;
   503.                when caused_by_OUT =>
   504.                   raise OUT_exception with message;
   505.                when caused_by_LOV  =>
   506.                   raise LOV_exception with message;
   507.                when caused_by_RESET  =>
   508.                   raise RESET_exception with message;
   509.                when EXITD_flag =>
   510.                   raise emulation_failure with "invalid EXITD RFI in effect_interrupt";
   511.                when caused_by_CLOCK =>
   512.                   raise emulation_failure with "invalid CLOCK RFI in effect_interrupt";
   513.             end case;
   514.       end case;
   515.    end effect_interrupt;
   516.
   517.    procedure effect_clock_interrupt (interval : in KDF9.us)
   518.       with Inline => False;
   519.
   520.    procedure effect_clock_interrupt (interval : in KDF9.us) is
   521.    begin
   522.       effect_interrupt(caused_by_CLOCK, interval'Image & " KDF9 us");
   523.    end effect_clock_interrupt;
   524.
   525.    procedure check_for_a_clock_interrupt is
   526.       interval : KDF9.us;
   527.    begin
   528.       -- Clock ticks are ignored in program_mode and privileged_mode.
   529.       -- In boot_mode:
   530.       --    they are actioned in program_state;
   531.       --    they are deferred in Director_state: Director will eventually find the time for itself.
   532.       if the_execution_mode = boot_mode and then
   533.             the_CPU_state = program_state   then
   534.          interval := (the_clock_time - the_last_K4_time);
   535.          if interval >= 2**20 then
   536.             effect_clock_interrupt(interval);
   537.          end if;
   538.       end if;
   539.    end check_for_a_clock_interrupt;
   540.
   541.    procedure fail_in_problem_program_state is
   542.    begin
   543.       case the_execution_mode is
   544.          when program_mode =>
   545.             -- The unprivileged program has attempted a privileged operation.
   546.             raise LIV_exception with "%Director-only instruction";
   547.          when privileged_mode =>
   548.             -- The privileged program is allowed to use privileged instructions.
   549.             return;
   550.          when boot_mode =>
   551.             if the_CPU_state = program_state then
   552.                -- Punt the error to Director.
   553.                effect_interrupt(caused_by_LIV, "Director-only instruction");
   554.             else
   555.                -- All privileged operations are permitted to Director.
   556.                return;
   557.             end if;
   558.       end case;
   559.    end fail_in_problem_program_state;
   560.
   561.    procedure LOV_if_user_mode (cause : in String) is
   562.    begin
   563.       -- LOV was TOTALLY suppressed in Director state.
   564.       if the_CPU_state /= Director_state then
   565.          set_NIA_to(CIA);
   566.          effect_interrupt(caused_by_LOV, cause);
   567.       end if;
   568.    end LOV_if_user_mode;
   569.
   570.    -- The %  prepended to the_message aids parsing of exception error messages in failure shutdown.
   571.
   572.    procedure trap_illegal_instruction (the_message : in String := "invalid opcode") is
   573.    begin
   574.       -- The program has failed in a manner that could cause a LIV interrupt.
   575.       case the_execution_mode is
   576.          when program_mode
   577.             | privileged_mode =>
   578.             raise LIV_exception with "%" & the_message;
   579.          when boot_mode =>
   580.             if the_CPU_state = program_state then
   581.                -- Punt the problem to Director.
   582.                effect_interrupt(caused_by_LIV, the_message);
   583.             else
   584.                -- The Director itself has gone seriously wrong.
   585.                -- LIV is impossible in Director, so ee9 takes responsibility for stopping the run
   586.                --    to avert consequential emulation failure.
   587.                raise Director_failure with "%" & the_message;
   588.             end if;
   589.       end case;
   590.    end trap_illegal_instruction;
   591.
   592.    procedure trap_operator_error (the_message : in String) is
   593.    begin
   594.       -- The program has failed for a reason, such as a misconfigured environment,
   595.       --    that is beyond its control and prevents further execution.
   596.       raise operator_error with "%" & the_message;
   597.    end trap_operator_error;
   598.
   599.    procedure trap_unimplemented_feature (the_message : in String) is
   600.    begin
   601.       -- The program has attempted to use something that ee9 does not (yet) support.
   602.       raise not_yet_implemented with "%" & the_message;
   603.    end trap_unimplemented_feature;
   604.
   605.    procedure trap_failing_OUT (OUT_number : in KDF9.word; the_message : in String) is
   606.       OUT_name : constant String := OUT_number'Image;
   607.    begin
   608.       -- The program has issued an invalid OUT.
   609.       raise OUT_error with "%" & OUT_name(2..OUT_name'Last) & ": " & the_message;
   610.    end trap_failing_OUT;
   611.
   612.    procedure trap_invalid_paper_tape (the_message : in String) is
   613.    begin
   614.       -- The paper tape file given to load or boot has defects.
   615.       raise invalid_paper_tape_file with "%" & the_message;
   616.    end trap_invalid_paper_tape;
   617.
   618.    procedure return_from_Director_to (new_IAR : in KDF9.syllable_address) is
   619.    begin
   620.       the_CPU_state := program_state;
   621.       set_NIA_to(new_IAR);
   622.    end return_from_Director_to;
   623.
   624.    procedure increment_by_1 (the_link : in out KDF9.syllable_address) is
   625.    begin
   626.       if the_link.syllable_index < 5 then
   627.          the_link.syllable_index := the_link.syllable_index + 1;
   628.       else
   629.          the_link.syllable_index := 0;
   630.          the_link.code_address     := the_link.code_address + 1;
   631.       end if;
   632.    end increment_by_1;
   633.
   634.    procedure increment_by_2 (the_link : in out KDF9.syllable_address) is
   635.    begin
   636.       if the_link.syllable_index < 4 then
   637.          the_link.syllable_index := the_link.syllable_index + 2;
   638.       else
   639.          the_link.syllable_index := the_link.syllable_index - 4;
   640.          the_link.code_address     := the_link.code_address + 1;
   641.       end if;
   642.    end increment_by_2;
   643.
   644.    procedure increment_by_3 (the_link : in out KDF9.syllable_address) is
   645.    begin
   646.       if the_link.syllable_index < 3 then
   647.          the_link.syllable_index := the_link.syllable_index + 3;
   648.       else
   649.          the_link.syllable_index := the_link.syllable_index - 3;
   650.          the_link.code_address     := the_link.code_address + 1;
   651.       end if;
   652.    end increment_by_3;
   653.
   654.    -- the_syllable_cache holds two instruction words, pre-split into syllables.
   655.    -- They would have been held in IWB0 and IWB1 by Main Control in the KDF9.
   656.
   657.    subtype syllable_cache_range is Natural range 0 .. 11;
   658.
   659.    the_syllable_cache  : array (syllable_cache_range) of KDF9.syllable;
   660.    the_cache_index     : syllable_cache_range   := 0;
   661.    the_cached_location : KDF9.code_address := 0;
   662.
   663.    function NIA
   664.    return KDF9.syllable_address
   665.    is (
   666.        if the_cache_index > 5 then
   667.           (the_cached_location, KDF9.syllable_index(the_cache_index-6))
   668.        else
   669.           (the_cached_location-1, KDF9.syllable_index(the_cache_index))
   670.       );
   671.
   672.    function NIA_word_number
   673.    return KDF9.code_address
   674.    is (the_cached_location - (if the_cache_index > 5 then 0 else 1));
   675.
   676.    procedure trap_an_invalid_order_address (new_NIA : in KDF9.syllable_address)
   677.       with Inline => False;
   678.
   679.    procedure trap_an_invalid_order_address (new_NIA : in KDF9.syllable_address) is
   680.    begin
   681.       if new_NIA.syllable_index = 6 then
   682.          effect_interrupt(caused_by_RESET, "syllable number = 6");
   683.       elsif new_NIA.syllable_index = 7 then
   684.          effect_interrupt(caused_by_RESET, "syllable number = 7");
   685.       else
   686.          effect_interrupt(caused_by_LIV, "jump to 8191");  -- See EE Report K/GD y 82.
   687.       end if;
   688.    end trap_an_invalid_order_address;
   689.
   690.    procedure set_NIA_to (new_NIA : in KDF9.syllable_address) is
   691.       mask        : constant := 8#377#;
   692.       shift       : constant := 8#400#;
   693.       IWB0, IWB1  : KDF9.word;
   694.    begin
   695.       if new_NIA.code_address = 8191 or else
   696.             new_NIA.syllable_index > 5       then
   697.          trap_an_invalid_order_address(new_NIA);
   698.       end if;
   699.
   700.       IWB0 := fetch_word(KDF9.address(new_NIA.code_address) + 0);
   701.       IWB1 := fetch_word(KDF9.address(new_NIA.code_address) + 1);
   702.
   703.       the_cache_index := syllable_cache_range(new_NIA.syllable_index);
   704.       the_cached_location := new_NIA.code_address + 1;
   705.
   706.       the_syllable_cache(5+0) := KDF9.syllable(IWB0 and mask);
   707.       IWB0 := IWB0 / shift;
   708.       the_syllable_cache(4+0) := KDF9.syllable(IWB0 and mask);
   709.       IWB0 := IWB0 / shift;
   710.       the_syllable_cache(3+0) := KDF9.syllable(IWB0 and mask);
   711.       IWB0 := IWB0 / shift;
   712.       the_syllable_cache(2+0) := KDF9.syllable(IWB0 and mask);
   713.       IWB0 := IWB0 / shift;
   714.       the_syllable_cache(1+0) := KDF9.syllable(IWB0 and mask);
   715.       IWB0 := IWB0 / shift;
   716.       the_syllable_cache(0+0) := KDF9.syllable(IWB0);
   717.
   718.       the_syllable_cache(5+6) := KDF9.syllable(IWB1 and mask);
   719.       IWB1 := IWB1 / shift;
   720.       the_syllable_cache(4+6) := KDF9.syllable(IWB1 and mask);
   721.       IWB1 := IWB1 / shift;
   722.       the_syllable_cache(3+6) := KDF9.syllable(IWB1 and mask);
   723.       IWB1 := IWB1 / shift;
   724.       the_syllable_cache(2+6) := KDF9.syllable(IWB1 and mask);
   725.       IWB1 := IWB1 / shift;
   726.       the_syllable_cache(1+6) := KDF9.syllable(IWB1 and mask);
   727.       IWB1 := IWB1 / shift;
   728.       the_syllable_cache(0+6) := KDF9.syllable(IWB1);
   729.    end set_NIA_to;
   730.
   731.    procedure set_NIA_to_the_INS_target_address is
   732.    begin
   733.       set_NIA_to(INS.target);
   734.    end set_NIA_to_the_INS_target_address;
   735.
   736.    procedure set_IWB0_and_IWB1_for_a_JCqNZS_loop is
   737.    begin
   738.       set_NIA_to((code_address => CIA.code_address-1, syllable_index => 0));
   739.       fetching_normally := False;
   740.    end set_IWB0_and_IWB1_for_a_JCqNZS_loop;
   741.
   742.    procedure go_back_to_the_start_of_IWB0 is
   743.    begin
   744.       the_cache_index := 0;
   745.    end go_back_to_the_start_of_IWB0;
   746.
   747.    procedure continue_after_JCqNZS is
   748.    begin
   749.       if CIA.syllable_index = 4 and the_cached_location = CIA.code_address then
   750.          set_NIA_to((code_address => CIA.code_address+1, syllable_index => 0));
   751.       end if;
   752.       fetching_normally := True;
   753.    end continue_after_JCqNZS;
   754.
   755.    function next_order_syllable
   756.    return KDF9.syllable
   757.       with Inline;
   758.
   759.    -- The amount by which the_CPU_time is increased, for a refill of both Instruction Word Buffers.
   760.
   761.    the_IWB01_reload_time : constant KDF9.us := 7;  -- microseconds
   762.
   763.    function next_order_syllable
   764.    return KDF9.syllable is
   765.       the_next_syllable : KDF9.syllable;
   766.    begin
   767.       the_next_syllable := the_syllable_cache(the_cache_index);
   768.       if the_cache_index < 11 then
   769.          the_cache_index := the_cache_index + 1;
   770.       elsif fetching_normally then
   771.          set_NIA_to((code_address => CIA.code_address+1, syllable_index => 0));
   772.          -- Part-overlapped order-word fetch: can happen only once per instruction,
   773.          --    and only before the instruction is executed, so no need to ADD to the_CPU_delta.
   774.          if (CIA.code_address and 15) < 10 then
   775.             -- The fudge factor applied here gives the Whetstone Benchmark its historical run time.
   776.             the_CPU_delta := the_IWB01_reload_time + 1;
   777.          else
   778.             the_CPU_delta := the_IWB01_reload_time;
   779.          end if;
   780.       else
   781.          go_back_to_the_start_of_IWB0;
   782.       end if;
   783.       return the_next_syllable;
   784.    end next_order_syllable;
   785.
   786.    procedure decode_syllable_0 (decoded : in out KDF9.decoded_order)
   787.       with Inline;
   788.
   789.    procedure decode_syllable_1 (decoded : in out KDF9.decoded_order)
   790.       with Inline;
   791.
   792.    procedure decode_a_jump_order (decoded : in out KDF9.decoded_order)
   793.       with Inline;
   794.
   795.    procedure decode_a_store_access_order (decoded : in out KDF9.decoded_order)
   796.       with Inline;
   797.
   798.    procedure decode_a_set_literal_order (decoded : in out KDF9.decoded_order)
   799.       with Inline;
   800.
   801.    procedure decode_syllable_0 (decoded : in out KDF9.decoded_order) is
   802.    begin
   803.       decoded.compressed_opcode := decoded.order.syllable_0 and 8#77#;
   804.       decoded.kind := KDF9.INS_kind(decoded.order.syllable_0 / 2**6);
   805.    end decode_syllable_0;
   806.
   807.    procedure process_syllable_0_of_INS is
   808.    begin
   809.       if the_cache_index > 5 then
   810.          CIA.code_address := the_cached_location;
   811.          CIA.syllable_index   := KDF9.syllable_index(the_cache_index-6);
   812.       else
   813.          CIA.code_address := the_cached_location - 1;
   814.          CIA.syllable_index   := KDF9.syllable_index(the_cache_index);
   815.       end if;
   816.       INS.order.syllable_0 := next_order_syllable;
   817.       INS.compressed_opcode := INS.order.syllable_0 and 8#77#;
   818.       INS.kind := KDF9.INS_kind(INS.order.syllable_0 / 2**6);
   819.    end process_syllable_0_of_INS;
   820.
   821.    procedure decode_syllable_1 (decoded : in out KDF9.decoded_order) is
   822.    begin
   823.       decoded.Qq := KDF9.Q_number(decoded.order.syllable_1 / 2**4);
   824.       decoded.Qk := KDF9.Q_number(decoded.order.syllable_1 and 8#17#);
   825.    end decode_syllable_1;
   826.
   827.    procedure process_syllable_1_of_INS is
   828.    begin
   829.       INS.order.syllable_1 := next_order_syllable;
   830.       INS.Qq := KDF9.Q_number(INS.order.syllable_1 / 2**4);
   831.       INS.Qk := KDF9.Q_number(INS.order.syllable_1 and 8#17#);
   832.    end process_syllable_1_of_INS;
   833.
   834.    syllable_nr_mask : constant := 2#111#;
   835.    D4_mask          : constant := 2#1000#;
   836.    D2_mask          : constant := 2#00_100_000#;
   837.    D0_thru_3_mask   : constant := 2#11_110_000#;
   838.
   839.    procedure decode_a_jump_order (decoded : in out KDF9.decoded_order) is
   840.    begin
   841.       decoded.target.syllable_index
   842.          := KDF9.syllable_index(decoded.order.syllable_0 and syllable_nr_mask);
   843.       decoded.target.code_address
   844.          := KDF9.code_address(decoded.order.syllable_2)
   845.           + KDF9.code_address(decoded.Qk) * 2**8
   846.           + KDF9.code_address(decoded.order.syllable_0 and D4_mask) * 2**9;
   847.       if (decoded.compressed_opcode and D2_mask) /= 0 then -- not JrCq ...
   848.          decoded.compressed_opcode := decoded.compressed_opcode and D0_thru_3_mask;
   849.       else
   850.          decoded.compressed_opcode := (decoded.compressed_opcode and D0_thru_3_mask) or KDF9.syllable(decoded.Qq);
   851.       end if;
   852.       if decoded.compressed_opcode = EXIT_n then
   853.          -- The syllable part of EXIT is actually a halfword offset,
   854.          --    so convert it to an actual syllable number.
   855.          if decoded.target.syllable_index = 2 then
   856.             decoded.target.syllable_index := 0;
   857.          else
   858.             decoded.target.syllable_index := 3;
   859.          end if;
   860.       end if;
   861.    end decode_a_jump_order;
   862.
   863.    procedure process_syllables_1_and_2_of_a_jump_order is
   864.    begin
   865.       process_syllable_1_of_INS;
   866.       INS.order.syllable_2 := next_order_syllable;
   867.       decode_a_jump_order(INS);
   868.    end process_syllables_1_and_2_of_a_jump_order;
   869.
   870.    D5_thru_7_mask : constant := 2#111#;
   871.    D5_and_7_mask  : constant := 2#101#;
   872.    D2_thru_4_mask : constant := 2#111000#;
   873.
   874.    procedure decode_a_store_access_order (decoded : in out KDF9.decoded_order) is
   875.    begin
   876.       decoded.operand := KDF9.Q_part(decoded.order.syllable_2) + KDF9.Q_part(decoded.Qk)*2**8
   877.                        + KDF9.Q_part((decoded.order.syllable_0 and D2_thru_4_mask)) * 2**9;
   878.       decoded.compressed_opcode := decoded.compressed_opcode and D5_thru_7_mask;
   879.    end decode_a_store_access_order;
   880.
   881.    procedure decode_a_set_literal_order (decoded : in out KDF9.decoded_order) is
   882.    begin
   883.       decoded.operand := KDF9.Q_part(decoded.order.syllable_2)
   884.                        + KDF9.Q_part(decoded.order.syllable_1)*2**8;
   885.       decoded.compressed_opcode := 2#100#;
   886.    end decode_a_set_literal_order;
   887.
   888.    procedure process_syllables_1_and_2_of_a_data_access_order is
   889.    begin
   890.       if (INS.compressed_opcode and D5_thru_7_mask) < SET then
   891.          process_syllable_1_of_INS;
   892.          INS.order.syllable_2 := next_order_syllable;
   893.          decode_a_store_access_order(INS);
   894.       elsif (INS.compressed_opcode and D5_and_7_mask) = SET then
   895.          -- SET n
   896.          INS.order.syllable_1 := next_order_syllable;
   897.          INS.order.syllable_2 := next_order_syllable;
   898.          decode_a_set_literal_order(INS);
   899.       else
   900.          INS.order.syllable_1 := next_order_syllable;
   901.          INS.order.syllable_2 := next_order_syllable;
   902.          decode_a_set_literal_order(INS);
   903.          INS.compressed_opcode := 7;  -- an invalid compression.
   904.       end if;
   905.    end process_syllables_1_and_2_of_a_data_access_order;
   906.
   907.    procedure decode_the_next_order is
   908.    begin
   909.       -- The CPU time is adjusted by a fudge factor to account for
   910.       --    the instruction-fetch time being partly overlapped.
   911.       process_syllable_0_of_INS;
   912.       case INS.kind is
   913.          when one_syllable_order =>
   914.             return;
   915.          when two_syllable_order =>
   916.             process_syllable_1_of_INS;
   917.          when normal_jump_order =>
   918.             process_syllables_1_and_2_of_a_jump_order;
   919.          when data_access_order =>
   920.             process_syllables_1_and_2_of_a_data_access_order;
   921.       end case;
   922.    end decode_the_next_order;
   923.
   924.    procedure decode (the_order : in out KDF9.decoded_order) is
   925.    begin
   926.       decode_syllable_0(the_order);
   927.       case the_order.kind is
   928.          when one_syllable_order =>
   929.             null;
   930.          when two_syllable_order =>
   931.             decode_syllable_1(the_order);
   932.          when normal_jump_order =>
   933.             decode_syllable_1(the_order);
   934.             decode_a_jump_order(the_order);
   935.          when data_access_order =>
   936.             if (the_order.compressed_opcode and D5_thru_7_mask) < SET then
   937.                decode_syllable_1(the_order);
   938.                decode_a_store_access_order(the_order);
   939.             elsif (INS.compressed_opcode and D5_and_7_mask) = SET then
   940.                -- SET n
   941.                decode_a_set_literal_order(the_order);
   942.             else
   943.                decode_a_set_literal_order(the_order);
   944.                INS.compressed_opcode := 7;  -- an invalid compression.
   945.             end if;
   946.       end case;
   947.    end decode;
   948.
   949.    -- the_order_at_NIA gets three syllables starting at [NIA].  It is FOR DIAGNOSTIC USE ONLY!
   950.    -- It does NOT update the CPU time properly and MUST NOT be used inside an instruction cycle.
   951.
   952.    function the_order_at_NIA
   953.    return KDF9.syllable_group is
   954.       saved_NIA : constant KDF9.syllable_address := NIA;
   955.       result    : KDF9.syllable_group;
   956.    begin
   957.       result.syllable_0 := next_order_syllable;
   958.       result.syllable_1 := next_order_syllable;
   959.       result.syllable_2 := next_order_syllable;
   960.       set_NIA_to(saved_NIA);
   961.       return result;
   962.    end the_order_at_NIA;
   963.
   964.    -- This is the initial jump from the top halfword of E0 just after loading.
   965.
   966.    E0U : KDF9.word := 0;  -- N.B. the lower halfword is used for option flags.
   967.
   968.    procedure save_the_initial_jump is
   969.    begin
   970.       E0U := fetch_halfword(0, 0);
   971.    end save_the_initial_jump;
   972.
   973.    procedure restore_the_initial_jump is
   974.    begin
   975.        store_halfword(E0U, 0, 0);
   976.    end restore_the_initial_jump;
   977.
   978.    function the_initial_jump_was_corrupted
   979.    return Boolean
   980.    is (E0U /= fetch_halfword(0, 0));
   981.
   982.    function is_an_invalid_order (decoded : KDF9.decoded_order)
   983.    return Boolean is
   984.       syllable_0 : constant KDF9.syllable := decoded.order.syllable_0;
   985.    begin
   986.       return
   987.          (decoded.kind = data_access_order and then (syllable_0 and 2#101#) > 2#100#)     or else
   988.             (decoded.kind = normal_jump_order and then decoded.target.syllable_index > 5) or else
   989.                syllable_0 in 8#006# | 8#040# | 8#046# | 8#055# | 8#073# | 8#076# | 8#150#;
   990.    end is_an_invalid_order;
   991.
   992.    function is_an_unconditional_jump (decoded : KDF9.decoded_order)
   993.    return Boolean
   994.    is (
   995.        decoded.kind = normal_jump_order                   and then
   996.           decoded.order.syllable_0 in Jr | EXIT_n | EXITD and then
   997.              decoded.target.syllable_index < 6
   998.       );
   999.
  1000.    the_signature_hash : KDF9.word := 0;
  1001.
  1002.    function the_digital_signature
  1003.    return KDF9.word
  1004.    is (the_signature_hash);
  1005.
  1006.    function visible_state_hash
  1007.    return KDF9.word
  1008.       with Inline;
  1009.
  1010.    function visible_state_hash
  1011.    return KDF9.word is
  1012.       hash : KDF9.word;
  1013.    begin
  1014.       hash := rotate_word_right(the_signature_hash, 1) xor KDF9.word(ICR);
  1015.       hash := rotate_word_right(hash, 1) xor as_word(the_Q_store(INS.Qq));
  1016.       hash := rotate_word_right(hash, 1) xor as_word(the_Q_store(INS.Qk));
  1017.       if the_SJNS_depth > 0 then
  1018.          for s in reverse KDF9.SJNS_depth range 0 .. the_SJNS_depth-1 loop
  1019.                hash := rotate_word_right(hash, 1) xor as_word(the_SJNS(s));
  1020.          end loop;
  1021.       end if;
  1022.       if the_NEST_depth > 0 then
  1023.          for n in reverse KDF9.NEST_depth range 0 .. the_NEST_depth-1 loop
  1024.                hash := rotate_word_right(hash, 1) xor the_NEST(n);
  1025.          end loop;
  1026.       end if;
  1027.       return hash;
  1028.    end visible_state_hash;
  1029.
  1030.    procedure update_the_digital_signature is
  1031.    begin
  1032.       the_signature_hash := visible_state_hash;
  1033.    end update_the_digital_signature;
  1034.
  1035. end KDF9;

Compiling: ../Source/kdf9.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- The architecturally-defined data and register formats of the KDF9 computer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with System;
    18. --
    19. private with KDF9_char_sets;
    20.
    21. package KDF9 is
    22.
    23.    --
    24.    --
    25.    -- The fundamental storage unit is the 48-bit word.
    26.    --
    27.    --
    28.
    29.    --
    30.    -- The 48-bit word, considered as an unsigned integer.
    31.    --
    32.
    33.    type word is mod 2**48;
    34.
    35.    word_mask     : constant := 8#7777777777777777#;
    36.    min_word      : constant := 8#4000000000000000#;
    37.    max_word      : constant := 8#3777777777777777#;
    38.    all_zero_bits : constant := 0;
    39.    sign_bit      : constant := KDF9.min_word;
    40.    not_sign_bit  : constant := KDF9.max_word;
    41.    all_one_bits  : constant := KDF9.word_mask;
    42.
    43.
    44.    --
    45.    -- The 96-bit double word, considered as a pair of words.
    46.    --
    47.
    48.    type pair is
    49.       record
    50.          msw, lsw : KDF9.word;
    51.       end record;
    52.
    53.
    54.    --
    55.    -- The basic 16-bit operand.
    56.    --
    57.
    58.    type field_of_16_bits is mod 2**16;
    59.
    60.    --
    61.    -- The 16-bit word, considered as a field of a Q register.
    62.    --
    63.
    64.    type Q_part is new KDF9.field_of_16_bits;
    65.
    66.    Q_part_mask : constant := KDF9.Q_part'Last;
    67.
    68.    function sign_extended (Q : KDF9.Q_part)
    69.    return KDF9.word
    70.       with Inline;
    71.
    72.    --
    73.    -- The 16-bit word, considered as a buffer (DMA channel) number.
    74.    --
    75.
    76.    subtype buffer_number is KDF9.Q_part range 0 .. 15;
    77.
    78.    buffer_number_mask : constant := buffer_number'Last;
    79.
    80.    --
    81.    -- The 16-bit word, considered as a core-store address.
    82.    --
    83.
    84.    subtype address is KDF9.Q_part range 0 .. 8#77777#;
    85.
    86.    --
    87.    -- The Q-store element.
    88.    --
    89.
    90.    type Q_register is
    91.       record
    92.          C, I, M : KDF9.Q_part;
    93.       end record;
    94.
    95.    function as_Q (the_word : KDF9.word)
    96.    return KDF9.Q_register
    97.       with Inline;
    98.
    99.    function as_word (the_Q : KDF9.Q_register)
   100.    return KDF9.word
   101.       with Inline;
   102.
   103.
   104.    --
   105.    -- The 8-bit instruction syllable and its components.
   106.    --
   107.
   108.    type syllable is mod 2**8;
   109.
   110.    subtype compressed_opcode is KDF9.syllable range 0 .. 63;
   111.    subtype Q_number          is KDF9.syllable range 0 .. 15;
   112.
   113.    type syllable_group is
   114.       record
   115.          syllable_0, syllable_1, syllable_2 : KDF9.syllable := 0;
   116.       end record;
   117.
   118.
   119.    --
   120.    -- An instruction address.
   121.    --
   122.    -- N.B. 5 is the hardware's largest valid syllable address.
   123.    -- The values 6 and 7 are used as diagnostic flags by ee9.
   124.    -- They cause a RESET trap if encountered during execution.
   125.    --
   126.
   127.    type code_address   is mod 2**13;
   128.    type syllable_index is mod 2**3;
   129.
   130.    type syllable_address is
   131.       record
   132.          code_address   : KDF9.code_address;
   133.          syllable_index : KDF9.syllable_index;
   134.       end record;
   135.
   136.    --
   137.    -- An instruction address, in the packed format of a hardware (SJNS) link.
   138.    --
   139.
   140.    type SJNS_link is new KDF9.syllable_address
   141.       with Size => 16;
   142.    for SJNS_link'Bit_Order use System.Low_Order_First;
   143.    for SJNS_link use
   144.       record
   145.          code_address   at 0 range  0 .. 12;
   146.          syllable_index at 0 range 13 .. 15;
   147.       end record;
   148.
   149.    function as_word (the_link : KDF9.SJNS_link)
   150.    return KDF9.word;
   151.
   152.    function as_link (the_word : KDF9.word)
   153.    return KDF9.SJNS_link;
   154.
   155.    procedure increment_by_1 (the_link : in out KDF9.syllable_address)
   156.       with Inline;
   157.
   158.    procedure increment_by_2 (the_link : in out KDF9.syllable_address)
   159.       with Inline;
   160.
   161.    procedure increment_by_3 (the_link : in out KDF9.syllable_address)
   162.       with Inline;
   163.
   164.
   165.    --
   166.    -- The KDF9 halfword. Each occupies 24 bits, packed 2 per word.
   167.    --
   168.
   169.    type halfword is mod 2**24;
   170.    halfword_mask : constant := 8#77_77_77_77#;
   171.
   172.    subtype halfword_number is KDF9.address range 0 .. 1;
   173.
   174.
   175.    --
   176.    -- The KDF9 character occupies six bits, and they are packed 8 per word.
   177.    -- The various character sets, and the symbol type, are defined in the package KDF9_char_sets.
   178.    --
   179.
   180.
   181.    --
   182.    --
   183.    --
   184.    -- The following types define the structure of the KDF9's programmable registers.
   185.    --
   186.    --
   187.    --
   188.
   189.
   190.    --
   191.    -- authenticity_mode is declared here instead of in settings, to avoid a cyclic dependency.
   192.    --
   193.
   194.    type authenticity_mode is (modern_times_mode, authentic_time_mode);
   195.
   196.    the_authenticity_default : constant KDF9.authenticity_mode := modern_times_mode;
   197.    the_authenticity_mode    :          KDF9.authenticity_mode := the_authenticity_default;
   198.
   199.
   200.    --
   201.    --
   202.    --
   203.    -- The following variables (the_NEST, the_SJNS and the_Q_store) constitute
   204.    --    the emulation microcode's fixed working set of registers.
   205.    -- ee9 (unlike the real KDF9) swaps them with register_bank(the_context)
   206.    --    when a context switch is made by the =K3 instruction.
   207.    -- The real KDF9 used register_bank(the_context) directly for operands.
   208.    -- ee9's approach improves host cache locality and avoids indexing overheads,
   209.    --    the trade off being microscopically increased context-switching time.
   210.    --
   211.    --
   212.    --
   213.
   214.    --
   215.    -- The NEST.
   216.    --
   217.
   218.    type NEST_depth is mod 19;
   219.
   220.    type NEST is array (KDF9.NEST_depth) of KDF9.word;
   221.
   222.    the_NEST       : KDF9.NEST;
   223.    the_NEST_depth : KDF9.NEST_depth  := 0;
   224.
   225.    -- The ensure_that_the_NEST_holds* procedures trap NOUV.
   226.    -- They are used to validate operations that reduce the NEST depth.
   227.
   228.    procedure ensure_that_the_NEST_holds (at_least : in KDF9.NEST_depth)
   229.       with Inline;
   230.
   231.    procedure ensure_that_the_NEST_holds_an_operand
   232.       with Inline;
   233.
   234.    procedure ensure_that_the_NEST_holds_2_operands
   235.       with Inline;
   236.
   237.    function operand_words_needed (need : KDF9.NEST_depth)
   238.    return String
   239.       with Inline => False;
   240.
   241.    function pop
   242.    return KDF9.word
   243.       with Inline;
   244.
   245.    procedure pop
   246.       with Inline;
   247.
   248.    procedure write_top (the_word : in KDF9.word)
   249.       with Inline;
   250.
   251.    function read_top
   252.    return KDF9.word
   253.       with Inline;
   254.
   255.    function pop
   256.    return KDF9.pair
   257.       with Inline;
   258.
   259.    procedure pop_pair
   260.       with Inline;
   261.
   262.    procedure write_top (the_pair : in KDF9.pair)
   263.       with Inline;
   264.
   265.    function read_top
   266.    return KDF9.pair
   267.       with Inline;
   268.
   269.    -- The ensure_that_the_NEST_has_room_for* procedures trap NOUV.
   270.    -- They are used to validate operations that increase the NEST depth.
   271.
   272.    procedure ensure_that_the_NEST_has_room_for (at_least : in KDF9.NEST_depth)
   273.       with Inline;
   274.
   275.    procedure ensure_that_the_NEST_has_room_for_a_result
   276.       with Inline;
   277.
   278.    procedure push (the_word : in KDF9.word)
   279.       with Inline;
   280.
   281.    procedure ensure_that_the_NEST_has_room_for_2_results
   282.       with Inline;
   283.
   284.    procedure push (the_pair : in KDF9.pair)
   285.       with Inline;
   286.
   287.
   288.    --
   289.    -- The SJNS.
   290.    --
   291.
   292.    type SJNS_depth is mod 17;
   293.
   294.    type SJNS is array (KDF9.SJNS_depth) of KDF9.SJNS_link;
   295.
   296.    the_SJNS       : KDF9.SJNS;
   297.    JB             : KDF9.SJNS_link renames the_SJNS(16);
   298.    the_SJNS_depth : KDF9.SJNS_depth := 0;
   299.
   300.    procedure ensure_that_the_SJNS_is_not_empty
   301.       with Inline;
   302.
   303.    function pop
   304.    return KDF9.syllable_address
   305.       with Inline;
   306.
   307.    function SJNS_top
   308.    return KDF9.SJNS_link
   309.       with Inline;
   310.
   311.    procedure ensure_that_the_SJNS_is_not_full
   312.       with Inline;
   313.
   314.    procedure push (the_link : in KDF9.syllable_address)
   315.       with Inline;
   316.
   317.
   318.    --
   319.    -- The Q Store.
   320.    -- Q0 is kept permanently zeroised.
   321.    --
   322.
   323.    type Q_store is array (KDF9.Q_number) of KDF9.Q_register;
   324.
   325.    the_Q_store : KDF9.Q_store;
   326.
   327.
   328.    --
   329.    -- The Boolean registers.
   330.    --
   331.
   332.    the_V_bit_is_set : Boolean := False;
   333.    the_T_bit_is_set : Boolean := False;
   334.
   335.
   336.    --
   337.    --
   338.    -- The following are to do with maintaining the virtual time.
   339.    --
   340.    --
   341.
   342.    type us is mod 2**64;  -- The emulation clocks tick in microseconds (unlike KDF9's clock).
   343.
   344.    -- The virtual processor time.
   345.
   346.    the_CPU_time  : KDF9.us := 0;
   347.
   348.    -- The amount by which the_CPU_time is increased by an instruction execution.
   349.
   350.    the_CPU_delta : KDF9.us := 0;
   351.
   352.    -- The virtual elapsed time, capped to prevent a spurious double-clock (RESET) interrupt.
   353.
   354.    function the_clock_time
   355.    return KDF9.us
   356.       with Inline;
   357.
   358.    -- Advance to the largest of the_CPU_time, the_elapsed_time, the_last_delay_time, and past.
   359.    -- Cap the increase to prevent a spurious double-clock (RESET) interrupt in Director.
   360.    -- If necessary, pause execution until the real time equals the virtual elapsed time.
   361.
   362.    procedure advance_the_clock (past : in KDF9.us);
   363.
   364.    -- The virtual clock time at which the next IO interrupt is expected.
   365.
   366.    the_next_interrupt_time : KDF9.us := KDF9.us'Last;
   367.
   368.    -- Pause execution for the_delay_time in virtual microseconds.
   369.
   370.    procedure delay_by (the_delay_time : in KDF9.us);
   371.
   372.    -- If necessary, pause execution until the real time equals the virtual elapsed time.
   373.
   374.    procedure synchronize_the_real_and_virtual_times;
   375.
   376. ------------------------------------------------------------------------------------------------
   377.
   378.    --
   379.    --
   380.    -- The following registers are used only in Director state.
   381.    --
   382.    --
   383.
   384.
   385.    --
   386.    -- The following are to do with the K1 order.
   387.    --
   388.
   389.    type priority is mod 2**2;
   390.
   391.    -- CPL = priority level of the currently-executing problem program.
   392.
   393.    CPL : KDF9.priority;
   394.
   395.    -- BA = word address of first allocated word (NOT group number as in the KDF9).
   396.
   397.    BA  : KDF9.address;
   398.
   399.    -- NOL = word address of last allocated word (NOT group number as in the KDF9).
   400.
   401.    NOL : KDF9.address;
   402.
   403.    -- Set BA (setting bits D38:47), CPL (D34:35) and NOL (D24:33).
   404.
   405.    procedure set_K1_register (setting : in KDF9.word);
   406.
   407.
   408.    --
   409.    -- The following are to do with the =K2 order.
   410.    --
   411.
   412.    -- The Current Peripheral Device Allocation Register.
   413.
   414.    type CPDAR is array (KDF9.buffer_number) of Boolean
   415.       with Component_Size => 8, Convention => C;
   416.
   417.    the_CPDAR : KDF9.CPDAR;
   418.
   419.    -- Set CPDAR (setting bits D32 .. D47).
   420.
   421.    procedure set_K2_register (setting : in KDF9.word);
   422.
   423.
   424.    --
   425.    -- The following are to do with the =K3 and K7 orders.
   426.    --
   427.
   428.    type user_register_set is
   429.       record
   430.          NEST     : KDF9.NEST;
   431.          SJNS     : KDF9.SJNS;
   432.          Q_store  : KDF9.Q_store;
   433.       end record;
   434.
   435.
   436.    -- There are 4 sets of user registers.
   437.    -- The execution context is the number of the register set in active use.
   438.
   439.    type context is mod 2**2;
   440.
   441.    -- register_bank holds the currently inactive register sets.
   442.
   443.    register_bank : array(KDF9.context) of KDF9.user_register_set;
   444.
   445.    -- KDF9 actually indexed the register bank with the value of the_context,
   446.    --   but the emulator swaps register sets between register_bank and
   447.    --      the_NEST, the_SJNS, and the_Q_store (q.v.).
   448.
   449.    the_context : KDF9.context := 0;
   450.
   451.    -- Set context (bits D46:47), NEST_depth (D41:45) and SJNS_depth (D36:41).
   452.
   453.    procedure set_K3_register (setting : in KDF9.word);
   454.
   455.    -- Get BA (bits D0 .. D9), CPL (D12 .. D13) and NOL (D14 .. D23).
   456.
   457.    function get_K7_operand
   458.    return KDF9.word;
   459.
   460.
   461.    --
   462.    -- The following are to do with the K4 order.
   463.    --
   464.
   465.    type interrupt_number is range 22 .. 31;
   466.
   467.    -- higher PRiority PRogram unblocked by end of I/O, or INTQq on busy device
   468.    caused_by_PR    : constant KDF9.interrupt_number := 22;
   469.    PR_exception    : exception;
   470.
   471.    -- FLEXowriter interrupt from operator
   472.    caused_by_FLEX  : constant KDF9.interrupt_number := 23;
   473.    FLEX_exception  : exception;
   474.
   475.    -- Lock-In Violation (attempt at a disallowed operation)
   476.    caused_by_LIV   : constant KDF9.interrupt_number := 24;
   477.    LIV_exception   : exception;
   478.
   479.    -- Nest (or SJNS) Over/Underflow Violation
   480.    caused_by_NOUV  : constant KDF9.interrupt_number := 25;
   481.    NOUV_exception  : exception;
   482.
   483.    -- End of Director Transfer, or I/O priority inversion
   484.    caused_by_EDT   : constant KDF9.interrupt_number := 26;
   485.    EDT_exception   : exception;
   486.
   487.    -- OUT system call
   488.    caused_by_OUT   : constant KDF9.interrupt_number := 27;
   489.    OUT_exception   : exception;
   490.
   491.    -- Lock-Out Violation
   492.    caused_by_LOV   : constant KDF9.interrupt_number := 28;
   493.    LOV_exception   : exception;
   494.
   495.    -- invalid syllable number or 'double-clock'
   496.    caused_by_RESET : constant KDF9.interrupt_number := 29;
   497.    RESET_exception : exception;
   498.
   499.    type RFIR is array (KDF9.interrupt_number) of Boolean;
   500.
   501.    the_RFIR : KDF9.RFIR := (others => False);
   502.
   503.    -- The time at which the last K4 order was executed.
   504.    the_last_K4_time : KDF9.us := 0;
   505.
   506.    -- Get clock (bits D0:15) and RFIR (D16:31), clearing both.
   507.    function get_K4_operand
   508.    return KDF9.word
   509.       with Inline => False;
   510.
   511.    -- An interrupt is raised when 1 second expires outside Director;
   512.    --    the flag does not correspond to any RFIR bit.
   513.    caused_by_CLOCK : constant KDF9.interrupt_number := 31;
   514.    CLOCK_exception : exception;
   515.
   516.    -- This is for tracing a return from Director;
   517.    --    the flag does not correspond to any RFIR bit.
   518.    EXITD_flag : constant KDF9.interrupt_number := 30;
   519.
   520.    -- abandon_this_order is raised
   521.    -- 1. when an interrupt is punted to Director
   522.    -- OR
   523.    -- 2. when an operation is attempted, in a program running under Director,
   524.    --    that is invalid but is not defined to cause a LIV interrupt.
   525.    abandon_this_order : exception;
   526.
   527.    --
   528.    -- The following are to do with the K5 order.
   529.    --
   530.
   531.    -- The Program Hold-Up register is internal to I/O Control.
   532.    -- Get PHUi (bits D6i .. 6i+5), i = 0 .. 3.
   533.
   534.    function get_K5_operand
   535.    return KDF9.word;
   536.
   537.
   538.    --
   539.    -- The following are to do with management of the CPU's internal state.
   540.    --
   541.
   542.    type CPU_state is (Director_state, program_state);
   543.
   544.    the_CPU_state : KDF9.CPU_state;
   545.
   546.    procedure reset_V_and_T;
   547.
   548.    procedure reset_the_CPU_state (initial_entry : KDF9.syllable_address);
   549.
   550.    procedure reset_the_internal_registers (the_new_state : in CPU_state);
   551.
   552.    procedure fail_in_problem_program_state;
   553.
   554.    procedure LOV_if_user_mode (cause : in String);
   555.
   556.    procedure return_from_Director_to (new_IAR : in KDF9.syllable_address);
   557.
   558.    procedure effect_interrupt (caused_by_this : in KDF9.interrupt_number; message : in String)
   559.       with Inline => False;
   560.
   561.    procedure check_for_a_clock_interrupt
   562.       with Inline;
   563.
   564.    procedure trap_illegal_instruction (the_message : in String := "invalid opcode")
   565.       with Inline => False;
   566.
   567.    procedure trap_operator_error (the_message : in String)
   568.       with Inline => False, No_Return;
   569.
   570.    procedure trap_unimplemented_feature (the_message : in String)
   571.       with Inline => False, No_Return;
   572.
   573.    procedure trap_failing_OUT (OUT_number : in KDF9.word; the_message : in String)
   574.       with Inline => False, No_Return;
   575.
   576.    procedure trap_invalid_paper_tape (the_message : in String)
   577.       with Inline => False, No_Return;
   578.
   579.    procedure reset_the_program_state;
   580.
   581.
   582.    --
   583.    --
   584.    -- Instruction fetch and decode.
   585.    --
   586.    --
   587.
   588.    -- These Instruction Address Registers are the nearest KDF9 has
   589.    --    to a conventional 'Program Counter' register.
   590.    -- NIA is significant only after an instruction has been decoded.
   591.
   592.    function NIA
   593.    return KDF9.syllable_address  -- the Next Instruction Address
   594.       with Inline;
   595.
   596.    function NIA_word_number
   597.    return KDF9.code_address
   598.       with Inline;
   599.
   600.    CIA : KDF9.syllable_address := (0, 0);  -- the Current Instruction Address
   601.
   602.    -- IWB0 and IWB1 in KDF9 contained the current 2 instruction words.
   603.    -- A 'short' loop, initiated by the JCqNZS instruction, ran entirely
   604.    --    inside the IWBs, obviating repeated instruction-fetch overhead.
   605.    -- Director exploits this in a loop that zeroizes the whole of core,
   606.    --    including that loop, which runs, immune to overwriting, in the IWBs.
   607.
   608.    procedure set_NIA_to (new_NIA : in KDF9.syllable_address)
   609.       with Inline;
   610.
   611.    procedure set_NIA_to_the_INS_target_address
   612.       with Inline;
   613.
   614.    procedure set_IWB0_and_IWB1_for_a_JCqNZS_loop
   615.       with Inline;
   616.
   617.    procedure go_back_to_the_start_of_IWB0
   618.       with Inline;
   619.
   620.    procedure continue_after_JCqNZS
   621.       with Inline;
   622.
   623.    -- Bits 0-1 of every order indicate its type as follows.
   624.
   625.    type INS_kind is mod 2**2;
   626.
   627.    one_syllable_order : constant := 0;
   628.    two_syllable_order : constant := 1;
   629.    normal_jump_order  : constant := 2;
   630.    data_access_order  : constant := 3;
   631.
   632.    type decoded_order is
   633.       record
   634.          order : KDF9.syllable_group := (0, 0, 0);
   635.          kind  : KDF9.INS_kind := 0;
   636.
   637.          -- The compressed_opcode is:
   638.          --    bits 2-7 of 1- and 2-syllable orders
   639.          --    bits 2-3|8-11 of normal jumps
   640.          --    bits 5-7 of SET and directly-addressed store access orders.
   641.          -- See the KDF9.decoding package.
   642.          compressed_opcode : KDF9.compressed_opcode := 0;
   643.
   644.           -- Qq is bits 8-11, Qk is bits 12-15.
   645.          Qq, Qk : KDF9.Q_number := 0;
   646.
   647.          -- For an jump instruction, syllable_index is bits 5-7.
   648.          target : KDF9.syllable_address;
   649.
   650.          -- For a data address or value (SET), operand is bits 2-4|12-23.
   651.          operand : KDF9.Q_part := 0;
   652.       end record;
   653.
   654.    INS : KDF9.decoded_order;  -- analogous to the INS register in Main Control
   655.
   656.    -- After decode_the_next_order:
   657.    --    INS contains the whole instruction at the address given by CIA,
   658.    --       with its components unpacked (not all are significant in every case).
   659.
   660.    procedure decode_the_next_order
   661.       with Inline;
   662.
   663.    procedure decode (the_order : in out KDF9.decoded_order)
   664.       with Inline;
   665.
   666.    procedure process_syllable_0_of_INS
   667.       with Inline;
   668.
   669.    procedure process_syllable_1_of_INS
   670.       with Inline;
   671.
   672.    procedure process_syllables_1_and_2_of_a_jump_order
   673.       with Inline;
   674.
   675.    procedure process_syllables_1_and_2_of_a_data_access_order
   676.       with Inline;
   677.
   678.    -- the_order_at_NIA gets three syllables starting at [NIA].
   679.    -- It is FOR DIAGNOSTIC USE ONLY!
   680.    -- It does NOT update the CPU time properly and must not be used inside an instruction cycle!
   681.
   682.    function the_order_at_NIA
   683.    return KDF9.syllable_group
   684.       with Inline;
   685.
   686.    -- Save E0U, lest the initial jump in E0 be corrupted during the run.
   687.    procedure save_the_initial_jump;
   688.
   689.    -- Restore E0U to its saved value.
   690.    procedure restore_the_initial_jump;
   691.
   692.    -- Check whether E0U has changed.
   693.    function the_initial_jump_was_corrupted
   694.    return Boolean;
   695.
   696.    -- True if the parameter is not a valid KDF9 instruction.
   697.    function is_an_invalid_order (decoded : KDF9.decoded_order)
   698.    return Boolean;
   699.
   700.    -- True if the parameter is a well-formed unconditional jump.
   701.    function is_an_unconditional_jump (decoded : KDF9.decoded_order)
   702.    return Boolean;
   703.
   704.    --
   705.    -- The Instruction Counter Register, ICR, (N.B. NOT a 'PROGRAM counter')
   706.    --   indicates the number of instructions executed by the KDF9.
   707.    --
   708.
   709.    type order_counter is mod 2**64;
   710.
   711.    ICR : KDF9.order_counter := 0;
   712.
   713.
   714.    --
   715.    -- The following support hashed execution-signature checking,
   716.    --    mainly for self-checking of new versions and ports.
   717.    --
   718.
   719.    function the_digital_signature
   720.    return KDF9.word;
   721.
   722.    procedure update_the_digital_signature
   723.       with Inline;
   724.
   725. private
   726.
   727.    use KDF9_char_sets; pragma Warnings(Off, KDF9_char_sets);
   728.
   729.    the_elapsed_time    : KDF9.us := 0;
   730.    the_last_delay_time : KDF9.us := 0;
   731.
   732.    fetching_normally   : Boolean := True;
   733.
   734. end KDF9;

 1035 lines: No errors


Compiling: /home/parallels/emulation/Source/kdf9-microcode.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- KDF9 ISP emulation - CPU microcode routines.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with break_in;
    18. with exceptions;
    19. with IOC;
    20. with IOC.dispatcher;
    21. with KDF9.CPU;
    22. with KDF9.decoding;
    23. with KDF9.EGDON;
    24. with KDF9.store;
    25. with KDF9.TSD;
    26. with KDF9.TSD.processes;
    27. with POSIX;
    28. with settings;
    29. with state_display;
    30. with tracing;
    31.
    32. use  exceptions;
    33. use  IOC;
    34. use  IOC.dispatcher;
    35. use  KDF9.CPU;
    36. use  KDF9.decoding;
    37. use  KDF9.EGDON;
    38. use  KDF9.store;
    39. use  KDF9.TSD;
    40. use  KDF9.TSD.processes;
    41. use  settings;
    42. use  state_display;
    43. use  tracing;
    44.
    45. package body KDF9.microcode is
    46.
    47.    procedure do_a_one_syllable_order is
    48.       A, B, C, E : KDF9.word;
    49.       bit_count  : KDF9.word;
    50.       AB, CD     : KDF9.pair;
    51.       X, Y       : CPU.f48;
    52.       XY, ZT     : CPU.f96;
    53.    begin
    54.       case INS.compressed_opcode is
    55.
    56.          when 0 =>
    57.             -- The DUMMY order originally had code 0, before being changed to #17.
    58.             -- The Kidsgrove compiler continued to use code 0, so we must assume that,
    59.             --    despite the Manual, 0 continued to be a valid no-op order.
    60.             the_CPU_delta := the_CPU_delta + 1;
    61.
    62.          when VR =>
    63.             the_V_bit_is_set := False;
    64.             the_CPU_delta := the_CPU_delta + 1;
    65.
    66.          when TO_TR =>
    67.             ensure_that_the_NEST_holds_an_operand;
    68.             if resign(pop) < 0 then
    69.                the_T_bit_is_set := True;
    70.             end if;
    71.             the_CPU_delta := the_CPU_delta + 2;
    72.
    73.          when BITS =>
    74.             write_top(number_of_1_bits_in(read_top));
    75.             the_CPU_delta := the_CPU_delta + 27;
    76.
    77.          when XF =>
    78.             ensure_that_the_NEST_holds_2_operands;
    79.             X := pop;
    80.             Y := read_top;
    81.             write_top(CPU.f48'(Y * X));
    82.             the_CPU_delta := the_CPU_delta + 15;
    83.
    84.          when XDF =>
    85.             ensure_that_the_NEST_holds_2_operands;
    86.             XY := read_top;
    87.             ZT := XY.lsw * XY.msw;
    88.             write_top(ZT);
    89.             the_CPU_delta := the_CPU_delta + 16;
    90.
    91.          when XPLUSF =>
    92.             ensure_that_the_NEST_holds(at_least => 4);
    93.             XY := pop;
    94.             ZT := XY.lsw * XY.msw;
    95.             XY := read_top;
    96.             write_top(XY + ZT);
    97.             the_CPU_delta := the_CPU_delta + 18;
    98.
    99.          when NEGD =>
   100.             AB := read_top;
   101.             write_top( - AB);
   102.             the_CPU_delta := the_CPU_delta + 2;
   103.
   104.          when OR_9 =>
   105.             ensure_that_the_NEST_holds_2_operands;
   106.             A := pop;
   107.             write_top(read_top or A);
   108.             the_CPU_delta := the_CPU_delta + 1;
   109.
   110.          when PERM =>
   111.             A := pop;
   112.             CD := pop;
   113.             push(A);
   114.             push(CD);
   115.             the_CPU_delta := the_CPU_delta + 2;
   116.
   117.          when TOB =>
   118.             ensure_that_the_NEST_holds_2_operands;
   119.             A := pop;      -- the value
   120.             bit_count := number_of_1_bits_in(A);
   121.             B := read_top; -- the radixes
   122.             C := 0;
   123.
   124.             for i in 1 .. 8 loop
   125.                A := rotate_word_left(A, 6);
   126.                B := rotate_word_left(B, 6);
   127.                E := B and 8#77#; -- this radix
   128.                C := C*E + (A and 8#77#);
   129.             end loop;
   130.
   131.             write_top(C);
   132.             the_CPU_delta := the_CPU_delta + 2 + 4*KDF9.us(bit_count);
   133.
   134.          when ROUNDH =>
   135.             A := read_top;
   136.             write_top(resign(A) + 2**23);
   137.             the_CPU_delta := the_CPU_delta + 22;
   138.
   139.          when NEV =>
   140.             ensure_that_the_NEST_holds_2_operands;
   141.             A := pop;
   142.             write_top(read_top xor A);
   143.             the_CPU_delta := the_CPU_delta + 2;
   144.
   145.          when ROUND =>
   146.             ensure_that_the_NEST_holds_2_operands;
   147.             A := pop;
   148.             write_top(resign(A) + resign(shift_word_right(read_top, 46) and 1));
   149.             the_CPU_delta := the_CPU_delta + 1;
   150.
   151.          when DUMMY =>
   152.             the_CPU_delta := the_CPU_delta + 1;
   153.
   154.          when ROUNDF =>
   155.             ensure_that_the_NEST_holds_2_operands;
   156.             XY := pop;
   157.             ZT := XY;
   158.             push(narrowed(XY));
   159.             the_CPU_delta := the_CPU_delta + 3;
   160.
   161.          when ROUNDHF =>
   162.             X := pop;
   163.             push(narrowed(X));
   164.             the_CPU_delta := the_CPU_delta + 3;
   165.
   166.          when MINUSDF =>
   167.             ensure_that_the_NEST_holds(at_least => 4);
   168.             XY := pop;
   169.             ZT := read_top;
   170.             write_top(ZT - XY);
   171.             the_CPU_delta := the_CPU_delta + 12;
   172.
   173.          when PLUSDF =>
   174.             ensure_that_the_NEST_holds(at_least => 4);
   175.             XY := pop;
   176.             ZT := read_top;
   177.             write_top(ZT + XY);
   178.             the_CPU_delta := the_CPU_delta + 12;
   179.
   180.          when FLOAT_9 =>
   181.             ensure_that_the_NEST_holds_2_operands;
   182.             -- There is great uncertainty as to how the FLOAT/FLOATD orders handled scale factors
   183.             --   in N1 that lie outside the range allowed by the Manual, namely -128 <= N1 <= +127.
   184.             -- ee9 here takes a safety-first approach which is consistent with the
   185.             --    behaviour of the Kidsgrove sqrt function with arguments < 0.5º0.
   186.             A := shift_arithmetic(shift_logical(pop, +40), -40);
   187.             B := read_top;
   188.             write_top(KDF9.word(normalized(full_fraction => B, scaler => A)));
   189.
   190.          when FLOATD =>
   191.             ensure_that_the_NEST_holds(at_least => 3);
   192.             A := shift_arithmetic(shift_logical(pop, +40), -40);
   193.             CD := read_top;
   194.             -- See §3.4 of Report K/GD.y.83, dated 6/12/1962.  It would seem to require this:
   195.             -- CD.lsw := CD.lsw and not 8#77#;  -- The 6 l.s.b. are lost.
   196.             -- The above is commented out because it gives the wrong answer with KAA01.
   197.             -- A post-document hardware modification is suspected.
   198.             reconstruct(CD, scaler => A);
   199.             write_top(CD);
   200.             the_CPU_delta := the_CPU_delta + 8;
   201.
   202.          when ABS_9 =>
   203.             write_top( abs resign(read_top));
   204.             the_CPU_delta := the_CPU_delta + 1;
   205.
   206.          when NEG =>
   207.             write_top( - resign(read_top));
   208.             the_CPU_delta := the_CPU_delta + 1;
   209.
   210.          when ABSF =>
   211.             X := read_top;
   212.             if resign(KDF9.word(X)) < 0 then
   213.                write_top( - X);
   214.                the_CPU_delta := the_CPU_delta + 4;
   215.             else
   216.                the_CPU_delta := the_CPU_delta + 1;
   217.             end if;
   218.
   219.          when NEGF =>
   220.             X := read_top;
   221.             write_top( - X);
   222.             the_CPU_delta := the_CPU_delta + 3;
   223.
   224.          when MAX =>
   225.             AB := read_top;
   226.             if resign(AB.lsw) >= resign(AB.msw) then
   227.                write_top(KDF9.pair'(msw => AB.lsw, lsw =>AB.msw));
   228.                the_V_bit_is_set := True;
   229.             end if;
   230.             the_CPU_delta := the_CPU_delta + 4;
   231.
   232.          when NOT_9 =>
   233.             A := read_top;
   234.             write_top(not A);
   235.             the_CPU_delta := the_CPU_delta + 1;
   236.
   237.          when XD =>
   238.             AB := read_top;
   239.             CD := AB.msw * AB.lsw;
   240.             write_top(CD);
   241.             the_CPU_delta := the_CPU_delta + 14;
   242.
   243.          when X_frac =>
   244.             ensure_that_the_NEST_holds_2_operands;
   245.             A := pop;
   246.             write_top(as_word(CPU.fraction'(read_top * A)));
   247.             the_CPU_delta := the_CPU_delta + 15;
   248.
   249.          when MINUS =>
   250.             ensure_that_the_NEST_holds_2_operands;
   251.             A := pop;
   252.             B := read_top;
   253.             write_top(resign(B) - resign(A));
   254.             the_CPU_delta := the_CPU_delta + 1;
   255.
   256.          when SIGN =>
   257.             ensure_that_the_NEST_holds_2_operands;
   258.             A := pop;
   259.             B := read_top;
   260.             if B = A then
   261.                write_top(KDF9.word'(0));
   262.             elsif resign(B) > resign(A) then
   263.                write_top(KDF9.word'(1));
   264.             else
   265.                write_top(KDF9.word'(all_one_bits));
   266.             end if;
   267.             the_CPU_delta := the_CPU_delta + 3;
   268.
   269.          when ZERO =>
   270.             ensure_that_the_NEST_has_room_for_a_result;
   271.             push(KDF9.word'(all_zero_bits));
   272.             the_CPU_delta := the_CPU_delta + 2;
   273.
   274.          when DUP =>
   275.             ensure_that_the_NEST_has_room_for_a_result;
   276.             A := read_top;
   277.             push(A);
   278.             the_CPU_delta := the_CPU_delta + 2;
   279.
   280.          when DUPD =>
   281.             ensure_that_the_NEST_has_room_for_2_results;
   282.             AB := read_top;
   283.             push(AB);
   284.             the_CPU_delta := the_CPU_delta + 4;
   285.
   286.          when DIVI =>
   287.             AB := read_top;
   288.             do_DIVI(L => AB.lsw,
   289.                     R => AB.msw,
   290.                     Quotient  => CD.lsw,
   291.                     Remainder => CD.msw);
   292.             write_top(CD);
   293.             the_CPU_delta := the_CPU_delta + 36;
   294.
   295.          when FIX =>
   296.             ensure_that_the_NEST_holds_an_operand;
   297.             ensure_that_the_NEST_has_room_for_a_result;
   298.             X := read_top;
   299.             write_top(fraction_word(X));
   300.             push(scaler(X));
   301.             the_CPU_delta := the_CPU_delta + 6;
   302.
   303.          when STR =>
   304.             ensure_that_the_NEST_has_room_for_a_result;
   305.             A := read_top;
   306.             if resign(A) < 0 then
   307.                write_top(A and not_sign_bit);
   308.                push(KDF9.word'(all_one_bits));
   309.             else
   310.                push(KDF9.word'(all_zero_bits));
   311.             end if;
   312.             the_CPU_delta := the_CPU_delta + 3;
   313.
   314.          when CONT =>
   315.             ensure_that_the_NEST_holds_2_operands;
   316.             A := pop;
   317.             B := read_top;
   318.             write_top(contracted(KDF9.pair'(msw => A, lsw => B)));
   319.             the_CPU_delta := the_CPU_delta + 2;
   320.
   321.          when REVD =>
   322.             AB := pop;
   323.             CD := pop;
   324.             push(AB);
   325.             push(CD);
   326.             the_CPU_delta := the_CPU_delta + 4;
   327.
   328.          when ERASE =>
   329.             ensure_that_the_NEST_holds_an_operand;
   330.             pop;
   331.             the_CPU_delta := the_CPU_delta + 1;
   332.
   333.          when MINUSD =>
   334.             ensure_that_the_NEST_holds(at_least => 4);
   335.             AB := pop;
   336.             CD := read_top;
   337.             write_top(CD - AB);
   338.             the_CPU_delta := the_CPU_delta + 3;
   339.
   340.          when AND_9 =>
   341.             ensure_that_the_NEST_holds_2_operands;
   342.             A := pop;
   343.             write_top(read_top and A);
   344.             the_CPU_delta := the_CPU_delta + 1;
   345.
   346.          when PLUS =>
   347.             ensure_that_the_NEST_holds_2_operands;
   348.             A := pop;
   349.             B := read_top;
   350.             write_top(resign(B) + resign(A));
   351.             the_CPU_delta := the_CPU_delta + 1;
   352.
   353.          when PLUSD =>
   354.             ensure_that_the_NEST_holds(at_least => 4);
   355.             AB := pop;
   356.             CD := read_top;
   357.             write_top(CD + AB);
   358.             the_CPU_delta := the_CPU_delta + 3;
   359.
   360.          when DIV =>
   361.             ensure_that_the_NEST_holds_2_operands;
   362.             AB := pop;
   363.             push(as_word(CPU.fraction'(AB.lsw / AB.msw)));
   364.             the_CPU_delta := the_CPU_delta + 36;
   365.
   366.          when DIVD =>
   367.             ensure_that_the_NEST_holds(at_least => 3);
   368.             A := pop;
   369.             CD := pop;
   370.             do_DIVD(L => CD,
   371.                     R => A,
   372.                     Q => E);
   373.             push(E);
   374.             the_CPU_delta := the_CPU_delta + 36;
   375.
   376.          when DIVF =>
   377.             X := pop;
   378.             Y := read_top;
   379.             write_top(Y / X);
   380.             the_CPU_delta := the_CPU_delta + 36;
   381.
   382.          when DIVDF =>
   383.             ensure_that_the_NEST_holds(at_least => 3);
   384.             Y := pop;
   385.             XY := pop;
   386.             push(XY / Y);
   387.             the_CPU_delta := the_CPU_delta + 35;
   388.
   389.          when DIVR =>
   390.             ensure_that_the_NEST_holds(at_least => 3);
   391.             A := pop;
   392.             CD := read_top;
   393.             do_DIVR(L => CD,
   394.                     R => A,
   395.                     Quotient  => AB.msw,
   396.                     Remainder => AB.lsw);
   397.             write_top(AB);
   398.             the_CPU_delta := the_CPU_delta + 36;
   399.
   400.          when REV =>
   401.             AB := read_top;
   402.             write_top(KDF9.pair'(msw => AB.lsw, lsw =>AB.msw));
   403.             the_CPU_delta := the_CPU_delta + 1;
   404.
   405.          when CAB =>
   406.             AB := pop;
   407.             C := pop;
   408.             push(AB);
   409.             push(C);
   410.             the_CPU_delta := the_CPU_delta + 2;
   411.
   412.          when FRB =>
   413.             ensure_that_the_NEST_holds_2_operands;
   414.             A := pop;      -- the value
   415.             bit_count := number_of_1_bits_in(A);
   416.             B := read_top; -- the radixes
   417.             C := 0;
   418.
   419.             for i in 1 .. 8 loop
   420.                E := B and 8#77#;
   421.                if E /= 0 then
   422.                   C := C or (A mod E);
   423.                   A := A / E;
   424.                else
   425.                   if A /= 0 then the_V_bit_is_set := True; end if;
   426.                end if;
   427.                B := shift_word_right(B, 6);
   428.                C := rotate_word_right(C, 6);
   429.             end loop;
   430.
   431.             if A /= 0 then
   432.                -- The value was too big for the representation; see Manual.
   433.                the_V_bit_is_set := True;
   434.             end if;
   435.             write_top(C);
   436.             the_CPU_delta := the_CPU_delta + 8 + 3*KDF9.us(bit_count);
   437.
   438.          when STAND =>
   439.             X := read_top;
   440.             write_top(normalized(X));
   441.             the_CPU_delta := the_CPU_delta + 5;
   442.
   443.          when NEGDF =>
   444.             XY := read_top;
   445.             write_top( - XY);
   446.             the_CPU_delta := the_CPU_delta + 9;
   447.
   448.          when MAXF =>
   449.             XY := read_top;
   450.             if XY.lsw >= XY.msw then
   451.                write_top(CPU.f96'(msw => XY.lsw, lsw =>XY.msw));
   452.                the_V_bit_is_set := True;
   453.             end if;
   454.             the_CPU_delta := the_CPU_delta + 6;
   455.
   456.          when PLUSF =>
   457.             ensure_that_the_NEST_holds_2_operands;
   458.             X := pop;
   459.             Y := read_top;
   460.             write_top(Y + X);
   461.             the_CPU_delta := the_CPU_delta + 7;
   462.
   463.          when MINUSF =>
   464.             ensure_that_the_NEST_holds_2_operands;
   465.             X := pop;
   466.             Y := read_top;
   467.             write_top(Y - X);
   468.             the_CPU_delta := the_CPU_delta + 7;
   469.
   470.          when SIGNF =>
   471.             ensure_that_the_NEST_holds_2_operands;
   472.             XY := pop;
   473.             if KDF9.word(XY.lsw) = KDF9.word(XY.msw) then
   474.                push(KDF9.word'(all_zero_bits));
   475.             elsif XY.lsw < XY.msw then
   476.                push(KDF9.word'(all_one_bits));
   477.             else
   478.                push(KDF9.word(1));
   479.             end if;
   480.             the_CPU_delta := the_CPU_delta + 5;
   481.
   482.          when others =>
   483.             trap_illegal_instruction;
   484.
   485.       end case;
   486.    end do_a_one_syllable_order;
   487.
   488.
   489.    procedure do_an_IO_order is
   490.       IO_opcode   : constant KDF9.compressed_opcode := (INS.Qk and not manual_bit);
   491.       IO_operand  : constant KDF9.Q_register := the_Q_store(INS.Qq);
   492.       set_offline : constant Boolean         := (INS.Qk and manual_bit) /= 0;
   493.    begin
   494.       case INS.compressed_opcode is
   495.
   496.          when PAR_Qq =>
   497.             the_CPU_delta := the_CPU_delta + 11;
   498.             PAR(IO_operand, set_offline, the_T_bit_is_set);
   499.             the_CPU_delta := the_CPU_delta + 3;
   500.
   501.          when PIA_PIC_CLO_TLO_Qq =>
   502.             the_CPU_delta := the_CPU_delta + 15;
   503.             case IO_opcode is
   504.                when PIA_bits =>
   505.                   PIA(IO_operand, set_offline);
   506.                   the_CPU_delta := the_CPU_delta + 7;
   507.                when PIC_bits =>
   508.                   PIC(IO_operand, set_offline);
   509.                   the_CPU_delta := the_CPU_delta + 7;
   510.                when CLO_bits =>
   511.                   fail_in_problem_program_state;
   512.                   CLO(IO_operand, set_offline);
   513.                   the_CPU_delta := the_CPU_delta + 1;
   514.                when TLO_bits =>
   515.                   TLO(IO_operand, the_T_bit_is_set);
   516.                when others =>
   517.                   trap_illegal_instruction;
   518.             end case;
   519.
   520.          when PIB_PID_Qq =>
   521.             the_CPU_delta := the_CPU_delta + 15;
   522.             case IO_opcode is
   523.                when PIB_bits =>
   524.                   PIB(IO_operand, set_offline);
   525.                   the_CPU_delta := the_CPU_delta + 7;
   526.                when PID_bits =>
   527.                   PID(IO_operand, set_offline);
   528.                   the_CPU_delta := the_CPU_delta + 7;
   529.                when others =>
   530.                   trap_illegal_instruction;
   531.             end case;
   532.
   533.          when PIE_PIG_Qq =>
   534.             the_CPU_delta := the_CPU_delta + 15;
   535.             case IO_opcode is
   536.                when PIE_bits =>
   537.                   PIE(IO_operand, set_offline);
   538.                   the_CPU_delta := the_CPU_delta + 7;
   539.                when PIG_bits =>
   540.                   PIG(IO_operand, set_offline);
   541.                   the_CPU_delta := the_CPU_delta + 7;
   542.                when others =>
   543.                   trap_illegal_instruction;
   544.             end case;
   545.
   546.          when PIF_PIH_Qq =>
   547.             the_CPU_delta := the_CPU_delta + 15;
   548.             case IO_opcode is
   549.                when PIF_bits =>
   550.                   PIF(IO_operand, set_offline);
   551.                   the_CPU_delta := the_CPU_delta + 7;
   552.                when PIH_bits =>
   553.                   PIH(IO_operand, set_offline);
   554.                   the_CPU_delta := the_CPU_delta + 7;
   555.                when others =>
   556.                   trap_illegal_instruction;
   557.             end case;
   558.
   559.          when PMA_PMK_INT_Qq =>
   560.             the_CPU_delta := the_CPU_delta + 11;
   561.             case IO_opcode is
   562.                when PMA_bits =>
   563.                   PMA(IO_operand, set_offline);
   564.                when PMK_bits =>
   565.                   PMK(IO_operand, set_offline);
   566.                when INT_bits =>
   567.                   INT(IO_operand, set_offline);
   568.                when others =>
   569.                   trap_illegal_instruction;
   570.             end case;
   571.
   572.          when CT_PMB_PMC_BUSY_Qq =>
   573.             the_CPU_delta := the_CPU_delta + 11;
   574.             case IO_opcode is
   575.                when CTQ_bits =>
   576.                   -- if set_offline then MANUALQq else CTQq
   577.                   if set_offline                      or else
   578.                         the_CPU_state = Director_state   then
   579.                      MANUAL_CT(IO_operand, set_offline);
   580.                      the_CPU_delta := the_CPU_delta + 2;
   581.                   else
   582.                      trap_illegal_instruction; -- This will always LIV, as we are not in Director.
   583.                   end if;
   584.                when PMB_bits =>
   585.                   PMB(IO_operand, set_offline);
   586.                   the_CPU_delta := the_CPU_delta + 3;
   587.                when PMC_bits =>
   588.                   PMC(IO_operand, set_offline);
   589.                   the_CPU_delta := the_CPU_delta + 3;
   590.                when BUSY_bits =>
   591.                   BUSY(IO_operand, set_offline, the_T_bit_is_set);
   592.                   the_CPU_delta := the_CPU_delta + 2;
   593.                when others =>
   594.                   trap_illegal_instruction;
   595.             end case;
   596.
   597.          when PMD_PME_PML_Qq =>
   598.             the_CPU_delta := the_CPU_delta + 14;
   599.             case IO_opcode is
   600.                when PMD_bits =>
   601.                   PMD(IO_operand, set_offline);
   602.                   the_CPU_delta := the_CPU_delta + 5;
   603.                when PME_bits =>
   604.                   PME(IO_operand, set_offline);
   605.                   the_CPU_delta := the_CPU_delta + 5;
   606.                when PML_bits =>
   607.                   PML(IO_operand, set_offline);
   608.                   the_CPU_delta := the_CPU_delta + 5;
   609.                when others =>
   610.                   trap_illegal_instruction;
   611.             end case;
   612.
   613.          when PMF_PMG_Qq =>
   614.             the_CPU_delta := the_CPU_delta + 11;
   615.             case IO_opcode is
   616.                when PMF_bits =>
   617.                   PMF(IO_operand, set_offline);
   618.                   the_CPU_delta := the_CPU_delta + 3;
   619.                when PMG_bits =>
   620.                   fail_in_problem_program_state;
   621.                   the_CPU_delta := the_CPU_delta + 14;  -- ??
   622.                   PMG(IO_operand, set_offline);
   623.                 when others =>
   624.                   trap_illegal_instruction;
   625.             end case;
   626.
   627.          when POA_POC_POE_POF_PMH_Qq =>
   628.             the_CPU_delta := the_CPU_delta + 15;
   629.             case IO_opcode is
   630.                when POA_bits =>
   631.                   POA(IO_operand, set_offline);
   632.                   the_CPU_delta := the_CPU_delta + 7;
   633.                when POC_bits =>
   634.                   POC(IO_operand, set_offline);
   635.                   the_CPU_delta := the_CPU_delta + 7;
   636.                when POE_bits =>
   637.                   POE(IO_operand, set_offline);
   638.                   the_CPU_delta := the_CPU_delta + 4;
   639.                when POF_bits =>
   640.                   POF(IO_operand, set_offline);
   641.                   the_CPU_delta := the_CPU_delta + 4;
   642.                when PMH_bits =>
   643.                   fail_in_problem_program_state;
   644.                   SLO(IO_operand, set_offline);
   645.                   the_CPU_delta := the_CPU_delta + 1;
   646.                when others =>
   647.                   trap_illegal_instruction;
   648.             end case;
   649.
   650.          when POB_POD_Qq =>
   651.             the_CPU_delta := the_CPU_delta + 15;
   652.             case IO_opcode is
   653.                when POB_bits =>
   654.                   POB(IO_operand, set_offline);
   655.                   the_CPU_delta := the_CPU_delta + 7;
   656.                when POD_bits =>
   657.                   POD(IO_operand, set_offline);
   658.                   the_CPU_delta := the_CPU_delta + 7;
   659.                when others =>
   660.                   trap_illegal_instruction;
   661.             end case;
   662.
   663.          when POG_POL_Qq =>
   664.             the_CPU_delta := the_CPU_delta + 15;
   665.             case IO_opcode is
   666.                when POG_bits =>
   667.                   POG(IO_operand, set_offline);
   668.                   the_CPU_delta := the_CPU_delta + 7;
   669.                when POL_bits =>
   670.                   POL(IO_operand, set_offline);
   671.                   the_CPU_delta := the_CPU_delta + 7;
   672.                when others =>
   673.                   trap_illegal_instruction;
   674.             end case;
   675.
   676.          when POH_POK_Qq =>
   677.             the_CPU_delta := the_CPU_delta + 15;
   678.             case IO_opcode is
   679.                when POH_bits =>
   680.                   POH(IO_operand, set_offline);
   681.                   the_CPU_delta := the_CPU_delta + 7;
   682.                when POK_bits =>
   683.                   POK(IO_operand, set_offline);
   684.                   the_CPU_delta := the_CPU_delta + 7;
   685.                when others =>
   686.                   trap_illegal_instruction;
   687.             end case;
   688.
   689.          when others =>
   690.             trap_illegal_instruction;
   691.
   692.       end case;
   693.    end do_an_IO_order;
   694.
   695.
   696.    all_zero_Q_store : constant KDF9.Q_register := (C | I | M => 0);
   697.
   698.    procedure ensure_that_Q0_contains_zero (suspect : KDF9.Q_number)
   699.       with Inline;
   700.
   701.    procedure ensure_that_Q0_contains_zero (suspect : KDF9.Q_number) is
   702.    begin
   703.       if suspect = 0 then
   704.          the_Q_store(0) := all_zero_Q_store;  -- Override any assignment to Q0.
   705.       end if;
   706.    end ensure_that_Q0_contains_zero;
   707.
   708.    procedure auto_increment
   709.       with Inline;
   710.
   711.    procedure auto_increment is
   712.    begin
   713.       if INS.Qq /= 0 then
   714.          the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M + the_Q_store(INS.Qq).I;
   715.          the_Q_store(INS.Qq).C := the_Q_store(INS.Qq).C - 1;
   716.       end if;
   717.    end auto_increment;
   718.
   719.    function shift_count
   720.    return CPU.signed_Q_part
   721.       with Inline;
   722.
   723.    function shift_count
   724.    return CPU.signed_Q_part
   725.    is (
   726.        if (INS.order.syllable_1 and constant_bit) /= 0  then
   727.           resign(KDF9.Q_part(INS.order.syllable_1/2 xor 64)) - 64
   728.        else
   729.           resign((the_Q_store(INS.Qq).C and 255) xor 128) - 128
   730.       );
   731.
   732.
   733.    procedure do_a_two_syllable_order is
   734.       A  : KDF9.word;
   735.       AB : KDF9.pair;
   736.       CD : KDF9.pair;
   737.    begin
   738.       case INS.compressed_opcode is
   739.
   740.          when JCqNZS =>
   741.             if CIA.syllable_index = 5 then
   742.                -- KDF9 did not actually detect this error, and the JCqNZS instruction would work
   743.                --    until broken-into by an interrupt, which returned to the word following that
   744.                --       containing the first syllable of the JCqNZS instruction.
   745.                -- I see no case for reproducing this behaviour.
   746.                trap_illegal_instruction ("JCqNZS instruction at syllable 5");
   747.             end if;
   748.             if the_Q_store(INS.Qq).C /= 0 then
   749.                if fetching_normally then
   750.                   set_IWB0_and_IWB1_for_a_JCqNZS_loop;
   751.                   the_CPU_delta := the_CPU_delta + 7;  -- Takes 11µs the first time it jumps.
   752.                end if;
   753.                -- The IWBs now contain the loop, so go to syllable 0 of IWB0.
   754.                go_back_to_the_start_of_IWB0;
   755.             else
   756.                continue_after_JCqNZS;
   757.             end if;
   758.             the_CPU_delta := the_CPU_delta + 4;
   759.
   760.          when MkMq =>
   761.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   762.             check_address_and_lockout(the_trace_address);
   763.             ensure_that_the_NEST_has_room_for_a_result;
   764.             the_trace_operand := fetch_word(the_trace_address);
   765.             push(the_trace_operand);
   766.             the_CPU_delta := the_CPU_delta + 7;
   767.
   768.          when MkMqQ =>
   769.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   770.             check_address_and_lockout(the_trace_address);
   771.             ensure_that_the_NEST_has_room_for_a_result;
   772.             the_trace_operand := fetch_word(the_trace_address);
   773.             push(the_trace_operand);
   774.             auto_increment;
   775.             the_CPU_delta := the_CPU_delta + 8;
   776.
   777.          when MkMqH =>
   778.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   779.             check_address_and_lockout(the_trace_address);
   780.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   781.             ensure_that_the_NEST_has_room_for_a_result;
   782.             push(the_trace_operand);
   783.             the_CPU_delta := the_CPU_delta + 7;
   784.
   785.          when MkMqQH =>
   786.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   787.             check_address_and_lockout(the_trace_address);
   788.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   789.             ensure_that_the_NEST_has_room_for_a_result;
   790.             push(the_trace_operand);
   791.             auto_increment;
   792.             the_CPU_delta := the_CPU_delta + 8;
   793.
   794.          when MkMqN =>
   795.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   796.             check_address_and_lockout(the_trace_address);
   797.             ensure_that_the_NEST_has_room_for_a_result;
   798.             the_trace_operand := fetch_word(the_trace_address);
   799.             push(the_trace_operand);
   800.             the_CPU_delta := the_CPU_delta + 7;
   801.
   802.          when MkMqQN =>
   803.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   804.             check_address_and_lockout(the_trace_address);
   805.             ensure_that_the_NEST_has_room_for_a_result;
   806.             the_trace_operand := fetch_word(the_trace_address);
   807.             push(the_trace_operand);
   808.             auto_increment;
   809.             the_CPU_delta := the_CPU_delta + 8;
   810.
   811.          when MkMqHN =>
   812.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   813.             check_address_and_lockout(the_trace_address);
   814.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   815.             ensure_that_the_NEST_has_room_for_a_result;
   816.             push(the_trace_operand);
   817.             the_CPU_delta := the_CPU_delta + 7;
   818.
   819.          when MkMqQHN =>
   820.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   821.             check_address_and_lockout(the_trace_address);
   822.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   823.             ensure_that_the_NEST_has_room_for_a_result;
   824.             push(the_trace_operand);
   825.             auto_increment;
   826.             the_CPU_delta := the_CPU_delta + 8;
   827.
   828.          when TO_MkMq =>
   829.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   830.             check_address_and_lockout(the_trace_address);
   831.             ensure_that_the_NEST_holds_an_operand;
   832.             the_trace_operand := pop;
   833.             store_word(the_trace_operand, the_trace_address);
   834.             the_CPU_delta := the_CPU_delta + 7;
   835.
   836.          when TO_MkMqQ =>
   837.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   838.             check_address_and_lockout(the_trace_address);
   839.             ensure_that_the_NEST_holds_an_operand;
   840.             the_trace_operand := pop;
   841.             store_word(the_trace_operand, the_trace_address);
   842.             auto_increment;
   843.             the_CPU_delta := the_CPU_delta + 8;
   844.
   845.          when TO_MkMqH =>
   846.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   847.             check_address_and_lockout(the_trace_address);
   848.             ensure_that_the_NEST_holds_an_operand;
   849.             the_trace_operand := pop;
   850.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   851.             the_CPU_delta := the_CPU_delta + 7;
   852.
   853.          when TO_MkMqQH =>
   854.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   855.             check_address_and_lockout(the_trace_address);
   856.             ensure_that_the_NEST_holds_an_operand;
   857.             the_trace_operand := pop;
   858.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   859.             auto_increment;
   860.             the_CPU_delta := the_CPU_delta + 8;
   861.
   862.          when TO_MkMqN =>
   863.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   864.             check_address_and_lockout(the_trace_address);
   865.             ensure_that_the_NEST_holds_an_operand;
   866.             the_trace_operand := pop;
   867.             store_word(the_trace_operand, the_trace_address);
   868.             the_CPU_delta := the_CPU_delta + 7;
   869.
   870.          when TO_MkMqQN =>
   871.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   872.             check_address_and_lockout(the_trace_address);
   873.             ensure_that_the_NEST_holds_an_operand;
   874.             the_trace_operand := pop;
   875.             store_word(the_trace_operand, the_trace_address);
   876.             auto_increment;
   877.             the_CPU_delta := the_CPU_delta + 8;
   878.
   879.          when TO_MkMqHN =>
   880.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   881.             check_address_and_lockout(the_trace_address);
   882.             ensure_that_the_NEST_holds_an_operand;
   883.             the_trace_operand := pop;
   884.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   885.             the_CPU_delta := the_CPU_delta + 7;
   886.
   887.          when TO_MkMqQHN =>
   888.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   889.             check_address_and_lockout(the_trace_address);
   890.             ensure_that_the_NEST_holds_an_operand;
   891.             the_trace_operand := pop;
   892.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   893.             auto_increment;
   894.             the_CPU_delta := the_CPU_delta + 8;
   895.
   896.          when M_PLUS_Iq =>
   897.             the_CPU_delta := the_CPU_delta + 4;
   898.             the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M + the_Q_store(INS.Qq).I;
   899.
   900.          when M_MINUS_Iq =>
   901.             the_CPU_delta := the_CPU_delta + 5;
   902.             the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M - the_Q_store(INS.Qq).I;
   903.
   904.          when NCq =>
   905.             the_CPU_delta := the_CPU_delta + 5;
   906.             the_Q_store(INS.Qq).C := - the_Q_store(INS.Qq).C;
   907.
   908.          when DCq =>
   909.             the_CPU_delta := the_CPU_delta + 3;
   910.             if INS.Qq /= 0 then
   911.                the_Q_store(INS.Qq).C := the_Q_store(INS.Qq).C - 1;
   912.             end if;
   913.
   914.          when POS1_TO_Iq =>
   915.             the_CPU_delta := the_CPU_delta + 3;
   916.             if INS.Qq /= 0 then
   917.                the_Q_store(INS.Qq).I := + 1;
   918.             end if;
   919.
   920.          when NEG1_TO_Iq =>
   921.             the_CPU_delta := the_CPU_delta + 3;
   922.             if INS.Qq /= 0 then
   923.                the_Q_store(INS.Qq).I := 8#177777#;  -- i.e. -1
   924.             end if;
   925.
   926.          when POS2_TO_Iq =>
   927.             the_CPU_delta := the_CPU_delta + 3;
   928.             if INS.Qq /= 0 then
   929.                the_Q_store(INS.Qq).I := + 2;
   930.             end if;
   931.
   932.          when NEG2_TO_Iq =>
   933.             the_CPU_delta := the_CPU_delta + 3;
   934.             if INS.Qq /= 0 then
   935.                the_Q_store(INS.Qq).I := 8#177776#;  -- i.e. -2
   936.             end if;
   937.
   938.          when CqTOQk =>
   939.             the_CPU_delta := the_CPU_delta + 4;
   940.             if INS.Qk /= 0 then
   941.                the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   942.             end if;
   943.
   944.          when IqTOQk =>
   945.             the_CPU_delta := the_CPU_delta + 4;
   946.             if INS.Qk /= 0 then
   947.                the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   948.             end if;
   949.
   950.          when MqTOQk =>
   951.             the_CPU_delta := the_CPU_delta + 4;
   952.             if INS.Qk /= 0 then
   953.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   954.             end if;
   955.
   956.          when QqTOQk =>
   957.             the_CPU_delta := the_CPU_delta + 4;
   958.             if INS.Qk /= 0 then
   959.                the_Q_store(INS.Qk) := the_Q_store(INS.Qq);
   960.             end if;
   961.
   962.          when CIqTOQk =>
   963.            the_CPU_delta := the_CPU_delta + 4;
   964.            if INS.Qk /= 0 then
   965.               the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   966.               the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   967.            end if;
   968.
   969.          when IMqTOQk =>
   970.             the_CPU_delta := the_CPU_delta + 4;
   971.             if INS.Qk /= 0 then
   972.                the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   973.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   974.             end if;
   975.
   976.          when CMqTOQk =>
   977.             the_CPU_delta := the_CPU_delta + 4;
   978.             if INS.Qk /= 0 then
   979.                the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   980.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   981.             end if;
   982.
   983.          when QCIMq =>
   984.             ensure_that_the_NEST_has_room_for_a_result;
   985.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- Qq
   986.                push(as_word(the_Q_store(INS.Qq)));
   987.                the_CPU_delta := the_CPU_delta + 4;
   988.             elsif (INS.Qk and M_part_choice) /= 0 then       -- Mq
   989.                push(sign_extended(the_Q_store(INS.Qq).M));
   990.                the_CPU_delta := the_CPU_delta + 4;
   991.             elsif (INS.Qk and C_part_choice) /= 0 then       -- Cq
   992.                push(sign_extended(the_Q_store(INS.Qq).C));
   993.                the_CPU_delta := the_CPU_delta + 5;
   994.             elsif (INS.Qk and I_part_choice) /= 0 then       -- Iq
   995.                push(sign_extended(the_Q_store(INS.Qq).I));
   996.                the_CPU_delta := the_CPU_delta + 6;
   997.             else
   998.                trap_illegal_instruction;
   999.             end if;
  1000.
  1001.          when TO_RCIMq =>
  1002.             ensure_that_the_NEST_holds_an_operand;
  1003.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- =Qq
  1004.                the_Q_store(INS.Qq) := as_Q(pop);
  1005.                the_CPU_delta := the_CPU_delta + 2;
  1006.             elsif (INS.Qk and M_part_choice) /= 0 then       -- =[R]Mq
  1007.                the_Q_store(INS.Qq).M := KDF9.Q_part(pop and Q_part_mask);
  1008.                if (INS.Qk and reset_choice) /= 0 then
  1009.                   the_Q_store(INS.Qq).C := 0;
  1010.                   the_Q_store(INS.Qq).I := 1;
  1011.                   the_CPU_delta := the_CPU_delta + 3;
  1012.                else
  1013.                   the_CPU_delta := the_CPU_delta + 2;
  1014.                end if;
  1015.             elsif (INS.Qk and C_part_choice) /= 0 then       -- =[R]Cq
  1016.                the_Q_store(INS.Qq).C := KDF9.Q_part(pop and Q_part_mask);
  1017.                if (INS.Qk and reset_choice) /= 0 then
  1018.                   the_Q_store(INS.Qq).I := 1;
  1019.                   the_Q_store(INS.Qq).M := 0;
  1020.                   the_CPU_delta := the_CPU_delta + 3;
  1021.                else
  1022.                   the_CPU_delta := the_CPU_delta + 2;
  1023.                end if;
  1024.             elsif (INS.Qk and I_part_choice) /= 0 then       -- =[R]Iq
  1025.                the_Q_store(INS.Qq).I := KDF9.Q_part(pop and Q_part_mask);
  1026.                if (INS.Qk and reset_choice) /= 0 then
  1027.                   the_Q_store(INS.Qq).C := 0;
  1028.                   the_Q_store(INS.Qq).M := 0;
  1029.                   the_CPU_delta := the_CPU_delta + 3;
  1030.                else
  1031.                   the_CPU_delta := the_CPU_delta + 2;
  1032.                end if;
  1033.             else
  1034.                trap_illegal_instruction;
  1035.             end if;
  1036.             ensure_that_Q0_contains_zero(suspect => INS.Qq);
  1037.
  1038.          when ADD_TO_QCIMq =>
  1039.             ensure_that_the_NEST_has_room_for_a_result;
  1040.             ensure_that_the_NEST_holds_an_operand;
  1041.
  1042.             -- Because the following does not push the Q operand on to the NEST,
  1043.             --   it will not leave an authentic bit pattern in the NEST core stack,
  1044.             --      in the event of a subsequent NOUV.
  1045.             -- I take this to be of no importance.
  1046.
  1047.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- =+Qq
  1048.                the_Q_store(INS.Qq) := as_Q(as_word(the_Q_store(INS.Qq)) + pop);
  1049.                the_CPU_delta := the_CPU_delta + 5;
  1050.             elsif (INS.Qk and M_part_choice) /= 0 then       -- =+Mq
  1051.                the_Q_store(INS.Qq).M := KDF9.Q_part(Q_part_mask and
  1052.                                              (sign_extended(the_Q_store(INS.Qq).M) + pop));
  1053.                the_CPU_delta := the_CPU_delta + 5;
  1054.             elsif (INS.Qk and C_part_choice) /= 0 then       -- =+Cq
  1055.                the_Q_store(INS.Qq).C := KDF9.Q_part(Q_part_mask and
  1056.                                              (sign_extended(the_Q_store(INS.Qq).C) + pop));
  1057.                the_CPU_delta := the_CPU_delta + 6;
  1058.             elsif (INS.Qk and I_part_choice) /= 0 then       -- =+Iq
  1059.                the_Q_store(INS.Qq).I := KDF9.Q_part(Q_part_mask and
  1060.                                              (sign_extended(the_Q_store(INS.Qq).I) + pop));
  1061.                the_CPU_delta := the_CPU_delta + 7;
  1062.             else
  1063.                trap_illegal_instruction;
  1064.             end if;
  1065.             ensure_that_Q0_contains_zero(suspect => INS.Qq);
  1066.
  1067.          when SHA =>
  1068.             A := read_top;
  1069.             write_top(KDF9.word'(shift_arithmetic(A, shift_count)));
  1070.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1071.
  1072.          when SHAD =>
  1073.             AB := read_top;
  1074.             write_top(KDF9.pair'(shift_arithmetic(AB, shift_count)));
  1075.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1076.
  1077.          when MACC =>
  1078.             ensure_that_the_NEST_holds(at_least => 4);
  1079.             AB := pop;
  1080.             AB := AB.msw * AB.lsw;
  1081.             CD := read_top;
  1082.             write_top(CD + shift_arithmetic(AB, shift_count));
  1083.             the_CPU_delta := the_CPU_delta + 15 + shift_time(Natural(abs shift_count));
  1084.
  1085.          when SHL =>
  1086.             write_top(KDF9.word'(shift_logical(read_top, shift_count)));
  1087.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1088.
  1089.          when SHLD =>
  1090.             write_top(KDF9.pair'(shift_logical(read_top, shift_count)));
  1091.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1092.
  1093.          when SHC =>
  1094.             write_top(shift_circular(read_top, shift_count));
  1095.             the_CPU_delta := the_CPU_delta + 3 + shift_time(Natural(abs shift_count));
  1096.
  1097.          when TO_Kq =>
  1098.             fail_in_problem_program_state;
  1099.             case INS.Qq is
  1100.                when K0 =>
  1101.                   if read_top /= KDF9.word'(all_zero_bits) then
  1102.                      for w in all_zero_bits .. read_top mod 8 loop
  1103.                         POSIX.output_line("BLEEP!");
  1104.                      end loop;
  1105.                      delay 10.0;
  1106.                   end if;
  1107.                when K1 =>
  1108.                   set_K1_register(read_top);
  1109.                when K2 =>
  1110.                   set_K2_register(read_top);
  1111.                when K3 =>
  1112.                   set_K3_register(read_top);
  1113.                when others =>
  1114.                   trap_illegal_instruction;
  1115.             end case;
  1116.             the_CPU_delta := the_CPU_delta + 3;
  1117.
  1118.          when Kk =>
  1119.             fail_in_problem_program_state;
  1120.             ensure_that_the_NEST_has_room_for_a_result;
  1121.             case INS.Qk is
  1122.                when K4 =>
  1123.                   push(get_K4_operand);
  1124.                   the_RFIR := (others => False);
  1125.                when K5 =>
  1126.                   push(get_K5_operand);
  1127.                when K7 =>
  1128.                   push(get_K7_operand);
  1129.                when others =>
  1130.                   trap_illegal_instruction;
  1131.             end case;
  1132.             the_CPU_delta := the_CPU_delta + 3;
  1133.
  1134.          when LINK =>
  1135.             if the_CPU_state = Director_state and the_SJNS_depth = 0 then -- clear out JB
  1136.                push(KDF9.word'(all_zero_bits));
  1137.                the_SJNS_depth := 0 - 1;
  1138.             else
  1139.                ensure_that_the_NEST_has_room_for_a_result;
  1140.                ensure_that_the_SJNS_is_not_empty;
  1141.                push(as_word(KDF9.SJNS_link(KDF9.syllable_address'(pop))));
  1142.             end if;
  1143.             the_CPU_delta := the_CPU_delta + 4;
  1144.
  1145.          when TO_LINK =>
  1146.             ensure_that_the_SJNS_is_not_full;
  1147.             ensure_that_the_NEST_holds_an_operand;
  1148.             push(KDF9.syllable_address(as_link(pop)));
  1149.             the_CPU_delta := the_CPU_delta + 3;
  1150.
  1151.          when others =>
  1152.             do_an_IO_order;
  1153.
  1154.       end case;
  1155.    end do_a_two_syllable_order;
  1156.
  1157.    procedure do_a_jump_order is
  1158.       RA        : KDF9.syllable_address;
  1159.       A         : KDF9.word;
  1160.    begin
  1161.       fetching_normally := True;
  1162.
  1163.       case INS.compressed_opcode is
  1164.
  1165.          when Jr =>
  1166.             set_NIA_to_the_INS_target_address;
  1167.             the_CPU_delta := the_CPU_delta + 8;
  1168.
  1169.          when JSr =>
  1170.             ensure_that_the_SJNS_is_not_full;
  1171.             push(CIA);
  1172.             set_NIA_to_the_INS_target_address;
  1173.             the_CPU_delta := the_CPU_delta + 11;
  1174.
  1175.          when JrEQ =>
  1176.             ensure_that_the_NEST_holds_2_operands;
  1177.             A := pop;
  1178.             if A = read_top then
  1179.                set_NIA_to_the_INS_target_address;
  1180.                the_CPU_delta := the_CPU_delta + 12;
  1181.             else
  1182.                the_CPU_delta := the_CPU_delta + 5;
  1183.             end if;
  1184.
  1185.          when JrNE =>
  1186.             ensure_that_the_NEST_holds_2_operands;
  1187.             A := pop;
  1188.             if A /= read_top then
  1189.                set_NIA_to_the_INS_target_address;
  1190.                the_CPU_delta := the_CPU_delta + 12;
  1191.             else
  1192.                the_CPU_delta := the_CPU_delta + 5;
  1193.             end if;
  1194.
  1195.          when JrGTZ =>
  1196.             ensure_that_the_NEST_holds_an_operand;
  1197.             if resign(pop) > 0 then
  1198.                set_NIA_to_the_INS_target_address;
  1199.                the_CPU_delta := the_CPU_delta + 11;
  1200.             else
  1201.                the_CPU_delta := the_CPU_delta + 4;
  1202.             end if;
  1203.
  1204.          when JrLTZ =>
  1205.             ensure_that_the_NEST_holds_an_operand;
  1206.             A := pop;
  1207.             if resign(A) < 0 then
  1208.                set_NIA_to_the_INS_target_address;
  1209.                the_CPU_delta := the_CPU_delta + 11;
  1210.             else
  1211.                the_CPU_delta := the_CPU_delta + 4;
  1212.             end if;
  1213.
  1214.          when JrEQZ =>
  1215.             ensure_that_the_NEST_holds_an_operand;
  1216.              if pop = KDF9.word'(all_zero_bits) then
  1217.                set_NIA_to_the_INS_target_address;
  1218.                the_CPU_delta := the_CPU_delta + 11;
  1219.             else
  1220.                the_CPU_delta := the_CPU_delta + 4;
  1221.             end if;
  1222.
  1223.          when JrLEZ =>
  1224.             ensure_that_the_NEST_holds_an_operand;
  1225.             if resign(pop) <= 0 then
  1226.                set_NIA_to_the_INS_target_address;
  1227.                the_CPU_delta := the_CPU_delta + 11;
  1228.             else
  1229.                the_CPU_delta := the_CPU_delta + 4;
  1230.             end if;
  1231.
  1232.          when JrGEZ =>
  1233.             ensure_that_the_NEST_holds_an_operand;
  1234.             if resign(pop) >= 0 then
  1235.                set_NIA_to_the_INS_target_address;
  1236.                the_CPU_delta := the_CPU_delta + 11;
  1237.             else
  1238.                the_CPU_delta := the_CPU_delta + 4;
  1239.             end if;
  1240.
  1241.          when JrNEZ =>
  1242.             ensure_that_the_NEST_holds_an_operand;
  1243.             if pop /= KDF9.word'(all_zero_bits) then
  1244.                set_NIA_to_the_INS_target_address;
  1245.                the_CPU_delta := the_CPU_delta + 11;
  1246.             else
  1247.                the_CPU_delta := the_CPU_delta + 4;
  1248.             end if;
  1249.
  1250.          when JrV =>
  1251.             if the_V_bit_is_set then
  1252.                the_V_bit_is_set := False;
  1253.                set_NIA_to_the_INS_target_address;
  1254.                the_CPU_delta := the_CPU_delta + 10;
  1255.             else
  1256.                the_CPU_delta := the_CPU_delta + 3;
  1257.             end if;
  1258.
  1259.          when JrNV =>
  1260.             if the_V_bit_is_set then
  1261.                the_V_bit_is_set := False;
  1262.                the_CPU_delta := the_CPU_delta + 3;
  1263.             else
  1264.                set_NIA_to_the_INS_target_address;
  1265.                the_CPU_delta := the_CPU_delta + 10;
  1266.             end if;
  1267.
  1268.          when JrEN =>
  1269.             the_trace_operand := KDF9.word(the_NEST_depth);
  1270.             if the_NEST_depth = 0 then
  1271.                set_NIA_to_the_INS_target_address;
  1272.                the_CPU_delta := the_CPU_delta + 10;
  1273.             else
  1274.                the_CPU_delta := the_CPU_delta + 3;
  1275.             end if;
  1276.
  1277.          when JrNEN =>
  1278.             the_trace_operand := KDF9.word(the_NEST_depth);
  1279.             if the_NEST_depth /= 0 then
  1280.                set_NIA_to_the_INS_target_address;
  1281.                the_CPU_delta := the_CPU_delta + 10;
  1282.             else
  1283.                the_CPU_delta := the_CPU_delta + 3;
  1284.             end if;
  1285.
  1286.          when JrEJ =>
  1287.             the_trace_operand := KDF9.word(the_SJNS_depth);
  1288.             if the_SJNS_depth = 0 then
  1289.                set_NIA_to_the_INS_target_address;
  1290.                the_CPU_delta := the_CPU_delta + 10;
  1291.             end if;
  1292.             the_CPU_delta := the_CPU_delta + 3;
  1293.
  1294.          when JrNEJ =>
  1295.             the_trace_operand := KDF9.word(the_SJNS_depth);
  1296.             if the_SJNS_depth /= 0 then
  1297.                set_NIA_to_the_INS_target_address;
  1298.                the_CPU_delta := the_CPU_delta + 10;
  1299.             end if;
  1300.             the_CPU_delta := the_CPU_delta + 3;
  1301.
  1302.          when JrTR =>
  1303.             if the_T_bit_is_set then
  1304.                the_T_bit_is_set := False;
  1305.                set_NIA_to_the_INS_target_address;
  1306.                the_CPU_delta := the_CPU_delta + 10;
  1307.             else
  1308.                the_CPU_delta := the_CPU_delta + 3;
  1309.             end if;
  1310.
  1311.          when JrNTR =>
  1312.             if the_T_bit_is_set then
  1313.                the_T_bit_is_set := False;
  1314.                the_CPU_delta := the_CPU_delta + 3;
  1315.             else
  1316.                set_NIA_to_the_INS_target_address;
  1317.                the_CPU_delta := the_CPU_delta + 10;
  1318.             end if;
  1319.
  1320.          when EXIT_n =>
  1321.             ensure_that_the_SJNS_is_not_empty;
  1322.             RA := pop;
  1323.             if INS.target.syllable_index = 3 then  -- c.f. decode_a_jump_order.
  1324.                increment_by_3(RA);
  1325.             end if;
  1326.             RA.code_address := RA.code_address+INS.target.code_address;
  1327.             set_NIA_to(RA);
  1328.             the_CPU_delta := the_CPU_delta + 12 + KDF9.us(INS.target.syllable_index mod 2);
  1329.
  1330.          when EXITD =>
  1331.             fail_in_problem_program_state;
  1332.             if the_SJNS_depth = 0 then
  1333.                -- This indicates a serious failure in Director; best to abandon it at once.
  1334.                trap_illegal_instruction("empty SJNS in Director");
  1335.             end if;
  1336.             RA := pop;
  1337.             the_CPU_delta := the_CPU_delta + 11;
  1338.             return_from_Director_to(RA);
  1339.
  1340.          when JrCqZ =>
  1341.             if the_Q_store(INS.Qq).C = 0 then
  1342.                set_NIA_to_the_INS_target_address;
  1343.                the_CPU_delta := the_CPU_delta + 11;
  1344.             else
  1345.                the_CPU_delta := the_CPU_delta + 4;
  1346.             end if;
  1347.
  1348.          when JrCqNZ =>
  1349.             if the_Q_store(INS.Qq).C /= 0 then
  1350.                set_NIA_to_the_INS_target_address;
  1351.                the_CPU_delta := the_CPU_delta + 11;
  1352.             else
  1353.                the_CPU_delta := the_CPU_delta + 4;
  1354.             end if;
  1355.
  1356.          when OS_OUT =>
  1357.             the_CPU_delta := the_CPU_delta + 13;
  1358.             ensure_that_the_SJNS_is_not_full;
  1359.             A := (if the_NEST_depth = 0 then 0 else read_top);
  1360.             if the_execution_mode = boot_mode then
  1361.                effect_interrupt(caused_by_OUT, A'Image);
  1362.                -- We get here only in Director state, when the OUT does not interrupt.
  1363.                -- Arguably, this should be notified as an error.
  1364.                return; -- OUT has the effect of a no-op in Director state.
  1365.             end if;
  1366.             -- Emulate a subset of the appropriate Director's API.
  1367.             if A < 100 then
  1368.                do_a_TSD_OUT(OUT_number => A);
  1369.             elsif A < 200 then
  1370.                do_an_EGDON_OUT(OUT_number => A);
  1371.             else
  1372.                trap_failing_OUT(A, "is unknown, or not yet implemented");
  1373.             end if;
  1374.
  1375.          when others =>
  1376.             trap_illegal_instruction;
  1377.
  1378.       end case;
  1379.    end do_a_jump_order;
  1380.
  1381.    procedure do_a_data_access_order is
  1382.    begin
  1383.       case INS.compressed_opcode is
  1384.
  1385.          when EaMq =>
  1386.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1387.             check_address_and_lockout(the_trace_address);
  1388.             ensure_that_the_NEST_has_room_for_a_result;
  1389.             the_trace_operand := fetch_word(the_trace_address);
  1390.             push(the_trace_operand);
  1391.             the_CPU_delta := the_CPU_delta + 6;
  1392.
  1393.          when TO_EaMq =>
  1394.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1395.             check_address_and_lockout(the_trace_address);
  1396.             ensure_that_the_NEST_holds_an_operand;
  1397.             the_trace_operand := pop;
  1398.             store_word(the_trace_operand, the_trace_address);
  1399.             the_CPU_delta := the_CPU_delta + 6;
  1400.
  1401.          when EaMqQ =>
  1402.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1403.             check_address_and_lockout(the_trace_address);
  1404.             ensure_that_the_NEST_has_room_for_a_result;
  1405.             the_trace_operand := fetch_word(the_trace_address);
  1406.             push(the_trace_operand);
  1407.             auto_increment;
  1408.             the_CPU_delta := the_CPU_delta + 7;
  1409.
  1410.          when TO_EaMqQ =>
  1411.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1412.             check_address_and_lockout(the_trace_address);
  1413.             ensure_that_the_NEST_holds_an_operand;
  1414.             the_trace_operand := pop;
  1415.             store_word(the_trace_operand, the_trace_address);
  1416.             auto_increment;
  1417.             the_CPU_delta := the_CPU_delta + 7;
  1418.
  1419.          when SET =>
  1420.             ensure_that_the_NEST_has_room_for_a_result;
  1421.             the_trace_operand := sign_extended(INS.operand);
  1422.             push(the_trace_operand);
  1423.             the_CPU_delta := the_CPU_delta + 4;
  1424.
  1425.          when others =>
  1426.             trap_illegal_instruction;
  1427.
  1428.       end case;
  1429.    end do_a_data_access_order;
  1430.
  1431.    procedure update_the_virtual_clocks
  1432.       with Inline;
  1433.
  1434.    procedure update_the_virtual_clocks is
  1435.    begin
  1436.       the_CPU_time := the_CPU_time + the_CPU_delta;
  1437.       the_elapsed_time := the_elapsed_time + the_CPU_delta;
  1438.       if the_CPU_time > the_elapsed_time then
  1439.          the_elapsed_time := the_CPU_time;
  1440.       end if;
  1441.       ICR := ICR + 1;
  1442.    end update_the_virtual_clocks;
  1443.
  1444.    procedure do_a_fast_time_slice is
  1445.    begin
  1446.
  1447.       if break_in.has_been_requested then
  1448.          break_in.handler;
  1449.       end if;
  1450.
  1451.       for i in 1 .. time_slice loop
  1452.
  1453.          the_CPU_delta := 0;
  1454.
  1455.          process_syllable_0_of_INS;
  1456.          case INS.kind is
  1457.             when one_syllable_order =>
  1458.                do_a_one_syllable_order;
  1459.             when two_syllable_order =>
  1460.                process_syllable_1_of_INS;
  1461.                do_a_two_syllable_order;
  1462.             when normal_jump_order =>
  1463.                process_syllables_1_and_2_of_a_jump_order;
  1464.                do_a_jump_order;
  1465.             when data_access_order =>
  1466.                process_syllables_1_and_2_of_a_data_access_order;
  1467.                do_a_data_access_order;
  1468.          end case;
  1469.
  1470.          update_the_virtual_clocks;
  1471.          check_for_a_clock_interrupt;
  1472.          if the_elapsed_time > the_next_interrupt_time then
  1473.             act_on_pending_interrupts;
  1474.          end if;
  1475.
  1476.       end loop;
  1477.
  1478.    exception
  1479.
  1480.       when program_exit =>
  1481.          complete_all_extant_transfers;
  1482.          update_the_virtual_clocks;
  1483.          synchronize_the_real_and_virtual_times;
  1484.          raise;
  1485.
  1486.       when OUT_2_restart =>
  1487.          complete_all_extant_transfers;
  1488.          update_the_virtual_clocks;
  1489.          synchronize_the_real_and_virtual_times;
  1490.          complete_TSD_OUT_2;
  1491.
  1492.    end do_a_fast_time_slice;
  1493.
  1494.    procedure do_a_traced_instruction_cycle is
  1495.       use tracing.order_flags;
  1496.
  1497.       procedure finalize_the_traced_instruction_execution is
  1498.       begin
  1499.          update_the_virtual_clocks;
  1500.          synchronize_the_real_and_virtual_times;
  1501.
  1502.          if ICR in low_count .. high_count            and then
  1503.                NIA_word_number in low_bound .. high_bound then
  1504.             take_note_of(the_trace_operand);
  1505.             if the_signature_is_enabled then
  1506.                update_the_digital_signature;
  1507.             end if;
  1508.             if histogramming_is_enabled then
  1509.                add_INS_to_the_histogram;
  1510.                add_CIA_to_the_profile;
  1511.             end if;
  1512.             if the_external_trace_is_enabled then
  1513.                log_to_external_trace;
  1514.             end if;
  1515.             case INS.kind is
  1516.                when two_syllable_order =>
  1517.                   act_on_any_two_syllable_order_watchpoints;
  1518.                when data_access_order =>
  1519.                   act_on_any_data_access_order_watchpoints;
  1520.                when others =>
  1521.                   null;
  1522.             end case;
  1523.          end if;
  1524.       end finalize_the_traced_instruction_execution;
  1525.
  1526.    begin  -- do_a_traced_instruction_cycle
  1527.
  1528.       if break_in.has_been_requested then
  1529.          break_in.handler;
  1530.       end if;
  1531.
  1532.       the_trace_operand := 0;
  1533.       the_trace_address := 0;
  1534.       the_CPU_delta := 0;
  1535.
  1536.       process_syllable_0_of_INS;
  1537.
  1538.       case INS.kind is
  1539.          when one_syllable_order =>
  1540.             preview_a_one_syllable_order;
  1541.                do_a_one_syllable_order;
  1542.             look_back_at_a_one_syllable_order;
  1543.          when two_syllable_order =>
  1544.             process_syllable_1_of_INS;
  1545.             preview_a_two_syllable_order;
  1546.                do_a_two_syllable_order;
  1547.             look_back_at_a_two_syllable_order;
  1548.          when normal_jump_order =>
  1549.             process_syllables_1_and_2_of_a_jump_order;
  1550.             preview_a_jump_order;
  1551.                do_a_jump_order;
  1552.             look_back_at_a_jump_order;
  1553.          when data_access_order =>
  1554.             process_syllables_1_and_2_of_a_data_access_order;
  1555.             preview_a_data_access_order;
  1556.                do_a_data_access_order;
  1557.             look_back_at_a_data_access_order;
  1558.       end case;
  1559.
  1560.       finalize_the_traced_instruction_execution;
  1561.
  1562.       if ICR >= time_limit then
  1563.          raise time_expired;
  1564.       end if;
  1565.
  1566.       if (breakpoints/NIA_word_number        and then
  1567.              ICR in low_count .. high_count)  or else
  1568.                 the_diagnostic_mode = pause_mode then
  1569.          handle_breakpoint;
  1570.       end if;
  1571.
  1572.       check_for_a_clock_interrupt;
  1573.       if the_elapsed_time > the_next_interrupt_time then
  1574.          act_on_pending_interrupts;
  1575.       end if;
  1576.
  1577.    exception
  1578.
  1579.       when program_exit =>
  1580.          case INS.kind is
  1581.             when one_syllable_order =>
  1582.                look_back_at_a_one_syllable_order;
  1583.             when two_syllable_order =>
  1584.                look_back_at_a_two_syllable_order;
  1585.             when normal_jump_order =>
  1586.                look_back_at_a_jump_order;
  1587.             when data_access_order =>
  1588.                look_back_at_a_data_access_order;
  1589.          end case;
  1590.          complete_all_extant_transfers;
  1591.          finalize_the_traced_instruction_execution;
  1592.          raise;
  1593.
  1594.       when OUT_2_restart =>
  1595.          complete_all_extant_transfers;
  1596.          finalize_the_traced_instruction_execution;
  1597.          complete_TSD_OUT_2;
  1598.
  1599.    end do_a_traced_instruction_cycle;
  1600.
  1601. end KDF9.microcode;

Compiling: ../Source/kdf9-microcode.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- KDF9 ISP emulation - CPU microcode routines.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.microcode is
    18.
    19.    procedure do_a_fast_time_slice;
    20.
    21.    procedure do_a_traced_instruction_cycle;
    22.
    23. end KDF9.microcode;

 1601 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-absent.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Handle attempted usage of a buffer with No Device attached.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.absent is
    18.
    19.    procedure disavow (the_device  : in out absent.device;
    20.                       Q_operand   : in KDF9.Q_register;
    21.                       set_offline : in Boolean) is
    22.       pragma Unreferenced(Q_operand);
    23.       pragma Unreferenced(set_offline);
    24.    begin
    25.       trap_operator_error("there is no device on buffer #" & oct_of(the_device.number, 2));
    26.    end disavow;
    27.
    28.    overriding
    29.    procedure PIA (the_device  : in out absent.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean) is
    32.    begin disavow(the_device, Q_operand, set_offline); end PIA;
    33.
    34.    overriding
    35.    procedure PIB (the_device  : in out absent.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean) is
    38.    begin disavow(the_device, Q_operand, set_offline); end PIB;
    39.
    40.    overriding
    41.    procedure PIC (the_device  : in out absent.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean) is
    44.    begin disavow(the_device, Q_operand, set_offline); end PIC;
    45.
    46.    overriding
    47.    procedure PID (the_device  : in out absent.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean) is
    50.    begin disavow(the_device, Q_operand, set_offline); end PID;
    51.
    52.    overriding
    53.    procedure PIE (the_device  : in out absent.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean) is
    56.    begin disavow(the_device, Q_operand, set_offline); end PIE;
    57.
    58.    overriding
    59.    procedure PIF (the_device  : in out absent.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean) is
    62.    begin disavow(the_device, Q_operand, set_offline); end PIF;
    63.
    64.    overriding
    65.    procedure PIG (the_device  : in out absent.device;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean) is
    68.    begin disavow(the_device, Q_operand, set_offline); end PIG;
    69.
    70.    overriding
    71.    procedure PIH (the_device  : in out absent.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean) is
    74.    begin disavow(the_device, Q_operand, set_offline); end PIH;
    75.
    76.    overriding
    77.    procedure PMA (the_device  : in out absent.device;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean) is
    80.    begin disavow(the_device, Q_operand, set_offline); end PMA;
    81.
    82.    overriding
    83.    procedure PMB (the_device  : in out absent.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean) is
    86.    begin disavow(the_device, Q_operand, set_offline); end PMB;
    87.
    88.    overriding
    89.    procedure PMC (the_device  : in out absent.device;
    90.                   Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean) is
    92.    begin disavow(the_device, Q_operand, set_offline); end PMC;
    93.    overriding
    94.    procedure PMD (the_device  : in out absent.device;
    95.                   Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean) is
    97.    begin disavow(the_device, Q_operand, set_offline); end PMD;
    98.
    99.    overriding
   100.    procedure PME (the_device  : in out absent.device;
   101.                   Q_operand   : in KDF9.Q_register;
   102.                   set_offline : in Boolean) is
   103.    begin disavow(the_device, Q_operand, set_offline); end PME;
   104.
   105.    overriding
   106.    procedure PMF (the_device  : in out absent.device;
   107.                   Q_operand   : in KDF9.Q_register;
   108.                   set_offline : in Boolean) is
   109.    begin disavow(the_device, Q_operand, set_offline); end PMF;
   110.
   111.
   112.    overriding
   113.    procedure PMG (the_device  : in out absent.device;
   114.                   Q_operand   : in KDF9.Q_register;
   115.                   set_offline : in Boolean) is
   116.    begin disavow(the_device, Q_operand, set_offline); end PMG;
   117.
   118.    overriding
   119.    procedure PMK (the_device  : in out absent.device;
   120.                   Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean) is
   122.    begin disavow(the_device, Q_operand, set_offline); end PMK;
   123.
   124.    overriding
   125.    procedure PML (the_device  : in out absent.device;
   126.                   Q_operand   : in KDF9.Q_register;
   127.                   set_offline : in Boolean) is
   128.    begin disavow(the_device, Q_operand, set_offline); end PML;
   129.
   130.    overriding
   131.    procedure POA (the_device  : in out absent.device;
   132.                   Q_operand   : in KDF9.Q_register;
   133.                   set_offline : in Boolean) is
   134.    begin disavow(the_device, Q_operand, set_offline); end POA;
   135.
   136.    overriding
   137.    procedure POB (the_device  : in out absent.device;
   138.                   Q_operand   : in KDF9.Q_register;
   139.                   set_offline : in Boolean) is
   140.    begin disavow(the_device, Q_operand, set_offline); end POB;
   141.
   142.    overriding
   143.    procedure POC (the_device  : in out absent.device;
   144.                   Q_operand   : in KDF9.Q_register;
   145.                   set_offline : in Boolean) is
   146.    begin disavow(the_device, Q_operand, set_offline); end POC;
   147.
   148.    overriding
   149.    procedure POD (the_device  : in out absent.device;
   150.                   Q_operand   : in KDF9.Q_register;
   151.                   set_offline : in Boolean) is
   152.    begin disavow(the_device, Q_operand, set_offline); end POD;
   153.
   154.    overriding
   155.    procedure POE (the_device  : in out absent.device;
   156.                   Q_operand   : in KDF9.Q_register;
   157.                   set_offline : in Boolean) is
   158.    begin disavow(the_device, Q_operand, set_offline); end POE;
   159.
   160.    overriding
   161.    procedure POF (the_device  : in out absent.device;
   162.                   Q_operand   : in KDF9.Q_register;
   163.                   set_offline : in Boolean) is
   164.    begin disavow(the_device, Q_operand, set_offline); end POF;
   165.
   166.    overriding
   167.    procedure POG (the_device  : in out absent.device;
   168.                   Q_operand   : in KDF9.Q_register;
   169.                   set_offline : in Boolean) is
   170.    begin disavow(the_device, Q_operand, set_offline); end POG;
   171.
   172.    overriding
   173.    procedure POH (the_device  : in out absent.device;
   174.                   Q_operand   : in KDF9.Q_register;
   175.                   set_offline : in Boolean) is
   176.    begin disavow(the_device, Q_operand, set_offline); end POH;
   177.
   178.    overriding
   179.    procedure POK (the_device  : in out absent.device;
   180.                   Q_operand   : in KDF9.Q_register;
   181.                   set_offline : in Boolean) is
   182.    begin disavow(the_device, Q_operand, set_offline); end POK;
   183.
   184.    overriding
   185.    procedure POL (the_device  : in out absent.device;
   186.                   Q_operand   : in KDF9.Q_register;
   187.                   set_offline : in Boolean) is
   188.    begin disavow(the_device, Q_operand, set_offline); end POL;
   189.
   190.    overriding
   191.    procedure Initialize (the_device : in out absent.device) is
   192.    begin
   193.       install(the_device);
   194.    end Initialize;
   195.
   196.    type AD_access is access absent.device;
   197.    AD_list : array (IOC.unit_number range 0..14) of AD_access with Warnings => Off;
   198.
   199.     -- This cannot overflow, because there must be at least 2 non-AD buffers: FW0 and TR0.
   200.    unit : IOC.unit_number := 0;
   201.
   202.    procedure enable (b : in KDF9.buffer_number) is
   203.    begin
   204.       AD_list(unit) := new absent.device(number => b, unit => unit);
   205.        unit := unit + 1;
   206.    end enable;
   207.
   208. end IOC.absent;
   209.

Compiling: ../Source/ioc-absent.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Handle attempted usage of a buffer with No Device attached.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.absent is
    18.
    19.    type device is new IOC.device with null record;
    20.
    21.    -- All the operations of an absent device terminate the run.
    22.
    23.    overriding
    24.    procedure PIA (the_device  : in out absent.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    overriding
    29.    procedure PIB (the_device  : in out absent.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    overriding
    34.    procedure PIC (the_device  : in out absent.device;
    35.                   Q_operand   : in KDF9.Q_register;
    36.                   set_offline : in Boolean);
    37.
    38.    overriding
    39.    procedure PID (the_device  : in out absent.device;
    40.                   Q_operand   : in KDF9.Q_register;
    41.                   set_offline : in Boolean);
    42.
    43.    overriding
    44.    procedure PIE (the_device  : in out absent.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    overriding
    49.    procedure PIF (the_device  : in out absent.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    overriding
    54.    procedure PIG (the_device  : in out absent.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    overriding
    59.    procedure PIH (the_device  : in out absent.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    overriding
    64.    procedure PMA (the_device  : in out absent.device;
    65.                   Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    overriding
    69.    procedure PMB (the_device  : in out absent.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean);
    72.
    73.    overriding
    74.    procedure PMC (the_device  : in out absent.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.    overriding
    78.    procedure PMD (the_device  : in out absent.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean);
    81.
    82.    overriding
    83.    procedure PME (the_device  : in out absent.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    overriding
    88.    procedure PMF (the_device  : in out absent.device;
    89.                   Q_operand   : in KDF9.Q_register;
    90.                   set_offline : in Boolean);
    91.
    92.    overriding
    93.    procedure PMG (the_device  : in out absent.device;
    94.                   Q_operand   : in KDF9.Q_register;
    95.                   set_offline : in Boolean);
    96.
    97.    overriding
    98.    procedure PMK (the_device  : in out absent.device;
    99.                   Q_operand   : in KDF9.Q_register;
   100.                   set_offline : in Boolean);
   101.
   102.    overriding
   103.    procedure PML (the_device  : in out absent.device;
   104.                   Q_operand   : in KDF9.Q_register;
   105.                   set_offline : in Boolean);
   106.
   107.    overriding
   108.    procedure POA (the_device  : in out absent.device;
   109.                   Q_operand   : in KDF9.Q_register;
   110.                   set_offline : in Boolean);
   111.
   112.    overriding
   113.    procedure POB (the_device  : in out absent.device;
   114.                   Q_operand   : in KDF9.Q_register;
   115.                   set_offline : in Boolean);
   116.
   117.    overriding
   118.    procedure POC (the_device  : in out absent.device;
   119.                   Q_operand   : in KDF9.Q_register;
   120.                   set_offline : in Boolean);
   121.
   122.    overriding
   123.    procedure POD (the_device  : in out absent.device;
   124.                   Q_operand   : in KDF9.Q_register;
   125.                   set_offline : in Boolean);
   126.
   127.    overriding
   128.    procedure POE (the_device  : in out absent.device;
   129.                   Q_operand   : in KDF9.Q_register;
   130.                   set_offline : in Boolean);
   131.
   132.    overriding
   133.    procedure POF (the_device  : in out absent.device;
   134.                   Q_operand   : in KDF9.Q_register;
   135.                   set_offline : in Boolean);
   136.
   137.    overriding
   138.    procedure POG (the_device  : in out absent.device;
   139.                   Q_operand   : in KDF9.Q_register;
   140.                   set_offline : in Boolean);
   141.
   142.    overriding
   143.    procedure POH (the_device  : in out absent.device;
   144.                   Q_operand   : in KDF9.Q_register;
   145.                   set_offline : in Boolean);
   146.
   147.    overriding
   148.    procedure POK (the_device  : in out absent.device;
   149.                   Q_operand   : in KDF9.Q_register;
   150.                   set_offline : in Boolean);
   151.
   152.    overriding
   153.    procedure POL (the_device  : in out absent.device;
   154.                   Q_operand   : in KDF9.Q_register;
   155.                   set_offline : in Boolean);
   156.
   157.    -- Register the absence of a device in case of future attempted access to buffer b.
   158.    procedure enable (b : in KDF9.buffer_number);
   159.
   160. private
   161.
   162.    overriding
   163.    procedure Initialize (the_device : in out absent.device);
   164.
   165.    overriding
   166.    function is_open (the_device : absent.device)
   167.    return Boolean
   168.    is (False);
   169.
   170.    overriding
   171.    function kind (the_device : absent.device)
   172.    return IOC.device_kind
   173.    is (AD_kind);
   174.
   175.    overriding
   176.    function quantum (the_device : absent.device)
   177.    return KDF9.us
   178.    is (0);
   179.
   180.    overriding
   181.    procedure add_in_the_IO_CPU_time (the_device  : in absent.device;
   182.                                      bytes_moved : in KDF9.word)
   183.    is null;
   184.
   185. end IOC.absent;

 209 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/state_display.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Provide the comprehensive machine-state display panel KDF9 never had.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Latin_1;
    18. with Ada.Exceptions;
    19. with Ada.Long_Float_Text_IO;
    20. --
    21. with disassembly;
    22. with exceptions;
    23. with formatting;
    24. with generic_sets;
    25. with HCI;
    26. with IOC;
    27. with IOC.fast.DR;
    28. with IOC.fast.FD;
    29. with KDF9_char_sets;
    30. with KDF9.CPU;
    31. with KDF9.decoding;
    32. with KDF9.PHU_store;
    33. with KDF9.store;
    34. with logging.file;
    35. with settings;
    36. with disassembly.symbols;
    37. with tracing;
    38.
    39. with IOC.diagnostics;
    40.
    41. use  Ada.Characters.Latin_1;
    42. use  Ada.Exceptions;
    43. use  Ada.Long_Float_Text_IO;
    44. --
    45. use  disassembly;
    46. use  exceptions;
    47. use  formatting;
    48. use  HCI;
    49. use  IOC;
    50. use  IOC.fast.DR;
    51. use  IOC.fast.FD;
    52. use  KDF9_char_sets;
    53. use  KDF9.CPU;
    54. use  KDF9.decoding;
    55. use  KDF9.PHU_store;
    56. use  KDF9.store;
    57. use  logging.file;
    58. use  settings;
    59. use  disassembly.symbols;
    60. use  tracing;
    61.
    62. package body state_display is
    63.
    64.    procedure show_IM_parts (the_Q_register : in KDF9.Q_register;
    65.                             width          : in Positive := 8) is
    66.    begin
    67.       log(
    68.           "/"
    69.         & just_right("#" & oct_of(the_Q_register.I, width-2), width)
    70.         & "/"
    71.         & just_right("#" & oct_of(the_Q_register.M, width-2), width)
    72.          );
    73.    end show_IM_parts;
    74.
    75.    procedure show_IO_register (the_Q_register : in KDF9.Q_register;
    76.                                width          : in Positive := 8;
    77.                                for_DR,
    78.                                for_FD,
    79.                                for_FH,
    80.                                for_seek,
    81.                                for_OUT         : in Boolean  := False) is
    82.    begin
    83.       log('Q');
    84.       if for_FD then
    85.          log(just_right(as_FD_command(the_Q_register, for_FD and for_seek, for_FD and for_FH), width));
    86.       elsif for_DR then
    87.          log(just_right(as_DR_command(the_Q_register, for_OUT), width));
    88.       else
    89.          log(just_right("#" & oct_of(the_Q_register.C, width-2), width));
    90.       end if;
    91.       show_IM_parts(the_Q_register, width);
    92.    end show_IO_register;
    93.
    94.    procedure show_Q_register (the_Q_register : in KDF9.Q_register;
    95.                               width          : in Positive := 8) is
    96.    begin
    97.       log('Q' & just_right("#" & oct_of(the_Q_register.C, width-2), width));
    98.       show_IM_parts(the_Q_register, width);
    99.    end show_Q_register;
   100.
   101.    procedure show_Q_in_decimal (the_Q_register : in KDF9.Q_register;
   102.                                 width          : in Positive := 7) is
   103.    begin
   104.       log(
   105.           'Q'
   106.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.C)), width)
   107.         & "/"
   108.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.I)), width)
   109.         & "/"
   110.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.M)), width)
   111.          );
   112.    end show_Q_in_decimal;
   113.
   114.    procedure show_in_syllables_form (the_word : in KDF9.word) is
   115.       word : KDF9.word := the_word;
   116.       syllable : KDF9.syllable;
   117.    begin
   118.       for b in 0 .. 5 loop
   119.          word := rotate_word_left(word, 8);
   120.          syllable := KDF9.syllable(word and 8#377#);
   121.          log("#" & just_right(oct_of(syllable), 3) & " ");
   122.       end loop;
   123.    end show_in_syllables_form;
   124.
   125.    procedure show_as_glyphs (the_word : in KDF9.word) is
   126.    begin
   127.       log("«" & glyphs_for(the_word) & "»");
   128.    end show_as_glyphs;
   129.
   130.    procedure log_padded_string (text  : in String;
   131.                                 width : in Positive := 1) is
   132.       pad_width   : constant Natural := Integer'Max (0, width - text'Length);
   133.       padding     : constant String (1 .. pad_width) := (others => ' ');
   134.       padded_text : constant String := padding & text;
   135.    begin
   136.       log(padded_text);
   137.    end log_padded_string;
   138.
   139.    procedure log_octal (number : in KDF9.field_of_16_bits;
   140.                         width  : in Positive := 1) is
   141.    begin
   142.       log_padded_string("#" & oct_of(number), width);
   143.    end log_octal;
   144.
   145.    procedure log_octal (number : in KDF9.word;
   146.                         width  : in Positive := 1) is
   147.    begin
   148.       log_padded_string("#" & oct_of(number), width);
   149.    end log_octal;
   150.
   151.   procedure show_in_various_formats (the_word : in KDF9.word;
   152.                                      column   : in Positive := 5) is
   153.       image : String(1 .. 21);
   154.    begin
   155.       log_octal(the_word);
   156.       log(" = " & just_right(trimmed(CPU.signed'Image(resign(the_word))), 16) & " = ");
   157.       Put(image, host_float(CPU.f48(the_word)), Aft => 12, Exp => 2);
   158.       log(trimmed(image) & " = ");
   159.       log(as_fraction(the_word)'Image);
   160.       log_new_line;
   161.       tab_log_to(column);
   162.       log(" = ");
   163.       show_Q_register(as_Q(the_word));
   164.       log("   = ");
   165.       show_Q_in_decimal(as_Q(the_word));
   166.       log_new_line;
   167.       tab_log_to(column);
   168.       log(" = ");
   169.       show_in_syllables_form(the_word);
   170.       log("= ");
   171.       show_as_glyphs(the_word);
   172.    end show_in_various_formats;
   173.
   174.    procedure show_progress is
   175.
   176.       function readable (t : KDF9.us)
   177.       return String is
   178.          t_plus_5E2 : constant KDF9.us := (t + 5E2)/ 1E3;
   179.          t_plus_5E5 : constant KDF9.us := (t + 5E5)/ 1E6;
   180.       begin
   181.          return (if t < 1E3 then
   182.                     ""
   183.               elsif t < 1E6 then
   184.                     " about" & t_plus_5E2'Image & " ms"
   185.               else  " about" & t_plus_5E5'Image & " sec" );
   186.       end readable;
   187.
   188.       CPU : constant String := " KDF9 us  (RAN)" & readable(the_CPU_time);
   189.       EL  : constant String := " KDF9 us  (EL) " & readable(the_clock_time);
   190.
   191.    begin
   192.       log_line("ORDERS:     " & just_right(ICR'Image, 10) & " executed (ICR)");
   193.       log_line("CPU TIME:   " & just_right(the_CPU_time'Image, 10) & CPU);
   194.       log_line("CLOCK TIME: " & just_right(KDF9.us'Image(the_clock_time), 10) & EL);
   195.    end show_progress;
   196.
   197.    slot_name : constant array (KDF9.context) of String(1..1)  := ("P", "Q", "R", "S");
   198.
   199.    procedure show_Director_registers is
   200.       interval : constant KDF9.us := the_clock_time - the_last_K4_time;
   201.    begin
   202.       log_line("The CPU is in " & the_CPU_state'Image);
   203.       log_line("CONTEXT:  " & slot_name(the_context));
   204.       log_line("PRIORITY: " & just_right(CPL'Image, 1));
   205.       log_line("BA:       " & just_right("#" & oct_of(BA), 6));
   206.       log_line("NOL:      " & just_right("#" & oct_of(NOL), 6));
   207.       log("CPDAR:    ");
   208.       for i in KDF9.buffer_number loop
   209.          log(if the_CPDAR(i) then device_name_of(buffer(i).all) & " " else "");
   210.       end loop;
   211.       log_new_line;
   212.       log_new_line;
   213.       log_line("PHU stores:");
   214.       for p in KDF9.priority loop
   215.          log("PHU" & p'Image & " is ");
   216.          if PHU(p).is_held_up then
   217.             if PHU(p).blockage.reason = buffer_busy then
   218.                log("waiting for " & device_name_of(IOC.device_number(PHU(p).blockage.buffer_nr)));
   219.                log(" on buffer #" & oct_of(PHU(p).blockage.buffer_nr, 2));
   220.                if PHU(p).blockage.by_INTQq then
   221.                   log(", because of INTQq");
   222.                end if;
   223.             else
   224.                log("locked out of group" & KDF9.store.group_address'Image(PHU(p).blockage.group_nr));
   225.             end if;
   226.          else
   227.             log("idle");
   228.          end if;
   229.          log_new_line;
   230.       end loop;
   231.       log_new_line;
   232.       log("RFIR: ");
   233.       if the_RFIR(caused_by_PR)     then log("PR, ");    end if;
   234.       if the_RFIR(caused_by_FLEX)   then log("FLEX, ");  end if;
   235.       if the_RFIR(caused_by_LIV)    then log("LIV, ");   end if;
   236.       if the_RFIR(caused_by_NOUV)   then log("NOUV, ");  end if;
   237.       if the_RFIR(caused_by_EDT)    then log("EDT, ");   end if;
   238.       if the_RFIR(caused_by_OUT)    then log("OUT, ");   end if;
   239.       if the_RFIR(caused_by_LOV)    then log("LOV, ");   end if;
   240.       if the_RFIR(caused_by_RESET)  then log("RESET, "); end if;
   241.       if interval >= 2**20          then log("CLOCK, "); end if;
   242.       log_line(trimmed(KDF9.us'Image(interval/32*32)) & " KDF9 us since last CLOCK");
   243.       log_new_line;
   244.    end show_Director_registers;
   245.
   246.    procedure show_V_and_T is
   247.    begin
   248.       if the_V_bit_is_set or the_T_bit_is_set then
   249.          log_new_line;
   250.          if the_V_bit_is_set then
   251.             log("V is set. ");
   252.          else
   253.             log("V is clear. ");
   254.          end if;
   255.          if the_T_bit_is_set then
   256.             log("T is set. ");
   257.          else
   258.             log("T is clear. ");
   259.          end if;
   260.          log_new_line;
   261.       end if;
   262.    end show_V_and_T;
   263.
   264.    procedure show_NEST is
   265.    begin
   266.       if the_NEST_depth = 0 then
   267.          log_line("The NEST is empty.");
   268.          return;
   269.       else
   270.          log_line("NEST:");
   271.          for i in reverse KDF9.NEST_depth loop
   272.             if i < the_NEST_depth then
   273.                log(just_right("N" & trimmed(KDF9.NEST_depth'Image(the_NEST_depth-i)), 3) & ": ");
   274.                log_new_line;
   275.                show_in_various_formats(the_NEST(i));
   276.                log_new_line;
   277.             end if;
   278.          end loop;
   279.       end if;
   280.    end show_NEST;
   281.
   282.    procedure show_SJNS is
   283.    begin
   284.       if the_SJNS_depth = 0 then
   285.          log_line("The SJNS is empty.");
   286.          return;
   287.       else
   288.          log_line("SJNS:");
   289.       end if;
   290.       for i in reverse KDF9.SJNS_depth loop
   291.          if i < the_SJNS_depth then
   292.             log(just_right("S" & trimmed(KDF9.SJNS_depth'Image(the_SJNS_depth-i)), 3) & ": ");
   293.             log_line(oct_of(the_SJNS(i)) & " (" & dec_of(KDF9.syllable_address(the_SJNS(i))) & ")");
   294.          end if;
   295.       end loop;
   296.    end show_SJNS;
   297.
   298.    procedure show_Q_store is
   299.       Q_bits  : KDF9.word := 0;
   300.    begin
   301.       for Qq of the_Q_store loop
   302.          Q_bits := Q_bits or as_word(Qq);
   303.       end loop;
   304.       if Q_bits = 0 then
   305.          log_line("Q store: all zero.");
   306.          return;
   307.       else
   308.          log_line("Q store:");
   309.       end if;
   310.       for q in KDF9.Q_store'Range loop
   311.          if as_word(the_Q_store(q)) /= KDF9.word'(0) then
   312.             log(just_right("Q" & trimmed(q'Image), 3) & ": ");
   313.             show_Q_register(the_Q_store(q));
   314.             log("  = ");
   315.             show_Q_in_decimal(the_Q_store(q));
   316.             log_new_line;
   317.          end if;
   318.       end loop;
   319.    end show_Q_store;
   320.
   321.    procedure show_registers is
   322.    begin
   323.       show_progress;
   324.       log_new_line;
   325.       if the_execution_mode = boot_mode then
   326.          show_Director_registers;
   327.       end if;
   328.       show_SJNS;
   329.       log_new_line;
   330.       show_Q_store;
   331.       show_V_and_T;
   332.       log_new_line;
   333.       show_NEST;
   334.    end show_registers;
   335.
   336.    procedure show_order is
   337.    begin
   338.       log(the_code_and_name_of_INS);
   339.    end show_order;
   340.
   341.    procedure show_execution_context is
   342.    begin
   343.       log("At "
   344.         & oct_of(CIA)
   345.         & " ("
   346.         & dec_of(CIA)
   347.         & ")"
   348.         & "; ICR ="
   349.         & ICR'Image
   350.         & "; EL ="
   351.         & the_clock_time'Image
   352.         & "; the instruction was ");
   353.       show_order;
   354.       log_new_line;
   355.    end show_execution_context;
   356.
   357.    procedure log_to_external_trace is
   358.    begin
   359.       log(the_external_trace_file, oct_of(CIA));
   360.       tab_log_to(the_external_trace_file, 10);
   361.       log(the_external_trace_file, ICR'Image);
   362.       tab_log_to(the_external_trace_file, 20);
   363.       if only_signature_tracing then
   364.          log(
   365.              the_external_trace_file,
   366.              "#"
   367.            & oct_of(the_digital_signature)
   368.            & (if the_V_bit_is_set then "V" else " ")
   369.            & (if the_T_bit_is_set then "T" else " ")
   370.             );
   371.          tab_log_to(the_external_trace_file, 40);
   372.          if the_NEST_depth > 0 then
   373.             log(the_external_trace_file, "#" & oct_of(read_top));
   374.          end if;
   375.          tab_log_to(the_external_trace_file, 58);
   376.       else
   377.          log(the_external_trace_file, the_CPU_time'Image);
   378.          tab_log_to(the_external_trace_file, 40);
   379.          log(the_external_trace_file, the_NEST_depth'Image);
   380.          tab_log_to(the_external_trace_file, 43);
   381.          log(the_external_trace_file, the_SJNS_depth'Image);
   382.          tab_log_to(the_external_trace_file, 46);
   383.          log(the_external_trace_file, (if the_V_bit_is_set then "V" else " "));
   384.          log(the_external_trace_file, (if the_T_bit_is_set then "T" else " "));
   385.          tab_log_to(the_external_trace_file, 50);
   386.          if the_NEST_depth > 0 then
   387.             log(the_external_trace_file, "#" & oct_of(read_top));
   388.          end if;
   389.          tab_log_to(the_external_trace_file, 68);
   390.       end if;
   391.       log(the_external_trace_file, " |" & the_full_name_of(INS));
   392.       tab_log_to(the_external_trace_file, 90);
   393.       log(the_external_trace_file, KDF9.us'Image(the_clock_time));
   394.       log_new_line(the_external_trace_file);
   395.    end log_to_external_trace;
   396.
   397.    procedure log_an_external_trace_header (caption : in String := "") is
   398.    begin
   399.       if caption /= "" then
   400.          log_new_line(the_external_trace_file);
   401.          log(the_external_trace_file, caption);
   402.          log_new_line(the_external_trace_file);
   403.       end if;
   404.       log(the_external_trace_file, "LOCATION");
   405.       tab_log_to(the_external_trace_file, 11);
   406.       log(the_external_trace_file, "ICR");
   407.       tab_log_to(the_external_trace_file, 20);
   408.       if only_signature_tracing then
   409.          log(the_external_trace_file, "DIGITAL SIGNATURE");
   410.          tab_log_to(the_external_trace_file, 40);
   411.          log(the_external_trace_file, "[N1]");
   412.          tab_log_to(the_external_trace_file, 58);
   413.       else
   414.          log(the_external_trace_file, " CPU");
   415.          tab_log_to(the_external_trace_file, 40);
   416.          log(the_external_trace_file, "ND");
   417.          tab_log_to(the_external_trace_file, 43);
   418.          log(the_external_trace_file, "SD");
   419.          tab_log_to(the_external_trace_file, 46);
   420.          log(the_external_trace_file, "VT");
   421.          tab_log_to(the_external_trace_file, 50);
   422.          log(the_external_trace_file, "[N1]");
   423.          tab_log_to(the_external_trace_file, 68);
   424.       end if;
   425.       log(the_external_trace_file, " |INSTRUCTION");
   426.       log_new_line(the_external_trace_file);
   427.    end log_an_external_trace_header;
   428.
   429.    procedure show_CIA_and_NIA is
   430.    begin
   431.       log_line("CIA:        " & just_right(oct_of(CIA), 10) & " (" & just_right(dec_of(CIA) & ")"));
   432.       log_line("NIA:        " & just_right(oct_of(NIA), 10) & " (" & just_right(dec_of(NIA) & ")"));
   433.    end show_CIA_and_NIA;
   434.
   435.    procedure long_witness is
   436.    begin
   437.       log_new_line;
   438.       log("At " & oct_of(CIA) & " (" & dec_of(CIA) & ") the instruction was ");
   439.       show_order;
   440.       log_new_line;
   441.       show_registers;
   442.    end long_witness;
   443.
   444.    procedure short_witness is
   445.
   446.       type register_usage is array (KDF9.compressed_opcode) of Boolean
   447.          with Size => 64, Component_Size => 1;
   448.
   449.       it_uses_JB : constant register_usage
   450.                  := (
   451.                       LINK
   452.                     | TO_LINK
   453.                     | OS_OUT
   454.                     | JrNEJ
   455.                     | JSr
   456.                     | EXIT_n
   457.                     | JrEJ
   458.                     | EXITD     => True,
   459.                       others    => False
   460.                     );
   461.
   462.       it_uses_Qq : constant register_usage
   463.                  := (
   464.                       MkMq
   465.                     | MkMqQ
   466.                     | MkMqH
   467.                     | MkMqQH
   468.                     | MkMqN
   469.                     | MkMqQN
   470.                     | MkMqHN
   471.                     | MkMqQHN
   472.                     | TO_MkMq
   473.                     | TO_MkMqQ
   474.                     | TO_MkMqH
   475.                     | TO_MkMqQH
   476.                     | TO_MkMqN
   477.                     | TO_MkMqQN
   478.                     | TO_MkMqHN
   479.                     | TO_MkMqQHN
   480.                     | MqTOQk
   481.                     | IqTOQk
   482.                     | IMqTOQk
   483.                     | CqTOQk
   484.                     | CMqTOQk
   485.                     | CIqTOQk
   486.                     | QqTOQk
   487.                     | M_PLUS_Iq
   488.                     | M_MINUS_Iq
   489.                     | NCq
   490.                     | DCq
   491.                     | POS1_TO_Iq
   492.                     | NEG1_TO_Iq
   493.                     | POS2_TO_Iq
   494.                     | NEG2_TO_Iq
   495.                     | SHA
   496.                     | SHAD
   497.                     | MACC
   498.                     | SHL
   499.                     | SHLD
   500.                     | SHC
   501.                     | TO_RCIMq
   502.                     | QCIMq
   503.                     | ADD_TO_QCIMq
   504.                     | JCqNZS
   505.                     | PAR_Qq
   506.                     | PIA_PIC_CLO_TLO_Qq
   507.                     | PIB_PID_Qq
   508.                     | PIE_PIG_Qq
   509.                     | PIF_PIH_Qq
   510.                     | PMA_PMK_INT_Qq
   511.                     | CT_PMB_PMC_BUSY_Qq
   512.                     | PMD_PME_PML_Qq
   513.                     | PMF_PMG_Qq
   514.                     | POA_POC_POE_POF_PMH_Qq
   515.                     | POB_POD_Qq
   516.                     | POG_POL_Qq
   517.                     | POH_POK_Qq
   518.                     | JrCqNZ    => True,
   519.                       others    => False
   520.                     );
   521.
   522.       is_modified : constant register_usage
   523.                   := (
   524.                        EaMq
   525.                      | TO_EaMq
   526.                      | EaMqQ
   527.                      | TO_EaMqQ  => True,
   528.                        others    => False
   529.                      );
   530.
   531.       it_uses_Qk : constant register_usage
   532.                  := (
   533.                       MkMq
   534.                     | MkMqQ
   535.                     | MkMqH
   536.                     | MkMqQH
   537.                     | MkMqN
   538.                     | MkMqQN
   539.                     | MkMqHN
   540.                     | MkMqQHN
   541.                     | TO_MkMq
   542.                     | TO_MkMqQ
   543.                     | TO_MkMqH
   544.                     | TO_MkMqQH
   545.                     | TO_MkMqN
   546.                     | TO_MkMqQN
   547.                     | TO_MkMqHN
   548.                     | TO_MkMqQHN
   549.                     | MqTOQk
   550.                     | IqTOQk
   551.                     | IMqTOQk
   552.                     | CqTOQk
   553.                     | CMqTOQk
   554.                     | CIqTOQk
   555.                     | QqTOQk    => True,
   556.                       others    => False
   557.                     );
   558.
   559.       function INS_uses_Qq
   560.       return Boolean is
   561.          (
   562.           -- A compressed_opcode may be ambiguous: to know which opcode it represents,
   563.           --   further attributes of the order may need to be considered.
   564.           case INS.kind is
   565.              when two_syllable_order =>
   566.                 it_uses_Qq(INS.compressed_opcode)
   567.                   and
   568.                 -- If a shift, exclude fixed-amount shifts.
   569.                 ((INS.order.syllable_1 and 1) = 0 or else INS.compressed_opcode not in SHA..SHC),
   570.              when normal_jump_order =>
   571.                 INS.compressed_opcode in JrCqZ | JrCqNZ,
   572.              when data_access_order =>
   573.                 is_modified(INS.compressed_opcode),
   574.              when others =>
   575.                 False
   576.          );
   577.
   578.       need_new_line : Boolean := False;
   579.
   580.    begin  -- short_witness
   581.       log_new_line;
   582.       show_execution_context;
   583.       if the_CPU_state = Director_state then
   584.          show_Director_registers;
   585.       end if;
   586.
   587.       if it_uses_JB(INS.compressed_opcode)                     and then
   588.             INS.kind in two_syllable_order | normal_jump_order and then
   589.                the_SJNS_depth > 0                                  then
   590.          log_line(
   591.                   " JB: "
   592.                 & oct_of(the_SJNS(the_SJNS_depth-1))
   593.                 & "; SJNS depth: " & just_right(the_SJNS_depth'Image, 3)
   594.                  );
   595.       end if;
   596.
   597.       if INS.Qq /= 0 and then
   598.             INS_uses_Qq  then
   599.          log(just_right("Q" & trimmed(INS.Qq'Image), 3) & ": ");
   600.          show_Q_register(the_Q_store(INS.Qq));
   601.          log("  = ");
   602.          show_Q_in_decimal(the_Q_store(INS.Qq));
   603.          log_new_line;
   604.          need_new_line := True;
   605.       end if;
   606.       if INS.Qk /= 0                       and then
   607.             INS.kind in two_syllable_order and then
   608.                it_uses_Qk(INS.compressed_opcode)    and then
   609.                   INS.Qq /= INS.Qk             then
   610.          log(just_right("Q" & trimmed(INS.Qk'Image), 3) & ": ");
   611.          show_Q_register(the_Q_store(INS.Qk));
   612.          log("  = ");
   613.          show_Q_in_decimal(the_Q_store(INS.Qk));
   614.          log_new_line;
   615.          need_new_line := True;
   616.       end if;
   617.       if need_new_line then
   618.          log_new_line;
   619.       end if;
   620.
   621.       show_V_and_T;
   622.       show_NEST;
   623.       log_rule;
   624.    end short_witness;
   625.
   626.    procedure show_frequency_plots is
   627.
   628.       function summed_counts (from, to : KDF9.syllable)
   629.       return KDF9.order_counter is
   630.          sum : KDF9.order_counter := 0;
   631.       begin
   632.          for i in from .. to loop
   633.             sum := sum + the_histogram(i);
   634.          end loop;
   635.          return sum;
   636.       end summed_counts;
   637.
   638.       procedure log_opcode_bin (bin    : in KDF9.syllable;
   639.                                 sum    : in KDF9.order_counter;
   640.                                 bound  : in Long_Float) is
   641.          percent : Long_Float;
   642.          image   : String(1 .. 6);
   643.       begin
   644.          if sum /= 0 then
   645.             percent := Long_Float(sum)/Long_Float(ICR)*100.0;
   646.             if percent < bound then
   647.                return;
   648.             end if;
   649.             log(oct_of(bin) & ": " & the_short_name_of(bin));
   650.             tab_log_to(32);
   651.             log(sum'Image);
   652.             tab_log_to(42);
   653.             Put(image, percent, Aft => 2, Exp => 0);
   654.             log(image & "% :");
   655.             for i in 1 .. Integer(percent) loop
   656.                log("|");
   657.             end loop;
   658.             log_new_line;
   659.          end if;
   660.       end log_opcode_bin;
   661.
   662.       procedure log_opcode_usage (bound : in Long_Float) is
   663.       begin
   664.          for i in KDF9.syllable'(0) .. 8#167# loop
   665.             log_opcode_bin(i, the_histogram(i), bound);
   666.          end loop;
   667.          for i in KDF9.syllable'(8#170#) .. 8#237# loop
   668.             log_opcode_bin(i, the_histogram(i), bound);
   669.          end loop;
   670.          log_opcode_bin(8#240#, summed_counts(from => 8#240#, to => 8#257#), bound);
   671.          log_opcode_bin(8#260#, summed_counts(from => 8#240#, to => 8#277#), bound);
   672.          for i in KDF9.syllable'(8#300#) .. 8#377# loop
   673.             log_opcode_bin(i, the_histogram(i), bound);
   674.          end loop;
   675.       end log_opcode_usage;
   676.
   677.       accounted_for : Long_Float;
   678.       cutoff_image  : String(1 .. 7) := "      %";
   679.       percent_image : String(1 .. 7) := "      %";
   680.
   681.       procedure log_order_word_bin (bin    : in KDF9.code_address;
   682.                                     sum    : in KDF9.order_counter;
   683.                                     bound  : in Long_Float) is
   684.          percent : Long_Float;
   685.       begin
   686.          if sum /= 0 then
   687.             percent := Long_Float(sum)/Long_Float(ICR)*100.0;
   688.             if percent < bound then
   689.                return;
   690.             end if;
   691.             accounted_for := accounted_for + percent;
   692.             log("#" & oct_of(bin) & ": ");
   693.             tab_log_to(32);
   694.             log(sum'Image);
   695.             tab_log_to(42);
   696.             Put(percent_image, percent, Aft => 2, Exp => 0);
   697.             percent_image(7) := '%';
   698.             log(percent_image);
   699.             log(" :");
   700.             for i in 1 .. Integer(percent) loop
   701.                log("|");
   702.             end loop;
   703.             log_new_line;
   704.          end if;
   705.       end log_order_word_bin;
   706.
   707.       procedure log_profile (bound : in Long_Float) is
   708.       begin
   709.          accounted_for := 0.0;
   710.          for w in KDF9.code_address loop
   711.             if the_profile(w) /= 0 then
   712.                log_order_word_bin(w, the_profile(w), bound);
   713.             end if;
   714.          end loop;
   715.       end log_profile;
   716.
   717.       procedure sum_logged_frequencies (bound  : in Long_Float) is
   718.          percent : Long_Float;
   719.       begin
   720.          accounted_for := 0.0;
   721.          for w in KDF9.code_address loop
   722.             percent := Long_Float(the_profile(w))/Long_Float(ICR)*100.0;
   723.             if percent >= bound then
   724.                accounted_for := accounted_for + percent;
   725.             end if;
   726.          end loop;
   727.       end sum_logged_frequencies;
   728.
   729.    begin -- show_frequency_plots
   730.       Put(cutoff_image(1..6), histogram_cutoff, Aft => 2, Exp => 0);
   731.       cutoff_image(7) := '%';
   732.       if the_INS_plot_is_wanted and ICR /= 0 and the_diagnostic_mode /= fast_mode then
   733.          -- Print the instruction execution-frequency histogram.
   734.          log_title(
   735.                    "Histogram of the opcodes of"
   736.                  & ICR'Image
   737.                  & " executed instructions with frequency >="
   738.                  & cutoff_image
   739.                   );
   740.          log_opcode_usage(bound => histogram_cutoff);
   741.          log_new_line;
   742.       end if;
   743.       if the_profile_is_wanted and ICR /= 0 and the_diagnostic_mode /= fast_mode then
   744.          log_title(
   745.                    "Histogram of the loci of"
   746.                  & ICR'Image
   747.                  & " executed instructions with frequency >="
   748.                  & cutoff_image
   749.                   );
   750.          log_profile(bound => histogram_cutoff);
   751.          log_new_line;
   752.       end if;
   753.       sum_logged_frequencies(bound => histogram_cutoff);
   754.       Put(percent_image(1..6), accounted_for, Aft =>1, Exp => 0);
   755.       log_line("Executions accounted for in the profile:" & percent_image);
   756.       log_rule;
   757.    end show_frequency_plots;
   758.
   759.    function as_RFIR (K4_word : KDF9.word)
   760.    return KDF9.RFIR is
   761.       mask : KDF9.word := 2**16;
   762.       RFIR : KDF9.RFIR := (others => False);
   763.    begin
   764.       for r in reverse KDF9.interrupt_number loop
   765.          if (K4_word and mask) /= 0 then
   766.             RFIR(r) := True;
   767.          end if;
   768.          mask := 2 * mask;
   769.       end loop;
   770.       return RFIR;
   771.    end as_RFIR;
   772.
   773.    function for_FH_disc (compressed_opcode : KDF9.compressed_opcode; Pxy_bits : KDF9.Q_number)
   774.    return Boolean
   775.    is (case compressed_opcode is
   776.           when PIA_PIC_CLO_TLO_Qq     => Pxy_bits = PIC_bits,
   777.           when PIB_PID_Qq             => Pxy_bits = PID_bits,
   778.           when PIE_PIG_Qq             => Pxy_bits = PIG_bits,
   779.           when PIF_PIH_Qq             => Pxy_bits = PIH_bits,
   780.           when POA_POC_POE_POF_PMH_Qq => Pxy_bits = POC_bits,
   781.           when POB_POD_Qq             => Pxy_bits = POD_bits,
   782.           when POG_POL_Qq             => Pxy_bits = POL_bits,
   783.           when POH_POK_Qq             => Pxy_bits = POK_bits,
   784.           when others                 => False
   785.       );
   786.
   787.
   788.    first_col   : constant := 17;
   789.    device_col  : constant := first_col + 23;
   790.    operand_col : constant := device_col;
   791.    event_col   : constant := operand_col + 4;
   792.    is_D_col    : constant := event_col + 29;
   793.    depth_col   : constant := operand_col + 29;
   794.    time_col    : constant := depth_col + 11;
   795.    ICR_col     : constant := time_col + 13;
   796.
   797.    procedure show_retro_FIFO is
   798.
   799.       RFIR_id : constant array (KDF9.interrupt_number) of Character
   800.               := ('P', 'F', 'I', 'N', 'E', 'S', 'O', 'R', 'Y', 'Z');
   801.       image   : String(1 .. 21);
   802.       RFIR    : KDF9.RFIR;
   803.    begin
   804.       if retro_FIFO_count = 0 then
   805.          return;
   806.       end if;
   807.       log_title("Retrospective trace of all instructions.");
   808.       tab_log_to(depth_col);
   809.       log_line("ND SD VTD   CPU TIME     ICR");
   810.       for i in 1 .. retro_FIFO_count loop
   811.          if i = 1 then
   812.             log("Ended ");
   813.          else
   814.             log("After ");
   815.          end if;
   816.          declare
   817.             this      : tracing.retro_FIFO_entry renames retro_FIFO(retro_FIFO_index);
   818.             Q         : constant KDF9.Q_register := as_Q(this.parameter);
   819.             decoded   : KDF9.decoded_order;
   820.          begin
   821.             log(oct_of(this.location) & ":");
   822.             tab_log_to(first_col);
   823.             decoded.order := this.order;
   824.             decode(decoded);
   825.             log(the_full_name_of(decoded,
   826.                                  in_octal => decoded.kind = normal_jump_order));
   827.             tab_log_to(operand_col);
   828.             case decoded.kind is
   829.                when one_syllable_order =>
   830.                   if this.nested > 0 then
   831.                      case decoded.compressed_opcode is
   832.                         when DIV
   833.                            | DIVD
   834.                            | X_frac =>
   835.                            log(CPU.fraction'Image(as_fraction(this.parameter)));
   836.                         when DIVI =>
   837.                            log(CPU.signed'Image(resign(this.parameter)));
   838.                         when STAND
   839.                            | ABSF
   840.                            | DIVDF
   841.                            | DIVF
   842.                            | FLOAT_9
   843.                            | FLOATD
   844.                            | MINUSDF
   845.                            | MINUSF
   846.                            | NEGDF
   847.                            | NEGF
   848.                            | PLUSDF
   849.                            | PLUSF
   850.                            | ROUNDF
   851.                            | ROUNDHF
   852.                            | XDF
   853.                            | XF
   854.                            | XPLUSF
   855.                            | MAXF =>
   856.                            Put(image, host_float(CPU.f48(this.parameter)), Aft => 12, Exp => 2);
   857.                            log(trimmed(image));
   858.                         when others =>
   859.                            if this.nested > 0 then
   860.                               log_octal(this.parameter);
   861.                            end if;
   862.                      end case;
   863.                   end if;
   864.                when two_syllable_order =>
   865.                   case decoded.compressed_opcode is
   866.                      when PAR_Qq =>
   867.                         show_IO_register(Q, for_DR => False, for_FD => False);
   868.                      when CT_PMB_PMC_BUSY_Qq
   869.                         | PMA_PMK_INT_Qq
   870.                         | PMD_PME_PML_Qq
   871.                         | PMF_PMG_Qq =>
   872.                         show_IO_register(
   873.                                          Q,
   874.                                          for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
   875.                                          for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
   876.                                          for_seek => decoded.Qk = PMA_bits
   877.                                         );
   878.                      when PIA_PIC_CLO_TLO_Qq
   879.                         | PIB_PID_Qq
   880.                         | PIE_PIG_Qq
   881.                         | PIF_PIH_Qq
   882.                         | POA_POC_POE_POF_PMH_Qq
   883.                         | POB_POD_Qq
   884.                         | POG_POL_Qq
   885.                         | POH_POK_Qq =>
   886.                         show_IO_register(
   887.                                          Q,
   888.                                          for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
   889.                                          for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
   890.                                          for_FH   => for_FH_disc(decoded.compressed_opcode, decoded.Qk)
   891.                                         );
   892.                      when M_PLUS_Iq
   893.                         | M_MINUS_Iq
   894.                         | NCq
   895.                         | DCq
   896.                         | POS1_TO_Iq
   897.                         | NEG1_TO_Iq
   898.                         | POS2_TO_Iq
   899.                         | NEG2_TO_Iq
   900.                         | CqTOQk
   901.                         | IqTOQk
   902.                         | MqTOQk
   903.                         | QqTOQk
   904.                         | CIqTOQk
   905.                         | IMqTOQk
   906.                         | CMqTOQk
   907.                         | TO_RCIMq
   908.                         | ADD_TO_QCIMq
   909.                         | JCqNZS =>
   910.                         show_Q_register(Q);
   911.                      when Kk =>
   912.                         case decoded.Qk is
   913.                            when K4 =>
   914.                               log(KDF9.word'Image(32*KDF9.word(Q.C)));
   915.                               log("us");
   916.                               if Q.I /= 0 then
   917.                                  log("; RFIR: ");
   918.                                  RFIR := as_RFIR(this.parameter);
   919.                                  for r in KDF9.interrupt_number loop
   920.                                     if RFIR(r) then
   921.                                        log(RFIR_id(r)&"");
   922.                                     end if;
   923.                                  end loop;
   924.                               end if;
   925.                               if resign(this.parameter) < 0 then
   926.                                  log("C");
   927.                               end if;
   928.                            when K5 | K7 =>
   929.                               log_octal(this.parameter);
   930.                            when others =>
   931.                               log("invalid K order: #" & oct_of(decoded.compressed_opcode));
   932.                         end case;
   933.                      when TO_LINK =>
   934.                         log(oct_of(as_link(this.parameter)));
   935.                      when LINK =>
   936.                         log(oct_of(as_link(this.parameter)));
   937.                      when TO_MkMq
   938.                         | TO_MkMqQ
   939.                         | TO_MkMqH
   940.                         | TO_MkMqQH
   941.                         | TO_MkMqN
   942.                         | TO_MkMqQN
   943.                         | TO_MkMqHN
   944.                         | TO_MkMqQHN =>
   945.                         log_octal(this.parameter);
   946.                      when others =>
   947.                         if this.nested > 0 then
   948.                            log_octal(this.parameter);
   949.                         end if;
   950.                   end case;
   951.                when normal_jump_order =>
   952.                   case decoded.compressed_opcode is
   953.                      when Jr
   954.                         | JSr =>
   955.                         log(oct_of(as_link(this.parameter)));
   956.                      when EXIT_n =>
   957.                         if this.parameter < 8 then
   958.                            log(this.parameter'Image);
   959.                         else
   960.                            log(oct_of(as_link(this.parameter)));
   961.                         end if;
   962.                      when EXITD =>
   963.                         log(oct_of(as_link(this.parameter)));
   964.                      when JrCqZ
   965.                         | JrCqNZ =>
   966.                         show_Q_register(Q);
   967.                      when OS_OUT =>
   968.                         if this.parameter < 16 then
   969.                            log_octal(this.parameter);
   970.                         elsif this.parameter < 64 then
   971.                            log(this.parameter'Image);
   972.                         elsif this.parameter > 2**47 then
   973.                            log_octal(this.parameter);
   974.                         else
   975.                            show_Q_register(Q);
   976.                         end if;
   977.                      when JrEJ
   978.                         | JrNEJ
   979.                         | JrEN
   980.                         | JrNEN =>
   981.                            log(this.parameter'Image);
   982.                      when JrTR
   983.                         | JrV =>
   984.                            log(Boolean'Image(Boolean'Val(this.parameter)));
   985.                      when JrNTR
   986.                         | JrNV =>
   987.                            log(Boolean'Image(not Boolean'Val(this.parameter)));
   988.                      when others =>
   989.                         if this.nested > 0 then
   990.                            log_octal(this.parameter);
   991.                         end if;
   992.                      end case;
   993.                when others =>
   994.                   if this.nested > 0 then
   995.                      log_octal(this.parameter);
   996.                   end if;
   997.             end case;
   998.             tab_log_to(depth_col);
   999.             log(just_right(this.nested'Image,2));
  1000.             log(" ");
  1001.             log(just_right(this.called'Image,2));
  1002.             log(" ");
  1003.             log(if this.V then "V" else " ");
  1004.             log(if this.T then "T" else " ");
  1005.             log(if this.D then "D" else " ");
  1006.             tab_log_to(time_col);
  1007.             log(this.CPU_time'Image);
  1008.             tab_log_to(ICR_col);
  1009.             log(this.ICR_value'Image);
  1010.             log_new_line;
  1011.          end;
  1012.          retro_FIFO_index := retro_FIFO_index - 1;
  1013.       end loop;
  1014.       if retro_FIFO_count = FIFO_size then
  1015.          log("After earlier instructions, whose tracing is now lost.");
  1016.       else
  1017.          log("After the start of traced execution.");
  1018.       end if;
  1019.       log_new_line;
  1020.       log_rule;
  1021.    end show_retro_FIFO;
  1022.
  1023.    the_final_ICR : KDF9.order_counter := 0;
  1024.
  1025.    procedure notify_state_display_of_final_ICR is
  1026.    begin
  1027.       the_final_ICR := ICR;
  1028.    end notify_state_display_of_final_ICR;
  1029.
  1030.    procedure show_IOC_FIFO is
  1031.    begin
  1032.       if IOC_FIFO_count = 0 then return; end if;
  1033.       log_title("Retrospective trace of peripheral I/O events.");
  1034.       tab_log_to(is_D_col);
  1035.       log_line("CPL T   EL. TIME     ICR");
  1036.       for i in 1 .. IOC_FIFO_count loop
  1037.          if i = 1 then
  1038.             log("Ended ");
  1039.          else
  1040.             log("After ");
  1041.          end if;
  1042.
  1043.          declare
  1044.             this    : tracing.IOC_FIFO_entry renames IOC_FIFO(IOC_FIFO_index);
  1045.             decoded : constant KDF9.decoded_order := this.decoded_order;
  1046.
  1047.             procedure show_transfer (
  1048.                                      Q                 : in KDF9.Q_register;
  1049.                                      for_OUT, for_seek : in Boolean := False
  1050.                                     ) is
  1051.             begin
  1052.                case decoded.compressed_opcode is
  1053.                   when PAR_Qq =>
  1054.                      show_IO_register(Q, for_DR => False, for_FD => False);
  1055.                   when CT_PMB_PMC_BUSY_Qq
  1056.                      | PMA_PMK_INT_Qq
  1057.                      | PMD_PME_PML_Qq
  1058.                      | PMF_PMG_Qq =>
  1059.                      show_IO_register(
  1060.                                       Q,
  1061.                                       for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
  1062.                                       for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
  1063.                                       for_seek => (decoded.Qk in PMA_bits) or show_transfer.for_seek,
  1064.                                       for_OUT  => show_transfer.for_OUT
  1065.                                      );
  1066.                   when PIA_PIC_CLO_TLO_Qq
  1067.                      | PIB_PID_Qq
  1068.                      | PIE_PIG_Qq
  1069.                      | PIF_PIH_Qq
  1070.                      | POA_POC_POE_POF_PMH_Qq
  1071.                      | POB_POD_Qq
  1072.                      | POG_POL_Qq
  1073.                      | POH_POK_Qq
  1074.                      | OS_OUT =>
  1075.                      show_IO_register(
  1076.                                       Q,
  1077.                                       for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
  1078.                                       for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
  1079.                                       for_FH   => for_FH_disc(decoded.compressed_opcode, decoded.Qk),
  1080.                                       for_OUT  => show_transfer.for_OUT
  1081.                                      );
  1082.                   when others =>
  1083.                      log("invalid IO order: #" & oct_of(decoded.compressed_opcode));
  1084.                end case;
  1085.             end show_transfer;
  1086.
  1087.             shown_ICR : KDF9.order_counter := this.ICR_value;
  1088.             FD_seek   : Boolean := False;
  1089.             FD_xfer   : Boolean := False;
  1090.
  1091.          begin -- show_IOC_FIFO
  1092.             log(oct_of(this.order_address) & ":");
  1093.             tab_log_to(first_col);
  1094.             if the_full_name_of(this.decoded_order) = "OUT"  then
  1095.                 if this.device_name(1..2) in "MT" | "ST" and then
  1096.                       this.ICR_value >= the_final_ICR        then
  1097.                   log("OUT 0/2 rewind");
  1098.                   shown_ICR := the_final_ICR + 1;
  1099.                elsif this.device_name(1..2) in "MT" | "ST" then
  1100.                   log("OUT 6/7 rewind");
  1101.                elsif this.device_name(1..2) in "LP" | "TP" then
  1102.                   log("OUT 8");
  1103.                elsif this.device_name(1..2) = "DR" then
  1104.                   if this.kind in start_transfer | finis_transfer | buffer_lockout | store_lockout then
  1105.                      log(if this.operation = output_operation then "OUT 11" else "OUT 12");
  1106.                   else
  1107.                      log("OUT 11/12");
  1108.                   end if;
  1109.                elsif this.device_name(1..2) = "FD" then
  1110.                   if this.kind in start_transfer | finis_transfer | buffer_lockout | store_lockout then
  1111.                      log(if this.operation = output_operation then "OUT 41" else "OUT 42");
  1112.                   else
  1113.                      log("OUT 41/42 seek"); FD_seek := True;
  1114.                   end if;
  1115.                elsif this.device_name(1..2) = "FW" then
  1116.                   log("OUT 8/16");
  1117.                else
  1118.                   log("OUT ?");
  1119.                end if;
  1120.             else
  1121.                log(mnemonic(the_full_name_of(this.decoded_order), this.device_name));
  1122.             end if;
  1123.             tab_log_to(device_col);
  1124.             log(this.device_name);
  1125.             case this.kind is
  1126.                when store_lockout =>
  1127.                   tab_log_to(event_col);
  1128.                   log("locks out #");
  1129.                   log(oct_of(this.data_address));
  1130.                   log(" = E");
  1131.                   log(dec_of(this.data_address));
  1132.                   tab_log_to(is_D_col);
  1133.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1134.                   log(this.priority_level'Image);
  1135.                   tab_log_to(time_col);
  1136.                   log(this.initiation_time'Image);
  1137.                   tab_log_to(ICR_col);
  1138.                   log(shown_ICR'Image);
  1139.                 when buffer_lockout =>
  1140.                   tab_log_to(event_col);
  1141.                   log("buffer lockout");
  1142.                   tab_log_to(is_D_col);
  1143.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1144.                   log(this.priority_level'Image);
  1145.                   tab_log_to(time_col);
  1146.                   log(this.initiation_time'Image);
  1147.                   tab_log_to(ICR_col);
  1148.                   log(shown_ICR'Image);
  1149.                when start_transfer =>
  1150.                   tab_log_to(event_col);
  1151.                   show_transfer(this.control_word);
  1152.                   tab_log_to(is_D_col);
  1153.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1154.                   log(this.priority_level'Image);
  1155.                   tab_log_to(time_col-2);
  1156.                   log(" S" & this.initiation_time'Image);
  1157.                   tab_log_to(ICR_col);
  1158.                   log(shown_ICR'Image);
  1159.                when finis_transfer =>
  1160.                   tab_log_to(event_col);
  1161.                   show_transfer(this.control_word);
  1162.                   tab_log_to(is_D_col);
  1163.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1164.                   log(this.priority_level'Image);
  1165.                   tab_log_to(time_col-2);
  1166.                   log(" E" & this.completion_time'Image);
  1167.                   tab_log_to(ICR_col);
  1168.                   log(shown_ICR'Image);
  1169.                when buffer_status =>
  1170.                   tab_log_to(event_col);
  1171.                   FD_xfer := this.device_name(1..2) = "FD";
  1172.                   -- PMFQq entails no data transfer or seek, but has a sector address parameter.
  1173.                   FD_seek := (FD_seek or (decoded.Qk in PMA_bits)) and FD_xfer;
  1174.                   FD_seek := FD_seek and decoded.compressed_opcode /= PMF_PMG_Qq;
  1175.                   show_IO_register(this.Q_register, for_FD => FD_xfer, for_seek => FD_seek);
  1176.                   tab_log_to(is_D_col);
  1177.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1178.                   log(this.priority_level'Image);
  1179.                   log(if this.status then " Y" else " N");
  1180.                   tab_log_to(time_col);
  1181.                   log(this.initiation_time'Image);
  1182.                   tab_log_to(ICR_col);
  1183.                   log(shown_ICR'Image);
  1184.             end case;
  1185.             log_new_line;
  1186.          end;
  1187.          IOC_FIFO_index := IOC_FIFO_index - 1;
  1188.       end loop;
  1189.       if IOC_FIFO_count = FIFO_size then
  1190.          log_line("After earlier instructions, whose tracing is now lost.");
  1191.       else
  1192.          log_line("After the start of traced execution.");
  1193.       end if;
  1194.       log_line("Total time waiting for unoverlapped I/O to finish ="
  1195.              & KDF9.us'Image((the_clock_time-the_CPU_time+500) / 1000)
  1196.              & " ms.");
  1197.       log_rule;
  1198.    end show_IOC_FIFO;
  1199.
  1200.    procedure show_interrupt_FIFO is
  1201.    begin
  1202.       if interrupt_FIFO_count = 0 then return; end if;
  1203.       log_title("Retrospective trace of interrupt requests.");
  1204.       tab_log_to(is_D_col);
  1205.       log_line("CPL     EL. TIME     ICR");
  1206.       for i in 1 .. interrupt_FIFO_count loop
  1207.          log(if i = 1 then "Ended " else "After ");
  1208.          declare
  1209.             this : tracing.interrupt_FIFO_entry renames interrupt_FIFO(interrupt_FIFO_index);
  1210.          begin
  1211.             log(oct_of(this.order_address) & ": ");
  1212.             tab_log_to(first_col);
  1213.             log(case this.interrupt_code is
  1214.                    when caused_by_PR     => "PR   ",
  1215.                    when caused_by_FLEX   => "FLEX ",
  1216.                    when caused_by_LIV    => "LIV  ",
  1217.                    when caused_by_NOUV   => "NOUV ",
  1218.                    when caused_by_EDT    => "EDT  ",
  1219.                    when caused_by_OUT    => "OUT  ",
  1220.                    when caused_by_LOV     => "LOV  ",
  1221.                    when caused_by_RESET   => "RESET",
  1222.                    when caused_by_CLOCK   => "CLOCK",
  1223.                    when EXITD_flag       => "EXITD"
  1224.                );
  1225.             tab_log_to(event_col-4);
  1226.             log(trimmed(this.message));
  1227.             tab_log_to(is_D_col);
  1228.             log(slot_name(this.context));
  1229.             log(this.priority_level'Image);
  1230.             tab_log_to(time_col);
  1231.             log(this.busy_time'Image);
  1232.             tab_log_to(ICR_col);
  1233.             log(this.ICR_value'Image);
  1234.             log_new_line;
  1235.          end;
  1236.          interrupt_FIFO_index := interrupt_FIFO_index - 1;
  1237.       end loop;
  1238.       log(
  1239.           if interrupt_FIFO_count = FIFO_size then
  1240.              "After earlier interrupts, whose tracing is now lost."
  1241.           else
  1242.             "After the start of traced execution."
  1243.          );
  1244.       log_new_line;
  1245.       log_new_line;
  1246.    end show_interrupt_FIFO;
  1247.
  1248.    procedure show_retrospective_traces is
  1249.    begin
  1250.       if peripheral_tracing_is_enabled then
  1251.          pragma Debug(IOC.diagnostics);
  1252.       end if;
  1253.       if interrupt_tracing_is_enabled then
  1254.          show_interrupt_FIFO;
  1255.       end if;
  1256.       if peripheral_tracing_is_enabled then
  1257.          show_IOC_FIFO;
  1258.       end if;
  1259.       if retrospective_tracing_is_enabled then
  1260.          show_retro_FIFO;
  1261.       end if;
  1262.    end show_retrospective_traces;
  1263.
  1264.    procedure show_current_state is
  1265.    begin
  1266.       show_execution_context;
  1267.       log_rule;
  1268.       show_registers;
  1269.       log_rule;
  1270.    end show_current_state;
  1271.
  1272.    procedure show_final_state (because : in String) is
  1273.    begin
  1274.       if the_final_state_is_wanted then
  1275.          if loading_was_successful then
  1276.
  1277.             -- make sure there is at least one NL after any FW output.
  1278.             if the_log_is_wanted then
  1279.                log_new_line;
  1280.                log_rule;
  1281.             else
  1282.                log_new_line;
  1283.             end if;
  1284.             log_line("Final State: " & because & ".");
  1285.             if not the_log_is_wanted then return; end if;
  1286.             long_witness;
  1287.             log_rule;
  1288.
  1289.             if nr_of_post_dumping_areas /= 0 then
  1290.                log_title("Post-run Dump:");
  1291.                print_postrun_dump_areas;
  1292.             end if;
  1293.
  1294.             if the_INS_plot_is_wanted or the_profile_is_wanted then
  1295.                if histogramming_is_enabled then
  1296.                   show_frequency_plots;
  1297.                end if;
  1298.             end if;
  1299.
  1300.             show_retrospective_traces;
  1301.             if the_signature_is_enabled then
  1302.                log_title("Digital signature of traced orders = #"
  1303.                        & oct_of(the_digital_signature)
  1304.                        & ".");
  1305.             end if;
  1306.
  1307.          else
  1308.
  1309.             log_line("ee9: " & because & ".");
  1310.             show_all_prerun_dump_areas;
  1311.          end if;
  1312.       end if;
  1313.    end show_final_state;
  1314.
  1315.    procedure show_all_prerun_dump_areas is
  1316.    begin
  1317.       if the_log_is_wanted and nr_of_pre_dumping_areas /= 0 then
  1318.          log_title("Pre-run Dump:");
  1319.          print_prerun_dump_areas;
  1320.          remove_prerun_dump_areas;
  1321.       end if;
  1322.    end show_all_prerun_dump_areas;
  1323.
  1324.    increment   : constant := 3;
  1325.    jump_tab    : constant := 4;
  1326.    first_tab   : constant := 7;
  1327.    last_column : constant := 96;
  1328.
  1329.    function is_non_blank (first : in KDF9.address)
  1330.    return Boolean is
  1331.       result : Boolean := False;
  1332.    begin
  1333.       for address in first .. first+increment-1 loop
  1334.          result := result or (fetch_word(address) /= 0);
  1335.       end loop;
  1336.       return result;
  1337.    end is_non_blank;
  1338.
  1339.    subtype converted_word is String(1..8);
  1340.
  1341.    type convertor is
  1342.       not null access function (address : KDF9.address) return converted_word;
  1343.
  1344.    procedure show_core (first, last : in KDF9.address;
  1345.                         head, side  : in String;
  1346.                         converted   : in convertor) is
  1347.
  1348.       procedure show_group (first : in KDF9.address) is
  1349.          address : KDF9.address := first;
  1350.       begin
  1351.          while address <= first+increment-1 loop
  1352.             log(converted(address));
  1353.             address := address + 1;
  1354.             exit when address < first;
  1355.          end loop;
  1356.       end show_group;
  1357.
  1358.       address : KDF9.address := first;
  1359.
  1360.    begin
  1361.       if (last-first+1) < 1 then
  1362.          return;
  1363.       end if;
  1364.       BA := 0; -- Ensure that physical store is examined when running in boot mode.
  1365.       log_title("Core store [#" & oct_of(first) & " .. #" & oct_of(last) & "] interpreted as " & head & ":");
  1366.       while address <= last loop
  1367.          if is_non_blank(address) then
  1368.             log_octal(KDF9.field_of_16_bits(address));
  1369.             log(":");
  1370.             tab_log_to(jump_tab);
  1371.             log(side);
  1372.             log(" """);
  1373.             show_group(address);
  1374.             log("""");
  1375.             log_new_line;
  1376.          else
  1377.             log_line("========  blank  ========");
  1378.          end if;
  1379.       exit when address >= KDF9.address'Last - increment;
  1380.          address := address + increment;
  1381.       end loop;
  1382.       log_new_line;
  1383.    end show_core;
  1384.
  1385.    function encoding_of (address : KDF9.address; code_table : output_code_table)
  1386.    return converted_word is
  1387.       result : converted_word;
  1388.    begin
  1389.       for b in KDF9_char_sets.symbol_index loop
  1390.          result(Natural(b)+1) := glyph_for(code_table(fetch_symbol(address, b)));
  1391.       end loop;
  1392.       return result;
  1393.    end encoding_of;
  1394.
  1395.    current_case : KDF9_char_sets.symbol := KDF9_char_sets.Case_Normal;
  1396.
  1397.    function interpretation_of (address : KDF9.address)
  1398.    return converted_word is
  1399.       result : converted_word;
  1400.       symbol : KDF9_char_sets.symbol;
  1401.       char   : Character;
  1402.    begin
  1403.       for b in KDF9_char_sets.symbol_index loop
  1404.          symbol := fetch_symbol(address, b);
  1405.          if current_case = KDF9_char_sets.Case_Normal then
  1406.             char := TP_CN(symbol);
  1407.          else
  1408.             char := TP_CS(symbol);
  1409.          end if;
  1410.          if symbol = KDF9_char_sets.Case_Normal then
  1411.             current_case := KDF9_char_sets.Case_Normal;
  1412.          elsif symbol = KDF9_char_sets.Case_Shift then
  1413.             current_case := KDF9_char_sets.Case_Shift;
  1414.          end if;
  1415.          result(Natural(b)+1) := glyph_for(char);
  1416.       end loop;
  1417.       return result;
  1418.    end interpretation_of;
  1419.
  1420.    function case_visible (address : KDF9.address)
  1421.    return converted_word
  1422.    is (interpretation_of(address));
  1423.
  1424.    function case_normal (address : KDF9.address)
  1425.    return converted_word
  1426.    is (encoding_of(address, code_table => TP_CN));
  1427.
  1428.    function case_shift (address : KDF9.address)
  1429.    return converted_word
  1430.    is (encoding_of(address, code_table => TP_CS));
  1431.
  1432.    function printer_code (address : KDF9.address)
  1433.    return converted_word
  1434.    is (encoding_of(address, code_table => to_LP));
  1435.
  1436.    function card_code (address : KDF9.address)
  1437.    return converted_word
  1438.    is (encoding_of(address, code_table => to_CP));
  1439.
  1440.    function Latin_1_code (address : KDF9.address)
  1441.    return converted_word
  1442.    is (converted_word'(1..7 => Space,
  1443.                        8    => glyph_for(Character'Val(fetch_word(address) and 8#377#))));
  1444.
  1445.    procedure show_core_in_case_visible (first, last : in KDF9.address) is
  1446.    begin
  1447.       show_core(first, last,
  1448.                 head => "characters in TR/TP code with case shifting",
  1449.                 side => "  ",
  1450.                 converted => case_visible'Access);
  1451.    end show_core_in_case_visible;
  1452.
  1453.    procedure show_core_in_case_normal (first, last : in KDF9.address) is
  1454.    begin
  1455.       show_core(first, last,
  1456.                 head => "characters in TR/TP Normal Case code",
  1457.                 side => "NC",
  1458.                 converted => case_normal'Access);
  1459.    end show_core_in_case_normal;
  1460.
  1461.    procedure show_core_in_case_shift (first, last : in KDF9.address) is
  1462.    begin
  1463.       show_core(first, last,
  1464.                 head => "characters in TR/TP Shift Case code",
  1465.                 side => "SC",
  1466.                 converted => case_shift'Access);
  1467.    end show_core_in_case_shift;
  1468.
  1469.    procedure show_core_in_print_code (first, last : in KDF9.address) is
  1470.    begin
  1471.       show_core(first, last,
  1472.                 head => "characters in LP code",
  1473.                 side => "LP",
  1474.                 converted => printer_code'Access);
  1475.    end show_core_in_print_code;
  1476.
  1477.    procedure show_core_in_card_code (first, last : in KDF9.address) is
  1478.    begin
  1479.       show_core(first, last,head => "characters in CR/CP code",
  1480.                 side => "CP",
  1481.                 converted => card_code'Access);
  1482.    end show_core_in_card_code;
  1483.
  1484.    procedure show_core_in_Latin_1 (first, last : in KDF9.address) is
  1485.    begin
  1486.       show_core(first, last,
  1487.                 head => "words with bits 40-47 of each in Latin-1 code",
  1488.                 side => "L1",
  1489.                 converted => Latin_1_code'Access);
  1490.    end show_core_in_Latin_1;
  1491.
  1492.    procedure show_core_in_tape_code (first, last : in KDF9.address) is
  1493.    begin
  1494.       show_core_in_case_visible(first, last);
  1495.    end show_core_in_tape_code;
  1496.
  1497.    procedure show_core_as_word_forms (first, last  : KDF9.address) is
  1498.
  1499.       procedure show_word (address : KDF9.address) is
  1500.          word : constant KDF9.word := fetch_word(address);
  1501.       begin
  1502.          log_octal(KDF9.field_of_16_bits(address));
  1503.          log(":");
  1504.          tab_log_to(jump_tab);
  1505.          show_in_various_formats(word, column => jump_tab);
  1506.          log_new_line;
  1507.       end show_word;
  1508.
  1509.       procedure show_word_group (first, last  : KDF9.address) is
  1510.          last_address : KDF9.address := first;
  1511.          this_word, last_word : KDF9.word;
  1512.       begin
  1513.          if last in first | 0 then
  1514.             show_word(last);
  1515.             return;
  1516.          end if;
  1517.          this_word := fetch_word(first);
  1518.          last_word := this_word;
  1519.          show_word(first);
  1520.          for address in first+1 .. last-1 loop
  1521.             this_word := fetch_word(address);
  1522.             if this_word = last_word and address = last_address+1 then
  1523.                log_line("==========  ditto  ========");
  1524.             elsif this_word /= last_word then
  1525.                show_word(address);
  1526.                last_word := this_word;
  1527.                last_address := address;
  1528.             end if;
  1529.          end loop;
  1530.          if last > first then
  1531.             show_word(last);
  1532.          end if;
  1533.       end show_word_group;
  1534.
  1535.    begin
  1536.       if first > last then
  1537.          return;
  1538.       end if;
  1539.       BA := 0; -- Ensure that physical store is examined when running in boot mode.
  1540.       log_title("Core store interpreted as 48-bit words:");
  1541.       show_word_group(first, last);
  1542.       log_new_line;
  1543.    end show_core_as_word_forms;
  1544.
  1545.    -- Each word of code space is described by a set of flags.
  1546.    -- Flags 0 .. 5 are set iff a jump order has that syllable as target.
  1547.    -- Flag 6 is set if the word is thought to be code, but not a target.
  1548.    -- Flag 7 is set if the word is thought to be addressed as data.
  1549.
  1550.    package word_flags is new generic_sets(member => KDF9.syllable_index);
  1551.    use word_flags;
  1552.
  1553.    is_a_code_word   : constant KDF9.syllable_index := 6;
  1554.    is_a_data_word   : constant KDF9.syllable_index := 7;
  1555.    all_jump_targets : constant word_flags.set := (6|7 => False, others => True);
  1556.
  1557.    analysis_flags   : array (KDF9.code_address) of word_flags.set;
  1558.
  1559.    function "/" (word : KDF9.code_address; flag : KDF9.syllable_index)
  1560.    return Boolean
  1561.    is (analysis_flags(word)/flag);
  1562.
  1563. --         procedure show_flags (a : in KDF9.code_address) is
  1564. --         begin
  1565. --            log_line(a'Image & ":  "
  1566. --             & (if analysis_flags(a)(is_a_code_word) then "CODE " else "DATA ")
  1567. --             & (if analysis_flags(a)(0) then "T" else " ")
  1568. --             & (if analysis_flags(a)(1) then "T" else " ")
  1569. --             & (if analysis_flags(a)(2) then "T" else " ")
  1570. --             & (if analysis_flags(a)(3) then "T" else " ")
  1571. --             & (if analysis_flags(a)(4) then "T" else " ")
  1572. --             & (if analysis_flags(a)(5) then "T" else " ")
  1573. --              );
  1574. --         end show_flags;
  1575.
  1576.    function is_a_jump_target (the_point : in KDF9.syllable_address)
  1577.    return Boolean
  1578.    is (analysis_flags(the_point.code_address)/the_point.syllable_index);
  1579.
  1580.    function is_a_jump_target (the_operand : in KDF9.code_address)
  1581.    return Boolean
  1582.    is ((analysis_flags(the_operand) and all_jump_targets) /= empty_set);
  1583.
  1584.    procedure clear_all_analysis_flags is
  1585.    begin
  1586.       analysis_flags := (others => empty_set);
  1587.    end clear_all_analysis_flags;
  1588.
  1589.    procedure unmark_as_a_data_word (the_operand : in KDF9.code_address) is
  1590.    begin
  1591.       analysis_flags(the_operand)(is_a_data_word) := False;
  1592.    end unmark_as_a_data_word;
  1593.
  1594.    procedure unmark_as_a_code_word (the_operand : in KDF9.code_address) is
  1595.    begin
  1596.       analysis_flags(the_operand)(is_a_code_word) := False;
  1597.    end unmark_as_a_code_word;
  1598.
  1599.    procedure mark_as_a_code_word (the_operand : in KDF9.code_address) is
  1600.    begin
  1601.       analysis_flags(the_operand)(is_a_code_word) := True;
  1602.       unmark_as_a_data_word(the_operand);
  1603.    end mark_as_a_code_word;
  1604.
  1605.    procedure mark_as_a_jump_target (the_point : in KDF9.syllable_address) is
  1606.    begin
  1607.       analysis_flags(the_point.code_address)(the_point.syllable_index) := True;
  1608.       mark_as_a_code_word(the_point.code_address);
  1609.    end mark_as_a_jump_target;
  1610.
  1611.    procedure mark_as_a_data_word (the_operand : in KDF9.code_address) is
  1612.    begin
  1613.       analysis_flags(the_operand)(is_a_data_word) := True;
  1614.       unmark_as_a_code_word(the_operand);
  1615.    end mark_as_a_data_word;
  1616.
  1617.    procedure mark_all_code_blocks (the_beginning : in KDF9.syllable_address) is
  1618.       address : KDF9.syllable_address := the_beginning;
  1619.    begin
  1620.       if address.code_address < 2 then
  1621.          return;  -- We already know this is code.
  1622.       end if;
  1623.       if address.syllable_index > 5 then
  1624.          return;  -- We have blundered into non-code words.
  1625.       end if;
  1626.       if is_a_jump_target(address) then
  1627.          return;  -- We have already handled this word.
  1628.       end if;
  1629.       -- Mark the first syllable of the block.
  1630.       mark_as_a_jump_target(the_beginning);
  1631.       -- Mark the destinations of all jumps in the block as code.
  1632.       loop
  1633.       -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1634.       exit when address.code_address = 8191;
  1635.          set_NIA_to(address);
  1636.          decode_the_next_order;
  1637.          if is_an_invalid_order(INS)                                                  or else
  1638.                (address.code_address/is_a_data_word and address.syllable_index = 0) then
  1639.             mark_as_a_data_word(address.code_address);
  1640.             return;
  1641.          else
  1642.             -- Assuming a valid code word, act on it.
  1643.             mark_as_a_code_word(address.code_address);
  1644.             case INS.kind is
  1645.                when normal_jump_order =>
  1646.                   if not is_a_jump_target(INS.target) then
  1647.                      -- Mark the jump's destination recursively.
  1648.                      -- N.B. EXIT is actioned only if it is of EXIT ARr type.
  1649.                      mark_all_code_blocks(INS.target);
  1650.                   end if;
  1651.                   increment_by_3(address);
  1652.                   if is_an_unconditional_jump(INS) then
  1653.                      -- What follows is either data or a jump target.
  1654.                      return;
  1655.                   end if;
  1656.                when one_syllable_order =>
  1657.                   increment_by_1(address);
  1658.                   if INS.order.syllable_0 = 0 then
  1659.                      -- This assumes that a valid code word does not contain DUMMY0.
  1660.                      -- That may not be true of code generated by KAlgol.
  1661.                      return;
  1662.                   end if;
  1663.                when two_syllable_order =>
  1664.                   if INS.compressed_opcode = JCqNZS then
  1665.                      -- Mark the preceding word.
  1666.                      mark_as_a_jump_target((address.code_address-1, 0));
  1667.                   end if;
  1668.                   increment_by_2(address);
  1669.                when data_access_order =>
  1670.                   increment_by_3(address);
  1671.             end case;
  1672.          end if;
  1673.       end loop;
  1674.    end mark_all_code_blocks;
  1675.
  1676.    procedure mark_all_data_blocks (the_beginning : in KDF9.syllable_address) is
  1677.       address : KDF9.syllable_address := the_beginning;
  1678.    begin
  1679.       if address.syllable_index > 5 then
  1680.          return;  -- We have blundered into non-code words.
  1681.       end if;
  1682.
  1683.    the_code_block_handler: loop
  1684.       -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1685.    exit the_code_block_handler when address.code_address = 8191;
  1686.
  1687.          -- Deal with the possibility that we actually have a word of instruction code.
  1688.          set_NIA_to(address);
  1689.          decode_the_next_order;
  1690.
  1691.          if (is_an_invalid_order(INS)                         or else
  1692.                address.code_address/is_a_data_word)     and then
  1693.                   not (address.code_address/is_a_code_word) then
  1694.
  1695.             -- This word is data: make sure it is not designated as code;
  1696.             --    and find the start of the next code block.
  1697.             for a in address.code_address .. 8190 loop
  1698.                address := (a, 0);
  1699.             exit when is_a_jump_target(a);
  1700.                unmark_as_a_code_word(a);
  1701.                mark_as_a_data_word(a);
  1702.             end loop;
  1703.    exit the_code_block_handler when address.code_address = 8190;
  1704.             -- Find the syllable at which the block starts.
  1705.             for s in KDF9.syllable_index'(0) .. 5 loop
  1706.                address.syllable_index := s;
  1707.             exit when is_a_jump_target(address);
  1708.             end loop;
  1709.
  1710.          else
  1711.
  1712.             -- We have a order, so act on it.
  1713.             case INS.kind is
  1714.                when data_access_order =>
  1715.                   -- Note the operand word as data, not code.
  1716.                   if INS.operand < 8192 then
  1717.                      declare
  1718.                         operand : constant KDF9.code_address
  1719.                                 := KDF9.code_address(INS.operand);
  1720.                      begin
  1721.                         if INS.compressed_opcode /= KDF9.decoding.SET and then
  1722.                               not is_a_jump_target(operand)               then
  1723.                            mark_as_a_data_word(operand);
  1724.                         end if;
  1725.                      end;
  1726.                   end if;
  1727.                   increment_by_3(address);
  1728.                when one_syllable_order =>
  1729.                   increment_by_1(address);
  1730.                when two_syllable_order =>
  1731.                   increment_by_2(address);
  1732.                when normal_jump_order =>
  1733.                   increment_by_3(address);
  1734.             end case;
  1735.          end if;
  1736.
  1737.       exit the_code_block_handler when address.code_address = KDF9.code_address'Last;
  1738.       end loop the_code_block_handler;
  1739.    end mark_all_data_blocks;
  1740.
  1741.    procedure reset_wrong_data_marks (the_beginning : in KDF9.syllable_address) is
  1742.       address : KDF9.syllable_address := the_beginning;
  1743.       locus   : KDF9.code_address;
  1744.    begin
  1745.       if address.syllable_index > 5 then
  1746.          return;  -- We have blundered into non-code words.
  1747.       end if;
  1748.       -- Unmark the first instruction of the block.
  1749.       unmark_as_a_data_word(address.code_address);
  1750.
  1751.       -- Unmark data marks on destinations of jumps.
  1752.       loop
  1753.       -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1754.       exit when address.code_address = 8191;
  1755.          set_NIA_to(address);
  1756.          decode_the_next_order;
  1757.
  1758.          if is_an_invalid_order(INS)                          or else
  1759.                address.code_address/is_a_data_word       or else
  1760.                   not (address.code_address/is_a_code_word) then
  1761.             -- We have reached the end of the code block.
  1762.             return;
  1763.
  1764.          else
  1765.
  1766.             -- We have a valid order, so act on it.
  1767.             case INS.kind is
  1768.                when normal_jump_order =>
  1769.                   locus := address.code_address;
  1770.                   increment_by_3(address);
  1771.                   if INS.target.code_address/is_a_data_word    then
  1772.                      -- UNmark the jump's destination recursively.
  1773.                      reset_wrong_data_marks(INS.target);
  1774.                   end if;
  1775.                   if INS.compressed_opcode /= Jr          and then
  1776.                         INS.compressed_opcode /= EXIT_n   and then
  1777.                            locus /= address.code_address then
  1778.                      -- The order flows on, so the next word cannot be data.
  1779.                      unmark_as_a_data_word(address.code_address);
  1780.                   elsif not (address.code_address/is_a_data_word) then
  1781.                      -- The next syllable starts a block, iff it is not the end of a block.
  1782.                      set_NIA_to(address);
  1783.                      decode_the_next_order;
  1784.                      if not is_an_invalid_order(INS) then
  1785.                         mark_as_a_jump_target(address);
  1786.                      end if;
  1787.                   end if;
  1788.                when one_syllable_order =>
  1789.                   increment_by_1(address);
  1790.                when two_syllable_order =>
  1791.                   increment_by_2(address);
  1792.                when data_access_order =>
  1793.                   increment_by_3(address);
  1794.             end case;
  1795.          end if;
  1796.       exit when address.code_address = KDF9.code_address'Last;
  1797.       end loop;
  1798.    end reset_wrong_data_marks;
  1799.
  1800.    procedure mark_the_words_reachable_from (address : in KDF9.syllable_address) is
  1801.       start_point : KDF9.syllable_address;
  1802.    begin
  1803.       mark_as_a_jump_target(address);
  1804.       set_NIA_to(address);
  1805.       decode_the_next_order;
  1806.       if INS.kind = normal_jump_order then
  1807.          start_point := INS.target;
  1808.          mark_all_code_blocks(start_point);
  1809.          mark_all_data_blocks(start_point);
  1810.          reset_wrong_data_marks(start_point);
  1811.       end if;
  1812.    end mark_the_words_reachable_from;
  1813.
  1814.    procedure mark_all_jump_targets (start_point : in KDF9.syllable_address) is
  1815.       address : KDF9.syllable_address := start_point;
  1816.    begin
  1817.       mark_as_a_jump_target(address);
  1818.       loop
  1819.       exit when address.code_address > 8190;
  1820.       exit when address.code_address/is_a_data_word;
  1821.          set_NIA_to(address);
  1822.          decode_the_next_order;
  1823.          case INS.kind is
  1824.             when data_access_order =>
  1825.                increment_by_3(address);
  1826.             when one_syllable_order =>
  1827.                increment_by_1(address);
  1828.             when two_syllable_order =>
  1829.                increment_by_2(address);
  1830.             when normal_jump_order =>
  1831.                if INS.kind = normal_jump_order then
  1832.                   mark_as_a_jump_target(INS.target);
  1833.                end if;
  1834.                increment_by_3(address);
  1835.          end case;
  1836.       end loop;
  1837.    end mark_all_jump_targets;
  1838.
  1839.    procedure do_symbol_table_based_markup is
  1840.       subtype own is KDF9.code_address;
  1841.       V_list : V_definition_list renames V_store_base(0..last_P_number);
  1842.       non_Vs : non_V_store_table renames the_WYZ_table;
  1843.    begin
  1844.       for e in V_list'First .. V_list'Last-1 loop
  1845.          -- Mark the V stores of P[e].
  1846.          for a in own(V_list(e).V_address) .. own(V_list(e).P_address-1) loop
  1847.             mark_as_a_data_word(own(a));
  1848.          end loop;
  1849.          -- Mark the order words of P[e].
  1850.          for a in own(V_list(e).P_address) .. own(V_list(e+1).V_address-1) loop
  1851.             mark_as_a_code_word(own(a));
  1852.          end loop;
  1853.          mark_all_jump_targets((own(V_list(e).P_address), 0));
  1854.       end loop;
  1855.       -- Mark the global data words.
  1856.       for a in own(non_Vs.W_base) .. own(KDF9.address'Min(8191, non_Vs.Z_base)) loop
  1857.          mark_as_a_data_word(own(a));
  1858.       end loop;
  1859.    end do_symbol_table_based_markup;
  1860.
  1861.
  1862.    procedure markup_a_problem_program is
  1863.    begin
  1864.       if the_initial_jump_was_corrupted then
  1865.          -- We cannot sensibly locate the order words using E0  ...
  1866.          log_new_line;
  1867.          log_line("The initial jump, in E0U, has been corrupted!");
  1868.          log_new_line;
  1869.          show_core_as_syllables((0, syllable_index => 0), (0, syllable_index => 5));
  1870.          --  ... so restore it to the value it had on loading.
  1871.          restore_the_initial_jump;
  1872.          log_line("E0U has been restored to the value it had on loading.");
  1873.          log_new_line;
  1874.       end if;
  1875.
  1876.       if last_P_number = 0 then
  1877.          -- There is no symbol table, so we have to do a flow analysis.
  1878.          -- Mark all orders reachable from the initial jump in E0 and the restart jumps in E4.
  1879.
  1880.          mark_the_words_reachable_from((0, syllable_index => 0));
  1881.          mark_the_words_reachable_from((4, syllable_index => 0));
  1882.          mark_the_words_reachable_from((4, syllable_index => 3));
  1883.
  1884.          -- Mark the words between E0 and P0 as data, skipping E4.
  1885.          mark_as_a_data_word(1);
  1886.          mark_as_a_data_word(2);
  1887.          mark_as_a_data_word(3);
  1888.          set_NIA_to((0, syllable_index => 0));
  1889.          decode_the_next_order;
  1890.          for d in 5 .. INS.target.code_address-1 loop
  1891.             mark_as_a_data_word(d);
  1892.          end loop;
  1893.
  1894.       else
  1895.          -- We have a symbol table, enable 100% accurate markup.
  1896.          do_symbol_table_based_markup;
  1897.          mark_as_a_code_word(0);
  1898.          mark_as_a_data_word(1);
  1899.          mark_as_a_data_word(2);
  1900.          mark_as_a_data_word(3);
  1901.          mark_as_a_code_word(4);
  1902.          mark_as_a_data_word(5);
  1903.          mark_as_a_data_word(6);
  1904.          mark_as_a_data_word(7);
  1905.       end if;
  1906.
  1907.       the_program_has_been_analysed := True;
  1908.    end markup_a_problem_program;
  1909.
  1910.    -- This analysis assumes that the Director has much the same structure as KKT40E007UPU.
  1911.    procedure markup_a_Director (pre_run : in Boolean) is
  1912.    begin
  1913.       the_program_has_been_analysed := False;
  1914.       BA := 0;  -- Director starts at physical word 0.
  1915.
  1916.       -- It does not have a jump in E0U, unlike problem programs.
  1917.       -- Instead it has a fixed sequence of orders to reset the hardware.
  1918.       -- Before intialization, it is: K4; SHL+63; =+Q0; with the code: #3740416437675016.
  1919.       -- After intialization,  it is: Q0; SHL+63; =+Q0; with the code: #3620716437675016.
  1920.
  1921.        -- Check that we do actually have a Director to examine.
  1922.
  1923.       if pre_run then
  1924.          if fetch_word(0) /= 8#3740416437675016# then
  1925.             log_line("The loaded program is not a Director bootstrap!");
  1926.             return;
  1927.          else
  1928.             log_line("The loaded program is a Director bootstrap.");
  1929.          end if;
  1930.
  1931.          -- The jumps in E2 and E4 are absent until after Director's initialzation,
  1932.          --    so they are not present in a pre-run state.
  1933.          -- All 9 words of the bootstrap are filled with instructions.
  1934.          for w in code_address'(0) .. 8 loop
  1935.             mark_as_a_code_word(w);
  1936.          end loop;
  1937.          mark_as_a_jump_target((0, 0));
  1938.          the_program_has_been_analysed := True;
  1939.          return;
  1940.       end if;
  1941.
  1942.       if fetch_word(0) /= 8#3620716437675016# then
  1943.          log_line("The loaded program is not a Director!");
  1944.          return;
  1945.       else
  1946.          log_line("The loaded program is a Director.");
  1947.       end if;
  1948.
  1949.       -- An initialised Director has a number of jumps in words 2 and 4, but not word 0.
  1950.       -- Give up if these are absent.
  1951.
  1952.       set_NIA_to((2, syllable_index => 0));
  1953.       decode_the_next_order;
  1954.       if INS.kind /= normal_jump_order then
  1955.          log_line("An expected jump, in E2U, has not been found!");
  1956.          return;
  1957.       end if;
  1958.       mark_as_a_jump_target((2, syllable_index => 0));
  1959.       mark_the_words_reachable_from((2, syllable_index => 0));
  1960.       mark_as_a_jump_target(INS.target);
  1961.       set_NIA_to((4, syllable_index => 0));
  1962.       decode_the_next_order;
  1963.       if INS.kind /= normal_jump_order then
  1964.          log_line("An expected jump, in E4U, has not been found!");
  1965.          return;
  1966.       end if;
  1967.       mark_as_a_jump_target((4, syllable_index => 0));
  1968.       mark_the_words_reachable_from((4, syllable_index => 0));
  1969.       mark_as_a_jump_target(INS.target);
  1970.
  1971.       set_NIA_to((4, syllable_index => 3));
  1972.       decode_the_next_order;
  1973.       if INS.kind /= normal_jump_order then
  1974.          log_line("An expected jump, in E4L, has not been found!");
  1975.          return;
  1976.       end if;
  1977.       mark_as_a_jump_target((4, syllable_index => 3));
  1978.       mark_the_words_reachable_from((4, syllable_index => 3));
  1979.       mark_as_a_jump_target(INS.target);
  1980.
  1981.       -- E0 is marked because interrupts cause a jump to it, in effect.
  1982.       mark_as_a_jump_target((0, syllable_index => 0));
  1983.
  1984.       -- Mark E3 and E5 through AP0 - 1 as data words.
  1985.       mark_as_a_data_word(3);
  1986.       set_NIA_to((2, 0));
  1987.       decode_the_next_order;
  1988.       for d in 5 .. INS.target.code_address-1 loop
  1989.          mark_as_a_data_word(d);
  1990.       end loop;
  1991.
  1992.       the_program_has_been_analysed := True;
  1993.    end markup_a_Director;
  1994.
  1995.    procedure mark_all_code_blocks_and_data_blocks (pre_run : in Boolean) is
  1996.    begin
  1997.       clear_all_analysis_flags;
  1998.       if the_execution_mode = boot_mode  then
  1999.          markup_a_Director(pre_run);
  2000.       else
  2001.          markup_a_problem_program;
  2002.       end if;
  2003.    end mark_all_code_blocks_and_data_blocks;
  2004.
  2005.    procedure show_core_as_Usercode (first, last  : in KDF9.syllable_address;
  2006.                                     octal_option : in Boolean) is
  2007.
  2008.       six_DUMMIES : constant KDF9.word := 8#0360741703607417#;
  2009.       prev_word   : KDF9.word := 8#0706050403020100#; -- invalid opcodes
  2010.       comparator  : KDF9.word := prev_word;
  2011.       address     : KDF9.syllable_address;
  2012.       this_word   : KDF9.word;
  2013.
  2014.       procedure show_a_block_of_orders (address : in out KDF9.syllable_address) is
  2015.
  2016.          function is_a_store_order (decoded : KDF9.decoded_order)
  2017.          return Boolean
  2018.          is (
  2019.              if decoded.kind = one_syllable_order then
  2020.                 False
  2021.              elsif decoded.kind = two_syllable_order then
  2022.                 (
  2023.                  case decoded.compressed_opcode is
  2024.                    when TO_MkMq   | TO_MkMqQ
  2025.                       | TO_MkMqH  | TO_MkMqQH
  2026.                       | TO_MkMqN  | TO_MkMqQN
  2027.                       | TO_MkMqHN | TO_MkMqQHN
  2028.                       | TO_Kq     | TO_LINK    => True,
  2029.                    when others                 => False
  2030.                 )
  2031.              elsif decoded.kind = data_access_order then
  2032.                 (
  2033.                  case decoded.compressed_opcode is
  2034.                     when TO_EaMq | TO_EaMqQ => True,
  2035.                     when others             => False
  2036.                 )
  2037.              else
  2038.                 False
  2039.             );
  2040.
  2041.          procedure set_line_at_minimum (tab : in Natural) is
  2042.          begin
  2043.             if panel_logger.column < tab then
  2044.                tab_log_to(tab);
  2045.             end if;
  2046.          end set_line_at_minimum;
  2047.
  2048.          procedure set_line_at (tab : in Natural) is
  2049.          begin
  2050.             if panel_logger.column > tab then
  2051.                log_new_line;
  2052.             end if;
  2053.             if panel_logger.column < tab then
  2054.                tab_log_to(tab);
  2055.             end if;
  2056.          end set_line_at;
  2057.
  2058.          procedure set_at_new_line is
  2059.          begin
  2060.             if panel_logger.column > 1 then
  2061.                log_new_line;
  2062.             end if;
  2063.          end set_at_new_line;
  2064.
  2065.          last_nz_location : KDF9.syllable_address;
  2066.
  2067.       begin -- show_a_block_of_orders
  2068.          this_word := fetch_word(KDF9.address(address.code_address));
  2069.
  2070.          -- Handle data words and dummy words.
  2071.          if address.code_address/is_a_data_word then
  2072.             set_at_new_line;
  2073.          elsif this_word in not 0 | 0 | six_DUMMIES then
  2074.             -- The word is not worth logging.  Step on.
  2075.             address := (address.code_address+1, 0);
  2076.             return;
  2077.          end if;
  2078.
  2079.          loop
  2080.             if address.code_address/is_a_data_word then
  2081.                last_nz_location := address;
  2082.
  2083.                -- Display a line of data.
  2084.                log(oct_or_dec_of(address, octal_option) & ": ");
  2085.                set_line_at(jump_tab);
  2086.                show_in_various_formats(fetch_word(KDF9.address(address.code_address)),
  2087.                                        column => jump_tab);
  2088.                log_new_line;
  2089.
  2090.                -- Skip over any following zero words (DUMMY0 or uninitialized V stores).
  2091.                loop
  2092.                   if address.code_address = last.code_address then
  2093.                      -- The whole block has been processed.
  2094.                      return;
  2095.                   end if;
  2096.                   address := (address.code_address+1, 0);
  2097.                exit when fetch_word(KDF9.address(address.code_address)) /= 0;
  2098.                end loop;
  2099.                if address.code_address > last_nz_location.code_address+1 then
  2100.                   log("========  zeros  ========");
  2101.                   log_new_line;
  2102.                end if;
  2103.             else
  2104.                -- We have found an instruction word.
  2105.                log_new_line;
  2106.          exit;
  2107.             end if;
  2108.          end loop;
  2109.
  2110.          -- Handle instruction words.
  2111.          loop
  2112.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  2113.          exit when address.code_address = 8191;
  2114.             this_word := fetch_word(KDF9.address(address.code_address));
  2115.
  2116.             -- Suppress output of more than 1 of a block of equal values.
  2117.             if this_word = comparator and this_word = prev_word then
  2118.                -- The word is not worth logging.  Step on.
  2119.                address := (address.code_address+1, 0);
  2120.                return;
  2121.             end if;
  2122.
  2123.             if this_word in not 0 | 0 | six_DUMMIES then
  2124.                -- Take this word as the new basis for comparison.
  2125.                comparator := this_word;
  2126.             end if;
  2127.
  2128.             -- This updates the Instruction word buffers.  Nasty side effect that has to be undone!
  2129.             set_NIA_to(address);
  2130.             decode_the_next_order;
  2131.             if is_an_invalid_order(INS) then
  2132.                -- The word is not worth logging.  Step on.
  2133.                address := (address.code_address+1, 0);
  2134.                return;
  2135.             end if;
  2136.
  2137.             if is_a_jump_target(address) then
  2138.                -- Jumps go at the start of a fresh line for best visibility.
  2139.                -- Label the jump with its address at the start of the line for easy reference.
  2140.                set_at_new_line;
  2141.                log(oct_or_dec_of(address, octal_option) & ": ");
  2142.                log_new_line;
  2143.             end if;
  2144.
  2145.             -- Set the tab position appropriately for the order type.
  2146.             case INS.kind is
  2147.                when one_syllable_order | data_access_order =>
  2148.                   set_line_at_minimum(first_tab);
  2149.                when two_syllable_order =>
  2150.                   case INS.compressed_opcode is
  2151.                      when JCqNZS =>
  2152.                         set_line_at(jump_tab);
  2153.                      when CT_PMB_PMC_BUSY_Qq
  2154.                         | PAR_Qq
  2155.                         | PMF_PMG_Qq
  2156.                         | PIA_PIC_CLO_TLO_Qq
  2157.                         | PIB_PID_Qq
  2158.                         | PIE_PIG_Qq
  2159.                         | PIF_PIH_Qq
  2160.                         | POA_POC_POE_POF_PMH_Qq
  2161.                         | POB_POD_Qq
  2162.                         | POG_POL_Qq
  2163.                         | POH_POK_Qq
  2164.                         | PMA_PMK_INT_Qq
  2165.                         | PMA_PMK_INT_Qq+1
  2166.                         | PMD_PME_PML_Qq
  2167.                         | PMD_PME_PML_Qq+1 =>
  2168.                         set_line_at(first_tab);
  2169.                      when TO_Kq =>
  2170.                         set_line_at(jump_tab);
  2171.                      when others =>
  2172.                         if panel_logger.column < first_tab then
  2173.                            set_line_at_minimum(first_tab);
  2174.                         end if;
  2175.                   end case;
  2176.                when normal_jump_order =>
  2177.                   set_line_at(jump_tab);
  2178.             end case;
  2179.
  2180.             -- Show the order in pseudo-Usercode format.
  2181.             log(the_full_name_of(INS, octal_option));
  2182.             log(closer(INS, address, octal_option));
  2183.
  2184.             case INS.kind is
  2185.                when one_syllable_order =>
  2186.                   increment_by_1(address);
  2187.                when two_syllable_order =>
  2188.                   increment_by_2(address);
  2189.                when normal_jump_order | data_access_order =>
  2190.                   increment_by_3(address);
  2191.             end case;
  2192.
  2193.             if address.code_address = last.code_address then
  2194.                -- All done with this block.
  2195.                log_new_line;
  2196.                return;
  2197.             end if;
  2198.
  2199.             if (address.code_address+1)/is_a_data_word then
  2200.                -- We have reached the end of the orders and are about to run into data.
  2201.                return;
  2202.             end if;
  2203.
  2204.             if is_a_store_order(INS)                                                 or else
  2205.                   (INS.kind = two_syllable_order and INS.compressed_opcode = JCqNZS) or else
  2206.                      INS.kind = normal_jump_order                                    or else
  2207.                         panel_logger.column > last_column                               then
  2208.                -- Make store to core and jump orders end their line for best visibility.
  2209.                log_new_line;
  2210.             elsif this_word = comparator and this_word /= prev_word then
  2211.                -- Display the placeholder of a suppressed group of equal words.
  2212.                log_new_line;
  2213.                log_line("==========  #"
  2214.                       & oct_of(KDF9.syllable(this_word and 255))
  2215.                       & "  ==========");
  2216.                address := (address.code_address+1, 0);
  2217.                if address.code_address > last.code_address or else
  2218.                      address.code_address/is_a_data_word           then
  2219.                   -- We have reached the end of the orders or are about to run into data.
  2220.                   return;
  2221.                end if;
  2222.             end if;
  2223.             prev_word := this_word;
  2224.
  2225.          end loop;
  2226.
  2227.       end show_a_block_of_orders;
  2228.
  2229.    begin -- show_core_as_Usercode
  2230.       if not the_program_has_been_analysed then
  2231.          mark_all_code_blocks_and_data_blocks(pre_run => False);
  2232.       end if;
  2233.       if the_program_has_been_analysed then
  2234.          log_line("Core store interpreted as instructions.");
  2235.           -- Ensure that physical store is examined when running in boot mode.
  2236.          BA := 0;
  2237.          address := first;
  2238.          loop
  2239.             show_a_block_of_orders(address);
  2240.             exit when address.code_address >= last.code_address;
  2241.          end loop;
  2242.          log_new_line;
  2243.          log_rule;
  2244.       else
  2245.          log_line(" ... Core store cannot be interpreted as instructions!");
  2246.          log_new_line;
  2247.       end if;
  2248.
  2249.       -- Restore NIA to its correct value for execution.
  2250.       set_NIA_to((0, syllable_index => 0));
  2251.    end show_core_as_Usercode;
  2252.
  2253.    procedure show_core_as_syllables (first, last  : KDF9.syllable_address) is
  2254.
  2255.       address     :   KDF9.syllable_address;
  2256.
  2257.       procedure show_a_block is
  2258.
  2259.          procedure set_line_at (tab : Natural) is
  2260.          begin  -- set_line_at
  2261.             if panel_logger.column > tab then
  2262.                log_new_line;
  2263.             end if;
  2264.             if panel_logger.column < tab then
  2265.                tab_log_to(tab);
  2266.             end if;
  2267.          end set_line_at;
  2268.
  2269.       begin  -- show_a_block
  2270.          loop
  2271.             if address.syllable_index = 0 then
  2272.                log_new_line;
  2273.                log(oct_of(address) & ": ");
  2274.                set_line_at(jump_tab);
  2275.             end if;
  2276.             log(oct_of(fetch_syllable(address)) &  "; ");
  2277.             increment_by_1(address);
  2278.          exit when address.code_address > last.code_address;
  2279.          end loop;
  2280.          log_new_line;
  2281.       end show_a_block;
  2282.
  2283.     begin  -- show_core_as_syllables
  2284.        BA := 0; -- Ensure that physical store is examined when running in boot mode.
  2285.       log_line("Core store interpreted as order syllables.");
  2286.       address := first;
  2287.       loop
  2288.          show_a_block;
  2289.          exit when address.code_address > last.code_address;
  2290.       end loop;
  2291.       log_new_line;
  2292.       log_rule;
  2293.    end show_core_as_syllables;
  2294.
  2295.    procedure poke (address    : in KDF9.address;
  2296.                    sub_word   : in sub_word_flag;
  2297.                    position   : in KDF9.address;
  2298.                    value      : in KDF9.word) is
  2299.    begin
  2300.       case sub_word is
  2301.          when 'W' | 'w' =>
  2302.             store_word(value, address);
  2303.          when 'U' | 'u' =>
  2304.             store_halfword(value*2**24, address, 0);
  2305.          when 'L' | 'l' =>
  2306.             store_halfword(value*2**24, address, 1);
  2307.          when 'S' | 's' =>
  2308.             store_syllable(KDF9.syllable(value), address, KDF9.syllable_index(position));
  2309.          when 'C' | 'c' =>
  2310.             store_symbol(KDF9_char_sets.symbol(value), address, KDF9_char_sets.symbol_index(position));
  2311.       end case;
  2312.    end poke;
  2313.
  2314. end state_display;

Compiling: ../Source/state_display.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Provide the comprehensive machine-state display panel KDF9 never had.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with dumping;
    18. with KDF9;
    19.
    20. use  dumping;
    21. use  KDF9;
    22.
    23. package state_display is
    24.
    25.    procedure show_all_prerun_dump_areas;
    26.
    27.    procedure show_CIA_and_NIA;
    28.
    29.    procedure show_V_and_T;
    30.
    31.    procedure show_NEST;
    32.
    33.    procedure show_SJNS;
    34.
    35.    procedure show_IO_register (the_Q_register : in KDF9.Q_register;
    36.                                width          : in Positive := 8;
    37.                                for_DR,
    38.                                for_FD,
    39.                                for_FH,
    40.                                for_seek,
    41.                                for_OUT         : in Boolean  := False);
    42.
    43.    procedure show_Q_register (the_Q_register : in KDF9.Q_register;
    44.                               width          : in Positive := 8);
    45.
    46.    procedure show_Q_store;
    47.
    48.    procedure show_registers;
    49.
    50.    procedure show_execution_context;
    51.
    52.    procedure long_witness;
    53.
    54.    procedure short_witness;
    55.
    56.    procedure log_an_external_trace_header (caption : in String := "");
    57.
    58.    procedure log_to_external_trace
    59.       with Inline => False;
    60.
    61.    procedure show_progress;
    62.
    63.    procedure show_Director_registers;
    64.
    65.    procedure show_retrospective_traces;
    66.
    67.    procedure show_current_state;
    68.
    69.    procedure show_final_state (because : String);
    70.
    71.    procedure mark_all_code_blocks_and_data_blocks (pre_run : in Boolean);
    72.
    73.    the_program_has_been_analysed : Boolean := False;
    74.
    75.    procedure show_core_as_word_forms (first, last : in KDF9.address);
    76.
    77.    procedure show_core_as_syllables (first, last : in KDF9.syllable_address);
    78.
    79.    procedure show_core_as_Usercode (first, last  : in KDF9.syllable_address;
    80.                                     octal_option : in Boolean);
    81.
    82.    procedure show_core_in_print_code (first, last : in KDF9.address);
    83.
    84.    procedure show_core_in_card_code (first, last : in KDF9.address);
    85.
    86.    procedure show_core_in_tape_code (first, last : in KDF9.address);
    87.
    88.    procedure show_core_in_case_normal (first, last : in KDF9.address);
    89.
    90.    procedure show_core_in_case_shift (first, last : in KDF9.address);
    91.
    92.    procedure show_core_in_Latin_1 (first, last : in KDF9.address);
    93.
    94.    -- poke is included here as it has the same relationship to dumping as show_core_*.
    95.    procedure poke (address    : in KDF9.address;
    96.                    sub_word   : in sub_word_flag;
    97.                    position   : in KDF9.address;
    98.                    value      : in KDF9.word);
    99.
   100.    -- Take note that an OUT 2 or OUT 0 has been obeyed.
   101.    procedure notify_state_display_of_final_ICR;
   102.
   103. end state_display;

 2314 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-fast.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Emulation of the common functionality of a KDF9 "fast", i.e. word-by-word, devices.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.fast is
    18.
    19.    overriding
    20.    function is_open (the_buffer : fast.device)
    21.    return Boolean
    22.    is (the_buffer.stream.is_open);
    23.
    24.    overriding
    25.    procedure add_in_the_IO_CPU_time (the_buffer  : in fast.device;
    26.                                      bytes_moved : in KDF9.word) is
    27.       pragma Unreferenced(the_buffer);
    28.    begin
    29.       the_CPU_delta := the_CPU_delta + KDF9.us(bytes_moved + 7) / 8 * 6; -- 6µs/word
    30.    end add_in_the_IO_CPU_time;
    31.
    32. end IOC.fast;

Compiling: ../Source/ioc-fast.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Emulation of the common functionality of a KDF9 "fast", i.e. word-by-word, devices.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. private with tracing;
    18.
    19. package IOC.fast is
    20.
    21.    --
    22.    -- This is the root type for all fast I/O device types.
    23.    --
    24.
    25.    type device is abstract new IOC.device with private;
    26.
    27. private
    28.
    29.    use tracing; pragma Warnings(Off, tracing);
    30.
    31.    type device is abstract new IOC.device with
    32.       record
    33.          switch_time,
    34.          latency_time,
    35.          elapsed_time  : KDF9.us := 0;
    36.          word_count,
    37.          switch_count,
    38.          latency_count : KDF9.word := 0;
    39.       end record;
    40.
    41.    overriding
    42.    function is_open (the_buffer : fast.device)
    43.    return Boolean;
    44.
    45.    overriding
    46.    procedure add_in_the_IO_CPU_time (the_buffer  : in fast.device;
    47.                                      bytes_moved : in KDF9.word);
    48.
    49. end IOC.fast;

 32 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-dr.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Emulation of a drum store.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.fast.DR is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    function as_DR_command (Q_operand : KDF9.Q_register; for_OUT : Boolean := False)
    22.    return String is
    23.       C, sector, track, drive :KDF9.Q_part;
    24.    begin
    25.       if for_OUT then
    26.          -- There is no buffer number.
    27.          C := Q_operand.C;
    28.       else
    29.          -- Get rid of the buffer number.
    30.          C := Q_operand.C / 16;
    31.       end if;
    32.       drive := C mod drums_per_system;
    33.       C := C  /  drums_per_system;
    34.       sector := C mod sectors_per_track;
    35.       track  := C mod sectors_per_drum / sectors_per_track;
    36.       return "D"
    37.            & dec_of(drive)
    38.            & "T"
    39.            & dec_of(track)
    40.            & "S"
    41.            & dec_of(sector);
    42.    end as_DR_command;
    43.
    44.    -- The host_IO stream for DR0 is used only to open and close the file.
    45.    -- I/O operations for the DR0 file are done with unmediated POSIX system calls.
    46.
    47.    function file_offset (sector_number : DR.drum_index)
    48.    return POSIX.file_position
    49.    is (bytes_per_sector * POSIX.file_position(sector_number));
    50.
    51.    procedure get (the_DR : in out DR.device; s : out sector; the_index : in KDF9.word) is
    52.       result : POSIX.file_position with Unreferenced;
    53.    begin
    54.       result := seek(fd_of(the_DR.stream), file_offset(the_index));
    55.       result := POSIX.file_position(read(fd_of(the_DR.stream), s, bytes_per_sector));
    56.    end get;
    57.
    58.    procedure put (the_DR : in out DR.device; s : in sector; the_index : in KDF9.word) is
    59.       result : POSIX.file_position with Unreferenced;
    60.    begin
    61.       result := seek(fd_of(the_DR.stream), file_offset(the_index));
    62.       result := POSIX.file_position(write(fd_of(the_DR.stream), s, bytes_per_sector));
    63.    end put;
    64.
    65.    overriding
    66.    procedure Initialize (the_DR : in out DR.device) is
    67.    begin
    68.       open(IOC.device(the_DR), rd_wr_mode);
    69.    exception
    70.       when others =>
    71.          trap_operator_error(the_DR.device_name & " cannot be opened for reading and writing");
    72.    end Initialize;
    73.
    74.    procedure keep_house (the_DR        : in out DR.device;
    75.                          transfer_size : in KDF9.word;
    76.                          busy_time     : out KDF9.us;
    77.                          from_core     : Boolean := True) is
    78.       full_sectors  : constant KDF9.word := transfer_size / bytes_per_sector;
    79.       residue       : constant KDF9.word := transfer_size mod bytes_per_sector;
    80.       total_sectors : constant KDF9.word := (if residue /= 0 then 1 else 0) + full_sectors;
    81.       gapping_time  : constant KDF9.us   := short_gap_time * KDF9.us(total_sectors-1)
    82.                                           + long_gap_time  * KDF9.us(total_sectors/sectors_per_track);
    83.    begin
    84.       the_DR.latency_count := the_DR.latency_count + 1;
    85.       the_DR.word_count := the_DR.word_count + transfer_size / 8;
    86.       if from_core then
    87.          add_in_the_IO_CPU_time(the_DR, bytes_moved => transfer_size);
    88.       end if;
    89.       busy_time :=  gapping_time + KDF9.us(transfer_size) * the_DR.quantum;
    90.    end keep_house;
    91.
    92.    procedure update_statistics (the_DR       : in out DR.device;
    93.                                 latency_time : in KDF9.us) is
    94.    begin
    95.       the_DR.latency_time := the_DR.latency_time + latency_time;
    96.    end update_statistics;
    97.
    98.    function angular_position (sector_number : sector_range)
    99.    return KDF9.us
   100.    is (KDF9.us(sector_number mod sectors_per_track * sector_time));
   101.
   102.    function latent_time (index : drum_index)
   103.    return KDF9.us is
   104.       sector_number : constant sector_range := sector_range(index mod sectors_per_track);
   105.       new_angle     : constant KDF9.us      := angular_position(sector_number);
   106.       old_angle     : constant KDF9.us      := the_clock_time mod track_time;
   107.       gap_time      : constant KDF9.us
   108.                     := (if old_angle > critical_time then short_gap_time else long_gap_time);
   109.       offset        : constant KDF9.us
   110.                     := (if   new_angle > old_angle
   111.                         then new_angle - old_angle
   112.                         else new_angle + track_time - old_angle);
   113.    begin
   114.       -- Hypothesis: we can pick up the next complete sector without a full latency delay,
   115.       --    if we are no closer to it than the start of its preceding inter-block gap.
   116.       return (if offset > gap_time then offset else track_time - offset);
   117.    end latent_time;
   118.
   119.    procedure validate_the_sector_number (the_DR : in out DR.device; sector_number : in KDF9.word) is
   120.    begin
   121.       if sector_number > sectors_per_system then
   122.          trap_failing_IO_operation(the_DR, "sector number too big =" & sector_number'Image);
   123.       end if;
   124.    end validate_the_sector_number;
   125.
   126.    function validated_drum_address (the_DR : in out DR.device; C_operand : KDF9.Q_part)
   127.    return KDF9.word is
   128.       result : constant KDF9.word := KDF9.word(C_operand / 16);
   129.    begin
   130.       -- We assume that the least significant 4 bits of the C operand are the buffer number,
   131.       --    that the next 2 bits specify one of 4 drums that can be fitted to the buffer,
   132.       --       and that the rest of the C operand is the sector number.
   133.       -- See the Drum Director KKT02E003UPU listing, routine P143 at label 1 et seq.
   134.       -- Returning C_operand / 16 treats the drums as consecutive sectors.
   135.       validate_the_sector_number(the_DR, result);
   136.       return result;
   137.    end validated_drum_address;
   138.
   139.    procedure increment (word_address : in out KDF9.address;
   140.                         symbol_nr    : in out KDF9_char_sets.symbol_index)
   141.       with Inline => True;
   142.
   143.    procedure increment (word_address : in out KDF9.address;
   144.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   145.    begin
   146.       if symbol_nr < 7 then
   147.          symbol_nr := symbol_nr + 1;
   148.       else
   149.          symbol_nr := 0;
   150.          word_address := word_address + 1;
   151.       end if;
   152.    end increment;
   153.
   154.    a_zero_sector   : constant DR.sector := (others => SP);
   155.
   156.    procedure read_drum (the_DR    : in out DR.device;
   157.                         Q_operand : in KDF9.Q_register) is
   158.       end_address  : constant KDF9.address := Q_operand.M;
   159.       next_address : KDF9.address := Q_operand.I;
   160.       the_sector   : DR.sector := a_zero_sector;
   161.       symbol_nr    : KDF9_char_sets.symbol_index;
   162.       size         : KDF9.word := 0;
   163.       the_index    : KDF9.word;
   164.       latency,
   165.       busy_time    : KDF9.us;
   166.    begin
   167.       check_addresses_and_lockouts(next_address, end_address);
   168.       the_index := validated_drum_address(the_DR, Q_operand.C);
   169.       latency := latent_time(the_index);
   170.       get(the_DR, the_sector, the_index);
   171.    sector_loop:
   172.       loop
   173.          if the_index > DR.drum_index'Last then
   174.             trap_failing_IO_operation(the_DR, "reading more would exceed the storage available");
   175.          end if;
   176.          symbol_nr := 0;
   177.       byte_loop:
   178.          for i in 1 .. bytes_per_sector loop
   179.             if symbol_nr = 0 then
   180.                store_word(0, next_address);
   181.             end if;
   182.             store_symbol(CN_TR(the_sector(i)), next_address, symbol_nr);
   183.             size := size + 1;
   184.          exit byte_loop when next_address = end_address and symbol_nr = 7;
   185.             increment(next_address, symbol_nr);
   186.          end loop byte_loop;
   187.       exit sector_loop when next_address = end_address and symbol_nr = 7;
   188.          validate_the_sector_number(the_DR, the_index);
   189.          get(the_DR, the_sector, the_index);
   190.          the_index := the_index + 1;
   191.       end loop sector_loop;
   192.       keep_house(the_DR, size, busy_time);
   193.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, input_operation);
   194.       update_statistics(the_DR, latency);
   195.       lock_out_relative_addresses(Q_operand);
   196.    end read_drum;
   197.
   198.    overriding
   199.    procedure PIA (the_DR      : in out DR.device;
   200.                   Q_operand   : in KDF9.Q_register;
   201.                   set_offline : in Boolean) is
   202.       pragma Unreferenced(set_offline);
   203.    begin
   204.       validate_transfer(the_DR, Q_operand);
   205.       validate_parity(the_DR);
   206.       read_drum(the_DR, Q_operand);
   207.    end PIA;
   208.
   209.    procedure read_drum_to_EM (the_DR    : in out DR.device;
   210.                               Q_operand : in KDF9.Q_register) is
   211.       end_address  : constant KDF9.address := Q_operand.M;
   212.       next_address : KDF9.address := Q_operand.I;
   213.       the_sector   : DR.sector := a_zero_sector;
   214.       at_EM        : Boolean := False;
   215.       symbol_nr    : KDF9_char_sets.symbol_index;
   216.       size         : KDF9.word := 0;
   217.       the_index    : KDF9.word;
   218.       latency,
   219.       busy_time    : KDF9.us;
   220.    begin
   221.       check_addresses_and_lockouts(next_address, end_address);
   222.       the_index := validated_drum_address(the_DR, Q_operand.C);
   223.       latency := latent_time(the_index);
   224.       get(the_DR, the_sector, the_index);
   225.    sector_loop:
   226.       loop
   227.          if the_index > DR.drum_index'Last then
   228.             trap_failing_IO_operation(the_DR, "reading more would exceed the storage available");
   229.          end if;
   230.          symbol_nr := 0;
   231.       byte_loop:
   232.          for i in 1 .. bytes_per_sector loop
   233.             if symbol_nr = 0 then
   234.                store_word(0, next_address);
   235.             end if;
   236.             store_symbol(CN_TR(the_sector(i)), next_address, symbol_nr);
   237.             size := size + 1;
   238.          at_EM := the_sector(i) = KDF9_char_sets.E_M;
   239.          exit byte_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   240.             increment(next_address, symbol_nr);
   241.          end loop byte_loop;
   242.          exit sector_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   243.          validate_the_sector_number(the_DR, the_index);
   244.          get(the_DR, the_sector, the_index);
   245.          the_index := the_index + 1;
   246.       end loop sector_loop;
   247.       keep_house(the_DR, size, busy_time);
   248.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, input_operation);
   249.       lock_out_relative_addresses(Q_operand);
   250.       update_statistics(the_DR, latency);
   251.    end read_drum_to_EM;
   252.
   253.    overriding
   254.    procedure PIB (the_DR      : in out DR.device;
   255.                   Q_operand   : in KDF9.Q_register;
   256.                   set_offline : in Boolean) is
   257.        pragma Unreferenced(set_offline);
   258.   begin
   259.       validate_transfer(the_DR, Q_operand);
   260.       validate_parity(the_DR);
   261.       read_drum_to_EM(the_DR, Q_operand);
   262.    end PIB;
   263.
   264.    overriding
   265.    procedure PIC (the_DR      : in out DR.device;
   266.                   Q_operand   : in KDF9.Q_register;
   267.                   set_offline : in Boolean) is
   268.    begin
   269.       PIA(the_DR, Q_operand, set_offline);
   270.    end PIC;
   271.
   272.    overriding
   273.    procedure PID (the_DR      : in out DR.device;
   274.                   Q_operand   : in KDF9.Q_register;
   275.                   set_offline : in Boolean) is
   276.    begin
   277.       PIB(the_DR, Q_operand, set_offline);
   278.    end PID;
   279.
   280.    overriding
   281.    procedure PIE (the_DR      : in out DR.device;
   282.                   Q_operand   : in KDF9.Q_register;
   283.                   set_offline : in Boolean) is
   284.    begin
   285.       PIA(the_DR, Q_operand, set_offline);
   286.    end PIE;
   287.
   288.    overriding
   289.    procedure PIF (the_DR      : in out DR.device;
   290.                   Q_operand   : in KDF9.Q_register;
   291.                   set_offline : in Boolean) is
   292.    begin
   293.       PIB(the_DR, Q_operand, set_offline);
   294.    end PIF;
   295.
   296.    overriding
   297.    procedure PIG (the_DR      : in out DR.device;
   298.                   Q_operand   : in KDF9.Q_register;
   299.                   set_offline : in Boolean) is
   300.    begin
   301.       PIA(the_DR, Q_operand, set_offline);
   302.    end PIG;
   303.
   304.    overriding
   305.    procedure PIH (the_DR      : in out DR.device;
   306.                   Q_operand   : in KDF9.Q_register;
   307.                   set_offline : in Boolean) is
   308.    begin
   309.       PIB(the_DR, Q_operand, set_offline);
   310.    end PIH;
   311.
   312.    procedure write_drum (the_DR    : in out DR.device;
   313.                          Q_operand : in KDF9.Q_register) is
   314.       end_address  : constant KDF9.address := Q_operand.M;
   315.       next_address : KDF9.address := Q_operand.I;
   316.       the_sector   : DR.sector := a_zero_sector;
   317.       symbol_nr    : KDF9_char_sets.symbol_index;
   318.       size         : KDF9.word := 0;
   319.       the_index    : KDF9.word;
   320.       latency,
   321.       busy_time    : KDF9.us;
   322.    begin
   323.       check_addresses_and_lockouts(next_address, end_address);
   324.       the_index := validated_drum_address(the_DR, Q_operand.C);
   325.       latency := latent_time(the_index);
   326.    sector_loop:
   327.       loop
   328.          symbol_nr := 0;
   329.       byte_loop:
   330.          for i in 1 .. bytes_per_sector loop
   331.             the_sector(i) := TP_CN(fetch_symbol(next_address, symbol_nr));
   332.             size := size + 1;
   333.          exit byte_loop when next_address = end_address and symbol_nr = 7;
   334.             increment(next_address, symbol_nr);
   335.          end loop byte_loop;
   336.          validate_the_sector_number(the_DR, the_index);
   337.          put(the_DR, the_sector, the_index);
   338.       exit sector_loop when next_address = end_address and symbol_nr = 7;
   339.          if the_index = DR.drum_index'Last then
   340.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   341.          else
   342.             the_index := the_index + 1;
   343.          end if;
   344.       end loop sector_loop;
   345.       keep_house(the_DR, size, busy_time);
   346.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   347.       lock_out_relative_addresses(Q_operand);
   348.       update_statistics(the_DR, latency);
   349.    end write_drum;
   350.
   351.    overriding
   352.    procedure POA (the_DR      : in out DR.device;
   353.                   Q_operand   : in KDF9.Q_register;
   354.                   set_offline : in Boolean) is
   355.       pragma Unreferenced(set_offline);
   356.    begin
   357.       validate_transfer(the_DR, Q_operand);
   358.       validate_parity(the_DR);
   359.       write_drum(the_DR, Q_operand);
   360.    end POA;
   361.
   362.    procedure write_drum_to_EM (the_DR    : in out DR.device;
   363.                                Q_operand : in KDF9.Q_register) is
   364.       end_address  : constant KDF9.address := Q_operand.M;
   365.       next_address : KDF9.address := Q_operand.I;
   366.       the_sector   : DR.sector := a_zero_sector;
   367.       at_EM        : Boolean := False;
   368.       size         : KDF9.word := 0;
   369.       symbol_nr    : KDF9_char_sets.symbol_index;
   370.       the_index    : KDF9.word;
   371.       latency,
   372.       busy_time    : KDF9.us;
   373.    begin
   374.       check_addresses_and_lockouts(next_address, end_address);
   375.       the_index := validated_drum_address(the_DR, Q_operand.C);
   376.       latency := latent_time(the_index);
   377.    sector_loop:
   378.       loop
   379.          if the_index > DR.drum_index'Last then
   380.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   381.          end if;
   382.          symbol_nr := 0;
   383.       byte_loop:
   384.          for i in 1 .. bytes_per_sector loop
   385.             the_sector(i) := TP_CN(fetch_symbol(next_address, symbol_nr));
   386.             size := size + 1;
   387.          at_EM := the_sector(i) = KDF9_char_sets.E_M;
   388.          exit byte_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   389.             increment(next_address, symbol_nr);
   390.          end loop byte_loop;
   391.          validate_the_sector_number(the_DR, the_index);
   392.          put(the_DR, the_sector, the_index);
   393.          exit sector_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   394.          the_index := the_index + 1;
   395.       end loop sector_loop;
   396.       keep_house(the_DR, size, busy_time);
   397.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   398.       lock_out_relative_addresses(Q_operand);
   399.       update_statistics(the_DR, latency);
   400.    end write_drum_to_EM;
   401.
   402.    overriding
   403.    procedure POB (the_DR      : in out DR.device;
   404.                   Q_operand   : in KDF9.Q_register;
   405.                   set_offline : in Boolean) is
   406.       pragma Unreferenced(set_offline);
   407.    begin
   408.       validate_transfer(the_DR, Q_operand);
   409.       validate_parity(the_DR);
   410.       write_drum_to_EM(the_DR, Q_operand);
   411.    end POB;
   412.
   413.    overriding
   414.    procedure POC (the_DR      : in out DR.device;
   415.                   Q_operand   : in KDF9.Q_register;
   416.                   set_offline : in Boolean) is
   417.    begin
   418.       POA(the_DR, Q_operand, set_offline);
   419.    end POC;
   420.
   421.    overriding
   422.    procedure POD (the_DR      : in out DR.device;
   423.                   Q_operand   : in KDF9.Q_register;
   424.                   set_offline : in Boolean) is
   425.    begin
   426.       POB(the_DR, Q_operand, set_offline);
   427.    end POD;
   428.
   429.    procedure write_zeroes (the_DR      : in out DR.device;
   430.                            Q_operand   : in KDF9.Q_register) is
   431.       start_address : constant KDF9.address := Q_operand.I;
   432.       end_address   : constant KDF9.address := Q_operand.M;
   433.       size      : KDF9.word := 0;
   434.       the_index : KDF9.word;
   435.       latency,
   436.       busy_time : KDF9.us;
   437.    begin
   438.       check_addresses_and_lockouts(start_address, end_address);
   439.       the_index := validated_drum_address(the_DR, Q_operand.C);
   440.       latency := latent_time(the_index);
   441.       for s in 1 .. (KDF9.word(end_address) - KDF9.word(start_address) + 128) / 128 loop
   442.          if the_index > DR.drum_index'Last then
   443.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   444.          end if;
   445.          validate_the_sector_number(the_DR, the_index);
   446.          put(the_DR, a_zero_sector, the_index);
   447.          size := size + bytes_per_sector;
   448.          the_index := the_index + 1;
   449.       end loop;
   450.       keep_house(the_DR, size, busy_time, from_core => False);
   451.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   452.       lock_out_relative_addresses(Q_operand);
   453.       update_statistics(the_DR, latency);
   454.    end write_zeroes;
   455.
   456.    overriding
   457.    procedure POE (the_DR      : in out DR.device;
   458.                   Q_operand   : in KDF9.Q_register;
   459.                   set_offline : in Boolean) is
   460.       pragma Unreferenced(set_offline);
   461.    begin
   462.       validate_transfer(the_DR, Q_operand);
   463.       write_zeroes(the_DR, Q_operand);
   464.    end POE;
   465.
   466.    overriding
   467.    procedure POF (the_DR      : in out DR.device;
   468.                   Q_operand   : in KDF9.Q_register;
   469.                   set_offline : in Boolean) is
   470.    begin
   471.       POE(the_DR, Q_operand, set_offline);
   472.    end POF;
   473.
   474.    overriding
   475.    procedure Finalize (the_DR : in out DR.device) is
   476.       transfer_time : constant KDF9.us := KDF9.us(the_DR.word_count) * 8 * the_DR.quantum;
   477.    begin
   478.       if the_DR.is_open then
   479.
   480.          if (the_final_state_is_wanted and the_log_is_wanted)    and then
   481.                (the_DR.word_count /= 0 or the_DR.latency_count /= 0) then
   482.             log_line
   483.                 (
   484.                  the_DR.device_name
   485.                & " on buffer #"
   486.                & oct_of(KDF9.Q_part(the_DR.number), 2)
   487.                & " spent:"
   488.                 );
   489.             log_line
   490.                 (
   491.                  "    "
   492.                & just_right(KDF9.us'Image(transfer_time / 1_000), 6)
   493.                & " ms in"
   494.                & the_DR.latency_count'Image
   495.                & " data transfer" & plurality(the_DR.latency_count)
   496.                & " totalling"
   497.                & KDF9.word'Image(the_DR.word_count)
   498.                & " word" & plurality(the_DR.word_count)
   499.                & ", and"
   500.                 );
   501.             log_line
   502.                 (
   503.                  "    "
   504.                & just_right(KDF9.us'Image(the_DR.latency_time / 1_000), 6)
   505.                & " ms in"
   506.                & the_DR.latency_count'Image
   507.                & " rotational latenc" & plurality(the_DR.latency_count, "y.", "ies.")
   508.                 );
   509.          end if;
   510.
   511.          close(IOC.device(the_DR));
   512.       end if;
   513.    end Finalize;
   514.
   515.    type DR_access is access DR.device;
   516.
   517.    DR0 : DR_access with Warnings => Off;
   518.
   519.    procedure enable (b : in KDF9.buffer_number) is
   520.    begin
   521.       if DR0_is_enabled then
   522.          trap_operator_error("more than one DR control unit has been configured");
   523.       end if;
   524.       DR0 := new DR.device (number => b, unit => 0);
   525.       DR0_is_enabled := True;
   526.       DR0_number := b;
   527.    end enable;
   528.
   529.    procedure replace_on_buffer (b : in KDF9.buffer_number) is
   530.    begin
   531.       if DR0_is_enabled and then
   532.             b = DR0.number  then
   533.          return;
   534.       end if;
   535.       buffer(b) := null;
   536.       enable(b);
   537.    end replace_on_buffer;
   538.
   539.    procedure remove_from_buffer (b : in KDF9.buffer_number) is
   540.    begin
   541.       if DR0_is_enabled and DR0_number = b then
   542.          buffer(b) := null;
   543.          DR0_is_enabled := False;
   544.       end if;
   545.    end remove_from_buffer;
   546.
   547. end IOC.fast.DR;

Compiling: ../Source/ioc-fast-dr.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Emulation of a drum store buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.DR is
    18.
    19.    type device is new fast.device with private;
    20.
    21.    overriding
    22.    procedure PIA (the_DR      : in out DR.device;
    23.                   Q_operand   : in KDF9.Q_register;
    24.                   set_offline : in Boolean);
    25.
    26.    overriding
    27.    procedure PIB (the_DR      : in out DR.device;
    28.                   Q_operand   : in KDF9.Q_register;
    29.                   set_offline : in Boolean);
    30.
    31.    overriding
    32.    procedure PIC (the_DR      : in out DR.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    overriding
    37.    procedure PID (the_DR      : in out DR.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    overriding
    42.    procedure PIE (the_DR      : in out DR.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    overriding
    47.    procedure PIF (the_DR      : in out DR.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    overriding
    52.    procedure PIG (the_DR      : in out DR.device;
    53.                   Q_operand   : in KDF9.Q_register;
    54.                   set_offline : in Boolean);
    55.
    56.    overriding
    57.    procedure PIH (the_DR      : in out DR.device;
    58.                   Q_operand   : in KDF9.Q_register;
    59.                   set_offline : in Boolean);
    60.
    61. -- PMA-PML, and POG-POL are inherited, as they have no new semantics for the drum.
    62.
    63.    overriding
    64.    procedure POA (the_DR      : in out DR.device;
    65.                   Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    overriding
    69.    procedure POB (the_DR      : in out DR.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean);
    72.
    73.    overriding
    74.    procedure POC (the_DR      : in out DR.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.    overriding
    78.    procedure POD (the_DR      : in out DR.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean);
    81.
    82.    overriding
    83.    procedure POE (the_DR      : in out DR.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    overriding
    88.    procedure POF (the_DR      : in out DR.device;
    89.                   Q_operand   : in KDF9.Q_register;
    90.                   set_offline : in Boolean);
    91.
    92.    procedure enable (b : in KDF9.buffer_number);
    93.
    94.    procedure replace_on_buffer (b : in KDF9.buffer_number);
    95.
    96.    procedure remove_from_buffer (b : in KDF9.buffer_number);
    97.
    98.    DR0_is_enabled : Boolean := False;
    99.
   100.    function as_DR_command (Q_operand : KDF9.Q_register; for_OUT : Boolean := False)
   101.    return String;
   102.
   103. private
   104.
   105.    -- For what little we know from EE of the drum geometry, see the Manual, App. 6, §4.
   106.    -- An additional and more helpful source is the SRLM, §103, Appendix 2, p.10-59-0,
   107.    --   which describes the drum used with the non-Time Sharing Director.
   108.    -- It says:
   109.    --   Drum revolution time     = 20.4   ms
   110.    --   Transfer time per sector =  2.15  ms
   111.    --   Short gap time           =  0.034 ms between successive sectors
   112.    --   Long gap time            =  2.97  ms after every 8th sector
   113.    -- Hence: Mean time per sector = revolution time/8 - short gap time - long gap time/8
   114.    --                             = 20.4 ms / 8       - 0.034          - 2.970 / 8
   115.    --                             = 2.145 ms, rounding correctly to 2.15 ms
   116.    -- This confirms 8 sectors per track, or 8192 characters per track, for 40 tracks per drum.
   117.
   118.    bytes_per_sector   : constant := 1024;
   119.    subtype byte_range is KDF9.word range 0 .. bytes_per_sector - 1;
   120.    subtype sector     is String(1..bytes_per_sector);
   121.
   122.    sectors_per_track  : constant := 8;
   123.    subtype sector_range is KDF9.word range 0 .. sectors_per_track - 1;
   124.
   125.    sectors_per_drum   : constant := 320;
   126.    drums_per_system   : constant := 4;
   127.    sectors_per_system : constant := sectors_per_drum * drums_per_system;
   128.    subtype drum_index is KDF9.word range 0 .. sectors_per_system - 1;
   129.
   130.    tracks_per_system   : constant := sectors_per_system / sectors_per_track;
   131.    subtype track_range is KDF9.word range 0 .. tracks_per_system - 1;
   132.
   133.    data_rate      : constant := 477_445;         -- chars/s
   134.    us_per_char    : constant := 1E6 / data_rate; -- ~2.1 µs/char
   135.
   136.    -- The following times are in microseconds.
   137.    short_gap_time : constant := 34;
   138.    sector_time    : constant := bytes_per_sector * us_per_char + short_gap_time;
   139.    long_gap_time  : constant := 2_970;
   140.    track_time     : constant := sector_time * sectors_per_track + long_gap_time;
   141.    critical_time  : constant := sector_time * (sectors_per_track-1) - short_gap_time;
   142.
   143.    type drum is array (drum_index) of DR.sector;
   144.
   145.    type device is new fast.device with null record;
   146.
   147.    overriding
   148.    procedure Initialize (the_DR : in out DR.device);
   149.
   150.    overriding
   151.    procedure Finalize (the_DR : in out DR.device);
   152.
   153.    overriding
   154.    function kind (the_DR : DR.device)
   155.    return IOC.device_kind
   156.    is (DR_kind);
   157.
   158.    overriding
   159.    function quantum (the_DR : DR.device)
   160.    return KDF9.us
   161.    is (us_per_char);
   162.
   163.    DR0_number : KDF9.buffer_number := 0;
   164.
   165. end IOC.fast.DR;

 547 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-fd.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Emulation of a fixed disc drive.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.fast.FD is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    function as_FD_command (Q_operand : KDF9.Q_register; for_seek, for_FH : Boolean := False)
    22.    return String is
    23.       parameter : constant KDF9.Q_part := Q_operand.C / 16;
    24.       cylinder  : constant KDF9.Q_part := parameter mod seek_areas_per_platter;
    25.       residue   : constant KDF9.Q_part := parameter  /  seek_areas_per_platter;
    26.       platter   : constant KDF9.Q_part := residue mod main_discs_per_drive;
    27.       drive     : constant KDF9.Q_part := residue  /  main_discs_per_drive;
    28.    begin
    29.       -- The disc geometry and I/O command bits are as defined in the FD package.
    30.       if for_seek then
    31.          return "D" & dec_of(drive)
    32.               & "P" & dec_of(if for_FH then KDF9.Q_part'(the_fixed_head_platter) else platter)
    33.               & "C" & dec_of(cylinder);
    34.       else -- for data transfer, parameter is sector #, with maximum 96 sectors per track.
    35.          return " S" & (if parameter < 10 then "0" else "") & dec_of(parameter);
    36.       end if;
    37.    end as_FD_command;
    38.
    39.    overriding
    40.    procedure Initialize (the_FD : in out FD.device) is
    41.    begin
    42.       open(the_FD, rd_wr_mode);
    43.    exception
    44.       when others =>
    45.          trap_operator_error(the_FD.device_name & " cannot be opened for reading and writing");
    46.    end Initialize;
    47.
    48.    -- Hypothesis:
    49.    -- Where a specification of the Fixed Disc subsystem cannot be inferred from extant software,
    50.    -- such as the Eldon 2 Director, or the EE KDF9 Programming Manual,
    51.    -- then it is reasonable to extrapolate from the Data Products Corporation documents:
    52.    --    "SPECIFICATION FOR MODEL 5022 DISCfILE STORAGE SYSTEM", of December 1964, and
    53.    --    "GENERAL INFORMATION MANUAL dp/f-5022 DISCfILE STORAGE SYSTEM", of March 1965,
    54.    -- which describe an (at least) very similar model.
    55.    -- These document are referred to herein as "GIM".
    56.    -- Confirmation of much of this material has been gained from the ICT document:
    57.    --    "Data Disc Store 1956", of September 1964",
    58.    -- which describes the same device, offered as a fixed disc drive for the 1900 Series.
    59.    -- All three depict the drive as having a different division of tracks into sectors.
    60.
    61.    -- Hypothesis:
    62.    -- The locus is set by a PMA or PMD operation; the sector number is updated by a transfer.
    63.
    64.    -- Hypothesis:
    65.    -- A PMA or PMD command sets the sector number to 0.
    66.
    67.    -- Hypothesis:
    68.    -- If a transfer would increase the sector number past 95, the end-of-area flag is set,
    69.    --    and the sector number is set to 95.
    70.
    71.    function locus_from (Q_operand : KDF9.Q_register)
    72.    return FD.locus is
    73.       parameter : constant KDF9.Q_part := Q_operand.C / 16; -- remove the buffer number
    74.       seek_area : constant KDF9.Q_part := parameter mod seek_areas_per_platter;
    75.       platter   : constant KDF9.Q_part
    76.                 := parameter / seek_areas_per_platter mod platters_per_drive;
    77.       drive     : constant KDF9.Q_part
    78.                 := parameter / seek_areas_per_platter / platters_per_drive;
    79.    begin
    80.       -- Hypothesis:
    81.       -- Seeking to a new locus zeroizes the sector number and clears the end-of-area flag.
    82.       return (
    83.               drive_number      => drive,
    84.               platter_number    => platter,
    85.               seek_area_number  => seek_area,
    86.               sector_number     => 0,
    87.               has_fixed_heads   => False,
    88.               is_at_end_of_area => False
    89.              );
    90.    end locus_from;
    91.
    92.    function sector_span (Q_operand : KDF9.Q_register)
    93.    return KDF9.Q_part
    94.    is ((Q_operand.M - Q_operand.I + words_per_sector - 1) / words_per_sector);
    95.
    96.    procedure advance_the_sector_number (the_FD : in out FD.device) is
    97.    begin
    98.       if the_FD.locus.sector_number = FD.sector_range'Last then
    99.          the_FD.locus.is_at_end_of_area := True;
   100.       else
   101.          the_FD.locus.is_at_end_of_area := False;
   102.          the_FD.locus.sector_number := the_FD.locus.sector_number + 1;
   103.       end if;
   104.    end advance_the_sector_number;
   105.
   106.    procedure set_the_new_sector_number (the_FD    : in out FD.device;
   107.                                     Q_operand : in KDF9.Q_register) is
   108.       the_sector_number : constant KDF9.Q_part := (Q_operand.C / 16) and 8#177#;
   109.    begin
   110.       if the_sector_number in FD.sector_range then
   111.          the_FD.locus.is_at_end_of_area := False;
   112.          the_FD.locus.sector_number := the_sector_number;
   113.       else
   114.          the_FD.locus.is_at_end_of_area := True;
   115.          the_FD.locus.sector_number := FD.sector_range'Last;
   116.       end if;
   117.    end set_the_new_sector_number;
   118.
   119.    sectors_per_platter : constant := sectors_per_seek_area * seek_areas_per_platter;
   120.    sectors_per_drive   : constant := platters_per_drive  * sectors_per_platter;
   121.
   122.    function file_offset (locus : FD.locus)
   123.    return POSIX.file_position
   124.    is (
   125.        bytes_per_sector *
   126.                         ( POSIX.file_position(locus.drive_number)     * sectors_per_drive
   127.                         + POSIX.file_position(locus.platter_number)   * sectors_per_platter
   128.                         + POSIX.file_position(locus.seek_area_number) * sectors_per_seek_area
   129.                         + POSIX.file_position(locus.sector_number)    * 1
   130.                         )
   131.       );
   132.
   133.    function disc_busy_time (first : FD.sector_range; size : KDF9.word)
   134.    return KDF9.us is
   135.
   136.       function ceiling (first : FD.sector_range; size : KDF9.word)
   137.       return FD.sector_range is
   138.          length : constant KDF9.Q_part := sector_span((0, 1, KDF9.Q_part(size)));
   139.       begin
   140.          return FD.sector_range'Min(first + length - 1, FD.sector_range'Last);
   141.       end ceiling;
   142.
   143.       function time_for (bytes : KDF9.word; in_outer_zone : Boolean)
   144.       return KDF9.word
   145.       is (1E6 * bytes / (if in_outer_zone then outer_rate else inner_rate));
   146.
   147.       boundary   : constant := sectors_per_seek_area / 3 * 2;
   148.       last       : constant FD.sector_range := ceiling(first, size);
   149.       bytes_left : KDF9.word := size * 8;
   150.       total_time : KDF9.word := 0;
   151.
   152.    begin
   153.       for s in first .. last loop
   154.       exit when bytes_left < bytes_per_sector;
   155.          total_time := total_time + time_for(bytes_per_sector, in_outer_zone => s < boundary);
   156.          bytes_left := bytes_left - bytes_per_sector;
   157.       end loop;
   158.       if bytes_left /= 0 then
   159.          total_time := total_time + time_for(bytes_left, in_outer_zone => last < boundary);
   160.       end if;
   161.       return KDF9.us(total_time);
   162.    end disc_busy_time;
   163.
   164.    -- The rotational position of the disc is measured in term of the time,
   165.    --    in microseconds, taken to get to that position from sector 0.
   166.
   167.    rotation_time : constant := 60E3;  -- 1000 RPM => 60 ms = 60_000 KDF9.us
   168.    track_size    : constant := 16;    -- There are only 8 sectors per track in the inner zone.
   169.    sector_time   : constant := rotation_time / track_size;
   170.
   171.    function angular_position (sector_number : FD.sector_range)
   172.    return KDF9.us
   173.    is (-- This is <= rotation_time.
   174.        if sector_number < sectors_in_outer_zone then
   175.           KDF9.us(sector_number * sector_time)
   176.        else
   177.           -- Inner zone sectors are twice as long as in the outer zone.
   178.           -- Assumes (without evidence) that the inner zone is offset 1/2 sector from the outer.
   179.           KDF9.us((sector_number - sectors_in_outer_zone) * sector_time * 2 - sector_time/2)
   180.       );
   181.
   182.    function latent_time (the_FD : FD.device; latency_start_time : in KDF9.us)
   183.    return KDF9.us is
   184.       new_angle  : constant KDF9.us := angular_position(the_FD.locus.sector_number);
   185.       old_angle  : constant KDF9.us := latency_start_time mod rotation_time;
   186.       offset     : constant KDF9.us
   187.                  := (if   new_angle > old_angle
   188.                      then new_angle - old_angle
   189.                      else new_angle + rotation_time - old_angle);
   190.    begin
   191.       -- According to GIM, the minimum latency is one sector;
   192.       --    if less we have to go all the way around.
   193.       return (if offset > sector_time then offset else rotation_time - offset );
   194.    end latent_time;
   195.
   196.    -- These times come from the Manual, §6.1, and from GIM.
   197.    checking_time  : constant :=   47E3;
   198.    min_seek_time  : constant :=  109E3;
   199.    max_seek_time  : constant :=  321E3;
   200.    per_track_time : constant KDF9.us
   201.                   := KDF9.us(max_seek_time - min_seek_time) / seek_areas_per_platter;
   202.
   203.    -- A seek distance of 1 takes the minimum seek time: zero_seek_time + per_track_time.
   204.    zero_seek_time : constant KDF9.us := min_seek_time - per_track_time;
   205.
   206.    subtype seek_time_range is KDF9.us range 0 .. max_seek_time + checking_time;
   207.
   208.    function arm_seek_time (the_FD : FD.device)
   209.    return seek_time_range is
   210.       next   : FD.locus renames the_FD.target;
   211.       drive  : FD.drive_range renames next.drive_number;
   212.       here   : constant FD.seek_area_range := the_FD.comb(drive, next.platter_number);
   213.       there  : constant FD.seek_area_range := next.seek_area_number;
   214.       span   : constant FD.seek_area_range := (if here > there then here - there else there - here);
   215.       cost   : constant KDF9.us := KDF9.us(span) * per_track_time;
   216.    begin
   217.       if cost > 0 and next.platter_number /= the_fixed_head_platter then
   218.          -- Hypothesis:
   219.          return KDF9.us'Min(zero_seek_time + cost, max_seek_time) + checking_time;
   220.       else
   221.          -- Hypothesis:
   222.          -- A seek to the present position takes no time.
   223.          return 0;
   224.       end if;
   225.    end arm_seek_time;
   226.
   227.    -- These times come from GIM.
   228.    -- A switch to a different platter takes 26 ms on average, as specified in GIM.
   229.    -- This time is needed to power-down then power-up the arm actuators for the R/W heads.
   230.    drive_switch_time : constant :=  5_000;
   231.    arm_switch_time   : constant := 26_000;
   232.
   233.    function platter_switch_time (the_FD : FD.device)
   234.    return KDF9.us is
   235.       the_drive_time : KDF9.us;
   236.    begin
   237.       if the_FD.target.drive_number /= the_FD.locus.drive_number then
   238.          the_drive_time := drive_switch_time;
   239.       else
   240.          the_drive_time := 0;
   241.       end if;
   242.       -- Hypothesis:
   243.       -- Operating successively on the current platter, or working on the fixed-head platter,
   244.       --    incurs no arm switch time.
   245.       if the_FD.target.platter_number = the_FD.locus.platter_number or else
   246.             the_FD.target.platter_number = the_fixed_head_platter      then
   247.           return the_drive_time;
   248.        else
   249.           return the_drive_time + arm_switch_time;
   250.       end if;
   251.    end platter_switch_time;
   252.
   253.    procedure set_seek_target (the_FD       : in out FD.device;
   254.                               Q_operand    : in KDF9.Q_register;
   255.                               it_will_seek : out Boolean) is
   256.       here : FD.locus renames the_FD.locus;
   257.       next : FD.locus renames the_FD.target;
   258.    begin
   259.       it_will_seek := False;
   260.       next := locus_from(Q_operand);
   261.       next.has_fixed_heads := False;
   262.       if next.platter_number /= here.platter_number then
   263.          the_FD.switch_count := the_FD.switch_count +1;
   264.       end if;
   265.       if the_FD.comb(next.drive_number, here.platter_number) /= next.seek_area_number then
   266.          the_FD.seek_count := the_FD.seek_count + 1;
   267.          it_will_seek := True;
   268.       end if;
   269.     end set_seek_target;
   270.
   271.    procedure seek_to_the_target_area (the_FD      : in out FD.device;
   272.                                       seek_time,
   273.                                       switch_time : out seek_time_range) is
   274.       here : FD.locus renames the_FD.locus;
   275.       next : FD.locus renames the_FD.target;
   276.    begin
   277.       seek_time := arm_seek_time(the_FD);
   278.       switch_time := platter_switch_time(the_FD);
   279.       here := the_FD.target;
   280.       the_FD.comb(here.drive_number, here.platter_number) := next.seek_area_number;
   281.     end seek_to_the_target_area;
   282.
   283.    subtype sector_image is String(1 .. bytes_per_sector);
   284.
   285.    empty_sector : constant sector_image := (others => SP);
   286.    this_sector  : sector_image;
   287.
   288.    procedure get_next_sector (the_FD : in out FD.device) is
   289.       result : POSIX.file_position with Unreferenced;
   290.    begin
   291.       result := seek(fd_of(the_FD.stream), file_offset(the_FD.locus));
   292.       result := POSIX.file_position(read(fd_of(the_FD.stream), this_sector, bytes_per_sector));
   293.       the_FD.sector_count := the_FD.sector_count + 1;
   294.       advance_the_sector_number(the_FD);
   295.    end get_next_sector;
   296.
   297.    procedure keep_house (the_FD        : in out FD.device;
   298.                          transfer_size : in KDF9.word;
   299.                          busy_time     : out KDF9.us) is
   300.    begin
   301.       the_FD.latency_count := the_FD.latency_count + 1;
   302.       the_FD.word_count := the_FD.word_count + transfer_size;
   303.       add_in_the_IO_CPU_time(the_FD, bytes_moved => transfer_size*8);
   304.       busy_time := disc_busy_time(the_FD.locus.sector_number, transfer_size);
   305.    end keep_house;
   306.
   307.    procedure update_statistics (the_FD        : in out FD.device;
   308.                                 switch_time,
   309.                                 seek_time,
   310.                                 latency_time,
   311.                                 data_time     : in KDF9.us := 0) is
   312.    begin
   313.       the_FD.switch_time := the_FD.switch_time + switch_time;
   314.       the_FD.seek_time := the_FD.seek_time + seek_time;
   315.       the_FD.latency_time := the_FD.latency_time + latency_time;
   316.       the_FD.data_time := the_FD.data_time + data_time;
   317.       the_FD.elapsed_time := the_FD.elapsed_time
   318.                                  + switch_time
   319.                                  + seek_time
   320.                                  + latency_time
   321.                                  + data_time;
   322.     end update_statistics;
   323.
   324.    procedure read (the_FD        : in out FD.device;
   325.                    start_address,
   326.                    end_address   : in  KDF9.address;
   327.                    busy_time     : out KDF9.us;
   328.                    reading_to_EM : in  Boolean := False) is
   329.       size : KDF9.word := 0;
   330.       next : Natural := 0;
   331.       char : Character;
   332.    begin
   333.       check_addresses_and_lockouts(start_address, end_address);
   334.    word_loop:
   335.       for w in start_address .. end_address loop
   336.          if size mod bytes_per_sector = 0 then
   337.             this_sector := empty_sector;
   338.             get_next_sector(the_FD);
   339.          exit word_loop when the_FD.locus.is_at_end_of_area;
   340.             next := 0;
   341.          end if;
   342.          for c in KDF9_char_sets.symbol_index'Range loop
   343.             next := next + 1;
   344.             char := this_sector(next);
   345.             store_symbol(CN_TR(char), w, c);
   346.             size := size + 1;
   347.          exit word_loop when reading_to_EM and char = E_M;
   348.          end loop;
   349.       end loop word_loop;
   350.       keep_house(the_FD, (size+7)/8, busy_time);
   351.    end read;
   352.
   353.    procedure PI_all (the_FD         : in out FD.device;
   354.                      Q_operand      : in KDF9.Q_register;
   355.                      transfer_to_EM : in Boolean := False) is
   356.       the_present_time   : constant KDF9.us := the_clock_time;
   357.       latency_start_time : KDF9.us;
   358.       seek_duration,
   359.       switch_duration,
   360.       latency_duration,
   361.       data_duration,
   362.       total_duration     : KDF9.us;
   363.    begin
   364.       validate_device(the_FD);
   365.       validate_parity(the_FD);
   366.       seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   367.       set_the_new_sector_number(the_FD, Q_operand);
   368.       latency_start_time := the_present_time + seek_duration + switch_duration;
   369.       latency_duration := latent_time(the_FD, latency_start_time);
   370.
   371.       if the_FD.locus.is_at_end_of_area then
   372.          -- Cannot transfer past the last sector in a seek area.
   373.          trap_failing_IO_operation(the_FD, "attempt to read FD at the end of a seek area");
   374.       end if;
   375.
   376.       -- Read from the newly established position.
   377.       read(
   378.            the_FD,
   379.            Q_operand.I, Q_operand.M,
   380.            data_duration,
   381.            reading_to_EM => transfer_to_EM
   382.           );
   383.
   384.       total_duration := seek_duration + switch_duration + latency_duration + data_duration;
   385.       start_data_transfer(the_FD, Q_operand, False, total_duration, input_operation);
   386.       lock_out_relative_addresses(Q_operand);
   387.       update_statistics(
   388.                         the_FD,
   389.                         switch_time  => switch_duration,
   390.                         seek_time    => seek_duration,
   391.                         latency_time => latency_duration,
   392.                         data_time    => data_duration
   393.                        );
   394.    end PI_all;
   395.
   396.    overriding
   397.    procedure PIA (the_FD      : in out FD.device;
   398.                   Q_operand   : in KDF9.Q_register;
   399.                   set_offline : in Boolean) is
   400.       pragma Unreferenced(set_offline);
   401.    begin
   402.       PI_all(the_FD, Q_operand);
   403.    end PIA;
   404.
   405.    overriding
   406.    procedure PIB (the_FD      : in out FD.device;
   407.                   Q_operand   : in KDF9.Q_register;
   408.                   set_offline : in Boolean) is
   409.       pragma Unreferenced(set_offline);
   410.    begin
   411.       PI_all(the_FD, Q_operand, transfer_to_EM => True);
   412.    end PIB;
   413.
   414.    -- Set up FD parameters for a transfer in the fixed-head platter.
   415.    procedure prepare_fixed_head_transfer (the_FD      : in out FD.device;
   416.                                           Q_operand   : in KDF9.Q_register) is
   417.    begin
   418.       the_FD.target := locus_from(Q_operand);
   419.       the_FD.target.has_fixed_heads := True;
   420.       the_FD.target.platter_number := 16;
   421.       the_FD.switch_time := platter_switch_time(the_FD);
   422.       the_FD.locus := the_FD.target;
   423.       the_FD.switch_count := the_FD.switch_count + (if the_FD.switch_time = 0 then 0 else 1);
   424.    end prepare_fixed_head_transfer;
   425.
   426.    overriding
   427.    procedure PIC (the_FD      : in out FD.device;
   428.                   Q_operand   : in KDF9.Q_register;
   429.                   set_offline : in Boolean) is
   430.       pragma Unreferenced(set_offline);
   431.    begin
   432.       prepare_fixed_head_transfer(the_FD, Q_operand);
   433.       PI_all(the_FD, Q_operand);
   434.    end PIC;
   435.
   436.    overriding
   437.    procedure PID (the_FD      : in out FD.device;
   438.                   Q_operand   : in KDF9.Q_register;
   439.                   set_offline : in Boolean) is
   440.       pragma Unreferenced(set_offline);
   441.    begin
   442.       prepare_fixed_head_transfer(the_FD, Q_operand);
   443.       PI_all(the_FD, Q_operand, transfer_to_EM => True);
   444.    end PID;
   445.
   446.    -- Find the number of the next (first) sector to rotate into an accessible position.
   447.    function next_sector_number (the_FD : FD.device)
   448.    return FD.sector_range is
   449.       now        : constant KDF9.us := the_clock_time;
   450.       best_time  : KDF9.us          := KDF9.us'Last;
   451.       the_sector : FD.sector_range  := FD.sector_range'Last;
   452.    begin
   453.       for s in FD.sector_range loop
   454.          if latent_time(the_FD, now) in sector_time+1 .. 2*sector_time then
   455.             if latent_time(the_FD, now) <= best_time then
   456.                the_sector := s;
   457.                best_time := latent_time(the_FD, now);
   458.             end if;
   459.          end if;
   460.       end loop;
   461.       return the_sector;
   462.    end next_sector_number;
   463.
   464.    -- Modify the given command to apply to the next sector to come under the heads.
   465.    function for_next_sector (the_FD : FD.device; Q : KDF9.Q_register)
   466.    return KDF9.Q_register
   467.    is (
   468.        C => (Q.C and 8#174000#) or (Q.C and 8#17#) or (next_sector_number(the_FD)*16),
   469.        I => Q.I,
   470.        M => Q.M
   471.       );
   472.
   473.    overriding
   474.    procedure PIE (the_FD      : in out FD.device;
   475.                   Q_operand   : in KDF9.Q_register;
   476.                   set_offline : in Boolean) is
   477.       pragma Unreferenced(set_offline);
   478.    begin
   479.       validate_transfer(the_FD, Q_operand);
   480.       PI_all(the_FD, for_next_sector(the_FD, Q_operand));
   481.    end PIE;
   482.
   483.    overriding
   484.    procedure PIF (the_FD      : in out FD.device;
   485.                   Q_operand   : in KDF9.Q_register;
   486.                   set_offline : in Boolean) is
   487.       pragma Unreferenced(set_offline);
   488.    begin
   489.       validate_transfer(the_FD, Q_operand);
   490.       PI_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   491.    end PIF;
   492.
   493.    overriding
   494.    procedure PIG (the_FD      : in out FD.device;
   495.                   Q_operand   : in KDF9.Q_register;
   496.                   set_offline : in Boolean) is
   497.       pragma Unreferenced(set_offline);
   498.    begin
   499.       validate_transfer(the_FD, Q_operand);
   500.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   501.       PI_all(the_FD, for_next_sector(the_FD, Q_operand));
   502.    end PIG;
   503.
   504.    overriding
   505.    procedure PIH (the_FD      : in out FD.device;
   506.                   Q_operand   : in KDF9.Q_register;
   507.                   set_offline : in Boolean) is
   508.       pragma Unreferenced(set_offline);
   509.    begin
   510.       validate_transfer(the_FD, Q_operand);
   511.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   512.       PI_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   513.    end PIH;
   514.
   515.    -- Set up, but do not yet effect, a seek to the locus specified by the Q_operand.
   516.    -- This follows advice from David Holdsworth that seeks were not effected
   517.    --    until a data transfer operation was obeyed.
   518.    -- PMA does not lockout for a busy device.  This may not be authentic.
   519.    overriding
   520.    procedure PMA (the_FD      : in out FD.device;
   521.                   Q_operand   : in KDF9.Q_register;
   522.                   set_offline : in Boolean) is
   523.       a_seek_is_needed : Boolean := False;
   524.    begin
   525.       validate_device(the_FD);
   526.       validate_parity(the_FD);
   527.       set_seek_target(the_FD, Q_operand, a_seek_is_needed);
   528.       deal_with_a_busy_device(the_FD, 19, set_offline);
   529.       take_note_of_test(the_FD.device_name, Q_operand, a_seek_is_needed);
   530.    end PMA;
   531.
   532.    overriding
   533.    procedure PMB (the_FD      : in out FD.device;
   534.                   Q_operand   : in KDF9.Q_register;
   535.                   set_offline : in Boolean) is
   536.       pragma Unreferenced(Q_operand);
   537.       pragma Unreferenced(set_offline);
   538.    begin
   539.       validate_device(the_FD);
   540.       validate_parity(the_FD);
   541.       null;
   542.    end PMB;
   543.
   544.    overriding
   545.    procedure PMC (the_FD      : in out FD.device;
   546.                   Q_operand   : in KDF9.Q_register;
   547.                   set_offline : in Boolean) is
   548.       pragma Unreferenced(Q_operand);
   549.       pragma Unreferenced(set_offline);
   550.    begin
   551.       validate_device(the_FD);
   552.       validate_parity(the_FD);
   553.       null;
   554.    end PMC;
   555.
   556.    overriding
   557.    procedure PMD (the_FD      : in out FD.device;
   558.                   Q_operand   : in KDF9.Q_register;
   559.                   set_offline : in Boolean) is
   560.       -- clear out seek area # and platter #, leaving buffer # and drive #
   561.       platter_0        : constant KDF9.Q_part := Q_operand.C and 16#C00F#;
   562.       control_word     : KDF9.Q_register;
   563.       a_seek_is_needed : Boolean;
   564.       seek_duration,
   565.       switch_duration  : KDF9.us;
   566.    begin
   567.       validate_device(the_FD);
   568.       -- Hypothesis: drive reset clears the parity flag.
   569.       the_FD.is_abnormal := False;
   570.       -- In effect, do 16 PMA operations, but treat them as a single operation.
   571.       for p in KDF9.Q_part range 0..15 loop -- p is platter #
   572.          control_word := (platter_0 + p*16#400#, Q_operand.I, Q_operand.M);
   573.          set_seek_target(the_FD, control_word, a_seek_is_needed);
   574.          seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   575.          update_statistics(
   576.                            the_FD,
   577.                            switch_time  => switch_duration,
   578.                            seek_time    => seek_duration
   579.                           );
   580.       end loop;
   581.       deal_with_a_busy_device(the_FD, 16, set_offline);
   582.    end PMD;
   583.
   584.    overriding
   585.    procedure PMF (the_FD      : in out FD.device;
   586.                   Q_operand   : in KDF9.Q_register;
   587.                   set_offline : in Boolean) is
   588.    begin
   589.       validate_device(the_FD);
   590.       validate_parity(the_FD);
   591.       deal_with_a_busy_device(the_FD, 13, set_offline);
   592.       the_T_bit_is_set := the_FD.locus.is_at_end_of_area;
   593.       take_note_of_test(the_FD.device_name, Q_operand, the_T_bit_is_set);
   594.    end PMF;
   595.
   596.    procedure put_next_sector (the_FD : in out FD.device) is
   597.       result : POSIX.file_position with Unreferenced;
   598.    begin
   599.       result := seek(fd_of(the_FD.stream), file_offset(the_FD.locus));
   600.       result := POSIX.file_position(write(fd_of(the_FD.stream), this_sector, bytes_per_sector));
   601.       the_FD.sector_count := the_FD.sector_count + 1;
   602.       advance_the_sector_number(the_FD);
   603.       this_sector := empty_sector;
   604.    end put_next_sector;
   605.
   606.    procedure write (the_FD       : in out FD.device;
   607.                    start_address,
   608.                    end_address   : in KDF9.address;
   609.                    busy_time     : out KDF9.us;
   610.                    writing_to_EM : in  Boolean := False) is
   611.       size   : KDF9.word := 0;
   612.       next   : Natural := 0;
   613.       symbol : KDF9_char_sets.symbol;
   614.       char   : Character;
   615.    begin
   616.       check_addresses_and_lockouts(start_address, end_address);
   617.       this_sector := empty_sector;
   618.    word_loop:
   619.       for w in start_address .. end_address loop
   620.          for c in KDF9_char_sets.symbol_index'Range loop
   621.             symbol := fetch_symbol(w, c);
   622.             char := TP_CN(symbol);
   623.             next := next + 1;
   624.             this_sector(next) := char;
   625.             size := size + 1;
   626.             exit when writing_to_EM and char = E_M;
   627.          end loop;
   628.          if writing_to_EM and char = E_M then
   629.             put_next_sector(the_FD);
   630.             next := 0;
   631.             exit word_loop;
   632.          elsif size mod bytes_per_sector = 0 then
   633.             put_next_sector(the_FD);
   634.             next := 0;
   635.             exit word_loop when the_FD.locus.is_at_end_of_area;
   636.          end if;
   637.       end loop word_loop;
   638.       if next > 0 then
   639.          -- Write out any untransferred residue of less than a full sector.
   640.          put_next_sector(the_FD);
   641.       end if;
   642.       keep_house(the_FD, (size+7)/8, busy_time);
   643.    end write;
   644.
   645.    procedure PO_all (the_FD         : in out FD.device;
   646.                      Q_operand      : in KDF9.Q_register;
   647.                      transfer_to_EM : in Boolean := False) is
   648.       the_present_time   : constant KDF9.us := the_clock_time;
   649.       seek_duration,
   650.       switch_duration,
   651.       latency_duration,
   652.       data_duration,
   653.       total_duration     : KDF9.us;
   654.       latency_start_time : KDF9.us;
   655.    begin
   656.       validate_device(the_FD);
   657.       validate_parity(the_FD);
   658.       seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   659.       set_the_new_sector_number(the_FD, Q_operand);
   660.       latency_start_time := the_present_time + seek_duration + switch_duration;
   661.       latency_duration := latent_time(the_FD, latency_start_time);
   662.
   663.       if the_FD.locus.is_at_end_of_area then
   664.          -- Cannot transfer past the last sector in a seek area.
   665.          trap_failing_IO_operation(the_FD, "attempt to write FD at the end of a seek area");
   666.       end if;
   667.
   668.       -- Write to the newly established position.
   669.       write(
   670.             the_FD,
   671.             Q_operand.I, Q_operand.M,
   672.             data_duration,
   673.             writing_to_EM => transfer_to_EM
   674.            );
   675.
   676.       total_duration := seek_duration + switch_duration + latency_duration + data_duration;
   677.       start_data_transfer(the_FD, Q_operand, False, total_duration, output_operation);
   678.       lock_out_relative_addresses(Q_operand);
   679.       update_statistics(
   680.                         the_FD,
   681.                         seek_time    => seek_duration,
   682.                         switch_time  => switch_duration,
   683.                         latency_time => latency_duration,
   684.                         data_time    => data_duration
   685.                        );
   686.    end PO_all;
   687.
   688.    overriding
   689.    procedure POA (the_FD      : in out FD.device;
   690.                   Q_operand   : in KDF9.Q_register;
   691.                   set_offline : in Boolean) is
   692.       pragma Unreferenced(set_offline);
   693.    begin
   694.       PO_all(the_FD, Q_operand);
   695.    end POA;
   696.
   697.    overriding
   698.    procedure POB (the_FD      : in out FD.device;
   699.                   Q_operand   : in KDF9.Q_register;
   700.                   set_offline : in Boolean) is
   701.       pragma Unreferenced(set_offline);
   702.    begin
   703.       PO_all(the_FD, Q_operand, transfer_to_EM => True);
   704.    end POB;
   705.
   706.    overriding
   707.    procedure POC (the_FD      : in out FD.device;
   708.                   Q_operand   : in KDF9.Q_register;
   709.                   set_offline : in Boolean) is
   710.       pragma Unreferenced(set_offline);
   711.    begin
   712.       prepare_fixed_head_transfer(the_FD, Q_operand);
   713.       PO_all(the_FD, Q_operand);
   714.    end POC;
   715.
   716.    overriding
   717.    procedure POD (the_FD      : in out FD.device;
   718.                   Q_operand   : in KDF9.Q_register;
   719.                   set_offline : in Boolean) is
   720.       pragma Unreferenced(set_offline);
   721.    begin
   722.       prepare_fixed_head_transfer(the_FD, Q_operand);
   723.       PO_all(the_FD, Q_operand, transfer_to_EM => True);
   724.    end POD;
   725.
   726.    overriding
   727.    procedure POE (the_FD      : in out FD.device;
   728.                   Q_operand   : in KDF9.Q_register;
   729.                   set_offline : in Boolean) is
   730.    begin
   731.       POC(the_FD, Q_operand, set_offline);
   732.    end POE;
   733.
   734.    overriding
   735.    procedure POF (the_FD      : in out FD.device;
   736.                   Q_operand   : in KDF9.Q_register;
   737.                   set_offline : in Boolean) is
   738.    begin
   739.       POA(the_FD, Q_operand, set_offline);
   740.    end POF;
   741.
   742.    overriding
   743.    procedure POG (the_FD      : in out FD.device;
   744.                   Q_operand   : in KDF9.Q_register;
   745.                   set_offline : in Boolean) is
   746.       pragma Unreferenced(set_offline);
   747.    begin
   748.       validate_transfer(the_FD, Q_operand);
   749.       PO_all(the_FD, for_next_sector(the_FD, Q_operand));
   750.    end POG;
   751.
   752.    overriding
   753.    procedure POH (the_FD      : in out FD.device;
   754.                   Q_operand   : in KDF9.Q_register;
   755.                   set_offline : in Boolean) is
   756.       pragma Unreferenced(set_offline);
   757.    begin
   758.       validate_transfer(the_FD, Q_operand);
   759.       PO_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   760.    end POH;
   761.
   762.    overriding
   763.    procedure POK (the_FD      : in out FD.device;
   764.                   Q_operand   : in KDF9.Q_register;
   765.                   set_offline : in Boolean) is
   766.       pragma Unreferenced(set_offline);
   767.    begin
   768.       validate_transfer(the_FD, Q_operand);
   769.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   770.       PO_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   771.    end POK;
   772.
   773.    overriding
   774.    procedure POL (the_FD      : in out FD.device;
   775.                   Q_operand   : in KDF9.Q_register;
   776.                   set_offline : in Boolean) is
   777.       pragma Unreferenced(set_offline);
   778.    begin
   779.       validate_transfer(the_FD, Q_operand);
   780.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   781.       PO_all(the_FD, for_next_sector(the_FD, Q_operand));
   782.    end POL;
   783.
   784.    overriding
   785.    procedure Finalize (the_FD : in out FD.device) is
   786.       buffer : constant String := oct_of(KDF9.Q_part(the_FD.number), 2);
   787.    begin
   788.       if the_FD.is_open then
   789.          if (the_final_state_is_wanted and the_log_is_wanted)    and then
   790.                (the_FD.word_count /= 0 or the_FD.latency_count /= 0  or
   791.                 the_FD.seek_count /= 0 or the_FD.switch_time   /= 0) then
   792.             log_line
   793.                    (
   794.                     the_FD.device_name
   795.                   & " on buffer #"
   796.                   & buffer
   797.                   & " spent:"
   798.                    );
   799.             log_line
   800.                    (
   801.                     "    "
   802.                   & just_right(KDF9.us'Image(the_FD.data_time / 1_000), 6)
   803.                   & " ms in"
   804.                   & the_FD.latency_count'Image
   805.                   & " data transfer" & plurality(the_FD.latency_count)
   806.                   & " totalling"
   807.                   & KDF9.word'Image(the_FD.word_count)
   808.                   & " word" & plurality(the_FD.word_count)
   809.                   & ","
   810.                    );
   811.             log_line
   812.                    (
   813.                     "    "
   814.                   & just_right(KDF9.us'Image(the_FD.switch_time / 1_000), 6)
   815.                   & " ms in"
   816.                   & the_FD.switch_count'Image
   817.                   & " platter switch" & plurality(the_FD.switch_count, "", "es")
   818.                   & ","
   819.                    );
   820.             log_line
   821.                    (
   822.                     "    "
   823.                   & just_right(KDF9.us'Image(the_FD.latency_time / 1_000), 6)
   824.                   & " ms in"
   825.                   & the_FD.latency_count'Image
   826.                   & " rotational latenc" & plurality(the_FD.latency_count, "y", "ies")
   827.                   & ", and"
   828.                    );
   829.             log_line
   830.                    (
   831.                     "    "
   832.                   & just_right(KDF9.us'Image(the_FD.seek_time / 1_000), 6)
   833.                   & " ms in"
   834.                   & the_FD.seek_count'Image
   835.                   & " seek" & plurality(the_FD.seek_count) & "."
   836.                    );
   837.          end if;
   838.          IOC.device(the_FD).Finalize;
   839.          close(the_FD);
   840.       end if;
   841.    end Finalize;
   842.
   843.    type FD_access is access FD.device;
   844.
   845.    FD0 : FD_access with Warnings => Off;
   846.
   847.    procedure enable (b : in KDF9.buffer_number) is
   848.    begin
   849.       if FD0_is_enabled then
   850.          trap_operator_error("more than one FD control unit has been configured");
   851.       end if;
   852.       FD0 := new FD.device (number => b, unit => 0);
   853.       FD0_is_enabled := True;
   854.       FD0_number := b;
   855.    end enable;
   856.
   857.    procedure replace_on_buffer (b : in KDF9.buffer_number) is
   858.    begin
   859.       if FD0 /= null    and then
   860.             b = FD0.number  then
   861.          return;
   862.       end if;
   863.       buffer(b) := null;
   864.       FD0 := null;
   865.       FD0_number := 0;
   866.       FD0_is_enabled := False;
   867.       enable(b);
   868.    end replace_on_buffer;
   869.
   870.    procedure remove_from_buffer (b : in KDF9.buffer_number) is
   871.    begin
   872.       if FD0 /= null    and then
   873.             b = FD0.number  then
   874.          buffer(b) := null;
   875.          FD0 := null;
   876.          FD0_number := 0;
   877.          FD0_is_enabled := False;
   878.       end if;
   879.    end remove_from_buffer;
   880.
   881. end IOC.fast.FD;

Compiling: ../Source/ioc-fast-fd.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Emulation of a fixed disc drive.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.FD is
    18.
    19.    type device is new fast.device with private;
    20.
    21.    overriding
    22.    procedure PIA (the_FD      : in out FD.device;
    23.                   Q_operand   : in KDF9.Q_register;
    24.                   set_offline : in Boolean);
    25.
    26.    overriding
    27.    procedure PIB (the_FD      : in out FD.device;
    28.                   Q_operand   : in KDF9.Q_register;
    29.                   set_offline : in Boolean);
    30.
    31.    overriding
    32.    procedure PIC (the_FD      : in out FD.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    overriding
    37.    procedure PID (the_FD      : in out FD.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    overriding
    42.    procedure PIE (the_FD      : in out FD.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    overriding
    47.    procedure PIF (the_FD      : in out FD.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    overriding
    52.    procedure PIG (the_FD      : in out FD.device;
    53.                   Q_operand   : in KDF9.Q_register;
    54.                   set_offline : in Boolean);
    55.
    56.    overriding
    57.    procedure PIH (the_FD      : in out FD.device;
    58.                   Q_operand   : in KDF9.Q_register;
    59.                   set_offline : in Boolean);
    60.
    61.    overriding
    62.    procedure PMA (the_FD      : in out FD.device;
    63.                   Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean);
    65.
    66.    overriding
    67.    procedure PMB (the_FD      : in out FD.device;
    68.                   Q_operand   : in KDF9.Q_register;
    69.                   set_offline : in Boolean);
    70.
    71.    overriding
    72.    procedure PMC (the_FD      : in out FD.device;
    73.                   Q_operand   : in KDF9.Q_register;
    74.                   set_offline : in Boolean);
    75.
    76.    overriding
    77.    procedure PMD (the_FD      : in out FD.device;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    overriding
    82.    procedure PMF (the_FD      : in out FD.device;
    83.                   Q_operand   : in KDF9.Q_register;
    84.                   set_offline : in Boolean);
    85.
    86.    overriding
    87.    procedure POA (the_FD      : in out FD.device;
    88.                   Q_operand   : in KDF9.Q_register;
    89.                   set_offline : in Boolean);
    90.
    91.    overriding
    92.    procedure POB (the_FD      : in out FD.device;
    93.                   Q_operand   : in KDF9.Q_register;
    94.                   set_offline : in Boolean);
    95.
    96.    overriding
    97.    procedure POC (the_FD      : in out FD.device;
    98.                   Q_operand   : in KDF9.Q_register;
    99.                   set_offline : in Boolean);
   100.
   101.    overriding
   102.    procedure POD (the_FD      : in out FD.device;
   103.                   Q_operand   : in KDF9.Q_register;
   104.                   set_offline : in Boolean);
   105.
   106.    overriding
   107.    procedure POE (the_FD      : in out FD.device;
   108.                   Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean);
   110.
   111.    overriding
   112.    procedure POF (the_FD      : in out FD.device;
   113.                   Q_operand   : in KDF9.Q_register;
   114.                   set_offline : in Boolean);
   115.
   116.    overriding
   117.    procedure POG (the_FD      : in out FD.device;
   118.                   Q_operand   : in KDF9.Q_register;
   119.                   set_offline : in Boolean);
   120.
   121.    overriding
   122.    procedure POH (the_FD      : in out FD.device;
   123.                   Q_operand   : in KDF9.Q_register;
   124.                   set_offline : in Boolean);
   125.
   126.    overriding
   127.    procedure POK (the_FD      : in out FD.device;
   128.                   Q_operand   : in KDF9.Q_register;
   129.                   set_offline : in Boolean);
   130.
   131.    overriding
   132.    procedure POL (the_FD      : in out FD.device;
   133.                   Q_operand   : in KDF9.Q_register;
   134.                   set_offline : in Boolean);
   135.
   136.    FD0_is_enabled : Boolean := False;
   137.
   138.    procedure enable (b : in KDF9.buffer_number);
   139.
   140.    procedure replace_on_buffer (b : in KDF9.buffer_number);
   141.
   142.    procedure remove_from_buffer (b : in KDF9.buffer_number);
   143.
   144.    function as_FD_command (Q_operand : KDF9.Q_register; for_seek, for_FH : Boolean := False)
   145.    return String;
   146.
   147. private
   148.
   149.    words_per_sector      : constant := 40;
   150.    bytes_per_sector      : constant := 8 * words_per_sector;
   151.
   152.    type sector_data      is array (KDF9.address range 0 .. bytes_per_sector-1)
   153.                          of KDF9_char_sets.symbol;
   154.
   155.    sectors_per_seek_area  : constant := 96;
   156.    sectors_in_outer_zone  : constant := 64;
   157.
   158.    subtype sector_range  is KDF9.Q_part range 0 .. sectors_per_seek_area-1;
   159.
   160.    type sector_array     is array (KDF9.Q_part range <>) of FD.sector_data;
   161.
   162.    subtype head_range    is KDF9.Q_part range 0 .. 7;
   163.
   164.    subtype inner_track   is FD.sector_array(FD.sector_range range 0 ..  7);
   165.    subtype outer_track   is FD.sector_array(FD.sector_range range 0 .. 15);
   166.
   167.    last_sector_for_head  : constant array (FD.head_range) of FD.sector_range
   168.                          := (0 .. 3 => FD.outer_track'Last,
   169.                              4 .. 7 => FD.inner_track'Last);
   170.
   171.    type outer_data       is array (FD.head_range range 0 .. 3) of FD.outer_track;
   172.    type inner_data       is array (FD.head_range range 4 .. 7) of FD.inner_track;
   173.
   174.    -- These rates come from the Manual, §6.1.
   175.    outer_rate : constant := 84_800;          -- bytes per second in the outer zone
   176.    inner_rate : constant := outer_rate / 2;  -- bytes per second in the outer zone
   177.
   178.    type track_set is
   179.       record
   180.          outer_zone : FD.outer_data;
   181.          inner_zone : FD.inner_data;
   182.       end record;
   183.
   184.    seek_areas_per_platter  : constant := 64;
   185.    subtype seek_area_range is KDF9.Q_part range 0 .. seek_areas_per_platter-1;
   186.
   187.    main_discs_per_drive    : constant := 16;
   188.    the_fixed_head_platter  : constant := 16;
   189.    platters_per_drive      : constant := main_discs_per_drive + 1;
   190.
   191.    subtype platter_range   is KDF9.Q_part range 0 .. platters_per_drive-1;
   192.
   193.    -- The Eldon 2 KDF9 at Leeds University had a 2-drive disc system.
   194.    -- This allows for the maximum number of drives possible.
   195.    number_of_drives : constant := 4;
   196.
   197.    subtype drive_range is KDF9.Q_part range 0 .. number_of_drives-1;
   198.
   199.    type locus is
   200.       record
   201.          drive_number      : FD.drive_range     := 0;
   202.          platter_number    : FD.platter_range   := 0;
   203.          seek_area_number  : FD.seek_area_range := 0;
   204.          sector_number     : FD.sector_range    := 0;
   205.          has_fixed_heads,
   206.          is_at_end_of_area : Boolean            := False;
   207.       end record;
   208.
   209.    -- The disc storage is actually implemented in an external file.
   210.    -- The comb and locus variables shadow the physical state of the drives.
   211.    -- They are used to derive a file address from the position established
   212.    --    by seek and transfer operations.
   213.
   214.    type comb_data is array (FD.drive_range, FD.platter_range) of FD.seek_area_range;
   215.
   216.    type device is new fast.device with
   217.       record
   218.          comb         : FD.comb_data := (others => (others => 0));
   219.          locus,
   220.          target       : FD.locus;
   221.          data_time,
   222.          seek_time    : KDF9.us := 0;
   223.          seek_count,
   224.          sector_count : KDF9.word := 0;
   225.       end record;
   226.
   227.    overriding
   228.    procedure Initialize (the_FD : in out FD.device);
   229.
   230.    overriding
   231.    procedure Finalize (the_FD : in out FD.device);
   232.
   233.    overriding
   234.    function kind (the_FD : FD.device)
   235.    return IOC.device_kind
   236.    is (FD_kind);
   237.
   238.    overriding
   239.    function quantum (the_FD : FD.device)
   240.    return KDF9.us
   241.    is ((1E6 + outer_rate - 1) / outer_rate);
   242.
   243.    FD0_number : KDF9.buffer_number := 0;
   244.
   245. end IOC.fast.FD;

 881 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-fast-tape.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Emulation of magnetic tape decks and buffers.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.IO_Exceptions;
    18.
    19. package body IOC.fast.tape is
    20.
    21.    --
    22.    -- Ada direct-access file management.
    23.    --
    24.
    25.    procedure open_RO (the_tape : in out tape.file; name : in String) is
    26.    begin
    27.       MT_slice_IO.Open(the_tape.reel, In_File, name);
    28.       the_tape.has_a_WP_ring := False;
    29.    exception
    30.       when others =>
    31.          trap_operator_error("«" & name & "» cannot be opened, even for reading");
    32.    end open_RO;
    33.
    34.    procedure open_RW (the_tape : in out tape.file; name : in String) is
    35.    begin
    36.       MT_slice_IO.Open(the_tape.reel, Inout_File, name);
    37.       the_tape.has_a_WP_ring := True;
    38.    exception
    39.       when Ada.IO_Exceptions.Use_Error =>
    40.          the_tape.has_a_WP_ring := False;
    41.          open_RO(the_tape, name);
    42.       when Ada.IO_Exceptions.Name_Error =>
    43.          trap_operator_error("«" & name & "» cannot be opened");
    44.    end open_RW;
    45.
    46.    procedure close (the_tape : in out tape.file) is
    47.    begin
    48.       if the_tape.has_a_WP_ring then
    49.          MT_slice_IO.Flush(the_tape.reel);
    50.       end if;
    51.       MT_slice_IO.Close(the_tape.reel);
    52.    end close;
    53.
    54.    overriding
    55.    function is_open (the_deck : tape.deck)
    56.    return Boolean
    57.    is (MT_slice_IO.Is_Open(the_deck.tape_file.reel));
    58.
    59. --
    60. --
    61.    -- Slice management.
    62. --
    63. --
    64.
    65.    procedure write_slice (the_tape : in out tape.file;
    66.                           slice    : in tape.slice) is
    67.    begin
    68.       the_tape.position := the_tape.position + 1;
    69.       MT_slice_IO.Write(the_tape.reel, slice, to => the_tape.position);
    70.       if slice.kind not in tape.gap_kind then
    71.          the_tape.last_data_index := Count'Max(the_tape.last_data_index, the_tape.position);
    72.       end if;
    73.    end write_slice;
    74.
    75.    procedure read_next_slice (the_tape : in out tape.file;
    76.                               slice    : out tape.slice) is
    77.    begin
    78.       if the_tape.last_data_index > 0 then
    79.          the_tape.position := the_tape.position + 1;
    80.          MT_slice_IO.Read(the_tape.reel, slice, from => the_tape.position);
    81.       else
    82.          trap_failing_IO_operation(Name(the_tape.reel), "is an empty file");
    83.       end if;
    84.    exception
    85.       when End_Error =>
    86.           trap_failing_IO_operation(Name(the_tape.reel), "cannot be moved forward at EOF");
    87.    end read_next_slice;
    88.
    89.    procedure read_prev_slice (the_tape : in out tape.file;
    90.                               slice    : out tape.slice) is
    91.    begin
    92.       if the_tape.position > 0 then
    93.          MT_slice_IO.Read(the_tape.reel, slice, from => the_tape.position);
    94.          the_tape.position := the_tape.position - 1;
    95.       else
    96.          trap_failing_IO_operation(Name(the_tape.reel), "cannot be moved backward at BTW");
    97.       end if;
    98.    end read_prev_slice;
    99.
   100.    procedure bound_the_written_data (the_tape : in out tape.file) is
   101.       the_slice : tape.slice;
   102.    begin
   103.       the_tape.position := Size(the_tape.reel);
   104.       if the_tape.position = 0 then
   105.          -- There is no data in the file.
   106.          the_tape.last_data_index := 0;
   107.          return;
   108.       end if;
   109.       -- Locate the last data slice (if any).
   110.       while the_tape.position > 0 loop
   111.          read_prev_slice(the_tape, the_slice);
   112.       exit when the_slice.kind not in tape.gap_kind;
   113.       end loop;
   114.       if the_slice.kind in tape.gap_kind then
   115.          the_tape.last_data_index := 0;
   116.       else
   117.          the_tape.last_data_index := the_tape.position + 1;
   118.       end if;
   119.       the_tape.position := 0;
   120.    end bound_the_written_data;
   121.
   122.    procedure reset (the_deck : in out tape.deck) is
   123.     begin
   124.       bound_the_written_data(the_deck.tape_file);
   125.       the_deck.is_LBM_flagged := False;
   126.       the_deck.is_abnormal := False;
   127.       the_deck.unwound_frames := 0;
   128.    end reset;
   129.
   130. --
   131. --
   132.    -- Tape physical characteristics.
   133. --
   134. --
   135.
   136.    -- The physical end of tape (PET) is signalled one maximum block length before the tape runs out.
   137.    --  So PET is signalled at max_block_size before the absolute maximum position
   138.    --    to avoid running past the end of the tape when a very large block is written.
   139.
   140.    -- There could be as little as 60 inches of tape between the End of Tape Warning (ETW) and PET.
   141.    -- See the Manual, §22.1.3, p.182.
   142.
   143.    overriding
   144.    procedure Initialize (the_deck : in out MT_deck) is
   145.    begin
   146.       the_deck.device_name := device_name_of(the_deck);
   147.       open_RW(the_deck.tape_file, the_deck.device_name);
   148.       Initialize(IOC.device(the_deck));
   149.       the_deck.terminator        := End_Message;
   150.       the_deck.recording_density := max_bits_per_inch;  -- bits / inch
   151.       the_deck.max_reel_length   := max_reel_length;    -- inches
   152.       the_deck.inter_block_gap := the_deck.recording_density / 3;
   153.       the_deck.tape_capacity   := the_deck.max_reel_length * the_deck.recording_density;
   154.       the_deck.PET_position    := the_deck.tape_capacity - max_block_size;
   155.       the_deck.ETW_position    := the_deck.PET_position - 60 * the_deck.recording_density;
   156.       reset(tape.deck(the_deck));
   157.    end Initialize;
   158.
   159.    overriding
   160.    procedure Initialize (the_deck : in out ST_deck) is
   161.    begin
   162.       the_deck.device_name := device_name_of(the_deck);
   163.       open_RW(the_deck.tape_file, the_deck.device_name);
   164.       Initialize(IOC.device(the_deck));
   165.       the_deck.terminator        := Group_Mark;
   166.       the_deck.recording_density := max_bits_per_inch/2;  -- bits / inch
   167.       the_deck.max_reel_length   := max_reel_length;      -- inches
   168.       the_deck.inter_block_gap := the_deck.recording_density / 3;
   169.       the_deck.tape_capacity   := the_deck.max_reel_length * the_deck.recording_density;
   170.       the_deck.PET_position    := the_deck.tape_capacity - max_block_size;
   171.       the_deck.ETW_position    := the_deck.PET_position - 60 * the_deck.recording_density;
   172.       reset(tape.deck(the_deck));
   173.    end Initialize;
   174.
   175.    function is_at_BTW (the_deck : tape.deck)
   176.    return Boolean
   177.    is (the_deck.is_open and then the_deck.tape_file.position = 0);
   178.
   179.    function holds_data (the_deck : tape.deck)
   180.    return Boolean
   181.    is (the_deck.is_open and then the_deck.tape_file.last_data_index > 0);
   182.
   183.    function is_at_ETW (the_deck : tape.deck)
   184.    return Boolean
   185.    is (the_deck.is_open and then the_deck.unwound_frames >= the_deck.ETW_position);
   186.
   187.    function is_at_PET (the_deck : tape.deck)
   188.    return Boolean
   189.    is (the_deck.is_open and then the_deck.unwound_frames >= the_deck.PET_position);
   190.
   191.    procedure deal_with_trying_to_pass_PET (the_deck : in out tape.deck;
   192.                                            do_this  : String) is
   193.    begin
   194.       if is_at_PET (the_deck) then
   195.          trap_failing_IO_operation(the_deck, "an attempt was made to " & do_this & " past PET");
   196.       end if;
   197.    end deal_with_trying_to_pass_PET;
   198.
   199.    -- There are cases that are invalid iff the tape is positioned beyond the last written block.
   200.    function is_at_EOD (the_deck : tape.deck)
   201.    return Boolean
   202.    is (the_deck.is_open and then the_deck.tape_file.position > the_deck.tape_file.last_data_index);
   203.
   204.    function tape_traversal_time (the_deck : tape.deck; tape_crossed : KDF9.word)
   205.    return KDF9.us
   206.    is (the_deck.quantum * KDF9.us(tape_crossed));
   207.
   208.    function data_transfer_time (the_deck   : tape.deck;
   209.                                 byte_count : KDF9.word)
   210.    return KDF9.us
   211.    is (the_deck.quantum * KDF9.us(byte_count));
   212.
   213.    -- This is the time the MT deck is busy traversing the interblock gap and the data block.
   214.    function MT_IO_time (the_deck  : tape.deck;
   215.                         Q_operand : in KDF9.Q_register)
   216.    return KDF9.us
   217.    is (KDF9.us(the_deck.inter_block_gap) + 8*KDF9.us(Q_operand.M-Q_operand.I+1) * the_deck.quantum);
   218.
   219.    overriding
   220.    function usage (the_deck : tape.deck)
   221.    return KDF9.word
   222.    is (the_deck.bytes_moved);
   223.
   224.    overriding
   225.    procedure close (the_deck : in out tape.deck) is
   226.    begin
   227.       the_deck.tape_file.close;
   228.    end close;
   229.
   230.    procedure update_statistics (the_deck    : in out tape.deck;
   231.                                 tape_crossed,
   232.                                 bytes_moved : in length_in_frames) is
   233.       real_time : KDF9.us;
   234.    begin
   235.       the_deck.bytes_moved := the_deck.bytes_moved + KDF9.word(bytes_moved);
   236.       real_time := tape_traversal_time(the_deck, KDF9.word(tape_crossed))
   237.                  + data_transfer_time (the_deck, KDF9.word(bytes_moved));
   238.       the_deck.elapsed_time := the_deck.elapsed_time + real_time;
   239.       add_in_the_IO_CPU_time(the_deck, KDF9.word(bytes_moved));
   240.       correct_transfer_time(the_deck, real_time);
   241.    end update_statistics;
   242.
   243. --
   244. --
   245.    -- Tape manipulations.
   246. --
   247. --
   248.
   249.    type movement is (forwards, backwards);
   250.
   251.    procedure note_tape_position (the_deck    : in out tape.deck;
   252.                                  direction   : in tape.movement;
   253.                                  tape_crossed,
   254.                                  bytes_moved : in length_in_frames) is
   255.    begin
   256.       if direction = forwards then
   257.          the_deck.unwound_frames := the_deck.unwound_frames
   258.                                   + tape.length_in_frames(tape_crossed + bytes_moved);
   259.       elsif tape.length_in_frames(tape_crossed + bytes_moved) > the_deck.unwound_frames then
   260.          the_deck.unwound_frames := 0;
   261.       else
   262.          the_deck.unwound_frames := the_deck.unwound_frames
   263.                                   - tape.length_in_frames(tape_crossed + bytes_moved);
   264.       end if;
   265.    end note_tape_position;
   266.
   267.    -- KDF9 MT operations.
   268.
   269.    -- Skip back over erased tape, leaving the_slice containing the next preceding data.
   270.    -- Postcondition: the_deck.is_at_BTW or else the_slice.kind not in tape.gap_kind
   271.    procedure skip_back_over_erasure (the_deck  : in out tape.deck;
   272.                                      the_slice : in out tape.slice;
   273.                                      crossed   : in out length_in_frames) is
   274.    begin
   275.       if the_deck.is_at_BTW then
   276.          return; -- We are as far back as we can go;
   277.       end if;
   278.       if the_slice.kind in data_kind then
   279.          return;  -- We have already found the preceding data block.
   280.       end if;
   281.       loop
   282.          read_prev_slice(the_deck.tape_file, the_slice);
   283.       exit when the_deck.is_at_BTW or else the_slice.kind not in tape.gap_kind;
   284.          crossed := crossed + the_slice.size;
   285.       end loop;
   286.    end skip_back_over_erasure;
   287.
   288.    -- Skip forward over erased tape, leaving the_slice containing the next following data.
   289.    -- Postcondition: the_deck.is_at_EOD or else the_slice.kind not in tape.gap_kind
   290.    procedure skip_forward_over_erasure (the_deck  : in out tape.deck;
   291.                                         the_slice : in out tape.slice;
   292.                                         crossed   : in out length_in_frames) is
   293.    begin
   294.       if the_slice.kind in data_slice then
   295.          return;
   296.       end if;
   297.       loop
   298.          read_next_slice(the_deck.tape_file, the_slice);
   299.       exit when the_deck.is_at_EOD or else the_slice.kind not in tape.gap_kind;
   300.          crossed := crossed + the_slice.size;
   301.       end loop;
   302.    end skip_forward_over_erasure;
   303.
   304. --
   305. --
   306.    -- Tape I/O.
   307. --
   308. --
   309.
   310.    -- Deal with blocks of invalid sizes.
   311.
   312.    -- 1081 buffers always write and read a whole number of words;
   313.    --    see Manual §22.1.5, p184, ¶2; and Appendix 7 ¶3, p318.
   314.    overriding
   315.    procedure handle_any_abnormality (the_deck : in out MT_deck;
   316.                                      the_size : in length_in_frames) is
   317.    begin
   318.       the_deck.is_abnormal := the_deck.is_abnormal or (the_size mod 8 /= 0);
   319.    end handle_any_abnormality;
   320.
   321.    -- §3.4.7 of the EGDON 3 manual says that the 7-track tape buffer, due to a hardware
   322.    --    limitation, rejects blocks (other than tape marks) of less than 6 characters.
   323.    overriding
   324.    procedure handle_any_abnormality (the_deck : in out ST_deck;
   325.                                      the_size : in length_in_frames) is
   326.    begin
   327.       the_deck.is_abnormal := the_deck.is_abnormal or (the_size < 6);
   328.    end handle_any_abnormality;
   329.
   330.    procedure read_block (the_deck  : in out tape.deck;
   331.                          the_data  : out tape.block_storage;
   332.                          the_size  : out length_in_frames;
   333.                          direction : in movement := forwards) is
   334.       left,
   335.       right      : length_in_frames := 1;
   336.       block_size,
   337.       crossed    : length_in_frames := 0;
   338.       is_last,
   339.       is_flagged : Boolean := False;
   340.       the_slice  : tape.slice := a_NULL_slice;
   341.    begin
   342.       the_deck.is_LBM_flagged := False;
   343.
   344.       skip_forward_over_erasure(the_deck, the_slice, crossed);
   345.
   346.       -- Ensure that we are not beyond the end of valid data.
   347.       if the_deck.is_at_EOD then
   348.          trap_failing_IO_operation(
   349.                                    the_deck,
   350.                                    "there is no data past slice" & the_deck.tape_file.position'Image
   351.                                   );
   352.       end if;
   353.
   354.       if the_slice.kind in tape.tape_mark_kind then
   355.          -- Deal with a tape mark block; according to the Maual, Appendix 7, §2, p.317,
   356.          --    it reads as a single character with value #17.
   357.          block_size := 8;
   358.          the_data(1)    := KDF9_char_sets.TP_CN(KDF9_char_sets.Tape_Mark);
   359.          the_data(2..8) := (others => KDF9_char_sets.TP_CN(KDF9_char_sets.Blank_Space));
   360.          the_deck.is_LBM_flagged := True;
   361.       else
   362.          -- We have a bona fide data block.
   363.          the_size := 0;
   364.          -- Accumulate a series of slicefuls.
   365.          loop
   366.             right := left + the_slice.size - 1;
   367.             the_data(left .. right) := the_slice.data(1..the_slice.size);
   368.             block_size := block_size + the_slice.size;
   369.             left := left + the_slice.size;
   370.             is_flagged := is_flagged or the_slice.is_LBM_flagged;
   371.             is_last  := the_slice.is_last;
   372.          exit when is_last or block_size = max_block_size;
   373.             read_next_slice(the_deck.tape_file, the_slice);
   374.          end loop;
   375.          the_deck.is_LBM_flagged := is_flagged;
   376.       end if;
   377.       the_size := block_size;
   378.
   379.       note_tape_position(the_deck, direction,
   380.                         crossed + the_deck.inter_block_gap, bytes_moved => the_size);
   381.       update_statistics(the_deck,
   382.                         crossed + the_deck.inter_block_gap, bytes_moved => the_size);
   383.
   384.      if not is_last and block_size = max_block_size then
   385.          trap_failing_IO_operation(the_deck, "a magnetic tape block > 32KW");
   386.       end if;
   387.       handle_any_abnormality(the_deck, block_size);
   388.    end read_block;
   389.
   390.    procedure increment (word_address : in out KDF9.address;
   391.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   392.    begin
   393.       if symbol_nr < 7 then
   394.          symbol_nr := symbol_nr + 1;
   395.       else
   396.          symbol_nr := 0;
   397.          word_address := word_address + 1;
   398.       end if;
   399.    end increment;
   400.
   401.    tape_mark_data_word : constant KDF9.word := 8#17_00_00_00_00_00_00_00#;
   402.
   403.    procedure read (the_deck       : in out tape.deck;
   404.                    Q_operand      : in KDF9.Q_register;
   405.                    to_terminator  : in Boolean := False) is
   406.       start_address : constant KDF9.address := Q_operand.I;
   407.       end_address   : constant KDF9.address := Q_operand.M;
   408.       the_data : tape.block_storage;
   409.       s        : KDF9_char_sets.symbol_index;
   410.       w        : KDF9.address;
   411.       stored   : KDF9.word := 0;
   412.       the_size : length_in_frames;
   413.    begin
   414.       validate_device(the_deck);
   415.       check_addresses_and_lockouts(start_address, end_address);
   416.
   417.       read_block(the_deck, the_data, the_size);
   418.
   419.       if the_size mod 8 /= 0 and the_deck.kind = MT_kind then
   420.          -- Disregard an incomplete final word; see Manual, §22.1.5, p184, ¶2.
   421.          the_deck.is_abnormal := True;
   422.          the_size := the_size - the_size mod 8;
   423.       end if;
   424.
   425.       -- Store the relevant words.
   426.       w := start_address;
   427.       s := 0;
   428.       for i in 1 .. the_size loop
   429.          if s = 0 then
   430.             store_word(0, w);
   431.          end if;
   432.          store_symbol(CN_TR(the_data(i)), w, s);
   433.          stored := stored + 1;
   434.       exit when (w = end_address) and (s = 7);
   435.       exit when to_terminator and CN_TR(the_data(i)) = the_deck.terminator;
   436.          increment(w, s);
   437.       end loop;
   438.       if to_terminator then
   439.          correct_transfer_time(the_deck, stored);
   440.       end if;
   441.    end read;
   442.
   443.    procedure find_start_of_earlier_block (the_deck : in out tape.deck;
   444.                                           crossed  : in out length_in_frames) is
   445.       the_slice  : tape.slice := a_NULL_slice;
   446.       block_size : length_in_frames;
   447.    begin
   448.       if the_deck.is_at_BTW then
   449.          return; -- We have already gone as far back as possible.
   450.       end if;
   451.
   452.       -- Skip back over any erasures or tape marks.
   453.       skip_back_over_erasure(the_deck, the_slice, crossed);
   454.       crossed := crossed + the_deck.inter_block_gap;
   455.
   456.       if the_deck.is_at_BTW and the_slice.kind in tape.gap_kind then
   457.          the_deck.is_abnormal := True;
   458.          trap_failing_IO_operation(the_deck, "cannot move back, at BTW");
   459.       end if;
   460.
   461.       if not the_slice.is_last then
   462.          trap_failing_IO_operation(the_deck, "on-tape data is malformed");
   463.       end if;
   464.
   465.       -- We have reached the last slice of the block.
   466.       if the_deck.kind = ST_kind and the_slice.kind in tape_mark_kind then
   467.          block_size := 1;
   468.       else
   469.          block_size := the_slice.size;
   470.          -- Jump backwards over data slices until we reach the first of the block.
   471.          while not the_slice.is_first and then the_deck.tape_file.position > 0 loop
   472.             read_prev_slice(the_deck.tape_file, the_slice);
   473.             block_size := block_size + the_slice.size;
   474.          end loop;
   475.          handle_any_abnormality(the_deck, block_size);
   476.       end if;
   477.
   478.       crossed := crossed + block_size;
   479.    end find_start_of_earlier_block;
   480.
   481.    procedure decrement (word_address : in out KDF9.address;
   482.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   483.    begin
   484.       if symbol_nr > 0 then
   485.          symbol_nr := symbol_nr - 1;
   486.       else
   487.          symbol_nr := 7;
   488.          word_address := word_address + 1;
   489.       end if;
   490.    end decrement;
   491.
   492.    procedure read_backwards (the_deck       : in out tape.deck;
   493.                              Q_operand      : in KDF9.Q_register;
   494.                              to_terminator  : in Boolean := False) is
   495.       start_address : constant KDF9.address := Q_operand.I;
   496.       end_address   : constant KDF9.address := Q_operand.M;
   497.       terminator    : constant KDF9_char_sets.symbol := the_deck.terminator;
   498.       the_data  : tape.block_storage;
   499.       s         : KDF9_char_sets.symbol_index;
   500.       w         : KDF9.address;
   501.       the_first,
   502.       the_last  : length_in_frames;
   503.       crossed   : length_in_frames := 0 with Warnings => Off;  -- Because its value is never used.
   504.    begin
   505.       validate_device(the_deck);
   506.       check_addresses_and_lockouts(start_address, end_address);
   507.
   508.       -- Locate the start of the previous block.
   509.       find_start_of_earlier_block(the_deck, crossed);
   510.
   511.       -- Read it normally, i.e. forwards.
   512.       read_block(the_deck, the_data, the_last, backwards);
   513.
   514.       -- And retrace our steps, to position the tape as if the block had been read backwards.
   515.       find_start_of_earlier_block(the_deck, crossed);
   516.
   517.       -- Disregard an incomplete first word; see Manual §22.1.5, p184, ¶2; and Appendix 7 ¶3, p318.
   518.       if the_last mod 8 = 0 or the_deck.kind = ST_kind then
   519.          the_first := the_data'First;
   520.       elsif the_last = 1 and the_deck.kind = ST_kind then
   521.          -- See Manual, Appendix 7 ¶2, p317.
   522.          store_word(tape_mark_data_word, start_address);
   523.       else
   524.          the_deck.is_abnormal := True;
   525.          the_first := the_data'First + the_last mod 8;
   526.       end if;
   527.
   528.       -- Store the relevant words.
   529.       w := start_address;
   530.       s := 7;
   531.       for i in reverse the_first .. the_last loop
   532.          if s = 7 then
   533.             store_word(0, w);
   534.          end if;
   535.          store_symbol(CN_TR(the_data(i)), w, s);
   536.       exit when to_terminator and CN_TR(the_data(i)) = terminator;
   537.          decrement(w, s);
   538.       end loop;
   539.    end read_backwards;
   540.
   541. --
   542. --
   543.    -- KDF9 tape input orders.
   544. --
   545. --
   546.
   547.    -- MFRQq
   548.    overriding
   549.    procedure PIA (the_deck    : in out tape.deck;
   550.                   Q_operand   : in KDF9.Q_register;
   551.                   set_offline : in Boolean) is
   552.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   553.    begin
   554.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   555.       read(the_deck, Q_operand, to_terminator => False);
   556.       lock_out_relative_addresses(Q_operand);
   557.    end PIA;
   558.
   559.    -- MFREQq
   560.    overriding
   561.    procedure PIB (the_deck    : in out tape.deck;
   562.                   Q_operand   : in KDF9.Q_register;
   563.                   set_offline : in Boolean) is
   564.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   565.    begin
   566.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   567.       read(the_deck, Q_operand, to_terminator => True);
   568.       lock_out_relative_addresses(Q_operand);
   569.    end PIB;
   570.
   571.    -- as PIA
   572.    overriding
   573.    procedure PIC (the_deck    : in out tape.deck;
   574.                   Q_operand   : in KDF9.Q_register;
   575.                   set_offline : in Boolean) is
   576.    begin
   577.       the_deck.PIA(Q_operand, set_offline);
   578.    end PIC;
   579.
   580.    -- as PIB
   581.    overriding
   582.    procedure PID (the_deck    : in out tape.deck;
   583.                   Q_operand   : in KDF9.Q_register;
   584.                   set_offline : in Boolean) is
   585.    begin
   586.       the_deck.PIB(Q_operand, set_offline);
   587.    end PID;
   588.
   589.    -- MBRQq
   590.    overriding
   591.    procedure PIE (the_deck    : in out tape.deck;
   592.                   Q_operand   : in KDF9.Q_register;
   593.                   set_offline : in Boolean) is
   594.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   595.    begin
   596.       if the_deck.is_at_BTW then
   597.          trap_illegal_instruction("MBRQq at BTW on " & the_deck.device_name);
   598.       end if;
   599.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   600.       read_backwards(the_deck, Q_operand, to_terminator => False);
   601.       if the_deck.kind = ST_kind then
   602.          the_deck.is_LBM_flagged := False;
   603.       end if;
   604.       lock_out_relative_addresses(Q_operand);
   605.    end PIE;
   606.
   607.    -- MBREQq
   608.    overriding
   609.    procedure PIF (the_deck    : in out tape.deck;
   610.                   Q_operand   : in KDF9.Q_register;
   611.                   set_offline : in Boolean) is
   612.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   613.    begin
   614.       if the_deck.is_at_BTW then
   615.          trap_illegal_instruction("MBREQq at BTW on " & the_deck.device_name);
   616.       end if;
   617.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   618.       read_backwards(the_deck, Q_operand, to_terminator => True);
   619.       if the_deck.kind = ST_kind then
   620.          the_deck.is_LBM_flagged := False;
   621.       end if;
   622.       lock_out_relative_addresses(Q_operand);
   623.    end PIF;
   624.
   625.    -- as PIE
   626.    overriding
   627.    procedure PIG (the_deck    : in out tape.deck;
   628.                   Q_operand   : in KDF9.Q_register;
   629.                   set_offline : in Boolean) is
   630.    begin
   631.       the_deck.PIE(Q_operand, set_offline);
   632.    end PIG;
   633.
   634.    -- as PIF
   635.    overriding
   636.    procedure PIH (the_deck    : in out tape.deck;
   637.                   Q_operand   : in KDF9.Q_register;
   638.                   set_offline : in Boolean) is
   639.    begin
   640.       the_deck.PIF(Q_operand, set_offline);
   641.    end PIH;
   642.
   643. --
   644. --
   645.    -- KDF9 tape movement and test orders.
   646. --
   647. --
   648.
   649.    procedure find_start_of_later_block (the_deck : in out tape.deck;
   650.                                         crossed  : in out length_in_frames) is
   651.       the_slice  : tape.slice := a_NULL_slice;
   652.       block_size : length_in_frames := 0;
   653.    begin
   654.       -- Skip over any erasures or tape marks.
   655.       skip_forward_over_erasure(the_deck, the_slice, crossed);
   656.       crossed := crossed + the_deck.inter_block_gap;
   657.
   658.       if not the_slice.is_first then
   659.          trap_failing_IO_operation(the_deck, "on-tape data is malformed");
   660.       end if;
   661.
   662.       -- We have reached the first slice of the block.
   663.       if the_deck.kind = ST_kind and the_slice.kind in tape_mark_kind then
   664.          block_size := 1;
   665.       else
   666.          block_size := the_slice.size;
   667.          -- Ignore data slices until we get to the last slice of the block.
   668.          while not the_slice.is_last loop
   669.             read_next_slice(the_deck.tape_file, the_slice);
   670.             block_size := block_size + the_slice.size;
   671.          end loop;
   672.          handle_any_abnormality(the_deck, block_size);
   673.       end if;
   674.
   675.       the_deck.is_LBM_flagged := the_slice.is_LBM_flagged;
   676.       crossed := crossed + block_size;
   677.    end find_start_of_later_block;
   678.
   679.    procedure skip_forwards (the_deck       : in out tape.deck;
   680.                             blocks_skipped : in KDF9.word) is
   681.       crossed : length_in_frames := 0;
   682.    begin
   683.       for i in 1 .. blocks_skipped loop
   684.          find_start_of_later_block(the_deck, crossed);
   685.       -- MFSKQq stops at an LBM-flagged block, or on count expiry.
   686.       -- Unlike MBSKQq it does record having seen an LBM-flagged block during the skipping.
   687.       -- See the Manual, §22.1.3, p.183, ¶1 and §22.1.9, p.188, ¶-2.
   688.       exit when the_deck.is_LBM_flagged;
   689.       end loop;
   690.       note_tape_position(the_deck, forwards, crossed, bytes_moved => 0);
   691.       update_statistics(the_deck, crossed, bytes_moved => 0);
   692.    end skip_forwards;
   693.
   694.    -- MFSKQq
   695.    overriding
   696.    procedure PMA (the_deck    : in out tape.deck;
   697.                   Q_operand   : in KDF9.Q_register;
   698.                   set_offline : in Boolean) is
   699.    begin
   700.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   701.       if Q_operand.M = 0 then
   702.          skip_forwards(the_deck, 32768);  -- See Manual §22.1.9, p188, ¶1.
   703.       else
   704.          require_positive_count(Q_operand.M);
   705.          skip_forwards(the_deck, KDF9.word(Q_operand.M));
   706.       end if;
   707.    end PMA;
   708.
   709.    -- MBTQq
   710.    overriding
   711.    procedure PMB (the_deck    : in out tape.deck;
   712.                   Q_operand   : in KDF9.Q_register;
   713.                   set_offline : in Boolean) is
   714.    begin
   715.       validate_device(the_deck);
   716.       validate_parity(the_deck);
   717.       deal_with_a_busy_device(the_deck, 14, set_offline);
   718.       the_T_bit_is_set := the_deck.is_at_BTW and the_deck.holds_data;
   719.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   720.    end PMB;
   721.
   722.    -- MLBQq
   723.    overriding
   724.    procedure PMC (the_deck    : in out tape.deck;
   725.                   Q_operand   : in KDF9.Q_register;
   726.                   set_offline : in Boolean) is
   727.    begin
   728.       validate_device(the_deck);
   729.       validate_parity(the_deck);
   730.       deal_with_a_busy_device(the_deck, 14, set_offline);
   731.       the_T_bit_is_set := the_deck.is_LBM_flagged;
   732.       the_deck.is_LBM_flagged := False;
   733.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   734.    end PMC;
   735.
   736.    procedure skip_backwards (the_deck       : in out tape.deck;
   737.                              blocks_skipped : in KDF9.word) is
   738.       crossed : length_in_frames := 0;
   739.    begin
   740.       for i in 1 .. blocks_skipped loop
   741.       exit when the_deck.is_at_BTW;  -- I.e., the tape is fully rewound.
   742.          find_start_of_earlier_block(the_deck, crossed);
   743.       -- MBSKQq does not stop at an LBM-flagged block, only at BTW or count expiry.
   744.       -- It ignores LBM flags encountered during the skipping.
   745.       -- See the Manual, §22.1.3, p.183, ¶1 and §22.1.9, p.188, ¶-2.
   746.       end loop;
   747.       note_tape_position(the_deck, backwards, crossed, bytes_moved => 0);
   748.       update_statistics(the_deck, crossed, bytes_moved => 0);
   749.    end skip_backwards;
   750.
   751.    -- MRWDQq
   752.    overriding
   753.    procedure PMD (the_deck    : in out tape.deck;
   754.                   Q_operand   : in KDF9.Q_register;
   755.                   set_offline : in Boolean) is
   756.       byte_count,
   757.       tape_length : length_in_frames := 0;
   758.       the_slice   : tape.slice;
   759.    begin  -- PMD
   760.       the_deck.is_abnormal := False;  -- See Manual §22.1.9, p.189, ¶-2.
   761.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   762.       -- No motion takes place if the tape is at BTW; see Manual §22.1.9, p.190, ¶1.
   763.       if the_deck.tape_file.position > 0 then
   764.          -- Make sure we dont try to read past the end of data.
   765.          -- Spool back to the BTW, accumulating distances.
   766.          while the_deck.tape_file.position > 0 loop
   767.             read_prev_slice(the_deck.tape_file, the_slice);
   768.             case the_slice.kind is
   769.                when data_slice =>
   770.                   byte_count := byte_count + the_slice.size;
   771.                   if the_slice.is_first then
   772.                      tape_length := tape_length + the_deck.inter_block_gap;
   773.                   end if;
   774.                when GAP_slice
   775.                   | WIPE_slice =>
   776.                   tape_length := tape_length + the_slice.size;
   777.                when others =>
   778.                   null;
   779.             end case;
   780.          end loop;
   781.       else
   782.          -- No motion takes place; see Manual §22.1.9, p.190, ¶1.
   783.          null;
   784.       end if;
   785.
   786.       update_statistics(the_deck, tape_length + byte_count, bytes_moved => 0);
   787.
   788.       reset(the_deck);
   789.    end PMD;
   790.
   791.    -- MBSKQq
   792.    overriding
   793.    procedure PME (the_deck    : in out tape.deck;
   794.                   Q_operand   : in KDF9.Q_register;
   795.                   set_offline : in Boolean) is
   796.    begin
   797.       if the_deck.is_at_BTW then
   798.          trap_illegal_instruction("MBSKQq at BTW on " & the_deck.device_name);
   799.       end if;
   800.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   801.       if Q_operand.M = 0 then
   802.          skip_backwards(the_deck, 32768);  -- See Manual §22.1.9, p188, ¶1.
   803.       else
   804.          require_positive_count(Q_operand.M);
   805.          skip_backwards(the_deck, KDF9.word(Q_operand.M));
   806.       end if;
   807.    end PME;
   808.
   809.    -- METQq
   810.    overriding
   811.    procedure PMF (the_deck    : in out tape.deck;
   812.                   Q_operand   : in KDF9.Q_register;
   813.                   set_offline : in Boolean) is
   814.    begin
   815.       validate_device(the_deck);
   816.       validate_parity(the_deck);
   817.       deal_with_a_busy_device(the_deck, 13, set_offline);
   818.       the_T_bit_is_set := the_deck.is_at_ETW;
   819.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   820.    end PMF;
   821.
   822.    -- PMKQq, forward skip, even parity, for character data with "group mark" (8#77#)
   823.    overriding
   824.    procedure PMK (the_deck    : in out tape.deck;
   825.                   Q_operand   : in KDF9.Q_register;
   826.                   set_offline : in Boolean) is
   827.    begin
   828.       if the_deck.kind = MT_kind then
   829.          trap_illegal_instruction("PMKQq on 1081 deck " & the_deck.device_name);
   830.       else
   831.          the_deck.PMA(Q_operand, set_offline);
   832.       end if;
   833.    end PMK;
   834.
   835.    -- PMLQq, backward skip, even parity, for character data with "group mark" (8#77#)
   836.    overriding
   837.    procedure PML (the_deck    : in out tape.deck;
   838.                   Q_operand   : in KDF9.Q_register;
   839.                   set_offline : in Boolean) is
   840.    begin
   841.       if the_deck.kind = MT_kind then
   842.          trap_illegal_instruction("PMLQq on 1081 deck " & the_deck.device_name);
   843.       else
   844.          the_deck.PMB(Q_operand, set_offline);
   845.       end if;
   846.    end PML;
   847.
   848. --
   849. --
   850.    -- KDF9 tape output orders.
   851. --
   852. --
   853.
   854.    procedure put_data_slice (the_deck   : in out tape.deck;
   855.                              data       : in tape.data_storage;
   856.                              size       : in length_in_frames;
   857.                              is_first,
   858.                              is_last,
   859.                              is_flagged : in Boolean) is
   860.       the_slice : tape.slice;
   861.    begin
   862.       the_slice := (
   863.                     data_slice,
   864.                     is_LBM_flagged => is_flagged,
   865.                     is_first => put_data_slice.is_first,
   866.                     is_last  => put_data_slice.is_last,
   867.                     size     => put_data_slice.size,
   868.                     data     => erased_gap_data
   869.                    );
   870.       the_slice.data(1 .. put_data_slice.size) := put_data_slice.data;
   871.       write_slice(the_deck.tape_file, the_slice);
   872.    end put_data_slice;
   873.
   874.    procedure write_block (the_deck       : in out tape.deck;
   875.                           the_data       : in tape.data_storage;
   876.                           is_LBM_flagged : in Boolean) is
   877.       remnant  : length_in_frames := the_data'Length;
   878.       from     : length_in_frames;
   879.       the_size : length_in_frames;
   880.    begin
   881.       if not the_deck.tape_file.has_a_WP_ring then
   882.          trap_operator_error(the_deck.device_name & " does not have a Write Permit Ring");
   883.       end if;
   884.
   885.       deal_with_trying_to_pass_PET(the_deck, "write");
   886.
   887.       the_deck.is_LBM_flagged := False;
   888.
   889.       -- Write the first (and possibly final) slice of the block.
   890.       the_size := (if remnant > slice_size_limit then slice_size_limit else remnant);
   891.       remnant := remnant - the_size;
   892.       from := the_data'First;
   893.       put_data_slice (
   894.                       the_deck,
   895.                       the_data(from .. the_size),
   896.                       the_size,
   897.                       is_first   => True,
   898.                       is_last    => remnant = 0,
   899.                       is_flagged => write_block.is_LBM_flagged
   900.                      );
   901.
   902.       -- Write any full slices, the last of which may be final.
   903.       while remnant >= slice_size_limit loop
   904.          deal_with_trying_to_pass_PET(the_deck, "write");
   905.          remnant := remnant - slice_size_limit;
   906.          from := from + slice_size_limit;
   907.          put_data_slice (
   908.                          the_deck,
   909.                          the_data(from .. from+slice_size_limit-1),
   910.                          slice_size_limit,
   911.                          is_first   => False,
   912.                          is_last    => remnant = 0,
   913.                          is_flagged => write_block.is_LBM_flagged
   914.                         );
   915.       end loop;
   916.
   917.       -- Write the residue as a final slice of the block.
   918.       if remnant > 0 then
   919.          put_data_slice (
   920.                          the_deck,
   921.                          the_data(from+slice_size_limit .. the_data'Last),
   922.                          remnant,
   923.                          is_first   => False,
   924.                          is_last    => True,
   925.                          is_flagged => write_block.is_LBM_flagged
   926.                         );
   927.       end if;
   928.
   929.       note_tape_position(the_deck, forwards,
   930.                         the_deck.inter_block_gap, bytes_moved => the_data'Length);
   931.       update_statistics(the_deck,
   932.                         the_deck.inter_block_gap, bytes_moved => the_data'Length);
   933.
   934.    end write_block;
   935.
   936.    procedure write (the_deck       : in out tape.deck;
   937.                     Q_operand      : in KDF9.Q_register;
   938.                     is_LBM_flagged : in Boolean := False) is
   939.       start_address : constant KDF9.address := Q_operand.I;
   940.       end_address   : constant KDF9.address := Q_operand.M;
   941.    begin
   942.       validate_device(the_deck);
   943.       check_addresses_and_lockouts(start_address, end_address);
   944.       declare
   945.          next_byte : length_in_frames := 1;
   946.          the_data  : tape.data_storage(1 .. length_in_frames(end_address-start_address+1)*8);
   947.       begin
   948.       word_loop:
   949.          for w in start_address .. end_address loop
   950.             for c in KDF9_char_sets.symbol_index'Range loop
   951.                the_data(next_byte) := TP_CN(fetch_symbol(w, c));
   952.                next_byte := next_byte + 1;
   953.             end loop;
   954.          end loop word_loop;
   955.          write_block(the_deck, the_data, is_LBM_flagged);
   956.       end;
   957.    end write;
   958.
   959.    procedure write_to_terminator (the_deck       : in out tape.deck;
   960.                                   Q_operand      : in KDF9.Q_register;
   961.                                   is_LBM_flagged : in Boolean := False) is
   962.       start_address : constant KDF9.address := Q_operand.I;
   963.       end_address   : constant KDF9.address := Q_operand.M;
   964.    begin
   965.       validate_device(the_deck);
   966.       check_addresses_and_lockouts(start_address, end_address);
   967.       declare
   968.          next_byte : length_in_frames := 1;
   969.          the_data  : tape.data_storage(1 .. length_in_frames(end_address-start_address+1)*8);
   970.          symbol    : KDF9_char_sets.symbol;
   971.       begin
   972.       word_loop:
   973.          for w in start_address .. end_address loop
   974.             for c in KDF9_char_sets.symbol_index'Range loop
   975.                symbol := fetch_symbol(w, c);
   976.                the_data(next_byte) := TP_CN(symbol);
   977.                next_byte := next_byte + 1;
   978.          exit word_loop when symbol = the_deck.terminator;
   979.             end loop;
   980.          end loop word_loop;
   981.          if the_deck.kind = MT_kind then
   982.             -- Pad out the last word to a full 8 symbols; 7-track decks do not do this.
   983.             while next_byte mod 8 /= 1 loop
   984.                the_data(next_byte) := TP_CN(0);
   985.                next_byte := next_byte + 1;
   986.             end loop;
   987.          end if;
   988.          write_block(the_deck, the_data(1 .. next_byte-1), is_LBM_flagged);
   989.          correct_transfer_time(the_deck, KDF9.word(next_byte-1));
   990.       end;
   991.    end write_to_terminator;
   992.
   993.    -- MWQq
   994.    overriding
   995.    procedure POA (the_deck    : in out tape.deck;
   996.                   Q_operand   : in KDF9.Q_register;
   997.                   set_offline : in Boolean) is
   998.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   999.    begin
  1000.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1001.       write(the_deck, Q_operand);
  1002.       lock_out_relative_addresses(Q_operand);
  1003.    end POA;
  1004.
  1005.    -- MWEQq
  1006.    overriding
  1007.    procedure POB (the_deck    : in out tape.deck;
  1008.                   Q_operand   : in KDF9.Q_register;
  1009.                   set_offline : in Boolean) is
  1010.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1011.    begin
  1012.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1013.       write_to_terminator(the_deck, Q_operand);
  1014.       lock_out_relative_addresses(Q_operand);
  1015.    end POB;
  1016.
  1017.    procedure put_ST_tapemark_slice (the_deck    : in out tape.deck;
  1018.                                     Q_operand   : in KDF9.Q_register;
  1019.                                     set_offline : in Boolean;
  1020.                                     the_slice   : in tape.slice) is
  1021.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, (Q_operand.C, 0, 0));
  1022.    begin
  1023.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1024.       write_slice(the_deck.tape_file, the_slice);
  1025.    end put_ST_tapemark_slice;
  1026.
  1027.    -- MLWQq
  1028.    overriding
  1029.    procedure POC (the_deck    : in out tape.deck;
  1030.                   Q_operand   : in KDF9.Q_register;
  1031.                   set_offline : in Boolean) is
  1032.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1033.    begin
  1034.       if the_deck.kind = MT_kind then
  1035.          start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1036.          write(the_deck, Q_operand, is_LBM_flagged => True);
  1037.          lock_out_relative_addresses(Q_operand);
  1038.       else
  1039.          put_ST_tapemark_slice(the_deck, Q_operand, set_offline, odd_parity_tape_mark);
  1040.       end if;
  1041.    end POC;
  1042.
  1043.    -- MLWEQq
  1044.    overriding
  1045.    procedure POD (the_deck    : in out tape.deck;
  1046.                   Q_operand   : in KDF9.Q_register;
  1047.                   set_offline : in Boolean) is
  1048.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1049.    begin
  1050.       if the_deck.kind = MT_kind then
  1051.          start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1052.          write_to_terminator(the_deck, Q_operand, is_LBM_flagged => True);
  1053.          lock_out_relative_addresses(Q_operand);
  1054.       else
  1055.          put_ST_tapemark_slice(the_deck, Q_operand, set_offline, even_parity_tape_mark);
  1056.       end if;
  1057.    end POD;
  1058.
  1059.    procedure erase_tape_gap (the_deck     : in out tape.deck;
  1060.                              the_length   : in KDF9.Q_part; -- the_length is a number of words.
  1061.                              the_gap_kind : in tape.gap_kind) is
  1062.       crossing  : constant length_in_frames := length_in_frames(the_length) * 8;
  1063.       the_slice : tape.slice := (if the_gap_kind = GAP_slice then a_GAP_slice else a_WIPE_slice);
  1064.       remnant   : length_in_frames := crossing;
  1065.       old_slice : tape.slice;
  1066.       the_size  : length_in_frames;
  1067.    begin
  1068.       loop
  1069.          deal_with_trying_to_pass_PET(the_deck, "erase");
  1070.          the_size := length_in_frames'Min(remnant, slice_size_limit);
  1071.          remnant  := remnant - the_size;
  1072.
  1073.          the_slice.size := the_size;
  1074.
  1075.          if the_gap_kind = GAP_slice  and then
  1076.                not the_deck.is_at_EOD then
  1077.             -- Safety rules apply to erasing gaps; see the Manual, Appendix 6.8, p.314.
  1078.             read_next_slice(the_deck.tape_file, old_slice);
  1079.             if old_slice.kind /= WIPE_slice then
  1080.                trap_failing_IO_operation(
  1081.                                          the_deck,
  1082.                                          "a GAP of length"
  1083.                                        & the_length'Image
  1084.                                        & " words would overwrite data at slice"
  1085.                                        & the_deck.tape_file.position'Image
  1086.                                         );
  1087.             end if;
  1088.             -- Restore the writing position.
  1089.             read_prev_slice(the_deck.tape_file, old_slice);
  1090.          end if;
  1091.
  1092.          write_slice(the_deck.tape_file, the_slice);
  1093.       exit when remnant = 0;
  1094.       end loop;
  1095.
  1096.       the_deck.is_LBM_flagged := False;
  1097.       note_tape_position(the_deck, forwards, crossing, bytes_moved => 0);
  1098.       update_statistics(the_deck, crossing, bytes_moved => 0);
  1099.    end erase_tape_gap;
  1100.
  1101.    -- MGAPQq
  1102.    overriding
  1103.    procedure POE (the_deck    : in out tape.deck;
  1104.                   Q_operand   : in KDF9.Q_register;
  1105.                   set_offline : in Boolean) is
  1106.       time : constant KDF9.us := 19+IO_elapsed_time(the_deck, KDF9.word(Q_operand.M));
  1107.    begin
  1108.       if not the_deck.tape_file.has_a_WP_ring then
  1109.          trap_operator_error(the_deck.device_name & " does not have a Write Permit Ring");
  1110.       end if;
  1111.       require_positive_count(Q_operand.M);
  1112.       start_data_transfer(the_deck, Q_operand, set_offline, time);
  1113.       erase_tape_gap(the_deck, Q_operand.M, the_gap_kind => GAP_slice);
  1114.    end POE;
  1115.
  1116.    -- MWIPEQq
  1117.    overriding
  1118.    procedure POF (the_deck    : in out tape.deck;
  1119.                   Q_operand   : in KDF9.Q_register;
  1120.                   set_offline : in Boolean) is
  1121.       time : constant KDF9.us := 19+IO_elapsed_time(the_deck, KDF9.word(Q_operand.M));
  1122.    begin
  1123.       if not the_deck.tape_file.has_a_WP_ring then
  1124.          trap_operator_error(the_deck.device_name & " does not have a Write Permit Ring");
  1125.       end if;
  1126.       require_positive_count(Q_operand.M);
  1127.       start_data_transfer(the_deck, Q_operand, set_offline, time);
  1128.       erase_tape_gap(the_deck, Q_operand.M, the_gap_kind => WIPE_slice);
  1129.    end POF;
  1130.
  1131.    overriding
  1132.    procedure Finalize (the_deck : in out tape.deck) is
  1133.       the_deck_was_used : constant Boolean := the_deck.bytes_moved /= 0 or not the_deck.is_at_BTW;
  1134.       buffer            : constant String  := oct_of(KDF9.Q_part(the_deck.number), 2);
  1135.    begin
  1136.       if the_deck.is_open then
  1137.          if (the_final_state_is_wanted and the_log_is_wanted) and then
  1138.                the_deck_was_used                                  then
  1139.             log_line(
  1140.                      the_deck.device_name
  1141.                    & " on buffer #"
  1142.                    & buffer
  1143.                    & " transferred"
  1144.                    & the_deck.bytes_moved'Image
  1145.                    & " character" & plurality(the_deck.bytes_moved)
  1146.                    & (
  1147.                       if    the_deck.is_at_PET then ", and is now at PET."
  1148.                       elsif the_deck.is_at_ETW then ", and is now at ETW."
  1149.                       else                          "."
  1150.                      )
  1151.                    );
  1152.          end if;
  1153.          close(the_deck.tape_file);
  1154.       end if;
  1155.    end Finalize;
  1156.
  1157.
  1158. --
  1159. --
  1160.    -- KDF9 tape configuration.
  1161. --
  1162. --
  1163.
  1164.    type tape_access is access tape.deck'Class;
  1165.    tape_deck         : array (IOC.unit_number range 0..14) of tape_access with Warnings => Off;
  1166.
  1167.    -- This cannot overflow, because there must be at least 2 non-tape buffers: FW0 and TR0.
  1168.    tape_units, ST_units : IOC.unit_number := 0;
  1169.
  1170.    procedure enable_MT_deck (b : in KDF9.buffer_number) is
  1171.    begin
  1172.       if tape_units > tape_deck'Last then
  1173.          trap_operator_error("too many tape decks specified");
  1174.       end if;
  1175.       tape_deck(tape_units) := new MT_deck (number => b, unit => tape_units-ST_units);
  1176.       tape_units := tape_units + 1;
  1177.    end enable_MT_deck;
  1178.
  1179.    procedure enable_ST_deck (b : in KDF9.buffer_number) is
  1180.    begin
  1181.       if tape_units > tape_deck'Last then
  1182.          trap_operator_error("too many tape decks specified");
  1183.       end if;
  1184.       tape_deck(tape_units) := new ST_deck (number => b, unit => ST_units);
  1185.       tape_units := tape_units + 1;
  1186.       ST_units   := ST_units + 1;
  1187.    end enable_ST_deck;
  1188.
  1189.    -- This is for use by Directors.
  1190.    procedure find_tape (the_label  : in  tape.data_storage;
  1191.                         its_number : out KDF9.buffer_number;
  1192.                         its_serial : out KDF9.word) is
  1193.
  1194.       function as_word (the_serial : tape.data_storage)
  1195.       return KDF9.word is
  1196.          word : KDF9.word := 0;
  1197.       begin
  1198.          for b in the_serial'Range loop
  1199.             word := (word * 2**6) or KDF9.word(CN_TR(the_serial(b)));
  1200.          end loop;
  1201.          return word;
  1202.       end as_word;
  1203.
  1204.       the_block : tape.data_storage(1 .. max_block_size);
  1205.       the_size  : length_in_frames;
  1206.
  1207.    begin -- find_tape
  1208.       for t in KDF9.buffer_number loop
  1209.          if buffer(t) /= null                      and then
  1210.                buffer(t).kind in MT_kind | ST_kind and then
  1211.                    is_unallocated(buffer(t))           then
  1212.             declare
  1213.                the_deck : tape.deck renames tape.deck(buffer(t).all);
  1214.             begin
  1215.                if the_deck.holds_data  and then
  1216.                      the_deck.is_at_BTW    then
  1217.                   -- Read the label.
  1218.                   -- After reading the label the tape must be set back to BTW,
  1219.                   -- as is required to emulate Director; see the Manual, §22.1, Ex. 1.
  1220.                   read_block(the_deck, the_block, the_size);
  1221.                   reset(the_deck);
  1222.                   if the_size >= 8+the_label'Length                and then
  1223.                         the_block(9 .. 8+the_label'Length) = the_label then
  1224.                      its_number := t;
  1225.                      its_serial := as_word(the_block(1 .. 8));
  1226.                      return;
  1227.                   end if;
  1228.                end if;
  1229.             end;
  1230.          end if;
  1231.       end loop;
  1232.       trap_operator_error("«" & String(the_label) & "» has not been mounted");
  1233.    end find_tape;
  1234.
  1235. end IOC.fast.tape;

Compiling: ../Source/ioc-fast-tape.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Emulation of magnetic tape decks and buffers.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18.
    19. private with Ada.Direct_IO;
    20. --
    21. private with IOC_tape_data;
    22.
    23. use  KDF9_char_sets;
    24.
    25. package IOC.fast.tape is
    26.
    27.    -- Both the EE 1081 (MT) and the Ampex TM-4 7-track (ST) decks are emulated.
    28.    --
    29.    -- EE 1081, 16-track tape deck.
    30.       -- The physical characteristics of the deck are taken from the Manual, §22.1.2, i.e.:
    31.       -- 0.3 inch interblock gap, 400 ch/inch density, 100 inch/s tape speed,
    32.       --    full-reel rewind time ~3 minutes.
    33.    --
    34.    -- Ampex TM-4, 7-track IBM-compatible, tape deck.
    35.       -- The physical characteristics of the deck are taken from the Ampex document:
    36.       --    TECHNICAL MANUAL FOR SDSTM-4 TAPE TRANSPORT of 1963/2/15.
    37.       -- Where alternative characteristics are described, this code uses those considered to be of
    38.       --    greatest data interchange compatibility, as this is how the deck was used on KDF9, i.e.:
    39.       -- 0.3 inch interblock gap, 200 ch/inch density, 75 inch/s tape speed,
    40.       --    full-reel rewind time ~3 minutes.
    41.    --
    42.
    43.    type deck is abstract new fast.device with private;
    44.
    45.    -- MRFQq
    46.    overriding
    47.    procedure PIA (the_deck    : in out tape.deck;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- MFREQq
    52.    overriding
    53.    procedure PIB (the_deck    : in out tape.deck;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- as PIA
    58.    overriding
    59.    procedure PIC (the_deck    : in out tape.deck;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    -- as PID
    64.    overriding
    65.    procedure PID (the_deck    : in out tape.deck;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    -- MBRQq
    70.    overriding
    71.    procedure PIE (the_deck    : in out tape.deck;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    -- MBREQq
    76.    overriding
    77.    procedure PIF (the_deck    : in out tape.deck;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    -- as PIE
    82.    overriding
    83.    procedure PIG (the_deck    : in out tape.deck;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    -- as PIF
    88.    overriding
    89.    procedure PIH (the_deck    : in out tape.deck;
    90.                   Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean);
    92.
    93.    -- MFSKQq, for odd parity on 7-track deck
    94.    overriding
    95.    procedure PMA (the_deck    : in out tape.deck;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean);
    98.
    99.    -- MBTQq
   100.    overriding
   101.    procedure PMB (the_deck    : in out tape.deck;
   102.                   Q_operand   : in KDF9.Q_register;
   103.                   set_offline : in Boolean);
   104.
   105.    -- MLBQq
   106.    overriding
   107.    procedure PMC (the_deck    : in out tape.deck;
   108.                   Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean);
   110.    -- MRWDQq
   111.    overriding
   112.    procedure PMD (the_deck    : in out tape.deck;
   113.                   Q_operand   : in KDF9.Q_register;
   114.                   set_offline : in Boolean);
   115.
   116.    -- MBSKQqMFSKQq, for odd parity on 7-track deck
   117.    overriding
   118.    procedure PME (the_deck    : in out tape.deck;
   119.                   Q_operand   : in KDF9.Q_register;
   120.                   set_offline : in Boolean);
   121.
   122.    -- METQq
   123.    overriding
   124.    procedure PMF (the_deck    : in out tape.deck;
   125.                   Q_operand   : in KDF9.Q_register;
   126.                   set_offline : in Boolean);
   127.
   128.    -- PMKQq, forward skip, even parity, for 7-track deck only
   129.    overriding
   130.    procedure PMK (the_deck    : in out tape.deck;
   131.                   Q_operand   : in KDF9.Q_register;
   132.                   set_offline : in Boolean);
   133.
   134.    -- PMLQq, backward skip, even parity, for 7-track deck only
   135.    overriding
   136.    procedure PML (the_deck    : in out tape.deck;
   137.                   Q_operand   : in KDF9.Q_register;
   138.                   set_offline : in Boolean);
   139.
   140.    -- MWQq
   141.    overriding
   142.    procedure POA (the_deck    : in out tape.deck;
   143.                   Q_operand   : in KDF9.Q_register;
   144.                   set_offline : in Boolean);
   145.
   146.    -- MWEQq
   147.    overriding
   148.    procedure POB (the_deck    : in out tape.deck;
   149.                   Q_operand   : in KDF9.Q_register;
   150.                   set_offline : in Boolean);
   151.
   152.    -- MLWQq
   153.    overriding
   154.    procedure POC (the_deck    : in out tape.deck;
   155.                   Q_operand   : in KDF9.Q_register;
   156.                   set_offline : in Boolean);
   157.
   158.    -- MLWEQq
   159.    overriding
   160.    procedure POD (the_deck    : in out tape.deck;
   161.                   Q_operand   : in KDF9.Q_register;
   162.                   set_offline : in Boolean);
   163.
   164.    -- MGAPQq
   165.    overriding
   166.    procedure POE (the_deck    : in out tape.deck;
   167.                   Q_operand   : in KDF9.Q_register;
   168.                   set_offline : in Boolean);
   169.
   170.    -- MWIPEQq
   171.    overriding
   172.    procedure POF (the_deck    : in out tape.deck;
   173.                   Q_operand   : in KDF9.Q_register;
   174.                   set_offline : in Boolean);
   175.
   176.    procedure enable_MT_deck (b : in KDF9.buffer_number);
   177.
   178.    procedure enable_ST_deck (b : in KDF9.buffer_number);
   179.
   180. private
   181.
   182.    use IOC_tape_data;
   183.
   184.    -- slice_size_limit must be set so that the slice size field fits into 1 byte,
   185.    --    thus avoiding endian-ness and portability issues.
   186.    pragma Compile_Time_Error (slice_size_limit > 255, "IOC_tape_data.slice_size_limit > 255");
   187.
   188.    -- I think that both types of tape for the KDF9 had a maximum reel length of 2400 feet.
   189.    -- I assume that the recording density of the 7-track deck was no greater than that of the 1081.
   190.
   191.    max_bits_per_inch      : constant := 400;
   192.    max_reel_length        : constant := 12 * 2400;
   193.    type length_in_frames is range 0 .. max_reel_length * max_bits_per_inch;
   194.    type data_storage     is array (tape.length_in_frames range <>) of Character;
   195.
   196.    -- Attempts to write a block of more than max_block_size/8 words will be rejected.
   197.    -- The largest recommended size, as stated in the Manual, §22.1.3, is 3000 words.
   198.    -- The present value cannot logically be exceeded, and so allows all possible usages.
   199.
   200.    max_block_size         : constant := 32768 * 8;
   201.    subtype block_range   is tape.length_in_frames range 0 .. max_block_size;
   202.    subtype block_storage is data_storage (tape.block_range range 1 .. max_block_size);
   203.
   204.    -- A data block consists of one or more slices:
   205.    --
   206.    -- 1. a block of data length <= slice_size_limit has 1 slice, with (is_last and is_first) = True;
   207.    --
   208.    -- 2. a longer block has 1 or more prior slices, which all have data length = slice_size_limit,
   209.    --       all of them having is_last = False, and the first of them having is_first = True;
   210.    --    and 1 final slice of data length <= slice_size_limit, with is_last = True.
   211.    --
   212.    -- The total data length of all the slices in a block is <= max_block_size.
   213.    --
   214.    -- GAP and WIPE slices represent erased lengths of tape.
   215.    -- They are implemented, in effect, as data slices with non-significant data.
   216.    --
   217.    -- Parity mark slices represent tape marks on IBM-compatible Ampex TM4 decks.
   218.    -- See Manual, Appendix 7, p.317.
   219.
   220.    type basis_kind is (data_slice,
   221.                        GAP_slice,
   222.                        NULL_slice,
   223.                        WIPE_slice,
   224.                        even_parity_mark,
   225.                        odd_parity_mark);
   226.
   227.    -- These representations make for easy inspection of a MT file (e.g. using the UNIX od command).
   228.    for basis_kind use (data_slice       => Character'Pos('D'),
   229.                        GAP_slice        => Character'Pos('G'),
   230.                        NULL_slice       => Character'Pos('N'),
   231.                        WIPE_slice       => Character'Pos('W'),
   232.                        even_parity_mark => Character'Pos('e'),
   233.                        odd_parity_mark  => Character'Pos('o'));
   234.
   235.    subtype gap_kind is tape.basis_kind
   236.       with Static_Predicate => gap_kind in GAP_slice | WIPE_slice;
   237.
   238.    subtype tape_mark_kind is tape.basis_kind
   239.       with Static_Predicate => tape_mark_kind in odd_parity_mark | even_parity_mark;
   240.
   241.    subtype data_kind is tape.basis_kind
   242.       with Static_Predicate => data_kind = data_slice;
   243.
   244.    subtype slice_range   is tape.block_range range 0 .. IOC_tape_data.slice_size_limit;
   245.    subtype slice_storage is data_storage (1 .. slice_range'Last);
   246.
   247.    tape_mark_data  : constant tape.slice_storage := (1 => tape_mark_sign, others => block_padding);
   248.    erased_gap_data : constant tape.slice_storage := (others => block_padding);
   249.
   250.    type slice is
   251.       record
   252.          kind              : tape.basis_kind;
   253.          is_first, is_last : Boolean;
   254.          is_LBM_flagged    : Boolean;
   255.          size              : tape.slice_range;
   256.          data              : tape.slice_storage; -- Only data(1 .. size) are valid.
   257.       end record
   258.    with Size => 8 * MT_record_length;
   259.
   260.    -- These two representation specifications put the kind and is_* fields at convenient positions
   261.    --    for easy inspection in a legible print of a MT file (e.g. using the UNIX od command).
   262.
   263.    -- The first byte contains the initial letter of the slice type (see basis_kind).
   264.
   265.    -- The second byte takes the following octal/ASCII values for non-tape mark slices:
   266.    --    000 = NUL  => no flags
   267.    --    001 = SOH  => first slice of block
   268.    --    010 = BEL  => last slice of block
   269.    --    011 = HT   => only slice of block (first and last)
   270.    --    100 = @    => LBM flag
   271.    --    101 = A    => first slice of block with LBM flag
   272.    --    110 = H    => last slice of block with LBM flag
   273.    --    111 = I    => only slice of block with LBM flag
   274.
   275.    for slice use
   276.       record
   277.          kind           at 0 range  0..7;
   278.          is_first       at 1 range  0..2;
   279.          is_last        at 1 range  3..5;
   280.          is_LBM_flagged at 1 range  6..7;
   281.          size           at 2 range  0..7;
   282.          data           at 3 range  0..8*slice_size_limit - 1;
   283.       end record;
   284.
   285.    even_parity_tape_mark : constant tape.slice := (even_parity_mark,
   286.                                                    is_first       => True,
   287.                                                    is_last        => True,
   288.                                                    is_LBM_flagged => True,
   289.                                                    size           => 1,
   290.                                                    data           => tape_mark_data);
   291.
   292.    odd_parity_tape_mark  : constant tape.slice := (odd_parity_mark,
   293.                                                    is_first       => True,
   294.                                                    is_last        => True,
   295.                                                    is_LBM_flagged => True,
   296.                                                    size           => 1,
   297.                                                    data           => tape_mark_data);
   298.
   299.    a_NULL_slice          : constant tape.slice := (NULL_slice,
   300.                                                    is_first       => False,
   301.                                                    is_last        => False,
   302.                                                    is_LBM_flagged => False,
   303.                                                    size           => 0,
   304.                                                    data           => erased_gap_data);
   305.
   306.    a_WIPE_slice          : constant tape.slice := (WIPE_slice,
   307.                                                    is_first       => True,
   308.                                                    is_last        => True,
   309.                                                    is_LBM_flagged => False,
   310.                                                    size           => 0,
   311.                                                    data           => erased_gap_data);
   312.
   313.    a_GAP_slice           : constant tape.slice := (GAP_slice,
   314.                                                    is_first       => True,
   315.                                                    is_last        => True,
   316.                                                    is_LBM_flagged => False,
   317.                                                    size           => 0,
   318.                                                    data           => erased_gap_data);
   319.
   320.    package MT_slice_IO is new Ada.Direct_IO(tape.slice);
   321.    use MT_slice_IO;
   322.
   323.    type file is tagged limited
   324.       record
   325.          has_a_WP_ring   : Boolean := True;
   326.          last_data_index : MT_slice_IO.Count := 0;
   327.          position        : MT_slice_IO.Count := 0;
   328.          reel            : MT_slice_IO.File_Type;
   329.       end record;
   330.
   331.    -- The complete deck type with its primitive operations.
   332.
   333.    type deck is new fast.device with
   334.       record
   335.          -- unwound_frames tallies the amount of tape wound from its spool to the takeup spool;
   336.          --    i.e. how much has to be wound back before being able to unload the tape.
   337.          unwound_frames    : tape.length_in_frames := 0;
   338.          bytes_moved       : KDF9.word := 0;
   339.          is_LBM_flagged    : Boolean   := False;
   340.          terminator        : KDF9_char_sets.symbol;
   341.          recording_density : tape.length_in_frames;
   342.          max_reel_length   : tape.length_in_frames;
   343.          inter_block_gap   : tape.length_in_frames;
   344.          tape_capacity     : tape.length_in_frames;
   345.          PET_position      : tape.length_in_frames;
   346.          ETW_position      : tape.length_in_frames;
   347.          model             : IOC.device_kind;
   348.          tape_file         : tape.file;
   349.       end record;
   350.
   351.    overriding
   352.    procedure Finalize (the_deck : in out tape.deck);
   353.
   354.    overriding
   355.    function quantum (the_deck : tape.deck)
   356.    return KDF9.us
   357.    is (tape.deck'Class(the_deck).quantum);
                                        |
        >>> warning: possible infinite recursion, Storage_Error may be raised at run time

   358.    pragma Warnings(Off, quantum);
   359.
   360.    overriding
   361.    function kind (the_deck : tape.deck)
   362.    return IOC.device_kind
   363.    is (tape.deck'Class(the_deck).kind);
                                        |
        >>> warning: possible infinite recursion, Storage_Error may be raised at run time

   364.    pragma Warnings(Off, kind);
   365.
   366.    procedure handle_any_abnormality (the_deck : in out tape.deck;
   367.                                      the_size : in length_in_frames)
   368.    is null;
   369.
   370.    overriding
   371.    function IO_elapsed_time_total (the_deck : tape.deck)
   372.    return KDF9.us
   373.    is (tape.deck'Class(the_deck).elapsed_time);
   374.    pragma Warnings(Off, IO_elapsed_time_total);
   375.
   376.    procedure open (the_deck : in out tape.deck;
   377.                    the_mode : in POSIX.access_mode)
   378.    is null;
   379.
   380.    overriding
   381.    function is_open (the_deck : tape.deck)
   382.    return Boolean;
   383.
   384.    overriding
   385.    function usage (the_deck : tape.deck)
   386.    return KDF9.word;
   387.
   388.    overriding
   389.    procedure close (the_deck : in out tape.deck);
   390.
   391.    overriding
   392.    procedure flush(the_deck : in out tape.deck) is null;
   393.
   394.    type MT_deck is new tape.deck with null record;
   395.
   396.    overriding
   397.    procedure Initialize (the_deck : in out MT_deck);
   398.
   399.    overriding
   400.    function kind (the_deck : MT_deck)
   401.    return IOC.device_kind
   402.    is (MT_kind);
   403.
   404.    overriding
   405.    function quantum (the_deck : MT_deck)
   406.    return KDF9.us
   407.    is (1E6 / 40E3);  -- ch/s
   408.
   409.    overriding
   410.    procedure handle_any_abnormality (the_deck : in out MT_deck;
   411.                                      the_size : in length_in_frames);
   412.
   413.    type ST_deck is new tape.deck with null record;
   414.
   415.    overriding
   416.    procedure Initialize (the_deck : in out ST_deck);
   417.
   418.    overriding
   419.    function kind (the_deck : ST_deck)
   420.    return IOC.device_kind
   421.    is (ST_kind);
   422.
   423.    overriding
   424.    function quantum (the_deck : ST_deck)
   425.    return KDF9.us
   426.    is (1E6 / 16E3);  -- ch/s
   427.
   428.    overriding
   429.    procedure handle_any_abnormality (the_deck : in out ST_deck;
   430.                                      the_size : in length_in_frames);
   431.
   432.
   433.    procedure find_tape (the_label  : in  tape.data_storage;
   434.                         its_number : out KDF9.buffer_number;
   435.                         its_serial : out KDF9.word);
   436.
   437. end IOC.fast.tape;


GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-fw.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:50

     1. -- Emulation of the FlexoWriter buffer: monitor typewriter functionality.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received the copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18. --
    19. with HCI;
    20. with host_IO;
    21.
    22. with imported_value_of;
    23.
    24. use  Ada.Text_IO;
    25. --
    26. use  HCI;
    27. use  host_IO;
    28.
    29. package body IOC.slow.shift.FW is
    30.
    31.    function a_LF_was_just_read (the_FW : FW.device)
    32.    return Boolean
    33.    is (the_FW.mode = the_flexowriter_is_reading and then a_LF_was_just_read(the_FW.stream));
    34.
    35.    max_text_length : constant Positive := 64;  -- This is the limit imposed by NTSD and TSD.
    36.    min_text_length : constant Positive :=  2;  -- This is arbitrary, but seems reasonable.
    37.
    38.    type interaction is
    39.       record
    40.          text           : String(1 .. max_text_length);
    41.          prompt_length,
    42.          total_length   : Positive range 1 .. max_text_length;
    43.       end record;
    44.
    45.    max_interactions : constant Positive := 16; -- This is arbitrary, but seems reasonable.
    46.
    47.    interactions     : array (1 .. max_interactions) of FW.interaction;
    48.    next_interaction : Positive := 1;
    49.    last_interaction : Natural  := 0;
    50.
    51.     -- A '®' denotes LF, and the '©' denotes FF in an interaction text input.
    52.    LF_surrogate     : constant Character := '®';
    53.    FF_surrogate     : constant Character := '©';
    54.
    55.    -- These are the ANSI SGR terminal escape codes for styling FW output.
    56.
    57.    function escaped (name, default : String)
    58.    return String is
    59.       text   : constant String := imported_value_of(name, default);
    60.       result : String (1..text'Length);
    61.       i, j   : Positive;
    62.    begin
    63.       if text'Length < 6 then return ""; end if;
    64.       i := text'First;
    65.       j := 1;
    66.       while i <= text'Last-2 loop
    67.          if text(i..i+2) = "ESC" then
    68.             result(j) := ESC;
    69.             i := i + 3;
    70.          else
    71.             result(j) := text(i);
    72.             i := i + 1;
    73.          end if;
    74.          j := j + 1;
    75.       end loop;
    76.       result(j..j+1) := text(i..i+1);
    77.       return result(1..j+1);
    78.    end escaped;
    79.
    80.    red_font   : constant String := escaped("RED_FONT",   "ESC[0mESC[31m");
    81.    black_font : constant String := escaped("BLACK_FONT", "ESC[0mESC[30m");
    82.    underline  : constant String := escaped("UNDERLINE",  "ESC[4m");
    83.    plain_font : constant String := escaped("PLAIN_FONT", "ESC[0m");
    84.
    85.    procedure set_text_colour_to_red (the_flexowriter_output : in out host_IO.stream) is
    86.    begin
    87.       if realistic_FW_output_is_wanted and red_font /= "" then
    88.          put_escape_code(red_font, the_flexowriter_output);
    89.       end if;
    90.    end set_text_colour_to_red;
    91.
    92.    procedure set_text_colour_to_black (the_flexowriter_output : in out host_IO.stream) is
    93.    begin
    94.       if black_font /= "" then
    95.          put_escape_code(black_font, the_flexowriter_output);
    96.       end if;
    97.    end set_text_colour_to_black;
    98.
    99.    procedure set_text_style_to_underline (the_flexowriter_output : in out host_IO.stream) is
   100.    begin
   101.       if underline /= "" then
   102.          put_escape_code(underline, the_flexowriter_output);
   103.       end if;
   104.    end set_text_style_to_underline;
   105.
   106.    procedure set_text_style_to_plain (the_flexowriter_output : in out host_IO.stream) is
   107.    begin
   108.       if plain_font /= "" then
   109.          put_escape_code(plain_font, the_flexowriter_output);
   110.       end if;
   111.    end set_text_style_to_plain;
   112.
   113.    overriding
   114.    procedure Initialize (the_FW : in out FW.device) is
   115.
   116.       procedure complain (part_1         : in String;
   117.                           part_2, part_3 : in String := "")
   118.       with
   119.          No_Return
   120.       is
   121.          left_quote  : constant String := (if part_2 /= "" then  " «" else "");
   122.          right_quote : constant String := (if part_2 /= "" then  "» " else "");
   123.       begin
   124.          raise operator_error
   125.             with part_1 & left_quote & glyphs_for(part_2) & right_quote & part_3;
   126.       end complain;
   127.
   128.       the_data         : String(1 .. max_text_length+1);
   129.       the_data_length  : Natural;
   130.
   131.       interaction_file : Ada.Text_IO.File_Type;
   132.
   133.    begin -- Initialize
   134.       ensure_UI_is_open;
   135.       the_FW.mode := the_flexowriter_is_writing;
   136.       the_FW.device_name := device_name_of(the_FW);
   137.
   138.       if the_FW.device_name = "FW0" then
   139.          -- Attempt to open the command file for the console the_FW.
   140.          begin
   141.             Open(interaction_file, In_File, "FW0");
   142.          response_list_loop:
   143.             while not End_of_File(interaction_file) loop
   144.                if last_interaction = max_interactions then
   145.                   complain("The file FW0 contains too many prompts");
   146.                end if;
   147.                last_interaction := last_interaction + 1;
   148.                Get_Line(interaction_file, the_data, the_data_length);
   149.
   150.             exit response_list_loop when the_data_length = 0;
   151.
   152.                declare
   153.                   next   : FW.interaction renames interactions(last_interaction);
   154.                   this   : String  := the_data(1..the_data_length);
   155.                   length : Natural := 0;
   156.                begin
   157.                   if the_data_length > max_text_length then
   158.                      complain("The FW0 prompt", this, "is too long");
   159.                   end if;
   160.                   if the_data_length < min_text_length then
   161.                      complain("The FW0 prompt", this, "is too short");
   162.                   end if;
   163.
   164.                   for p in this'Range loop
   165.                      if this(p) = ';' then
   166.                         if length /= 0 then
   167.                            complain("The FW0 prompt", this, "contains 2 semicolons");
   168.                         end if;
   169.                         length := p;
   170.                      elsif this(p) = LF_surrogate then
   171.                         -- Convert '®' to LF to allow for multi-line prompts.
   172.                         this(p) := LF;
   173.                      elsif this(p) = FF_surrogate then
   174.                         -- Convert '©' to FF to allow for multi-line prompts.
   175.                         this(p) := FF;
   176.                      end if;
   177.                   end loop;
   178.
   179.                   if length = 0 then
   180.                      complain("The FW0 prompt", this, "contains no semicolon");
   181.                   end if;
   182.
   183.                   next.text(1..this'Length) := this;
   184.                   next.prompt_length        := length;
   185.                   next.total_length         := this'Length;
   186.                end;
   187.
   188.             end loop response_list_loop;
   189.
   190.          exception
   191.
   192.             when Name_Error =>
   193.                complain("The file FW0 is absent");
   194.             when Use_Error =>
   195.                complain("The file FW0 exists, but cannot be read");
   196.          end;
   197.       end if;
   198.
   199.       open(the_FW.stream, the_FW.device_name, read_mode, UI_in_FD);
   200.       open(the_FW.output, the_FW.device_name, write_mode, UI_out_FD);
   201.       IOC.device(the_FW).Initialize;
   202.       the_FW.current_case := KDF9_char_sets.Case_Normal;
   203.    end Initialize;
   204.
   205.    -- If authentic timing, the delay of length the_pause is inserted between characters output
   206.    --    to the Flexowriter, with the aim of approximating the actual speed of its typing.
   207.    the_pause  : KDF9.us := 0;
   208.
   209.    procedure set_the_duration_of_the_pause (the_FW : in FW.device) is
   210.    begin
   211.       if authentic_timing_is_enabled then
   212.          the_pause := the_FW.quantum;
   213.       else
   214.          the_pause := 0;
   215.       end if;
   216.    end set_the_duration_of_the_pause;
   217.
   218.    call_for_manual_input    : constant String (1..2) := (others => BEL);
   219.
   220.    procedure inject_a_response (the_FW     : in out FW.device;
   221.                                 the_prompt : in String;
   222.                                 the_size   : in out KDF9.word) is
   223.    begin
   224.       set_the_duration_of_the_pause(the_FW);
   225.       for t in next_interaction .. last_interaction loop
   226.          declare
   227.             the : interaction renames interactions(t);
   228.          begin
   229.             if the.prompt_length = the.total_length then
   230.                -- A null response, so terminate the program.
   231.                raise exceptions.quit_request with "at the prompt: «"& the_prompt & "»";
   232.             end if;
   233.             next_interaction := next_interaction + 1;
   234.             if the.text(1..the.prompt_length-1) = the_prompt and then
   235.                   the.text(the.prompt_length-0) = ';'            then
   236.                inject(the.text(the.prompt_length+1..the.total_length) & LF, the_FW.stream);
   237.                the_size := the_size + KDF9.word(the.total_length-the.prompt_length);
   238.                put_chars(the.text(the.prompt_length+1..the.total_length) & LF, the_FW.output);
   239.                -- Human operators type much more slowly than KDF9 buffers!
   240.                flush(the_FW.output, the_pause*10);
   241.                the_FW.mode := the_flexowriter_is_reading;
   242.                return;
   243.             end if;
   244.          end;
   245.       end loop;
   246.       -- No canned response is available, so control reverts to the terminal.
   247.       -- Output an audible signal to notify the operator.
   248.       if noninteractive_usage_is_enabled then
   249.          raise input_is_impossible;
   250.       end if;
   251.       put_bytes(call_for_manual_input, the_FW.output);
   252.       flush(the_FW.output, the_pause);
   253.       the_FW.mode := the_flexowriter_is_reading;
   254.    end inject_a_response;
   255.
   256.    -- TRQq
   257.    overriding
   258.    procedure PIA (the_FW      : in out FW.device;
   259.                   Q_operand   : in KDF9.Q_register;
   260.                   set_offline : in Boolean) is
   261.    begin
   262.       if noninteractive_usage_is_enabled then
   263.          raise input_is_impossible;
   264.       end if;
   265.       put_bytes(call_for_manual_input, the_FW.output);
   266.       flush(the_FW.output);
   267.       the_FW.mode := the_flexowriter_is_reading;
   268.       start_slow_transfer(the_FW, Q_operand, set_offline);
   269.       read(the_FW, Q_operand);
   270.       lock_out_relative_addresses(Q_operand);
   271.       reset(the_FW.stream);
   272.    end PIA;
   273.
   274.    -- TREQq
   275.    overriding
   276.    procedure PIB (the_FW      : in out FW.device;
   277.                   Q_operand   : in KDF9.Q_register;
   278.                   set_offline : in Boolean) is
   279.    begin
   280.       if noninteractive_usage_is_enabled then
   281.          raise input_is_impossible;
   282.       end if;
   283.       put_bytes(call_for_manual_input, the_FW.output);
   284.       flush(the_FW.output);
   285.       the_FW.mode := the_flexowriter_is_reading;
   286.       start_slow_transfer(the_FW, Q_operand, set_offline);
   287.       read_to_EM(the_FW, Q_operand);
   288.       lock_out_relative_addresses(Q_operand);
   289.       reset(the_FW.stream);
   290.    end PIB;
   291.
   292.    overriding
   293.    procedure PIC (the_FW      : in out FW.device;
   294.                   Q_operand   : in KDF9.Q_register;
   295.                   set_offline : in Boolean) is
   296.    begin
   297.       if noninteractive_usage_is_enabled then
   298.          raise input_is_impossible;
   299.       end if;
   300.       put_bytes(call_for_manual_input, the_FW.output);
   301.       flush(the_FW.output);
   302.       the_FW.mode := the_flexowriter_is_reading;
   303.       start_slow_transfer(the_FW, Q_operand, set_offline);
   304.       words_read(the_FW, Q_operand);
   305.       lock_out_relative_addresses(Q_operand);
   306.       reset(the_FW.stream);
   307.    end PIC;
   308.
   309.    overriding
   310.    procedure PID (the_FW      : in out FW.device;
   311.                   Q_operand   : in KDF9.Q_register;
   312.                   set_offline : in Boolean) is
   313.    begin
   314.       if noninteractive_usage_is_enabled then
   315.          raise input_is_impossible;
   316.       end if;
   317.       put_bytes(call_for_manual_input, the_FW.output);
   318.       flush(the_FW.output);
   319.       the_FW.mode := the_flexowriter_is_reading;
   320.       start_slow_transfer(the_FW, Q_operand, set_offline);
   321.       words_read_to_EM(the_FW, Q_operand);
   322.       lock_out_relative_addresses(Q_operand);
   323.       reset(the_FW.stream);
   324.    end PID;
   325.
   326.    overriding
   327.    procedure PIE (the_FW      : in out FW.device;
   328.                   Q_operand   : in KDF9.Q_register;
   329.                   set_offline : in Boolean) is
   330.    begin
   331.       PIA(the_FW, Q_operand, set_offline);
   332.    end PIE;
   333.
   334.    overriding
   335.    procedure PIF (the_FW      : in out FW.device;
   336.                   Q_operand   : in KDF9.Q_register;
   337.                   set_offline : in Boolean) is
   338.    begin
   339.       PIB(the_FW, Q_operand, set_offline);
   340.    end PIF;
   341.
   342.    overriding
   343.    procedure PIG (the_FW      : in out FW.device;
   344.                   Q_operand   : in KDF9.Q_register;
   345.                   set_offline : in Boolean) is
   346.    begin
   347.       PIC(the_FW, Q_operand, set_offline);
   348.    end PIG;
   349.
   350.    overriding
   351.    procedure PIH (the_FW      : in out FW.device;
   352.                   Q_operand   : in KDF9.Q_register;
   353.                   set_offline : in Boolean) is
   354.    begin
   355.       PID(the_FW, Q_operand, set_offline);
   356.    end PIH;
   357.
   358.    -- neat strips off any enclosing non-graphic characters from s.
   359.    function neat (s : String)
   360.    return String is
   361.       l : Positive := 1;
   362.       r : Natural  := 0;
   363.    begin
   364.       for i in s'Range loop
   365.          l := i;
   366.       exit when s(i) > SP and s(i) /= DEL;
   367.       end loop;
   368.       for i in reverse s'Range loop
   369.          r := i;
   370.       exit when s(i) > SP and s(i) /= DEL;
   371.       end loop;
   372.       return s(l..r);  -- s(1..0) yields the null string when s is the null string.
   373.    end neat;
   374.
   375.    overriding
   376.    procedure do_output_housekeeping (the_FW   : in out FW.device;
   377.                                      written,
   378.                                      fetched  : in KDF9.word) is
   379.    begin
   380.       flush(the_FW.stream);
   381.       add_in_the_IO_CPU_time(the_FW, fetched);
   382.       correct_transfer_time(the_FW, written);
   383.       the_FW.byte_count := the_FW.byte_count + fetched;
   384.    end do_output_housekeeping;
   385.
   386.    underlined : Boolean := False;
   387.
   388.    procedure put_symbols (the_FW         : in out FW.device;
   389.                           Q_operand      : in KDF9.Q_register;
   390.                           transfer_to_EM : in Boolean) is
   391.       start_address : constant KDF9.address := Q_operand.I;
   392.       end_address   : constant KDF9.address := Q_operand.M;
   393.       fill   : KDF9.word := 0;
   394.       size   : KDF9.word := 0;
   395.       symbol : KDF9_char_sets.symbol;
   396.       char   : Character;
   397.    begin
   398.       check_addresses_and_lockouts(start_address, end_address);
   399.       set_the_duration_of_the_pause(the_FW);
   400.       the_FW.mode := the_flexowriter_is_writing;
   401.       set_text_style_to_plain(the_FW.output);
   402.       set_text_colour_to_red(the_FW.output);
   403.
   404.       -- Ensure that any prompt occupies the buffer alone.
   405.       flush(the_FW.output);
   406.
   407.    word_loop:
   408.       for w in start_address .. end_address loop
   409.          for c in KDF9_char_sets.symbol_index'Range loop
   410.             case the_FW.mode is
   411.
   412.                when the_flexowriter_is_writing =>
   413.                   symbol := fetch_symbol(w, c);
   414.                   size := size + 1;
   415.
   416.                   if symbol = KDF9_char_sets.Word_Filler then
   417.                      fill := fill + 1;
   418.
   419.                   elsif symbol = KDF9_char_sets.Case_Shift then
   420.                      the_FW.current_case := KDF9_char_sets.Case_Shift;
   421.                      the_FW.shifts := the_FW.shifts + 1;
   422.
   423.                   elsif  symbol = KDF9_char_sets.Case_Normal then
   424.                      the_FW.current_case := KDF9_char_sets.Case_Normal;
   425.                      the_FW.shifts := the_FW.shifts + 1;
   426.
   427.                   else
   428.
   429.                      if the_FW.current_case = KDF9_char_sets.Case_Normal then
   430.                         char := TP_CN(symbol);
   431.                      else
   432.                         char := TP_CS(symbol);
   433.                      end if;
   434.
   435.                      if char = ';' then
   436.
   437.                         declare
   438.                            the_prompt : constant String := contents(the_FW.output);
   439.                         begin
   440.                            -- Must flush AFTER saving the prompt and BEFORE going black.
   441.                            flush(the_FW.output, the_pause);
   442.                            set_text_colour_to_black(the_FW.output);
   443.                            set_text_style_to_plain(the_FW.output);
   444.                            put_byte(';', the_FW.output);
   445.                            flush(the_FW.output, the_pause);
   446.
   447.                            inject_a_response(the_FW, neat(the_prompt), size);
   448.
   449.                            the_FW.mode := the_flexowriter_is_reading;
   450.                            set_text_style_to_plain(the_FW.output);
   451.                         end;
   452.
   453.                      elsif flexowriter_output_is_wanted then
   454.
   455.                         if char = '_' then
   456.                            underlined := True;
   457.                            do_not_put_byte(char, the_FW.output);
   458.                            flush(the_FW.output, the_pause);
   459.                         else
   460.                            if underlined then
   461.                               set_text_style_to_underline(the_FW.output);
   462.                            end if;
   463.                            put_char(char, the_FW.output);
   464.                            if underlined then
   465.                               flush(the_FW.output, the_pause);
   466.                               set_text_style_to_plain(the_FW.output);
   467.                               set_text_colour_to_red(the_FW.output);
   468.                               underlined := False;
   469.                            end if;
   470.                         end if;
   471.
   472.                      else
   473.                         do_not_put_byte(char, the_FW.output);
   474.                      end if;
   475.
   476.                      exit word_loop when transfer_to_EM and symbol = KDF9_char_sets.End_Message;
   477.                   end if;
   478.
   479.                when the_flexowriter_is_reading =>
   480.                   get_char(char, the_FW.stream);
   481.                   if case_of(char) not in both | the_FW.current_case then
   482.                      store_symbol(CN_TR(next_case(the_FW.current_case)), w, c);
   483.                      size := size + 1;
   484.                      the_FW.current_case := the_FW.current_case xor 1;
   485.                      back_off(the_FW.stream);
   486.                   else
   487.                      if the_FW.current_case = KDF9_char_sets.Case_Normal then
   488.                         symbol := CN_TR(char);
   489.                      else
   490.                         symbol := CS_TR(char);
   491.                      end if;
   492.                      store_symbol(symbol, w, c);
   493.                      size := size + 1;
   494.                      if transfer_to_EM and symbol = KDF9_char_sets.End_Message then
   495.                         for d in 1 .. 7-c loop
   496.                            store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
   497.                         end loop;
   498.                         exit word_loop;
   499.                      end if;
   500.                   end if;
   501.
   502.             end case;
   503.          end loop;
   504.       end loop word_loop;
   505.
   506.       flush(the_FW.output, the_pause);
   507.       set_text_style_to_plain(the_FW.output);
   508.       set_text_colour_to_black(the_FW.output);
   509.       do_output_housekeeping(the_FW, written => size-fill, fetched => size);
   510.       flush(the_FW.output);
   511.    exception
   512.       when end_of_stream =>
   513.          flush(the_FW.output);
   514.          set_text_colour_to_black(the_FW.output);
   515.          set_text_style_to_plain(the_FW.output);
   516.          do_output_housekeeping(the_FW, written => size-fill, fetched => size);
   517.    end put_symbols;
   518.
   519.    overriding
   520.    procedure write (the_FW    : in out FW.device;
   521.                     Q_operand : in KDF9.Q_register) is
   522.    begin
   523.       put_symbols(the_FW, Q_operand, transfer_to_EM => False);
   524.    end write;
   525.
   526.    overriding
   527.    procedure write_to_EM (the_FW    : in out FW.device;
   528.                           Q_operand : in KDF9.Q_register) is
   529.    begin
   530.       put_symbols(the_FW, Q_operand, transfer_to_EM => True);
   531.    end write_to_EM;
   532.
   533.    -- TWQq
   534.    overriding
   535.    procedure POA (the_FW      : in out FW.device;
   536.                   Q_operand   : in KDF9.Q_register;
   537.                   set_offline : in Boolean) is
   538.    begin
   539.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   540.       write(the_FW, Q_operand);
   541.       lock_out_relative_addresses(Q_operand);
   542.       reset(the_FW.stream);
   543.    end POA;
   544.
   545.    -- TWEQq
   546.    overriding
   547.    procedure POB (the_FW      : in out FW.device;
   548.                   Q_operand   : in KDF9.Q_register;
   549.                   set_offline : in Boolean) is
   550.    begin
   551.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   552.       write_to_EM(the_FW, Q_operand);
   553.       lock_out_relative_addresses(Q_operand);
   554.       -- reset(the_FW.stream);
   555.    end POB;
   556.
   557.    procedure put_words (the_FW         : in out FW.device;
   558.                         Q_operand      : in KDF9.Q_register;
   559.                         transfer_to_EM : in Boolean := False) is
   560.       start_address : constant KDF9.address := Q_operand.I;
   561.       end_address   : constant KDF9.address := Q_operand.M;
   562.       size : KDF9.word := 0;
   563.       word : KDF9.word;
   564.       char : Character;
   565.    begin
   566.       check_addresses_and_lockouts(start_address, end_address);
   567.       set_the_duration_of_the_pause(the_FW);
   568.       the_FW.mode := the_flexowriter_is_writing;
   569.       set_text_style_to_plain(the_FW.output);
   570.       set_text_colour_to_red(the_FW.output);
   571.    word_loop:
   572.       for w in start_address .. end_address loop
   573.          case the_FW.mode is
   574.
   575.             when the_flexowriter_is_writing =>
   576.                word := fetch_word(w) and 8#377#;
   577.                size := size + 1;
   578.                char := Character'Val(word);
   579.
   580.                if word = KDF9_char_sets.Semi_Colon_tape_bits then
   581.                   -- Hypothesis: POC and POD act like POA and POB with respect to prompting;
   582.                   --    and change from writing to reading after the output of any word that has
   583.                   --       the KDF9 FW tape code for a semicolon in its least significant 8 bits.
   584.                   declare
   585.                      the_prompt : constant String := contents(the_FW.output);
   586.                   begin
   587.                      -- Must flush AFTER saving the prompt and BEFORE going black.
   588.                      flush(the_FW.output, the_pause);
   589.                      set_text_colour_to_black(the_FW.output);
   590.                      set_text_style_to_plain(the_FW.output);
   591.                      put_byte(';', the_FW.output);
   592.                      flush(the_FW.output, the_pause);
   593.
   594.                      inject_a_response(the_FW, neat(the_prompt), size);
   595.
   596.                      the_FW.mode := the_flexowriter_is_reading;
   597.                      set_text_style_to_plain(the_FW.output);
   598.                   end;
   599.                elsif flexowriter_output_is_wanted then
   600.
   601.                         if char = '_' then
   602.                            underlined := True;
   603.                            do_not_put_byte(char, the_FW.output);
   604.                            flush(the_FW.output, the_pause);
   605.                         else
   606.                            if underlined then
   607.                               set_text_style_to_underline(the_FW.output);
   608.                            end if;
   609.                            put_char(char, the_FW.output);
   610.                            if underlined then
   611.                               flush(the_FW.output, the_pause);
   612.                               set_text_style_to_plain(the_FW.output);
   613.                               set_text_colour_to_red(the_FW.output);
   614.                               underlined := False;
   615.                            end if;
   616.                         end if;
   617.       exit word_loop when transfer_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   618.                end if;
   619.
   620.             when the_flexowriter_is_reading =>
   621.                get_char(char, the_FW.stream);
   622.                size := size + 1;
   623.                word := KDF9.word(Character'Pos(char));
   624.                store_word(word, w);
   625.       exit word_loop when transfer_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   626.
   627.          end case;
   628.       end loop word_loop;
   629.
   630.       flush(the_FW.output);
   631.       set_text_colour_to_black(the_FW.output);
   632.       set_text_style_to_plain(the_FW.output);
   633.       do_output_housekeeping(the_FW, written => size, fetched => size);
   634.    exception
   635.       when end_of_stream =>
   636.          flush(the_FW.output);
   637.          set_text_colour_to_black(the_FW.output);
   638.          set_text_style_to_plain(the_FW.output);
   639.          do_output_housekeeping(the_FW, written => size, fetched => size);
   640.    end put_words;
   641.
   642.    overriding
   643.    procedure words_write (the_FW    : in out FW.device;
   644.                           Q_operand : in KDF9.Q_register) is
   645.    begin
   646.       put_words(the_FW, Q_operand, transfer_to_EM => False);
   647.    end words_write;
   648.
   649.    overriding
   650.    procedure words_write_to_EM (the_FW    : in out FW.device;
   651.                                 Q_operand : in KDF9.Q_register) is
   652.    begin
   653.       put_words(the_FW, Q_operand, transfer_to_EM => True);
   654.    end words_write_to_EM;
   655.
   656.    -- TWCQq
   657.    overriding
   658.    procedure POC (the_FW      : in out FW.device;
   659.                   Q_operand   : in KDF9.Q_register;
   660.                   set_offline : in Boolean) is
   661.    begin
   662.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   663.       words_write(the_FW, Q_operand);
   664.       lock_out_relative_addresses(Q_operand);
   665.    end POC;
   666.
   667.    -- TWECQq
   668.    overriding
   669.    procedure POD (the_FW      : in out FW.device;
   670.                   Q_operand   : in KDF9.Q_register;
   671.                   set_offline : in Boolean) is
   672.    begin
   673.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   674.       words_write_to_EM(the_FW, Q_operand);
   675.       lock_out_relative_addresses(Q_operand);
   676.    end POD;
   677.
   678.    overriding
   679.    procedure Finalize (the_FW : in out FW.device) is
   680.       total : constant KDF9.word := the_FW.output.bytes_moved+the_FW.stream.bytes_moved + the_FW.shifts;
   681.    begin
   682.       close(
   683.            the_FW,
   684.            "transferred",
   685.            total,
   686.            "character" & plurality(total)
   687.           );
   688.    end Finalize;
   689.
   690.    -- This is the monitor console Flexowriter.
   691.
   692.    type FW_access is access FW.device;
   693.
   694.    FW0 : FW_access with Warnings => Off;
   695.
   696.    already_enabled : Boolean := False;
   697.
   698.    procedure enable (b : in KDF9.buffer_number) is
   699.    begin
   700.       if already_enabled then
   701.          trap_operator_error("more than one FW unit has been configured");
   702.       end if;
   703.       if b /= 0 then
   704.          trap_operator_error("FW0 must be on buffer 0");
   705.       end if;
   706.       FW0 := new FW.device (number => b, unit => 0);
   707.       already_enabled := True;
   708.    end enable;
   709.
   710. end IOC.slow.shift.FW;

Compiling: ../Source/ioc-slow-shift-fw.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:50

     1. -- Emulation of a FlexoWriter buffer: monitor typewriter functionality.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.FW is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    function a_LF_was_just_read (the_FW : FW.device)
    22.    return Boolean;
    23.
    24.    -- TRQq
    25.    overriding
    26.    procedure PIA (the_FW      : in out FW.device;
    27.                   Q_operand   : in KDF9.Q_register;
    28.                   set_offline : in Boolean);
    29.
    30.    -- TREQq
    31.    overriding
    32.    procedure PIB (the_FW      : in out FW.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    -- TRCQq character read
    37.    overriding
    38.    procedure PIC (the_FW      : in out FW.device;
    39.                   Q_operand   : in KDF9.Q_register;
    40.                   set_offline : in Boolean);
    41.
    42.    -- TRECQq character read to End_Message
    43.    overriding
    44.    procedure PID (the_FW      : in out FW.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    -- as PIA
    49.    overriding
    50.    procedure PIE (the_FW      : in out FW.device;
    51.                   Q_operand   : in KDF9.Q_register;
    52.                   set_offline : in Boolean);
    53.
    54.    -- as PIB
    55.    overriding
    56.    procedure PIF (the_FW      : in out FW.device;
    57.                   Q_operand   : in KDF9.Q_register;
    58.                   set_offline : in Boolean);
    59.
    60.    -- as PIC
    61.    overriding
    62.    procedure PIG (the_FW      : in out FW.device;
    63.                   Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean);
    65.
    66.    -- as PID
    67.    overriding
    68.    procedure PIH (the_FW      : in out FW.device;
    69.                   Q_operand   : in KDF9.Q_register;
    70.                   set_offline : in Boolean);
    71.
    72.    -- TWQq
    73.    overriding
    74.    procedure POA (the_FW      : in out FW.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.
    78.    -- TWEQq
    79.    overriding
    80.    procedure POB (the_FW      : in out FW.device;
    81.                   Q_operand   : in KDF9.Q_register;
    82.                   set_offline : in Boolean);
    83.
    84.    -- NB the following assumes that page 285 of the Manual is erroneous,
    85.    -- and that POC and POD for the Flexowriter are analogous to the tape punch,
    86.    -- as other sources, such as the "Usecode Digest", do in fact indicate.
    87.
    88.    -- TWCQq character write
    89.    overriding
    90.    procedure POC (the_FW      : in out FW.device;
    91.                   Q_operand   : in KDF9.Q_register;
    92.                   set_offline : in Boolean);
    93.
    94.    -- TWECQq character write to End_Message
    95.    overriding
    96.    procedure POD (the_FW      : in out FW.device;
    97.                   Q_operand   : in KDF9.Q_register;
    98.                   set_offline : in Boolean);
    99.
   100.    procedure enable (b : in KDF9.buffer_number);
   101.
   102. private
   103.
   104.    type flexowriter_mode is
   105.       (the_flexowriter_is_reading, the_flexowriter_is_writing);
   106.
   107.    -- The Flexowriter has separate input and output streams, to accommodate the console I/O API
   108.    --    of MS Windows, which requires separate pseudo-devices for input and output.
   109.    type device is new IOC.slow.shift.device with
   110.       record
   111.          output : host_IO.stream;
   112.          mode   : FW.flexowriter_mode;
   113.          shifts : KDF9.word := 0;
   114.       end record;
   115.
   116.    overriding
   117.    procedure Initialize (the_FW : in out FW.device);
   118.
   119.    overriding
   120.    procedure Finalize (the_FW : in out FW.device);
   121.
   122.    overriding
   123.    function kind (the_FW : FW.device)
   124.    return IOC.device_kind
   125.    is (FW_kind);
   126.
   127.    overriding
   128.    function quantum (the_FW : FW.device)
   129.    return KDF9.us
   130.    is (1E6 / 10);
   131.
   132.    overriding
   133.    procedure write (the_FW    : in out FW.device;
   134.                     Q_operand : in KDF9.Q_register);
   135.
   136.    overriding
   137.    procedure write_to_EM (the_FW    : in out FW.device;
   138.                           Q_operand : in KDF9.Q_register);
   139.    overriding
   140.    procedure words_write (the_FW    : in out FW.device;
   141.                           Q_operand : in KDF9.Q_register);
   142.
   143.    overriding
   144.    procedure words_write_to_EM (the_FW    : in out FW.device;
   145.                                 Q_operand : in KDF9.Q_register);
   146.
   147.    overriding
   148.    procedure do_output_housekeeping (the_FW   : in out FW.device;
   149.                                      written,
   150.                                      fetched  : in KDF9.word);
   151.
   152. end IOC.slow.shift.FW;

 710 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-gp.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a Calcomp 564 graph plotter, switched to a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with plotter;
    18. with postscript;
    19.
    20. use  plotter;
    21. use  postscript;
    22.
    23. package body IOC.slow.shift.GP is
    24.
    25.    overriding
    26.    procedure Initialize (the_GP : in out GP.device) is
    27.    begin
    28.       -- Ready the graph plotter driver and PostScript output file.
    29.       the_GP.device_name := device_name_of(the_GP);
    30.       open(the_GP.stream, the_GP.device_name, write_mode);
    31.       IOC.device(the_GP).Initialize;
    32.       if the_GP.is_open then
    33.          truncate(the_GP.stream);
    34.          initialize_PS_output(the_GP.stream);
    35.          open_the_plot_file(the_GP.stream);
    36.       end if;
    37.    end Initialize;
    38.
    39.    overriding
    40.    procedure Finalize (the_GP : in out GP.device) is
    41.    begin
    42.       if the_GP.is_open           and then
    43.             the_GP.byte_count /= 0    then
    44.          if the_final_state_is_wanted then
    45.             log_line(
    46.                      the_GP.device_name
    47.                    & " on buffer #"
    48.                    & oct_of(KDF9.Q_part(the_GP.number), 2)
    49.                    & " made"
    50.                    & the_GP.byte_count'Image
    51.                    & plurality(the_GP.byte_count, " plotting step.", " plotting steps.")
    52.                     );
    53.          end if;
    54.          the_GP.byte_count := 0;
    55.          close_the_plot_file(the_GP.stream);
    56.          finalize_PS_output(the_GP.stream);
    57.       end if;
    58.    end Finalize;
    59.
    60.    -- the_T_bit_is_set (the buffer has been switched from a tape punch to a graph plotter)
    61.    overriding
    62.    procedure PMB (the_GP      : in out GP.device;
    63.                   Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean) is
    65.    begin
    66.       validate_device(the_GP);
    67.       validate_parity(the_GP);
    68.       deal_with_a_busy_device(the_GP, 13, set_offline);
    69.       the_T_bit_is_set := True;
    70.       take_note_of_test(the_GP.device_name, Q_operand, the_T_bit_is_set);
    71.    end PMB;
    72.
    73.    GP_lift_time : constant := 1E6 /  10;           -- 10 pen up/down movements per second.
    74.    lift_ratio   : constant := GP_lift_time / 200;  -- the number of steps made in a lift time
    75.
    76.    overriding
    77.    procedure do_output_housekeeping (the_GP      : in out GP.device;
    78.                                      size, lifts : in     KDF9.word) is
    79.    begin
    80.       add_in_the_IO_CPU_time(the_GP, size);
    81.       correct_transfer_time(the_GP, size - lifts + lifts * lift_ratio);
    82.    end do_output_housekeeping;
    83.
    84.    procedure put_symbols (the_GP    : in out GP.device;
    85.                           Q_operand : in KDF9.Q_register) is
    86.       start_address : constant KDF9.address := Q_operand.I;
    87.       end_address   : constant KDF9.address := Q_operand.M;
    88.       size    : KDF9.word := 0;
    89.       lifts   : KDF9.word := 0;
    90.       command : plotter.command;
    91.    begin
    92.       check_addresses_and_lockouts(start_address, end_address);
    93.    word_loop:
    94.       for w in start_address .. end_address loop
    95.          for c in KDF9_char_sets.symbol_index'Range loop
    96.             command := plotter.command(fetch_symbol(w, c));
    97.             perform(command, the_GP.stream);
    98.             size := size + 1;
    99.             the_GP.byte_count := the_GP.byte_count + 1;
   100.             if command in pen_up | pen_down then
   101.                -- These actions are much slower than plotting movements.
   102.                lifts := lifts + 1;
   103.             end if;
   104.          end loop;
   105.       end loop word_loop;
   106.       do_output_housekeeping (the_GP, size, lifts);
   107.    end put_symbols;
   108.
   109.    overriding
   110.    procedure POA (the_GP      : in out GP.device;
   111.                   Q_operand   : in KDF9.Q_register;
   112.                   set_offline : in Boolean) is
   113.    begin
   114.       start_slow_transfer(the_GP, Q_operand, set_offline, output_operation);
   115.       put_symbols(the_GP, Q_operand);
   116.       lock_out_relative_addresses(Q_operand);
   117.    end POA;
   118.
   119.    overriding
   120.    procedure POB (the_GP      : in out GP.device;
   121.                   Q_operand   : in KDF9.Q_register;
   122.                   set_offline : in Boolean) is
   123.    begin
   124.       -- See the Manual Appendix 6, §5.2, p.303.
   125.       POA(the_GP, Q_operand, set_offline);
   126.    end POB;
   127.
   128.    procedure put_words (the_GP    : in out GP.device;
   129.                         Q_operand : in KDF9.Q_register) is
   130.       start_address : constant KDF9.address := Q_operand.I;
   131.       end_address   : constant KDF9.address := Q_operand.M;
   132.       size    : KDF9.word := 0;
   133.       lifts   : KDF9.word := 0;
   134.       command : plotter.command;
   135.    begin
   136.       check_addresses_and_lockouts(start_address, end_address);
   137.       for w in start_address .. end_address loop
   138.          -- Ony the last 6 bits (character 7) of each word are used.
   139.          command := plotter.command(fetch_symbol(w, 7));
   140.          perform(command, the_GP.stream);
   141.          size := size + 1;
   142.          the_GP.byte_count := the_GP.byte_count + 1;
   143.          if command in pen_up | pen_down then
   144.             -- These actions are much slower than plotting movements.
   145.             lifts := lifts + 1;
   146.          end if;
   147.       end loop;
   148.       do_output_housekeeping (the_GP, size, lifts);
   149.    end put_words;
   150.
   151.    overriding
   152.    procedure POC (the_GP      : in out GP.device;
   153.                   Q_operand   : in KDF9.Q_register;
   154.                   set_offline : in Boolean) is
   155.    begin
   156.       start_slow_transfer(the_GP, Q_operand, set_offline, output_operation);
   157.       put_words(the_GP, Q_operand);
   158.       lock_out_relative_addresses(Q_operand);
   159.    end POC;
   160.
   161.    overriding
   162.    procedure POD (the_GP      : in out GP.device;
   163.                   Q_operand   : in KDF9.Q_register;
   164.                   set_offline : in Boolean) is
   165.    begin
   166.       -- See the Manual Appendix 6, §5.2, p.303.
   167.       POC(the_GP, Q_operand, set_offline);
   168.    end POD;
   169.
   170.    type GP_access is access GP.device;
   171.
   172.    GP0 : GP_access with Warnings => Off;
   173.
   174.    procedure enable (b : in KDF9.buffer_number) is
   175.    begin
   176.       GP0 := new GP.device (number => b, unit => 0);
   177.       GP0_number := b;
   178.    end enable;
   179.
   180.    procedure replace_on_buffer (b : in KDF9.buffer_number) is
   181.    begin
   182.       if GP0 /= null and then
   183.             b = GP0_number then
   184.          return;
   185.       end if;
   186.       buffer(b) := null;
   187.       enable(b);
   188.    end replace_on_buffer;
   189.
   190.    procedure notify_invalid_movement (from_x, from_y, step_x, step_y : in Integer) is
   191.    begin
   192.       trap_failing_IO_operation(
   193.                                 GP0.all,
   194.                                 "cannot move from <"
   195.                               & trimmed(from_x'Image)
   196.                               & ","
   197.                               & from_y'Image
   198.                               & "> by <"
   199.                               & trimmed(step_x'Image)
   200.                               & ","
   201.                               & step_y'Image
   202.                               & ">"
   203.                                );
   204.    end notify_invalid_movement;
   205.
   206. end IOC.slow.shift.GP;

Compiling: ../Source/ioc-slow-shift-gp.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a Calcomp 564 graph plotter, switched to a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.GP is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    overriding
    22.    procedure POA (the_GP      : in out GP.device;
    23.                   Q_operand   : in KDF9.Q_register;
    24.                   set_offline : in Boolean);
    25.
    26.    overriding
    27.    procedure POB (the_GP      : in out GP.device;
    28.                   Q_operand   : in KDF9.Q_register;
    29.                   set_offline : in Boolean);
    30.
    31.    overriding
    32.    procedure POC (the_GP      : in out GP.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    overriding
    37.    procedure POD (the_GP      : in out GP.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    -- the_T_bit_is_set (buffer is switched to graph plotter)
    42.    overriding
    43.    procedure PMB (the_GP      : in out GP.device;
    44.                   Q_operand   : in KDF9.Q_register;
    45.                   set_offline : in Boolean);
    46.
    47.    procedure enable (b : in KDF9.buffer_number);
    48.
    49.    procedure replace_on_buffer (b : in KDF9.buffer_number);
    50.
    51.    procedure notify_invalid_movement (from_x, from_y, step_x, step_y : in Integer)
    52.       with Inline => False;
    53.
    54. private
    55.
    56.    type device is new IOC.slow.shift.device with null record;
    57.
    58.    overriding
    59.    procedure Initialize (the_GP : in out GP.device);
    60.
    61.    overriding
    62.    procedure Finalize (the_GP : in out GP.device);
    63.
    64.    overriding
    65.    function kind (the_GP : GP.device)
    66.    return IOC.device_kind
    67.    is (GP_kind);
    68.
    69.    overriding
    70.    function quantum (the_GP : GP.device)
    71.    return KDF9.us
    72.    is (1E6 / 200);
    73.
    74.    overriding
    75.    procedure do_output_housekeeping (the_GP      : in out GP.device;
    76.                                      size, lifts : in     KDF9.word);
    77.
    78. end IOC.slow.shift.GP;

 206 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-si.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a standard interface buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.shift.SI is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_SI : in out SI.device) is
    23.    begin
    24.       -- Open the associated file.
    25.       open(IOC.device(the_SI), rd_wr_mode);
    26.    end Initialize;
    27.
    28.    overriding
    29.    procedure PIA (the_SI      : in out SI.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean) is
    32.    begin
    33.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    34.       read(the_SI, Q_operand);
    35.       lock_out_relative_addresses(Q_operand);
    36.    end PIA;
    37.
    38.    overriding
    39.    procedure PIB (the_SI      : in out SI.device;
    40.                   Q_operand   : in KDF9.Q_register;
    41.                   set_offline : in Boolean) is
    42.    begin
    43.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    44.       read_to_EM(the_SI, Q_operand);
    45.       lock_out_relative_addresses(Q_operand);
    46.    end PIB;
    47.
    48.    overriding
    49.    procedure PIC (the_SI      : in out SI.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean) is
    52.    begin
    53.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    54.       words_read(the_SI, Q_operand);
    55.       lock_out_relative_addresses(Q_operand);
    56.    end PIC;
    57.
    58.    overriding
    59.    procedure PID (the_SI      : in out SI.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean) is
    62.    begin
    63.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    64.       words_read_to_EM(the_SI, Q_operand);
    65.       lock_out_relative_addresses(Q_operand);
    66.    end PID;
    67.
    68.    overriding
    69.    procedure PIE (the_SI      : in out SI.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean) is
    72.    begin
    73.       -- as PIA: "parity off" has no effect on the data read in
    74.       PIA(the_SI, Q_operand, set_offline);
    75.    end PIE;
    76.
    77.    overriding
    78.    procedure PIF (the_SI      : in out SI.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean) is
    81.    begin
    82.       -- as PIB: "parity off" has no effect on the data read in
    83.       PIB(the_SI, Q_operand, set_offline);
    84.    end PIF;
    85.
    86.    overriding
    87.    procedure PIG (the_SI      : in out SI.device;
    88.                   Q_operand   : in KDF9.Q_register;
    89.                   set_offline : in Boolean) is
    90.    begin
    91.       PIC(the_SI, Q_operand, set_offline);
    92.    end PIG;
    93.
    94.    overriding
    95.    procedure PIH (the_SI      : in out SI.device;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean) is
    98.    begin
    99.       PID(the_SI, Q_operand, set_offline);
   100.    end PIH;
   101.
   102.    overriding
   103.    procedure PMB (the_SI      : in out SI.device;
   104.                   Q_operand   : in KDF9.Q_register;
   105.                   set_offline : in Boolean) is
   106.    begin
   107.       -- ee9's SI0 always asserts 8 channel mode.
   108.       validate_device(the_SI);
   109.       validate_parity(the_SI);
   110.       deal_with_a_busy_device(the_SI, 13, set_offline);
   111.       the_T_bit_is_set := True;
   112.       take_note_of_test(the_SI.device_name, Q_operand, the_T_bit_is_set);
   113.    end PMB;
   114.
   115.    overriding
   116.    procedure PMC (the_SI      : in out SI.device;
   117.                   Q_operand   : in KDF9.Q_register;
   118.                   set_offline : in Boolean) is
   119.    begin
   120.       PMB(the_SI, Q_operand, set_offline);
   121.    end PMC;
   122.
   123.    overriding
   124.    procedure POA (the_SI      : in out SI.device;
   125.                   Q_operand   : in KDF9.Q_register;
   126.                   set_offline : in Boolean) is
   127.    begin
   128.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   129.       write(the_SI, Q_operand);
   130.       lock_out_relative_addresses(Q_operand);
   131.    end POA;
   132.
   133.    overriding
   134.    procedure POB (the_SI      : in out SI.device;
   135.                   Q_operand   : in KDF9.Q_register;
   136.                   set_offline : in Boolean) is
   137.    begin
   138.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   139.       write_to_EM(the_SI, Q_operand);
   140.       lock_out_relative_addresses(Q_operand);
   141.    end POB;
   142.
   143.    overriding
   144.    procedure POC (the_SI      : in out SI.device;
   145.                   Q_operand   : in KDF9.Q_register;
   146.                   set_offline : in Boolean) is
   147.    begin
   148.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   149.       words_write(the_SI, Q_operand);
   150.       lock_out_relative_addresses(Q_operand);
   151.    end POC;
   152.
   153.    overriding
   154.    procedure POD (the_SI      : in out SI.device;
   155.                   Q_operand   : in KDF9.Q_register;
   156.                   set_offline : in Boolean) is
   157.    begin
   158.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   159.       words_write_to_EM(the_SI, Q_operand);
   160.       lock_out_relative_addresses(Q_operand);
   161.    end POD;
   162.
   163.    overriding
   164.    procedure POE (the_SI      : in out SI.device;
   165.                   Q_operand   : in KDF9.Q_register;
   166.                   set_offline : in Boolean) is
   167.    begin
   168.       require_nonnegative_count(Q_operand.M);
   169.       output_a_gap(the_SI, Q_operand, set_offline, word_mode => False, text_mode => False);
   170.    end POE;
   171.
   172.    overriding
   173.    procedure POF (the_SI      : in out SI.device;
   174.                   Q_operand   : in KDF9.Q_register;
   175.                   set_offline : in Boolean) is
   176.    begin
   177.       require_nonnegative_count(Q_operand.M);
   178.       output_a_gap(the_SI, Q_operand, set_offline, word_mode => True, text_mode => False);
   179.    end POF;
   180.
   181.    overriding
   182.    procedure Finalize (the_SI : in out SI.device) is
   183.    begin
   184.       close(
   185.             the_SI,
   186.             "transferred",
   187.             the_SI.byte_count,
   188.             "character" & plurality(the_SI.byte_count)
   189.            );
   190.    end Finalize;
   191.
   192.    type SI_access is access SI.device;
   193.
   194.    SI0 : SI_access with Warnings => Off;
   195.    SI1 : SI_access with Warnings => Off;
   196.
   197.    unit : IOC.unit_number := 0;
   198.
   199.    procedure enable (b : in KDF9.buffer_number) is
   200.    begin
   201.       case unit is
   202.          when 0 =>
   203.             SI0 := new SI.device (number => b, unit => 0);
   204.             SI0_number := b;
   205.          when 1 =>
   206.             SI1 := new SI.device (number => b, unit => 1);
   207.             SI1_number := b;
   208.          when others =>
   209.             trap_operator_error("more than two SI units have been configured");
   210.       end case;
   211.       unit := unit + 1;
   212.    end enable;
   213.
   214.    procedure replace_on_buffer (b : in KDF9.buffer_number) is
   215.    begin
   216.       if SI0 /= null   and then
   217.             SI0.number = b then
   218.          return;
   219.       end if;
   220.       if SI1 /= null   and then
   221.             SI1.number = b then
   222.          return;
   223.       end if;
   224.       buffer(b) := null;
   225.       enable(b);
   226.    end replace_on_buffer;
   227.
   228.    function SI0_is_enabled
   229.    return Boolean
   230.    is (SI0 /= null or SI1 /= null);
   231.
   232. end IOC.slow.shift.SI;

Compiling: ../Source/ioc-slow-shift-si.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a standard interface buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.SI is
    18.
    19.    -- The Standard Interface Buffer is the KDF9 device about which least is presently known.
    20.    -- Anecdotal evidence suggests it is an implementation of the British Standard Interface (BSIF).
    21.    -- ee9 implements a best guess as to its functionality, based on the following considerations.
    22.
    23.    -- According to the Manual, Appendix 6.1, p.296,
    24.    --    the Standard Interface Buffer has orders that look very like the union of a TR and a TP.
    25.
    26.    -- However:
    27.
    28.    -- (a) PIE and PIF do a read with "parity off".
    29.    --     I think this relates to a feature of the BSIF,
    30.    --        whereby a source device can omit parity if it de-asserts its "parity valid" signal.
    31.    --     With such a device the KDF9 would need a way of ignoring spurious parity errors.
    32.    -- PIE/PIF act in exactly the same way as PIA/PIB as there will be no such error under ee9.
    33.
    34.    -- (b) PMB and PMC set the Test Register "if 8 channel set".  The BSIF is 8 data bits wide.
    35.    --     I think this signals that the KDF9 should use "character" orders to access all 8 bits,
    36.    --        and I think that the other orders access only the low-order 6 bits of the interface.
    37.    -- ee9 always asserts "8 channel set", as it is always capable of providing 8-bit bytes.
    38.
    39.    -- In any case, 6-bit transfers work in the same way as for paper tape readers and punches.
    40.
    41.    type device is new IOC.slow.shift.device with private;
    42.
    43.    overriding
    44.    procedure PIA (the_SI      : in out SI.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    overriding
    49.    procedure PIB (the_SI      : in out SI.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    overriding
    54.    procedure PIC (the_SI      : in out SI.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    overriding
    59.    procedure PID (the_SI      : in out SI.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    overriding
    64.    procedure PIE (the_SI      : in out SI.device;
    65.                   Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    overriding
    69.    procedure PIF (the_SI      : in out SI.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean);
    72.
    73.    overriding
    74.    procedure PIG (the_SI      : in out SI.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.
    78.    overriding
    79.    procedure PIH (the_SI      : in out SI.device;
    80.                   Q_operand   : in KDF9.Q_register;
    81.                   set_offline : in Boolean);
    82.
    83.    overriding
    84.    procedure PMB (the_SI      : in out SI.device;
    85.                   Q_operand   : in KDF9.Q_register;
    86.                   set_offline : in Boolean);
    87.
    88.    overriding
    89.    procedure PMC (the_SI      : in out SI.device;
    90.                   Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean);
    92.
    93.    overriding
    94.    procedure POA (the_SI      : in out SI.device;
    95.                   Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean);
    97.
    98.    overriding
    99.    procedure POB (the_SI      : in out SI.device;
   100.                   Q_operand   : in KDF9.Q_register;
   101.                   set_offline : in Boolean);
   102.
   103.    overriding
   104.    procedure POC (the_SI      : in out SI.device;
   105.                   Q_operand   : in KDF9.Q_register;
   106.                   set_offline : in Boolean);
   107.
   108.    overriding
   109.    procedure POD (the_SI      : in out SI.device;
   110.                   Q_operand   : in KDF9.Q_register;
   111.                   set_offline : in Boolean);
   112.
   113.    overriding
   114.    procedure POE (the_SI      : in out SI.device;
   115.                   Q_operand   : in KDF9.Q_register;
   116.                   set_offline : in Boolean);
   117.
   118.    overriding
   119.    procedure POF (the_SI      : in out SI.device;
   120.                   Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean);
   122.
   123.    procedure enable (b : in KDF9.buffer_number);
   124.
   125.    procedure replace_on_buffer (b : in KDF9.buffer_number);
   126.
   127.    function SI0_is_enabled
   128.    return Boolean;
   129.
   130. private
   131.
   132.    type device is new IOC.slow.shift.device with null record;
   133.
   134.    overriding
   135.    procedure Initialize (the_SI : in out SI.device);
   136.
   137.    overriding
   138.    procedure Finalize (the_SI : in out SI.device);
   139.
   140.    overriding
   141.    function kind (the_SI : SI.device)
   142.    return IOC.device_kind
   143.    is (SI_kind);
   144.
   145.    overriding
   146.    function quantum (the_SI : SI.device)
   147.    return KDF9.us
   148.    is (1E6 / 50E3); -- I am guessing 50_000 characters per second.
   149.
   150. end IOC.slow.shift.SI;

 232 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-slow-unit.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of the common functionality of "unit record" (i.e. LP, CP or CR) devices.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.unit is
    18.
    19.    overriding
    20.    function IO_elapsed_time_total (the_buffer : unit.device)
    21.    return KDF9.us is
    22.    begin
    23.       return IO_elapsed_time(the_buffer, the_buffer.unit_count);
    24.    end IO_elapsed_time_total;
    25.
    26.    overriding
    27.    function atomic_item_count (the_buffer : unit.device;
    28.                                Q_operand  : KDF9.Q_register)
    29.    return KDF9.word is
    30.       pragma Unreferenced(the_buffer);
    31.       pragma Unreferenced(Q_operand);
    32.    begin
    33.       return 1;
    34.    end atomic_item_count;
    35.
    36. end IOC.slow.unit;

Compiling: ../Source/ioc-slow-unit.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of the common functionality of "unit record" (i.e. LP, CP or CR) devices.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.unit is
    18.
    19.    --
    20.    -- This is the root type for all unit-record I/O device types.
    21.    --
    22.
    23.    type device is abstract new IOC.slow.device with private;
    24.
    25. private
    26.
    27.    type device is abstract new IOC.slow.device with
    28.       record
    29.          unit_count : KDF9.word := 0;
    30.       end record;
    31.
    32.    overriding
    33.    function IO_elapsed_time_total (the_buffer : unit.device)
    34.    return KDF9.us;
    35.
    36.    overriding
    37.    function atomic_item_count (the_buffer : unit.device;
    38.                                Q_operand  : KDF9.Q_register)
    39.    return KDF9.word;
    40.
    41. end IOC.slow.unit;

 36 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-unit-cr.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a card reader buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.unit.CR is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_CR : in out CR.device) is
    23.    begin
    24.       open(the_CR, read_mode);
    25.    end Initialize;
    26.
    27.    blank_card : constant String(max_card_columns) := (others => SP);
    28.
    29.    procedure get_card_image (the_CR         : in out CR.device;
    30.                               size          : in out KDF9.word;
    31.                               max_columns   : in KDF9.address;
    32.                               reading_to_EM : in Boolean := False) is
    33.       max  : constant Positive := Positive(max_columns);
    34.       char : Character;
    35.    begin
    36.       -- Clear out the card image field.
    37.       the_CR.card_image(1..max) := blank_card(1..max);
    38.       -- Fill as much of the card image as possible with the next data line, padded out with
    39.       --    blanks, so that it is unnecessary to type all 80 or 160 characters.
    40.       -- For transfers to End Message, a line terminator must follow the E_M.
    41.       for i in 1 .. max loop
    42.          get_char_from_stream (char, the_CR);
    43.          size := size + 1;
    44.       exit when char = LF;
    45.          the_CR.card_image(i) := char;
    46.       exit when reading_to_EM and char = KDF9_char_sets.E_M;
    47.       end loop;
    48.       if char /= KDF9_char_sets.E_M then  -- The whole card was read.
    49.          size := KDF9.word(max);
    50.       end if;
    51.       the_CR.unit_count := the_CR.unit_count + 1;
    52.       -- Discard excess characters in the current data line.
    53.       while char /= LF loop
    54.          get_char_from_stream (char, the_CR);  -- N.B. do not update size for discards.
    55.       end loop;
    56.    exception
    57.       when end_of_stream =>
    58.          flush(the_CR.stream);
    59.          the_CR.is_abnormal := True;
    60.          raise;
    61.    end get_card_image;
    62.
    63.    procedure do_input_housekeeping (the_CR  : in out CR.device;
    64.                                     fetched : in KDF9.word) is
    65.    begin
    66.       add_in_the_IO_CPU_time(the_CR, fetched);
    67.       correct_transfer_time(the_CR, actual_length => 1);
    68.    end do_input_housekeeping;
    69.
    70.    procedure read_card (the_CR        : in out CR.device;
    71.                         Q_operand     : in KDF9.Q_register;
    72.                         max_words     : in KDF9.address;
    73.                         reading_to_EM : in Boolean := False) is
    74.       start_address : constant KDF9.address := Q_operand.I;
    75.       end_address   : constant KDF9.address := Q_operand.M;
    76.       size : KDF9.word := 0;
    77.       next : Natural := 0;
    78.       char : Character;
    79.       byte : KDF9_char_sets.symbol;
    80.    begin
    81.       check_addresses_and_lockouts(start_address, end_address);
    82.       get_card_image(the_CR, size, max_columns => max_words*8);
    83.    word_loop:
    84.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    85.          for c in KDF9_char_sets.symbol_index'Range loop
    86.             next := next + 1;
    87.             char := the_CR.card_image(next);
    88.             byte := CR_in(char);
    89.             store_symbol(byte, w, c);
    90.             if reading_to_EM and byte = KDF9_char_sets.End_Message then
    91.                for d in 1 .. 7-c loop
    92.                   store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
    93.                end loop;
    94.                exit word_loop;
    95.             end if;
    96.          end loop;
    97.       end loop word_loop;
    98.       do_input_housekeeping(the_CR, size);
    99.    exception
   100.       when end_of_stream =>
   101.          do_input_housekeeping(the_CR, size);
   102.    end read_card;
   103.
   104.    procedure words_read_card (the_CR        : in out CR.device;
   105.                               Q_operand     : in KDF9.Q_register;
   106.                               max_words     : in KDF9.address;
   107.                               reading_to_EM : in Boolean := False) is
   108.       start_address : constant KDF9.address := Q_operand.I;
   109.       end_address   : constant KDF9.address := Q_operand.M;
   110.       size : KDF9.word := 0;
   111.       next : Natural := 0;
   112.       char : Character;
   113.       word : KDF9.word;
   114.    begin
   115.       check_addresses_and_lockouts(start_address, end_address);
   116.       get_card_image(the_CR, size, max_columns => max_words);
   117.       if the_CR.is_abnormal then return; end if;
   118.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
   119.          next := next + 1;
   120.          char := the_CR.card_image(next);
   121.          word := KDF9.word(CR_in(char));
   122.          store_word(word, w);
   123.       exit when reading_to_EM and char = KDF9_char_sets.E_M;
   124.       end loop;
   125.       add_in_the_IO_CPU_time(the_CR, size);
   126.       correct_transfer_time(the_CR, actual_length => 1);
   127.    exception
   128.       when end_of_stream =>
   129.          flush(the_CR.stream);
   130.          add_in_the_IO_CPU_time(the_CR, size);
   131.          correct_transfer_time(the_CR, actual_length => 1);
   132.    end words_read_card;
   133.
   134.    overriding
   135.    procedure PIA (the_CR      : in out CR.device;
   136.                   Q_operand   : in KDF9.Q_register;
   137.                   set_offline : in Boolean) is
   138.    begin
   139.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   140.       read_card(the_CR, Q_operand, max_words => 20);
   141.       lock_out_relative_addresses(Q_operand);
   142.    end PIA;
   143.
   144.    overriding
   145.    procedure PIB (the_CR      : in out CR.device;
   146.                   Q_operand   : in KDF9.Q_register;
   147.                   set_offline : in Boolean) is
   148.    begin
   149.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   150.       read_card(the_CR, Q_operand, max_words => 20, reading_to_EM => True);
   151.       lock_out_relative_addresses(Q_operand);
   152.    end PIB;
   153.
   154.    overriding
   155.    procedure PIC (the_CR      : in out CR.device;
   156.                   Q_operand   : in KDF9.Q_register;
   157.                   set_offline : in Boolean) is
   158.    begin
   159.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   160.       words_read_card(the_CR, Q_operand, max_words => 160);
   161.       lock_out_relative_addresses(Q_operand);
   162.    end PIC;
   163.
   164.    overriding
   165.    procedure PID (the_CR      : in out CR.device;
   166.                   Q_operand   : in KDF9.Q_register;
   167.                   set_offline : in Boolean) is
   168.    begin
   169.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   170.       words_read_card(the_CR, Q_operand, max_words => 160, reading_to_EM => True);
   171.       lock_out_relative_addresses(Q_operand);
   172.    end PID;
   173.
   174.    overriding
   175.    procedure PIE (the_CR      : in out CR.device;
   176.                   Q_operand   : in KDF9.Q_register;
   177.                   set_offline : in Boolean) is
   178.    begin
   179.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   180.       read_card(the_CR, Q_operand, max_words => 10);
   181.       lock_out_relative_addresses(Q_operand);
   182.    end PIE;
   183.
   184.    overriding
   185.    procedure PIF (the_CR      : in out CR.device;
   186.                   Q_operand   : in KDF9.Q_register;
   187.                   set_offline : in Boolean) is
   188.    begin
   189.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   190.       read_card(the_CR, Q_operand, max_words => 10, reading_to_EM => True);
   191.       lock_out_relative_addresses(Q_operand);
   192.    end PIF;
   193.
   194.    overriding
   195.    procedure PIG (the_CR      : in out CR.device;
   196.                   Q_operand   : in KDF9.Q_register;
   197.                   set_offline : in Boolean) is
   198.    begin
   199.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   200.       words_read_card(the_CR, Q_operand, max_words => 80);
   201.       lock_out_relative_addresses(Q_operand);
   202.    end PIG;
   203.
   204.    overriding
   205.    procedure PIH (the_CR      : in out CR.device;
   206.                   Q_operand   : in KDF9.Q_register;
   207.                   set_offline : in Boolean) is
   208.    begin
   209.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   210.       words_read_card(the_CR, Q_operand, max_words => 80, reading_to_EM => True);
   211.       lock_out_relative_addresses(Q_operand);
   212.    end PIH;
   213.
   214.    -- the_T_bit_is_set := (RECHECK switch is OFF). {It always is nowadays!}
   215.    overriding
   216.    procedure PMB (the_CR      : in out CR.device;
   217.                   Q_operand   : in KDF9.Q_register;
   218.                   set_offline : in Boolean) is
   219.    begin
   220.       validate_device(the_CR);
   221.       validate_parity(the_CR);
   222.       deal_with_a_busy_device(the_CR, 13, set_offline);
   223.       the_T_bit_is_set := True;
   224.       take_note_of_test(the_CR.device_name, Q_operand, the_T_bit_is_set);
   225.    end PMB;
   226.
   227.    overriding
   228.    procedure Finalize (the_CR : in out CR.device) is
   229.    begin
   230.       close(
   231.             the_CR,
   232.             "read",
   233.             the_CR.unit_count,
   234.             "card" & plurality(the_CR.unit_count)
   235.            );
   236.    end Finalize;
   237.
   238.    type CR_access is access CR.device;
   239.
   240.    CR0 : CR_access with Warnings => Off;
   241.    CR1 : CR_access with Warnings => Off;
   242.
   243.    unit : IOC.unit_number := 0;
   244.
   245.    procedure enable (b : in KDF9.buffer_number) is
   246.    begin
   247.       case unit is
   248.          when 0 =>
   249.             CR0 := new CR.device (number => b, unit => 0);
   250.             CR0_number := b;
   251.          when 1 =>
   252.             CR1 := new CR.device (number => b, unit => 1);
   253.             CR1_number := b;
   254.          when others =>
   255.             trap_operator_error("more than two CR units have been configured");
   256.       end case;
   257.       unit := unit + 1;
   258.    end enable;
   259.
   260. end IOC.slow.unit.CR;

Compiling: ../Source/ioc-slow-unit-cr.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a card reader buffer.
     2. -- Card readers are "unit record" devices: they cannot transfer less than a whole card.
     3. --
     4. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package IOC.slow.unit.CR is
    19.
    20.    type device is new IOC.slow.unit.device with private;
    21.
    22.    -- Binary (undecoded) read
    23.    overriding
    24.    procedure PIA (the_CR      : in out CR.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    -- Binary (undecoded) read to End_Message
    29.    overriding
    30.    procedure PIB (the_CR      : in out CR.device;
    31.                   Q_operand   : in KDF9.Q_register;
    32.                   set_offline : in Boolean);
    33.
    34.    -- Binary (undecoded) character read
    35.    overriding
    36.    procedure PIC (the_CR      : in out CR.device;
    37.                   Q_operand   : in KDF9.Q_register;
    38.                   set_offline : in Boolean);
    39.
    40.    -- Binary (undecoded) character read to End_Message
    41.    overriding
    42.    procedure PID (the_CR      : in out CR.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    -- Alphanumeric (decoded) read
    47.    overriding
    48.    procedure PIE (the_CR      : in out CR.device;
    49.                   Q_operand   : in KDF9.Q_register;
    50.                   set_offline : in Boolean);
    51.
    52.    -- Alphanumeric (decoded) read to End_Message
    53.    overriding
    54.    procedure PIF (the_CR      : in out CR.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    -- Alphanumeric (decoded) character read
    59.    overriding
    60.    procedure PIG (the_CR      : in out CR.device;
    61.                   Q_operand   : in KDF9.Q_register;
    62.                   set_offline : in Boolean);
    63.
    64.    -- Alphanumeric (decoded) character read to End_Message
    65.    overriding
    66.    procedure PIH (the_CR      : in out CR.device;
    67.                   Q_operand   : in KDF9.Q_register;
    68.                   set_offline : in Boolean);
    69.
    70.    -- the_T_bit_is_set := (RECHECK switch is OFF)
    71.    overriding
    72.    procedure PMB (the_CR      : in out CR.device;
    73.                   Q_operand   : in KDF9.Q_register;
    74.                   set_offline : in Boolean);
    75.
    76.    procedure enable (b : in KDF9.buffer_number);
    77.
    78. private
    79.
    80.    subtype max_card_columns is Positive range 1 .. 160;
    81.
    82.    type device is new IOC.slow.unit.device with
    83.       record
    84.          card_image : String(max_card_columns);
    85.       end record;
    86.
    87.    overriding
    88.    procedure Initialize (the_CR : in out CR.device);
    89.
    90.    overriding
    91.    procedure Finalize (the_CR : in out CR.device);
    92.
    93.    overriding
    94.    function kind (the_CR : CR.device)
    95.    return IOC.device_kind
    96.    is (CR_kind);
    97.
    98.    overriding
    99.    function quantum (the_CR : CR.device)
   100.    return KDF9.us
   101.    is (1E6 / (600 / 60)); -- 600 cards per minute.
   102.
   103. end IOC.slow.unit.CR;

 260 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-slow-unit-cp.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a card punch buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.unit.CP is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_CP : in out CP.device) is
    23.    begin
    24.       open(the_CP, write_mode);
    25.    end Initialize;
    26.
    27.    procedure do_output_housekeeping (the_CP     : in out CP.device;
    28.                                      fetched    : in KDF9.word) is
    29.    begin
    30.       correct_transfer_time(the_CP, actual_length => 1);
    31.       add_in_the_IO_CPU_time(the_CP, fetched);
    32.    end do_output_housekeeping;
    33.
    34.    procedure write_card (the_CP        : in out CP.device;
    35.                          Q_operand     : in KDF9.Q_register;
    36.                          max_words     : in KDF9.address;
    37.                          writing_to_EM : in Boolean := False) is
    38.       start_address : constant KDF9.address := Q_operand.I;
    39.       end_address   : constant KDF9.address := Q_operand.M;
    40.       size : KDF9.word := 0;
    41.       char : Character;
    42.       byte : KDF9_char_sets.symbol;
    43.    begin
    44.       check_addresses_and_lockouts(start_address, end_address);
    45.    word_loop:
    46.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    47.          for c in KDF9_char_sets.symbol_index'Range loop
    48.             byte := fetch_symbol(w, c);
    49.             size := size + 1;
    50.             char := to_CP(byte);
    51.             put_byte(char, the_CP.stream);
    52.             exit word_loop when writing_to_EM and char = KDF9_char_sets.E_M;
    53.          end loop;
    54.       end loop word_loop;
    55.       put_EOL(the_CP.stream);
    56.       the_CP.unit_count := the_CP.unit_count + 1;
    57.       do_output_housekeeping(the_CP, fetched => size);
    58.    end write_card;
    59.
    60.    procedure words_write_card (the_CP        : in out CP.device;
    61.                                Q_operand     : in KDF9.Q_register;
    62.                                max_words     : in KDF9.address;
    63.                                writing_to_EM : in Boolean := False) is
    64.
    65.       start_address : constant KDF9.address := Q_operand.I;
    66.       end_address   : constant KDF9.address := Q_operand.M;
    67.       size : KDF9.word := 0;
    68.       char : Character;
    69.       byte : KDF9_char_sets.symbol;
    70.    begin
    71.       check_addresses_and_lockouts(start_address, end_address);
    72.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    73.          byte := KDF9_char_sets.symbol(fetch_word(w) and 8#77#);
    74.          size := size + 1;
    75.          char := to_CP(byte);
    76.          put_byte(char, the_CP.stream);
    77.       exit when writing_to_EM and char = KDF9_char_sets.E_M;
    78.       end loop;
    79.       put_EOL(the_CP.stream);
    80.       the_CP.unit_count := the_CP.unit_count + 1;
    81.       do_output_housekeeping(the_CP, fetched => size);
    82.    end words_write_card;
    83.
    84.    overriding
    85.    procedure POA (the_CP      : in out CP.device;
    86.                   Q_operand   : in KDF9.Q_register;
    87.                   set_offline : in Boolean) is
    88.    begin
    89.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
    90.       write_card(the_CP, Q_operand, max_words => 20);
    91.       lock_out_relative_addresses(Q_operand);
    92.    end POA;
    93.
    94.    overriding
    95.    procedure POB (the_CP      : in out CP.device;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean) is
    98.    begin
    99.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   100.       write_card(the_CP, Q_operand, max_words => 20, writing_to_EM => True);
   101.       lock_out_relative_addresses(Q_operand);
   102.    end POB;
   103.
   104.    overriding
   105.    procedure POC (the_CP      : in out CP.device;
   106.                   Q_operand   : in KDF9.Q_register;
   107.                   set_offline : in Boolean) is
   108.    begin
   109.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   110.       words_write_card(the_CP, Q_operand, max_words => 160);
   111.       lock_out_relative_addresses(Q_operand);
   112.    end POC;
   113.
   114.    overriding
   115.    procedure POD (the_CP      : in out CP.device;
   116.                   Q_operand   : in KDF9.Q_register;
   117.                   set_offline : in Boolean) is
   118.    begin
   119.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   120.       words_write_card(the_CP, Q_operand, max_words => 160, writing_to_EM => True);
   121.       lock_out_relative_addresses(Q_operand);
   122.    end POD;
   123.
   124.    overriding
   125.    procedure POE (the_CP      : in out CP.device;
   126.                   Q_operand   : in KDF9.Q_register;
   127.                   set_offline : in Boolean) is
   128.    begin
   129.       POC(the_CP, Q_operand, set_offline);
   130.    end POE;
   131.
   132.    overriding
   133.    procedure POF (the_CP      : in out CP.device;
   134.                   Q_operand   : in KDF9.Q_register;
   135.                   set_offline : in Boolean) is
   136.    begin
   137.       POA(the_CP, Q_operand, set_offline);
   138.    end POF;
   139.
   140.    overriding
   141.    procedure POG (the_CP      : in out CP.device;
   142.                   Q_operand   : in KDF9.Q_register;
   143.                   set_offline : in Boolean) is
   144.    begin
   145.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   146.       write_card(the_CP, Q_operand, max_words => 10, writing_to_EM => False);
   147.       lock_out_relative_addresses(Q_operand);
   148.    end POG;
   149.
   150.    overriding
   151.    procedure POH (the_CP      : in out CP.device;
   152.                   Q_operand   : in KDF9.Q_register;
   153.                   set_offline : in Boolean) is
   154.    begin
   155.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   156.       write_card(the_CP, Q_operand, max_words => 10, writing_to_EM => True);
   157.       lock_out_relative_addresses(Q_operand);
   158.    end POH;
   159.
   160.    overriding
   161.    procedure POK (the_CP      : in out CP.device;
   162.                   Q_operand   : in KDF9.Q_register;
   163.                   set_offline : in Boolean) is
   164.    begin
   165.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   166.       -- See the Manual, p289.
   167.       words_write_card(the_CP, Q_operand, max_words => 80, writing_to_EM => True);
   168.       lock_out_relative_addresses(Q_operand);
   169.    end POK;
   170.
   171.    overriding
   172.    procedure POL (the_CP      : in out CP.device;
   173.                   Q_operand   : in KDF9.Q_register;
   174.                   set_offline : in Boolean) is
   175.    begin
   176.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   177.       -- See the Manual, p289.
   178.       words_write_card(the_CP, Q_operand, max_words => 80, writing_to_EM => False);
   179.       lock_out_relative_addresses(Q_operand);
   180.    end POL;
   181.
   182.    overriding
   183.    procedure Finalize (the_CP : in out CP.device) is
   184.    begin
   185.       close(
   186.             the_CP,
   187.             "punched",
   188.             the_CP.unit_count,
   189.             "card" & plurality(the_CP.unit_count)
   190.            );
   191.    end Finalize;
   192.
   193.    type CP_access is access CP.device;
   194.
   195.    CP0 : CP_access with Warnings => Off;
   196.    CP1 : CP_access with Warnings => Off;
   197.
   198.    unit : IOC.unit_number := 0;
   199.
   200.    procedure enable (b : in KDF9.buffer_number) is
   201.    begin
   202.       case unit is
   203.          when 0 =>
   204.             CP0 := new CP.device (number => b, unit => 0);
   205.             CP0_number := b;
   206.          when 1 =>
   207.             CP1 := new CP.device (number => b, unit => 1);
   208.             CP1_number := b;
   209.          when others =>
   210.             trap_operator_error("more than two CP units have been configured");
   211.       end case;
   212.       unit := unit + 1;
   213.    end enable;
   214.
   215. end IOC.slow.unit.CP;

Compiling: ../Source/ioc-slow-unit-cp.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a card punch buffer.
     2. -- Card punches are "unit record" devices: they cannot transfer less than a whole card.
     3. --
     4. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package IOC.slow.unit.CP is
    19.
    20.    type device is new IOC.slow.unit.device with private;
    21.
    22.    -- Punch binary mode.
    23.    overriding
    24.    procedure POA (the_CP      : in out CP.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    -- Punch binary mode to End Message.
    29.    overriding
    30.    procedure POB (the_CP      : in out CP.device;
    31.                   Q_operand   : in KDF9.Q_register;
    32.                   set_offline : in Boolean);
    33.
    34.    -- Punch binary character mode.
    35.    overriding
    36.    procedure POC (the_CP      : in out CP.device;
    37.                   Q_operand   : in KDF9.Q_register;
    38.                   set_offline : in Boolean);
    39.
    40.    -- Punch binary character mode to End Message.
    41.    overriding
    42.    procedure POD (the_CP      : in out CP.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    -- As POC.
    47.    overriding
    48.    procedure POE (the_CP      : in out CP.device;
    49.                   Q_operand   : in KDF9.Q_register;
    50.                   set_offline : in Boolean);
    51.
    52.    -- As POA.
    53.    overriding
    54.    procedure POF (the_CP      : in out CP.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    -- Punch alphanumeric mode.
    59.    overriding
    60.    procedure POG (the_CP      : in out CP.device;
    61.                   Q_operand   : in KDF9.Q_register;
    62.                   set_offline : in Boolean);
    63.
    64.    -- Punch alphanumeric mode to End Message.
    65.    overriding
    66.    procedure POH (the_CP      : in out CP.device;
    67.                   Q_operand   : in KDF9.Q_register;
    68.                   set_offline : in Boolean);
    69.
    70.    -- Punch alphanumeric character mode to End Message.
    71.    overriding
    72.    procedure POK (the_CP      : in out CP.device;
    73.                   Q_operand   : in KDF9.Q_register;
    74.                   set_offline : in Boolean);
    75.
    76.    -- Punch alphanumeric character mode.
    77.    overriding
    78.    procedure POL (the_CP      : in out CP.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean);
    81.
    82.    procedure enable (b : in KDF9.buffer_number);
    83.
    84. private
    85.
    86.    type device is new IOC.slow.unit.device with null record;
    87.
    88.    overriding
    89.    procedure Initialize (the_CP : in out CP.device);
    90.
    91.    overriding
    92.    procedure Finalize (the_CP : in out CP.device);
    93.
    94.    overriding
    95.    function kind (the_CP : CP.device)
    96.    return IOC.device_kind
    97.    is (CP_kind);
    98.
    99.    overriding
   100.    function quantum (the_CP : CP.device)
   101.    return KDF9.us
   102.    is (1E6 / (300 / 60)); -- 300 cards per minute.
   103.
   104. end IOC.slow.unit.CP;

 215 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-the_locker_of.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Identify the buffer that caused a store lockout.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. function IOC.the_locker_of (address : KDF9.Q_part; found : out Boolean)
    18. return KDF9.Q_part is
    19.    candidate_time   : KDF9.us     := KDF9.us'Last;
    20.    candidate_number : KDF9.Q_part := 0;
    21. begin
    22.    -- Select the buffer actively doing DMA in the_group;
    23.    --    if there is more than one, choose the buffer with the earliest completion time.
    24.    -- The latter case should not arise in practice, but is allowed by the hardware.
    25.    found := False;
    26.    for b in buffer'Range loop
    27.       if buffer(b) /= null                                               and then
    28.             buffer(b).is_busy                                            and then
    29.                buffer(b).operation in input_operation | output_operation and then
    30.                   buffer(b).completion_time < candidate_time             and then
    31.                      group(address) in group(buffer(b).control_word.I)
    32.                                     .. group(buffer(b).control_word.M)       then
    33.          found := True;
    34.          candidate_number := b;
    35.          candidate_time   := buffer(b).completion_time;
    36.       end if;
    37.    end loop;
    38.    return candidate_number;
    39. end IOC.the_locker_of;

 39 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-slow-unit-lp.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a lineprinter buffer.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.unit.LP is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_LP : in out LP.device) is
    23.    begin
    24.       open(the_LP, write_mode);
    25.    end Initialize;
    26.
    27.    max_LP_line_length : constant := 160;  -- This is a hardware limit.
    28.    max_LP_page_length : constant :=  66;  -- This is the length of a page of standard stationery.
    29.
    30.    -- The number of lines traversed by paper motion with a standard control loop.
    31.    function skip_length (the_LP : LP.device; symbol : KDF9_char_sets.symbol)
    32.    return KDF9.word
    33.    is (
    34.        if symbol = KDF9_char_sets.Page_Change
    35.        then max_LP_page_length - the_LP.unit_count mod max_LP_page_length
    36.        else 1
    37.       );
    38.
    39.    procedure do_output_housekeeping (the_LP   : in out LP.device;
    40.                                      old_count,
    41.                                      fetched  : in KDF9.word) is
    42.    begin
    43.       flush(the_LP.stream);
    44.       correct_transfer_time(the_LP, IO_elapsed_time(the_LP, the_LP.unit_count-old_count));
    45.       add_in_the_IO_CPU_time(the_LP, fetched);
    46.    end do_output_housekeeping;
    47.
    48.    next_column : Natural := 0;
    49.
    50.    procedure print (symbol : in KDF9_char_sets.symbol; the_LP : in out LP.device) is
    51.       char : constant Character := to_LP(symbol);
    52.    begin
    53.       if char /= KDF9_char_sets.W_F then
    54.          if symbol in KDF9_char_sets.Line_Shift | KDF9_char_sets.Page_Change then
    55.             the_LP.unit_count := the_LP.unit_count + skip_length(the_LP, symbol);
    56.             put_char(char, the_LP.stream);
    57.             next_column := 0;
    58.          elsif next_column < max_LP_line_length then
    59.             next_column := next_column + 1;
    60.             put_char(char, the_LP.stream);
    61.          end if;
    62.       end if;
    63.    end print;
    64.
    65.    -- It is unclear what should happen if more than max_LP_line_length printable characters
    66.    --    are sent to the printer before a LS or PC character, which empties the print matrix.
    67.    -- ee9 simply ignores the excess.
    68.
    69.    procedure put_symbols (the_LP        : in out LP.device;
    70.                           Q_operand     : in KDF9.Q_register;
    71.                           writing_to_EM : in Boolean) is
    72.       start_address : constant KDF9.address := Q_operand.I;
    73.       end_address   : constant KDF9.address := Q_operand.M;
    74.       count         : constant KDF9.word := the_LP.unit_count;
    75.       size   : KDF9.word := 0;
    76.       symbol : KDF9_char_sets.symbol;
    77.    begin
    78.       check_addresses_and_lockouts(start_address, end_address);
    79.    word_loop:
    80.       for w in start_address .. end_address loop
    81.          for c in KDF9_char_sets.symbol_index'Range loop
    82.             symbol := fetch_symbol(w, c);
    83.             size := size + 1;
    84.       -- Is this what should happen transfers on EM, leaving the print matrix ready for more data ??
    85.       exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
    86.             print(symbol, the_LP);
    87.          end loop;
    88.       end loop word_loop;
    89.       do_output_housekeeping(the_LP, old_count => count, fetched => size);
    90.    end put_symbols;
    91.
    92.    -- LPQq
    93.    overriding
    94.    procedure POA (the_LP      : in out LP.device;
    95.                   Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean) is
    97.    begin
    98.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
    99.       put_symbols(the_LP, Q_operand, writing_to_EM => False);
   100.       lock_out_relative_addresses(Q_operand);
   101.    end POA;
   102.
   103.    -- LPEQq
   104.    overriding
   105.    procedure POB (the_LP      : in out LP.device;
   106.                   Q_operand   : in KDF9.Q_register;
   107.                   set_offline : in Boolean) is
   108.    begin
   109.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   110.       put_symbols(the_LP, Q_operand, writing_to_EM => True);
   111.       lock_out_relative_addresses(Q_operand);
   112.    end POB;
   113.
   114.    procedure put_words (the_LP        : in out LP.device;
   115.                         Q_operand     : in KDF9.Q_register;
   116.                         writing_to_EM : in Boolean) is
   117.       start_address : constant KDF9.address := Q_operand.I;
   118.       end_address   : constant KDF9.address := Q_operand.M;
   119.       count         : constant KDF9.word := the_LP.unit_count;
   120.       size   : KDF9.word := 0;
   121.       symbol : KDF9_char_sets.symbol;
   122.    begin
   123.       check_addresses_and_lockouts(start_address, end_address);
   124.       for w in start_address .. end_address loop
   125.          symbol := KDF9_char_sets.symbol(fetch_word(w) and 8#77#);
   126.          size := size + 1;
   127.       -- Is this what should happen transfers on EM, leaving the print matrix ready for more data ??
   128.       exit when writing_to_EM and symbol = KDF9_char_sets.End_Message;
   129.          print(symbol, the_LP);
   130.       end loop;
   131.       do_output_housekeeping(the_LP, old_count => count, fetched => size);
   132.    end put_words;
   133.
   134.    -- Character write ?? Usercode Digest and Manual conflict!
   135.    overriding
   136.    procedure POC (the_LP      : in out LP.device;
   137.                   Q_operand   : in KDF9.Q_register;
   138.                   set_offline : in Boolean) is
   139.    begin
   140.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   141.       put_words(the_LP, Q_operand, writing_to_EM => False);
   142.       lock_out_relative_addresses(Q_operand);
   143.    end POC;
   144.
   145.    -- Character write to End_Message ?? Usercode Digest and Manual conflict!
   146.    overriding
   147.    procedure POD (the_LP      : in out LP.device;
   148.                   Q_operand   : in KDF9.Q_register;
   149.                   set_offline : in Boolean) is
   150.    begin
   151.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   152.       put_words(the_LP, Q_operand, writing_to_EM => True);
   153.       lock_out_relative_addresses(Q_operand);
   154.    end POD;
   155.
   156.    overriding
   157.    procedure Finalize (the_LP : in out LP.device) is
   158.    begin
   159.       close(
   160.             the_LP,
   161.             "printed",
   162.             the_LP.unit_count,
   163.             "line" & plurality(the_LP.unit_count)
   164.            );
   165.    end Finalize;
   166.
   167.    type LP_access is access LP.device;
   168.
   169.    LP0 : LP_access with Warnings => Off;
   170.    LP1 : LP_access with Warnings => Off;
   171.
   172.    unit : IOC.unit_number := 0;
   173.
   174.    procedure enable (b : in KDF9.buffer_number) is
   175.    begin
   176.       case unit is
   177.          when 0 =>
   178.             LP0 := new LP.device (number => b, unit => 0);
   179.             LP0_number := b;
   180.          when 1 =>
   181.             LP1 := new LP.device (number => b, unit => 1);
   182.             LP1_number := b;
   183.          when others =>
   184.             trap_operator_error("more than two LP units have been configured");
   185.       end case;
   186.       unit := unit + 1;
   187.    end enable;
   188.
   189. end IOC.slow.unit.LP;

Compiling: ../Source/ioc-slow-unit-lp.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Emulation of a lineprinter buffer.
     2. -- Lineprinters are "unit record" devices: they cannot transfer less than a whole line.
     3. --
     4. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package IOC.slow.unit.LP is
    19.
    20.    type device is new IOC.slow.unit.device with private;
    21.
    22.    -- LPQq
    23.    overriding
    24.    procedure POA (the_LP      : in out LP.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    -- LPEQq
    29.    overriding
    30.    procedure POB (the_LP      : in out LP.device;
    31.                   Q_operand   : in KDF9.Q_register;
    32.                   set_offline : in Boolean);
    33.
    34.    -- Character write ??
    35.    overriding
    36.    procedure POC (the_LP      : in out LP.device;
    37.                   Q_operand   : in KDF9.Q_register;
    38.                   set_offline : in Boolean);
    39.
    40.    -- Character write to End_Message ??
    41.    overriding
    42.    procedure POD (the_LP      : in out LP.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    procedure enable (b : in KDF9.buffer_number);
    47.
    48. private
    49.
    50.    type device is new IOC.slow.unit.device with null record;
    51.
    52.    overriding
    53.    procedure Initialize (the_LP : in out LP.device);
    54.
    55.    overriding
    56.    procedure Finalize (the_LP : in out LP.device);
    57.
    58.    overriding
    59.    function kind (the_LP : LP.device)
    60.    return IOC.device_kind
    61.    is (LP_kind);
    62.
    63.    overriding
    64.    function quantum (the_LP : LP.device)
    65.    return KDF9.us
    66.    is (1E6 / (900 / 60)); -- 900 lines per minute.
    67.
    68. end IOC.slow.unit.LP;

 189 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-cpu.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Support for KDF9 CPU/ALU operations that are not automatically inherited from
     2. --   Ada types; and for types used in the internal functioning of the microcode.
     3. --
     4. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17. --
    18.
    19. package body KDF9.CPU is
    20.
    21. --
    22. --
    23.    --
    24.    -- KDF9 Arithmetic Control (AC) primitives representing Shift Control and associated units.
    25.    -- These units implement shifting, multiplication, division, and floating-point arithmetic.
    26.    --
    27. --
    28. --
    29.
    30.    KDF9_max_signed : constant CPU.s_64 := CPU.s_64(CPU.signed'Last);
    31.    KDF9_min_signed : constant CPU.s_64 := CPU.s_64(CPU.signed'First);
    32.
    33.    function as_word (u : CPU.u_64)
    34.    return KDF9.word
    35.    is (KDF9.word(u and KDF9.word_mask));
    36.
    37.    function as_word (s : CPU.s_64)
    38.    return KDF9.word is
    39.    begin
    40.       if s > KDF9_max_signed or s < KDF9_min_signed then
    41.          the_V_bit_is_set := True;
    42.       end if;
    43.       return as_word(unsign(s));
    44.    end as_word;
    45.
    46.    function contracted (P : KDF9.pair)
    47.    return KDF9.word is
    48.    begin
    49.       if resign(P.lsw) < 0 or (P.msw+1) > 1 then
    50.          the_V_bit_is_set := True;
    51.       end if;
    52.       return (P.lsw and not_sign_bit) or (P.msw and sign_bit);
    53.    end contracted;
    54.
    55.    function shift_time (amount : Natural)
    56.    return KDF9.us
    57.    is (KDF9.us(amount/16 + amount/8 mod 2 + (if amount mod 8 > 0 then 1 else 0)));
    58.
    59.    function normalize_time (amount : Natural)
    60.    return KDF9.us
    61.    is (KDF9.us(amount/8 + (if amount mod 8 > 0 then 1 else 0)));
    62.
    63.    function shift_word_left (W : KDF9.word; amount : word_shift_length)
    64.    return KDF9.word
    65.    is (as_word(shift_left(CPU.u_64(W), amount)));
    66.
    67.    function shift_word_right (W : KDF9.word; amount : word_shift_length)
    68.    return KDF9.word
    69.    is (KDF9.word(shift_right(CPU.u_64(W), amount)));
    70.
    71.    function rotate_word_left (W : KDF9.word; amount : word_shift_length)
    72.    return KDF9.word
    73.    is (shift_word_left(W, amount) or shift_word_right(W, 48-amount));
    74.
    75.    function rotate_word_right (W : KDF9.word; amount : word_shift_length)
    76.    return KDF9.word
    77.    is (shift_word_right(W, amount) or shift_word_left(W, 48-amount));
    78.
    79.    function shift_circular (W : KDF9.word; L : CPU.signed_Q_part)
    80.    return KDF9.word
    81.       -- The logic here conforms to ¶1.1 of EE Report K/GD.y.80, entitled
    82.       --    "KDF 9: SHIFTING AND SHIFT CONTROL".
    83.       -- Circular shifts were implemented by duplicating the operand, doing a double-length
    84.       --    shift of the two words, and selecting the appropriate word from the result.
    85.    is (
    86.        if abs L > 95  then 0
    87.        elsif  L < -48 then shift_word_right(W, Natural(-L-48))
    88.        elsif  L > +48 then shift_word_left(W, Natural(+L-48))
    89.        elsif  L < 0   then rotate_word_right(W, Natural(-L))
    90.        else                rotate_word_left(W, Natural(L))
    91.       );
    92.
    93.    function shift_logical (W : KDF9.word; L : CPU.signed_Q_part)
    94.    return KDF9.word
    95.    is
    96.       (
    97.        if abs L > 47 then 0
    98.        elsif  L < 0  then shift_word_right(W, Natural(-L))
    99.        else               shift_word_left(W, Natural(L))
   100.       );
   101.
   102.    function shift_pair_left (P : KDF9.pair; L : Natural)
   103.    return KDF9.pair is
   104.       result    : KDF9.pair;
   105.       crossover : KDF9.word;
   106.    begin
   107.       -- The logic here conforms to ¶3.2 of EE Report K/GD.y.80.
   108.       if L < 48 then
   109.          result.lsw := shift_word_left(P.lsw, L);
   110.          crossover  := shift_word_right(P.lsw, 48-L);
   111.          result.msw := shift_word_left(P.msw, L) or crossover;
   112.       else
   113.          result.lsw := 0;
   114.          result.msw := shift_word_left(P.lsw, L-48);
   115.       end if;
   116.       return result;
   117.    end shift_pair_left;
   118.
   119.    function shift_pair_right (P : KDF9.pair; L : Natural)
   120.    return KDF9.pair is
   121.       result    : KDF9.pair;
   122.       crossover : KDF9.word;
   123.    begin
   124.       -- The logic here conforms to ¶3.2 of EE Report K/GD.y.80.
   125.       if L < 48 then
   126.          result.msw := shift_word_right(P.msw, L);
   127.          crossover  := shift_word_left(P.msw, 48-L);
   128.          result.lsw := shift_word_right(P.lsw, L) or crossover;
   129.       else
   130.          result.msw := 0;
   131.          result.lsw := shift_word_right(P.msw, L-48);
   132.       end if;
   133.       return result;
   134.    end shift_pair_right;
   135.
   136.    function shift_logical (P : KDF9.pair; L : CPU.signed_Q_part)
   137.    return KDF9.pair
   138.    is (
   139.        if    L > 0 then shift_pair_left(P, Natural(L))
   140.        elsif L < 0 then shift_pair_right(P, Natural(-L))
   141.        else        P
   142.       );
   143.
   144.    function scale_down (W : KDF9.word; amount : Natural)
   145.    return KDF9.word is
   146.       unrounded, clearing : CPU.u_64;
   147.    begin
   148.       if amount = 0 then
   149.          return W;
   150.       elsif amount > 46 then
   151.          if resign(W) < 0 then
   152.             return KDF9.all_one_bits;
   153.          else
   154.             return 0;
   155.          end if;
   156.       else
   157.          -- It is undefined whether the intrinsic shift_right_arithmetic function,
   158.          --    operating on CPU.u_64, yields a rounded result.
   159.          -- So, any rounding it might do is completely suppressed.
   160.          unrounded := shift_right_arithmetic(shift_left(CPU.u_64(W),16), 16);
   161.          clearing  := - shift_left(1, amount);
   162.          return as_word(shift_right_arithmetic(unrounded and clearing, amount));
   163.       end if;
   164.    end scale_down;
   165.
   166.    function scale_down_and_round (W : KDF9.word; amount : Natural)
   167.    return KDF9.word is
   168.       unrounded, clearing, rounding : CPU.u_64;
   169.    begin
   170.       if amount = 0 then
   171.          return W;
   172.       elsif amount > 46 then
   173.          if resign(W) < 0 then
   174.             return KDF9.all_one_bits;
   175.          else
   176.             return 0;
   177.          end if;
   178.       else
   179.          -- It is undefined whether the intrinsic shift_right_arithmetic,
   180.          --    operating on CPU.u_64, yields a rounded result.
   181.          -- So, any rounding it might do is suppressed,
   182.          --    and correct rounding is explicitly computed.
   183.          unrounded := shift_right_arithmetic(shift_left(CPU.u_64(W),16), 16);
   184.          rounding  := shift_right(unrounded, amount-1) and 1;
   185.          clearing  := - shift_left(1, amount);
   186.          unrounded := unrounded and clearing;
   187.          return as_word(shift_right_arithmetic(unrounded, amount) + rounding);
   188.       end if;
   189.    end scale_down_and_round;
   190.
   191.    function scale_up (W : KDF9.word; amount : Natural)
   192.    return KDF9.word is
   193.       M : constant Natural := Natural'Min(amount, 47);
   194.    begin
   195.       if resign(W) < 0 then
   196.          if scale_down(W, 47-M) /= all_one_bits or
   197.                resign(shift_word_left(W, M)) >= 0 then
   198.             -- See EE Report K/GD.y.80., ¶ 1.1.
   199.             the_V_bit_is_set := True;
   200.          end if;
   201.          return shift_word_left(W, M);
   202.       else
   203.          if shift_word_right(W, 47-M) /= KDF9.word'(all_zero_bits) or
   204.                resign(shift_word_left(W, M)) < 0 then
   205.             -- See EE Report K/GD.y.80., ¶ 1.1.
   206.             the_V_bit_is_set := True;
   207.          end if;
   208.          return shift_word_left(W, M);
   209.       end if;
   210.    end scale_up;
   211.
   212.    function shift_arithmetic (I : KDF9.word; L : CPU.signed_Q_part)
   213.    return KDF9.word
   214.    is (
   215.        if L < 0 then scale_down_and_round(I, Natural(-L))
   216.        else          scale_up(I, Natural(L))
   217.       );
   218.
   219.    function scale_up (P : KDF9.pair; L : Natural)
   220.    return KDF9.pair is
   221.       result    : KDF9.pair;
   222.       crossover : KDF9.word;
   223.    begin
   224.       -- The logic here conforms to ¶3.2 of EE Report K/GD.y.80.
   225.       -- D0 of P.lsw is effectively ignored.
   226.       if L < 48 then
   227.          result.lsw := shift_word_left(P.lsw, L) and KDF9.not_sign_bit;
   228.          crossover  := shift_word_right(P.lsw and KDF9.not_sign_bit, 47-L);
   229.          result.msw := scale_up(P.msw, L) or crossover;
   230.       else
   231.          result.lsw := 0;
   232.          result.msw := (P.msw and KDF9.sign_bit) or (P.lsw and KDF9.not_sign_bit);
   233.          result.msw := scale_up(result.msw, Natural'Min(L, 94)-47);
   234.      end if;
   235.       return result;
   236.    end scale_up;
   237.
   238.    function scale_down (P : KDF9.pair; L : Natural)
   239.    return KDF9.pair is
   240.       result    : KDF9.pair;
   241.       crossover : KDF9.word;
   242.    begin
   243.       -- The logic here conforms to ¶3.2 of EE Report K/GD.y.80.
   244.       -- D0 of P.lsw is effectively ignored.
   245.       -- SHAD-n does NOT round, according to the Manual.
   246.       if L < 48 then
   247.          result.msw := scale_down(P.msw, L);
   248.          crossover  := shift_word_left(P.msw, 47-L) and KDF9.not_sign_bit;
   249.          result.lsw := shift_word_right(P.lsw and KDF9.not_sign_bit, L) or crossover;
   250.       else
   251.          result.msw := scale_down(P.msw, 47);
   252.          result.lsw := shift_word_right(P.msw, Natural'Min(L, +94)-47) and KDF9.not_sign_bit;
   253.       end if;
   254.       return result;
   255.    end scale_down;
   256.
   257.    function shift_arithmetic (P : KDF9.pair; L : CPU.signed_Q_part)
   258.    return KDF9.pair
   259.    is (
   260.        if    L < 0 then scale_down(P, Natural(-L))
   261.        elsif L > 0 then scale_up(P, Natural(L))
   262.        else             P -- See ¶1.1 of EE Report K/GD.y.80: this avoids clearing D0 of P.lsw.
   263.       );
   264.
   265.    -- Count the leading zeros of the absolute value of y, omitting the sign bit.
   266.    -- If y is 0, return 47.
   267.    function nr_leading_zeros (y : KDF9.word)
   268.    return Natural is
   269.       x : CPU.u_64;
   270.       r : Natural;
   271.    begin
   272.       if y = 0 then return 47; end if;
   273.       if resign(y) < 0 then
   274.          x := CPU.u_64(16#FFFF_FFFF_FFFF# and not y);
   275.       else
   276.          x := CPU.u_64(y);
   277.       end if;
   278.       -- Only 48 bits of x need be tested.
   279.       if (x and 16#FFFF_0000_0000#) /= 0 then
   280.          r := 32; x := shift_right(x, 32);
   281.       elsif (x and 16#FFFF_0000#) /= 0 then
   282.          r := 16; x := shift_right(x, 16);
   283.       else
   284.          r := 0;
   285.       end if;
   286.       if (x and 16#FF00#) /= 0 then
   287.          r := r + 8; x := shift_right(x, 8);
   288.       end if;
   289.       if (x and 16#F0#) /= 0 then
   290.          r := r + 4; x := shift_right(x, 4);
   291.       end if;
   292.       if (x and 16#C#) /= 0 then
   293.          r := r + 2; x := shift_right(x, 2);
   294.       end if;
   295.       if (x and 16#2#) /= 0 then
   296.          r := r + 1;
   297.       end if;
   298.       r := 47 - r - 1;  -- -1 discounts the sign bit.
   299.       return r;
   300.    end nr_leading_zeros;
   301.
   302.    procedure normalize (fraction, exponent : in out KDF9.word) is
   303.       sign_flag  : constant KDF9.word := shift_word_right(fraction and sign_bit, 1);
   304.       normalizer : Natural;
   305.    begin
   306.       if fraction = 0 then
   307.          exponent := 2#10_000_000#;  -- This yields 0 when biased positive.
   308.          return;
   309.       end if;
   310.
   311.       normalizer := nr_leading_zeros(fraction);
   312.       exponent := exponent - KDF9.word(normalizer);
   313.
   314.       -- shift_word_left is used, not _arithmetic, as D[1..normalizer] = D0
   315.       fraction := shift_word_left(fraction, normalizer);
   316.
   317.       the_CPU_delta := the_CPU_delta + normalize_time(normalizer);
   318.
   319.       -- scale_down_and_round may round up and overflow the fraction bits ...
   320.       fraction := scale_down_and_round(fraction, 8);
   321.       if (fraction and overflow_mask) /= shift_word_right(sign_flag, 7) then
   322.           -- ... so re-normalize; scale_down cannot round here.
   323.          fraction := scale_down(fraction, 1);
   324.          the_CPU_delta := the_CPU_delta + normalize_time(1);
   325.          exponent := exponent + 1;
   326.          the_CPU_delta := the_CPU_delta + 1;
   327.       end if;
   328.       fraction := fraction and mantissa_mask;
   329.
   330.       if resign(exponent) < -128 then
   331.          -- Deal with underflow.
   332.          fraction := 0;
   333.          exponent := 2#10_000_000#;  -- This yields 0 when biased positive.
   334.       elsif resign(exponent) > +127 then
   335.          -- Deal with overflow.
   336.          the_V_bit_is_set := True;
   337.          exponent := 2#01_111_111#;
   338.       end if;
   339.    end normalize;
   340.
   341.    function fraction_word (mantissa : CPU.f48)
   342.    return KDF9.word
   343.     -- shift_word_left must be used instead of scale_up to avoid a spurious overflow.
   344.    is (
   345.        (shift_word_left(as_word(mantissa), 8) and KDF9.not_sign_bit)
   346.           or
   347.        (as_word(mantissa) and sign_bit)
   348.       );
   349.
   350.    function masked_mantissa (F : CPU.f48)
   351.    return CPU.f48
   352.    is (as_f48(as_word(F) and mantissa_mask));
   353.
   354.    function scaler (F : CPU.f48)
   355.    return KDF9.word
   356.    is ((shift_word_right(as_word(F), 39) and 2#11_111_111#) - 128);
   357.
   358.    function normalized (full_fraction, scaler : KDF9.word)
   359.    return CPU.f48 is
   360.       E : KDF9.word := scaler;
   361.       F : KDF9.word := full_fraction;
   362.    begin
   363.       normalize(fraction => F, exponent => E);
   364.       return CPU.f48(shift_word_left((E + 128) and 2#11_111_111#, 39) or F);
   365.    end normalized;
   366.
   367.    function normalized  (R : CPU.f48)
   368.    return CPU.f48
   369.    is (normalized(full_fraction => fraction_word(R), scaler => scaler(R)));
   370.
   371.    function "-" (I : CPU.signed)
   372.    return KDF9.word
   373.    is (as_word(-CPU.s_64(I)));
   374.
   375.    function "abs" (I : CPU.signed)
   376.    return KDF9.word
   377.    is (as_word(abs CPU.s_64(I)));
   378.
   379.    function "+" (L, R : CPU.signed)
   380.    return KDF9.word
   381.    is (as_word(CPU.s_64(L) + CPU.s_64(R)));
   382.
   383.    function "-" (L, R : CPU.signed)
   384.    return KDF9.word
   385.    is (as_word(CPU.s_64(L) - CPU.s_64(R)));
   386.
   387.    function "*" (L, R : CPU.signed)
   388.    return KDF9.word
   389.    is (contracted(KDF9.pair'(unsign(L) * unsign(R))));
   390.
   391.    procedure do_DIVI (
   392.                       L         : in KDF9.word;
   393.                       R         : in KDF9.word;
   394.                       Quotient,
   395.                       Remainder : out KDF9.word
   396.                      ) is
   397.    begin
   398.       if R /= 0 then
   399.          Remainder := as_word(CPU.s_64(resign(L)) mod CPU.s_64(resign(R)));
   400.          Quotient  :=
   401.             as_word((CPU.s_64(resign(L)) - CPU.s_64(resign(Remainder))) / CPU.s_64(resign(R)));
   402.       else
   403.          the_V_bit_is_set := True;
   404.          Quotient  := L;  -- ??
   405.          Remainder := R;  -- ??
   406.       end if;
   407.    end do_DIVI;
   408.
   409.    function "*" (L, R : KDF9.word)
   410.    return CPU.fraction is
   411.    begin
   412.       if L = sign_bit and R = sign_bit then
   413.          the_V_bit_is_set := True;
   414.          return as_fraction(sign_bit);  -- The only case is L = R = -1.0 = L*R.
   415.       else
   416.          return as_fraction(L) * as_fraction(R);
   417.       end if;
   418.    end "*";
   419.
   420.    function "/" (L, R : KDF9.word)
   421.    return CPU.fraction is
   422.    begin
   423.       if R = 0 or L = sign_bit then
   424.          the_V_bit_is_set := True;
   425.          return as_fraction(L); -- ??
   426.       elsif R = sign_bit then
   427.          return -as_fraction(L);
   428.       elsif abs as_fraction(L) < abs as_fraction(R) then  -- abs is safe now.
   429.          return as_fraction(L) / as_fraction(R);
   430.       else
   431.          the_V_bit_is_set := True;
   432.          return as_fraction(L); -- ??
   433.       end if;
   434.    end "/";
   435.
   436.    function "+" (L, R : KDF9.pair)
   437.    return KDF9.pair is
   438.       carry, sum : CPU.s_64;
   439.       result     : KDF9.pair;
   440.    begin
   441.       sum := CPU.s_64(L.lsw and KDF9.not_sign_bit) + CPU.s_64(R.lsw and KDF9.not_sign_bit);
   442.       if unsign(sum) > KDF9.max_word then -- carry into msw
   443.          carry := 1;
   444.          result.lsw := KDF9.word(unsign(sum) and KDF9.not_sign_bit);
   445.       else
   446.          carry := 0;
   447.          result.lsw := KDF9.word(sum);
   448.       end if;
   449.       sum := CPU.s_64(resign(L.msw)) + CPU.s_64(resign(R.msw)) + carry;
   450.       result.msw := as_word(sum);
   451.       return result;
   452.    end "+";
   453.
   454.    function "-" (J : KDF9.pair)
   455.    return KDF9.pair is
   456.       borrow,
   457.       negative : CPU.s_64;
   458.       result   : KDF9.pair;
   459.    begin
   460.       negative := - CPU.s_64(J.lsw and KDF9.not_sign_bit);
   461.       if unsign(negative) > KDF9.max_word then -- borrow from msw
   462.          borrow := 1;
   463.          result.lsw := KDF9.word(unsign(negative) and KDF9.not_sign_bit);
   464.       else
   465.          borrow := 0;
   466.          result.lsw := KDF9.word(negative);
   467.       end if;
   468.       negative := - CPU.s_64(resign(J.msw)) - borrow;
   469.       result.msw := as_word(negative);
   470.       return result;
   471.    end "-";
   472.
   473.    function "-" (L, R : KDF9.pair)
   474.    return KDF9.pair is
   475.       borrow,
   476.       difference : CPU.s_64;
   477.       result     : KDF9.pair;
   478.    begin
   479.       difference := CPU.s_64(L.lsw and KDF9.not_sign_bit) - CPU.s_64(R.lsw and KDF9.not_sign_bit);
   480.       if unsign(difference) > KDF9.max_word then -- borrow from msw
   481.          borrow := 1;
   482.          result.lsw := KDF9.word(unsign(difference) and KDF9.not_sign_bit);
   483.       else
   484.          borrow := 0;
   485.          result.lsw := KDF9.word(difference);
   486.       end if;
   487.       difference := CPU.s_64(resign(L.msw)) - CPU.s_64(resign(R.msw)) - borrow;
   488.       result.msw := as_word(difference);
   489.       return result;
   490.    end "-";
   491.
   492.    function "*" (L, R : KDF9.word)
   493.    return KDF9.pair is
   494.       S, T, U, V, W : KDF9.word;
   495.       H, M, B       : KDF9.pair;
   496.    begin
   497.       if L = sign_bit then
   498.          if R = L then
   499.             -- L*R = (+1.0), which is not a valid fraction, so deal with overflow.
   500.             the_V_bit_is_set := True;
   501.             return (L, 0);
   502.          else
   503.             -- L*R = -R.
   504.             return -(R, 0);
   505.          end if;
   506.       end if;
   507.       if R = sign_bit then
   508.          -- L*R = -L.
   509.          return -(L, 0);
   510.       end if;
   511.       -- Now it is safe to take absolute values, as they cannot overflow.
   512.       S := scale_down(abs resign(L), 24);
   513.       T := abs resign(L) and halfword_mask;
   514.       U := scale_down(abs resign(R), 24);
   515.       V := abs resign(R) and halfword_mask;
   516.       H := ((S*U)*2, 0);
   517.       M := scale_down((KDF9.word'(S*V), 0), 1) + scale_down((KDF9.word'(T*U), 0), 1);
   518.       M := scale_down(M, 22);
   519.       W := rotate_word_left(KDF9.word'(T*V), 1);
   520.       B := (W and 1, shift_word_right(W, 1));
   521.       if resign(L xor R) < 0 then
   522.          return - (H + M + B);
   523.       else
   524.          return    H + M + B;
   525.       end if;
   526.    end "*";
   527.
   528.    f_64_small : constant := 2.0**(-63);
   529.    type f_64 is delta f_64_small range -1.0 .. +1.0 - f_64_small with Size => 64;
   530.
   531.    function scale_down (f : CPU.f_64; N : Natural)
   532.    return f_64
   533.    is (if N > 62 then 0.0 else f / 2**N);
   534.
   535.    function to_f_64 (w : KDF9.word)
   536.    return CPU.f_64
   537.    is (CPU.f_64(as_fraction(w)));
   538.
   539.    function to_word (f : CPU.f_64)
   540.    return KDF9.word
   541.    is (as_word(CPU.fraction(f)));
   542.
   543.    procedure long_division (
   544.                             L : in KDF9.pair;
   545.                             R : in KDF9.word;
   546.                             Q : out KDF9.word
   547.                            ) is
   548.       N  : KDF9.pair := L;
   549.       D  : KDF9.word;
   550.       Ls,
   551.       Rs,
   552.       Qs : CPU.f_64;
   553.       normalizer_N : Natural;
   554.       normalizer_R : Natural;
   555.       normalizer_Q : Integer;
   556.    begin
   557.       -- Normalize the dividend.
   558.       normalizer_N := nr_leading_zeros(N.msw);
   559.       if normalizer_N < 47 then
   560.          -- N.msw contains significant bits.
   561.          N := scale_up(N, normalizer_N);
   562.       else
   563.          -- All of the significant bits are in N.lsw, which is non-zero.
   564.          N := scale_up(N, 47);
   565.          normalizer_N := nr_leading_zeros(N.msw);
   566.          N := scale_up(N, normalizer_N);
   567.          normalizer_N := normalizer_N + 47;
   568.       end if;
   569.
   570.       -- Normalize the divisor.
   571.       normalizer_R := nr_leading_zeros(R);
   572.       D := scale_up(R, normalizer_R);
   573.
   574.       -- Scale Ls and Rs so that the Ada fractional division cannot overflow.
   575.       Ls := scale_down(to_f_64(N.msw), 2);
   576.       Rs := scale_down(to_f_64(D), 1);
   577.
   578.       Qs := Ls / Rs;  -- Ada fractional division rounds, correctly for KDF9 DIV and DIVD.
   579.
   580.       -- Rescale the quotient.
   581.       normalizer_Q := 1 + normalizer_R - normalizer_N;
   582.       if normalizer_Q <= 0 then
   583.          -- Overflow is impossible.
   584.          Qs := scale_down(Qs, -normalizer_Q);
   585.          Q := to_word(Qs);
   586.       else
   587.          -- If Qs >= 0.5, then L/R >= 1.0 is not a representable result fraction.
   588.          -- If Qs < -0.5, then L/R < -1.0 is not a representable result fraction.
   589.          the_V_bit_is_set := Qs >= 0.5 or Qs < -0.5;
   590.          Q := scale_up(to_word(Qs), normalizer_Q);  -- A guess at the result for overflow ?? !!
   591.       end if;
   592.    end long_division;
   593.
   594.    procedure do_DIVD (
   595.                       L : in KDF9.pair;
   596.                       R : in KDF9.word;
   597.                       Q : out KDF9.word
   598.                      ) is
   599.       N : KDF9.pair;
   600.    begin
   601.       N.msw := L.msw;
   602.       -- Ignore an invalid D0 in the lsw of the dividend.
   603.       N.lsw := L.lsw and KDF9.not_sign_bit;
   604.
   605.       -- Deal quickly with a zero dividend, giving a zero result.
   606.       if (N.msw or N.lsw) = 0 then
   607.          Q := 0;
   608.          return;
   609.       end if;
   610.
   611.       -- Deal with division by 0.
   612.       if R = 0 then
   613.          the_V_bit_is_set := True;
   614.          Q := N.msw;  -- A guess at the result for division by zero ?? !!
   615.          return;
   616.       end if;
   617.
   618.       long_division(N, R, Q);
   619.    end do_DIVD;
   620.
   621.    procedure do_DIVR (
   622.                       L         : in KDF9.pair;
   623.                       R         : in KDF9.word;
   624.                       Quotient,
   625.                       Remainder : out KDF9.word
   626.                      ) is
   627.       N  : KDF9.pair := L;
   628.       D  : KDF9.word := R;
   629.       S  : Integer   := 1;
   630.       T  : KDF9.pair;
   631.    begin
   632.       -- Ignore an invalid D0 in the lsw of the dividend.
   633.       N.lsw := N.lsw and KDF9.not_sign_bit;
   634.
   635.       -- Deal quickly with a zero dividend, giving a zero result.
   636.       if (N.msw or N.lsw) = 0 then
   637.          Quotient  := 0;
   638.          Remainder := 0;
   639.          return;
   640.       end if;
   641.
   642.       -- Deal with division by 0.
   643.       if R = 0 then
   644.          the_V_bit_is_set := True;
   645.          -- A guess at the results for division by zero ?? !!
   646.          Quotient  := N.msw;
   647.          Remainder := 0;
   648.          return;
   649.       end if;
   650.
   651.       -- Convert to an unsigned division problem, and note whether it needs to be be converted back.
   652.       if resign(N.msw) < 0 then
   653.          N := - N;
   654.          S := - S;
   655.       end if;
   656.       if resign(R) < 0 then
   657.          D := - D;
   658.          S := - S;
   659.       end if;
   660.
   661.       -- Check for inevitable overflow, and deal with it separately.
   662.       if N.msw > D then
   663.          the_V_bit_is_set := True;
   664.          -- A guess at the results for overflow ?? !!
   665.          Quotient := (if S < 0 then -(N.msw / D) else N.msw / D);
   666.          T := L - (msw => Quotient*R, lsw => 0);
   667.          Remainder := T.msw;
   668.          return;
   669.       end if;
   670.
   671.       -- Overflow is now impossible, but the result may be rounded.
   672.       long_division(N, D, Quotient);
   673.
   674.       -- Undo any rounding effected by do_DIVD.
   675.       loop
   676.          T := N - Quotient * D;
   677.       exit when T.msw = 0;
   678.          Quotient := Quotient + 1;
   679.       end loop;
   680.       Quotient  := Quotient + T.lsw / D;
   681.
   682.       -- Correct the sign of the quotient and compute the remainder.
   683.       Quotient  := (if S < 0 then -Quotient else Quotient);
   684.       Remainder := contracted(L - Quotient*R);
   685.    end do_DIVR;
   686.
   687.    function host_float (X : CPU.f48)
   688.    return Long_Float is
   689.       -- Warn if Long_Float does not have at least the range of a KDF9 floating point number.
   690.       pragma Compile_Time_Warning(Long_Float'Last < 2.0**127,
   691.                                   "Long_Float does not have enough range for KDF9 f.p.");
   692.       -- Warn if Long_Float does not have at least the precision of a KDF9 floating point number.
   693.       pragma Compile_Time_Warning(Long_Float'Small > 1.0/2.0**39,
   694.                                   "Long_Float does not have enough precision for KDF9 f.p.");
   695.       W : constant KDF9.word  := fraction_word(masked_mantissa(X));
   696.       S : constant Long_Float := 2.0**Integer(resign(scaler(X)));
   697.    begin
   698.       return Long_Float(as_fraction(W)) * S;  -- Cannot overflow if warnings are absent.
   699.    end host_float;
   700.
   701.    -- Round a 48-bit floating-point number to 24-bit format.
   702.    function narrowed (R : CPU.f48)
   703.    return CPU.f48
   704.    is (normalized(fraction_word(R) + 2**23, scaler(R)));
   705.
   706.    overriding
   707.    function "-" (R : CPU.f48)
   708.    return CPU.f48 is
   709.       -- F is made half of a true fraction to prevent overflow when negating:
   710.       --    the result exponent is offset by 1, accordingly.
   711.       E : constant KDF9.word := scaler(R) + 1;
   712.       F : KDF9.word := scale_down_and_round(fraction_word(R), 1);
   713.    begin
   714.       F := as_word(CPU.u_64(-F));  -- "-" cannot overflow here.
   715.       return normalized(full_fraction => F, scaler => E);
   716.    end "-";
   717.
   718.    overriding
   719.    function "abs" (R : CPU.f48)
   720.    return CPU.f48
   721.    is (if resign(KDF9.word(R)) < 0 then - R else + R);
   722.
   723.    overriding
   724.    function "+" (L, R : CPU.f48)
   725.    return CPU.f48 is
   726.       -- B and D are made half of a true fraction to prevent overflow when
   727.       --    adding; the result exponent is offset by 1, accordingly.
   728.       A : constant KDF9.word := scaler(R);
   729.       B : KDF9.word := scale_down(fraction_word(R), 1);
   730.       C : constant KDF9.word := scaler(L);
   731.       D : KDF9.word := scale_down(fraction_word(L), 1);
   732.       E : KDF9.word;
   733.       F : KDF9.word;
   734.       N : Natural;
   735.    begin
   736.       if resign(A) >= resign(C) then
   737.          N := Natural'Min(Natural(resign(A-C)), 48);
   738.          D := scale_down_and_round(D, N);
   739.          E := A + 1;
   740.       else
   741.          N := Natural'Min(Natural(resign(C-A)), 48);
   742.          B := scale_down_and_round(B, N);
   743.          E := C + 1;
   744.       end if;
   745.       the_CPU_delta := the_CPU_delta + shift_time(N);
   746.       F := as_word(CPU.u_64(D + B));  -- "+" cannot overflow here.
   747.       return normalized(full_fraction => F, scaler => E);
   748.    end "+";
   749.
   750.    overriding
   751.    function "-" (L, R : CPU.f48)
   752.    return CPU.f48 is
   753.       -- See "+".
   754.       A : constant KDF9.word := scaler(R);
   755.       B : KDF9.word := scale_down(fraction_word(R), 1);
   756.       C : constant KDF9.word := scaler(L);
   757.       D : KDF9.word := scale_down(fraction_word(L), 1);
   758.       E : KDF9.word;
   759.       F : KDF9.word;
   760.       N : Natural;
   761.    begin
   762.       if resign(A) >= resign(C) then
   763.          N := Natural'Min(Natural(resign(A-C)), 48);
   764.          D := scale_down_and_round(D, N);
   765.          E := A + 1;
   766.       else
   767.          N := Natural'Min(Natural(resign(C-A)), 48);
   768.          B := scale_down_and_round(B, N);
   769.          E := C + 1;
   770.       end if;
   771.       the_CPU_delta := the_CPU_delta + shift_time(N);
   772.       F := as_word(CPU.u_64(D - B));  -- "-" cannot overflow here.
   773.       return normalized(full_fraction => F, scaler => E);
   774.    end "-";
   775.
   776.    overriding
   777.    function "*" (L, R : CPU.f48)
   778.    return CPU.f48 is
   779.       B, D, E, F : KDF9.word;
   780.    begin
   781.       if (KDF9.word(L) or KDF9.word(R)) = 0 then
   782.          return 0;
   783.       end if;
   784.       B := fraction_word(R);
   785.       D := fraction_word(L);
   786.       E := scaler(L) + scaler(R);
   787.       if (B = sign_bit) and (B = D) then
   788.           -- D*B = (+1), which is not a valid fraction, so treat specially.
   789.           B := B / 2;
   790.           D := D / 2;
   791.           E := E + 2;
   792.        end if;
   793.       F := as_word(as_fraction(D) * as_fraction(B));  -- "*" cannot overflow here.
   794.       return normalized(full_fraction => F, scaler => E);
   795.    end "*";
   796.
   797.    overriding
   798.    function "/" (L, R : CPU.f48)
   799.    return CPU.f48 is
   800.       D, N   : CPU.fraction;
   801.       Ls, Rs : KDF9.word;
   802.       E, F   : KDF9.word;
   803.    begin
   804.       if R = 0 then
   805.          the_V_bit_is_set := True;
   806.          return L;  -- ?? This result is not well defined in the Manual.
   807.       end if;
   808.       -- If L>=R, L/R>= 1, which is not a valid fraction; so Ls and Rs are
   809.       --    scaled so that the division cannot overflow.
   810.       Ls := scale_down(fraction_word(L), 2);
   811.       Rs := scale_down(fraction_word(R), 1);
   812.       N := abs as_fraction(Ls);  -- Ls is scaled down by 1/8, so "abs" cannot overflow.
   813.       D := abs as_fraction(Rs);  -- Rs is scaled down by 1/2, so "abs" cannot overflow.
   814.       -- E is increased by 1 to compensate the quotient's scaling by 1/2.
   815.       E := scaler(L) - scaler(R) + 1;
   816.       F := as_word(N / D);
   817.       if resign(KDF9.word(L) xor KDF9.word(R)) < 0 then
   818.          -- The result is negative.
   819.          F := -F;
   820.       end if;
   821.       return normalized(full_fraction => F, scaler => E);
   822.    end "/";
   823.
   824.    overriding
   825.    function "<" (L, R : CPU.f48)
   826.    return Boolean is
   827.       s : constant KDF9.word := KDF9.word(L) xor KDF9.word(R);
   828.    begin
   829.       if resign(s) < 0 then
   830.          -- The signs differ: L<R iff L is negative.
   831.          return resign(KDF9.word(L)) < 0;
   832.       elsif resign(KDF9.word(L)) < 0 then
   833.          -- L and R are both negative, so invert lexicographical order.
   834.          return not (KDF9.word(L) < KDF9.word(R));
   835.       else
   836.          -- L and R are both non-negative: so use lexicographical order.
   837.          return KDF9.word(L) < KDF9.word(R);
   838.       end if;
   839.    end "<";
   840.
   841.    function fraction_pair (DF : CPU.f96)
   842.    return KDF9.pair is
   843.       P : KDF9.pair;
   844.    begin
   845.       P.msw := scale_down(fraction_word(DF.msw), 8);
   846.       P.lsw := fraction_word(DF.lsw) and KDF9.not_sign_bit;
   847.       return scale_up(P, 8);
   848.    end fraction_pair;
   849.
   850.    function scaler (DF : CPU.f96)
   851.    return KDF9.word
   852.    is (scaler(DF.msw));
   853.
   854.    function narrowed (DF : CPU.f96)
   855.    return CPU.f48 is
   856.       fraction : KDF9.pair := fraction_pair(DF) + (0, 2**46);
   857.    begin
   858.       reconstruct(fraction, scaler(DF));
   859.       return CPU.f48(fraction.msw);
   860.    end narrowed;
   861.
   862.    procedure reconstruct (frac   : in out KDF9.pair;
   863.                           scaler : in KDF9.word) is
   864.       KDF9_exponent :  KDF9.word := scaler + 128;
   865.       normalizer    : Natural;
   866.    begin
   867.       if (frac.msw or frac.lsw) = 0 then
   868.          return; -- frac is already normalized.
   869.       end if;
   870.
   871.       normalizer := nr_leading_zeros(frac.msw);
   872.
   873.       if normalizer = 47 then  -- frac.msw is zero, so frac.lsw is non-zero.
   874.          normalizer := 47 + nr_leading_zeros(frac.lsw);
   875.       end if;
   876.
   877.       KDF9_exponent := KDF9_exponent - KDF9.word(normalizer);
   878.
   879.       frac := scale_up(frac, normalizer);
   880.       the_CPU_delta := the_CPU_delta + shift_time(normalizer);
   881.
   882.       -- 96-bit shift_arithmetic does not round and so cannot overflow here.
   883.       frac := scale_down(frac, 8);
   884.       frac.lsw := scale_down(frac.lsw, 8);
   885.       -- Clear both scaler fields.
   886.       frac.msw := frac.msw and mantissa_mask;
   887.       frac.lsw := frac.lsw and mantissa_mask;
   888.       if resign(KDF9_exponent) < 0 then
   889.          -- Deal with underflow.
   890.          frac := (0, 0);
   891.          return;
   892.       elsif KDF9_exponent > 255 then
   893.          -- Deal with overflow.
   894.          the_V_bit_is_set := True;
   895.          KDF9_exponent := 255;
   896.       end if;
   897.
   898.       frac.msw := frac.msw or shift_word_left(KDF9_exponent and 8#377#, 39);
   899.       if KDF9_exponent < 39 then
   900.          frac.lsw := 0;
   901.       else
   902.          frac.lsw := frac.lsw or shift_word_left((KDF9_exponent-39) and 8#377#, 39);
   903.       end if;
   904.    end reconstruct;
   905.
   906.    function "-" (R : CPU.f96)
   907.    return CPU.f96
   908.    is (CPU.f96'(0, 0) - R);
   909.
   910.    function "+" (L, R : CPU.f96)
   911.    return CPU.f96 is
   912.       -- Scale fractions to prevent overflow; must adjust exponent accordingly.
   913.       L_exponent : constant KDF9.word := scaler(L);
   914.       R_exponent : constant KDF9.word := scaler(R);
   915.       L_fraction : KDF9.pair := scale_down(fraction_pair(L), 1);
   916.       R_fraction : KDF9.pair := scale_down(fraction_pair(R), 1);
   917.       exponent   : KDF9.word;
   918.       the_result : KDF9.pair;
   919.       aligner    : Natural;
   920.    begin
   921.       if resign(R_exponent) >= resign(L_exponent) then
   922.          aligner := Natural(resign(R_exponent-L_exponent));
   923.          aligner := Natural'Min(95, aligner);
   924.          L_fraction := scale_down(L_fraction, aligner);
   925.          exponent := R_exponent + 1;
   926.       else
   927.          aligner := Natural(resign(L_exponent-R_exponent));
   928.          aligner := Natural'Min(95, aligner);
   929.          R_fraction := scale_down(R_fraction, aligner);
   930.          exponent := L_exponent + 1;
   931.       end if;
   932.       the_CPU_delta := the_CPU_delta + shift_time(aligner);
   933.       the_result := L_fraction + R_fraction;  -- "+" cannot overflow here.
   934.       reconstruct(the_result, scaler => exponent);
   935.       return as_f96(the_result);
   936.    end "+";
   937.
   938.    function "-" (L, R : CPU.f96)
   939.    return CPU.f96 is
   940.       -- See "+".
   941.       L_exponent : constant KDF9.word := scaler(L);
   942.       R_exponent : constant KDF9.word := scaler(R);
   943.       L_fraction : KDF9.pair := scale_down(fraction_pair(L), 1);
   944.       R_fraction : KDF9.pair := scale_down(fraction_pair(R), 1);
   945.       exponent   : KDF9.word;
   946.       the_result : KDF9.pair;
   947.       aligner    : Natural;
   948.    begin
   949.       if resign(R_exponent) >= resign(L_exponent) then
   950.          aligner := Natural(resign(R_exponent-L_exponent));
   951.          aligner := Natural'Min(95, aligner);
   952.          L_fraction := scale_down(L_fraction, aligner);
   953.          exponent := R_exponent + 1;
   954.       else
   955.          aligner := Natural(resign(L_exponent-R_exponent));
   956.          aligner := Natural'Min(95, aligner);
   957.          R_fraction := scale_down(R_fraction, aligner);
   958.          exponent := L_exponent + 1;
   959.       end if;
   960.       the_CPU_delta := the_CPU_delta + shift_time(aligner);
   961.       the_result := L_fraction - R_fraction;  -- "-" cannot overflow here.
   962.       reconstruct(the_result, scaler => exponent);
   963.       return as_f96(the_result);
   964.    end "-";
   965.
   966.    function "*" (L, R : CPU.f48)
   967.    return CPU.f96 is
   968.       V_was_set : constant Boolean := the_V_bit_is_set;
   969.       LR        : KDF9.pair;
   970.    begin
   971.       the_V_bit_is_set := False;
   972.       LR := fraction_word(L) * fraction_word(R);
   973.       if the_V_bit_is_set then
   974.          -- The product is not a valid fixed-point fraction, but is actually OK,
   975.          --    so restore the orginal overflow state, and  ...
   976.          the_V_bit_is_set := V_was_set;
   977.          --  ... construct +1.0 in double-precision floating-point.
   978.          return as_f96((shift_word_left(2#0_10_000_001_1#, 38), 0));
   979.       end if;
   980.       reconstruct(LR, scaler => scaler(L) + scaler(R));
   981.       return as_f96(LR);
   982.    end "*";
   983.
   984.    function "/" (L : CPU.f96; R : CPU.f48)
   985.    return CPU.f48 is  -- aka DIVDF
   986.       -- If L>=R, L/R>= 1, which is not a valid fraction; so Ls and Rs are
   987.       --    scaled so that the division cannot overflow.
   988.       Ls : constant KDF9.pair := scale_down(fraction_pair(L), 2);
   989.       Rs : constant KDF9.word := scale_down(fraction_word(R), 1);
   990.       -- E is increased by 1 to compensate the quotient's scaling by 1/2.
   991.       E : constant KDF9.word  := scaler(L) - scaler(R) + 1;
   992.       F : KDF9.word;
   993.    begin
   994.       if R = 0 then
   995.          the_V_bit_is_set := True;
   996.          return L.msw;  -- ?? This result is not well defined in the Manual.
   997.       end if;
   998.       do_DIVD(Ls, Rs, F);
   999.       return normalized(full_fraction => F, scaler => E);
  1000.    end "/";
  1001.
  1002.    function number_of_1_bits_in (W : KDF9.word)
  1003.    return KDF9.word is
  1004.       u : constant CPU.u_64 := CPU.u_64(W);
  1005.       n :          CPU.u_64 := shift_right(u, 1) and 16#77_77_77_77_77_77_77_77#;
  1006.       x :          CPU.u_64 := u - n;
  1007.    begin
  1008.       n := shift_right(n, 1) and 16#77_77_77_77_77_77_77_77#;
  1009.       x := x - n;
  1010.       n := shift_right(n, 1) and 16#77_77_77_77_77_77_77_77#;
  1011.       x := x - n;
  1012.       x := (x + shift_right(x, 4)) and 16#0F_0F_0F_0F_0F_0F_0F_0F#;
  1013.       x := x * 16#01_01_01_01_01_01_01_01#;
  1014.       return KDF9.word(shift_right(x, CPU.u_64'Size-8));
  1015.    end number_of_1_bits_in;
  1016.
  1017.    procedure push (F : in CPU.f48) is
  1018.    begin
  1019.       push(KDF9.word(F));
  1020.    end push;
  1021.
  1022.    function pop
  1023.    return CPU.f48
  1024.    is (CPU.f48(KDF9.word'(pop)));
  1025.
  1026.    function read_top
  1027.    return CPU.f48
  1028.    is (CPU.f48(KDF9.word'(read_top)));
  1029.
  1030.    procedure write_top (F : in CPU.f48) is
  1031.    begin
  1032.       write_top(KDF9.word(F));
  1033.    end write_top;
  1034.
  1035.    procedure push (DF : in CPU.f96) is
  1036.       AB : constant KDF9.pair := as_pair(DF);
  1037.    begin
  1038.       push(AB);
  1039.    end push;
  1040.
  1041.    function pop
  1042.    return CPU.f96
  1043.    is (as_f96(pop));
  1044.
  1045.    function read_top
  1046.    return CPU.f96
  1047.    is (as_f96(read_top));
  1048.
  1049.    procedure write_top (DF : in CPU.f96) is
  1050.       AB : constant KDF9.pair := as_pair(DF);
  1051.    begin
  1052.       write_top(AB);
  1053.    end write_top;
  1054.
  1055. end KDF9.CPU;

Compiling: ../Source/kdf9-cpu.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Support for KDF9 CPU/ALU operations that are not automatically inherited from
     2. --   Ada types; and for types used in the internal functioning of the microcode.
     3. --
     4. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with Ada.Unchecked_Conversion;
    19.
    20. package KDF9.CPU is
    21.
    22. --
    23. --
    24.    --
    25.    -- 48-bit integer and fractional ALU types and operations
    26.    --
    27. --
    28. --
    29.
    30.    type signed is range -2**47 .. +2**47 - 1 with Size => KDF9.word'Size;
    31.
    32.    function unsign is new Ada.Unchecked_Conversion (CPU.signed, KDF9.word);
    33.
    34.    function resign is new Ada.Unchecked_Conversion (KDF9.word, CPU.signed);
    35.
    36.    function "-" (I : CPU.signed)
    37.    return KDF9.word
    38.       with Inline;
    39.
    40.    function "abs" (I : CPU.signed)
    41.    return KDF9.word
    42.       with Inline;
    43.
    44.    function "+" (L, R : CPU.signed)
    45.    return KDF9.word
    46.       with Inline;
    47.
    48.    function "-" (L, R : CPU.signed)
    49.    return KDF9.word
    50.       with Inline;
    51.
    52.    function "*" (L, R : CPU.signed)
    53.    return KDF9.word;
    54.
    55.    -- Determine the Quotient and Remainder of L/R, where:
    56.    --    sign(Remainder) = sign(R) and |Remainder| < |R|, i.e. Remainder = L mod R;
    57.    --    Quotient = (L - Remainder) / R.
    58.
    59.    procedure do_DIVI (
    60.                       L         : in KDF9.word;
    61.                       R         : in KDF9.word;
    62.                       Quotient,
    63.                       Remainder : out KDF9.word
    64.                      );
    65.
    66.    -- Inherited signed single-length integer division is removed from the type.
    67.
    68.    function "/" (L, R : CPU.signed)
    69.    return KDF9.word is abstract;
    70.
    71.    function "mod" (L, R : CPU.signed)
    72.    return KDF9.word is abstract;
    73.
    74.    -- Contract a double-word, setting the V bit if necessary.
    75.
    76.    function contracted (P : KDF9.pair)
    77.    return KDF9.word
    78.       with Inline;
    79.
    80. --
    81. --
    82.    -- Shifting operations with KDF9 semantics.
    83. --
    84. --
    85.
    86.    type signed_Q_part is range  -2**15 .. +2**15 - 1 with Size => KDF9.Q_part'Size;
    87.
    88.    function resign is new Ada.Unchecked_Conversion (KDF9.Q_part, CPU.signed_Q_part);
    89.
    90.    -- L>0 for left-shift, L<0 for right-shift.
    91.
    92.    function shift_logical (W : KDF9.word; L : CPU.signed_Q_part)
    93.    return KDF9.word
    94.       with Inline;
    95.
    96.    function shift_circular (W : KDF9.word; L : CPU.signed_Q_part)
    97.    return KDF9.word
    98.       with Inline;
    99.
   100.    -- shift_arithmetic rounds the result correctly.
   101.    function shift_arithmetic (I : KDF9.word; L : CPU.signed_Q_part)
   102.    return KDF9.word
   103.       with Inline;
   104.
   105.    -- number_of_1_bits_in counts the number of bits in W with value 1.
   106.    function number_of_1_bits_in (W : KDF9.word)
   107.    return KDF9.word
   108.       with Inline;
   109.
   110. --
   111. --
   112.    -- A fraction is a word W interpreted as the value W / 2**47;
   113. --
   114. --
   115.
   116.    KDF9_small : constant := 2.0**(-47);
   117.
   118.    type fraction is delta KDF9_small range -1.0 .. +1.0 - KDF9_small with Size => KDF9.word'Size;
   119.
   120.    function as_fraction is new Ada.Unchecked_Conversion (KDF9.word, CPU.fraction);
   121.
   122.    function as_word     is new Ada.Unchecked_Conversion (CPU.fraction, KDF9.word);
   123.
   124.    -- These operations treat the KDF9.word operands as full-word fractions,
   125.
   126.    function "*" (L, R : KDF9.word)
   127.    return CPU.fraction;
   128.
   129.    function "/" (L, R : KDF9.word)
   130.    return CPU.fraction;
   131.
   132.
   133. --
   134. --
   135.    --
   136.    -- 48-bit integer and fractional ALU operations
   137.    --
   138. --
   139. --
   140.
   141.    function "+" (L, R : KDF9.pair)
   142.    return KDF9.pair
   143.       with Inline;
   144.
   145.    function "-" (J : KDF9.pair)
   146.    return KDF9.pair
   147.       with Inline;
   148.
   149.    function "-" (L, R : KDF9.pair)
   150.    return KDF9.pair
   151.       with Inline;
   152.
   153.    -- 48 * 48 -> 96-bit, for XD, etc.
   154.
   155.    function "*" (L, R : KDF9.word)
   156.    return KDF9.pair;
   157.
   158.    procedure do_DIVD (
   159.                       L : in KDF9.pair;
   160.                       R : in KDF9.word;
   161.                       Q : out KDF9.word
   162.                      );
   163.
   164.    procedure do_DIVR (
   165.                       L         : in KDF9.pair;
   166.                       R         : in KDF9.word;
   167.                       Quotient,
   168.                       Remainder : out KDF9.word
   169.                      );
   170.
   171.    function shift_logical (P : KDF9.pair; L : CPU.signed_Q_part)
   172.    return KDF9.pair
   173.       with Inline;
   174.
   175.    function shift_arithmetic (P : KDF9.pair; L : CPU.signed_Q_part)
   176.    return KDF9.pair
   177.       with Inline;
   178.
   179.
   180. --
   181. --
   182.    --
   183.    -- 48-bit floating point ALU types and operations
   184.    --
   185. --
   186. --
   187.
   188.    -- This is a substrate for KDF9 floating point, not an Ada f.p. type.
   189.
   190.    type f48 is mod 2**48 with Size => KDF9.word'Size;
   191.
   192.    -- Remove useless substrate modular operations not, and, or, xor and mod.
   193.
   194.    overriding
   195.    function "not" (R : CPU.f48)
   196.    return CPU.f48 is abstract;
   197.
   198.    overriding
   199.    function "and" (L, R : CPU.f48)
   200.    return CPU.f48 is abstract;
   201.
   202.    overriding
   203.    function "or" (L, R : CPU.f48)
   204.    return CPU.f48 is abstract;
   205.
   206.    overriding
   207.    function "xor" (L, R : CPU.f48)
   208.    return CPU.f48 is abstract;
   209.
   210.    overriding
   211.    function "mod" (L, R : CPU.f48)
   212.    return CPU.f48 is abstract;
   213.
   214.    function as_word is new Ada.Unchecked_Conversion (CPU.f48, KDF9.word);
   215.
   216.    function as_f48  is new Ada.Unchecked_Conversion (KDF9.word, CPU.f48);
   217.
   218.    procedure push (F : in CPU.f48);
   219.
   220.    function pop
   221.    return CPU.f48
   222.       with Inline;
   223.
   224.    procedure write_top (F : in CPU.f48)
   225.       with Inline;
   226.
   227.    function read_top
   228.    return CPU.f48
   229.       with Inline;
   230.
   231.     -- Standardize a (possibly) non-normalized floating-point number.
   232.
   233.    function normalized  (R : CPU.f48)
   234.    return CPU.f48;
   235.
   236.    -- Convert a 47-bit fraction to a rounded, standardized 39-bit mantissa,
   237.    --    and adjust its exponent accordingly, setting overflow when necessary.
   238.
   239.    procedure normalize (fraction, exponent : in out KDF9.word)
   240.       with Inline;
   241.
   242.    -- Convert a 39-bit mantissa to a 47-bit fraction, preserving the sign.
   243.
   244.    function fraction_word (mantissa : CPU.f48)
   245.    return KDF9.word
   246.       with Inline;
   247.
   248.    -- The floating-point number with the exponent field set to 0.
   249.
   250.    function masked_mantissa (F : CPU.f48)
   251.    return CPU.f48
   252.       with Inline;
   253.
   254.    -- The algebraic scale-factor, not the hardware exponent, -128 <= scaler < +128.
   255.
   256.    function scaler (F : CPU.f48)
   257.    return KDF9.word
   258.       with Inline;
   259.
   260.     -- Synthesize a normalized floating-point number from its components.
   261.
   262.    function normalized (full_fraction, scaler : KDF9.word)
   263.    return CPU.f48
   264.       with Inline;
   265.
   266.    -- Round a 48-bit floating-point number to 24-bit format.
   267.
   268.    function narrowed (R : CPU.f48)
   269.    return CPU.f48;
   270.
   271.    overriding
   272.    function "-" (R : CPU.f48)
   273.    return CPU.f48;
   274.
   275.    overriding
   276.    function "abs" (R : CPU.f48)
   277.    return CPU.f48;
   278.
   279.    overriding
   280.    function "+" (L, R : CPU.f48)
   281.    return CPU.f48;
   282.
   283.    overriding
   284.    function "-" (L, R : CPU.f48)
   285.    return CPU.f48;
   286.
   287.    overriding
   288.    function "*" (L, R : CPU.f48)
   289.    return CPU.f48;
   290.
   291.    overriding
   292.    function "/" (L, R : CPU.f48)
   293.    return CPU.f48;
   294.
   295.    overriding
   296.    function "<" (L, R : CPU.f48)
   297.    return Boolean;
   298.
   299.    function host_float (X : CPU.f48)
   300.    return Long_Float;
   301.
   302.    exponent_mask : constant KDF9.word := KDF9.word'(2#11_111_111#) * 2**39;
   303.    mantissa_mask : constant KDF9.word := not exponent_mask;
   304.    frac_msb_mask : constant KDF9.word := 2**46;  -- M.S.B. of a 47-bit fraction
   305.    mant_msb_mask : constant KDF9.word := 2**38;  -- M.S.B. of a 39-bit mantissa
   306.    overflow_mask : constant KDF9.word := 2**39;  -- bit set on rounding overflow
   307.
   308.
   309. --
   310. --
   311.    --
   312.    -- 96-bit floating point ALU types and operations
   313.    --
   314. --
   315. --
   316.
   317.    type f96 is
   318.       record
   319.          msw, lsw : CPU.f48;
   320.       end record;
   321.
   322.    function as_pair is new Ada.Unchecked_Conversion (CPU.f96, KDF9.pair);
   323.
   324.    function as_f96  is new Ada.Unchecked_Conversion (KDF9.pair, CPU.f96);
   325.
   326.    procedure push (DF : in CPU.f96)
   327.       with Inline,
   328.            Pre => the_NEST_depth < 15
   329.                or else the_CPU_state = Director_state;
   330.
   331.    function pop
   332.    return CPU.f96
   333.       with Inline;
   334.
   335.    procedure write_top (DF : in CPU.f96)
   336.       with Inline;
   337.
   338.    function read_top
   339.    return CPU.f96
   340.       with Inline;
   341.
   342.    -- The algebraic scale-factor, not the hardware exponent, -128 <= scaler < +128.
   343.
   344.    function scaler (DF : CPU.f96)
   345.    return KDF9.word
   346.       with Inline;
   347.
   348.    -- Round a 96-bit double-precision floating-point number to 48 bit format.
   349.
   350.    function narrowed (DF : CPU.f96)
   351.    return CPU.f48
   352.       with Inline;
   353.
   354.    -- Derive a 96-bit fraction from the double-precision floating-point number,
   355.    --    with the mantissa bits in D9-D47 and D49-D87,
   356.    --       and with D1-D8 copies of the sign, D48 zero, and D87-D95 zero.
   357.
   358.    function fraction_pair (DF : CPU.f96)
   359.    return KDF9.pair
   360.       with Inline;
   361.
   362.    -- Convert 96-bit fraction, and an algebraic scale-factor exponent,
   363.    --    into a 96-bit floating point number, setting overflow when necessary.
   364.
   365.    procedure reconstruct (frac   : in out KDF9.pair;
   366.                           scaler : in KDF9.word);
   367.
   368.    function "-" (R : CPU.f96)
   369.    return CPU.f96;
   370.
   371.    function "+" (L, R : CPU.f96)
   372.    return CPU.f96;
   373.
   374.    function "-" (L, R : CPU.f96)
   375.    return CPU.f96;
   376.
   377.    function "*" (L, R : CPU.f48)
   378.    return CPU.f96;
   379.
   380.    function "/" (L : CPU.f96;
   381.                  R : CPU.f48)
   382.    return CPU.f48;
   383.
   384. ------------------------------------------------------------------------------------------------
   385.
   386. --
   387. --
   388.    --
   389.    -- These are the emulation host's register types and their operations.
   390.    --
   391. --
   392. --
   393.
   394.    type u_64 is mod 2**64 with Size => 64;
   395.
   396.    pragma Provide_Shift_Operators (u_64);
   397.
   398.    function as_word (u : CPU.u_64)
   399.    return KDF9.word
   400.       with Inline;
   401.
   402.    type s_64 is range -2**63 .. +2**63-1 with Size => 64;
   403.
   404.    -- The signed as_word sets the V bit if necessary.
   405.
   406.    function as_word (s : CPU.s_64)
   407.    return KDF9.word
   408.       with Inline;
   409.
   410.    function unsign is new Ada.Unchecked_Conversion(CPU.s_64, CPU.u_64);
   411.
   412.    function resign is new Ada.Unchecked_Conversion(CPU.u_64, CPU.s_64);
   413.
   414. --
   415. --
   416.    --
   417.    -- These are the 48-bit primitive, fixed-direction, shift operations.
   418.    --
   419. --
   420. --
   421.
   422.    function shift_time (amount : Natural)
   423.    return KDF9.us
   424.       with Inline;
   425.
   426.    subtype word_shift_length is Natural range 0..48;
   427.
   428.    function shift_word_left (W : KDF9.word; amount : word_shift_length)
   429.    return KDF9.word
   430.       with Inline;
   431.
   432.    function shift_word_right (W : KDF9.word; amount : word_shift_length)
   433.    return KDF9.word
   434.       with Inline;
   435.
   436.    function rotate_word_left (W : KDF9.word; amount : word_shift_length)
   437.    return KDF9.word
   438.       with Inline;
   439.
   440.    function rotate_word_right (W : KDF9.word; amount : word_shift_length)
   441.    return KDF9.word
   442.       with Inline;
   443.
   444. end KDF9.CPU;

 1055 lines: No errors


Compiling: /home/parallels/emulation/Source/kdf9-phu_store.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- The K5 operation data formats.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Unchecked_Conversion;
    18. --
    19. with KDF9.CPU;
    20.
    21. package body KDF9.PHU_store is
    22.
    23.    function short_PHU (p : KDF9.priority)
    24.    return KDF9.word is
    25.
    26.       use type KDF9.store.group_address;
    27.
    28.       type PHU_as_6_bits is mod 2**6
    29.          with Size => 6;
    30.
    31.       function as_6_bits is new Ada.Unchecked_Conversion(Source => PHU_store.PHU_subset,
    32.                                                          Target => short_PHU.PHU_as_6_bits);
    33.
    34.       the_reason    : PHU_store.blockage_kind;
    35.       the_parameter : KDF9.buffer_number;
    36.
    37.    begin
    38.       if not PHU(p).is_held_up then
    39.          return 0;  -- All fields are non-significant.
    40.       end if;
    41.
    42.       -- PHU(p).is_held_up, so other fields are valid.
    43.       the_reason := PHU(p).blockage.reason;
    44.       if the_reason = buffer_busy then
    45.          the_parameter := PHU(p).blockage.buffer_nr;
    46.       else
    47.          -- This is next to useless, but is what the K5 order actually did.
    48.          the_parameter := KDF9.buffer_number(PHU(p).blockage.group_nr mod 2**4);
    49.       end if;
    50.
    51.       return KDF9.word(as_6_bits((the_parameter, the_reason, True)));
    52.    end short_PHU;
    53.
    54.    function K5_operand
    55.    return KDF9.word
    56.    is (
    57.        KDF9.CPU.shift_word_left(short_PHU(0), 48-06) or
    58.        KDF9.CPU.shift_word_left(short_PHU(1), 48-12) or
    59.        KDF9.CPU.shift_word_left(short_PHU(2), 48-18) or
    60.        KDF9.CPU.shift_word_left(short_PHU(3), 48-24)
    61.       );
    62.
    63. end KDF9.PHU_store;

Compiling: ../Source/kdf9-phu_store.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- The K5 operation data formats.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with System;
    18. --
    19. with KDF9.store;
    20.
    21. package KDF9.PHU_store is
    22.
    23.    -- PHU, the Program Hold-Up register is internal to I/O Control.
    24.    -- It has one element for each of the 4 program priority levels, 0..3.
    25.    -- A subset of its content is exposed to Director by means of the K5 order.
    26.
    27.    type blockage_kind is (buffer_busy, locked_core) with Size => 1;
    28.
    29.    type PHU_reason (reason : PHU_store.blockage_kind := buffer_busy) is
    30.       record
    31.          case reason is
    32.             when buffer_busy =>
    33.                buffer_nr : KDF9.buffer_number;
    34.                by_INTQq  : Boolean;
    35.             when locked_core =>
    36.                group_nr  : KDF9.store.group_address;
    37.          end case;
    38.       end record;
    39.
    40.    type PHU_register (is_held_up : Boolean := False) is
    41.       record
    42.          case is_held_up is
    43.             when False =>
    44.                null;
    45.             when True =>
    46.                blockage : PHU_reason;
    47.          end case;
    48.       end record;
    49.
    50.    idle_PHU : constant PHU_register := (is_held_up => False);
    51.
    52.    PHU : array (KDF9.priority) of PHU_store.PHU_register := (others => idle_PHU);
    53.
    54.    type PHU_subset is
    55.       record
    56.          parameter  : KDF9.buffer_number;
    57.          reason     : PHU_store.blockage_kind;
    58.          is_held_up : Boolean;
    59.       end record
    60.    with Size => 6, Bit_Order => System.Low_Order_First;
    61.
    62.    for  PHU_subset use
    63.       record
    64.          parameter  at 0 range 0 .. 3;
    65.          reason     at 0 range 4 .. 4;
    66.          is_held_up at 0 range 5 .. 5;
    67.       end record;
    68.
    69.    -- A K5_operand is a KDF9 word, D00-D47, with the content:
    70.    --    PHU_subset(0) in D00 .. D05
    71.    --    PHU_subset(1) in D06 .. D11
    72.    --    PHU_subset(2) in D12 .. D17
    73.    --    PHU_subset(3) in D18 .. D23
    74.    --    zeros         in D24 .. D47
    75.
    76.    function K5_operand
    77.    return KDF9.word;
    78.
    79. end KDF9.PHU_store;

 63 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/tracing.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Provide diagnostic trace, breakpoint, and watchpoint support.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with exceptions;
    18. with formatting;
    19. with HCI;
    20. with KDF9.decoding;
    21. with KDF9.store;
    22. with state_display;
    23.
    24. use exceptions;
    25. use formatting;
    26. use HCI;
    27. use KDF9;
    28. use KDF9.decoding;
    29. use KDF9.store;
    30. use state_display;
    31.
    32. package body tracing is
    33.
    34.    procedure clear_the_histogram is
    35.    begin
    36.       the_histogram := (others => 0);
    37.    end clear_the_histogram;
    38.
    39.    procedure clear_the_profile is
    40.    begin
    41.       the_profile := (others => 0);
    42.    end clear_the_profile;
    43.
    44.    procedure set_breakpoints (first, last : in KDF9.code_address) is
    45.    begin
    46.       for p in first .. last loop
    47.          breakpoints(p) := True;
    48.       end loop;
    49.    end set_breakpoints;
    50.
    51.    procedure handle_breakpoint is
    52.    begin
    53.       short_witness;
    54.       interact;
    55.       quit_if_requested;
    56.       change_diagnostic_mode_if_requested;
    57.    end handle_breakpoint;
    58.
    59.    procedure clear_all_watchpoints is
    60.    begin
    61.       fetchpoints := (others => False);
    62.       storepoints := (others => False);
    63.    end clear_all_watchpoints;
    64.
    65.    procedure set_fetch_points (first, last : in KDF9.address) is
    66.    begin
    67.       for p in first .. last loop
    68.          fetchpoints(p) := True;
    69.       end loop;
    70.    end set_fetch_points;
    71.
    72.    procedure set_store_points (first, last : in KDF9.address) is
    73.    begin
    74.       for p in first .. last loop
    75.          storepoints(p) := True;
    76.       end loop;
    77.    end set_store_points;
    78.
    79.    procedure clear_retro_FIFO is
    80.    begin
    81.       retro_FIFO_count := 0; retro_FIFO_index := 0;
    82.    end clear_retro_FIFO;
    83.
    84.    procedure take_note_of (the_IAR   : in KDF9.syllable_address;
    85.                            the_value : in KDF9.word) is
    86.    begin
    87.       if retrospective_tracing_is_enabled             and then
    88.             ICR in low_count .. high_count            and then
    89.                NIA_word_number in low_bound .. high_bound then
    90.          declare
    91.             the_note : constant retro_FIFO_entry
    92.                      := (
    93.                          location   => the_IAR,
    94.                          order      => INS.order,
    95.                          parameter  => the_value,
    96.                          ICR_value  => ICR,
    97.                          CPU_time   => the_CPU_time,
    98.                          nested     => the_NEST_depth,
    99.                          called     => the_SJNS_depth,
   100.                          V          => the_V_bit_is_set,
   101.                          T          => the_T_bit_is_set,
   102.                          D          => the_CPU_state = Director_state,
   103.                          level      => CPL
   104.                         );
   105.          begin
   106.             if retro_FIFO_count = 0 then
   107.                retro_FIFO(0) := the_note;
   108.                retro_FIFO_count := 1;
   109.             else
   110.                retro_FIFO_index := retro_FIFO_index + 1;
   111.                retro_FIFO(retro_FIFO_index) := the_note;
   112.                if retro_FIFO_count < FIFO_size then
   113.                   retro_FIFO_count := retro_FIFO_count + 1;
   114.                end if;
   115.             end if;
   116.          end;
   117.       end if;
   118.    end take_note_of;
   119.
   120.    procedure take_note_of (the_value : in KDF9.word) is
   121.    begin
   122.       take_note_of(CIA, the_value);
   123.    end take_note_of;
   124.
   125.    procedure clear_IOC_FIFO is
   126.    begin
   127.       IOC_FIFO_count := 0; IOC_FIFO_index := 0;
   128.    end clear_IOC_FIFO;
   129.
   130.    procedure register_IO_event (the_note : in IOC_FIFO_entry) is
   131.    begin
   132.       if peripheral_tracing_is_enabled                and then
   133.             ICR in low_count .. high_count            and then
   134.                NIA_word_number in low_bound .. high_bound then
   135.          if IOC_FIFO_count = 0 then
   136.             IOC_FIFO(0) := the_note;
   137.             IOC_FIFO_count := 1;
   138.          else
   139.             IOC_FIFO_index := IOC_FIFO_index + 1;
   140.             IOC_FIFO(IOC_FIFO_index) := the_note;
   141.             if IOC_FIFO_count < FIFO_size then
   142.                IOC_FIFO_count := IOC_FIFO_count + 1;
   143.             end if;
   144.          end if;
   145.       end if;
   146.    end register_IO_event;
   147.
   148.    procedure take_note_of_IO_start (
   149.                                     device_name     : in IOC.device_name;
   150.                                     completion_time : in KDF9.us;
   151.                                     control_word    : in KDF9.Q_register;
   152.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   153.                                    )
   154.    is
   155.       the_note : constant  IOC_FIFO_entry
   156.                :=
   157.                 (
   158.                  kind            => start_transfer,
   159.                  ICR_value       => ICR,
   160.                  order_address   => CIA,
   161.                  decoded_order   => INS,
   162.                  initiation_time => the_clock_time,
   163.                  device_name     => take_note_of_IO_start.device_name,
   164.                  completion_time => take_note_of_IO_start.completion_time,
   165.                  is_for_Director => (the_CPU_state = Director_state),
   166.                  priority_level  => CPL,
   167.                  context         => the_context,
   168.                  control_word    => take_note_of_IO_start.control_word,
   169.                  operation       => take_note_of_IO_start.operation
   170.                 );
   171.    begin
   172.       register_IO_event(the_note);
   173.    end take_note_of_IO_start;
   174.
   175.    procedure take_note_of_IO_finis (
   176.                                     ICR_value       : in KDF9.order_counter;
   177.                                     order_address   : in KDF9.syllable_address;
   178.                                     decoded_order   : in KDF9.decoded_order;
   179.                                     initiation_time : in KDF9.us;
   180.                                     device_name     : in IOC.device_name;
   181.                                     is_for_Director : Boolean;
   182.                                     priority_level  : in KDF9.priority;
   183.                                     completion_time : in KDF9.us;
   184.                                     control_word    : in KDF9.Q_register;
   185.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   186.                                    )
   187.    is
   188.       the_note : constant  IOC_FIFO_entry
   189.                :=
   190.                 (
   191.                  kind            => finis_transfer,
   192.                  ICR_value       => take_note_of_IO_finis.ICR_value,
   193.                  order_address   => take_note_of_IO_finis.order_address,
   194.                  decoded_order   => take_note_of_IO_finis.decoded_order,
   195.                  initiation_time => take_note_of_IO_finis.initiation_time,
   196.                  device_name     => take_note_of_IO_finis.device_name,
   197.                  is_for_Director => take_note_of_IO_finis.is_for_Director,
   198.                  priority_level  => take_note_of_IO_finis.priority_level,
   199.                  context         => the_context,
   200.                  completion_time => take_note_of_IO_finis.completion_time,
   201.                  control_word    => take_note_of_IO_finis.control_word,
   202.                  operation       => take_note_of_IO_finis.operation
   203.                 );
   204.
   205.    begin
   206.       register_IO_event(the_note);
   207.    end take_note_of_IO_finis;
   208.
   209.    procedure take_note_of_store_lockout (device_name : in IOC.device_name) is
   210.       the_note : constant  IOC_FIFO_entry
   211.                :=
   212.                 (
   213.                  kind            => store_lockout,
   214.                  ICR_value       => ICR,
   215.                  order_address   => CIA,
   216.                  decoded_order   => INS,
   217.                  initiation_time => the_clock_time,
   218.                  device_name     => take_note_of_store_lockout.device_name,
   219.                  is_for_Director => False,
   220.                  priority_level  => CPL,
   221.                  context         => the_context,
   222.                  data_address    => the_locked_out_address,
   223.                  operation       => IOC.some_other_operation
   224.                 );
   225.    begin
   226.       register_IO_event(the_note);
   227.    end take_note_of_store_lockout;
   228.
   229.    procedure take_note_of_buffer_lockout (device_name : in IOC.device_name;
   230.                                           operation   : in IOC.transfer_kind := IOC.some_other_operation) is
   231.       the_note : constant  IOC_FIFO_entry
   232.                :=
   233.                 (
   234.                  kind            => buffer_lockout,
   235.                  ICR_value       => ICR,
   236.                  order_address   => CIA,
   237.                  decoded_order   => INS,
   238.                  initiation_time => the_clock_time,
   239.                  device_name     => take_note_of_buffer_lockout.device_name,
   240.                  is_for_Director => False,
   241.                  priority_level  => CPL,
   242.                  context         => the_context,
   243.                  operation       => take_note_of_buffer_lockout.operation
   244.                 );
   245.    begin
   246.       register_IO_event(the_note);
   247.    end take_note_of_buffer_lockout;
   248.
   249.    procedure take_note_of_test (
   250.                                 device_name : in IOC.device_name;
   251.                                 Q_register  : in KDF9.Q_register;
   252.                                 status      : in Boolean
   253.                                )
   254.    is
   255.       the_note : constant  IOC_FIFO_entry
   256.                :=
   257.                 (
   258.                  kind            => buffer_status,
   259.                  ICR_value       => ICR+1,  -- ICR is not incremented until the end of an order.
   260.                  order_address   => CIA,
   261.                  decoded_order   => INS,
   262.                  initiation_time => the_clock_time,
   263.                  device_name     => take_note_of_test.device_name,
   264.                  is_for_Director => (the_CPU_state = Director_state),
   265.                  priority_level  => CPL,
   266.                  context         => the_context,
   267.                  Q_register      => take_note_of_test.Q_register,
   268.                  status          => take_note_of_test.status,
   269.                  operation       => IOC.some_other_operation
   270.                 );
   271.    begin
   272.       register_IO_event(the_note);
   273.    end take_note_of_test;
   274.
   275.    procedure clear_interrupt_FIFO is
   276.    begin
   277.       interrupt_FIFO_count := 0; interrupt_FIFO_index := 0;
   278.    end clear_interrupt_FIFO;
   279.
   280.    procedure take_note_of_interrupt (interrupt_code : in KDF9.interrupt_number; message : in String)
   281.    is
   282.       length  : constant Natural  := Natural'Min(message'Length, max_interrupt_message_length);
   283.       content : constant String   := message(message'First .. message'First+length-1);
   284.       padding : constant String   := (1 .. max_interrupt_message_length-length => ' ');
   285.    begin
   286.       declare
   287.          the_note : constant interrupt_FIFO_entry
   288.                   :=
   289.                    (
   290.                     interrupt_code => take_note_of_interrupt.interrupt_code,
   291.                     ICR_value      => ICR,
   292.                     order_address  => CIA,
   293.                     busy_time      => the_clock_time,
   294.                     priority_level => CPL,
   295.                     context        => the_context,
   296.                     message        => content & padding
   297.                    );
   298.       begin
   299.          if interrupt_tracing_is_enabled                 and then
   300.                ICR in low_count .. high_count            and then
   301.                   NIA_word_number in low_bound .. high_bound then
   302.             if interrupt_FIFO_count = 0 then
   303.                interrupt_FIFO(0) := the_note;
   304.                interrupt_FIFO_count := 1;
   305.             else
   306.                interrupt_FIFO_index := interrupt_FIFO_index + 1;
   307.                interrupt_FIFO(interrupt_FIFO_index) := the_note;
   308.                if interrupt_FIFO_count < FIFO_size then
   309.                   interrupt_FIFO_count := interrupt_FIFO_count + 1;
   310.                end if;
   311.             end if;
   312.          end if;
   313.       end;
   314.    end take_note_of_interrupt;
   315.
   316.    procedure add_INS_to_the_histogram is
   317.       syllable_0 : KDF9.syllable := INS.order.syllable_0;
   318.    begin
   319.       if INS.kind = normal_jump_order then
   320.          syllable_0 := (syllable_0 and 2#1111_0000#) or INS.Qq;
   321.       elsif INS.kind = data_access_order then
   322.          syllable_0 := (syllable_0 and 2#11_000_111#);
   323.       end if;
   324.       the_histogram(syllable_0) := the_histogram(syllable_0) + 1;
   325.    end add_INS_to_the_histogram;
   326.
   327.    procedure add_CIA_to_the_profile is
   328.    begin
   329.       the_profile(CIA.code_address) := the_profile(CIA.code_address) + 1;
   330.    end add_CIA_to_the_profile;
   331.
   332.    procedure preview_a_one_syllable_order is null;
   333.
   334.    procedure preview_a_two_syllable_order is
   335.    begin
   336.       case INS.compressed_opcode is
   337.          when TO_MkMq
   338.             | TO_MkMqQ
   339.             | TO_MkMqH
   340.             | TO_MkMqQH
   341.             | TO_MkMqN
   342.             | TO_MkMqQN
   343.             | TO_MkMqHN
   344.             | TO_MkMqQHN =>
   345.             the_trace_operand := read_top;
   346.          when others =>
   347.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   348.       end case;
   349.    end preview_a_two_syllable_order;
   350.
   351.    procedure preview_a_jump_order is
   352.    begin
   353.       case INS.compressed_opcode is
   354.          when JrEQ
   355.             | JrNE
   356.             | JrGTZ
   357.             | JrLTZ
   358.             | JrEQZ
   359.             | JrLEZ
   360.             | JrGEZ
   361.             | JrNEZ
   362.             | OS_OUT =>
   363.             if the_NEST_depth > 0 then
   364.                the_trace_operand := read_top;
   365.             end if;
   366.          when JrEN
   367.             | JrNEN =>
   368.             the_trace_operand := KDF9.word(the_NEST_depth);
   369.          when JrEJ
   370.             | JrNEJ =>
   371.             the_trace_operand := KDF9.word(the_SJNS_depth);
   372.          when EXIT_n
   373.             | EXITD =>
   374.             if the_SJNS_depth > 0 then
   375.                the_trace_operand := as_word(SJNS_top);
   376.             else
   377.                the_trace_operand := -1;
   378.             end if;
   379.          when JrCqZ
   380.             | JrCqNZ =>
   381.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   382.          when JrV
   383.             | JrNV =>
   384.             the_trace_operand := (if the_V_bit_is_set then 1 else 0);
   385.          when JrTR
   386.             | JrNTR =>
   387.             the_trace_operand := (if the_T_bit_is_set then 1 else 0);
   388.          when others =>
   389.             null;
   390.       end case;
   391.    end preview_a_jump_order;
   392.
   393.    procedure preview_a_data_access_order is
   394.    begin
   395.       case INS.compressed_opcode is
   396.          when TO_EaMq
   397.             | TO_EaMqQ =>
   398.             the_trace_operand := read_top;
   399.          when others =>
   400.             null;
   401.       end case;
   402.    end preview_a_data_access_order;
   403.
   404.    procedure look_back_at_a_one_syllable_order is
   405.       AB : KDF9.pair;
   406.    begin
   407.       case INS.compressed_opcode is
   408.          when XDF
   409.             | XPLUSF
   410.             | MINUSDF
   411.             | PLUSDF
   412.             | FLOATD
   413.             | NEGDF
   414.             | MAXF
   415.             | PERM
   416.             | CAB
   417.             | MAX
   418.             | XD
   419.             | NEGD
   420.             | DUPD
   421.             | DIVI
   422.             | STR
   423.             | REVD
   424.             | MINUSD
   425.             | PLUSD
   426.             | DIVR =>
   427.             AB := read_top;
   428.             the_trace_operand := AB.msw;
   429.          when others =>
   430.             if the_NEST_depth > 0 then
   431.                the_trace_operand := read_top;
   432.             end if;
   433.       end case;
   434.    end look_back_at_a_one_syllable_order;
   435.
   436.    procedure look_back_at_an_IO_order is null;
   437.
   438.    procedure look_back_at_a_two_syllable_order is
   439.       AB : KDF9.pair;
   440.    begin
   441.       case INS.compressed_opcode is
   442.          when MkMq
   443.             | MkMqQ
   444.             | MkMqH
   445.             | MkMqQH
   446.             | MkMqQN
   447.             | MkMqHN
   448.             | MkMqQHN
   449.             | QCIMq
   450.             | SHA
   451.             | SHL
   452.             | SHC
   453.             | TO_Kq
   454.             | Kk
   455.             | LINK =>
   456.             the_trace_operand := read_top;
   457.          when TO_MkMq
   458.             | TO_MkMqQ
   459.             | TO_MkMqH
   460.             | TO_MkMqQH
   461.             | TO_MkMqN
   462.             | TO_MkMqQN
   463.             | TO_MkMqHN
   464.             | TO_MkMqQHN =>
   465.             null;
   466.          when M_PLUS_Iq
   467.             | M_MINUS_Iq
   468.             | NCq
   469.             | DCq
   470.             | POS1_TO_Iq
   471.             | NEG1_TO_Iq
   472.             | POS2_TO_Iq
   473.             | NEG2_TO_Iq
   474.             | TO_RCIMq
   475.             | ADD_TO_QCIMq
   476.             | JCqNZS =>
   477.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   478.          when CqTOQk
   479.             | IqTOQk
   480.             | MqTOQk
   481.             | QqTOQk
   482.             | CIqTOQk
   483.             | IMqTOQk
   484.             | CMqTOQk =>
   485.             the_trace_operand := as_word(the_Q_store(INS.Qk));
   486.          when SHLD
   487.             | SHAD
   488.             | MACC =>
   489.             AB := read_top;
   490.             the_trace_operand := AB.msw;
   491.          when TO_LINK =>
   492.             the_trace_operand := as_word(SJNS_top);
   493.          when others =>
   494.             look_back_at_an_IO_order;
   495.       end case;
   496.    end look_back_at_a_two_syllable_order;
   497.
   498.    procedure look_back_at_a_jump_order is
   499.       BA_image  : constant String := "BA #" & oct_of(BA);
   500.       NOL_image : constant String := "NOL"  & NOL'Image;
   501.    begin
   502.       case INS.compressed_opcode is
   503.          when Jr =>
   504.             the_trace_operand := as_word(SJNS_link(NIA));
   505.          when JSr =>
   506.             the_trace_operand := as_word(SJNS_top);
   507.          when EXITD =>
   508.             take_note_of_interrupt(EXITD_flag, BA_image & " " & NOL_image & " @ " & oct_of(NIA));
   509.          when others =>
   510.             null;
   511.       end case;
   512.    end look_back_at_a_jump_order;
   513.
   514.    procedure look_back_at_a_data_access_order is
   515.    begin
   516.       case INS.compressed_opcode is
   517.          when EaMq
   518.             | EaMqQ
   519.             | SET =>
   520.             the_trace_operand := read_top;
   521.          when others =>
   522.             null;
   523.       end case;
   524.    end look_back_at_a_data_access_order;
   525.
   526.    procedure act_on_any_fetchpoint is
   527.       use type watch_flags.set;
   528.    begin
   529.       if fetchpoints/the_trace_address then
   530.          log_new_line;
   531.          log("Fetch watchhpoint: N1 := [#" & oct_of(the_trace_address) & "]");
   532.          short_witness;
   533.          interact;
   534.          quit_if_requested;
   535.          change_diagnostic_mode_if_requested;
   536.       end if;
   537.    end act_on_any_fetchpoint;
   538.
   539.    procedure act_on_any_storepoint is
   540.       use type watch_flags.set;
   541.    begin
   542.       if storepoints/the_trace_address then
   543.          log_new_line;
   544.          log(
   545.              "Store watchpoint: #"
   546.            & oct_of(the_trace_address)
   547.            & " := [N1] = #"
   548.            & oct_of(the_trace_operand)
   549.             );
   550.          short_witness;
   551.          interact;
   552.          quit_if_requested;
   553.          change_diagnostic_mode_if_requested;
   554.       end if;
   555.    end act_on_any_storepoint;
   556.
   557.    procedure act_on_any_two_syllable_order_watchpoints is
   558.    begin
   559.       case INS.compressed_opcode is
   560.          when MkMq
   561.             | MkMqQ
   562.             | MkMqH
   563.             | MkMqQH
   564.             | MkMqQN
   565.             | MkMqHN
   566.             | MkMqQHN =>
   567.             act_on_any_fetchpoint;
   568.          when TO_MkMq
   569.             | TO_MkMqQ
   570.             | TO_MkMqH
   571.             | TO_MkMqQH
   572.             | TO_MkMqN
   573.             | TO_MkMqQN
   574.             | TO_MkMqHN
   575.             | TO_MkMqQHN =>
   576.             act_on_any_storepoint;
   577.          when others =>
   578.             null;
   579.       end case;
   580.    end act_on_any_two_syllable_order_watchpoints;
   581.
   582.    procedure act_on_any_data_access_order_watchpoints is
   583.    begin
   584.       case INS.compressed_opcode is
   585.          when EaMq
   586.             | EaMqQ =>
   587.             act_on_any_fetchpoint;
   588.          when TO_EaMq
   589.             | TO_EaMqQ =>
   590.             act_on_any_storepoint;
   591.          when others =>
   592.             null;
   593.       end case;
   594.    end act_on_any_data_access_order_watchpoints;
   595.
   596. end tracing;

Compiling: ../Source/tracing.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Provide diagnostic trace, breakpoint, and watchpoint support.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with generic_sets;
    18. with IOC;
    19. with KDF9;
    20. with settings;
    21.
    22. use  settings;
    23.
    24. package tracing is
    25.
    26.    -- Support for significant-operand evaluation and tracing.
    27.
    28.    the_trace_operand : KDF9.word;
    29.    the_trace_address : KDF9.address;
    30.
    31.    procedure preview_a_one_syllable_order;
    32.
    33.    procedure preview_a_two_syllable_order;
    34.
    35.    procedure preview_a_jump_order;
    36.
    37.    procedure preview_a_data_access_order;
    38.
    39.    procedure look_back_at_a_one_syllable_order;
    40.
    41.    procedure look_back_at_a_two_syllable_order;
    42.
    43.    procedure look_back_at_a_jump_order
    44.       with Inline => False;
    45.
    46.    procedure look_back_at_a_data_access_order;
    47.
    48.    -- Support for breakpoints.
    49.
    50.    package order_flags is new generic_sets(member => KDF9.code_address);
    51.
    52.    breakpoints : order_flags.set := order_flags.empty_set;
    53.
    54.    procedure set_breakpoints (first, last : in KDF9.code_address);
    55.
    56.    procedure handle_breakpoint;
    57.
    58.    -- Support for watchpoints.
    59.
    60.    package watch_flags is new generic_sets(member => KDF9.address);
    61.
    62.    fetchpoints : watch_flags.set := watch_flags.empty_set;
    63.    storepoints : watch_flags.set := watch_flags.empty_set;
    64.
    65.    procedure clear_all_watchpoints;
    66.
    67.    procedure set_fetch_points (first, last : in KDF9.address);
    68.
    69.    procedure set_store_points (first, last : in KDF9.address);
    70.
    71.    procedure act_on_any_two_syllable_order_watchpoints
    72.       with Inline => False;
    73.
    74.    procedure act_on_any_data_access_order_watchpoints
    75.       with Inline => False;
    76.
    77.
    78.    --
    79.    -- Retrospective tracing.
    80.    --
    81.
    82.    FIFO_size : constant := 256;
    83.
    84.    type FIFO_index is mod FIFO_size;
    85.
    86.    -- Support for all-instruction retrospective tracing.
    87.
    88.    type retro_FIFO_entry is
    89.       record
    90.          location  : KDF9.syllable_address;
    91.          order     : KDF9.syllable_group;
    92.          parameter : KDF9.word;
    93.          ICR_value : KDF9.order_counter;
    94.          CPU_time  : KDF9.us;
    95.          nested    : KDF9.NEST_depth;
    96.          called    : KDF9.SJNS_depth;
    97.          V, T, D   : Boolean;
    98.          level     : KDF9.priority;
    99.       end record;
   100.
   101.    retro_FIFO  : array (tracing.FIFO_index) of tracing.retro_FIFO_entry;
   102.
   103.    retro_FIFO_index : tracing.FIFO_index := 0;
   104.
   105.    retro_FIFO_count : Natural range 0 .. FIFO_size := 0;
   106.
   107.    procedure clear_retro_FIFO;
   108.
   109.    procedure take_note_of (the_value : in KDF9.word);
   110.
   111.    -- Support for retrospective peripheral I/O tracing.
   112.
   113.    type IOC_event_kind is (start_transfer,
   114.                            finis_transfer,
   115.                            buffer_lockout,
   116.                            store_lockout,
   117.                            buffer_status);
   118.
   119.
   120.    type IOC_FIFO_entry (kind : IOC_event_kind := start_transfer) is
   121.       record
   122.          ICR_value       : KDF9.order_counter;
   123.          order_address   : KDF9.syllable_address;
   124.          decoded_order   : KDF9.decoded_order;
   125.          initiation_time : KDF9.us;
   126.          device_name     : IOC.device_name;
   127.          is_for_Director : Boolean;
   128.          priority_level  : KDF9.priority;
   129.          context         : KDF9.context;
   130.          operation       : IOC.transfer_kind := IOC.some_other_operation;
   131.          case kind is
   132.             when start_transfer | finis_transfer =>
   133.                completion_time : KDF9.us;
   134.                control_word    : KDF9.Q_register;
   135.             when store_lockout =>
   136.                data_address : KDF9.Q_part;
   137.             when buffer_lockout =>
   138.                null;
   139.             when buffer_status =>
   140.                Q_register : KDF9.Q_register;
   141.                status     : Boolean;
   142.          end case;
   143.       end record;
   144.
   145.    IOC_FIFO  : array (tracing.FIFO_index) of tracing.IOC_FIFO_entry;
   146.
   147.    IOC_FIFO_index : tracing.FIFO_index := 0;
   148.
   149.    IOC_FIFO_count : Natural range 0 .. FIFO_size := 0;
   150.
   151.    procedure clear_IOC_FIFO;
   152.
   153.    procedure take_note_of_IO_start (
   154.                                     device_name     : in IOC.device_name;
   155.                                     completion_time : in KDF9.us;
   156.                                     control_word    : in KDF9.Q_register;
   157.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   158.                                    );
   159.
   160.    procedure take_note_of_IO_finis (
   161.                                     ICR_value       : in KDF9.order_counter;
   162.                                     order_address   : in KDF9.syllable_address;
   163.                                     decoded_order   : in KDF9.decoded_order;
   164.                                     initiation_time : in KDF9.us;
   165.                                     device_name     : in IOC.device_name;
   166.                                     is_for_Director : Boolean;
   167.                                     priority_level  : in KDF9.priority;
   168.                                     completion_time : in KDF9.us;
   169.                                     control_word    : in KDF9.Q_register;
   170.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   171.                                    );
   172.
   173.    procedure take_note_of_store_lockout  (device_name : in IOC.device_name);
   174.
   175.    procedure take_note_of_buffer_lockout (device_name : in IOC.device_name;
   176.                                           operation   : in IOC.transfer_kind := IOC.some_other_operation);
   177.
   178.    procedure take_note_of_test (
   179.                                 device_name : in IOC.device_name;
   180.                                 Q_register  : in KDF9.Q_register;
   181.                                 status      : in Boolean
   182.                                 );
   183.
   184.
   185.    -- Support for retrospective interrupt-request tracing.
   186.
   187.    max_interrupt_message_length : constant := 100;
   188.    type interrupt_FIFO_entry is
   189.       record
   190.          interrupt_code : KDF9.interrupt_number;
   191.          ICR_value      : KDF9.order_counter;
   192.          order_address  : KDF9.syllable_address;
   193.          busy_time      : KDF9.us;
   194.          priority_level : KDF9.priority;
   195.          context        : KDF9.context;
   196.          message        : String (1..max_interrupt_message_length);
   197.       end record;
   198.
   199.    interrupt_FIFO  : array (tracing.FIFO_index) of tracing.interrupt_FIFO_entry;
   200.
   201.    interrupt_FIFO_index : tracing.FIFO_index := 0;
   202.
   203.    interrupt_FIFO_count : Natural range 0 .. FIFO_size := 0;
   204.
   205.    procedure clear_interrupt_FIFO;
   206.
   207.    procedure take_note_of_interrupt (interrupt_code : in KDF9.interrupt_number; message : in String)
   208.       with Inline => False;
   209.
   210.
   211.    -- Support for the instruction-type and instruction-word frequency histograms.
   212.
   213.    the_histogram : array (KDF9.syllable) of KDF9.order_counter;
   214.
   215.    procedure clear_the_histogram;
   216.
   217.    procedure add_INS_to_the_histogram
   218.       with Inline;
   219.
   220.    the_profile   : array (KDF9.code_address) of KDF9.order_counter;
   221.
   222.    procedure clear_the_profile;
   223.
   224.    procedure add_CIA_to_the_profile
   225.       with Inline;
   226.
   227. end tracing;

 596 lines: No errors


Compiling: /home/parallels/emulation/Source/formatting.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Provide basic data-formatting operations for KDF9 data types.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Handling;
    18. with Ada.Strings;
    19. with Ada.Strings.Fixed;
    20. --
    21. with KDF9_char_sets;
    22. with KDF9.CPU;
    23.
    24. use  Ada.Characters.Handling;
    25. use  Ada.Strings;
    26. use  Ada.Strings.Fixed;
    27. --
    28. use  KDF9_char_sets;
    29. use  KDF9.CPU;
    30.
    31. package body formatting is
    32.
    33.    digit_map : constant array (KDF9.halfword range 0 .. 15) of Character := "0123456789ABCDEF";
    34.
    35.    -- Return N as 3 octal digits.
    36.    function oct_of (N : KDF9.syllable)
    37.    return String
    38.    is (oct_of(KDF9.halfword(N))(6 .. 8));
    39.
    40.    -- Return N as 6 octal digits.
    41.    function oct_of (N : KDF9.field_of_16_bits)
    42.    return String is
    43.       value : KDF9.field_of_16_bits := N;
    44.       oct   : String(1 .. 6);
    45.    begin
    46.       for i in reverse oct'Range loop
    47.          oct(i) := digit_map(KDF9.halfword(value mod 8));
    48.          value := value / 8;
    49.       end loop;
    50.       return oct;
    51.    end oct_of;
    52.
    53.    -- Return N as 1 .. min_digits octal digits, with (partial) zero suppression.
    54.    function oct_of (N : KDF9.Q_part; min_digits : octal_width := 6)
    55.    return String is
    56.       oct : constant String(octal_width) := oct_of(KDF9.field_of_16_bits(N));
    57.    begin
    58.      if N = 0 then return (1..min_digits => '0'); end if;
    59.      for i in 1 .. 6-min_digits loop
    60.         if oct(i) /= '0' then
    61.            return oct(i .. 6);
    62.         end if;
    63.       end loop;
    64.       return oct(7-min_digits .. 6);
    65.    end oct_of;
    66.
    67.    -- Return N as 1 .. 5 decimal digits, with zero suppression and sign when neagtive.
    68.    function signed_dec_of (N : KDF9.Q_part)
    69.    return String is
    70.       dec : constant String := resign(N)'Image;
    71.    begin
    72.       return trimmed(dec);
    73.    end signed_dec_of;
    74.
    75.    -- Return N as decimal digits, with zero suppression.
    76.    function dec_of (N : KDF9.Q_part)
    77.    return String is
    78.       dec : constant String := N'Image;
    79.    begin
    80.       return trimmed(dec);
    81.    end dec_of;
    82.
    83.    -- Return N as up to 5 octal digits.
    84.    function oct_of (N : KDF9.code_address)
    85.    return String is
    86.       value : KDF9.code_address := N;
    87.       j     : Positive := 5;
    88.       oct   : String(1 .. 5);
    89.    begin
    90.       for i in reverse oct'Range loop
    91.          oct(i) := digit_map(KDF9.halfword(value mod 8));
    92.          value := value / 8;
    93.       end loop;
    94.       for i in oct'Range loop
    95.          if oct(i) /= '0' then j := i; exit; end if;
    96.       end loop;
    97.       return oct(j..5);
    98.    end oct_of;
    99.
   100.    -- Return N as decimal digits, with zero suppression.
   101.    function dec_of (N : KDF9.code_address)
   102.    return String
   103.    is (trimmed(N'Image));
   104.
   105.    -- Return N as 8 octal digits.
   106.    function oct_of (N : KDF9.halfword)
   107.    return String is
   108.       value : KDF9.halfword := N;
   109.       oct   : String(1 .. 8);
   110.    begin
   111.       for i in reverse oct'Range loop
   112.          oct(i) := digit_map(value mod 8);
   113.          value := value / 8;
   114.       end loop;
   115.       return oct;
   116.    end oct_of;
   117.
   118.    -- Return N as #wwwww/s, where w and s are octal digits.
   119.    function oct_of (N : KDF9.SJNS_link)
   120.    return String
   121.    is (
   122.        "#"
   123.       &  oct_of(N.code_address)
   124.       & '/'
   125.       & digit_map(KDF9.halfword(N.syllable_index))
   126.       );
   127.
   128.    -- Return N as #wwwww/s, where w and s are octal digits.
   129.    function oct_of (N : KDF9.syllable_address)
   130.    return String
   131.    is (oct_of(KDF9.SJNS_link(N)));
   132.
   133.    -- Return N as dddd/d, where d is a decimal digit.
   134.    function dec_of (N : KDF9.syllable_address)
   135.    return String
   136.    is (
   137.        trimmed(N.code_address'Image)
   138.             & '/'
   139.             & digit_map(KDF9.halfword(N.syllable_index))
   140.       );
   141.
   142.    -- Return N as #wwwww/s, where w and s are octal digits;
   143.    --    or as dddd/s, where d is a decimal digit, according to octal_option.
   144.    function oct_or_dec_of (N : KDF9.syllable_address; octal_option : Boolean)
   145.    return String
   146.    is (if octal_option then oct_of(N) else dec_of(N));
   147.
   148.    -- Return N as 16 octal digits
   149.    function oct_of (N : KDF9.word)
   150.    return String is
   151.       value : KDF9.word := N;
   152.       oct   : String(1 .. 16);
   153.    begin
   154.       for i in reverse oct'Range loop
   155.          oct(i) := digit_map(KDF9.halfword(value mod 8));
   156.          value := value / 8;
   157.       end loop;
   158.       return oct;
   159.    end oct_of;
   160.
   161.    -- Return "L', R'", or "L'"if R' is empty; ' indicates removal of trailing blanks.
   162.    function "-" (L, R : String)
   163.    return String is
   164.       trim_R : constant String := trim(R, right);
   165.    begin
   166.       if trim_R /= "" then
   167.          return trim(L, right) & ", " & trim_R;
   168.       else
   169.          return trim(L, right);
   170.       end if;
   171.    end "-";
   172.
   173.    -- Return S with all leading an trailing blanks removed.
   174.    function trimmed (S : String)
   175.    return String
   176.    is (Trim(S, Ada.Strings.Both));
   177.
   178.    -- Return trimmed(S), right-just_right in a field of width at least W.
   179.    function just_right (S : String; W : Positive := 3)
   180.    return String is
   181.      image   : constant String   := Trim(S, Ada.Strings.Both);
   182.      columns : constant Positive := Positive'Max(W, image'Length);
   183.    begin
   184.      return Ada.Strings.Fixed.Tail(image, columns, ' ');
   185.    end just_right;
   186.
   187.    -- Return trimmed(S), left-justified in a field of width at least W.
   188.    function just_left (S : String; W : Positive := 3)
   189.    return String is
   190.      image   : constant String   := Trim(S, Ada.Strings.Both);
   191.      columns : constant Positive := Positive'Max(W, image'Length);
   192.    begin
   193.      return Ada.Strings.Fixed.Head(image, columns, ' ');
   194.    end just_left;
   195.
   196.    function plurality (count : KDF9.word; for_1 : String := ""; for_more : String := "s")
   197.    return String
   198.    is (if count /= 1 then for_more else for_1);
   199.
   200.    -- Return C converted to a 1-character string.
   201.    function "+" (C : Character)
   202.    return unit_string
   203.    is ((1 => C));
   204.
   205.    -- Return C with all Latin-1 lower-case letters converted to upper-case.
   206.    function to_upper (C : Character)
   207.    return Character
   208.    renames Ada.Characters.Handling.to_upper;
   209.
   210.    -- Return S with all Latin-1 lower-case letters converted to upper-case.
   211.    function to_upper (S : String)
   212.    return String
   213.    renames Ada.Characters.Handling.to_upper;
   214.
   215.    -- Return C with all Latin-1 upper-case letters converted to lower-case.
   216.    function to_lower (C : Character)
   217.    return Character
   218.    renames Ada.Characters.Handling.to_lower;
   219.
   220.    -- Return S with all Latin-1 upper-case letters converted to lower-case.
   221.    function to_lower (S : String)
   222.    return String
   223.    renames Ada.Characters.Handling.to_lower;
   224.
   225.    -- Return the 8-character Latin-1 string representing the 8 Case Normal characters in N.
   226.    function to_string (N : KDF9.word)
   227.    return word_as_byte_string is
   228.       word   : KDF9.word := N;
   229.       result : word_as_byte_string;
   230.    begin
   231.       for i in reverse 1 .. 8 loop
   232.          result(i) := KDF9_char_sets.TP_CN(KDF9_char_sets.symbol(word and 8#77#));
   233.          word := word / 64;
   234.       end loop;
   235.       return result;
   236.    end to_string;
   237.
   238.    -- Return the result of applying to_string to each word of a double-word.
   239.    function to_string (P : KDF9.pair)
   240.    return pair_as_byte_string is
   241.       result : pair_as_byte_string;
   242.    begin
   243.       result(1 ..  8) := to_string(P.msw);
   244.       result(9 .. 16) := to_string(P.lsw);
   245.       return result;
   246.    end to_string;
   247.
   248.    -- Like to_string, but with glyphs for format effectors.
   249.    function glyphs_for (N : KDF9.word)
   250.    return word_as_byte_string is
   251.       word   : KDF9.word := N;
   252.       glyphs : word_as_byte_string;
   253.    begin
   254.       for i in reverse 1..8 loop
   255.          glyphs(i) := glyph_for(to_CP(KDF9_char_sets.symbol(word and 8#77#)));
   256.          word := word / 64;
   257.       end loop;
   258.       return glyphs;
   259.    end glyphs_for;
   260.
   261.    function glyphs_for (S : String)
   262.    return String is
   263.       T : String (S'First..S'Last);
   264.    begin
   265.       for i in T'Range loop
   266.          T(i) := glyph_for(S(i));
   267.       end loop;
   268.       return T;
   269.    end glyphs_for;
   270.
   271. end formatting;

Compiling: ../Source/formatting.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Provide basic data-formatting operations for KDF9 data types.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18.
    19. use  KDF9;
    20.
    21. package formatting is
    22.
    23.    subtype unit_string         is String(1 .. 1);
    24.    subtype word_as_byte_string is String(1 .. 8);
    25.    subtype pair_as_byte_string is String(1 .. 16);
    26.
    27.    -- Return N as 3 octal digits.
    28.    function oct_of (N : KDF9.syllable)
    29.    return String;
    30.
    31.    -- Return N as 6 octal digits.
    32.    function oct_of (N : KDF9.field_of_16_bits)
    33.    return String;
    34.
    35.    subtype octal_width is Positive range 1 .. 6;
    36.
    37.    -- Return N as octal digits, with (partial) zero suppression.
    38.    -- The first (6-min_digits) are elided if '0'; all remaining digits are returned.
    39.    -- Up to 6 digits can be returned if the result is longer than min_digits.
    40.    -- If N is 0, the String (1..min_digits => '0') is returned.
    41.    function oct_of (N : KDF9.Q_part; min_digits : octal_width := 6)
    42.    return String;
    43.
    44.    -- Return N as 1 .. 5 decimal digits, with zero suppression and sign when neagtive.
    45.    function signed_dec_of (N : KDF9.Q_part)
    46.    return String;
    47.
    48.    -- Return N as 1 .. 6 decimal digits, with zero suppression.
    49.    function dec_of (N : KDF9.Q_part)
    50.    return String;
    51.
    52.    -- Return N as up to 5 octal digits.
    53.    function oct_of (N : KDF9.code_address)
    54.    return String;
    55.
    56.    -- Return N as decimal digits, with zero suppression.
    57.    function dec_of (N : KDF9.code_address)
    58.    return String ;
    59.
    60.    -- Return N as 8 octal digits.
    61.    function oct_of (N : KDF9.halfword)
    62.    return String;
    63.
    64.    -- Return N as #wwwww/s, where w and s are octal digits.
    65.    function oct_of (N : KDF9.SJNS_link)
    66.    return String;
    67.
    68.    -- Return N as #wwwww/s, where w and s are octal digits.
    69.    function oct_of (N : KDF9.syllable_address)
    70.    return String;
    71.
    72.    -- Return N as dddd/d, where d is a decimal digit.
    73.    function dec_of (N : KDF9.syllable_address)
    74.    return String;
    75.
    76.    -- Return N as #wwwww/s, where w and s are octal digits;
    77.    --    or as dddd/s, where d is a decimal digit, according to octal_option.
    78.    function oct_or_dec_of (N : KDF9.syllable_address; octal_option : Boolean)
    79.    return String;
    80.
    81.    -- Return N as 16 octal digits.
    82.    function oct_of (N : KDF9.word)
    83.    return String;
    84.
    85.    -- Return "L', R'", or "L'"if R' is empty; ' indicates removal of trailing blanks.
    86.    function "-" (L, R : String)
    87.    return String;
    88.
    89.    -- Return S with all leading and trailing blanks removed.
    90.    function trimmed (S : String)
    91.    return String;
    92.
    93.    -- Return trimmed(S), right-justified in a field of width at least W.
    94.    function just_right (S : String; W : Positive := 3)
    95.    return String;
    96.
    97.    -- Return trimmed(S), left-justified in a field of width at least W.
    98.    function just_left (S : String; W : Positive := 3)
    99.    return String;
   100.
   101.    -- Return the (pluralizing) suffix if count /= 1.
   102.    function plurality (count : KDF9.word; for_1 : String := ""; for_more : String := "s")
   103.    return String;
   104.
   105.    -- Return C converted to a 1-character string.
   106.    function "+" (C : Character)
   107.    return unit_string;
   108.
   109.    -- Return C with all Latin-1 lower-case letters converted to upper-case.
   110.    function to_upper (C : Character)
   111.    return Character;
   112.
   113.    -- Return S with all Latin-1 lower-case letters converted to upper-case.
   114.    function to_upper (S : String)
   115.    return String;
   116.
   117.    -- Return C with all Latin-1 upper-case letters converted to lower-case.
   118.    function to_lower (C : Character)
   119.    return Character;
   120.
   121.    -- Return S with all Latin-1 upper-case letters converted to lower-case.
   122.    function to_lower (S : String)
   123.    return String;
   124.
   125.    -- Return the 8-character Latin-1 string representing the 8 Case Normal characters in N.
   126.    function to_string (N : KDF9.word)
   127.    return word_as_byte_string;
   128.
   129.    -- Return the result of applying to_string to each word of a double-word.
   130.    function to_string (P : KDF9.pair)
   131.    return pair_as_byte_string;
   132.
   133.    -- Like to_string, but with glyphs for format effectors.
   134.    function glyphs_for (N : KDF9.word)
   135.    return word_as_byte_string;
   136.
   137.    function glyphs_for (S : String)
   138.    return String;
   139.
   140. end formatting;

 271 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/host_io.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Buffered I/O streams to support KDF9 device I/O.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Latin_1;
    18. --
    19. with OS_specifics;
    20.
    21. use  Ada.Characters.Latin_1;
    22. --
    23. use  OS_specifics;
    24.
    25. package body host_IO is
    26.
    27.    function fd_of (the_stream : host_IO.stream)
    28.    return Natural
    29.    is (the_stream.fd);
    30.
    31.    procedure open (the_stream : in out host_IO.stream;
    32.                    file_name  : in String;
    33.                    mode       : in POSIX.access_mode;
    34.                    fd         : in Integer) is
    35.    begin
    36.       if fd >= 0 then
    37.          make_transparent(fd);
    38.          the_stream.base_name := file_name(file_name'First .. file_name'First+2);
    39.          the_stream.IO_mode := mode;
    40.          the_stream.last_IO := read_mode;
    41.          the_stream.fd := fd;
    42.          the_stream.is_open := True;
    43.       else
    44.          the_stream.is_open := False;
    45.       end if;
    46.    end open;
    47.
    48.    procedure open (the_stream : in out host_IO.stream;
    49.                    file_name  : in String;
    50.                    mode       : in POSIX.access_mode) is
    51.       fd : Integer;
    52.    begin -- open
    53.       fd := POSIX.open(file_name, mode);
    54.       open(the_stream, file_name, mode, fd);
    55.    exception
    56.       when POSIX_IO_error =>
    57.          trap_operator_error("«" & file_name & "» cannot be opened");
    58.    end open;
    59.
    60.    procedure truncate (the_stream : in out host_IO.stream) is
    61.    begin
    62.       truncate(the_stream.fd);
    63.    end truncate;
    64.
    65.    procedure close (the_stream : in out host_IO.stream) is
    66.       response : Integer;
    67.    begin
    68.       if the_stream.is_open then
    69.          flush(the_stream);
    70.          response := close(the_stream.fd);
    71.          pragma Unreferenced(response);
    72.          the_stream.is_open := False;
    73.       end if;
    74.    end close;
    75.
    76.    procedure flush (the_stream  : in out host_IO.stream;
    77.                     a_byte_time : in KDF9.us := 0) is
    78.       response : Integer with Unreferenced;
    79.    begin
    80.       if the_stream.is_open      and then
    81.             the_stream.next_byte > 0 then
    82.          if the_stream.IO_mode > read_mode and the_stream.last_IO = write_mode then
    83.             if a_byte_time = 0 then
    84.                response := write(the_stream.fd, the_stream.buffer, the_stream.next_byte);
    85.             else
    86.                for p in 1 .. the_stream.next_byte loop
    87.                   response := write(the_stream.fd, the_stream.buffer(p..p), 1);
    88.                   KDF9.delay_by(a_byte_time);
    89.                end loop;
    90.             end if;
    91.          end if;
    92.          the_stream.next_byte := 0;
    93.          the_stream.block_size := 0;
    94.       end if;
    95.    end flush;
    96.
    97.    function a_LF_was_just_read (the_stream : host_IO.stream)
    98.    return Boolean
    99.    is (
   100.        the_stream.is_open                   and then
   101.           the_stream.bytes_moved > 0        and then
   102.              the_stream.last_IO = read_mode and then
   103.                 the_stream.next_byte = 0    and then
   104.                    the_stream.block_size = 0
   105.       );
   106.
   107.    function a_LF_was_just_written (the_stream : host_IO.stream)
   108.    return Boolean
   109.    is (
   110.        the_stream.is_open                    and then
   111.           the_stream.bytes_moved > 0         and then
   112.              the_stream.last_IO /= read_mode and then
   113.                 the_stream.column = 0
   114.       );
   115.
   116.    procedure reattach (the_stream : in out host_IO.stream;
   117.                        file_name  : in String;
   118.                        mode       : in POSIX.access_mode) is
   119.    begin
   120.       close(the_stream);
   121.       open(the_stream, file_name, (if the_stream.IO_mode = rd_wr_mode then rd_wr_mode else mode));
   122.       if the_stream.is_open then
   123.          the_stream.last_char := ' ';
   124.          the_stream.block_size := 0;
   125.          the_stream.next_byte := 0;
   126.          the_stream.position := 0;
   127.       end if;
   128.    end reattach;
   129.
   130.    function is_open (the_stream : host_IO.stream)
   131.    return Boolean
   132.    is (the_stream.is_open);
   133.
   134.    function bytes_moved (the_stream : host_IO.stream)
   135.    return KDF9.word
   136.    is (the_stream.bytes_moved);
   137.
   138.    function column (the_stream : host_IO.stream)
   139.    return Natural
   140.    is (the_stream.column);
   141.
   142.    procedure get_position (position   : out Natural;
   143.                            the_stream : in out host_IO.stream) is
   144.    begin
   145.       flush(the_stream);
   146.       position := the_stream.position;
   147.    end get_position;
   148.
   149.    function buffer_is_empty (the_stream : host_IO.stream)
   150.    return Boolean
   151.    is (not the_stream.is_open or else the_stream.next_byte >= the_stream.block_size);
   152.
   153.    function buffer_is_full (the_stream : host_IO.stream)
   154.    return Boolean
   155.    is (the_stream.is_open and then the_stream.next_byte = the_stream.buffer'Last);
   156.
   157.    procedure set_position (position   : in Natural;
   158.                            the_stream : in out host_IO.stream;
   159.                            whence     : in POSIX.seek_origin := from_start) is
   160.       response : POSIX.file_position with Warnings => Off;
   161.    begin
   162.       flush(the_stream);
   163.       response := seek(the_stream.fd, POSIX.file_position(position), whence);
   164.       the_stream.position := position;
   165.    end set_position;
   166.
   167.    procedure clear (the_stream : in out host_IO.stream) is
   168.    begin
   169.       the_stream.next_byte := 0;
   170.       the_stream.block_size := 0;
   171.    end clear;
   172.
   173.    procedure reset (the_stream : in out host_IO.stream) is
   174.    begin
   175.       flush(the_stream);
   176.       if the_stream.is_open then
   177.          the_stream.last_IO := read_mode;
   178.          the_stream.position := 0;
   179.          the_stream.next_byte := 0;
   180.          the_stream.block_size := 0;
   181.       end if;
   182.    end reset;
   183.
   184.    procedure back_off (the_stream : in out host_IO.stream) is
   185.    begin
   186.       if the_stream.is_open                   and then
   187.             the_stream.next_byte > 0          and then
   188.                the_stream.last_IO = read_mode     then
   189.          the_stream.next_byte := the_stream.next_byte - 1;
   190.          the_stream.position := the_stream.position - 1;
   191.       else
   192.          trap_operator_error(the_stream.base_name & "cannot back_off");
   193.       end if;
   194.    end back_off;
   195.
   196.    procedure get_byte (char       : out Character;
   197.                        the_stream : in out host_IO.stream) is
   198.       response : Integer;
   199.    begin
   200.       if buffer_is_empty(the_stream) then
   201.          response := read(the_stream.fd, the_stream.buffer, the_stream.buffer'Size);
   202.          the_stream.block_size := response;
   203.          the_stream.next_byte := 0;
   204.          if response <= 0 then
   205.             raise end_of_stream;
   206.          end if;
   207.       end if;
   208.       the_stream.next_byte := the_stream.next_byte + 1;
   209.       the_stream.position := the_stream.position + 1;
   210.       the_stream.bytes_moved := the_stream.bytes_moved + 1;
   211.       the_stream.last_IO := read_mode;
   212.       char := the_stream.buffer(the_stream.next_byte);
   213.       if char = LF then
   214.          the_stream.column := 0;
   215.       else
   216.          the_stream.column := the_stream.column + 1;
   217.       end if;
   218.    end get_byte;
   219.
   220.    procedure get_bytes (the_string : out String;
   221.                         the_stream : in out host_IO.stream;
   222.                         uncounted  : in Boolean := True) is
   223.       old_bytes_moved : constant KDF9.word := the_stream.bytes_moved;
   224.    begin
   225.       for b of the_string loop
   226.          get_byte(b, the_stream);
   227.       end loop;
   228.       if uncounted then
   229.          the_stream.bytes_moved := old_bytes_moved;
   230.       end if;
   231.    end get_bytes;
   232.
   233.    procedure get_char (char       : out Character;
   234.                        the_stream : in out host_IO.stream) is
   235.    begin
   236.       get_byte(char, the_stream);
   237.       if char = CR then
   238.          char := LF;
   239.          the_stream.last_char := CR;
   240.       elsif char = LF and the_stream.last_char = CR then
   241.          the_stream.last_char := LF;
   242.          get_byte(char, the_stream);
   243.       else
   244.          the_stream.last_char := char;
   245.       end if;
   246.    end get_char;
   247.
   248.    procedure peek_at_char (char       : out Character;
   249.                            the_stream : in out host_IO.stream) is
   250.    begin
   251.       get_char(char, the_stream);
   252.       back_off(the_stream);
   253.    end peek_at_char;
   254.
   255.    -- put_escape_code writes directly to the stream's device, avoiding the stream's buffers.
   256.    procedure put_escape_code (the_string : in String;
   257.                               the_stream : in out host_IO.stream) is
   258.       response : Integer with Warnings => Off;
   259.    begin
   260.       if not the_stream.is_open then
   261.          raise end_of_stream;
   262.       end if;
   263.       response := write(the_stream.fd,
   264.                         the_string,
   265.                         the_string'Length);
   266.    end put_escape_code;
   267.
   268.    procedure put_byte (char       : in Character;
   269.                        the_stream : in out host_IO.stream) is
   270.       response : Integer with Warnings => Off;
   271.    begin
   272.       if the_stream.buffer_is_full then
   273.          response := write(the_stream.fd,
   274.                            the_stream.buffer,
   275.                            the_stream.buffer'Size);
   276.          the_stream.next_byte := 0;
   277.       end if;
   278.       the_stream.next_byte := the_stream.next_byte + 1;
   279.       the_stream.position := the_stream.position + 1;
   280.       the_stream.bytes_moved := the_stream.bytes_moved + 1;
   281.       the_stream.buffer(the_stream.next_byte) := char;
   282.       the_stream.last_IO := write_mode;
   283.       if char = LF then
   284.          the_stream.column := 0;
   285.       else
   286.          the_stream.column := the_stream.column + 1;
   287.       end if;
   288.    end put_byte;
   289.
   290.    procedure do_not_put_byte (char       : in Character;
   291.                               the_stream : in out host_IO.stream) is
   292.    begin
   293.       the_stream.bytes_moved := the_stream.bytes_moved + 1;
   294.       the_stream.last_IO := write_mode;
   295.       if char = LF then
   296.          the_stream.column := 0;
   297.       else
   298.          the_stream.column := the_stream.column + 1;
   299.       end if;
   300.    end do_not_put_byte;
   301.
   302.    procedure put_bytes (the_string : in String;
   303.                         the_stream : in out host_IO.stream;
   304.                         uncounted  : in Boolean := True) is
   305.       old_bytes_moved : constant KDF9.word := the_stream.bytes_moved;
   306.    begin
   307.       for c of the_string loop
   308.          put_byte(c, the_stream);
   309.       end loop;
   310.       if uncounted then
   311.          the_stream.bytes_moved := old_bytes_moved;
   312.       end if;
   313.    end put_bytes;
   314.
   315.    procedure put_EOL (the_stream : in out host_IO.stream;
   316.                       uncounted  : in Boolean := True) is
   317.    begin
   318.       put_bytes(NL, the_stream, uncounted);
   319.    end put_EOL;
   320.
   321.    procedure put_char (char       : in Character;
   322.                        the_stream : in out host_IO.stream) is
   323.    begin
   324.       if char = LF then
   325.          put_EOL(the_stream, uncounted => False);
   326.       else
   327.          put_byte(char, the_stream);
   328.       end if;
   329.    end put_char;
   330.
   331.    procedure put_chars (the_string : in String;
   332.                         the_stream : in out host_IO.stream) is
   333.    begin
   334.       for c of the_string loop
   335.          put_char(c, the_stream);
   336.       end loop;
   337.    end put_chars;
   338.
   339.    function contents (the_stream : host_IO.stream)
   340.    return String is
   341.    begin
   342.       return the_stream.buffer(1..the_stream.next_byte);
   343.    end contents;
   344.
   345.    procedure inject (the_string : in String;
   346.                      the_stream : in out host_IO.stream) is
   347.       the_length : constant Natural := the_string'Length;
   348.    begin
   349.       if the_length > 0 and the_length < the_stream.buffer'Length then
   350.          the_stream.block_size := the_length + 1;
   351.          the_stream.buffer(1 .. the_length) := the_string;
   352.          the_stream.buffer(the_length + 1)  := LF;
   353.       end if;
   354.    end inject;
   355.
   356. end host_IO;

Compiling: ../Source/host_io.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- Buffered I/O streams to support KDF9 device I/O.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18. with POSIX;
    19.
    20. use  KDF9;
    21. use  POSIX;
    22.
    23. package host_IO is
    24.
    25.    end_of_stream : exception;
    26.
    27.    type stream is tagged limited private;
    28.
    29.    function fd_of (the_stream : host_IO.stream)
    30.    return Natural;
    31.
    32.    -- Open a stream with an established fd.
    33.    procedure open (the_stream : in out host_IO.stream;
    34.                    file_name  : in String;
    35.                    mode       : in POSIX.access_mode;
    36.                    fd         : in Integer);
    37.
    38.    -- Open a base file then use its fd to open a stream.
    39.    procedure open (the_stream : in out host_IO.stream;
    40.                    file_name  : in String;
    41.                    mode       : in POSIX.access_mode)
    42.       with Inline => False;
    43.
    44.    procedure truncate (the_stream : in out host_IO.stream);
    45.
    46.    procedure close (the_stream : in out host_IO.stream);
    47.
    48.    procedure flush (the_stream  : in out host_IO.stream;
    49.                     a_byte_time : in KDF9.us := 0);
    50.
    51.    -- Reassign an open stream to another file.
    52.    procedure reattach (the_stream : in out host_IO.stream;
    53.                        file_name  : in String;
    54.                        mode       : in POSIX.access_mode);
    55.
    56.    function is_open (the_stream : host_IO.stream)
    57.    return Boolean;
    58.
    59.    function bytes_moved (the_stream : host_IO.stream)
    60.    return KDF9.word;
    61.
    62.    function column (the_stream : host_IO.stream)
    63.    return Natural;
    64.
    65.    procedure get_position (position   : out Natural;
    66.                            the_stream : in out host_IO.stream);
    67.
    68.    procedure set_position (position   : in Natural;
    69.                            the_stream : in out host_IO.stream;
    70.                            whence     : in POSIX.seek_origin := from_start);
    71.
    72.    procedure clear (the_stream : in out host_IO.stream);
    73.
    74.    procedure reset (the_stream : in out host_IO.stream);
    75.
    76.    -- Arrange for the last-read byte to be read again.
    77.    procedure back_off (the_stream : in out host_IO.stream)
    78.       with Inline;
    79.
    80.    procedure get_byte (char       : out Character;
    81.                        the_stream : in out host_IO.stream);
    82.
    83.    -- get_bytes iterates get_byte over the_string, for convenience.
    84.    -- If uncounted then the output is not included in the_stream.bytes_moved.
    85.    procedure get_bytes (the_string : out String;
    86.                         the_stream : in out host_IO.stream;
    87.                         uncounted  : in Boolean := True);
    88.
    89.    -- True iff the last get_byte obtained a LF.
    90.    function a_LF_was_just_read (the_stream : host_IO.stream)
    91.    return Boolean;
    92.
    93.    -- get_char differs from get_byte in the treatment of line terminators.
    94.    -- CR, LF, and CRLF are all returned as a single LF character, so catering
    95.    --    for old MacOS, MSDOS, and macOS/UNIX/Linux external text-file formats.
    96.    procedure get_char (char       : out Character;
    97.                        the_stream : in out host_IO.stream);
    98.
    99.    -- peek_at_char uses get_char to inspect the next char to be delivered,
   100.    --    then invokes back_off so that it is left in the input stream.
   101.    procedure peek_at_char (char       : out Character;
   102.                            the_stream : in out host_IO.stream);
   103.
   104.    -- do_not_put_byte does the same as put_byte, except for actually writing it to the_stream.
   105.    procedure do_not_put_byte (char       : in Character;
   106.                               the_stream : in out host_IO.stream);
   107.
   108.    procedure put_byte (char       : in Character;
   109.                        the_stream : in out host_IO.stream);
   110.
   111.    -- put_escape_code writes directly to the stream's device, avoiding the stream's buffers.
   112.    procedure put_escape_code (the_string : in String;
   113.                               the_stream : in out host_IO.stream);
   114.
   115.    -- put_bytes iterates put_byte over the_string, for convenience.
   116.    -- If uncounted then the output is not included in the_stream.bytes_moved.
   117.    procedure put_bytes (the_string : in String;
   118.                         the_stream : in out host_IO.stream;
   119.                         uncounted  : in Boolean := True);
   120.
   121.    -- put_EOL writes the host-appropriate line terminator (CRLF, or just LF)
   122.    procedure put_EOL (the_stream : in out host_IO.stream;
   123.                       uncounted  : in Boolean := True);
   124.
   125.    -- put_char differs from put_byte only in the treatment of line terminators.
   126.    -- If char is LF, then put_EOL is used to output a host-appropriate line terminator.
   127.    procedure put_char (char       : in Character;
   128.                        the_stream : in out host_IO.stream);
   129.
   130.    -- put_chars iterates put_bytes over the_string, for convenience.
   131.    procedure put_chars (the_string : in String;
   132.                         the_stream : in out host_IO.stream);
   133.
   134.    -- True iff the last put_byte wrote out a LF.
   135.    function a_LF_was_just_written (the_stream : host_IO.stream)
   136.    return Boolean;
   137.
   138.    function buffer_is_empty (the_stream : host_IO.stream)
   139.    return Boolean
   140.       with Inline;
   141.
   142.    function buffer_is_full (the_stream : host_IO.stream)
   143.    return Boolean
   144.       with Inline;
   145.
   146.    -- Return the currently buffered output as a single string.
   147.    function contents (the_stream : host_IO.stream)
   148.    return String;
   149.
   150.    -- Make the_string appear to be input for the_stream (which must be empty).
   151.    procedure inject (the_string : in String;
   152.                      the_stream : in out host_IO.stream);
   153.
   154. private
   155.
   156.    -- N.B. in host_IO the term 'buffer' is used conventionally.
   157.    -- It does NOT refer to a KDF9 DMA channel.
   158.
   159.    -- IO_buffer_size is enough for a full LP line, lacking any better criterion.
   160.    IO_buffer_size : constant Positive := 161;
   161.
   162.    type stream is tagged limited
   163.       record
   164.          base_name   : String (1 .. 3) := "???";
   165.          is_open     : Boolean := False;
   166.          last_char   : Character := ' ';
   167.          block_size,
   168.          next_byte,
   169.          saved_size,
   170.          position,
   171.          column      : Natural := 0;
   172.          bytes_moved : KDF9.word := 0;
   173.          fd          : Natural := Natural'Last;
   174.          IO_mode     : POSIX.access_mode range read_mode .. rd_wr_mode;
   175.          last_IO     : POSIX.access_mode range read_mode .. write_mode;
   176.          buffer,
   177.          look_behind : String(1 .. IO_buffer_size);
   178.       end record;
   179.
   180. end host_IO;

 356 lines: No errors


Compiling: /home/parallels/emulation/Source/kdf9-store.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- KDF9 core store operations.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Unchecked_Conversion;
    18. --
    19. with formatting;
    20. with KDF9.CPU;
    21.
    22. use formatting;
    23. use  KDF9.CPU;
    24.
    25. package body KDF9.store is
    26.
    27.    -- diagnose_invalid_address avoids secondary stack usage in the address validation procedures.
    28.    procedure diagnose_invalid_address (message : in String; address : in KDF9.word)
    29.       with Inline => False;
    30.
    31.    procedure diagnose_invalid_address (message : in String; address : in KDF9.word) is
    32.    begin
    33.       trap_illegal_instruction(message & " =" & address'Image);
    34.    end diagnose_invalid_address;
    35.
    36.    -- Check that EA, EA+BA are valid; LIV if invalid.
    37.    procedure validate_virtual_and_real_addresses (EA : in KDF9.Q_part)
    38.       with Inline => True;
    39.
    40.    procedure validate_virtual_and_real_addresses (EA : in KDF9.Q_part) is
    41.       PA : constant KDF9.word := (KDF9.word(EA) + KDF9.word(BA)) and Q_part_mask;
    42.    begin
    43.       if EA > NOL and then the_CPU_state = program_state then
    44.          diagnose_invalid_address("NOL < virtual address", KDF9.word(EA));
    45.       end if;
    46.       if PA > max_address and then the_CPU_state = program_state then
    47.          diagnose_invalid_address("32K-1 < physical address", PA);
    48.       end if;
    49.    end validate_virtual_and_real_addresses;
    50.
    51.    procedure if_user_mode_then_LOV (address_1 : KDF9.Q_part;
    52.                                     address_2 : KDF9.Q_part := 0;
    53.                                     solo      : Boolean     := True) is
    54.    begin
    55.       LOV_if_user_mode(
    56.                        if solo
    57.                        then "at #" & oct_of(address_1) & " (E" & dec_of(address_1) & ")"
    58.                        else "in #" & oct_of(address_1) & "..#" & oct_of(address_2)
    59.                       );
    60.    end if_user_mode_then_LOV;
    61.
    62.    function group (PA : KDF9.Q_part)
    63.    return KDF9.Q_part
    64.    is (PA / group_size);
    65.
    66.    procedure check_address_and_lockout (EA : in KDF9.Q_part) is
    67.       PA : constant KDF9.Q_part := EA + BA;
    68.    begin
    69.       validate_virtual_and_real_addresses(EA);
    70.       if locked_out(group(PA)) then
    71.          the_locked_out_address := PA;
    72.          if the_CPU_state /= Director_state then
    73.             if_user_mode_then_LOV(PA);
    74.          end if;
    75.       end if;
    76.    end check_address_and_lockout;
    77.
    78.    procedure validate_address_range (EA1, EA2 : in KDF9.Q_part) is
    79.    begin
    80.       if EA1 > EA2 then
    81.          diagnose_invalid_address("initial address > final address", KDF9.word(EA2));
    82.       end if;
    83.       validate_virtual_and_real_addresses(EA1);
    84.       validate_virtual_and_real_addresses(EA2);
    85.    end validate_address_range;
    86.
    87.    procedure check_addresses_and_lockouts (EA1, EA2 : in KDF9.Q_part) is
    88.        PA1 : constant KDF9.Q_part := EA1 + BA;
    89.        PA2 : constant KDF9.Q_part := EA2 + BA;
    90.    begin
    91.       validate_address_range (EA1, EA2);
    92.       if there_are_locks_in_physical_addresses(KDF9.Q_register'(C => 0, I => PA1, M => PA2)) then
    93.          if the_CPU_state /= Director_state then
    94.             if_user_mode_then_LOV(PA1, PA2, solo => False);
    95.          end if;
    96.       end if;
    97.    end check_addresses_and_lockouts;
    98.
    99.    -- Check that A1+A2 is valid; trap if it is invalid.
   100.    function valid_word_address (A1, A2 : in KDF9.Q_part)
   101.    return KDF9.address is
   102.       V : constant KDF9.word := (KDF9.word(A1) + KDF9.word(A2)) and Q_part_mask;
   103.    begin
   104.       if V > max_address then
   105.          diagnose_invalid_address("32K-1 < virtual address", V);
   106.       end if;
   107.       return KDF9.address(V);
   108.    end valid_word_address;
   109.
   110.    function signed is new Ada.Unchecked_Conversion (KDF9.Q_part, CPU.signed_Q_part);
   111.    function design is new Ada.Unchecked_Conversion (CPU.signed_Q_part, KDF9.Q_part);
   112.
   113.    -- Check that A1+A2/2 is valid; trap if it is invalid.  A2 must be treated as a signed number.
   114.    function valid_halfword_address (A1, A2 : in KDF9.Q_part)
   115.    return KDF9.address is
   116.       V : constant KDF9.word := (KDF9.word(A1) + KDF9.word(design(signed(A2)/2))) and Q_part_mask;
   117.    begin
   118.       if V > max_address then
   119.          diagnose_invalid_address("32K-1 < virtual address", V);
   120.       end if;
   121.       return KDF9.address(V);
   122.    end valid_halfword_address;
   123.
   124.    function fetch_symbol (EA : KDF9.address; index : KDF9_char_sets.symbol_index)
   125.    return KDF9_char_sets.symbol
   126.    is (KDF9_char_sets.symbol(shift_word_right(core(EA+BA), 42 - 6*Natural(index)) and 8#77#));
   127.
   128.    procedure store_symbol (value : in KDF9_char_sets.symbol;
   129.                            EA    : in KDF9.address;
   130.                            index : in KDF9_char_sets.symbol_index) is
   131.       place  : constant Natural   := 42 - 6*Natural(index);
   132.       mask   : constant KDF9.word := not shift_word_left(8#77#, place);
   133.       symbol : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   134.    begin
   135.       core(EA+BA) := (core(EA+BA) and mask) or symbol;
   136.    end store_symbol;
   137.
   138.    function fetch_octet (EA : KDF9.address; index : KDF9_char_sets.octet_index)
   139.    return KDF9_char_sets.octet is
   140.       place : constant Natural := 40 - 8*Natural(index);
   141.    begin
   142.       return KDF9_char_sets.octet(shift_word_right(core(EA+BA), place) and 8#377#);
   143.    end fetch_octet;
   144.
   145.    procedure store_octet  (value : in KDF9_char_sets.octet;
   146.                            EA    : in KDF9.address;
   147.                            index : in KDF9_char_sets.octet_index) is
   148.       place : constant Natural   := 40 - 8*Natural(index);
   149.       octet : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   150.       mask  : constant KDF9.word := not shift_word_left(8#377#, place);
   151.    begin
   152.       core(EA+BA) := (core(EA+BA) and mask) or octet;
   153.    end store_octet;
   154.
   155.    function fetch_syllable (EA : KDF9.syllable_address)
   156.    return KDF9.syllable is
   157.       address : constant KDF9.address := Q_part(EA.code_address) + BA;
   158.       place   : constant Natural      := 40 - 8*Natural(EA.syllable_index);
   159.    begin
   160.       return KDF9.syllable(shift_word_right(core(address), place) and 8#377#);
   161.    end fetch_syllable;
   162.
   163.    procedure store_syllable (value : in KDF9.syllable;
   164.                              EA    : in KDF9.address;
   165.                              index : in KDF9.syllable_index) is
   166.       place    : constant Natural   := 40 - 8*Natural(index);
   167.       syllable : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   168.       mask     : constant KDF9.word := not shift_word_left(8#377#, place);
   169.    begin
   170.       core(EA+BA) := (core(EA+BA) and mask) or syllable;
   171.    end store_syllable;
   172.
   173.    function fetch_halfword (EA : KDF9.address; index : KDF9.halfword_number)
   174.    return KDF9.word
   175.    is (shift_word_left(shift_word_right(core(EA+BA), 24 - 24*Natural(index)), 24));
   176.
   177.    procedure store_halfword (value : in KDF9.word;
   178.                              EA    : in KDF9.address;
   179.                              index : in KDF9.halfword_number) is
   180.       place   : constant Natural   := 24 - 24*Natural(index);
   181.       half    : constant KDF9.word := shift_word_left(shift_word_right(value, 24), place);
   182.       mask    : constant KDF9.word := not shift_word_left(halfword_mask, place);
   183.    begin
   184.       core(EA+BA) := (core(EA+BA) and mask) or half;
   185.    end store_halfword;
   186.
   187.    function fetch_word (EA : KDF9.address)
   188.    return KDF9.word
   189.    is (core(EA+BA));
   190.
   191.    procedure store_word (value : in KDF9.word; EA : in KDF9.address) is
   192.    begin
   193.       core(EA+BA) := value;
   194.    end store_word;
   195.
   196.    function there_are_locks_in_relative_addresses (Q : KDF9.Q_register)
   197.    return Boolean is
   198.    begin
   199.       validate_address_range (Q.I, Q.M);
   200.       return there_are_locks_in_physical_addresses((0, Q.I+BA, Q.M+BA));
   201.    end there_are_locks_in_relative_addresses;
   202.
   203.    function there_are_locks_in_physical_addresses (Q : KDF9.Q_register)
   204.    return Boolean is
   205.    begin
   206.       for g in group(Q.I) .. group(Q.M) loop
   207.          if locked_out(g) then
   208.             the_locked_out_address := g * group_size;
   209.             return True;
   210.          end if;
   211.       end loop;
   212.       return False;
   213.    end there_are_locks_in_physical_addresses;
   214.
   215.    function is_unlocked (G : KDF9.store.group_address)
   216.    return Boolean is
   217.    begin
   218.       return not locked_out(KDF9.Q_part(G));
   219.    end is_unlocked;
   220.
   221.    procedure lock_out_relative_addresses (Q : in KDF9.Q_register) is
   222.    begin
   223.       validate_address_range (Q.I, Q.M);
   224.       lock_out_absolute_addresses((0, Q.I+BA, Q.M+BA));
   225.    end lock_out_relative_addresses;
   226.
   227.    procedure lock_out_absolute_addresses (Q : in KDF9.Q_register) is
   228.    begin
   229.       for g in group(Q.I) .. group(Q.M) loop
   230.          locked_out(g) := True;
   231.       end loop;
   232.    end lock_out_absolute_addresses;
   233.
   234.    procedure unlock_absolute_addresses (Q : in KDF9.Q_register) is
   235.    begin
   236.       for g in group(Q.I) .. group(Q.M) loop
   237.          locked_out(g) := False;
   238.       end loop;
   239.    end unlock_absolute_addresses;
   240.
   241. end KDF9.store;

Compiling: ../Source/kdf9-store.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:51

     1. -- KDF9 core store operations.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18.
    19. use  KDF9_char_sets;
    20.
    21. package KDF9.store is
    22.
    23.    --
    24.    -- Relative addresses may be either virtual or physical.
    25.    -- Virtual addresses are generated by problem programs and must be relativized by adding BA.
    26.    -- These addresses must also be validated to ensure they do not breach store limits.
    27.    -- Physical "relative" addresses are generated by Director, when BA is guaranteed to be 0,
    28.    --   so it has no effect, thus allowing the relative address routines to be used.
    29.    --
    30.    -- Absolute addresses are generated by I/O Control, which may be doing a transfer for either
    31.    --   a Director or a problem program, and must therefore ensure that BA is not added.
    32.    --
    33.
    34.    --
    35.    -- Parameters named EA are Effective "relative" Addresses.
    36.    --
    37.
    38.    function fetch_symbol (EA : KDF9.address; index : KDF9_char_sets.symbol_index)
    39.    return KDF9_char_sets.symbol;
    40.
    41.    function fetch_octet (EA : KDF9.address; index : KDF9_char_sets.octet_index)
    42.    return KDF9_char_sets.octet
    43.       with Inline;
    44.
    45.    function fetch_syllable (EA : KDF9.syllable_address)
    46.    return KDF9.syllable
    47.       with Inline;
    48.
    49.    function fetch_halfword (EA : KDF9.address; index : KDF9.halfword_number)
    50.    return KDF9.word
    51.       with Inline;
    52.
    53.    function fetch_word (EA : KDF9.address)
    54.    return KDF9.word
    55.       with Inline;
    56.
    57.    procedure store_symbol (value : in KDF9_char_sets.symbol;
    58.                            EA    : in KDF9.address;
    59.                            index : in KDF9_char_sets.symbol_index)
    60.       with Inline;
    61.
    62.    procedure store_octet  (value : in KDF9_char_sets.octet;
    63.                            EA    : in KDF9.address;
    64.                            index : in KDF9_char_sets.octet_index)
    65.       with Inline;
    66.
    67.    procedure store_syllable (value : in KDF9.syllable;
    68.                              EA    : in KDF9.address;
    69.                              index : in KDF9.syllable_index)
    70.       with Inline;
    71.
    72.    procedure store_halfword (value : in KDF9.word;
    73.                              EA    : in KDF9.address;
    74.                              index : in KDF9.halfword_number)
    75.       with Inline;
    76.
    77.    procedure store_word (value : in KDF9.word; EA : in KDF9.address)
    78.       with Inline;
    79.
    80.    -- Check that A1+A2 is a valid word address; LIV if it is invalid.
    81.    function valid_word_address (A1, A2 : in KDF9.Q_part)
    82.    return KDF9.address
    83.       with Inline;
    84.
    85.    -- Check that A1+A2/2 is valid; LIV if it is invalid.  A2 is treated as a signed number.
    86.    function valid_halfword_address (A1, A2 : in KDF9.Q_part)
    87.    return KDF9.address
    88.       with Inline;
    89.
    90.    -- If a store access is locked out, its physical address is left here.
    91.    the_locked_out_address : KDF9.Q_part;
    92.
    93.    procedure if_user_mode_then_LOV (address_1 : KDF9.Q_part;
    94.                                     address_2 : KDF9.Q_part := 0;
    95.                                     solo      : Boolean     := True)
    96.       with Inline => False;
    97.
    98.    -- Check EA and lockout for EA.
    99.    procedure check_address_and_lockout (EA : in KDF9.Q_part)
   100.       with Inline;
   101.
   102.    -- Check that EA1, EA2, EA1+BA, EA2+BA are valid, and EA1 <= EA2.
   103.    --    LIV in any invalid case.
   104.    procedure validate_address_range (EA1, EA2 : in KDF9.Q_part);
   105.
   106.    -- Check EA1, EA2, and lockouts for EA1+BA .. EA2+BA.
   107.    procedure check_addresses_and_lockouts (EA1, EA2 : in KDF9.Q_part);
   108.
   109.    function there_are_locks_in_relative_addresses (Q : KDF9.Q_register)
   110.    return Boolean;
   111.
   112.    function there_are_locks_in_physical_addresses (Q : KDF9.Q_register)
   113.    return Boolean;
   114.
   115.    procedure lock_out_relative_addresses (Q : in KDF9.Q_register);
   116.
   117.    procedure lock_out_absolute_addresses (Q : in KDF9.Q_register);
   118.
   119.    procedure unlock_absolute_addresses (Q : in KDF9.Q_register);
   120.
   121.    -- The maximum size KDF9 core store has 32Kibiwords.
   122.    max_address   : constant := 2**15 - 1;
   123.
   124.    -- The group size of 32 words is 1 physical core allocation unit and physical lockout unit.
   125.    group_size : constant := 32;
   126.
   127.    type group_address is mod 1024;
   128.
   129.     -- is_unlocked yields True if the designated group is NOT locked out.
   130.    function is_unlocked (G : KDF9.store.group_address)
   131.    return Boolean;
   132.
   133.    function group (PA : KDF9.Q_part)
   134.    return KDF9.Q_part
   135.       with Inline;
   136.
   137. private
   138.
   139.    type word_array is array (KDF9.Q_part range <>) of KDF9.word
   140.       with Component_Size => 64, Convention => C;
   141.
   142.    -- The core store of KDF9.  Must be zeroized before loading any software.
   143.    core : word_array (KDF9.Q_part range 0 .. max_address) := (others => 0);
   144.
   145.    -- The lockout store has one bit for every group_size words.
   146.    last_lockout : constant := max_address / group_size;
   147.    locked_out   : array (KDF9.Q_part range 0 .. last_lockout) of Boolean := (others => False);
   148.
   149. end KDF9.store;

 241 lines: No errors


GNAT 8.3.0
GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/imported_value_of.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Get the value of an environment variable.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Environment_Variables;
    18.
    19. function imported_value_of (name : in String; default : in String := "")
    20. return String is
    21. begin
    22.    return Ada.Environment_Variables.Value(name, default);
    23. end imported_value_of;

 23 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tod_clock.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- functions that implement timing for Director emulation.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Calendar;
    18. with Ada.Calendar.Time_Zones;
    19. with Ada.Calendar.Formatting;
    20.
    21. use  Ada.Calendar;
    22. use  Ada.Calendar.Time_Zones;
    23. use  Ada.Calendar.Formatting;
    24.
    25. package body KDF9.TOD_clock is
    26.
    27.    function todays_date_28n_years_ago
    28.    return KDF9.word is
    29.
    30.       zero  : constant KDF9.word := 8#20#;  -- in KDF9 internal code
    31.       slash : constant KDF9.word := 8#17#;  -- in KDF9 internal code
    32.       today : constant Ada.Calendar.Time := Ada.Calendar.Clock;
    33.
    34.       year, month, day, hour, minute, second, sub_second : KDF9.word;
    35.
    36.       -- For values of i in 0..99, return two 6-bit decimal digits in KDF9 internal code.
    37.       function as_2_digits (i : KDF9.word)
    38.       return KDF9.word
    39.       is ((i/10 + zero)*64 or (i mod 10 + zero));
    40.
    41.    begin  -- todays_date_28n_years_ago
    42.       Split(today,
    43.             Year_Number(year),
    44.             Month_Number(month),
    45.             Day_Number(day),
    46.             Hour_Number(hour),
    47.             Minute_Number(minute),
    48.             Second_Number(second),
    49.             Second_Duration(sub_second),
    50.             Time_Zone => UTC_Time_Offset(today)
    51.            );
    52.       loop  -- Repeat n > 0 times, assuming no time travel into the past!
    53.          year := year - 28;
    54.       exit when year < 2000;
    55.       end loop;
    56.       return (as_2_digits(day)*64   or slash) * 64**5  -- DD/.....
    57.           or (as_2_digits(month)*64 or slash) * 64**2  --    MM/..
    58.           or (as_2_digits((year) mod 100));            --       YY
    59.    end todays_date_28n_years_ago;
    60.
    61.    function the_time_of_day
    62.    return KDF9.us is
    63.       today : constant Ada.Calendar.Time := Ada.Calendar.Clock;
    64.       year, month, day, hour, minute, second, sub_second : KDF9.word;
    65.    begin
    66.       Split(today,
    67.             Year_Number(year),
    68.             Month_Number(month),
    69.             Day_Number(day),
    70.             Hour_Number(hour),
    71.             Minute_Number(minute),
    72.             Second_Number(second),
    73.             Second_Duration(sub_second),
    74.             Time_Zone => UTC_Time_Offset(today)
    75.            );
    76.       return KDF9.us(hour*3600 + minute*60 + second) * 1_000_000;
    77.    end the_time_of_day;
    78.
    79. end KDF9.TOD_clock;

Compiling: ../Source/kdf9-tod_clock.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- functions that implement timing for Director emulation.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TOD_clock is
    18.
    19.    -- The date a multiple of 28 years ago has the same day/date correspondence as today.
    20.    -- To avoid exposing KDF9's lack of Y2K compliance, ee9 uses such a date before 2000.
    21.    -- 8-)
    22.    -- todays_date_28n_years_ago returns a word of 8 KDF9 characters in the format DD/MM/YY.
    23.
    24.    function todays_date_28n_years_ago
    25.    return KDF9.word;
    26.
    27.    -- The time in microseconds since midnight.
    28.    function the_time_of_day
    29.    return KDF9.us;
    30.
    31. end KDF9.TOD_clock;

 79 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd-timing.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Implement the timing OUTs of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body KDF9.TSD.timing is
    18.
    19.    -- This is the actual wall clock time at which the program was loaded.
    20.    -- If signature hashing is enabled, it stays at zero to get a repeatable hash.
    21.    the_time_of_loading : KDF9.us := 0;
    22.
    23.    -- Set the base for virtual elapsed time reckoning.
    24.    procedure set_the_time_of_loading (the_time : in KDF9.us) is
    25.    begin
    26.       the_time_of_loading := the_time;
    27.    end set_the_time_of_loading;
    28.
    29.    -- Return a time in µs as 48-bit seconds to 23 integral places.
    30.    function OUT_time (microseconds : KDF9.us)
    31.    return KDF9.word is
    32.       -- The time was recorded by the hardware in units of 32 us, not 1 us.
    33.       truncated_time : constant KDF9.us := microseconds and not 31;
    34.    begin
    35.       if truncated_time < 2**23 * 1E6 then
    36.          -- 2**18 / 15625 = 2**24 / 1E6, with no risk of overflow in 64 bits.
    37.          return KDF9.word(truncated_time * 2**18 / 15625);
    38.       else
    39.          -- The virtual elapsed time overflows the 23-bit seconds field.
    40.          -- This would never have happened to a real KDF9, as 2**23 seconds is over three months.
    41.          -- No KDF9 could stay up that long!
    42.          -- However 2**23 KDF9 seconds pass in about 5 hours of ee9 real time,
    43.          --    so precautions have to be taken.
    44.          raise program_exit with "the KDF9 has been running too long, time > 2**23 seconds";
    45.       end if;
    46.    end OUT_time;
    47.
    48.    procedure do_OUT_3 is
    49.    begin
    50.       push(OUT_time(the_CPU_time));
    51.       the_trace_operand := read_top;
    52.    end do_OUT_3;
    53.
    54.    procedure do_OUT_9 is
    55.    begin
    56.       -- A TOD clock is simulated using the real TOD at which the program was
    57.       --    loaded, and the virtual time that has elapsed since.
    58.       push(OUT_time(the_time_of_loading + the_clock_time));
    59.       the_trace_operand := read_top;
    60.    end do_OUT_9;
    61.
    62.    procedure do_OUT_17 is
    63.    begin
    64.       ensure_that_the_NEST_has_room_for_2_results;
    65.       -- In program mode, the Elapsed Time is the same thing as the_clock_time.
    66.       push(OUT_time(the_clock_time));
    67.       push(OUT_time(the_CPU_time));
    68.       the_trace_operand := read_top;
    69.    end do_OUT_17;
    70.
    71. end KDF9.TSD.timing;

Compiling: ../Source/kdf9-tsd-timing.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Implement the timing OUTs of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.timing is
    18.
    19.    procedure do_OUT_3;
    20.
    21.    procedure do_OUT_9;
    22.
    23.    procedure do_OUT_17;
    24.
    25.    -- Set the base for virtual elapsed time reckoning.
    26.    procedure set_the_time_of_loading (the_time : in KDF9.us);
    27.
    28. end KDF9.TSD.timing;

 71 lines: No errors


Compiling: /home/parallels/emulation/Source/kdf9-tsd.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Implement the API (OUTs) of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with formatting;
    18. with IOC.fast.DR.TSD_OUTs;
    19. with IOC.fast.FD.TSD_OUTs;
    20. with IOC.fast.tape.TSD_OUTs;
    21. with KDF9.CPU;
    22. with KDF9.store;
    23. with KDF9.TSD.peripherals;
    24. with KDF9.TSD.processes;
    25. with KDF9.TSD.spooling;
    26. with KDF9.TSD.timing;
    27. with settings;
    28. with tracing;
    29.
    30. use  formatting;
    31. use  IOC.fast.DR.TSD_OUTs;
    32. use  IOC.fast.FD.TSD_OUTs;
    33. use  IOC.fast.tape.TSD_OUTs;
    34. use  KDF9.store;
    35. use  KDF9.TSD.peripherals;
    36. use  KDF9.TSD.processes;
    37. use  KDF9.TSD.spooling;
    38. use  KDF9.TSD.timing;
    39. use  settings;
    40. use  tracing;
    41.
    42. package body KDF9.TSD is
    43.
    44.    procedure restore_the_IO_OUT_operands (OUT_number, parameter : KDF9.word) is
    45.    begin
    46.       push(parameter);
    47.       push(OUT_number);
    48.    end restore_the_IO_OUT_operands;
    49.
    50.    procedure do_OUT_95 is
    51.       Q             : constant KDF9.Q_register := as_Q(pop);
    52.       start_address : constant KDF9.address := Q.I;
    53.       end_address   :          KDF9.address := Q.M;
    54.    begin
    55.       the_trace_operand := as_word(Q);
    56.       validate_address_range(start_address, end_address);
    57.
    58.       if Q.C / 2 > 0 then
    59.          log_new_line;
    60.       end if;
    61.
    62.       end_address := KDF9.address'Min(end_address, start_address + 9);
    63.
    64.       declare
    65.          size : constant Positive := Positive(end_address - start_address + 1) * 8;
    66.          next : Positive := 1;
    67.          text : String(1 .. size);
    68.          char : KDF9_char_sets.symbol;
    69.       begin
    70.       word_loop:
    71.          for w in start_address .. end_address loop
    72.             for c in KDF9_char_sets.symbol_index'Range loop
    73.                char := fetch_symbol(w, c);
    74.                text(next) := to_CP(char);
    75.                next := next + 1;
    76.             end loop;
    77.          end loop word_loop;
    78.          log(text);
    79.       end;
    80.
    81.       if Q.C mod 2 = 1  then
    82.          log_new_line;
    83.       end if;
    84.    end do_OUT_95;
    85.
    86.    procedure do_OUT_96 is
    87.       use KDF9.CPU;
    88.       P    : constant KDF9.word := pop;
    89.       text : constant String    := glyphs_for(P);
    90.    begin
    91.       the_trace_operand := P;
    92.       log_line("N1 = "
    93.              & resign(P)'Image
    94.              & " "
    95.              & as_fraction(P)'Image
    96.              & " "
    97.              & host_float(as_f48(P))'Image
    98.              & " #"
    99.              & oct_of(P)
   100.              & " «"
   101.              & text
   102.              & "»");
   103.       push(P);
   104.    end do_OUT_96;
   105.
   106.    procedure remove_the_IO_OUT_operands renames KDF9.pop_pair;
   107.
   108.    -- Emulate a subset of the Time Sharing Director's OUT API.
   109.    procedure do_a_TSD_OUT (OUT_number : in KDF9.word) is
   110.    begin
   111.       -- Dismiss the OUT number in N1, allowing for an empty NEST, treated as OUT 0.
   112.       if the_NEST_depth > 0 then
   113.          pop;
   114.       end if;
   115.
   116.       case OUT_number is
   117.
   118.          when 0 =>
   119.             do_OUT_0;
   120.
   121.          when 1 =>
   122.             do_OUT_1;
   123.
   124.          when 2 =>
   125.             do_OUT_2;
   126.
   127.          when 3 =>
   128.             do_OUT_3;
   129.
   130.          when 4 =>
   131.             do_OUT_4;
   132.
   133.          when 5 =>
   134.             do_OUT_5;
   135.
   136.          when 6 =>
   137.             do_OUT_6;
   138.
   139.          when 7 =>
   140.             do_OUT_7;
   141.
   142.          when 8 =>
   143.             do_OUT_8;
   144.
   145.          when 9 =>
   146.             do_OUT_9;
   147.
   148.          when 10 =>
   149.             do_OUT_10;
   150.
   151.          when 11 =>
   152.             do_OUT_11;
   153.
   154.          when 12 =>
   155.             do_OUT_12;
   156.
   157.          when 13 =>
   158.             do_OUT_13;
   159.
   160.          when 14 =>
   161.             do_OUT_14;
   162.
   163.          when 16 =>
   164.             do_OUT_16;
   165.
   166.          when 17 =>
   167.             do_OUT_17;
   168.
   169.          when 41 =>
   170.             do_OUT_41;
   171.
   172.          when 42 =>
   173.             do_OUT_42;
   174.
   175.          when 43 =>
   176.             do_OUT_43;
   177.
   178.          when 44 =>
   179.             do_OUT_44;
   180.
   181.          when 45 =>
   182.             do_OUT_45;
   183.
   184.          when 47 =>
   185.             do_OUT_47;
   186.
   187.          when 95 =>
   188.             -- This is not a genuine TSD OUT, it prints the 8-character text in N1.
   189.             ensure_that_the_NEST_holds_an_operand;
   190.             do_OUT_95;
   191.
   192.          when 96 =>
   193.             -- This is not a genuine TSD OUT, it prints the integer value in N1.
   194.             ensure_that_the_NEST_holds_an_operand;
   195.             do_OUT_96;
   196.
   197.          when 97 =>
   198.             -- This is not a genuine TSD OUT, it gets an integer value from the command line.
   199.             -- The operand is the name of an environment variable.
   200.             -- The result is the numerical value of that variable.
   201.             ensure_that_the_NEST_holds_an_operand;
   202.             do_OUT_97;
   203.
   204.          when 98 =>
   205.             -- This is not a genuine TSD OUT, it is an ee9 'OUT' for setting FW output format.
   206.             ensure_that_the_NEST_holds_an_operand;
   207.             the_trace_operand := pop;
   208.             realistic_FW_output_is_wanted := the_trace_operand /= 0;
   209.
   210.          when 99 =>
   211.             -- This is not a genuine TSD OUT, it is an ee9 'OUT' for program instrumentation.
   212.             -- Get present value of the Instruction Count Register (ICR) from within ee9.
   213.             push(KDF9.word(ICR));
   214.             the_trace_operand := KDF9.word(ICR);
   215.
   216.          when others =>
   217.             push(OUT_number);
   218.             trap_failing_OUT(OUT_number, "is unknown, or not yet implemented");
   219.
   220.       end case;
   221.    end do_a_TSD_OUT;
   222.
   223. end KDF9.TSD;

Compiling: ../Source/kdf9-tsd.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Implement the API (OUTs) of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. private with exceptions;
    18. private with formatting;
    19. private with HCI;
    20. private with IOC.equipment;
    21. private with settings;
    22. private with state_display;
    23. private with tracing;
    24.
    25. package KDF9.TSD is
    26.
    27.    procedure do_a_TSD_OUT (OUT_number : in KDF9.word);
    28.
    29.    -- Put the parameters of an I/O OUT back into the NEST in case the I/O order causes a lockout.
    30.    procedure restore_the_IO_OUT_operands (OUT_number, parameter : KDF9.word);
    31.
    32.    -- Remove the OUT parameters from the NEST after the I/O order completes without interrupting.
    33.    procedure remove_the_IO_OUT_operands;
    34.
    35. private
    36.
    37.    use exceptions;     pragma Warnings(Off, exceptions);
    38.    use formatting;     pragma Warnings(Off, formatting);
    39.    use HCI;            pragma Warnings(Off, HCI);
    40.    use IOC.equipment;  pragma Warnings(Off, IOC.equipment);
    41.    use settings;       pragma Warnings(Off, settings);
    42.    use state_display;  pragma Warnings(Off, state_display);
    43.    use tracing;        pragma Warnings(Off, tracing);
    44.
    45. end KDF9.TSD;

 223 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/file_interfacing.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Provide an Ada.Text_IO interface to the file system of the real OS.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body file_interfacing is
    18.
    19.    procedure initialize (some_file : in out File_Type;
    20.                          mode      : in File_Mode;
    21.                          file_name : in String) is
    22.    begin
    23.       Open(some_file, mode, file_name);
    24.    exception
    25.       when others =>
    26.          if mode = Out_File then
    27.             Create(some_file, Out_File, file_name);
    28.          else
    29.             raise;
    30.          end if;
    31.    end initialize;
    32.
    33.    procedure finalize (some_file : in out File_Type;
    34.                        file_name : in String) is
    35.       pragma Unreferenced(file_name);
    36.    begin
    37.       Close(some_file);
    38.    end finalize;
    39.
    40. end file_interfacing;

Compiling: ../Source/file_interfacing.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Provide an Ada.Text_IO interface to the file system of the real OS.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18.
    19. use  Ada.Text_IO;
    20.
    21. package file_interfacing is
    22.
    23.    procedure initialize (some_file : in out File_Type;
    24.                          mode      : in File_Mode;
    25.                          file_name : in String);
    26.
    27.    procedure finalize (some_file : in out File_Type;
    28.                        file_name : in String);
    29.
    30. end file_interfacing;

 40 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/finalize_ee9.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Shut down processing in preparation for a dignified exit.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. --
    19. with HCI;
    20. with IOC;
    21. with state_display;
    22.
    23. use  HCI;
    24. use  IOC;
    25. use  state_display;
    26.
    27. procedure finalize_ee9 (because : in String) is
    28. begin
    29.    show_final_state(because);
    30.    finalize_all_KDF9_buffers;
    31. exception
    32.    when error : others =>
    33.       log_line("Failure: " & Ada.Exceptions.Exception_Information(error));
    34. end finalize_ee9;

 34 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/disassembly.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Produce dis-assembled instructions in an approximation to KDF9 Usercode.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with formatting;
    18. with KDF9.CPU;
    19. with KDF9.decoding;
    20. with disassembly.symbols;
    21.
    22. use  formatting;
    23. use  KDF9.CPU;
    24. use  KDF9.decoding;
    25. use  disassembly.symbols;
    26.
    27. package body disassembly is
    28.
    29.    function flagged (flag : String; s : KDF9.syllable)
    30.    return String
    31.    is (flag & oct_of(s));
    32.
    33.    function machine_code (decoded : KDF9.decoded_order)
    34.    return String
    35.    is (
    36.        case decoded.kind is
    37.           when one_syllable_order => flagged("#", decoded.order.syllable_0),
    38.
    39.           when two_syllable_order => flagged("#", decoded.order.syllable_0)
    40.                                    & flagged(":", decoded.order.syllable_1),
    41.           when normal_jump_order
    42.              | data_access_order  => flagged("#", decoded.order.syllable_0)
    43.                                    & flagged(":", decoded.order.syllable_1)
    44.                                    & flagged(":", decoded.order.syllable_2)
    45.       );
    46.
    47.    function one_syllable_name (decoded : KDF9.decoded_order)
    48.    return String
    49.    is (
    50.        case decoded.compressed_opcode is
    51.           when ABS_9   => "ABS",
    52.           when ABSF    => "ABSF",
    53.           when AND_9   => "AND",
    54.           when BITS    => "BITS",
    55.           when CAB     => "CAB",
    56.           when CONT    => "CONT",
    57.           when DIV     => "/",
    58.           when DIVD    => "/D",
    59.           when DIVDF   => "/DF",
    60.           when DIVF    => "/F",
    61.           when DIVI    => "/I",
    62.           when DIVR    => "/R",
    63.           when DUMMY   => "DUMMY",
    64.           when DUP     => "DUP",
    65.           when DUPD    => "DUPD",
    66.           when ERASE   => "ERASE",
    67.           when FIX     => "FIX",
    68.           when FLOAT_9 => "FLOAT",
    69.           when FLOATD  => "FLOATD",
    70.           when FRB     => "FRB",
    71.           when MAX     => "MAX",
    72.           when MAXF    => "MAXF",
    73.           when MINUS   => "-",
    74.           when MINUSD  => "-D",
    75.           when MINUSDF => "-DF",
    76.           when MINUSF  => "-F",
    77.           when NEG     => "NEG",
    78.           when NEGD    => "NEGD",
    79.           when NEGDF   => "NEGDF",
    80.           when NEGF    => "NEGF",
    81.           when NEV     => "NEV",
    82.           when NOT_9   => "NOT",
    83.           when OR_9    => "OR",
    84.           when PERM    => "PERM",
    85.           when PLUS    => "+",
    86.           when PLUSD   => "+D",
    87.           when PLUSDF  => "+DF",
    88.           when PLUSF   => "+F",
    89.           when REV     => "REV",
    90.           when REVD    => "REVD",
    91.           when ROUND   => "ROUND",
    92.           when ROUNDF  => "ROUNDF",
    93.           when ROUNDH  => "ROUNDH",
    94.           when ROUNDHF => "ROUNDHF",
    95.           when SIGN    => "SIGN",
    96.           when SIGNF   => "SIGNF",
    97.           when STAND   => "STAND",
    98.           when STR     => "STR",
    99.           when TO_TR   => "=TR",
   100.           when TOB     => "TOB",
   101.           when VR      => "VR",
   102.           when X_frac  => "×",
   103.           when XD      => "×D",
   104.           when XDF     => "×DF",
   105.           when XF      => "×F",
   106.           when XPLUSF  => "×+F",
   107.           when ZERO    => "ZERO",
   108.           when 0       => "DUMMY0",
   109.           when others  =>  machine_code(decoded)
   110.        );
   111.
   112.    function two_syllable_name (decoded : KDF9.decoded_order)
   113.    return String is
   114.
   115.       default : constant String := machine_code(decoded);
   116.       invalid : constant String := "";
   117.       k       : constant String := trimmed(decoded.Qk'Image);
   118.       q       : constant String := trimmed(decoded.Qq'Image);
   119.       opcode  : constant KDF9.compressed_opcode := (decoded.Qk and not manual_bit);
   120.       CT      : constant Boolean := (decoded.Qk and manual_bit) = 0;
   121.
   122.       function IO_order (stem : String)
   123.       return String
   124.       is (if stem = invalid then default else stem & "Q" & q);
   125.
   126.       function IO_name
   127.       return String
   128.       is (
   129.           case decoded.compressed_opcode is
   130.                when PIA_PIC_CLO_TLO_Qq =>
   131.                                    IO_order(case opcode is
   132.                                                when PIA_bits => "PIA",
   133.                                                when PIC_bits => "PIC",
   134.                                                when CLO_bits => "CLO",
   135.                                                when TLO_bits => "TLO",
   136.                                                when others   => invalid),
   137.                when PIB_PID_Qq =>
   138.                                    IO_order(case opcode is
   139.                                                when PIB_bits => "PIB",
   140.                                                when PID_bits => "PID",
   141.                                                when others   => invalid),
   142.                when PIE_PIG_Qq =>
   143.                                    IO_order(case opcode is
   144.                                                when PIE_bits => "PIE",
   145.                                                when PIG_bits => "PIG",
   146.                                                when others   => invalid),
   147.                when PIF_PIH_Qq =>
   148.                                    IO_order(case opcode is
   149.                                                when PIF_bits => "PIF",
   150.                                                when PIH_bits => "PIH",
   151.                                                when others   => invalid),
   152.                when PMA_PMK_INT_Qq =>
   153.                                    IO_order(case opcode is
   154.                                                when PMA_bits => "PMA",
   155.                                                when PMK_bits => "PMK",
   156.                                                when INT_bits => "INT",
   157.                                                when others   => invalid),
   158.                when CT_PMB_PMC_BUSY_Qq =>
   159.                                    IO_order(case opcode is
   160.                                                when PMB_bits  => "PMB",
   161.                                                when PMC_bits  => "PMC",
   162.                                                when BUSY_bits => "BUSY",
   163.                                                when CTQ_bits => (if CT then "CT" else "MANUAL"),
   164.                                                when others    => invalid),
   165.                when PMD_PME_PML_Qq =>
   166.                                    IO_order(case opcode is
   167.                                                when PMD_bits => "PMD",
   168.                                                when PME_bits => "PME",
   169.                                                when PML_bits => "PML",
   170.                                                when others   => invalid),
   171.                when PMF_PMG_Qq =>
   172.                                    IO_order(case opcode is
   173.                                                when PMF_bits => "PMF",
   174.                                                when PMG_bits => "PMG",
   175.                                                when others   => invalid),
   176.                when POA_POC_POE_POF_PMH_Qq =>
   177.                                    IO_order(case opcode is
   178.                                                when POA_bits => "POA",
   179.                                                when POC_bits => "POC",
   180.                                                when POE_bits => "POE",
   181.                                                when POF_bits => "POF",
   182.                                                when PMH_bits => "PMH",
   183.                                                when others   => invalid),
   184.                when POB_POD_Qq =>
   185.                                    IO_order(case opcode is
   186.                                                when POB_bits => "POB",
   187.                                                when POD_bits => "POD",
   188.                                                when others   => invalid),
   189.                when POG_POL_Qq =>
   190.                                    IO_order(case opcode is
   191.                                                when POG_bits => "POG",
   192.                                                when POL_bits => "POL",
   193.                                                when others   => invalid),
   194.                when POH_POK_Qq =>
   195.                                    IO_order(case opcode is
   196.                                                when POH_bits => "POH",
   197.                                                when POL_bits => "POK",
   198.                                                when others   => invalid),
   199.                when PAR_Qq =>      IO_order("PAR"),
   200.                when others =>      IO_order(invalid)
   201.          );
   202.
   203.       function indirect_store_name (suffix : String := "")
   204.       return String
   205.       is ("=M" & k & "M" & q & suffix);
   206.
   207.       function indirect_fetch_name (suffix : String := "")
   208.       return String
   209.       is ("M" & k & "M" & q & suffix);
   210.
   211.       function Qq_to_Qk_name (part : String)
   212.       return String
   213.       is (part & q & " TO Q" & k);
   214.
   215.       function Qq_name (action : String; suffix : String := "")
   216.       return String
   217.       is (action & q & suffix);
   218.
   219.       function shift_count
   220.       return String is
   221.          constant_flag : constant := 1;
   222.          fixed_shift   : CPU.signed_Q_part;
   223.       begin
   224.          if (decoded.order.syllable_1 and constant_flag) /= 0  then
   225.             fixed_shift := resign(KDF9.Q_part(decoded.order.syllable_1/2));
   226.             if fixed_shift > 63 then
   227.                fixed_shift := fixed_shift - 128;
   228.             end if;
   229.             return (if fixed_shift < 0 then "" else "+") & trimmed(fixed_shift'Image);
   230.          else
   231.             return "C" & q;
   232.          end if;
   233.       end shift_count;
   234.
   235.       function shift_name (action : String)
   236.       return String
   237.       is (action & shift_count);
   238.
   239.    begin -- two_syllable_name
   240.       return
   241.          (
   242.           case decoded.compressed_opcode is
   243.              when MkMq       => indirect_fetch_name,
   244.              when MkMqQ      => indirect_fetch_name(suffix => "Q"),
   245.              when MkMqH      => indirect_fetch_name(suffix => "H"),
   246.              when MkMqQH     => indirect_fetch_name(suffix => "QH"),
   247.              when MkMqN      => indirect_fetch_name(suffix => "N"),
   248.              when MkMqQN     => indirect_fetch_name(suffix => "QN"),
   249.              when MkMqHN     => indirect_fetch_name(suffix => "HN"),
   250.              when MkMqQHN    => indirect_fetch_name(suffix => "QHN"),
   251.
   252.              when TO_MkMq    => indirect_store_name,
   253.              when TO_MkMqQ   => indirect_store_name(suffix => "Q"),
   254.              when TO_MkMqH   => indirect_store_name(suffix => "H"),
   255.              when TO_MkMqQH  => indirect_store_name(suffix => "QH"),
   256.              when TO_MkMqN   => indirect_store_name(suffix => "N"),
   257.              when TO_MkMqQN  => indirect_store_name(suffix => "QN"),
   258.              when TO_MkMqHN  => indirect_store_name(suffix => "HN"),
   259.              when TO_MkMqQHN => indirect_store_name(suffix => "QHN"),
   260.
   261.              when M_PLUS_Iq  => Qq_name("M+I"),
   262.              when M_MINUS_Iq => Qq_name("M-I"),
   263.              when NCq        => Qq_name("NC"),
   264.              when DCq        => Qq_name("DC"),
   265.              when POS1_TO_Iq => Qq_name("I",  suffix => "=+1"),
   266.              when NEG1_TO_Iq => Qq_name("I",  suffix => "=-1"),
   267.              when POS2_TO_Iq => Qq_name("I",  suffix => "=+2"),
   268.              when NEG2_TO_Iq => Qq_name("I",  suffix => "=+2"),
   269.              when JCqNZS     => Qq_name("JC", suffix => "NZS"),
   270.
   271.              when MqTOQk     => Qq_to_Qk_name("M"),
   272.              when IqTOQk     => Qq_to_Qk_name("I"),
   273.              when IMqTOQk    => Qq_to_Qk_name("IM"),
   274.              when CqTOQk     => Qq_to_Qk_name("C"),
   275.              when CMqTOQk    => Qq_to_Qk_name("CM"),
   276.              when CIqTOQk    => Qq_to_Qk_name("CI"),
   277.              when QqTOQk     => Qq_to_Qk_name("Q"),
   278.              when QCIMq =>
   279.                 (
   280.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then  Qq_name("Q")
   281.                  elsif (decoded.Qk and M_part_choice) /= 0       then  Qq_name("M")
   282.                  elsif (decoded.Qk and C_part_choice) /= 0       then  Qq_name("C")
   283.                  elsif (decoded.Qk and I_part_choice) /= 0       then  Qq_name("I")
   284.                  else  default
   285.                 ),
   286.              when TO_RCIMq =>
   287.                 (
   288.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then Qq_name("=Q")
   289.                  elsif (decoded.Qk and M_part_choice) /= 0 then
   290.                     Qq_name(if (decoded.Qk and reset_choice) /= 0 then "=RM" else "=M")
   291.                  elsif (decoded.Qk and C_part_choice) /= 0 then
   292.                     Qq_name(if (decoded.Qk and reset_choice) /= 0 then "=RC" else "=C")
   293.                  elsif (decoded.Qk and I_part_choice) /= 0 then
   294.                     Qq_name(if (decoded.Qk and reset_choice) /= 0 then "=RI" else "=I")
   295.                  else default
   296.                 ),
   297.              when ADD_TO_QCIMq =>
   298.                 (
   299.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then Qq_name("=+Q")
   300.                  elsif (decoded.Qk and M_part_choice) /= 0       then Qq_name("=+M")
   301.                  elsif (decoded.Qk and C_part_choice) /= 0       then Qq_name("=+C")
   302.                  elsif (decoded.Qk and I_part_choice) /= 0       then Qq_name("=+I")
   303.                  else  default
   304.                 ),
   305.
   306.              when SHA   => shift_name("SHA"),
   307.              when SHAD  => shift_name("SHAD"),
   308.              when MACC  => shift_name("×+"),
   309.              when SHL   => shift_name("SHL"),
   310.              when SHLD  => shift_name("SHLD"),
   311.              when SHC   => shift_name("SHC"),
   312.
   313.              when TO_Kq =>
   314.                 (
   315.                  case decoded.Qq is
   316.                     when K0 => "=K0",
   317.                     when K1 => "=K1",
   318.                     when K2 => "=K2",
   319.                     when K3 => "=K3",
   320.                     when others => default
   321.                 ),
   322.              when Kk =>
   323.                 (
   324.                  case decoded.Qk is
   325.                    when K4 => "K4",
   326.                    when K5 => "K5",
   327.                    when K7 => "K7",
   328.                    when others => default
   329.                 ),
   330.
   331.              when LINK    => "LINK",
   332.              when TO_LINK => "=LINK",
   333.
   334.              when others  => IO_name
   335.           );
   336.    end two_syllable_name;
   337.
   338.    function closer (
   339.                     decoded  : KDF9.decoded_order;
   340.                     address  : KDF9.syllable_address := (0, 0);
   341.                     in_octal : Boolean := True
   342.                    )   return String
   343.    is (
   344.        if decoded.kind = normal_jump_order and decoded.compressed_opcode = JSr
   345.        then ";(LINK=" & oct_or_dec_of(address, in_octal) & "); "
   346.        else "; "
   347.       );
   348.
   349.    function normal_jump_name (
   350.                               decoded   : KDF9.decoded_order;
   351.                               in_octal  : Boolean := True
   352.                              )
   353.    return String is
   354.
   355.       the_target  : constant KDF9.syllable_address  := decoded.target;
   356.       the_symbol  : constant String := P_symbol(the_target, in_octal);
   357.       num_remark  : constant String
   358.                   := (
   359.                       if   in_octal
   360.                       then ";("  & dec_of(KDF9.Q_part(the_target.code_address))
   361.                       else ";(#" & oct_of(the_target.code_address)
   362.                      )
   363.                   & ")";
   364.       sym_remark  : constant String
   365.                   := (
   366.                       if   in_octal
   367.                       then ";(#" & oct_of(the_target.code_address)
   368.                       else ";("  & dec_of(KDF9.Q_part(the_target.code_address))
   369.                      )
   370.                    & ")";
   371.       remark      : constant String
   372.                   := (if the_symbol(the_symbol'First) = 'E' then num_remark else sym_remark);
   373.
   374.       function jump (condition : String; name : String := "J")
   375.       return String
   376.       is (name & P_symbol(the_target, in_octal) & condition & remark);
   377.
   378.       function leave (and_how : String)
   379.       return String
   380.       is ("EXIT " & and_how);
   381.
   382.    begin  -- normal_jump_name
   383.       return (
   384.               case decoded.compressed_opcode is
   385.                  when JrEQ   => jump("="),
   386.                  when JrGTZ  => jump("GTZ"),
   387.                  when JrLTZ  => jump("LTZ"),
   388.                  when JrEQZ  => jump("=Z"),
   389.                  when JrV    => jump("V"),
   390.                  when JrEN   => jump("EN"),
   391.                  when Jr     => jump(""),
   392.                  when JrEJ   => jump("EJ"),
   393.                  when JrTR   => jump("TR"),
   394.                  when JrNE   => jump("±"),
   395.                  when JrLEZ  => jump("LEZ"),
   396.                  when JrGEZ  => jump("GEZ"),
   397.                  when JrNEZ  => jump("±Z"),
   398.                  when JrNV   => jump("NV"),
   399.                  when JrNEN  => jump("NEN"),
   400.                  when JrNEJ  => jump("NEJ"),
   401.                  when JrNTR  => jump("NTR"),
   402.                  when JrCqZ  => jump("C" & trimmed(decoded.Qq'Image) & "Z"),
   403.                  when JrCqNZ => jump("C" & trimmed(decoded.Qq'Image) & "NZ"),
   404.                  when JSr    => jump("", name => "JS"),
   405.                  when OS_OUT => "OUT",
   406.                  when EXITD  => leave("D"),
   407.                  when EXIT_n =>
   408.                     -- Try to give the most helpful interpretation of the operand.
   409.                     (
   410.                      if the_target.syllable_index = 0 then  -- c.f. decode_a_jump_order.
   411.                         -- No halfword offset applies.
   412.                         (
   413.                          if the_target.code_address < 4 then
   414.                            leave(
   415.                                  if the_target.code_address = 0
   416.                                  then ""
   417.                                  else oct_of(KDF9.Q_part(2*the_target.code_address), 1)
   418.                                 )
   419.                          else
   420.                            leave("AE" & oct_or_dec_of((the_target.code_address, 0), in_octal))
   421.                         )
   422.                      elsif the_target.code_address < 4 then
   423.                         leave(oct_of(KDF9.Q_part(2*the_target.code_address + 1), 1))
   424.                      else
   425.                         leave("AE" & oct_or_dec_of((the_target.code_address, 3), in_octal))
   426.                     ),
   427.
   428.                  when others =>  machine_code(decoded)
   429.              );
   430.    end normal_jump_name;
   431.
   432.    function data_access_name (
   433.                               decoded       : KDF9.decoded_order;
   434.                               in_octal      : Boolean
   435.                              )
   436.    return String is
   437.       opcode       : constant KDF9.compressed_opcode := decoded.compressed_opcode;
   438.       operand      : KDF9.Q_part renames decoded.operand;
   439.
   440.       as_octal   : constant String := oct_of(operand, 1);
   441.       as_decimal : constant String := signed_dec_of(operand);
   442.       number     : constant String := (if in_octal then "#" & as_octal else as_decimal);
   443.       the_bare_name : constant String := (
   444.                                           if operand > 2**15
   445.                                           then "E" & number
   446.                                           else symbolic(operand, in_octal, opcode /= SET)
   447.                                          );
   448.
   449.       Qq        : KDF9.Q_number    renames decoded.Qq;
   450.       M_suffix  : constant String  := (if Qq /= 0 then "M" & trimmed(Qq'Image) else "");
   451.       Q_suffix  : constant String  := (if opcode in EaMqQ | TO_EaMqQ then "Q" else "");
   452.       modifier  : constant String  := M_suffix & Q_suffix;
   453.       one_digit : constant Boolean := (in_octal and operand < 8) or (not in_octal and operand < 10);
   454.       remark    : constant String
   455.                 := (
   456.                     if one_digit
   457.                     then ""
   458.                     elsif the_bare_name(1) = 'E'
   459.                     then ";(" & (if in_octal then as_decimal else "#" & as_octal) & ")"
   460.                     else ";(" & number & ")"
   461.                    );
   462.
   463.       the_name : constant String := the_bare_name & modifier & remark;
   464.
   465.    begin
   466.       return
   467.              (
   468.               case opcode is
   469.                  when EaMq
   470.                     | EaMqQ    => the_name,
   471.                  when TO_EaMq
   472.                     | TO_EaMqQ => "=" & the_name,
   473.                  when SET      => (if the_name(1) = 'E'
   474.                                    then
   475.                                       "SET"
   476.                                     & (if one_digit
   477.                                        then oct_of(operand, 1)
   478.                                        else
   479.                                            (
   480.                                             if in_octal
   481.                                             then "B" & as_octal
   482.                                                & (
   483.                                                   if operand > 7
   484.                                                   then ";(" & as_decimal & ")"
   485.                                                   else ""
   486.                                                  )
   487.                                             else as_decimal
   488.                                                & (
   489.                                                   if operand > 9
   490.                                                   then ";(B" & as_octal & ")"
   491.                                                   else ""
   492.                                                  )
   493.                                            )
   494.                                       )
   495.                                   else
   496.                                      "SETA" & the_bare_name & remark
   497.                                 ),
   498.                  when others   => "?"
   499.              );
   500.    end data_access_name;
   501.
   502.    function the_full_name_of (
   503.                               order      : KDF9.decoded_order;
   504.                               in_octal   : Boolean := True
   505.                              )
   506.    return String is
   507.       result : constant String
   508.          := (
   509.              case order.kind is
   510.                 when one_syllable_order => one_syllable_name(order),
   511.                 when two_syllable_order => two_syllable_name(order),
   512.                 when normal_jump_order  => normal_jump_name(order, in_octal),
   513.                 when data_access_order  => data_access_name(order, in_octal)
   514.             );
   515.    begin
   516.       return (if result(1) /= '?' then result else "an INVALID order");
   517.    end the_full_name_of;
   518.
   519.    function the_code_and_name_of_INS
   520.    return String
   521.    is (machine_code(INS) & ", i.e. " & the_full_name_of(INS, in_octal => True)); -- & short_closer(INS));
   522.
   523.    function two_syllable_skeleton (encoding : KDF9.syllable)
   524.    return String is
   525.
   526.       function IO_skeleton
   527.       return String
   528.       is (
   529.           case encoding and 8#77# is
   530.              when POA_POC_POE_POF_PMH_Qq => "{POA|POC|POE|POF|PMH}Qq",
   531.              when PIA_PIC_CLO_TLO_Qq     => "{PIA|PIC|CLO|TLO}Qq",
   532.              when CT_PMB_PMC_BUSY_Qq     => "{BUSY|CT|MANUAL|PMB|PMC}Qq",
   533.              when PAR_Qq                 => "PARQq",
   534.              when PIB_PID_Qq             => "{PIB|PID}Qq",
   535.              when PIE_PIG_Qq             => "{PIE|PIG}Qq",
   536.              when PIF_PIH_Qq             => "{PIF|PIH}Qq",
   537.              when PMA_PMK_INT_Qq         => "{INT|PMA|PMK}Qq",
   538.              when PMD_PME_PML_Qq         => "{PMD|PME}Qq",
   539.              when PMF_PMG_Qq             => "{PMF|PMG}Qq",
   540.              when POB_POD_Qq             => "{POB|POD}Qq",
   541.              when POG_POL_Qq             => "{POG|POL}Qq",
   542.              when POH_POK_Qq             => "{POH|POK}Qq",
   543.              when others                 => "invalid IO group syllable #" & oct_of(encoding)
   544.          );
   545.
   546.    begin  -- two_syllable_skeleton
   547.       return
   548.          (
   549.           case encoding and 8#77# is
   550.              when MkMq         => "MkMq",
   551.              when MkMqQ        => "MkMqQ",
   552.              when MkMqH        => "MkMqH",
   553.              when MkMqQH       => "MkMqQH",
   554.              when MkMqN        => "MkMqN",
   555.              when MkMqQN       => "MkMqQN",
   556.              when MkMqHN       => "MkMqHN",
   557.              when MkMqQHN      => "MkMqQHN",
   558.
   559.              when TO_MkMq      => "=MkMq",
   560.              when TO_MkMqQ     => "=MkMqQ",
   561.              when TO_MkMqH     => "=MkMqH",
   562.              when TO_MkMqQH    => "=MkMqQH",
   563.              when TO_MkMqN     => "=MkMqN",
   564.              when TO_MkMqQN    => "=MkMqQN",
   565.              when TO_MkMqHN    => "=MkMqHN",
   566.              when TO_MkMqQHN   => "=MkMqQHN",
   567.
   568.              when JCqNZS       => "JCqNZS",
   569.              when M_PLUS_Iq    => "M+Iq",
   570.              when M_MINUS_Iq   => "M-Iq",
   571.              when NCq          => "NCq",
   572.              when DCq          => "DCq",
   573.              when POS1_TO_Iq   => "Iq=+1",
   574.              when NEG1_TO_Iq   => "Iq=-1",
   575.              when POS2_TO_Iq   => "Iq=+2",
   576.              when NEG2_TO_Iq   => "Iq=-2",
   577.
   578.              when MqTOQk       => "MqTOQk",
   579.              when IqTOQk       => "IqTOQk",
   580.              when IMqTOQk      => "IMqTOQk",
   581.              when CqTOQk       => "CqTOQk",
   582.              when CMqTOQk      => "CMqTOQk",
   583.              when CIqTOQk      => "CIqTOQk",
   584.              when QqTOQk       => "QqTOQk",
   585.
   586.              when QCIMq        => "{Q|C|I|M}q",
   587.              when TO_RCIMq     => "=[R]{Q|C|I|M}q",
   588.              when ADD_TO_QCIMq => "=+{Q|C|I|M}q",
   589.
   590.              when SHA          => "SHA",
   591.              when SHAD         => "SHAD",
   592.              when MACC         => "×+",
   593.              when SHL          => "SHL",
   594.              when SHLD         => "SHLD",
   595.              when SHC          => "SHC",
   596.
   597.              when TO_Kq =>
   598.                 (
   599.                  case encoding / 16 mod 16 is
   600.                     when K0 => "=K0",
   601.                     when K1 => "=K1",
   602.                     when K2 => "=K2",
   603.                     when K3 => "=K3",
   604.                     when others => "=K?"
   605.                 ),
   606.              when Kk =>
   607.                 (
   608.                  case encoding mod 16 is
   609.                     when K4 => "K4",
   610.                     when K5 => "K5",
   611.                     when K7 => "K7",
   612.                     when others => "K?"
   613.                 ),
   614.
   615.              when LINK =>    "LINK",
   616.              when TO_LINK => "=LINK",
   617.
   618.              when others =>  IO_skeleton
   619.          );
   620.    end two_syllable_skeleton;
   621.
   622.    function normal_jump_skeleton (encoding : KDF9.syllable)
   623.    return String
   624.    is (
   625.        case encoding and 8#77# is
   626.           when JrCqZ  .. JrCqZ+2#1111#  => "JrCqZ",
   627.           when JrCqNZ .. JrCqNZ+2#1111# => "JrCqNZ",
   628.           when JrEQ   => "Jr=",
   629.           when JrGTZ  => "JrGTZ",
   630.           when JrLTZ  => "JrLTZ",
   631.           when JrEQZ  => "Jr=Z",
   632.           when JrV    => "JrV",
   633.           when JrEN   => "JrEN",
   634.           when Jr     => "Jr",
   635.           when JrEJ   => "JrEJ",
   636.           when JSr    => "JSr",
   637.           when JrTR   => "JrTR",
   638.           when EXIT_n => "EXIT",
   639.           when JrNE   => "Jr±",
   640.           when JrLEZ  => "JrLEZ",
   641.           when JrGEZ  => "JrGEZ",
   642.           when JrNEZ  => "Jr±Z",
   643.           when JrNV   => "JrNV",
   644.           when JrNEN  => "JrNEN",
   645.           when JrNEJ  => "JrNEJ",
   646.           when JrNTR  => "JrNTR",
   647.           when OS_OUT => "OUT",
   648.           when EXITD  => "EXITD",
   649.           when others => "invalid jump group syllable #" & oct_of(encoding)
   650.       );
   651.
   652.    function data_access_skeleton (compressed_opcode : KDF9.compressed_opcode)
   653.    return String
   654.    is (
   655.        case compressed_opcode is
   656.           when EaMq     => "EeMq",
   657.           when TO_EaMq  => "=EeMq",
   658.           when EaMqQ    => "EeMqQ",
   659.           when TO_EaMqQ => "=EeMqQ",
   660.           when SET      => "SET",
   661.           when others   => "invalid data access compressed opcode #" & oct_of(compressed_opcode)
   662.       );
   663.
   664.    function the_short_name_of (syllable_0 : KDF9.syllable)
   665.    return String is
   666.       its_INS : KDF9.decoded_order := (order => (syllable_0, 0, 0), others => <>);
   667.    begin
   668.       decode(its_INS);
   669.       return
   670.          (
   671.           case KDF9.INS_kind(syllable_0 / 2**6) is
   672.              when one_syllable_order   => one_syllable_name(its_INS),
   673.              when two_syllable_order   => two_syllable_skeleton(syllable_0),
   674.              when normal_jump_order    => normal_jump_skeleton(syllable_0),
   675.              when data_access_order    => data_access_skeleton(its_INS.compressed_opcode)
   676.          );
   677.    end the_short_name_of;
   678.
   679. end disassembly;

Compiling: ../Source/disassembly.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Produce dis-assembled instructions in an approximation to KDF9 Usercode.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18.
    19. use  KDF9;
    20.
    21. package disassembly is
    22.
    23.    function the_code_and_name_of_INS
    24.    return String;
    25.
    26.    function the_full_name_of (
    27.                               order      : KDF9.decoded_order;
    28.                               in_octal   : Boolean := True
    29.                              )
    30.    return String;
    31.
    32.    function closer (
    33.                     decoded  : KDF9.decoded_order;
    34.                     address  : KDF9.syllable_address := (0, 0);
    35.                     in_octal : Boolean := True
    36.                    )
    37.    return String;
    38.
    39.    function the_short_name_of (syllable_0 : KDF9.syllable)
    40.    return String;
    41.
    42. end disassembly;

 679 lines: No errors


Compiling: /home/parallels/emulation/Source/disassembly-symbols.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Map object code addresses to Usercode symbolic addresses.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with formatting;
    18.
    19. use  formatting;
    20.
    21. package body disassembly.symbols is
    22.
    23.    procedure set_Z_min is
    24.    begin
    25.       if the_WYZ_table.Y_max = 0 or the_WYZ_table.Y_base = KDF9.address'Last then
    26.          the_WYZ_table.Z_min := the_WYZ_table.Z_base - (the_WYZ_table.Y_base+the_WYZ_table.Z_base)/8;
    27.       else
    28.          the_WYZ_table.Z_min := the_WYZ_table.Y_base + the_WYZ_table.Y_max;
    29.       end if;
    30.    end set_Z_min;
    31.
    32.    procedure define_W0 (address : in KDF9.address) is
    33.    begin
    34.       the_WYZ_table.W_base := address;
    35.    end define_W0;
    36.
    37.    procedure define_Y0 (address : in KDF9.address) is
    38.    begin
    39.       the_WYZ_table.Y_base := address;
    40.    end define_Y0;
    41.
    42.    procedure define_Z0 (address : in KDF9.address) is
    43.    begin
    44.       the_WYZ_table.Z_base := address;
    45.       set_Z_min;
    46.    end define_Z0;
    47.
    48.    procedure define_Yy0 (x : in Y_store_id; address : in KDF9.address) is
    49.    begin
    50.       the_WYZ_table.Yy_base(x) := address;
    51.    end define_Yy0;
    52.
    53.    function Y_symbol (address : KDF9.address)
    54.    return String is
    55.    begin
    56.       if address >= the_WYZ_table.Z_min then
    57.          return "Z" & trimmed(KDF9.address'Image(the_WYZ_table.Z_base - address));
    58.       end if;
    59.       if address >= the_WYZ_table.Y_base then
    60.          return "Y" & trimmed(KDF9.address'Image(address - the_WYZ_table.Y_base));
    61.       end if;
    62.       for y in reverse Y_store_id loop
    63.          if address >= the_WYZ_table.Yy_base(y) then
    64.             return "Y" & y & trimmed(KDF9.address'Image(address - the_WYZ_table.Yy_base(y))) ;
    65.          end if;
    66.       end loop;
    67.       if address >= the_WYZ_table.W_base then
    68.          return "W" & trimmed(KDF9.address'Image(address - the_WYZ_table.W_base));
    69.       end if;
    70.       return "E" & trimmed(KDF9.address'Image(address));
    71.    end Y_symbol;
    72.
    73.    procedure declare_P0 (P0v : in KDF9.address) is
    74.    begin
    75.       V_store_base(0) := (P_number => 0, V_count => P0v, P_address => P0v+8,  V_address => 8);
    76.    end declare_P0;
    77.
    78.    procedure define_Y_size (size : in KDF9.address) is
    79.    begin
    80.       the_WYZ_table.Y_max := size;
    81.    end define_Y_size;
    82.
    83.    procedure declare_Pp (P_number : in Natural; V_count, P_address : in KDF9.address) is
    84.       V_address : constant KDF9.address := P_address - V_count;
    85.    begin
    86.       last_P_number := last_P_number + 1;
    87.       if last_P_number not in 0 .. 999 then
    88.          raise Program_Error with "number of V store bases >" & Integer'Image(V_store_base'Last);
    89.       end if;
    90.       V_store_base(last_P_number)   := (P_number, V_count, P_address, V_address);
    91.       V_store_base(last_P_number+1) := (8191, 8191, 8191, 8191);
    92.    end declare_Pp;
    93.
    94.    function V_symbol (address : KDF9.address; in_octal : Boolean; not_for_SET : Boolean := True)
    95.    return String is
    96.    begin
    97.       if address > 255 or not_for_SET then
    98.          for p in 0 .. last_P_number loop
    99.          exit when address < V_store_base(p).V_address;
   100.             if V_store_base(p).V_count /= 0                                       and then
   101.                   address in V_store_base(p).V_address .. V_store_base(p).P_address   then
   102.                   -- N.B. NOT "V_store_base(p).P_address-1" to avoid wrap-around.
   103.                return "V"
   104.                     & trimmed(KDF9.address'Image(address - V_store_base(p).V_address))
   105.                     & "P"
   106.                     & trimmed(Natural'Image(V_store_base(p).P_number));
   107.             end if;
   108.          end loop;
   109.       end if;
   110.       return "E"
   111.            & (if in_octal then "#" & oct_of(address, 1) else trimmed(KDF9.address'Image(address)));
   112.    end V_symbol;
   113.
   114.    function P_symbol (address : KDF9.syllable_address; in_octal : Boolean)
   115.    return String is
   116.    begin
   117.       for p in 0 .. last_P_number loop
   118.          if KDF9.address(address.code_address) = V_store_base(p).P_address then
   119.             return "P" & trimmed(Natural'Image(V_store_base(p).P_number));
   120.          end if;
   121.       end loop;
   122.       return "E" & oct_or_dec_of(address, in_octal);
   123.    end P_symbol;
   124.
   125.    function symbolic (address : KDF9.address; in_octal : Boolean; not_for_SET : Boolean := True)
   126.    return String is
   127.       Y_store : constant String := Y_symbol(address);
   128.    begin
   129.      return (if Y_store(1) = 'E' then V_symbol(address, in_octal, not_for_SET) else Y_store);
   130.    end symbolic;
   131.
   132.    procedure clear_all_symbol_definitions is
   133.    begin
   134.       the_WYZ_table.Yy_base := (others => KDF9.address'Last);
   135.       V_store_base  := (others => (0, 0, 0, 0));
   136.       last_P_number := 0;
   137.       V_store_base(0) := (P_number => 0, V_count => 0, P_address => 8,  V_address => 8);
   138.    end clear_all_symbol_definitions;
   139.
   140. end disassembly.symbols;

Compiling: ../Source/disassembly-symbols.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1.  -- Map object code addresses to Usercode symbolic addresses.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package disassembly.symbols is
    18.
    19.    procedure clear_all_symbol_definitions;
    20.
    21.    procedure declare_P0 (P0v : in KDF9.address);
    22.    procedure declare_Pp (P_number : in Natural; V_count, P_address : in KDF9.address);
    23.
    24.    procedure define_Y_size (size : in KDF9.address);
    25.
    26.    procedure define_W0 (address : in KDF9.address);
    27.    procedure define_Y0 (address : in KDF9.address);
    28.    procedure define_Z0 (address : in KDF9.address);
    29.
    30.    subtype Y_store_id is Character range 'A' ..'Z';
    31.
    32.    procedure define_Yy0 (x : in Y_store_id; address : in KDF9.address);
    33.
    34.    function P_symbol (address : KDF9.syllable_address; in_octal : Boolean)
    35.    return String;
    36.
    37.    function symbolic (address : KDF9.address; in_octal : Boolean; not_for_SET : Boolean := True)
    38.    return String;
    39.
    40.    last_P_number : Integer range -1 .. 1000 := -1;
    41.
    42.    type V_definition is
    43.    record
    44.       P_number  : Natural;
    45.       V_count   : KDF9.address;
    46.       P_address : KDF9.address;
    47.       V_address : KDF9.address;
    48.    end record;
    49.
    50.    type V_definition_list is array (Natural range <>) of V_definition;
    51.
    52.    V_store_base : V_definition_list (0 .. 1000);
    53.
    54.    type address_list is array (Y_store_id) of KDF9.address;
    55.
    56.    type non_V_store_table is
    57.       record
    58.          Yy_base : address_list := (others => KDF9.address'Last);
    59.          W_base  : KDF9.address := KDF9.address'Last;
    60.          Y_base  : KDF9.address := KDF9.address'Last;
    61.          Y_max   : KDF9.address := 0;
    62.          Z_base  : KDF9.address := KDF9.address'Last;
    63.          Z_min   : KDF9.address := KDF9.address'Last;
    64.       end record;
    65.
    66.    the_WYZ_table : non_V_store_table;
    67.
    68. end disassembly.symbols;

 140 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/postscript.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Elementary Encapsulated PostScript (EPS) line drawing.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body postscript is
    18.
    19.    use host_IO;
    20.
    21.    -- A path is a series of vectors v1, v2, ..., vn such that the last point
    22.    --    of vi is the same as the first point of v(i+1),
    23.    --       and v1, ..., vn are all drawn in the same colour.
    24.    -- A new path is started by a jump to a non-contiguous point or by a change of pen colour.
    25.
    26.    there_is_an_open_path      : Boolean := False;
    27.    the_last_point_in_the_path : postscript.point := (0, 0);
    28.
    29.    -- The bounding box limits are set from the value of maximum_offset at the end of the plot.
    30.    maximum_offset             : postscript.point := (0, 0);
    31.
    32.    procedure ensure_separation (stream : in out host_IO.stream) is
    33.    begin
    34.       if column(stream) > 0 then
    35.          put_byte(' ', stream);
    36.       end if;
    37.    end ensure_separation;
    38.
    39.    procedure put (stream : in out host_IO.stream; PS_text : String) is
    40.    begin
    41.       put_bytes(PS_text, stream);
    42.    end put;
    43.
    44.    procedure put_unit (stream : in out host_IO.stream; PS_text : String) is
    45.    begin
    46.       ensure_separation(stream);
    47.       put(stream, PS_text);
    48.    end put_unit;
    49.
    50.    procedure put_line (stream : in out host_IO.stream; PS_text : String) is
    51.    begin
    52.       put(stream, PS_text);
    53.       put_EOL(stream);
    54.    end put_line;
    55.
    56.    procedure put_unit_line (stream : in out host_IO.stream; PS_text : String) is
    57.    begin
    58.       put_unit(stream, PS_text);
    59.       put_EOL(stream);
    60.    end put_unit_line;
    61.
    62.    procedure put_integer (stream : in out host_IO.stream; i : Integer) is
    63.       integer_image  : constant String := i'Image;
    64.    begin
    65.       ensure_separation(stream);
    66.       if integer_image(integer_image'First) /= ' ' then
    67.          put(stream, integer_image);
    68.       else  -- Suppress the nuisance blank character.
    69.          put(stream, integer_image(integer_image'First+1..integer_image'Last));
    70.       end if;
    71.    end put_integer;
    72.
    73.    procedure terminate_any_open_path (stream : in out host_IO.stream) is
    74.    begin
    75.       if there_is_an_open_path then
    76.          -- Draw the accumulated strokes.
    77.          put_unit_line(stream, "s");
    78.       end if;
    79.       there_is_an_open_path := False;
    80.    end terminate_any_open_path;
    81.
    82.    procedure draw_a_PS_vector (stream : in out host_IO.stream;
    83.                                initial,
    84.                                final  : in postscript.point) is
    85.
    86.       function largest_of (a, b, c : Natural)
    87.       return Natural
    88.       is (Natural'Max(a, Natural'Max(b, c)));
    89.
    90.    begin -- draw_a_PS_vector
    91.       if initial /= the_last_point_in_the_path then
    92.          -- This vector is not contiguous with the previous one.
    93.          terminate_any_open_path(stream);
    94.       end if;
    95.       if initial = final then
    96.          -- This vector is of length 0.
    97.          return;
    98.       end if;
    99.       maximum_offset.x := largest_of(maximum_offset.x, initial.x, final.x);
   100.       maximum_offset.y := largest_of(maximum_offset.y, initial.y, final.y);
   101.       if there_is_an_open_path then
   102.          -- Draw a line to the final point, extending the current path.
   103.          put_integer(stream, final.x);
   104.          put_integer(stream, final.y);
   105.          put_unit_line(stream, "l");
   106.       else
   107.          -- Move to the initial point, opening a fresh path, and draw a line to the final point.
   108.          put_integer(stream, final.x);
   109.          put_integer(stream, final.y);
   110.          put_integer(stream, initial.x);
   111.          put_integer(stream, initial.y);
   112.          put_unit_line(stream, "n");
   113.          there_is_an_open_path := True;
   114.       end if;
   115.       the_last_point_in_the_path := final;
   116.    end draw_a_PS_vector;
   117.
   118.    subtype RGB is String(1..11);
   119.    gamut : constant array (pen_colour) of RGB
   120.          := (
   121.                Black          => ".00 .00 .00",
   122.                Blue           => ".00 .00 1.0",
   123.                Brown          => ".60 .20 .00",
   124.                Cyan           => ".00 1.0 1.0",
   125.                Dark_Blue      => ".10 .10 .80",
   126.                Dark_Cyan      => ".20 .80 1.0",
   127.                Dark_Green     => ".00 .60 .40",
   128.                Dark_Grey      => ".50 .50 .50",
   129.                Dark_Magenta   => ".75 .25 .75",
   130.                Dark_Red       => ".75 .00 .00",
   131.                Green          => ".00 1.0 .00",
   132.                Grey           => ".80 .80 .80",
   133.                Magenta        => "1.0 .00 1.0",
   134.                Red            => "1.0 .00 .00",
   135.                White          => "1.0 1.0 1.0",
   136.                Yellow         => "1.0 1.0 .00"
   137.             );
   138.
   139.    subtype tip_breadth is String(1..4);
   140.    breadth : constant array (pen_tip_size) of tip_breadth
   141.            := (
   142.                Extra_Extra_Fine => "1.00",
   143.                Extra_Fine       => "2.00",
   144.                Fine             => "4.00",
   145.                Medium           => "6.00",
   146.                Medium_Broad     => "8.00",
   147.                Broad            => "10.0",
   148.                Extra_Broad      => "12.0"
   149.               );
   150.
   151.    the_colour   : pen_colour   := the_default_colour;
   152.    the_pen_size : pen_tip_size := the_default_tip_size;
   153.
   154.    procedure put_the_pen_settings (stream : in out host_IO.Stream) is
   155.    begin -- put_the_pen_settings
   156.       terminate_any_open_path(stream);
   157.       put_unit(stream, gamut(the_colour));
   158.       put_unit_line(stream, "setrgbcolor");
   159.       put_unit(stream, breadth(the_pen_size));
   160.       put_unit_line(stream, "setlinewidth");
   161.    end put_the_pen_settings;
   162.
   163.    procedure set_the_pen_properties (this_colour   : in pen_colour   := the_default_colour;
   164.                                      this_pen_size : in pen_tip_size := the_default_tip_size) is
   165.    begin -- set_the_pen_properties
   166.       the_colour := this_colour;
   167.       the_pen_size := this_pen_size;
   168.    end set_the_pen_properties;
   169.
   170.    -- We eventually seek back to the bounding box parametsrs using this, their file offset.
   171.    the_position_of_the_placeholders : Natural;
   172.
   173.    procedure initialize_PS_output (stream : in out host_IO.Stream) is
   174.
   175.    begin -- initialize_PS_output
   176.       put_line(stream, "%!PS-Adobe-3.0 EPSF-1.0");
   177.       put_unit(stream, "%%BoundingBox: ");
   178.
   179.       -- Note the file offset of the bounding box placeholders.
   180.       get_position(the_position_of_the_placeholders, stream);
   181.
   182.       -- Write the 12-column placeholders.
   183.       put_line(stream, "xxxxxxxxxxxx|yyyyyyyyyyyy");
   184.
   185.       put_line(stream, "% This graph was plotted by ee9, the GNU Ada KDF9 emulator.");
   186.       put_line(stream, "% For more information, see <http://www.findlayw.plus.com/KDF9>.");
   187.       put_line(stream, "save");
   188.
   189.       put_line(stream, "1 setlinecap");
   190.       put_line(stream, "1 setlinejoin");
   191.
   192.       put_the_pen_settings(stream);
   193.
   194.       put_line(stream, "0 792 translate");  -- Assumes a page of length 11"!
   195.
   196.       -- The plotter step was 0.005", which is the same as 0.36 PostScript points.
   197.       -- The scaling factor is set here to make the wabbit example fit an A4 page.
   198.       put_line(stream, "0.12 -0.12 scale");
   199.
   200.       put_line(stream, "/l { lineto } bind def");
   201.       put_line(stream, "/n { newpath moveto lineto } bind def");
   202.       put_line(stream, "/s { stroke } bind def");
   203.
   204.       put_line(stream, "save");
   205.    end initialize_PS_output;
   206.
   207.    procedure finalize_PS_output (stream : in out host_IO.Stream) is
   208.
   209.       subtype bound_string is String(1..12);
   210.
   211.       function bound_image (n : in Natural)
   212.       return bound_string is
   213.          n_image : constant String := n'Image;
   214.       begin
   215.          return b : bound_string := (others => ' ') do
   216.             b(b'Last-n_image'Length+1 .. b'Last) := n_image;
   217.          end return;
   218.       end bound_image;
   219.
   220.    begin -- finalize_PS_output
   221.       terminate_any_open_path(stream);
   222.       put_line(stream, "showpage");
   223.       put_line(stream, "restore");
   224.       put_line(stream, "restore");
   225.       put_line(stream, "% End of plot");
   226.
   227.       -- Go back to the bounding box placeholders in the output file.
   228.       set_position(the_position_of_the_placeholders, stream);
   229.
   230.       -- Overwrite them with the actual x and y co-ordinate bounds.
   231.       put(stream, bound_image(maximum_offset.x));
   232.       put(stream, " ");
   233.       put(stream, bound_image(maximum_offset.y));
   234.
   235.       close(stream);
   236.    end finalize_PS_output;
   237.
   238. end postscript;
   239.

Compiling: ../Source/postscript.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Elementary Encapsulated PostScript (EPS) line drawing.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with host_IO;
    18.
    19. package postscript is
    20.
    21.    type pen_colour is (
    22.                        Black,
    23.                        Blue,
    24.                        Brown,
    25.                        Cyan,
    26.                        Dark_Blue,
    27.                        Dark_Cyan,
    28.                        Dark_Green,
    29.                        Dark_Grey,
    30.                        Dark_Magenta,
    31.                        Dark_Red,
    32.                        Green,
    33.                        Grey,
    34.                        Magenta,
    35.                        Red,
    36.                        White,
    37.                        Yellow
    38.                       );
    39.
    40.    the_default_colour : constant pen_colour := Black;
    41.
    42.    type pen_tip_size is (
    43.                          Extra_Extra_Fine,
    44.                          Extra_Fine,
    45.                          Fine,
    46.                          Medium,
    47.                          Medium_Broad,
    48.                          Broad,
    49.                          Extra_Broad
    50.                         );
    51.
    52.    the_default_tip_size : constant pen_tip_size := Extra_Extra_Fine;
    53.
    54.    -- Choose the pen's colour and tip size.
    55.
    56.    procedure set_the_pen_properties (this_colour   : in pen_colour   := the_default_colour;
    57.                                      this_pen_size : in pen_tip_size := the_default_tip_size);
    58.
    59.    -- Drawing is done in terms of the plotter's co-ordinate system.
    60.    -- (0, 0) is the top left point of the drawing,
    61.    -- The x axis increases down the plot (long axis, direction of paper movement),
    62.    --    and the y axis increases across the plot (short axis, direction of pen movement).
    63.
    64.    type point is
    65.      record
    66.         x, y : Natural;  -- All physically possible co-ordinates are non-negative.
    67.      end record;
    68.
    69.    -- Draw a straight line from initial to final.
    70.    procedure draw_a_PS_vector (stream : in out host_IO.stream;
    71.                                initial,
    72.                                final  : in postscript.point);
    73.
    74.    -- Open the PostScript file and write the prelude, with a placeholder for the bounds.
    75.    procedure initialize_PS_output (stream : in out host_IO.Stream);
    76.
    77.    -- Close the PostScript file, having gone back to overwrite the bounding box placeholders.
    78.    procedure finalize_PS_output (stream : in out host_IO.Stream);
    79.
    80. end postscript;

 239 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/settings-io.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Settings-reader I/O support.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Latin_1;
    18. --
    19. with file_interfacing;
    20. with KDF9;
    21.
    22. use  Ada.Characters.Latin_1;
    23.
    24. package body settings.IO is
    25.
    26.    procedure open_options_file (file : in out File_Type; name : in String) is
    27.    begin
    28.       file_interfacing.initialize(file, in_file, name);
    29.       line_number := 1;
    30.    exception
    31.       when others =>
    32.          raise Status_Error with name;
    33.    end open_options_file;
    34.
    35.    procedure close_options_file (file : in out File_Type; name : in String) is
    36.    begin
    37.       file_interfacing.finalize(file, name);
    38.    end close_options_file;
    39.
    40.    comment_flag_character : constant Character := '|';
    41.
    42.    procedure skip_to_next_non_blank (file : File_Type) is
    43.       next_char : Character := ' ';
    44.       end_line  : Boolean;
    45.    begin
    46.       loop
    47.         look_ahead(file, next_char, end_line);
    48.       exit when end_line or else (next_char not in ' ' | HT);
    49.          get(file, next_char);
    50.       end loop;
    51.       if next_char = comment_flag_character then
    52.          while not end_of_line(file) loop
    53.             get(file, next_char);
    54.          end loop;
    55.       end if;
    56.    end skip_to_next_non_blank;
    57.
    58.    procedure ensure_not_at_end_of_line (file : File_Type) is
    59.    begin
    60.       skip_to_next_non_blank (file);
    61.       if end_of_line(file) then
    62.          raise Data_Error;
    63.       end if;
    64.    end ensure_not_at_end_of_line;
    65.
    66.    procedure skip_to_next_nonempty_line (file : in File_Type) is
    67.       flag     : Character;
    68.       end_line : Boolean;
    69.    begin
    70.       loop
    71.          look_ahead(file, flag, end_line);
    72.          if end_line                      or else
    73.                flag = comment_flag_character then
    74.             Skip_Line(file);
    75.             line_number := line_number + 1;
    76.          else
    77.             exit;
    78.          end if;
    79.       end loop;
    80.       if flag = comment_flag_character then
    81.          raise Data_Error;
    82.       end if;
    83.    end skip_to_next_nonempty_line;
    84.
    85.    digit_offset : constant := Character'Pos('0');
    86.
    87.    procedure get_octal (file : in File_Type; value : out KDF9.word) is
    88.       next_char : Character;
    89.       last_char : Character := '_';
    90.       place     : Natural   := 0;
    91.       end_line  : Boolean   := False;
    92.    begin
    93.       value := 0;
    94.       ensure_not_at_end_of_line(file);
    95.       get(file, next_char);
    96.       if next_char = '#' then
    97.          get(file, next_char);
    98.       else
    99.          raise Data_Error;
   100.       end if;
   101.       loop
   102.          if next_char in '0' .. '7' then
   103.             value := value*8 + KDF9.word(Character'Pos(next_char)-digit_offset);
   104.             place := place + 1;
   105.             if place > 16 then
   106.                raise Data_Error;
   107.             end if;
   108.          elsif next_char = '_' then
   109.             if place = 0 then
   110.                raise Data_Error;
   111.             end if;
   112.          else
   113.             if last_char = '_' or place = 0 then
   114.                raise Data_Error;
   115.             end if;
   116.             exit;
   117.          end if;
   118.          last_char := next_char;
   119.          look_ahead(file, next_char, end_line);
   120.       exit when end_line;
   121.          if next_char in '0' .. '7' or next_char = '_' then
   122.             get(file, next_char);
   123.          else
   124.             if last_char = '_' or place = 0 then
   125.                raise Data_Error;
   126.             end if;
   127.             exit;
   128.          end if;
   129.       end loop;
   130.    end get_octal;
   131.
   132.    procedure get_decimal (file : in File_Type; value : out KDF9.word) is
   133.       next_char : Character;
   134.       last_char : Character := '_';
   135.       place     : Natural   := 0;
   136.       negative  : Boolean   := False;
   137.       end_line  : Boolean   := False;
   138.    begin
   139.       value := 0;
   140.       ensure_not_at_end_of_line(file);
   141.       get(file, next_char);
   142.       if next_char = '-' then
   143.          negative := True;
   144.          get(file, next_char);
   145.       elsif next_char not in '0' .. '9' then
   146.          raise Data_Error with "get_decimal " & next_char;
   147.       end if;
   148.       loop
   149.          if next_char in '0' .. '9' then
   150.             value := value*10 + KDF9.word(Character'Pos(next_char)-digit_offset);
   151.             place := place + 1;
   152.             if place > 15 then
   153.                raise Data_Error;
   154.             end if;
   155.          elsif next_char = '_' then
   156.             if place = 0 then
   157.                raise Data_Error;
   158.             end if;
   159.          else
   160.             if last_char = '_' or place = 0 then
   161.                raise Data_Error;
   162.             end if;
   163.       exit;
   164.          end if;
   165.          last_char := next_char;
   166.          look_ahead(file, next_char, end_line);
   167.       exit when end_line;
   168.          if next_char in '0' .. '9' or next_char = '_' then
   169.             get(file, next_char);
   170.          else
   171.             if last_char = '_' or place = 0 then
   172.                raise Data_Error;
   173.             end if;
   174.       exit;
   175.          end if;
   176.       end loop;
   177.       if negative then
   178.          value := - value;
   179.       end if;
   180.    end get_decimal;
   181.
   182.    procedure get_word (file : in File_Type; value : out KDF9.word) is
   183.       next_char : Character;
   184.       end_line  : Boolean;
   185.    begin
   186.       ensure_not_at_end_of_line(file);
   187.       look_ahead(file, next_char, end_line);
   188.       pragma Unreferenced(end_line);
   189.       if next_char = '#' then
   190.          get_octal(file, value);
   191.       else
   192.          get_decimal(file, value);
   193.       end if;
   194.    end get_word;
   195.
   196.    procedure get_char (file : in File_Type; value : out Character) is
   197.       end_line : Boolean;
   198.       char     : Character;
   199.    begin
   200.       ensure_not_at_end_of_line(file);
   201.       look_ahead(file, char, end_line);
   202.       if end_line then
   203.          raise Data_Error;
   204.       end if;
   205.       if char /= ' ' then
   206.          get(file, value);
   207.       end if;
   208.    end get_char;
   209.
   210. end settings.IO;
   211.

Compiling: ../Source/settings-io.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Settings-reader I/O support.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18. --
    19. with postscript;
    20.
    21. use  Ada.Text_IO;
    22.
    23. package settings.IO is
    24.
    25.    line_number : Natural := 0;
    26.
    27.    procedure open_options_file (file : in out File_Type; name : in String);
    28.
    29.    procedure close_options_file (file : in out File_Type; name : in String);
    30.
    31.    -- Check that the end of the line has not yet been reached, else raise Data_Error.
    32.    procedure ensure_not_at_end_of_line (file : in File_Type);
    33.
    34.    -- Move the reading position to the next non-blank or EOL, skipping comment.
    35.    procedure skip_to_next_non_blank (file : in File_Type);
    36.
    37.    -- Discard input until a non-empty line is reached,
    38.    --    leaving the reading position at the start of that line,
    39.    --    and incrementing line_number for each line terminator passed.
    40.    procedure skip_to_next_nonempty_line (file : in File_Type);
    41.
    42.    -- Read octal digits string as KDF9.word,
    43.    --    raising Data_Error on overflow or bad syntax.
    44.    procedure get_octal (file : in File_Type; value : out KDF9.word);
    45.
    46.    -- Read decimal digits string as KDF9.word,
    47.    --    raising Data_Error on overflow or bad syntax.
    48.    procedure get_decimal (file  : in File_Type; value : out KDF9.word);
    49.
    50.    -- Read an address as a KDF9.word in either octal or decimal,
    51.    --    using get_octal or get_decimal as indicated by the syntax.
    52.    procedure get_word (file : in File_Type; value : out KDF9.word);
    53.
    54.    -- Read the character value immediately following an octal or decimal number,
    55.    --    if it is not a space character; if it is a space, leave value unchanged.
    56.    procedure get_char (file : in File_Type; value : out Character);
    57.
    58.    package colour_IO is new Ada.Text_IO.Enumeration_IO(postscript.pen_colour);
    59.    package  width_IO is new Ada.Text_IO.Enumeration_IO(postscript.pen_tip_size);
    60.
    61. end settings.IO;

 211 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/generic_sets.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Powersets of a discrete member type.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. -- generic
    18. --    type member is (<>);
    19. package body generic_sets is
    20.
    21.    function "/" (set : generic_sets.set; member : generic_sets.member)
    22.    return Boolean
    23.    is (set(member));
    24.
    25.    function "or" (set : generic_sets.set; member : generic_sets.member)
    26.    return generic_sets.set is
    27.    begin
    28.       return result : generic_sets.set := set do
    29.          result(member) := True;
    30.       end return;
    31.    end "or";
    32.
    33.    function "-" (set1, set2 : generic_sets.set)
    34.    return generic_sets.set is
    35.    begin -- Compute (set1 and not set2), avoiding need for a potentially large workspace.
    36.       return result : generic_sets.set := set1 do
    37.          for m in generic_sets.member loop
    38.             if set2(m) then
    39.                result(m) := False;
    40.             end if;
    41.          end loop;
    42.       end return;
    43.    end "-";
    44.
    45. end generic_sets;

Compiling: ../Source/generic_sets.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Powersets of a discrete member type.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. generic
    18.    type member is (<>);
    19. package generic_sets is
    20.
    21.    pragma Preelaborate;
    22.
    23. --
    24. -- This package implements only those set operations that are needed by ee9.
    25. --
    26.
    27.    type set is array (generic_sets.member) of Boolean
    28.       with Component_Size => 1;
    29.
    30.    empty_set : constant generic_sets.set := (others => False);
    31.
    32.    -- Test for membership of the set.
    33.    function "/" (set : generic_sets.set; member : generic_sets.member)
    34.    return Boolean with Inline;
    35.
    36.    -- Union of a set and a singleton.
    37.    function "or"  (set : generic_sets.set; member : generic_sets.member)
    38.    return generic_sets.set;
    39.
    40.    -- Computes (set1 and not set2).
    41.    function "-" (set1, set2 : generic_sets.set)
    42.    return generic_sets.set;
    43.
    44. end generic_sets;

 45 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-dispatcher.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- CPU I/O orders are dispatched here to device-specific handlers within the IOC type hierarchy.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9.PHU_store;
    18. with tracing;
    19.
    20. use  tracing;
    21.
    22. package body IOC.dispatcher is
    23.
    24.    --
    25.    --
    26.    -- CLO, SLO and TLO do not operate on a buffer, and so can be fully implemented here.
    27.    --
    28.    --
    29.
    30.    procedure CLO (Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean) is
    32.       pragma Unreferenced(set_offline);
    33.       use  KDF9.PHU_store;
    34.    begin
    35.       -- This is a Director-only instruction.
    36.       take_note_of_test("   ", Q_operand, False);
    37.       unlock_absolute_addresses(Q_operand);
    38.       -- CLO also clears PHU[CPL].
    39.       PHU(CPL) := idle_PHU;
    40.       add_in_the_IO_lockout_CPU_time(Q_operand);
    41.    end CLO;
    42.
    43.    procedure SLO (Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean) is
    45.       pragma Unreferenced(set_offline);
    46.    begin
    47.       -- This is a Director-only instruction.
    48.       take_note_of_test("   ", Q_operand, False);
    49.       lock_out_absolute_addresses(Q_operand);
    50.       add_in_the_IO_lockout_CPU_time(Q_operand);
    51.    end SLO;
    52.
    53.    procedure TLO (Q_operand   : in KDF9.Q_register;
    54.                   result      : out Boolean) is
    55.    begin
    56.       -- This is NOT Director-only.
    57.       result := there_are_locks_in_relative_addresses(Q_operand);
    58.       take_note_of_test("   ", Q_operand, result);
    59.       add_in_the_IO_lockout_CPU_time(Q_operand);
    60.    end TLO;
    61.
    62.    --
    63.    --
    64.    -- All other I/O orders do access a buffer, and so dispatch to the relevant device driver.
    65.    --
    66.    --
    67.
    68.    procedure BUSY (Q_operand   : in KDF9.Q_register;
    69.                    set_offline : in Boolean;
    70.                    result      : out Boolean) is
    71.    begin
    72.       buffer(Q_operand.C and buffer_number_mask).BUSY(Q_operand, set_offline, result);
    73.    end BUSY;
    74.
    75.    procedure PAR (Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean;
    77.                   result      : out Boolean) is
    78.    begin
    79.       buffer(Q_operand.C and buffer_number_mask).PAR(Q_operand, set_offline, result);
    80.    end PAR;
    81.
    82.    procedure MANUAL_CT (Q_operand   : in KDF9.Q_register;
    83.                         set_offline : in Boolean) is
    84.    begin
    85.       buffer(Q_operand.C and buffer_number_mask).MANUAL_CT(Q_operand, set_offline);
    86.    end MANUAL_CT;
    87.
    88.    procedure INT (Q_operand   : in KDF9.Q_register;
    89.                   set_offline : in Boolean) is
    90.    begin
    91.       buffer(Q_operand.C and buffer_number_mask).INT(Q_operand, set_offline);
    92.    end INT;
    93.
    94.    procedure PIA (Q_operand   : in KDF9.Q_register;
    95.                   set_offline : in Boolean) is
    96.    begin
    97.       buffer(Q_operand.C and buffer_number_mask).PIA(Q_operand, set_offline);
    98.       add_in_the_IO_lockout_CPU_time(Q_operand);
    99.    end PIA;
   100.
   101.    procedure PIB (Q_operand   : in KDF9.Q_register;
   102.                   set_offline : in Boolean) is
   103.    begin
   104.       buffer(Q_operand.C and buffer_number_mask).PIB(Q_operand, set_offline);
   105.       add_in_the_IO_lockout_CPU_time(Q_operand);
   106.    end PIB;
   107.
   108.    procedure PIC (Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean) is
   110.    begin
   111.       buffer(Q_operand.C and buffer_number_mask).PIC(Q_operand, set_offline);
   112.       add_in_the_IO_lockout_CPU_time(Q_operand);
   113.    end PIC;
   114.
   115.    procedure PID (Q_operand   : in KDF9.Q_register;
   116.                   set_offline : in Boolean) is
   117.    begin
   118.       buffer(Q_operand.C and buffer_number_mask).PID(Q_operand, set_offline);
   119.       add_in_the_IO_lockout_CPU_time(Q_operand);
   120.    end PID;
   121.
   122.    procedure PIE (Q_operand   : in KDF9.Q_register;
   123.                   set_offline : in Boolean) is
   124.    begin
   125.       buffer(Q_operand.C and buffer_number_mask).PIE(Q_operand, set_offline);
   126.       add_in_the_IO_lockout_CPU_time(Q_operand);
   127.    end PIE;
   128.
   129.    procedure PIF (Q_operand   : in KDF9.Q_register;
   130.                   set_offline : in Boolean) is
   131.    begin
   132.       buffer(Q_operand.C and buffer_number_mask).PIF(Q_operand, set_offline);
   133.       add_in_the_IO_lockout_CPU_time(Q_operand);
   134.    end PIF;
   135.
   136.    procedure PIG (Q_operand   : in KDF9.Q_register;
   137.                   set_offline : in Boolean) is
   138.    begin
   139.       buffer(Q_operand.C and buffer_number_mask).PIG(Q_operand, set_offline);
   140.       add_in_the_IO_lockout_CPU_time(Q_operand);
   141.    end PIG;
   142.
   143.    procedure PIH (Q_operand   : in KDF9.Q_register;
   144.                   set_offline : in Boolean) is
   145.    begin
   146.       buffer(Q_operand.C and buffer_number_mask).PIH(Q_operand, set_offline);
   147.       add_in_the_IO_lockout_CPU_time(Q_operand);
   148.    end PIH;
   149.
   150.    procedure PMA (Q_operand   : in KDF9.Q_register;
   151.                   set_offline : in Boolean) is
   152.    begin
   153.       buffer(Q_operand.C and buffer_number_mask).PMA(Q_operand, set_offline);
   154.    end PMA;
   155.
   156.    procedure PMB (Q_operand   : in KDF9.Q_register;
   157.                   set_offline : in Boolean) is
   158.    begin
   159.       buffer(Q_operand.C and buffer_number_mask).PMB(Q_operand, set_offline);
   160.    end PMB;
   161.
   162.    procedure PMC (Q_operand   : in KDF9.Q_register;
   163.                   set_offline : in Boolean) is
   164.    begin
   165.       buffer(Q_operand.C and buffer_number_mask).PMC(Q_operand, set_offline);
   166.    end PMC;
   167.
   168.    procedure PMD (Q_operand   : in KDF9.Q_register;
   169.                   set_offline : in Boolean) is
   170.    begin
   171.       buffer(Q_operand.C and buffer_number_mask).PMD(Q_operand, set_offline);
   172.    end PMD;
   173.
   174.    procedure PME (Q_operand   : in KDF9.Q_register;
   175.                   set_offline : in Boolean) is
   176.    begin
   177.       buffer(Q_operand.C and buffer_number_mask).PME(Q_operand, set_offline);
   178.    end PME;
   179.
   180.    procedure PMF (Q_operand   : in KDF9.Q_register;
   181.                   set_offline : in Boolean) is
   182.    begin
   183.       buffer(Q_operand.C and buffer_number_mask).PMF(Q_operand, set_offline);
   184.    end PMF;
   185.
   186.    procedure PMG (Q_operand   : in KDF9.Q_register;
   187.                   set_offline : in Boolean) is
   188.    begin
   189.       buffer(Q_operand.C and buffer_number_mask).PMG(Q_operand, set_offline);
   190.    end PMG;
   191.
   192.    procedure PMK (Q_operand   : in KDF9.Q_register;
   193.                   set_offline : in Boolean) is
   194.    begin
   195.       buffer(Q_operand.C and buffer_number_mask).PMK(Q_operand, set_offline);
   196.    end PMK;
   197.
   198.    procedure PML (Q_operand   : in KDF9.Q_register;
   199.                   set_offline : in Boolean) is
   200.    begin
   201.       buffer(Q_operand.C and buffer_number_mask).PML(Q_operand, set_offline);
   202.    end PML;
   203.
   204.    procedure POA (Q_operand   : in KDF9.Q_register;
   205.                   set_offline : in Boolean) is
   206.    begin
   207.       buffer(Q_operand.C and buffer_number_mask).POA(Q_operand, set_offline);
   208.       add_in_the_IO_lockout_CPU_time(Q_operand);
   209.    end POA;
   210.
   211.    procedure POB (Q_operand   : in KDF9.Q_register;
   212.                   set_offline : in Boolean) is
   213.    begin
   214.       buffer(Q_operand.C and buffer_number_mask).POB(Q_operand, set_offline);
   215.       add_in_the_IO_lockout_CPU_time(Q_operand);
   216.    end POB;
   217.
   218.    procedure POC (Q_operand   : in KDF9.Q_register;
   219.                   set_offline : in Boolean) is
   220.    begin
   221.       buffer(Q_operand.C and buffer_number_mask).POC(Q_operand, set_offline);
   222.       add_in_the_IO_lockout_CPU_time(Q_operand);
   223.    end POC;
   224.
   225.    procedure POD (Q_operand   : in KDF9.Q_register;
   226.                   set_offline : in Boolean) is
   227.    begin
   228.       buffer(Q_operand.C and buffer_number_mask).POD(Q_operand, set_offline);
   229.       add_in_the_IO_lockout_CPU_time(Q_operand);
   230.    end POD;
   231.
   232.    procedure POE (Q_operand   : in KDF9.Q_register;
   233.                   set_offline : in Boolean) is
   234.    begin
   235.       buffer(Q_operand.C and buffer_number_mask).POE(Q_operand, set_offline);
   236.    end POE;
   237.
   238.    procedure POF (Q_operand   : in KDF9.Q_register;
   239.                   set_offline : in Boolean) is
   240.    begin
   241.       buffer(Q_operand.C and buffer_number_mask).POF(Q_operand, set_offline);
   242.    end POF;
   243.
   244.    procedure POG (Q_operand   : in KDF9.Q_register;
   245.                   set_offline : in Boolean) is
   246.    begin
   247.       buffer(Q_operand.C and buffer_number_mask).POG(Q_operand, set_offline);
   248.    end POG;
   249.
   250.    procedure POH (Q_operand   : in KDF9.Q_register;
   251.                   set_offline : in Boolean) is
   252.    begin
   253.       buffer(Q_operand.C and buffer_number_mask).POH(Q_operand, set_offline);
   254.    end POH;
   255.
   256.    procedure POK (Q_operand   : in KDF9.Q_register;
   257.                   set_offline : in Boolean) is
   258.    begin
   259.       buffer(Q_operand.C and buffer_number_mask).POK(Q_operand, set_offline);
   260.    end POK;
   261.
   262.    procedure POL (Q_operand   : in KDF9.Q_register;
   263.                   set_offline : in Boolean) is
   264.    begin
   265.       buffer(Q_operand.C and buffer_number_mask).POL(Q_operand, set_offline);
   266.    end POL;
   267.
   268. end IOC.dispatcher;

Compiling: ../Source/ioc-dispatcher.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- CPU I/O orders are dispatched here to device-specific handlers within the IOC type hierarchy.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.dispatcher is
    18.
    19.    procedure MANUAL_CT (Q_operand   : in KDF9.Q_register;
    20.                         set_offline : in Boolean);
    21.
    22.    procedure BUSY (Q_operand   : in KDF9.Q_register;
    23.                    set_offline : in Boolean;
    24.                    result      : out Boolean);
    25.
    26.    procedure PAR (Q_operand   : in KDF9.Q_register;
    27.                   set_offline : in Boolean;
    28.                   result      : out Boolean);
    29.
    30.    procedure TLO (Q_operand   : in KDF9.Q_register;
    31.                   result      : out Boolean);
    32.
    33.    procedure CLO (Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    procedure SLO (Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    procedure INT (Q_operand   : in KDF9.Q_register;
    40.                   set_offline : in Boolean);
    41.
    42.    procedure PIA (Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    procedure PIB (Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    procedure PIC (Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    procedure PID (Q_operand   : in KDF9.Q_register;
    52.                   set_offline : in Boolean);
    53.
    54.    procedure PIE (Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    procedure PIF (Q_operand   : in KDF9.Q_register;
    58.                   set_offline : in Boolean);
    59.
    60.    procedure PIG (Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    procedure PIH (Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean);
    65.
    66.    procedure PMA (Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    procedure PMB (Q_operand   : in KDF9.Q_register;
    70.                   set_offline : in Boolean);
    71.
    72.    procedure PMC (Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    procedure PMD (Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.
    78.    procedure PME (Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    procedure PMF (Q_operand   : in KDF9.Q_register;
    82.                   set_offline : in Boolean);
    83.
    84.    procedure PMG (Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    procedure PMK (Q_operand   : in KDF9.Q_register;
    88.                   set_offline : in Boolean);
    89.
    90.    procedure PML (Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean);
    92.
    93.    procedure POA (Q_operand   : in KDF9.Q_register;
    94.                   set_offline : in Boolean);
    95.
    96.    procedure POB (Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean);
    98.
    99.    procedure POC (Q_operand   : in KDF9.Q_register;
   100.                   set_offline : in Boolean);
   101.
   102.    procedure POD (Q_operand   : in KDF9.Q_register;
   103.                   set_offline : in Boolean);
   104.
   105.    procedure POE (Q_operand   : in KDF9.Q_register;
   106.                   set_offline : in Boolean);
   107.
   108.    procedure POF (Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean);
   110.
   111.    procedure POG (Q_operand   : in KDF9.Q_register;
   112.                   set_offline : in Boolean);
   113.
   114.    procedure POH (Q_operand   : in KDF9.Q_register;
   115.                   set_offline : in Boolean);
   116.
   117.    procedure POK (Q_operand   : in KDF9.Q_register;
   118.                   set_offline : in Boolean);
   119.
   120.    procedure POL (Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean);
   122.
   123. end IOC.dispatcher;
   124.

 268 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-decoding.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- The "compressed_opcode" values are effective opcodes, partially decoded from the first syllable,
     2. --   and combined with opcode bits of the second syllable, where appropriate (e.g. in jumps).
     3. --
     4. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package KDF9.decoding is
    19.
    20.    -- The compressed_opcode values for 1-syllable orders are equal to their full codes.
    21.
    22.    ALL_0    : constant KDF9.compressed_opcode := 2#000_000#;
    23.    VR       : constant KDF9.compressed_opcode := 2#000_001#;
    24.    TO_TR    : constant KDF9.compressed_opcode := 2#000_010#;
    25.    BITS     : constant KDF9.compressed_opcode := 2#000_011#;
    26.    XF       : constant KDF9.compressed_opcode := 2#000_100#;
    27.    XDF      : constant KDF9.compressed_opcode := 2#000_101#;
    28.    INV006   : constant KDF9.compressed_opcode := 2#000_110#;
    29.    XPLUSF   : constant KDF9.compressed_opcode := 2#000_111#;
    30.    NEGD     : constant KDF9.compressed_opcode := 2#001_000#;
    31.    OR_9     : constant KDF9.compressed_opcode := 2#001_001#;
    32.    PERM     : constant KDF9.compressed_opcode := 2#001_010#;
    33.    TOB      : constant KDF9.compressed_opcode := 2#001_011#;
    34.    ROUNDH   : constant KDF9.compressed_opcode := 2#001_100#;
    35.    NEV      : constant KDF9.compressed_opcode := 2#001_101#;
    36.    ROUND    : constant KDF9.compressed_opcode := 2#001_110#;
    37.    DUMMY    : constant KDF9.compressed_opcode := 2#001_111#;
    38.    ROUNDF   : constant KDF9.compressed_opcode := 2#010_000#;
    39.    ROUNDHF  : constant KDF9.compressed_opcode := 2#010_001#;
    40.    MINUSDF  : constant KDF9.compressed_opcode := 2#010_010#;
    41.    PLUSDF   : constant KDF9.compressed_opcode := 2#010_011#;
    42.    FLOAT_9  : constant KDF9.compressed_opcode := 2#010_100#;
    43.    FLOATD   : constant KDF9.compressed_opcode := 2#010_101#;
    44.    ABS_9    : constant KDF9.compressed_opcode := 2#010_110#;
    45.    NEG      : constant KDF9.compressed_opcode := 2#010_111#;
    46.    ABSF     : constant KDF9.compressed_opcode := 2#011_000#;
    47.    NEGF     : constant KDF9.compressed_opcode := 2#011_001#;
    48.    MAX      : constant KDF9.compressed_opcode := 2#011_010#;
    49.    NOT_9    : constant KDF9.compressed_opcode := 2#011_011#;
    50.    XD       : constant KDF9.compressed_opcode := 2#011_100#;
    51.    X_frac   : constant KDF9.compressed_opcode := 2#011_101#;
    52.    MINUS    : constant KDF9.compressed_opcode := 2#011_110#;
    53.    SIGN     : constant KDF9.compressed_opcode := 2#011_111#;
    54.    INV040   : constant KDF9.compressed_opcode := 2#100_000#;
    55.    ZERO     : constant KDF9.compressed_opcode := 2#100_001#;
    56.    DUP      : constant KDF9.compressed_opcode := 2#100_010#;
    57.    DUPD     : constant KDF9.compressed_opcode := 2#100_011#;
    58.    DIVI     : constant KDF9.compressed_opcode := 2#100_100#;
    59.    FIX      : constant KDF9.compressed_opcode := 2#100_101#;
    60.    INV046   : constant KDF9.compressed_opcode := 2#100_110#;
    61.    STR      : constant KDF9.compressed_opcode := 2#100_111#;
    62.    CONT     : constant KDF9.compressed_opcode := 2#101_000#;
    63.    REVD     : constant KDF9.compressed_opcode := 2#101_001#;
    64.    ERASE    : constant KDF9.compressed_opcode := 2#101_010#;
    65.    MINUSD   : constant KDF9.compressed_opcode := 2#101_011#;
    66.    AND_9    : constant KDF9.compressed_opcode := 2#101_100#;
    67.    INV055   : constant KDF9.compressed_opcode := 2#101_101#;
    68.    PLUS     : constant KDF9.compressed_opcode := 2#101_110#;
    69.    PLUSD    : constant KDF9.compressed_opcode := 2#101_111#;
    70.    DIV      : constant KDF9.compressed_opcode := 2#110_000#;
    71.    DIVD     : constant KDF9.compressed_opcode := 2#110_001#;
    72.    DIVF     : constant KDF9.compressed_opcode := 2#110_010#;
    73.    DIVDF    : constant KDF9.compressed_opcode := 2#110_011#;
    74.    DIVR     : constant KDF9.compressed_opcode := 2#110_100#;
    75.    REV      : constant KDF9.compressed_opcode := 2#110_101#;
    76.    CAB      : constant KDF9.compressed_opcode := 2#110_110#;
    77.    FRB      : constant KDF9.compressed_opcode := 2#110_111#;
    78.    STAND    : constant KDF9.compressed_opcode := 2#111_000#;
    79.    NEGDF    : constant KDF9.compressed_opcode := 2#111_001#;
    80.    MAXF     : constant KDF9.compressed_opcode := 2#111_010#;
    81.    INV073   : constant KDF9.compressed_opcode := 2#111_011#;
    82.    PLUSF    : constant KDF9.compressed_opcode := 2#111_100#;
    83.    MINUSF   : constant KDF9.compressed_opcode := 2#111_101#;
    84.    INV076   : constant KDF9.compressed_opcode := 2#111_110#;
    85.    SIGNF    : constant KDF9.compressed_opcode := 2#111_111#;
    86.
    87.
    88.    -- compressed_opcode values for 2-syllable indirect fetch and store orders
    89.
    90.    MkMq       : constant KDF9.compressed_opcode := 2#000_000#;
    91.    MkMqQ      : constant KDF9.compressed_opcode := 2#000_010#;
    92.    MkMqH      : constant KDF9.compressed_opcode := 2#000_100#;
    93.    MkMqQH     : constant KDF9.compressed_opcode := 2#000_110#;
    94.    MkMqN      : constant KDF9.compressed_opcode := 2#001_000#;
    95.    MkMqQN     : constant KDF9.compressed_opcode := 2#001_010#;
    96.    MkMqHN     : constant KDF9.compressed_opcode := 2#001_100#;
    97.    MkMqQHN    : constant KDF9.compressed_opcode := 2#001_110#;
    98.
    99.    TO_MkMq    : constant KDF9.compressed_opcode := 2#000_001#;
   100.    TO_MkMqQ   : constant KDF9.compressed_opcode := 2#000_011#;
   101.    TO_MkMqH   : constant KDF9.compressed_opcode := 2#000_101#;
   102.    TO_MkMqQH  : constant KDF9.compressed_opcode := 2#000_111#;
   103.    TO_MkMqN   : constant KDF9.compressed_opcode := 2#001_001#;
   104.    TO_MkMqQN  : constant KDF9.compressed_opcode := 2#001_011#;
   105.    TO_MkMqHN  : constant KDF9.compressed_opcode := 2#001_101#;
   106.    TO_MkMqQHN : constant KDF9.compressed_opcode := 2#001_111#;
   107.
   108.
   109.    -- compressed_opcode values for 2-syllable Q store orders
   110.
   111.    M_PLUS_Iq    : constant KDF9.compressed_opcode := 2#100_000#;
   112.    M_MINUS_Iq   : constant KDF9.compressed_opcode := 2#100_001#;
   113.    NCq          : constant KDF9.compressed_opcode := 2#100_010#;
   114.    DCq          : constant KDF9.compressed_opcode := 2#100_011#;
   115.    POS1_TO_Iq   : constant KDF9.compressed_opcode := 2#100_100#;
   116.    NEG1_TO_Iq   : constant KDF9.compressed_opcode := 2#100_101#;
   117.    POS2_TO_Iq   : constant KDF9.compressed_opcode := 2#100_110#;
   118.    NEG2_TO_Iq   : constant KDF9.compressed_opcode := 2#100_111#;
   119.
   120.    MqTOQk       : constant KDF9.compressed_opcode := 2#101_001#;
   121.    IqTOQk       : constant KDF9.compressed_opcode := 2#101_010#;
   122.    IMqTOQk      : constant KDF9.compressed_opcode := 2#101_011#;
   123.    CqTOQk       : constant KDF9.compressed_opcode := 2#101_100#;
   124.    CMqTOQk      : constant KDF9.compressed_opcode := 2#101_101#;
   125.    CIqTOQk      : constant KDF9.compressed_opcode := 2#101_110#;
   126.    QqTOQk       : constant KDF9.compressed_opcode := 2#101_111#;
   127.
   128.    SHA          : constant KDF9.compressed_opcode := 2#110_001#;
   129.    SHAD         : constant KDF9.compressed_opcode := 2#110_010#;
   130.    MACC         : constant KDF9.compressed_opcode := 2#110_011#;
   131.    SHL          : constant KDF9.compressed_opcode := 2#110_100#;
   132.    SHLD         : constant KDF9.compressed_opcode := 2#110_110#;
   133.    SHC          : constant KDF9.compressed_opcode := 2#110_111#;
   134.    constant_bit : constant := 1;
   135.
   136.    TO_RCIMq     : constant KDF9.compressed_opcode := 2#111_000#;
   137.    QCIMq        : constant KDF9.compressed_opcode := 2#111_001#;
   138.    ADD_TO_QCIMq : constant KDF9.compressed_opcode := 2#111_010#;
   139.
   140.    -- masks for Q store Qk bits
   141.
   142.    reset_choice  : constant := 2#0001#;
   143.    C_part_choice : constant := 2#1000#;
   144.    I_part_choice : constant := 2#0100#;
   145.    M_part_choice : constant := 2#0010#;
   146.    all_Q_choice  : constant := C_part_choice + I_part_choice + M_part_choice;
   147.
   148.
   149.    -- compressed_opcode values for 2-syllable SJNS orders
   150.
   151.    LINK    : constant KDF9.compressed_opcode := 2#111_011#;
   152.    TO_LINK : constant KDF9.compressed_opcode := 2#111_100#;
   153.
   154.
   155.    -- compressed_opcode values for 2-syllable Director-only orders
   156.
   157.    TO_Kq : constant KDF9.compressed_opcode := 2#111_101#;
   158.    K0    : constant := 2#1000#;
   159.    K1    : constant := 2#0100#;
   160.    K2    : constant := 2#0010#;
   161.    K3    : constant := 2#0001#;
   162.    Kk    : constant KDF9.compressed_opcode := 2#111_110#;
   163.    K4    : constant := 2#1000#;
   164.    K5    : constant := 2#0100#;
   165.    K7    : constant := 2#0001#;
   166.
   167.
   168.    -- compressed_opcode value for 2-syllable short-loop jump order
   169.
   170.    JCqNZS : constant KDF9.compressed_opcode := 2#111_111#;
   171.
   172.
   173.    -- compressed_opcode values for 2-syllable I/O orders
   174.
   175.    CT_PMB_PMC_BUSY_Qq     : constant KDF9.compressed_opcode := 2#010_000#;
   176.    PAR_Qq                 : constant KDF9.compressed_opcode := 2#010_001#;
   177.    PMF_PMG_Qq             : constant KDF9.compressed_opcode := 2#010_010#;
   178.    PIA_PIC_CLO_TLO_Qq     : constant KDF9.compressed_opcode := 2#010_100#;
   179.    PIB_PID_Qq             : constant KDF9.compressed_opcode := 2#010_101#;
   180.    PIE_PIG_Qq             : constant KDF9.compressed_opcode := 2#010_110#;
   181.    PIF_PIH_Qq             : constant KDF9.compressed_opcode := 2#010_111#;
   182.
   183.    POA_POC_POE_POF_PMH_Qq : constant KDF9.compressed_opcode := 2#011_000#;
   184.    POB_POD_Qq             : constant KDF9.compressed_opcode := 2#011_001#;
   185.    POG_POL_Qq             : constant KDF9.compressed_opcode := 2#011_010#;
   186.    POH_POK_Qq             : constant KDF9.compressed_opcode := 2#011_011#;
   187.    PMA_PMK_INT_Qq         : constant KDF9.compressed_opcode := 2#011_100#;
   188.    PMD_PME_PML_Qq         : constant KDF9.compressed_opcode := 2#011_110#;
   189.
   190.    -- masks for I/O opcode extension bits (Qk field)
   191.
   192.    PAR_bits  : constant := 2#0000#;
   193.
   194.    -- PIA_PIC_CLO_TLO_Qq:
   195.    PIA_bits  : constant := 2#0000#;
   196.    PIC_bits  : constant := 2#1000#;
   197.    CLO_bits  : constant := 2#0010#;
   198.    TLO_bits  : constant := 2#0100#;
   199.
   200.    -- PIB_PID_Qq:
   201.    PIB_bits  : constant := 2#0000#;
   202.    PID_bits  : constant := 2#1000#;
   203.
   204.    -- PIE_PIG_Qq:
   205.    PIE_bits  : constant := 2#0000#;
   206.    PIG_bits  : constant := 2#1000#;
   207.
   208.    -- PIF_PIH_Qq:
   209.    PIF_bits  : constant := 2#0000#;
   210.    PIH_bits  : constant := 2#1000#;
   211.
   212.    -- PMA_PMK_INT_Qq:
   213.    PMA_bits  : constant := 2#0000#;
   214.    PMK_bits  : constant := 2#0100#;
   215.    INT_bits  : constant := 2#0010#;
   216.
   217.    -- CT_PMB_PMC_BUSY_Qq:
   218.    CTQ_bits   : constant := 2#0000#;
   219.    PMB_bits   : constant := 2#1000#;
   220.    PMC_bits   : constant := 2#0100#;
   221.    BUSY_bits  : constant := 2#0010#;
   222.    manual_bit : constant := 2#0001#;
   223.
   224.    -- PMD_PME_PML_Qq:
   225.    PME_bits  : constant := 2#0000#;
   226.    PMD_bits  : constant := 2#1000#;
   227.    PML_bits  : constant := 2#0100#;
   228.
   229.    -- PMF_PMG_Qq:
   230.    PMF_bits  : constant := 2#0000#;
   231.    PMG_bits  : constant := 2#0100#;
   232.
   233.    -- POA_POC_POE_POF_PMH_Qq:
   234.    POA_bits  : constant := 2#0000#;
   235.    POC_bits  : constant := 2#1000#;
   236.    POE_bits  : constant := 2#1100#;
   237.    POF_bits  : constant := 2#0100#;
   238.    PMH_bits  : constant := 2#0010#;
   239.
   240.    -- POB_POD_Qq:
   241.    POB_bits  : constant := 2#0000#;
   242.    POD_bits  : constant := 2#1000#;
   243.
   244.    -- POG_POL_Qq:
   245.    POG_bits  : constant := 2#0000#;
   246.    POL_bits  : constant := 2#1000#;
   247.
   248.    -- POH_POK_Qq:
   249.    POH_bits  : constant := 2#0000#;
   250.    POK_bits  : constant := 2#1000#;
   251.
   252.
   253.    -- compressed_opcode values for normal jump orders
   254.
   255.    JrNE   : constant KDF9.compressed_opcode := 2#000_001#;
   256.    JrGEZ  : constant KDF9.compressed_opcode := 2#000_010#;
   257.    JrLEZ  : constant KDF9.compressed_opcode := 2#000_100#;
   258.    JrNEZ  : constant KDF9.compressed_opcode := 2#000_110#;
   259.    JrNV   : constant KDF9.compressed_opcode := 2#001_000#;
   260.    OS_OUT : constant KDF9.compressed_opcode := 2#001_001#;
   261.    JrNEN  : constant KDF9.compressed_opcode := 2#001_010#;
   262.    Jr     : constant KDF9.compressed_opcode := 2#001_011#;
   263.    JrNEJ  : constant KDF9.compressed_opcode := 2#001_100#;
   264.    JSr    : constant KDF9.compressed_opcode := 2#001_101#;
   265.    JrNTR  : constant KDF9.compressed_opcode := 2#001_110#;
   266.    EXIT_n : constant KDF9.compressed_opcode := 2#001_111#;  -- 0h0 in bits 5-7
   267.    JrEQ   : constant KDF9.compressed_opcode := 2#010_001#;
   268.    JrLTZ  : constant KDF9.compressed_opcode := 2#010_010#;
   269.    JrGTZ  : constant KDF9.compressed_opcode := 2#010_100#;
   270.    JrEQZ  : constant KDF9.compressed_opcode := 2#010_110#;
   271.    JrV    : constant KDF9.compressed_opcode := 2#011_000#;
   272.    JrEN   : constant KDF9.compressed_opcode := 2#011_010#;
   273.    JrEJ   : constant KDF9.compressed_opcode := 2#011_100#;
   274.    JrTR   : constant KDF9.compressed_opcode := 2#011_110#;
   275.    EXITD  : constant KDF9.compressed_opcode := 2#011_111#;  -- 010 in bits 5-7
   276.    JrCqZ  : constant KDF9.compressed_opcode := 2#100_000#;
   277.    JrCqNZ : constant KDF9.compressed_opcode := 2#110_000#;
   278.
   279.    EXIT_1_bit : constant := 2#010#;  -- 0h0 in bits 5-7 of EXIT syllable_0
   280.
   281.
   282.    -- compressed_opcode values for directly-addressed data access orders
   283.
   284.    EaMq     : constant KDF9.compressed_opcode := 2#000_000#;
   285.    TO_EaMq  : constant KDF9.compressed_opcode := 2#000_001#;
   286.    EaMqQ    : constant KDF9.compressed_opcode := 2#000_010#;
   287.    TO_EaMqQ : constant KDF9.compressed_opcode := 2#000_011#;
   288.    SET      : constant KDF9.compressed_opcode := 2#000_100#;
   289.
   290.
   291. end KDF9.decoding;

 291 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-egdon.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Implement the API (OUTs) of the EGDON Director.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body KDF9.EGDON is
    18.
    19.    procedure do_an_EGDON_OUT (OUT_number : in KDF9.word) is
    20.    begin
    21.       trap_unimplemented_feature("EGDON OUT" & OUT_number'Image);
    22.    end do_an_EGDON_OUT;
    23.
    24. end KDF9.EGDON;

Compiling: ../Source/kdf9-egdon.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Implement the API (OUTs) of the EGDON Director.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.EGDON is
    18.
    19.    procedure do_an_EGDON_OUT (OUT_number : in KDF9.word);
    20.
    21. end KDF9.EGDON;

 24 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd-processes.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Implement OUTs 0, 1 and 2 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with dumping;
    18. with IOC;
    19. with IOC.fast.DR.TSD_OUTs;
    20. with IOC.fast.FD.TSD_OUTs;
    21. with IOC.slow.shift.TR;
    22. with KDF9.CPU;
    23. with KDF9.store;
    24. with KDF9.TSD.peripherals;
    25.
    26. with imported_value_of;
    27.
    28. use  dumping;
    29. use  IOC;
    30. use  IOC.fast.DR.TSD_OUTs;
    31. use  IOC.fast.FD.TSD_OUTs;
    32. use  IOC.slow.shift.TR;
    33. use  KDF9.store;
    34. use  KDF9.TSD.peripherals;
    35.
    36. package body KDF9.TSD.processes is
    37.
    38. --
    39. -- OUTs 0, 1 and 2 terminate execution in various ways and call for appropriate finalization.
    40. --
    41.
    42.    procedure free_any_allocated_tapes (OUT_number : in KDF9.word) is
    43.    begin
    44.       for b in KDF9.buffer_number loop
    45.          if buffer(b) /= null                      and then
    46.                buffer(b).kind in MT_kind | ST_kind and then
    47.                   is_allocated(buffer(b))              then
    48.             free_the_device_on_buffer(b, OUT_number);
    49.          end if;
    50.       end loop;
    51.    end free_any_allocated_tapes;
    52.
    53.
    54. --
    55. -- OUT 0: terminate the run.
    56. --
    57.
    58.    procedure do_OUT_0 is
    59.    begin
    60.       free_any_allocated_tapes(OUT_number => 0);
    61.       notify_state_display_of_final_ICR;
    62.       log_API_message("OUT 0: end of run");
    63.       raise program_exit;
    64.    end do_OUT_0;
    65.
    66.
    67. --
    68. -- OUT 1: terminate the run and overlay another program in a fresh start.
    69. --
    70.
    71.    procedure finalize_interim_diagnostics (OUT_number : in KDF9.word) is
    72.    begin
    73.       if the_log_is_wanted and pre_overlay_state_is_enabled then
    74.          show_final_state("before overlay by OUT" & OUT_number'Image);
    75.       end if;
    76.
    77.       -- Deal with any dump requests.
    78.       if the_log_is_wanted and nr_of_post_dumping_areas /= 0 then
    79.          log_new_line;
    80.          log_rule;
    81.          log_title("Post-run Dump:");
    82.          print_postrun_dump_areas;
    83.       end if;
    84.       remove_prerun_dump_areas;
    85.       remove_postrun_dump_areas;
    86.
    87.       -- Restart tracing.
    88.       clear_retro_FIFO;
    89.       clear_IOC_FIFO;
    90.       clear_the_histogram;
    91.       clear_the_profile;
    92.       the_profile_is_wanted := False;
    93.       the_INS_plot_is_wanted := False;
    94.       if the_external_trace_is_enabled then
    95.          log_an_external_trace_header("ee9: Restarting the run for OUT" & OUT_number'Image);
    96.       end if;
    97.    end finalize_interim_diagnostics;
    98.
    99.    procedure prepare_successor (new_limits : in KDF9.word; new_program_name : in String := "" ) is
   100.    begin
   101.       -- Set up any new options.
   102.       get_settings_from_file("2");
   103.       display_execution_modes(new_program_name);
   104.
   105.       -- Complete the core image.
   106.       poke_all_amendments;
   107.       save_the_initial_jump;
   108.       store_word(new_limits, 1);
   109.
   110.       -- Display initial dumps.
   111.       the_program_has_been_analysed := False;
   112.       show_all_prerun_dump_areas;
   113.
   114.       -- Establish the new CPU state.
   115.       reset_V_and_T;
   116.       set_NIA_to((0, 0));
   117.    end prepare_successor;
   118.
   119.    procedure do_OUT_1 is
   120.       P : KDF9.pair;
   121.       W : KDF9.word;
   122.    begin
   123.       -- Get the program name.
   124.       ensure_that_the_NEST_holds_2_operands;
   125.       P := pop;
   126.       P := KDF9.CPU.shift_logical(P, 24);
   127.
   128.       declare
   129.          program_name : constant String := trimmed(to_string(P));
   130.          overlay_name : constant String := imported_value_of("KDF9_BINARY", default => "Binary")
   131.                                          & "/"
   132.                                          & program_name;
   133.       begin
   134.          if program_name = "" then
   135.             trap_failing_OUT(1, "the given program name is an empty string");
   136.          end if;
   137.
   138.          if program_name = "KMW0201--UPU" then
   139.             -- The Whetstone Controller is trying to overlay itself with the Translator.
   140.             -- This is so inconvenient in practice that I simply prevent it.
   141.             notify_state_display_of_final_ICR;
   142.             log_API_message("OUT 1: ee9 will not return to the Whetstone Translator", skip => 2);
   143.             raise program_exit;
   144.          end if;
   145.
   146.          -- Tidy up the running program.
   147.          free_all_devices;
   148.          complete_all_extant_transfers;
   149.          notify_state_display_of_final_ICR;
   150.          finalize_interim_diagnostics(OUT_number => 1);
   151.          log_API_message("OUT 1: ICR ="
   152.                        & ICR'Image
   153.                        & "; RAN/EL ="
   154.                        & the_CPU_time'Image
   155.                        & " /"
   156.                        & KDF9.us'Image(the_clock_time)
   157.                        & " KDF9 us"
   158.                         );
   159.
   160.          -- The overlaid program inherits the predecessor's time and store limits.
   161.          W := fetch_word(1);
   162.          load_a_program(overlay_name);
   163.          prepare_successor(new_limits => W, new_program_name => overlay_name);
   164.
   165.          raise mode_change_request;
   166.       end;
   167.    end do_OUT_1;
   168.
   169.
   170. --
   171. -- OUT 2: terminate the run and then restart it with a program already in core.
   172. -- complete_TSD_OUT_2 is called by KDF9.microcode after it has finalized the OUT instruction.
   173. --
   174.
   175.    time_limit : KDF9.word;
   176.
   177.    procedure do_OUT_2 is
   178.    begin
   179.       ensure_that_the_NEST_holds_an_operand;
   180.       time_limit := pop;
   181.       the_trace_operand := time_limit;
   182.
   183.       -- Tidy up the running program.
   184.       free_any_allocated_tapes(OUT_number => 2);
   185.       free_any_reserved_disc_space;
   186.       free_any_reserved_drum_space;
   187.       notify_state_display_of_final_ICR;
   188.
   189.       raise OUT_2_restart;
   190.    end do_OUT_2;
   191.
   192.    procedure complete_TSD_OUT_2 is
   193.    begin
   194.       finalize_interim_diagnostics(OUT_number => 2);
   195.       if time_limit >= 2**24 then
   196.          trap_failing_OUT(2, "the new time limit =" & time_limit'Image & "s is too big");
   197.       end if;
   198.
   199.       log_API_message("OUT 2: ICR ="
   200.                     & ICR'Image
   201.                     & "; RAN/EL ="
   202.                     & the_CPU_time'Image
   203.                     & " /"
   204.                     & KDF9.us'Image(the_clock_time)
   205.                     & " KDF9 us"
   206.                     & "; new time limit = "
   207.                     & time_limit'Image &"s"
   208.                      );
   209.
   210.       --The successor has a new time limit and inherits the predecessor's store limit.
   211.       prepare_successor(new_limits => time_limit * 2**24 + fetch_halfword(1, 1) / 2**24);
   212.
   213.       reset_the_program_state;
   214.    end complete_TSD_OUT_2;
   215.
   216.
   217. --
   218. -- OUT 97: this not a genuine TSD OUT.
   219. --
   220.
   221.    procedure do_OUT_97 is
   222.       P      : constant KDF9.word := pop;
   223.       name   : constant String    := trimmed(to_string(P));
   224.       value  : constant String    := imported_value_of(name, "0");
   225.       number : KDF9.word;
   226.    begin
   227.       number := KDF9.word'Value(value);
   228.       the_trace_operand := number;
   229.       push(number);
   230.    exception
   231.       when others =>
   232.          trap_failing_OUT(97, name & " = «"& value & "», not a valid integer");
   233.    end do_OUT_97;
   234.
   235. end KDF9.TSD.processes;

Compiling: ../Source/kdf9-tsd-processes.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Implement OUTs 0.. 2 and 5..7 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.processes is
    18.
    19.    procedure do_OUT_0
    20.       with No_Return, Inline => False;
    21.
    22.    procedure do_OUT_1
    23.       with No_Return, Inline => False;
    24.
    25.    procedure do_OUT_2
    26.       with No_Return, Inline => False;
    27.
    28.    procedure complete_TSD_OUT_2
    29.       with Inline => False;
    30.
    31.    procedure do_OUT_97
    32.       with Inline => False;
    33.
    34. end KDF9.TSD.processes;

 235 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-diagnostics.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Provide diagnostic output of the state of all the buffers.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with disassembly;
    18.
    19. with IOC.the_locker_of;
    20.
    21. procedure IOC.diagnostics is
    22.    Q : KDF9.Q_register;
    23.    B : KDF9.Q_part;
    24.    F : Boolean;
    25. begin
    26.    if not debugging_is_enabled then return; end if;
    27.    for g in Q_part'(0) .. 100 loop
    28.       if there_are_locks_in_physical_addresses(KDF9.Q_register'(0, 32*g, 32*g + 31)) then
    29.          output("there are locks in group" & g'Image & " PHY" & Q_part'(32*g)'Image);
    30.          B := the_locker_of(32*g, F);
    31.          output(", locked by" & B'Image & ":");
    32.          if F then output_line(buffer(B).device_name); else output_line("??"); end if;
    33.       end if;
    34.    end loop;
    35.    for the_buffer of buffer loop
    36.       if the_buffer /= null                        and then
    37.          the_buffer.initiation_time /= KDF9.us'Last    then
    38.          output_line;
    39.          output_line("Current state of buffer #" & oct_of(the_buffer.number, 2));
    40.          output_line("   device: " & the_buffer.device_name);
    41.          output_line("  is_busy: " & the_buffer.is_busy'Image);
    42.          output_line("operation: " & the_buffer.operation'Image);
    43.          output_line(" off_line: " & the_buffer.is_offline'Image);
    44.          output_line(" abnormal: " & the_buffer.is_abnormal'Image);
    45.          output_line(" Director: " & the_buffer.is_for_Director'Image);
    46.          output_line(" priority:"  & the_buffer.priority_level'Image);
    47.          output_line("initiated:"  & the_buffer.initiation_time'Image);
    48.          output_line("xfer_time:"  & the_buffer.transfer_time'Image);
    49.          output_line("completes:"  & the_buffer.completion_time'Image);
    50.          Q := the_buffer.control_word;
    51.          output_line(
    52.                      "  control: "
    53.                    & "Q"
    54.                    & Q.C'Image
    55.                    &"/"
    56.                    & Q.I'Image
    57.                    & "/"
    58.                    & Q.M'Image
    59.                     );
    60.          if Q.I <= max_address               and then
    61.              Q.M <= max_address              and then
    62.                 Q.I <= the_buffer.control_word.M then
    63.             output_line(
    64.                         "locked in:"
    65.                       & group(Q.I)'Image
    66.                       & ".."
    67.                       & group(Q.M)'Image
    68.                       & " is "
    69.                       & there_are_locks_in_physical_addresses(Q)'Image
    70.                        );
    71.          end if;
    72.          output_line("order ICR:"  & the_buffer.order_count'Image);
    73.          output_line("    order: " & disassembly.the_full_name_of(the_buffer.decoded_order));
    74.          output_line("@ address: " & oct_of(the_buffer.order_address));
    75.       end if;
    76.    end loop;
    77. end IOC.diagnostics;

 77 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/plotter.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Emulation of the plotting commands of the Calcomp 564 graph plotter.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.slow.shift.GP;
    18. with postscript;
    19.
    20. use  IOC.slow.shift.GP;
    21. use  postscript;
    22.
    23. package body plotter is
    24.
    25.    -- The plotter made equal movements in the x and y directions, in steps of 0.005 inches.
    26.    -- Each command moves the plotting position by at most 1 step,
    27.    --   in either the positive or negative direction of each axis.
    28.
    29.    type step is
    30.       record
    31.          dx, dy : Integer range -1 .. +1;
    32.       end record;
    33.
    34.    null_step : constant plotter.step := (0, 0);
    35.
    36.    function "+" (p : postscript.point; s : plotter.step)
    37.    return postscript.point
    38.    is ((p.x + s.dx, p.y + s.dy));
    39.
    40.    function "-" (p, q : postscript.point)
    41.    return plotter.step
    42.    is ((p.x - q.x, p.y - q.y));
    43.
    44.    -- The plotter drew on a roll of paper 29.5 inches wide and 120 feet long.
    45.    -- 29.5" is   5900 steps at 200 steps per inch = 59 * 100
    46.    -- 120'  is 288000 steps  = 200 per inch * 12 inches per foot * 120 feet.
    47.    -- This sets the boundaries of the plot.
    48.    -- It was physically impossible to move to a point beyond these limits.
    49.
    50.    plot_limit : constant postscript.point := (120*12*200, 59*100);
    51.
    52.    -- A vector is represented by a series of consecutive colinear plotter movements.
    53.    -- For better efficiency, the steps of a vector are accumulated until there is
    54.    --    a change of direction, a pen lift, or the need to close the plotter file.
    55.    -- On these events, any vector thus defined is drawn via a single PostScript command.
    56.
    57.    the_origin      : constant postscript.point := (0, 0);
    58.
    59.    plot_position,
    60.    start_position  : postscript.point := the_origin;
    61.
    62.    -- last_step retains the direction of the previous plotter step.
    63.    last_step       : plotter.step := null_step;
    64.
    65.    the_pen_is_down : Boolean := False;
    66.
    67.    procedure ensure_the_validity_of (from  : in postscript.point;
    68.                                      step  : in plotter.step) is
    69.    begin
    70.      if from.x + step.dx < 0                     or else
    71.            from.y + step.dy < 0                  or else
    72.               from.x + step.dx > plot_limit.x    or else
    73.                  from.y + step.dy > plot_limit.y    then
    74.         notify_invalid_movement(from.x, from.y, step.dx, step.dy);
    75.      end if;
    76.    end ensure_the_validity_of;
    77.
    78.    procedure jump_to (p : in postscript.point)
    79.      with Inline;
    80.
    81.    procedure jump_to (p : in postscript.point) is
    82.    begin
    83.      -- Posit a new vector starting at p.
    84.      last_step := null_step;
    85.      plot_position := p;
    86.      start_position := p;
    87.    end;
    88.
    89.    procedure jump_by (this_step : in plotter.step)
    90.      with Inline;
    91.
    92.    procedure jump_by (this_step : in plotter.step) is
    93.    begin
    94.      ensure_the_validity_of(from => plot_position, step => this_step);
    95.      jump_to(plot_position + this_step);
    96.    end jump_by;
    97.
    98.    procedure close_any_open_vector (stream : in out host_IO.stream) is
    99.    begin
   100.      if the_pen_is_down                and then
   101.            start_position /= plot_position then
   102.         draw_a_PS_vector(stream, start_position, plot_position);
   103.         start_position := plot_position;
   104.      end if;
   105.    end close_any_open_vector;
   106.
   107.    procedure perform (action : in plotter.command; stream : in out host_IO.stream) is
   108.
   109.      procedure draw_to (p : in postscript.point)
   110.         with Inline;
   111.
   112.      procedure draw_to (p : in postscript.point) is
   113.      begin
   114.         if (plot_position - p) = last_step then
   115.            -- p is colinear with the previous step, so merely extend the vector to p.
   116.            plot_position := p;
   117.         else
   118.            -- Draw the whole vector and start a new one.
   119.            draw_a_PS_vector(stream, start_position, plot_position);
   120.            last_step := plot_position - p;
   121.            start_position := plot_position;
   122.            plot_position := p;
   123.         end if;
   124.      end draw_to;
   125.
   126.      procedure draw_by (this_step : in plotter.step)
   127.         with Inline;
   128.
   129.      procedure draw_by (this_step : in plotter.step) is
   130.      begin
   131.         ensure_the_validity_of(from => plot_position, step => this_step);
   132.         draw_to(plot_position + this_step);
   133.      end draw_by;
   134.
   135.      procedure move_by (this_step : in plotter.step)
   136.         with Inline;
   137.
   138.      procedure move_by (this_step : in plotter.step) is
   139.      begin
   140.         -- Convert from natural orientation of X axis to PostScript direction.
   141.         if the_pen_is_down then
   142.            draw_by((-this_step.dx, +this_step.dy));
   143.         else
   144.            jump_by((-this_step.dx, +this_step.dy));
   145.         end if;
   146.      end move_by;
   147.
   148.    begin -- perform
   149.      case action is
   150.         when dummy =>
   151.            null;
   152.         when pen_up =>
   153.            close_any_open_vector(stream);
   154.            the_pen_is_down := False;
   155.         when pen_down =>
   156.            the_pen_is_down := True;
   157.         when go_pY =>
   158.            move_by((+0, +1));
   159.         when go_nY =>
   160.            move_by((+0, -1));
   161.         when go_pX =>
   162.            move_by((+1, +0));
   163.         when go_nX =>
   164.            move_by((-1, +0));
   165.         when go_pXpY =>
   166.            move_by((+1, +1));
   167.         when go_nXnY =>
   168.            move_by((-1, -1));
   169.         when go_pXnY =>
   170.            move_by((+1, -1));
   171.         when go_nXpY =>
   172.            move_by((-1, +1));
   173.         when others =>
   174.            -- EM causes a 'peculiar' motion, according to the Manual, Appendix 5.2, p.303,
   175.            --    and other codes cause 'unpredictable' effects.
   176.            -- ee9 therefore performs an arbitrary, but safe, operation: moving to the origin.
   177.            close_any_open_vector(stream);
   178.            plot_position := the_origin;
   179.      end case;
   180.    end perform;
   181.
   182.    a_plot_is_open : Boolean := False;
   183.
   184.    procedure open_the_plot_file (stream : in out host_IO.stream) is
   185.    begin
   186.      if a_plot_is_open then
   187.         close_the_plot_file(stream);
   188.      end if;
   189.      plot_position := (0,0);
   190.      a_plot_is_open := True;
   191.    end open_the_plot_file;
   192.
   193.    procedure close_the_plot_file (stream : in out host_IO.stream) is
   194.    begin
   195.      if not a_plot_is_open then
   196.         return;
   197.      end if;
   198.      close_any_open_vector(stream);
   199.      a_plot_is_open := False;
   200.    end close_the_plot_file;
   201.
   202. end plotter;

Compiling: ../Source/plotter.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Emulation of the plotting commands of the Calcomp 564 graph plotter.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with host_IO;
    18. with KDF9_char_sets;
    19.
    20. use  host_IO;
    21.
    22. package plotter is
    23.
    24.    procedure open_the_plot_file (stream : in out host_IO.stream);
    25.
    26.    procedure close_the_plot_file (stream : in out host_IO.stream);
    27.
    28.    type command is new KDF9_char_sets.symbol;
    29.
    30.    -- The KDF9 plotting commands are defined in the Manual, Appendix 6, §5.3, pp. 303-304.
    31.
    32.    -- BUT there is obviously an error in the Manual, as only 9 of the claimed 11 command
    33.    --    codes are listed, and the last, go_nXnY, is coded inconsistently with the others.
    34.
    35.    -- Hypothesis: the table should read as follows:
    36.
    37.    dummy    : constant plotter.command := 2#000_000#;
    38.
    39.    pen_up   : constant plotter.command := 2#100_000#;
    40.    pen_down : constant plotter.command := 2#010_000#;
    41.
    42.    go_pY    : constant plotter.command := 2#001_000#;
    43.    go_nY    : constant plotter.command := 2#000_100#;
    44.    go_pX    : constant plotter.command := 2#000_010#;
    45.    go_nX    : constant plotter.command := 2#000_001#;
    46.
    47.    go_nXnY  : constant plotter.command := go_nX + go_nY;
    48.    go_pXnY  : constant plotter.command := go_pX + go_nY;
    49.    go_nXpY  : constant plotter.command := go_nX + go_pY;
    50.    go_pXpY  : constant plotter.command := go_pX + go_pY;
    51.
    52.    -- These encodings are consistent with the Calcomp plotter command codes used here:
    53.    --     ub.fnwi.uva.nl/computermuseum//calcomp565.html
    54.    -- which defines a full set of 11 commands, two of which are missing from the KDF9 list.
    55.
    56.    is_valid : constant array (plotter.command) of Boolean
    57.             := (dummy    |
    58.                 pen_up   |
    59.                 pen_down |
    60.                 go_pY    |
    61.                 go_nY    |
    62.                 go_pX    |
    63.                 go_nX    |
    64.                 go_pXnY  |
    65.                 go_nXpY  |
    66.                 go_pXpY  |
    67.                 go_nXnY  => True,
    68.                 others   => False
    69.                );
    70.
    71.    procedure perform (action : in plotter.command; stream : in out host_IO.stream);
    72.
    73. end plotter;

 202 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-fast-dr-tsd_outs.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Implement the drum API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.dispatcher;
    18. with KDF9.TSD;
    19.
    20. use  IOC.dispatcher;
    21. use  KDF9.TSD;
    22.
    23. package body IOC.fast.DR.TSD_OUTs is
    24.
    25.    OUT13_was_done          : Boolean   := False;
    26.    last_reserved_DR_sector : KDF9.word := -1;
    27.
    28.    procedure free_any_reserved_drum_space is
    29.    begin
    30.       OUT13_was_done := False;
    31.       last_reserved_DR_sector := -1;
    32.    end free_any_reserved_drum_space;
    33.
    34.    Q : KDF9.Q_register;
    35.    W : KDF9.word;
    36.
    37.    procedure access_the_OUT_operand is
    38.    begin
    39.       ensure_that_the_NEST_holds_an_operand;
    40.       W := pop;
    41.       Q := as_Q(W);
    42.       the_trace_operand := W;
    43.     end access_the_OUT_operand;
    44.
    45.    procedure ensure_that_DR0_is_enabled (OUT_number : in KDF9.word) is
    46.    begin
    47.       if not DR0_is_enabled then
    48.          trap_failing_OUT(OUT_number, "there is no drum in this configuration");
    49.       end if;
    50.    end ensure_that_DR0_is_enabled;
    51.
    52.    procedure formulate_the_drum_transfer_operand (OUT_number : in KDF9.word) is
    53.       S : KDF9.word;
    54.    begin
    55.       ensure_that_DR0_is_enabled(OUT_number);
    56.       if not OUT13_was_done then
    57.          trap_failing_OUT(OUT_number, "obeyed before OUT 13");
    58.       end if;
    59.       S := KDF9.word(Q.C + (Q.M - Q.I + bytes_per_sector/2) / bytes_per_sector);
    60.       if S > last_reserved_DR_sector then
    61.          trap_failing_OUT(OUT_number, "too many drum sectors would be transferred");
    62.       end if;
    63.       Q := (Q.C*16 + DR0_number, Q.I, Q.M);
    64.       the_trace_operand := as_word(Q);
    65.    end formulate_the_drum_transfer_operand;
    66.
    67.    procedure do_OUT_11 is
    68.    begin
    69.       access_the_OUT_operand;
    70.       formulate_the_drum_transfer_operand(11);
    71.       restore_the_IO_OUT_operands(11, W);
    72.          POA(Q, False);
    73.       remove_the_IO_OUT_operands;
    74.    end do_OUT_11;
    75.
    76.    procedure do_OUT_12 is
    77.    begin
    78.       access_the_OUT_operand;
    79.       formulate_the_drum_transfer_operand(12);
    80.       restore_the_IO_OUT_operands(12, W);
    81.          PIA(Q, False);
    82.       remove_the_IO_OUT_operands;
    83.    end do_OUT_12;
    84.
    85.    procedure do_OUT_13 is
    86.    begin
    87.       access_the_OUT_operand;
    88.       ensure_that_DR0_is_enabled(13);
    89.       if OUT13_was_done then
    90.          trap_failing_OUT(13, "obeyed a second time");
    91.       end if;
    92.       if W > sectors_per_system or else
    93.             W = 0                  then
    94.          trap_failing_OUT(13, "demands an impossible number of drum sectors");
    95.       end if;
    96.       last_reserved_DR_sector := W - 1;
    97.       OUT13_was_done := True;
    98.       set_state_of(buffer(DR0_number), allocated => True);
    99.       log_API_message("OUT 13: allocated" & W'Image & " drum sectors");
   100.    end do_OUT_13;
   101.
   102.    procedure do_OUT_14 is
   103.    begin
   104.       -- I assume that the drum never experiences a parity error in ee9.
   105.       ensure_that_DR0_is_enabled(14);
   106.       if OUT13_was_done then
   107.          the_trace_operand := (sectors_per_system - last_reserved_DR_sector - 1) or 2**47;
   108.       else
   109.          the_trace_operand := sectors_per_system;
   110.       end if;
   111.       push(the_trace_operand);
   112.    end do_OUT_14;
   113.
   114. end IOC.fast.DR.TSD_OUTs;

Compiling: ../Source/ioc-fast-dr-tsd_outs.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:52

     1. -- Implement the drum API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.DR.TSD_OUTs is
    18.
    19.    procedure do_OUT_11;
    20.
    21.    procedure do_OUT_12;
    22.
    23.    procedure do_OUT_13;
    24.
    25.    procedure do_OUT_14;
    26.
    27.    procedure free_any_reserved_drum_space;
    28.
    29. end IOC.fast.DR.TSD_OUTs;

 114 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-fd-tsd_outs.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:53

     1. -- Implement the fixed disc API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.dispatcher;
    18. with KDF9.TSD;
    19.
    20. use  IOC.dispatcher;
    21. use  KDF9.TSD;
    22.
    23. package body IOC.fast.FD.TSD_OUTs is
    24.
    25.    -- See the Manual, Appendix 6, §2 for the TSD FD OUTs.
    26.
    27.    claimable_discs              : constant := 8;
    28.    sectors_per_logical_block    : constant := 16;
    29.    logical_blocks_per_seek_area : constant := sectors_per_seek_area / sectors_per_logical_block;
    30.    logical_blocks_per_platter   : constant := seek_areas_per_platter * logical_blocks_per_seek_area;
    31.    sectors_per_platter          : constant := sectors_per_logical_block * logical_blocks_per_platter;
    32.
    33.    type reserved_disc_set is
    34.       record
    35.          claimed : Boolean := False;
    36.          size    : KDF9.Q_part range 0 .. claimable_discs;
    37.          sectors : KDF9.Q_part range 0 .. claimable_discs * sectors_per_platter;
    38.          start   : KDF9.Q_part range 0 .. claimable_discs;
    39.       end record;
    40.
    41.    disc_set             : array (KDF9.Q_part range 1 .. 2) of reserved_disc_set;
    42.    disc_sets_claimed    : KDF9.Q_part range 0 .. 2 := 0;
    43.    current_disc_set     : KDF9.Q_part range 1 .. 2;
    44.    discs_claimed_so_far : KDF9.Q_part := 0;
    45.
    46.    procedure free_any_reserved_disc_space is
    47.    begin
    48.       disc_sets_claimed := 0;
    49.       discs_claimed_so_far := 0;
    50.    end free_any_reserved_disc_space;
    51.
    52.    function FD_seek_parameter (OUT_number: KDF9.word; Q : KDF9.Q_register)
    53.    return KDF9.Q_register is
    54.       current_set : reserved_disc_set renames disc_set(current_disc_set);
    55.       block       : constant KDF9.Q_part := Q.C / sectors_per_logical_block;
    56.       seek_area   : constant KDF9.Q_part := block  /  (6 * current_set.size);
    57.       residue     : constant KDF9.Q_part := block mod (6 * current_set.size);
    58.       disc        : constant KDF9.Q_part := residue / 6 + current_set.start;
    59.       drive       : constant KDF9.Q_part := 0;  -- ee9 will reserve discs on drive 0 only.
    60.       parameter   : constant KDF9.Q_part
    61.                   := drive * seek_areas_per_platter * main_discs_per_drive
    62.                    + disc  * seek_areas_per_platter
    63.                    + seek_area;
    64.    begin
    65.       if Q.C >= disc_set(current_disc_set).sectors then
    66.          trap_failing_OUT(OUT_number, Q.C'Image & " exceeds the sector capacity of the selected set");
    67.       end if;
    68.       return (parameter * 16 + FD0_number,  Q.I, Q.M);
    69.    end FD_seek_parameter;
    70.
    71.    function FD_xfer_parameter (Q : KDF9.Q_register)
    72.    return KDF9.Q_register is
    73.       sector : constant KDF9.Q_part := Q.C mod 96;
    74.    begin
    75.       return (sector * 16 + FD0_number, Q.I, Q.M);
    76.    end FD_xfer_parameter;
    77.
    78.    Q : KDF9.Q_register;
    79.    W : KDF9.word;
    80.
    81.    procedure ensure_that_FD0_is_enabled (OUT_number : in KDF9.word) is
    82.    begin
    83.       if not FD0_is_enabled then
    84.          trap_failing_OUT(OUT_number, "there is no disc in this configuration");
    85.       end if;
    86.    end ensure_that_FD0_is_enabled;
    87.
    88.    procedure access_the_operand is
    89.    begin
    90.       ensure_that_the_NEST_holds_an_operand;
    91.       W := pop;
    92.       Q := as_Q(W);
    93.       the_trace_operand := W;
    94.    end access_the_operand;
    95.
    96.    procedure do_OUT_41 is
    97.       F       : KDF9.Q_part;
    98.       seek_Q,
    99.       write_Q : KDF9.Q_register;
   100.    begin
   101.       access_the_operand;
   102.       ensure_that_FD0_is_enabled(41);
   103.       if disc_sets_claimed = 0 then
   104.          trap_failing_OUT(41, "tries to write to FD0 with no discs reserved");
   105.       end if;
   106.       W := KDF9.word(Q.C) / 16;
   107.       F := Q.C mod 16 + (Q.M - Q.I + words_per_sector - 1)/words_per_sector;
   108.       if F >= sectors_per_logical_block then
   109.          trap_failing_OUT(41, "tries to write past the end of a logical block on FD0");
   110.       end if;
   111.       seek_Q  := FD_seek_parameter(41, Q);
   112.       write_Q := FD_xfer_parameter(Q);
   113.       the_trace_operand := as_word(write_Q);
   114.       restore_the_IO_OUT_operands(42, W);
   115.          PMA(seek_Q, False);
   116.          POA(write_Q, False);
   117.       remove_the_IO_OUT_operands;
   118.    end do_OUT_41;
   119.
   120.    procedure do_OUT_42 is
   121.       F      : KDF9.Q_part;
   122.       seek_Q,
   123.       read_Q : KDF9.Q_register;
   124.    begin
   125.       access_the_operand;
   126.       ensure_that_FD0_is_enabled(42);
   127.       if disc_sets_claimed = 0 then
   128.          trap_failing_OUT(42, "tries to read from FD0 with no discs reserved");
   129.       end if;
   130.       W := KDF9.word(Q.C) / 16;
   131.       F := Q.C mod 16 + (Q.M - Q.I + words_per_sector - 1)/words_per_sector;
   132.       if F >= sectors_per_logical_block then
   133.          trap_failing_OUT(42, "tries to read past the end of a logical block on FD0");
   134.       end if;
   135.       seek_Q := FD_seek_parameter(41, Q);
   136.       read_Q := FD_xfer_parameter(Q);
   137.       the_trace_operand := as_word(read_Q);
   138.       restore_the_IO_OUT_operands(42, W);
   139.          PMA(seek_Q, False);
   140.          PIA(read_Q, False);
   141.       remove_the_IO_OUT_operands;
   142.    end do_OUT_42;
   143.
   144.    procedure do_OUT_43 is
   145.       F : KDF9.Q_part;
   146.    begin
   147.       access_the_operand;
   148.       ensure_that_FD0_is_enabled(43);
   149.       if disc_sets_claimed = 0 then
   150.          trap_failing_OUT(43, "no FD0 discs have been reserved yet");
   151.       end if;
   152.       if W not in 0 | -1 then
   153.          trap_failing_OUT(43, "tries to select an impossible set of discs");
   154.       end if;
   155.       F := as_Q(-W).M + 1;
   156.       if F > disc_sets_claimed then
   157.          trap_failing_OUT(43, "tries to select an unreserved FD0 disc set");
   158.       end if;
   159.       current_disc_set := as_Q(-the_trace_operand).M + 1;
   160.    end do_OUT_43;
   161.
   162.    procedure do_OUT_44 is
   163.       F : KDF9.Q_part;
   164.    begin
   165.       access_the_operand;
   166.       ensure_that_FD0_is_enabled(44);
   167.       if disc_sets_claimed = 2 then
   168.          trap_failing_OUT(44, "tries to reserve more than two sets of FD0 discs");
   169.       end if;
   170.       F := as_Q(W).M;
   171.       if W not in 1..claimable_discs                        or else
   172.             discs_claimed_so_far + F not in 1..claimable_discs then
   173.          trap_failing_OUT(44, "tries to reserve more than 8 FD0 discs");
   174.       end if;
   175.       current_disc_set := disc_sets_claimed + 1;
   176.       disc_set(current_disc_set).claimed := True;
   177.       disc_set(current_disc_set).size := F;
   178.       disc_set(current_disc_set).sectors := F * sectors_per_platter;
   179.       disc_set(current_disc_set).start := discs_claimed_so_far;
   180.       discs_claimed_so_far := discs_claimed_so_far + F;
   181.       disc_sets_claimed := disc_sets_claimed + 1;
   182.       log_API_message(
   183.                       "OUT 44: reserved"
   184.                     & F'Image
   185.                     & " FD0 disc"
   186.                     & plurality(KDF9.word(F))
   187.                     & " in set"
   188.                     & current_disc_set'Image
   189.                      );
   190.       set_state_of(buffer(FD0_number), allocated => True);
   191.    end do_OUT_44;
   192.
   193.    procedure do_OUT_45 is
   194.       F : KDF9.Q_part;
   195.    begin
   196.       access_the_operand;
   197.       ensure_that_FD0_is_enabled(45);
   198.       if disc_sets_claimed = 0 then
   199.          trap_failing_OUT(45, "tries to release an unreserved set of FD0 discs");
   200.       end if;
   201.       if W not in 0 | -1 then
   202.          trap_failing_OUT(45, "tries to release an unknown set of FD0 discs");
   203.       end if;
   204.       F := as_Q(-W).M + 1;
   205.       if F > disc_sets_claimed then
   206.          trap_failing_OUT(45, "tries to release more FD0 disc sets than are reserved");
   207.       end if;
   208.       log_API_message(
   209.                       "OUT 45: released"
   210.                     & disc_set(F).size'Image
   211.                     & " FD0 disc"
   212.                     & plurality(KDF9.word(disc_set(F).size))
   213.                     & " from set"
   214.                     & F'Image
   215.                      );
   216.       discs_claimed_so_far := discs_claimed_so_far - disc_set(F).size;
   217.       current_disc_set := 1;
   218.       disc_sets_claimed := disc_sets_claimed - 1;
   219.       if F = 1 then
   220.          disc_set(1) := disc_set(2);
   221.          disc_set(2).claimed := False;
   222.       end if;
   223.    end do_OUT_45;
   224.
   225.    procedure do_OUT_47 is
   226.    begin
   227.       the_trace_operand := pop;
   228.       -- I assume that disc transfer parity errors never occur under ee9.
   229.       ensure_that_FD0_is_enabled(47);
   230.       if disc_sets_claimed = 0 then
   231.          trap_failing_OUT(47, "tries to check a transfer on unreserved FD0 discs");
   232.       end if;
   233.    end do_OUT_47;
   234.
   235. end IOC.fast.FD.TSD_OUTs;

Compiling: ../Source/ioc-fast-fd-tsd_outs.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:53

     1. -- Implement the fixed disc API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.FD.TSD_OUTs is
    18.
    19.    -- See the Manual, Appendix 6, §2 for the TSD FD OUTs.
    20.
    21.    procedure do_OUT_41;
    22.
    23.    procedure do_OUT_42;
    24.
    25.    procedure do_OUT_43;
    26.
    27.    procedure do_OUT_44;
    28.
    29.    procedure do_OUT_45;
    30.
    31.    procedure do_OUT_47;
    32.
    33.    procedure free_any_reserved_disc_space;
    34.
    35. end IOC.fast.FD.TSD_OUTs;

 235 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-fast-tape-tsd_outs.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:53

     1. -- Emulation of magnetic tape decks and buffers.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.fast.tape.TSD_OUTs is
    18.
    19.    type short_label is new String(1 .. 8);
    20.    type long_label  is new String(1 .. 16);
    21.
    22.    function needs_rewinding (b : KDF9.buffer_number)
    23.    return Boolean is
    24.       the_deck : tape.deck renames tape.deck(buffer(b).all);
    25.    begin
    26.       return the_deck.is_open and then the_deck.tape_file.position > 0;
    27.    end needs_rewinding;
    28.
    29.    procedure do_OUT_4 is
    30.       B : KDF9.Q_part;
    31.       S : KDF9.word;
    32.       W : KDF9.word;
    33.    begin
    34.       ensure_that_the_NEST_holds_an_operand;
    35.       W := pop;
    36.       declare
    37.          label : constant short_label := short_label(to_string(W));
    38.       begin
    39.          find_tape(tape.data_storage(label), B, S);
    40.          push(KDF9.word(B));
    41.          the_trace_operand := KDF9.word(B);
    42.          if W = 0 then
    43.             log_API_message("OUT 4: requested a ZERO tape  and got "
    44.                           & device_name_of(buffer(B).all)
    45.                           & " with TSN «"
    46.                           & to_string(S)
    47.                           & "»"
    48.                            );
    49.          else
    50.             log_API_message("OUT 4: requested  «"
    51.                           & String(label)
    52.                           & "»  and got "
    53.                           & device_name_of(buffer(B).all)
    54.                           & " with TSN «"
    55.                           & to_string(S)
    56.                           & "»"
    57.                            );
    58.          end if;
    59.       end;
    60.       set_state_of(buffer(B), allocated => True);
    61.    end do_OUT_4;
    62.
    63.    procedure do_OUT_10 is
    64.       B : KDF9.Q_part;
    65.       P : KDF9.pair;
    66.       S : KDF9.word;
    67.    begin
    68.       ensure_that_the_NEST_holds_2_operands;
    69.       P := pop;
    70.       declare
    71.          label : constant long_label := long_label(to_string(P));
    72.       begin
    73.          find_tape(tape.data_storage(label), B, S);
    74.          push(S);
    75.          push(KDF9.word(B));
    76.          the_trace_operand := KDF9.word(B);
    77.          log_API_message("OUT 10: requested «"
    78.                        & String(label)
    79.                        & "» and got "
    80.                        & device_name_of(buffer(B).all)
    81.                        & " with TSN «"
    82.                        & to_string(S)
    83.                        & "»"
    84.                         );
    85.       end;
    86.       set_state_of(buffer(B), allocated => True);
    87.    end do_OUT_10;
    88.
    89. end IOC.fast.tape.TSD_OUTs;

Compiling: ../Source/ioc-fast-tape-tsd_outs.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:53

     1. -- Implement the magnetic tape API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.tape.TSD_OUTs is
    18.
    19.    procedure do_OUT_4;
    20.
    21.    procedure do_OUT_10;
    22.
    23.    function needs_rewinding (b : KDF9.buffer_number)
    24.    return Boolean;
    25.
    26. end IOC.fast.tape.TSD_OUTs;

 89 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd-peripherals.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:53

     1. -- Implement OUTs 5, 6 and 7 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC;
    18. with IOC.fast.tape.TSD_OUTs;
    19. with IOC.slow.shift.SI;
    20. with IOC.slow.shift.TR;
    21. with KDF9.store;
    22.
    23. use  IOC;
    24. use  IOC.fast.tape.TSD_OUTs;
    25. use  IOC.slow.shift.SI;
    26. use  IOC.slow.shift.TR;
    27. use  KDF9.store;
    28.
    29. package body KDF9.TSD.peripherals is
    30.
    31.    -- is_free_for_explicit_allocation keeps a note of explicitly requested allocations by OUT 5.
    32.    -- Implicit allocations by OUT 8 are done to prevent spurious LIVs on the output devices,
    33.    --    but they must not cause explicit reservations by OUT 5 to fail.
    34.
    35.    is_free_for_explicit_allocation : array(KDF9.buffer_number) of Boolean := (others => True);
    36.    is_implicitly_allocated_to_OUT8 : array(KDF9.buffer_number) of Boolean := (others => False);
    37.
    38.    procedure free_all_devices is
    39.    begin
    40.       is_free_for_explicit_allocation := (others => True);
    41.       is_implicitly_allocated_to_OUT8 := (others => False);
    42.       for b in KDF9.buffer_number loop
    43.          set_state_of(buffer(b), allocated => False);
    44.       end loop;
    45.       --  Keep FW0 online.
    46.       set_state_of(buffer(0), allocated => True);
    47.    end free_all_devices;
    48.
    49.    procedure let_OUT_8_use_the_device_on_buffer (B : in KDF9.buffer_number) is
    50.    begin
    51.       is_implicitly_allocated_to_OUT8(B) := True;
    52.       set_state_of(buffer(B), allocated => True);
    53.    end let_OUT_8_use_the_device_on_buffer;
    54.
    55.    -- These are the device-type codes to be given when requesting
    56.    --    the allocation of a peripheral with TSD OUT 5,
    57.    --       according to the Manual and the document:
    58.    --          "Service Routine Library Manual" §22.13, p22-28-0.
    59.
    60.    FW_OUT5_code : constant := 0;
    61.    TP_OUT5_code : constant := 1;
    62.    TR_OUT5_code : constant := 2;
    63.    LP_OUT5_code : constant := 3;
    64.    CR_OUT5_code : constant := 4;
    65.    FP_OUT5_code : constant := 5;      -- Ferranti 5-channel Tape punch
    66.    CP_OUT5_code : constant := 7;
    67.    GP_OUT5_code : constant := 8#20#;
    68.    SI_OUT5_code : constant := 8#21#;  -- Standard Interface, "Data Link, N.P.L. Special Buffer"
    69.    FE_OUT5_code : constant := 8#65#;  -- Tape buffer link for PDP-8 on Eldon2, and perhaps COTAN
    70.    UT_OUT5_code : constant := 8#67#;  -- Unlabelled Tape
    71.
    72.    procedure select_the_next_device_from_among
    73.       (device_A, device_B : in  KDF9.buffer_number;
    74.        chosen_device      : out KDF9.buffer_number;
    75.        wanted_type        : in String) is
    76.    begin
    77.       if device_A /= 0                            and then
    78.             is_free_for_explicit_allocation(device_A) then
    79.          chosen_device := device_A;
    80.       elsif device_B /= 0                         and then
    81.             is_free_for_explicit_allocation(device_B) then
    82.          chosen_device := device_B;
    83.       else
    84.          trap_failing_OUT(5, "there is no available device of type " & wanted_type);
    85.       end if;
    86.    end select_the_next_device_from_among;
    87.
    88.    procedure allocate_a_device is
    89.       B : KDF9.buffer_number;
    90.       W : KDF9.word;
    91.    begin
    92.       ensure_that_the_NEST_holds_an_operand;
    93.       W := read_top;
    94.
    95.       case W is
    96.          -- 8 was added to the code to pre-allocate a device.
    97.          -- I treat pre-allocating and allocating the same way here.
    98.          when FW_OUT5_code
    99.             | FW_OUT5_code+8 =>
   100.             B := 0;  -- Always allowed, no checking performed.
   101.          when TP_OUT5_code
   102.             | TP_OUT5_code+8
   103.             | FP_OUT5_code
   104.             | FP_OUT5_code+8 =>
   105.             select_the_next_device_from_among(TP0_number, TP1_number, B, "TP");
   106.          when TR_OUT5_code
   107.             | TR_OUT5_code+8 =>
   108.             -- TR0 is used for reading the bootstrap/problem program in KDF9 code.
   109.             -- When there is Latin-1 data it therefore needs to go in via TR1.
   110.             -- N.B. the TR devices must appear in this order.
   111.             select_the_next_device_from_among(TR1_number, TR0_number, B, "TR");
   112.             set_case(IOC.slow.shift.TR.device(buffer(B).all));
   113.          when LP_OUT5_code
   114.             | LP_OUT5_code+8 =>
   115.             select_the_next_device_from_among(LP0_number, LP1_number, B, "LP");
   116.          when CR_OUT5_code
   117.             | CR_OUT5_code+8 =>
   118.             select_the_next_device_from_among(CR0_number, CR1_number, B, "CR");
   119.          when CP_OUT5_code
   120.             | CP_OUT5_code+8 =>
   121.             select_the_next_device_from_among(CP0_number, CP1_number, B, "CP");
   122.          when GP_OUT5_code
   123.             | GP_OUT5_code+8 =>
   124.             -- There is only 1 graph plotter.
   125.             select_the_next_device_from_among(GP0_number, GP0_number, B, "GP");
   126.          when SI_OUT5_code =>
   127.             if SI0_is_enabled then
   128.                select_the_next_device_from_among(SI0_number, SI1_number, B, "SI");
   129.             else
   130.                trap_failing_OUT(5, "the SI buffer has not been enabled");
   131.             end if;
   132.          when FE_OUT5_code =>
   133.             trap_unimplemented_feature("PDP-8 Front End Tape buffers");
   134.          when UT_OUT5_code =>
   135.             trap_unimplemented_feature("Unlabelled Tape buffers");
   136.          when others =>
   137.             trap_failing_OUT(5, "unknown device type #" & oct_of(W));
   138.       end case;
   139.
   140.       is_free_for_explicit_allocation(B) := False;
   141.       set_state_of(buffer(B), allocated => True);
   142.
   143.       pop;
   144.       push(KDF9.word(B));
   145.       the_trace_operand := KDF9.word(B);
   146.
   147.       if buffer(B).all in IOC.slow.shift.device'Class and then
   148.             buffer(B).kind /= GP_kind                     then
   149.          log_API_message("OUT 5: requested a #"
   150.                        & oct_of(KDF9.Q_part(W), 2)
   151.                        & " device and got "
   152.                        & device_name_of(buffer(B).all)
   153.                        & (
   154.                           if IOC.slow.shift.device(buffer(B).all).uses_Latin_1 then
   155.                              " in Latin-1 mode"
   156.                           else
   157.                              " in KDF9 mode"
   158.                          )
   159.                         );
   160.       else
   161.          log_API_message("OUT 5: requested a #"
   162.                        & oct_of(KDF9.Q_part(W), 2)
   163.                        & " device and got "
   164.                        & device_name_of(buffer(B).all)
   165.                         );
   166.       end if;
   167.    end allocate_a_device;
   168.
   169.    procedure free_the_device_on_buffer (B : in KDF9.buffer_number; OUT_number : in KDF9.word) is
   170.    begin
   171.       if buffer(B).kind in MT_kind | ST_kind then
   172.          if needs_rewinding(b) then
   173.             PMD(buffer(B).all, KDF9.Q_register'(B, 0, 0), set_offline => (OUT_number = 6));
   174.          end if;
   175.       elsif OUT_number = 7 then
   176.          trap_failing_OUT(7, "device #" & oct_of(B, 2) & ", is not a tape deck");
   177.       end if;
   178.       is_free_for_explicit_allocation(B) := True;
   179.       set_state_of(buffer(B), allocated => is_implicitly_allocated_to_OUT8(B));
   180.       log_API_message("OUT" & OUT_number'Image & ": released " & device_name_of(buffer(B).all));
   181.    end free_the_device_on_buffer;
   182.
   183.    procedure deallocate_a_device (OUT_number : in KDF9.word) is
   184.       B : KDF9.Q_part;
   185.    begin
   186.       ensure_that_the_NEST_holds_an_operand;
   187.       the_trace_operand := pop;
   188.       if the_trace_operand > 15 then
   189.          notify_state_display_of_final_ICR;
   190.          trap_failing_OUT(OUT_number, "#" & oct_of(the_trace_operand) & " is not a valid buffer number");
   191.       end if;
   192.       B := KDF9.buffer_number(the_trace_operand);
   193.       if is_unallocated(buffer(B)) then
   194.          trap_failing_OUT(OUT_number, "device #" & oct_of(B, 2) & " is not allocated to this program");
   195.       end if;
   196.       free_the_device_on_buffer(B, OUT_number);
   197.    end deallocate_a_device;
   198.
   199.    procedure do_OUT_5 is
   200.    begin
   201.       allocate_a_device;
   202.    end do_OUT_5;
   203.
   204.    procedure do_OUT_6 is
   205.    begin
   206.       deallocate_a_device(OUT_number => 6);
   207.    end do_OUT_6;
   208.
   209.    procedure do_OUT_7 is
   210.    begin
   211.       deallocate_a_device(OUT_number => 7);
   212.    end do_OUT_7;
   213.
   214.
   215. end KDF9.TSD.peripherals;

Compiling: ../Source/kdf9-tsd-peripherals.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:53

     1. -- Implement 5, 6 and 7 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.peripherals is
    18.
    19.    procedure do_OUT_5;
    20.
    21.    procedure do_OUT_6;
    22.
    23.    procedure do_OUT_7;
    24.
    25.    procedure let_OUT_8_use_the_device_on_buffer (B : in KDF9.buffer_number);
    26.
    27.    procedure free_all_devices;
    28.
    29.    procedure free_the_device_on_buffer (B : in KDF9.buffer_number; OUT_number : in KDF9.word);
    30.
    31. end KDF9.TSD.peripherals;

 215 lines: No errors


Compiling: /home/parallels/emulation/Source/kdf9-tsd-spooling.adb
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:53

     1. -- Implement a subset of the Time Sharing Director's OUT 8 / OUT 16 spooling API.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC;
    18. with IOC.dispatcher;
    19. with IOC.slow.shift.FW;
    20. with KDF9.store;
    21. with KDF9.TSD.peripherals;
    22.
    23. use  IOC;
    24. use  IOC.dispatcher;
    25. use  IOC.slow.shift.FW;
    26. use  KDF9.store;
    27. use  KDF9.TSD.peripherals;
    28.
    29. package body KDF9.TSD.spooling is
    30.
    31.    procedure do_IO (this_OUT : in KDF9.word) is
    32.
    33.       function destination_device_for (the_stream : KDF9.word)
    34.       return IOC.device_number is
    35.          data_word  : constant String(1..16) := oct_of(the_stream);
    36.          the_device : IOC.device_number;
    37.          the_type   : String(1..2);
    38.       begin
    39.          case the_stream is
    40.             when 8#00# =>
    41.                return 0;
    42.             when 8#10# |8#12# |8#14# | 8#16# =>
    43.                the_device := TP0_number; the_type := "TP";
    44.             when 8#11# |8#13# |8#15# | 8#17# =>
    45.                the_device := TP1_number; the_type := "TP";
    46.             when 8#30#..8#37# =>
    47.                the_device := LP0_number; the_type := "LP";
    48.             when 8#50#..8#57# =>
    49.                the_device := TP1_number; the_type := "TP";
    50.             when 8#70#..8#77# =>
    51.                the_device := LP0_number; the_type := "LP";
    52.             when others =>
    53.                trap_failing_OUT(8, "invalid stream #" & data_word);
    54.          end case;
    55.          if the_device = 0 then
    56.             trap_operator_error("OUT 8 needs a " & the_type & " for stream #" & data_word(15..16));
    57.          end if;
    58.          return the_device;
    59.       end destination_device_for;
    60.
    61.       W, the_stream : KDF9.word;
    62.       Q, G    : KDF9.Q_register;
    63.
    64.       procedure prepare_output_to_FW0 is
    65.          message_prefix  : constant KDF9.word := 8#02_06_21_55_22_00_07_77#; -- LS CS [ m ] SP CN Ø
    66.          prompt_prefix   : constant KDF9.word := 8#02_06_21_61_22_00_07_77#; -- LS CS [ q ] SP CN Ø
    67.          OUT_16_prefix   : constant KDF9.word := 8#02_07_56_33_00_77_77_77#; -- LS CN N º SP Ø  Ø Ø
    68.          filler_in_D0_D5 : constant KDF9.word := 8#77_00_00_00_00_00_00_00#; -- Ø
    69.          S               : KDF9_char_sets.symbol := KDF9_char_sets.Word_Filler;
    70.          the_prefix      : KDF9.word;
    71.       begin  -- prepare_output_to_FW0
    72.          -- The logic of FW streams is rather complex, to preserve the layout of the typescript.
    73.          -- There are three significant aspects.
    74.
    75.          -- 1. The message is truncated if longer than 8 words.
    76.          if Q.M - Q.I > 8 then
    77.             Q.M := Q.I + 8;
    78.          end if;
    79.
    80.          -- 2. It must not contain LS or HT;
    81.          --       nor ';' in the last word;
    82.          --          nor ';' other than in character position 7;
    83.          --    but anything after an End Message can safely be ignored.
    84.          word_loop: for w in Q.I+1 .. Q.M loop
    85.              for c in KDF9_char_sets.symbol_index'Range loop
    86.                 S := fetch_symbol(w, c);
    87.                 if S = KDF9_char_sets.Line_Shift                                 or else
    88.                       S = KDF9_char_sets.Tabulation                              or else
    89.                          ((S = KDF9_char_sets.Semi_Colon) and (c /= 7 or  w = Q.M)) then
    90.                    trap_failing_OUT(this_OUT, "invalid data for OUT 8 to FW");
    91.                 end if;
    92.          exit word_loop when S in KDF9_char_sets.Semi_Colon | KDF9_char_sets.End_Message;
    93.              end loop;
    94.          end loop word_loop;
    95.
    96.          the_prefix := (if S = KDF9_char_sets.Semi_Colon then prompt_prefix else message_prefix);
    97.          the_prefix := (if this_OUT = 16                 then OUT_16_prefix else the_prefix);
    98.
    99.          -- 3. Take a new line for each OUT 8 message to the FW.
   100.          --    Set up the format effector(s) in the first word of the OUT 8 area.
   101.          declare
   102.             package FW renames IOC.slow.shift.FW;
   103.             the_FW : FW.device renames FW.device(buffer(0).all);
   104.          begin
   105.             if a_LF_was_just_read(the_FW) then
   106.                -- Replace the redundant Line Shift with a Word Filler character.
   107.                store_word(the_prefix or filler_in_D0_D5, Q.I);
   108.             else
   109.                -- The initial Line Shift is needed.
   110.                store_word(the_prefix, Q.I);
   111.             end if;
   112.          end;
   113.       end prepare_output_to_FW0;
   114.
   115.       page_change : constant := 8#77_77_77_77_77_77_77_03#;  --  LP Page Change character
   116.
   117.    begin  -- do_IO
   118.       ensure_that_the_NEST_holds_an_operand;
   119.       W := pop;
   120.       Q := as_Q(W);
   121.       the_trace_operand := W;
   122.
   123.       -- A FW query has (only) D0 of the control word set.
   124.       if (Q.C and 8#1_00000#) /= 0 then
   125.          Q.C := 0;
   126.       end if;
   127.
   128.       if Q.C = Q.I and Q.I = Q.M then
   129.          -- The N2 parameter specifies stream closure.
   130.          flush(buffer(destination_device_for(KDF9.word(Q.C))).all);
   131.          return;
   132.       end if;
   133.
   134.       --
   135.       -- This must precede anything that might LOV, e.g. store accesses and I/O orders.
   136.       --
   137.       restore_the_IO_OUT_operands(this_OUT, W);
   138.       --
   139.       --
   140.       --
   141.
   142.       -- The (Q, from N2) parameter specifies a block starting with the stream number.
   143.       check_address_and_lockout(Q.I);
   144.       the_stream := fetch_word(Q.I);
   145.
   146.       Q.C := destination_device_for(the_stream);
   147.       let_OUT_8_use_the_device_on_buffer(Q.C);
   148.
   149.       check_address_and_lockout(Q.I+1);
   150.       G := as_Q(fetch_word(Q.I+1));
   151.
   152.       -- See the Manual, §12.6.1.
   153.       if G.C = 4095 and then G.I = 8#177777# then
   154.          -- The G parameter specifies output of a 'gap' suitable for the device.
   155.          if G.M = 0 then
   156.             -- Do nothing.
   157.             the_trace_operand := as_word(G);
   158.          elsif destination_device_for(the_stream) in TP0_number | TP1_number then
   159.             -- Write runout according to the character set mode of the punch.
   160.             G.M := (if G.M in 1 .. 511 then G.M else 120);
   161.             Q := (Q.C, 0, G.M);
   162.             the_trace_operand := as_word(Q);
   163.             POE(Q, False);
   164.          elsif destination_device_for(the_stream) = LP0_number then
   165.              -- Write a Page Change.
   166.             store_word(page_change, Q.I);
   167.             Q := (Q.C, Q.I, Q.I);
   168.             the_trace_operand := as_word(Q);
   169.             POA(Q, False);
   170.          end if;
   171.
   172.          --
   173.          --
   174.          remove_the_IO_OUT_operands;
   175.          --
   176.          --
   177.
   178.          return;
   179.       end if;
   180.
   181.       if Q.M <= Q.I then
   182.          trap_failing_OUT(8, "invalid end-address #" & oct_of(Q.M));
   183.       end if;
   184.
   185.       if Q.C = 0 then
   186.          -- The logic for FW streams is more complex, to preserve the layout of the typescript.
   187.          prepare_output_to_FW0;
   188.       else
   189.          -- For non-FW streams, the first word of the OUT 8 area is not transferred.
   190.          Q.I := Q.I + 1;
   191.       end if;
   192.       the_trace_operand := as_word(Q);
   193.
   194.       POB(Q, False);
   195.
   196.       --
   197.       --
   198.       remove_the_IO_OUT_operands;
   199.       --
   200.       --
   201.
   202.    end do_IO;
   203.
   204.    procedure do_OUT_8 is
   205.    begin
   206.       do_IO(this_OUT => 8);
   207.    end do_OUT_8;
   208.
   209.    procedure do_OUT_16 is
   210.    begin
   211.       do_IO(this_OUT => 16);
   212.    end do_OUT_16;
   213.
   214. end KDF9.TSD.spooling;

Compiling: ../Source/kdf9-tsd-spooling.ads
Source file time stamp: 2021-06-28 18:14:50
Compiled at: 2021-06-28 19:31:53

     1. -- Implement a subset of the Time Sharing Director's OUT 8 / OUT 16 spooling API.
     2. --
     3. -- This file is part of ee9 (8.0k), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.spooling is
    18.
    19.    procedure do_OUT_8;
    20.
    21.    procedure do_OUT_16;
    22.
    23. end KDF9.TSD.spooling;

 214 lines: No errors
