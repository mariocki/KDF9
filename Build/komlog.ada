Version V5p2b of ee9 for macOS, built on Wed 30 Dec 2020 00:11:18 GMT.
mk9 'ee9' build: optimised and with full language checks, using configuration options:

pragma Unsuppress(All_Checks);
pragma Optimize_Alignment(Time);
pragma Assertion_Policy(Ignore);
pragma Validity_Checks(Off);
pragma Check_Policy(Debug, Off);
pragma Restrictions(Max_Asynchronous_Select_Nesting => 0);
pragma Restrictions(Max_Tasks => 0);
pragma Restrictions(No_Abort_Statements);
pragma Restrictions(No_Implementation_Attributes);
pragma Restrictions(No_Obsolescent_Features);

Using the build command:
gnatmake -aI../Source -aO../Build -funwind-tables -gnatl12j96 -gnatw.e -gnatwD -gnatwH -gnatwP -gnatwT -gnatw.W -gnatw.B -gnatwC -gnatw.u -gnatyO -gnatw.Y -gnatw.N -fdata-sections -ffunction-sections -gnatf -mtune=native -O3 -flto -j1 ee9 -bargs -static -Sin -largs -Wl,-dead_strip -Wl,-dead_strip -largs -flto

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ee9.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:18

     1. -- ee9.adb
     2. --
     3. -- This is the "main program" for the entire emulator.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with GNAT.Source_Info;
    20. --
    21. with Ada.Text_IO;
    22. with Ada.Command_Line;
    23. with Ada.Exceptions;
    24. --
    25. with exceptions;
    26. with HCI;
    27. with IOC.equipment;
    28. with IOC.slow.shift.TP;
    29. with IOC.slow.shift.TR;
    30. with settings;
    31.
    32. with execute;
    33. with say_goodbye;
    34.
    35. use  Ada.Text_IO;
    36. use  Ada.Exceptions;
    37. --
    38. use  exceptions;
    39. use  HCI;
    40. use  settings;
    41.
    42. procedure ee9 is
    43.
    44.    package CLI renames Ada.Command_Line;
    45.
    46.    the_log_file_name : constant String := "KDF9_log.txt";
    47.
    48.    a_command_line_error_is_detected : exception;
    49.
    50.    procedure show_proper_usage (message : in String := "") is
    51.    begin
    52.       if message /= "" then
    53.          log_line(message);
    54.       end if;
    55.       log_line(
    56.                "usage: ee9 { [ -s{b|p|t} ] | [ -d{f|p|t|x|-} ] | [ -m"
    57.              & miscellany_prompt
    58.              & " ] [ -TP{k|l}{k|l} ] [ -TR{k|l}{k|l} ] } +program_file_name"
    59.               );
    60.       CLI.Set_Exit_Status(CLI.Failure);
    61.       raise a_command_line_error_is_detected;
    62.    end show_proper_usage;
    63.
    64.    procedure complain (about : in String; because : in String := "") is
    65.    begin
    66.       show_proper_usage(
    67.                         "Parameter " & about & " is not valid"
    68.                       & (if because = "" then "." else " because " & because & ".")
    69.                        );
    70.    end complain;
    71.
    72.    the_program_name_position : Natural := 0;
    73.
    74.    procedure check_all_flag_settings is
    75.
    76.       procedure check_flag_setting (i : in Positive) is
    77.
    78.          subtype tape_code_flags is Character
    79.             with Predicate => tape_code_flags in 'K' | 'L' | 'k' | 'l';
    80.
    81.          subtype tape_device_flags is Character
    82.             with Predicate => tape_device_flags in 'P' | 'R' |'p' | 'r';
    83.
    84.          argument : constant String   := CLI.Argument(i);
    85.          index    : constant Positive := argument'First;
    86.
    87.       begin
    88.          -- Ignore an empty parameter.
    89.          if argument'Length = 0 then
    90.             return;
    91.          end if;
    92.
    93.          -- Take note of a program name parameter.
    94.          if argument(index) = '+' then
    95.             if the_program_name_position /= 0 then
    96.                complain(about   => argument,
    97.                         because => "more than one program has been specified");
    98.             end if;
    99.             if argument'Length < 3 then
   100.                complain(about   => argument,
   101.                         because => "it is too short for a program file name");
   102.             end if;
   103.             the_program_name_position := i;
   104.             return;
   105.          end if;
   106.
   107.          -- Fail any non-flag parameter.
   108.          if argument(index) /= '-'  then
   109.             complain(about => "'" & argument & "'");
   110.          end if;
   111.
   112.          -- Fail a too-short flag parameter.
   113.          if argument'Length < 2 then
   114.             complain(about   => argument,
   115.                      because => "it is too short");
   116.          end if;
   117.
   118.          -- Check for a miscellany parameter.
   119.          if argument'Length in 2 .. miscellany_flags'Length+2 and then
   120.                argument(index..index+1) = "-m"                    then
   121.             for i in index+2 .. argument'Last loop
   122.                if is_invalid_miscellany_flag(argument(i)) then
   123.                   complain(about => """" & argument & """ at """ & argument(i) & """");
   124.                end if;
   125.             end loop;
   126.             return;
   127.          end if;
   128.
   129.          -- Check for a state or diagnostic parameter.
   130.          if argument in "-sb" | "-sp" | "-st" | "-df" | "-dt" | "-dp" | "-dx" | "-d-" then
   131.             return;
   132.          end if;
   133.
   134.          -- Check for a Tape Punch/Reader parameter.
   135.          if argument'Length in 4 .. 5                    and then
   136.                argument(index+1) in 'T' | 't'            and then
   137.                   argument(index+2) in tape_device_flags and then
   138.                      argument(index+3) in tape_code_flags    then
   139.             if argument'Length = 4                  or else
   140.                   argument(index+4) in tape_code_flags then
   141.                return;
   142.             end if;
   143.          end if;
   144.
   145.          complain(about => argument);
   146.
   147.       end check_flag_setting;
   148.
   149.    begin -- check_all_flag_settings
   150.       if CLI.Argument_Count = 0 then
   151.          return;
   152.       end if;
   153.       for i in 1..CLI.Argument_Count loop
   154.          check_flag_setting(i);
   155.       end loop;
   156.    end check_all_flag_settings;
   157.
   158.    procedure impose_all_flag_settings is
   159.
   160.       procedure impose_flag_setting (i : in Positive) is
   161.
   162.          subtype Latin_1_code_flags is Character
   163.             with Predicate => Latin_1_code_flags in 'L' | 'l';
   164.
   165.          subtype punch_device_flags is Character
   166.             with Predicate => punch_device_flags in 'P' |'p';
   167.
   168.          argument : constant String   := CLI.Argument(i);
   169.          index    : constant Positive := argument'First;
   170.
   171.       begin -- impose_flag_setting
   172.          -- Ignore an empty parameter.
   173.          if argument'Length = 0 then
   174.             return;
   175.          end if;
   176.
   177.          -- Ignore a program_file_name parameter.
   178.          if argument(index) = '+'  then
   179.             return;
   180.          end if;
   181.
   182.          -- Impose a miscellany parameter.
   183.          if argument'Length in 2 .. miscellany_flags'Length+2 and then
   184.                argument(index..index+1) = "-m"  then
   185.             for i in index+2 .. argument'Last loop
   186.                set_this_miscellany_flag(argument(i));
   187.             end loop;
   188.             return;
   189.          end if;
   190.
   191.          -- Impose  a Tape Punch/Reader parameter.
   192.          if argument'Length in 4 .. 5 then
   193.             -- Set the code for the first device.
   194.             if argument(index+2) in punch_device_flags then
   195.                IOC.slow.shift.TP.set_unit_code(0, argument(index+3) in Latin_1_code_flags);
   196.             else
   197.                IOC.slow.shift.TR.set_unit_code(0, argument(index+3) in Latin_1_code_flags);
   198.             end if;
   199.          end if;
   200.          if argument'Length = 5 then
   201.             -- Set the code for the second device.
   202.             if argument(index+2) in punch_device_flags then
   203.                IOC.slow.shift.TP.set_unit_code(1, argument(index+4) in Latin_1_code_flags);
   204.             else
   205.                IOC.slow.shift.TR.set_unit_code(1, argument(index+4) in Latin_1_code_flags);
   206.             end if;
   207.          end if;
   208.
   209.          -- Impose a state or diagnostic parameter; argument is known to be 3 characters long.
   210.          if    argument = "-sb" then
   211.             set_execution_mode(boot_mode);
   212.          elsif argument = "-sp" then
   213.             set_execution_mode(program_mode);
   214.          elsif argument = "-st" then
   215.             set_execution_mode(test_program_mode);
   216.          elsif argument = "-d-" then
   217.             set_diagnostic_mode(fast_mode);
   218.          elsif argument = "-df" then
   219.             set_diagnostic_mode(fast_mode);
   220.          elsif argument = "-dt" then
   221.             set_diagnostic_mode(trace_mode);
   222.          elsif argument = "-dp" then
   223.             set_diagnostic_mode(pause_mode);
   224.          elsif argument = "-dx" then
   225.             set_diagnostic_mode(external_mode);
   226.          end if;
   227.       end impose_flag_setting;
   228.
   229.    begin -- impose_all_flag_settings
   230.       if CLI.Argument_Count = 0 then
   231.          return;
   232.       end if;
   233.       for i in 1..CLI.Argument_Count loop
   234.          impose_flag_setting(i);
   235.       end loop;
   236.    end impose_all_flag_settings;
   237.
   238.    function plain (f : String)
   239.    return String
   240.    is (f(f'First+1 .. f'Last));
   241.
   242.    function the_program_name
   243.    return String
   244.    is (plain(CLI.Argument(the_program_name_position)));
   245.
   246.    procedure tidy_up (reason : in String) is
   247.    begin
   248.       Put_Line(Standard_Error, reason & ".");
   249.       close(the_log_file_name);
   250.       CLI.Set_Exit_Status(CLI.Failure);
   251.    end tidy_up;
   252.
   253. begin -- ee9
   254.
   255.    check_all_flag_settings;
   256.    open(the_log_file_name);
   257.
   258.    if the_program_name_position /= 0 then
   259.       get_settings_from_file("1");
   260.       IOC.equipment.configure;
   261.       impose_all_flag_settings;
   262.       IOC.equipment.re_configure;
   263.       IOC.equipment.install_GP0;
   264.       if the_log_is_wanted then
   265.          log_line(
   266.                   "This is ee9 V5.2b, compiled by "
   267.                 & Standard'Compiler_Version
   268.                 & " on "
   269.                 & GNAT.Source_Info.Compilation_ISO_Date
   270.                 & "."
   271.                  );
   272.       end if;
   273.       display_execution_modes(the_program_name);
   274.       execute(the_program_name);
   275.    else
   276.       log_line("Cannot run ee9; no program file parameter was supplied.");
   277.    end if;
   278.
   279.    close(the_log_file_name);
   280.
   281. exception
   282.
   283.    when a_command_line_error_is_detected =>
   284.       tidy_up("Invalid command line");
   285.
   286.    when diagnostic : operator_error =>
   287.       say_goodbye("The KDF9 operator has made a mistake: ", Exception_Message(diagnostic));
   288.
   289.    when error : others =>
   290.       tidy_up("Failure in ee9; unexpected exception: " & Exception_Information(error));
   291.
   292. end ee9;

 292 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/exceptions.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:19

     1. -- exceptions.ads
     2. --
     3. -- Declare the exceptions used in emulation-mode control.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package exceptions is
    20.
    21.    -- program_exit is raised when a KDF9 program terminates normally.
    22.    program_exit : exception;
    23.
    24.   -- program_restart is raised when a KDF9 program executes OUT 2.
    25.    program_restart : exception;
    26.
    27.    -- time_expired is raised when a KDF9 program executes too many instructions.
    28.    time_expired : exception;
    29.
    30.    -- quit_request is raised when the user requests a quit at a break-in.
    31.    quit_request : exception;
    32.
    33.    -- input_is_impossible is raised when an attempt is made to read from the terminal in
    34.    --    noninteractive mode.  This prevents absent-user scripted usage from hanging.
    35.    input_is_impossible : exception;
    36.
    37.    -- operator_error is raised when the operating context is invalid; e.g. labelled tape not mounted.
    38.    operator_error : exception;
    39.
    40.    -- IO_error is raised when an impossible I/O operation is attempted in problem program state.
    41.    IO_error : exception;
    42.
    43.    -- Director_IO_error when an impossible I/O operation is attempted in Director state.
    44.    Director_IO_error : exception;
    45.
    46.    -- Director_failure is raised for an instruction that would LIV in problem program state.
    47.    Director_failure : exception;
    48.
    49.    -- invalid_paper_tape_file is raised when given invalid data for a KDF9-code paper tape file.
    50.    invalid_paper_tape_file : exception;
    51.
    52.    -- not_yet_implemented is raised by an incomplete emulation.
    53.    not_yet_implemented : exception;
    54.
    55.    -- emulation_failure is raised when an emulator self-check fails.
    56.    emulation_failure : exception;
    57.
    58.    -- debugging_stop is raised when a debugging run needs to halt at once.
    59.    debugging_stop : exception;
    60.
    61. end exceptions;

 61 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/execute.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:19

     1. -- execute.adb
     2. --
     3. -- This is the emulation-mode coordinate module.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with GNAT.Ctrl_C;
    20. --
    21. with Ada.Command_Line;
    22. with Ada.Exceptions;
    23. --
    24. with break_in;
    25. with dumping;
    26. with exceptions;
    27. with HCI;
    28. with IOC.slow.shift.TR;
    29. with KDF9;
    30. with KDF9.microcode;
    31. with settings;
    32. with state_display;
    33.
    34. with say_goodbye;
    35.
    36. use  Ada.Command_Line;
    37. use  Ada.Exceptions;
    38.
    39. --
    40. use  dumping;
    41. use  exceptions;
    42. use  HCI;
    43. use  IOC.slow.shift.TR;
    44. use  KDF9;
    45. use  KDF9.microcode;
    46. use  settings;
    47. use  state_display;
    48.
    49. procedure execute (program_name : in String) is
    50.
    51.    procedure check_times_and_modes
    52.       with Inline;
    53.
    54.    pause_count : KDF9.order_counter := 0;
    55.
    56.    procedure check_times_and_modes is
    57.    begin
    58.       if ICR > pause_count then
    59.          if ICR >= time_limit then
    60.             raise time_expired;
    61.          end if;
    62.          pause_count := pause_count + time_slice;
    63.          change_diagnostic_mode_if_requested;
    64.       end if;
    65.    end check_times_and_modes;
    66.
    67. begin  -- execute
    68.    GNAT.Ctrl_C.Install_Handler(break_in.note_user_interrupt'Access);
    69.
    70.    if the_external_trace_is_enabled then
    71.       log_an_external_trace_header;
    72.    end if;
    73.
    74.    case the_execution_mode is
    75.       when boot_mode =>
    76.          reset_the_internal_registers(Director_state);
    77.          boot_the_KDF9(program_name);
    78.       when test_program_mode=>
    79.          reset_the_internal_registers(Director_state);
    80.          load_a_program(program_name);
    81.       when program_mode =>
    82.          reset_the_internal_registers(program_state);
    83.          load_a_program(program_name);
    84.    end case;
    85.
    86.    if not loading_was_successful then
    87.       say_goodbye("Could not load the specified program.");
    88.       return;
    89.    end if;
    90.
    91.    poke_all_amendments;
    92.    show_all_prerun_dump_areas;
    93.
    94.    if do_not_execute then
    95.       log_new_line;
    96.       log_line("Run abandoned as requested.");
    97.       return;
    98.    end if;
    99.
   100.    reset_the_CPU_state;
   101.
   102. execution_loop:
   103.    loop
   104.
   105.       begin
   106.
   107.          check_times_and_modes;
   108.          if the_diagnostic_mode /= fast_mode then
   109.             -- Do a single, traced instruction, breaking-in conditionally.
   110.             do_a_traced_instruction_cycle;
   111.          else
   112.             -- Fast mode is designed for minimal overhead;
   113.             --    it interacts with the user only at the end of a time slice.
   114.             loop
   115.                do_a_fast_time_slice;
   116.                check_times_and_modes;
   117.             end loop;
   118.          end if;
   119.
   120.       exception  -- handler for execution_loop
   121.
   122.          when debugging_stop =>
   123.             null;
   124.
   125.          when mode_change_request =>
   126.             quit_if_requested;
   127.
   128.          when abandon_this_order =>
   129.             null;  -- Just get on with it after an interrupt or nullified order.
   130.
   131.          when LOV_trap =>
   132.             IOC.handle_a_main_store_lockout;
   133.
   134.          when program_exit =>
   135.             say_goodbye("Normal end of run", status => Success);
   136.             exit execution_loop;
   137.
   138.          when quit_request =>
   139.             say_goodbye("Run stopped by the user", status => Success);
   140.             exit execution_loop;
   141.
   142.          when time_expired =>
   143.             say_goodbye("Infinite loop? Run failed by exceeding the time limit");
   144.             exit execution_loop;
   145.
   146.          when diagnostic : NOUV_trap =>
   147.             say_goodbye("NOUV interrupt", Exception_Message(diagnostic));
   148.             exit execution_loop;
   149.
   150.          when input_is_impossible =>
   151.             say_goodbye("Noninteractive mode cannot handle a prompt");
   152.             exit execution_loop;
   153.
   154.          when diagnostic : not_yet_implemented =>
   155.             say_goodbye("Not yet implemented", Exception_Message(diagnostic));
   156.             exit execution_loop;
   157.
   158.          when diagnostic : RESET_trap =>
   159.             say_goodbye("RESET interrupt", Exception_Message(diagnostic));
   160.             exit execution_loop;
   161.
   162.          when diagnostic : LIV_trap =>
   163.             say_goodbye( "LIV interrupt", Exception_Message(diagnostic));
   164.             exit execution_loop;
   165.
   166.          when diagnostic : Director_failure =>
   167.             say_goodbye("Invalid operation in Director", Exception_Message(diagnostic));
   168.             exit execution_loop;
   169.
   170.          when diagnostic : IO_error =>
   171.             say_goodbye("Impossible I/O operation", Exception_Message(diagnostic));
   172.             exit execution_loop;
   173.
   174.          when diagnostic : Director_IO_error =>
   175.             say_goodbye("Impossible I/O operation in Director", Exception_Message(diagnostic));
   176.             exit execution_loop;
   177.
   178.          when diagnostic : operator_error =>
   179.             say_goodbye("The KDF9 operator has made a mistake", Exception_Message(diagnostic));
   180.             exit execution_loop;
   181.
   182.       end;
   183.
   184.    end loop execution_loop;
   185.
   186. exception  -- handler for execute
   187.
   188.    when diagnostic : invalid_paper_tape_file =>
   189.       say_goodbye("Invalid paper tape file supplied", Exception_Message(diagnostic));
   190.
   191.    when diagnostic : operator_error =>
   192.       say_goodbye("The KDF9 operator must have made a mistake", Exception_Message(diagnostic));
   193.
   194.    when diagnostic : others =>
   195.       say_goodbye("Apologies for this dismal failure", Exception_Message(diagnostic));
   196.
   197. end execute;

 197 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/hci.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:19

     1. -- HCI.adb
     2. --
     3. -- Provide operations supporting replicated human-readable output:
     4. --    1: to an interactive user interface for transient display, and
     5. --    2: to a file for persistent storage.
     6. -- If no file has been opened, or if it has been explicitly closed,
     7. --    output is to the interactive interface only.
     8. --
     9. -- Also provide operations allowing synchronization with the user.
    10. --
    11. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
    12. -- Copyright (C) 2021, W. Findlay; all rights reserved.
    13. --
    14. -- The ee9 program is free software; you can redistribute it and/or
    15. -- modify it under terms of the GNU General Public License as published
    16. -- by the Free Software Foundation; either version 3, or (at your option)
    17. -- any later version. This program is distributed in the hope that it
    18. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    19. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    20. -- See the GNU General Public License for more details. You should have
    21. -- received a copy of the GNU General Public License distributed with
    22. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    23. --
    24.
    25. with formatting;
    26. with generic_logger;
    27. with settings;
    28.
    29. use  formatting;
    30. use  settings;
    31.
    32. package body HCI is
    33.
    34.    package log_manager is new generic_logger(max_logger_list_size => 2);
    35.
    36.    cc_list : log_manager.replicator;
    37.
    38.    procedure tab_log (at_least : in Natural;
    39.                       spacing  : in Positive := 6;
    40.                       iff      : in Boolean := True) is
    41.    begin
    42.       cc_list.tab_log(at_least, spacing, iff);
    43.    end tab_log;
    44.
    45.    procedure tab_log_to (column : in Positive;
    46.                          iff    : in Boolean := True) is
    47.    begin
    48.       cc_list.tab_log_to(column, iff);
    49.    end tab_log_to;
    50.
    51.    procedure log (char : in Character;
    52.                   iff  : in Boolean := True) is
    53.    begin
    54.       cc_list.log(char, iff);
    55.    end log;
    56.
    57.    procedure log (text : in String;
    58.                   iff  : in Boolean := True) is
    59.    begin
    60.       cc_list.log(text, iff);
    61.    end log;
    62.
    63.    procedure log_line (text : in String;
    64.                        iff  : in Boolean := True) is
    65.    begin
    66.       if text /= "" then
    67.          cc_list.log(text, iff);
    68.       end if;
    69.       log_new_line(iff);
    70.    end log_line;
    71.
    72.    procedure log_padded_string (text  : in String;
    73.                                 width : in Positive := 1) is
    74.       pad_width   : constant Natural := Integer'Max (0, width - text'Length);
    75.       padding     : constant String (1 .. pad_width) := (others => ' ');
    76.       padded_text : constant String := padding & text;
    77.    begin
    78.       cc_list.log(padded_text);
    79.    end log_padded_string;
    80.
    81.    procedure log_octal (number : in KDF9.field_of_16_bits;
    82.                         width  : in Positive := 1) is
    83.    begin
    84.       log_padded_string("#" & oct_of(number), width);
    85.    end log_octal;
    86.
    87.    procedure log_octal (number : in KDF9.word;
    88.                         width  : in Positive := 1) is
    89.    begin
    90.       log_padded_string("#" & oct_of(number), width);
    91.    end log_octal;
    92.
    93.    procedure log_new_line (iff : in Boolean := True) is
    94.    begin
    95.       cc_list.log_new_line(iff);
    96.    end log_new_line;
    97.
    98.    half_ruler : constant String (1 .. 40) := (others => '_');
    99.    half_blank : constant String (1 .. 40) := (others => ' ');
   100.    full_ruler : constant String (1 .. 80) := half_ruler & half_ruler;
   101.
   102.    procedure log_rule (start_a_new_line : in Boolean := False;
   103.                        iff              : in Boolean := True) is
   104.    begin
   105.       if start_a_new_line then
   106.          cc_list.log_new_line(iff);
   107.       end if;
   108.       log_line(full_ruler, iff);
   109.    end log_rule;
   110.
   111.    procedure log_rule_half (second_half : in Boolean := False) is
   112.    begin
   113.       if second_half then
   114.          log(half_blank);
   115.       end if;
   116.       log_line(half_ruler);
   117.    end log_rule_half;
   118.
   119.    procedure log_message (message : in String) is
   120.    begin
   121.       cc_list.log(message);
   122.       cc_list.log_new_line;
   123.    end log_message;
   124.
   125.    procedure log_title (message : in String) is
   126.    begin
   127.       cc_list.log_new_line;
   128.       cc_list.log(message);
   129.       cc_list.log_new_line;
   130.    end log_title;
   131.
   132.    procedure log_ee9_status (message  : in String;
   133.                              skip     : in Natural := 0;
   134.                              complete : in Boolean := True;
   135.                              iff      : in Boolean := True) is
   136.    begin
   137.       if not iff then return; end if;
   138.       panel_logger.tab_log_to(1);
   139.       for i in 1 .. skip loop
   140.          log_new_line;
   141.       end loop;
   142.       if complete then
   143.          log_line("ee9: " & message & ".");
   144.       else
   145.          log("ee9: " & message);
   146.       end if;
   147.    end log_ee9_status;
   148.
   149.    procedure log_API_message (message  : in String;
   150.                               skip     : in Natural := 1) is
   151.    begin
   152.       if API_logging_is_wanted then
   153.          log_ee9_status(message, skip, True);
   154.       end if;
   155.    end log_API_message;
   156.
   157.    procedure hoot (message : in String := "") is
   158.    begin
   159.       panel_logger.log(message & Character'Val (7));  -- Append a BEL to the message.
   160.    end hoot;
   161.
   162.    procedure show (message : in String) is
   163.    begin
   164.       if debugging_is_enabled then
   165.          panel_logger.show(message);
   166.          flush;
   167.       end if;
   168.    end show;
   169.
   170.    procedure show_line (message : in String) is
   171.    begin
   172.       if debugging_is_enabled then
   173.          panel_logger.show_line(message);
   174.          flush;
   175.       end if;
   176.    end show_line;
   177.
   178.    procedure interact (reason : in String := "Mode") is
   179.    begin
   180.       panel_logger.interact(reason);
   181.    end interact;
   182.
   183.    procedure open (logfile_name : in String) is
   184.    begin
   185.       cc_list.open(logfile_name);
   186.    end open;
   187.
   188.    procedure close (logfile_name : in String) is
   189.    begin
   190.       cc_list.close(logfile_name);
   191.    end close;
   192.
   193.    procedure flush (iff : in Boolean := True) is
   194.    begin
   195.       cc_list.flush(iff);
   196.    end flush;
   197.
   198.    procedure log_to_file (message : in String) is
   199.    begin
   200.       file_logger.log(message);
   201.       file_logger.log_new_line;
   202.    end log_to_file;
   203.
   204. begin
   205.    cc_list.set_logger_list((file_logger'Access, panel_logger'Access));
   206. end HCI;

Compiling: ../Source/hci.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:19

     1. -- HCI.ads
     2. --
     3. -- Provide operations supporting replicated human-readable output:
     4. --    1: to an interactive user interface for transient display, and
     5. --    2: to a file for persistent storage.
     6. -- If no file has been opened, or if it has been explicitly closed,
     7. --    output is to the interactive interface only.
     8. --
     9. -- Also provide operations allowing synchronization with the user.
    10. --
    11. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
    12. -- Copyright (C) 2021, W. Findlay; all rights reserved.
    13. --
    14. -- The ee9 program is free software; you can redistribute it and/or
    15. -- modify it under terms of the GNU General Public License as published
    16. -- by the Free Software Foundation; either version 3, or (at your option)
    17. -- any later version. This program is distributed in the hope that it
    18. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    19. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    20. -- See the GNU General Public License for more details. You should have
    21. -- received a copy of the GNU General Public License distributed with
    22. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    23. --
    24.
    25. with KDF9;
    26. with logging.file;
    27. with logging.panel;
    28.
    29. use  KDF9;
    30. use  logging.file;
    31. use  logging.panel;
    32.
    33. package HCI is
    34.
    35.    file_logger  : aliased logging.file.output;
    36.    panel_logger : aliased logging.panel.display;
    37.
    38.    procedure tab_log (at_least : in Natural;
    39.                       spacing  : in Positive := 6;
    40.                       iff      : in Boolean := True);
    41.
    42.    procedure tab_log_to (column : in Positive;
    43.                          iff    : in Boolean := True);
    44.
    45.    procedure log (char : in Character;
    46.                   iff  : in Boolean := True);
    47.
    48.    procedure log (text : in String;
    49.                   iff  : in Boolean := True);
    50.
    51.    procedure log_line (text : in String;
    52.                        iff  : in Boolean := True);
    53.
    54.    -- Log in octal with initial '#'.
    55.    procedure log_octal (number : in KDF9.word;
    56.                         width  : in Positive := 1);
    57.
    58.    procedure log_octal (number : in KDF9.field_of_16_bits;
    59.                         width  : in Positive := 1);
    60.
    61.    procedure log_new_line (iff : in Boolean := True);
    62.
    63.    procedure log_rule (start_a_new_line : in Boolean := False;
    64.                        iff              : in Boolean := True);
    65.
    66.    procedure log_rule_half (second_half : in Boolean := False);
    67.
    68.    procedure log_message (message : in String);
    69.
    70.    procedure log_title (message : in String);
    71.
    72.    procedure log_ee9_status (message  : in String;
    73.                              skip     : in Natural := 0;
    74.                              complete : in Boolean := True;
    75.                              iff      : in Boolean := True);
    76.
    77.    procedure log_API_message (message  : in String;
    78.                               skip     : in Natural := 1);
    79.
    80.    procedure hoot (message : in String := "");
    81.
    82.    procedure show (message : in String);
    83.
    84.    procedure show_line (message : in String);
    85.
    86.    procedure interact (reason : in String := "Mode");
    87.
    88.    procedure open  (logfile_name : in String);
    89.
    90.    procedure close (logfile_name : in String);
    91.
    92.    procedure flush (iff : in Boolean := True);
    93.
    94.    procedure log_to_file (message : in String);
    95.
    96. end HCI;

 206 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:19

     1. -- ioc.adb
     2. --
     3. -- Emulation of the common functionality of a KDF9 IOC "buffer" (DMA channel),
     4. --    with fail-stop stubs for operations having device-specific behaviour.
     5. --
     6. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     7. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     8. --
     9. -- The ee9 program is free software; you can redistribute it and/or
    10. -- modify it under terms of the GNU General Public License as published
    11. -- by the Free Software Foundation; either version 3, or (at your option)
    12. -- any later version. This program is distributed in the hope that it
    13. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    14. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    15. -- See the GNU General Public License for more details. You should have
    16. -- received a copy of the GNU General Public License distributed with
    17. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    18. --
    19.
    20. with Ada.Exceptions;
    21. --
    22. with exceptions;
    23. with IOC.slow;
    24. with KDF9.CPU;
    25. with KDF9.PHU_store;
    26. with tracing;
    27.
    28. with IOC.the_locker_of;
    29.
    30. use  exceptions;
    31. use  KDF9.CPU;
    32. use  KDF9.PHU_store;
    33. use  tracing;
    34.
    35. package body IOC is
    36.
    37.    procedure set_state_of (the_buffer : in device_class_access;
    38.                            allocated  : in Boolean) is
    39.    begin
    40.       if the_buffer = null then
    41.          raise emulation_failure with "trying to set state of null buffer to " & allocated'Image;
    42.       end if;
    43.       if the_buffer.is_allocated = allocated then
    44.          -- Allocating an already allocated device, or deallocating an unallocated device.
    45.          -- Both are benign, so ignore.
    46.          return;
    47.       else
    48.          the_buffer.is_allocated := allocated;
    49.          the_CPDAR(the_buffer.number) := allocated;
    50.       end if;
    51.     end set_state_of;
    52.
    53.    function is_allocated (the_buffer : device_class_access)
    54.    return Boolean
    55.    is (the_buffer.is_allocated);
    56.
    57.    function is_unallocated (the_buffer : device_class_access)
    58.    return Boolean
    59.    is (not the_buffer.is_allocated);
    60.
    61.    function device_name_of (the_buffer : IOC.device)
    62.    return IOC.device_name
    63.    is (IOC.device_kind'Image(the_buffer.kind)(1 .. 2)
    64.      & trimmed(the_buffer.unit'Image));
    65.
    66.    function device_name_of (the_number : IOC.device_number)
    67.    return IOC.device_name
    68.    is (device_name_of(buffer(the_number).all));
    69.
    70.    function device_kind_of (the_number : IOC.device_number)
    71.    return IOC.device_kind
    72.    is (buffer(the_number).kind);
    73.
    74.    overriding
    75.    procedure Initialize (the_buffer : in out IOC.device) is
    76.    begin
    77.       if not IOC.device'Class(the_buffer).is_open then
    78.          the_buffer.is_abnormal := True;
    79.          the_buffer.is_offline  := True;
    80.       end if;
    81.       install(the_buffer);
    82.    end Initialize;
    83.
    84.    procedure open (the_buffer : in out IOC.device'Class;
    85.                    the_mode   : in POSIX.access_mode) is
    86.    begin
    87.       the_buffer.device_name := device_name_of(the_buffer);
    88.       host_IO.open(the_buffer.stream, the_buffer.device_name, the_mode);
    89.       if the_buffer.is_open then
    90.          if the_mode = write_mode then
    91.             truncate(the_buffer.stream, to_length => 0);
    92.          end if;
    93.       else
    94.          trap_operator_error(the_buffer.device_name, "cannot be found");
    95.       end if;
    96.       IOC.device(the_buffer).Initialize;
    97.    end open;
    98.
    99.    overriding
   100.    procedure Finalize (the_buffer : in out IOC.device) is
   101.       buffer : constant String  := oct_of(KDF9.Q_part(the_buffer.number), 2);
   102.    begin
   103.       if IOC.device'Class(the_buffer).is_open   and then
   104.             IOC.device'Class(the_buffer).usage /= 0 then
   105.          IOC.device'Class(the_buffer).close;
   106.       end if;
   107.    exception
   108.       when error : others =>
   109.          raise emulation_failure
   110.             with "Finalizing buffer #" & buffer & "; " & Ada.Exceptions.Exception_Information(error);
   111.    end Finalize;
   112.
   113.    function is_open (the_buffer : IOC.device)
   114.    return Boolean
   115.    is (the_buffer.stream.is_open);
   116.
   117.    function usage (the_buffer : IOC.device)
   118.    return KDF9.word is
   119.    begin
   120.       return the_buffer.stream.bytes_moved;
   121.    end usage;
   122.
   123.    procedure flush (the_buffer : in out IOC.device) is
   124.    begin
   125.       flush(the_buffer.stream);
   126.    end flush;
   127.
   128.    procedure close (the_buffer : in out IOC.device) is
   129.    begin
   130.       close(the_buffer.stream);
   131.       IOC.buffer(the_buffer.number) := null;
   132.    end close;
   133.
   134.    procedure finalize_all_KDF9_buffers is
   135.    begin
   136.       for b in IOC.buffer'Range loop
   137.          if IOC.buffer(b) /= null then
   138.             Finalize(IOC.buffer(b).all);
   139.          end if;
   140.       end loop;
   141.    end finalize_all_KDF9_buffers;
   142.
   143.    procedure add_in_the_IO_lockout_CPU_time (Q_operand : in KDF9.Q_register) is
   144.       IO_size : constant KDF9.Q_part := Q_operand.M - Q_operand.I;
   145.    begin
   146.       the_CPU_delta := the_CPU_delta + KDF9.us(IO_size + group_size - 1) / group_size;
   147.    end add_in_the_IO_lockout_CPU_time;
   148.
   149.    function IO_elapsed_time (the_buffer   : IOC.device;
   150.                              atomic_items : KDF9.word)
   151.    return KDF9.us
   152.    is (
   153.        if IOC.device'Class(the_buffer).is_open then
   154.           KDF9.us(atomic_items) * the_buffer.quantum
   155.        else
   156.           0
   157.       );
   158.
   159.    procedure add_in_the_IO_CPU_time (IO_CPU_time : in KDF9.us) is
   160.    begin
   161.       the_CPU_delta := the_CPU_delta + IO_CPU_time;
   162.    end add_in_the_IO_CPU_time;
   163.
   164.    procedure add_in_the_IO_CPU_time (the_buffer  : in IOC.device'Class;
   165.                                      bytes_moved : in KDF9.word) is
   166.       the_IO_CPU_time : KDF9.us;
   167.    begin
   168.       if the_buffer.is_open then
   169.          if the_buffer in IOC.slow.device'Class then
   170.             the_IO_CPU_time := KDF9.us(bytes_moved) * 6;          -- 6µs/char
   171.          else
   172.             the_IO_CPU_time := KDF9.us(bytes_moved + 7) / 8 * 6;  -- 6µs/word
   173.          end if;
   174.       else
   175.          the_IO_CPU_time := 0;
   176.       end if;
   177.       add_in_the_IO_CPU_time(the_IO_CPU_time);
   178.    end add_in_the_IO_CPU_time;
   179.
   180.    function IO_elapsed_time_total (the_buffer : IOC.device)
   181.    return KDF9.us
   182.    is (IO_elapsed_time(IOC.device'Class(the_buffer), IOC.device'Class(the_buffer).usage));
   183.
   184.    procedure install (the_device : in out IOC.device'Class) is
   185.    begin
   186.       if buffer(the_device.number) /= null then
   187.          raise emulation_failure
   188.             with "attempt to install a second device, namely "
   189.                & the_device.device_name
   190.                & ", on buffer #"
   191.                & oct_of(the_device.number)
   192.                & " which already has "
   193.                & buffer(the_device.number).device_name;
   194.       end if;
   195.       buffer(the_device.number) := the_device'Unchecked_Access;
   196.    end install;
   197.
   198.    -- Mask off the buffer number in the Q_operand.C; to remove any disc parameter.
   199.    function canonical (Q_operand : KDF9.Q_register)
   200.    return KDF9.Q_register
   201.    is (C => Q_operand.C and buffer_number_mask, I => Q_operand.I, M => Q_operand.M);
   202.
   203.    procedure validate_device (the_buffer : in IOC.device'Class;
   204.                               Q_operand  : in KDF9.Q_register) is
   205.       Q : constant KDF9.Q_register := canonical(Q_operand);
   206.    begin
   207.       if not the_buffer.is_open then
   208.          trap_operator_error(the_buffer.device_name,
   209.                              " on buffer #"
   210.                            & oct_of(KDF9.Q_part(the_buffer.number), 2)
   211.                            & " is offline");
   212.       end if;
   213.       if KDF9.Q_part(the_buffer.number) /= Q.C then
   214.          raise emulation_failure
   215.             with "wrong C-part: "
   216.                & oct_of(Q_operand.C)
   217.                & " for "
   218.                & the_buffer.device_name
   219.                & " on buffer #"
   220.                & oct_of(KDF9.Q_part(the_buffer.number), 2);
   221.       end if;
   222.       if not the_CPDAR(the_buffer.number) and the_CPU_state /= Director_state then
   223.          trap_illegal_instruction("unallocated I/O device " & the_buffer.device_name);
   224.       end if;
   225.    end validate_device;
   226.
   227.    procedure validate_bounds (Q_operand  : in KDF9.Q_register) is
   228.    begin
   229.       if Q_operand.I > Q_operand.M then
   230.          trap_illegal_instruction("invalid I/O Q operand: I > M");
   231.       end if;
   232.       validate_address_range(Q_operand.I, Q_operand.M);
   233.    end validate_bounds;
   234.
   235.    procedure validate_transfer (the_buffer : in IOC.device'Class;
   236.                                 Q_operand  : in KDF9.Q_register) is
   237.    begin
   238.       validate_device(the_buffer, Q_operand);
   239.       validate_bounds(Q_operand);
   240.    end validate_transfer;
   241.
   242.    procedure validate_parity (the_buffer : in IOC.device'Class) is
   243.    begin
   244.       if the_buffer.is_abnormal then
   245.          trap_illegal_instruction("the buffer for "
   246.                                 & the_buffer.device_name
   247.                                 & " is abnormal (parity error or end-of-data)");
   248.       end if;
   249.    end validate_parity;
   250.
   251.    procedure require_positive_count (count : in KDF9.Q_part) is
   252.    begin
   253.       if resign(count) <= 0 then
   254.          trap_illegal_instruction("nonpositive I/O repetition count");
   255.       end if;
   256.    end require_positive_count;
   257.
   258.    procedure require_nonnegative_count (count : in KDF9.Q_part) is
   259.    begin
   260.       if resign(count) < 0 then
   261.          trap_illegal_instruction("negative I/O repetition count");
   262.       end if;
   263.    end require_nonnegative_count;
   264.
   265.    function image (the_buffer : in IOC.device'Class)
   266.    return String
   267.    is (
   268.        the_buffer.device_name
   269.      & " Q"  & the_buffer.control_word.C'Image
   270.      & "/#"  & oct_of(the_buffer.control_word.I)
   271.      & "/#"  & oct_of(the_buffer.control_word.M)
   272.       );
   273.
   274.    -- In boot mode, effect the LOV interrupt to Director.
   275.    -- In other modes, advance the elapsed time to the next-interrupt time,
   276.    --    and suppress the LOV by simulating an earlier end of transfer.
   277.    procedure handle_a_buffer_lockout (the_buffer : in IOC.device'Class) is
   278.    begin
   279.       PHU(CPL) := (
   280.                    is_held_up => True,
   281.                    blockage   => (buffer_busy, the_buffer.number, by_INTQq => False)
   282.                   );
   283.       take_note_of_buffer_lockout(the_buffer.device_name, the_buffer.operation);
   284.       if the_execution_mode = boot_mode then
   285.          LOV_if_user_mode(the_buffer.device_name & " is busy");
   286.       else
   287.          advance_the_clock(the_buffer.completion_time);
   288.          act_on_pending_interrupts;
   289.       end if;
   290.    end handle_a_buffer_lockout;
   291.
   292.    procedure deal_with_a_busy_device (the_buffer  : in out IOC.device'Class;
   293.                                       order_time  : in KDF9.us;
   294.                                       set_offline : in Boolean) is
   295.    begin
   296.       advance_the_clock(the_clock_time+order_time);
   297.       if the_buffer.is_busy then
   298.          handle_a_buffer_lockout(the_buffer);
   299.       end if;
   300.       the_buffer.is_offline := set_offline;
   301.    end deal_with_a_busy_device;
   302.
   303.    procedure finalize_transfer (the_buffer : in out IOC.device'Class;
   304.                                 need_EDT,
   305.                                 need_PR    : out Boolean);
   306.
   307.    procedure effect_device_interrupt (code : KDF9.interrupt_number; the_buffer : in IOC.device'Class) is
   308.    begin
   309.       effect(code, the_buffer.image);
   310.     end effect_device_interrupt;
   311.
   312.    function is_DMAing (the_buffer : in IOC.device'Class)
   313.    return Boolean
   314.    is (the_buffer.operation in input_operation | output_operation);
   315.
   316.    procedure start_data_transfer (the_buffer   : in out IOC.device'Class;
   317.                                   Q_operand    : in KDF9.Q_register;
   318.                                   set_offline  : in Boolean;
   319.                                   busy_time    : in KDF9.us;
   320.                                   operation    : in IOC.transfer_kind := some_other_operation) is
   321.       pragma Unreferenced(set_offline);
   322.       transferring_data : constant Boolean := operation in input_operation | output_operation;
   323.       time_now          : constant KDF9.us := the_clock_time;
   324.       real_Q            : KDF9.Q_register := Q_operand;
   325.       EDT_needed,
   326.       PR_needed         : Boolean;
   327.    begin
   328.       -- Check the IO parameters and the buffer state, and handle any lockout set by another device.
   329.       validate_device(the_buffer, Q_operand);
   330.
   331.       if transferring_data then
   332.          validate_bounds(real_Q);
   333.          real_Q := (real_Q.C, real_Q.I+BA, real_Q.M+BA);
   334.       else
   335.          require_nonnegative_count(real_Q.M);
   336.       end if;
   337.
   338.       validate_parity(the_buffer);
   339.
   340.       if the_buffer.is_busy then
   341.          handle_a_buffer_lockout(the_buffer);
   342.          if the_execution_mode = boot_mode then
   343.             finalize_transfer (the_buffer, EDT_needed, PR_needed);
   344.             if the_next_interrupt_time > time_now + 1_024_000 then
   345.                the_next_interrupt_time := time_now + 1_024_000;
   346.             end if;
   347.             if EDT_needed then
   348.                effect_device_interrupt(EDT_interrupt, the_buffer);
   349.             elsif PR_needed then
   350.                effect_device_interrupt(PR_interrupt, the_buffer);
   351.             end if;
   352.          end if;
   353.       end if;
   354.
   355.       if transferring_data                            and then
   356.             there_are_locks_in_physical_addresses(real_Q) then
   357.          LOV_if_user_mode(
   358.                           "in "
   359.                        &  "#"   & oct_of(the_buffer.control_word.I)
   360.                        &  "/#"  & oct_of(the_buffer.control_word.M)
   361.                        &  " for "
   362.                        &  the_buffer.device_name
   363.                          );
   364.       end if;
   365.
   366.       -- Set up the transfer parameters.
   367.       the_buffer.is_for_Director := (the_CPU_state = Director_state);
   368.       the_buffer.priority_level  := CPL;
   369.       the_buffer.control_word    := real_Q;
   370.       the_buffer.operation       := operation;
   371.       the_buffer.order_count     := ICR+1;
   372.       the_buffer.order_address   := CIA;
   373.       the_buffer.decoded_order   := INS;
   374.       the_buffer.initiation_time := time_now;
   375.       the_buffer.transfer_time   := busy_time;
   376.       the_buffer.completion_time := the_buffer.initiation_time + busy_time;
   377.
   378.       if busy_time > 0 or transferring_data then
   379.          if the_buffer.completion_time < the_next_interrupt_time then
   380.             the_next_interrupt_time := the_buffer.completion_time;
   381.          end if;
   382.          the_buffer.is_busy := True;
   383.          take_note_of_IO_start(
   384.                                the_buffer.device_name,
   385.                                the_buffer.completion_time,
   386.                                the_buffer.control_word,
   387.                                the_buffer.operation
   388.                               );
   389.       else
   390.          the_buffer.is_busy := False;
   391.          take_note_of_IO_finis (
   392.                                 the_buffer.order_count,
   393.                                 the_buffer.order_address,
   394.                                 the_buffer.decoded_order,
   395.                                 the_buffer.initiation_time,
   396.                                 the_buffer.device_name,
   397.                                 the_buffer.is_for_Director,
   398.                                 the_buffer.priority_level,
   399.                                 the_buffer.completion_time,
   400.                                 the_buffer.control_word,
   401.                                 the_buffer.operation
   402.                                );
   403.       end if;
   404.       PHU(CPL) := idle_PHU;
   405.    end start_data_transfer;
   406.
   407.    -- start_slow_transfer takes a pessimistic view of transfers-to-End_Message.
   408.    -- When the actual transfer length is known, the end-of-transfer time can be
   409.    --    made more realistic by specifying its real length to correct_transfer_time.
   410.    -- correct_transfer_time must be called before finalize_transfer is called.
   411.
   412.    procedure correct_transfer_time (the_buffer  : in out IOC.device'Class;
   413.                                     actual_time : in KDF9.us) is
   414.    begin
   415.       the_buffer.transfer_time :=  actual_time;
   416.       the_buffer.completion_time := the_buffer.initiation_time + the_buffer.transfer_time;
   417.       if the_buffer.completion_time < the_next_interrupt_time then
   418.          the_next_interrupt_time := the_buffer.completion_time;
   419.       end if;
   420.    end correct_transfer_time;
   421.
   422.    procedure correct_transfer_time (the_buffer    : in out IOC.device'Class;
   423.                                     actual_length : in KDF9.word) is
   424.    begin
   425.       the_buffer.transfer_time := IO_elapsed_time(the_buffer, actual_length);
   426.       the_buffer.completion_time := the_buffer.initiation_time + the_buffer.transfer_time;
   427.       if the_buffer.completion_time < the_next_interrupt_time then
   428.          the_next_interrupt_time := the_buffer.completion_time;
   429.       end if;
   430.    end correct_transfer_time;
   431.
   432.    -- If the buffer has a terminated transfer, clear its lockouts, reset its state,
   433.    --    update the PHUs, and demand an EDT or PR interrupt as needed.
   434.    procedure finalize_transfer (the_buffer : in out IOC.device'Class;
   435.                                 need_EDT,
   436.                                 need_PR    : out Boolean) is
   437.       the_PHU : KDF9.PHU_store.PHU_register renames KDF9.PHU_store.PHU(the_buffer.priority_level);
   438.       blocked : PHU_reason;
   439.    begin
   440.       if the_buffer.transfer_time /= 0 then
   441.          take_note_of_IO_finis (
   442.                                 the_buffer.order_count,
   443.                                 the_buffer.order_address,
   444.                                 the_buffer.decoded_order,
   445.                                 the_buffer.initiation_time,
   446.                                 the_buffer.device_name,
   447.                                 the_buffer.is_for_Director,
   448.                                 the_buffer.priority_level,
   449.                                 the_buffer.completion_time,
   450.                                 the_buffer.control_word,
   451.                                 the_buffer.operation
   452.                                );
   453.       end if;
   454.
   455.       need_EDT := the_buffer.is_for_Director;
   456.
   457.       -- Clear down the transfer and idle the buffer.
   458.       if the_buffer.is_DMAing then
   459.          unlock_absolute_addresses(the_buffer.control_word);
   460.       end if;
   461.       the_buffer.is_busy := False;
   462.       the_buffer.is_for_Director := False;
   463.
   464.       -- The following code is somewhat redundant, but written like this to exactly mirror the
   465.       -- logic stated in the KDF9 TIME-SHARING DIRECTOR SUPPORT DOCUMENTATION of 1-May-1965.
   466.       need_PR := False;
   467.       if the_PHU.is_held_up then
   468.          blocked := the_PHU.blockage;
   469.          if (blocked.reason = buffer_busy and then blocked.by_INTQq)                      or else
   470.             (blocked.reason = buffer_busy and then not buffer(blocked.buffer_nr).is_busy) or else
   471.             (blocked.reason = locked_core and then is_unlocked(blocked.group_nr))            then
   472.             the_PHU := idle_PHU;
   473.             need_PR := the_buffer.priority_level < CPL;
   474.          end if;
   475.       end if;
   476.
   477.       -- A PR interrupt may be wanted, BUT not if an EDT interrupt is wanted.
   478.       -- EDT is wanted if the transfer was for Director OR another program awaits the same buffer.
   479.
   480.       -- Check the rest of the PHU stores for an EDT interrupt.
   481.       -- This is needed only when running a Director.
   482.       if the_execution_mode = boot_mode then
   483.          -- Test for possible priority inversion, i.e. other program(s) blocked on this buffer.
   484.          for p of PHU loop
   485.             if p.is_held_up                               and then
   486.                   p.blockage.reason = buffer_busy         and then
   487.                      p.blockage.buffer_nr = the_buffer.number then
   488.                -- The KDF9 TIME-SHARING DIRECTOR SUPPORT DOCUMENTATION of 1-May-1965
   489.                --   says such a PHU is NOT cleared, but EDT is requested INSTEAD of PR,
   490.                --   so Director can take action according to what it finds there.
   491.                need_EDT := True;
   492.             end if;
   493.          end loop;
   494.       end if;
   495.       if need_EDT then
   496.          need_PR := False;
   497.       end if;
   498.    end finalize_transfer;
   499.
   500.    procedure act_on_pending_interrupts is
   501.       time_now   : constant KDF9.us := the_clock_time;
   502.       EDT_needed,
   503.       PR_needed  : Boolean := False;
   504.       number     : IOC.device_number := 16;
   505.    begin
   506.       advance_the_clock(the_next_interrupt_time);
   507.       -- Predict another interrupt (at most 2**20 seconds in the future in boot mode).
   508.       the_next_interrupt_time := KDF9.us'Last;
   509.       for b of buffer loop
   510.          if b /= null and then
   511.                b.is_busy  then
   512.             if time_now >= b.completion_time then
   513.                finalize_transfer(b.all, EDT_needed, PR_needed);
   514.                if EDT_needed or PR_needed then
   515.                   number := b.number;
   516.                end if;
   517.             elsif the_next_interrupt_time > b.completion_time then
   518.                the_next_interrupt_time := b.completion_time;
   519.             end if;
   520.          end if;
   521.       end loop;
   522.       -- Prevent an inadvertant double clock interrupt.
   523.       if the_execution_mode = boot_mode                and then
   524.             the_next_interrupt_time > time_now + 1_048_575 then
   525.          the_next_interrupt_time := time_now + 1_048_575;
   526.       end if;
   527.       if EDT_needed then
   528.          effect_device_interrupt(EDT_interrupt, buffer(number).all);
   529.       elsif PR_needed then
   530.          effect_device_interrupt(PR_interrupt, buffer(number).all);
   531.       end if;
   532.    end act_on_pending_interrupts;
   533.
   534.    -- Advance the time to a point after all extant transfer have terminated,
   535.    --    finalizing all extant transfer in temporal order in the process.
   536.    procedure complete_all_extant_transfers is
   537.       EDT_needed,
   538.       PR_needed      : Boolean := False;
   539.       last_time      : KDF9.us := 0;
   540.       next_time      : KDF9.us;
   541.    begin
   542.       -- At least one transfer is terminated each time around outer_loop,
   543.       --    if not, outer_loop is exited.
   544.    outer_loop:
   545.       for c in buffer'Range loop
   546.          -- Find the earliest transfer termination time.
   547.          next_time := KDF9.us'Last;
   548.          for b of buffer loop
   549.             if b /= null                       and then
   550.                   b.is_busy                    and then
   551.                      b.completion_time < next_time then
   552.                next_time := b.completion_time;
   553.             end if;
   554.          end loop;
   555.
   556.          if next_time = KDF9.us'Last then
   557.             -- All the buffers are quiescent.
   558.             exit outer_loop;
   559.          else
   560.             -- At least one transfer remains to be finalized.
   561.             advance_the_clock(next_time);
   562.             last_time := KDF9.us'Max(last_time, next_time);
   563.          end if;
   564.
   565.          -- Finalize all transfers with completion time <= next_time.
   566.          for b of buffer loop
   567.             if b /= null                        and then
   568.                   b.is_busy                     and then
   569.                      b.completion_time <= next_time then
   570.                finalize_transfer(b.all, EDT_needed, PR_needed);
   571.             end if;
   572.          end loop;
   573.
   574.       end loop outer_loop;
   575.    end complete_all_extant_transfers;
   576.
   577.    procedure handle_a_main_store_lockout is
   578.       the_buffer : KDF9.buffer_number;
   579.    begin
   580.       PHU(CPL) := (
   581.                    is_held_up => True,
   582.                    blockage   => (locked_core, group_address(group(the_locked_out_address)))
   583.                   );
   584.       -- Store access LOV interrupts invoke instruction restart outside Director.
   585.       the_buffer := the_locker_of(the_locked_out_address);
   586.       take_note_of_store_lockout(device_name_of(buffer(the_buffer).all));
   587.       if the_execution_mode = boot_mode then
   588.          if_user_mode_then_LOV(the_locked_out_address);
   589.       else
   590.          set_NIA_to(CIA);
   591.          advance_the_clock(buffer(the_buffer).completion_time);
   592.          act_on_pending_interrupts;
   593.       end if;
   594.       ICR := ICR + 1;
   595.    end handle_a_main_store_lockout;
   596.
   597.    procedure MANUAL_CT (the_buffer  : in out IOC.device'Class;
   598.                         Q_operand   : in KDF9.Q_register;
   599.                         set_offline : in Boolean) is
   600.       EDT_needed, PR_needed : Boolean := False;
   601.    begin
   602.       validate_device(the_buffer, Q_operand);
   603.       take_note_of_test(the_buffer.device_name, Q_operand, the_buffer.is_busy);
   604.       -- ee9 allows the transfer to terminate normally, as if MANUALQ with set_offline = True;
   605.       --    even when set_offline = False, i.e. CTQ, which aborted any residual I/O on the KDF9.
   606.       if the_buffer.is_busy then
   607.          the_buffer.completion_time := KDF9.us'Min(the_buffer.completion_time, the_clock_time);
   608.          finalize_transfer(the_buffer, EDT_needed, PR_needed);
   609.       end if;
   610.       the_buffer.is_busy     := False;
   611.       the_buffer.operation   := some_other_operation;
   612.       the_buffer.is_abnormal := False;
   613.       the_buffer.is_offline  := set_offline;
   614.    end MANUAL_CT;
   615.
   616.    procedure INT (the_buffer  : in out IOC.device'Class;
   617.                   Q_operand   : in KDF9.Q_register;
   618.                   set_offline : in Boolean) is
   619.       now  : constant KDF9.us := the_clock_time;
   620.       step : KDF9.us;
   621.    begin
   622.       validate_device(the_buffer, Q_operand);
   623.       if the_buffer.is_busy then
   624.          PHU(CPL) := (
   625.                       is_held_up => True,
   626.                       blockage   => (buffer_busy, the_buffer.number, by_INTQq => True)
   627.                      );
   628.          take_note_of_buffer_lockout(the_buffer.device_name, the_buffer.operation);
   629.          if the_execution_mode = boot_mode then
   630.             step := KDF9.us'Max((the_buffer.completion_time - now) / 16, 1);
   631.             advance_the_clock(KDF9.us'Min(the_buffer.completion_time, now + step));
   632.             effect(PR_interrupt, image(the_buffer));
   633.          else
   634.             advance_the_clock(the_buffer.completion_time);
   635.             act_on_pending_interrupts;
   636.          end if;
   637.       else
   638.          take_note_of_test(the_buffer.device_name, Q_operand, False);
   639.       end if;
   640.       the_buffer.is_offline := set_offline;
   641.    end INT;
   642.
   643.    procedure BUSY (the_buffer  : in out IOC.device'Class;
   644.                    Q_operand   : in KDF9.Q_register;
   645.                    set_offline : in Boolean;
   646.                    result      : out Boolean) is
   647.    begin
   648.       validate_device(the_buffer, Q_operand);
   649.       result := the_buffer.is_busy;
   650.       take_note_of_test(the_buffer.device_name, Q_operand, result);
   651.       if the_buffer.is_busy and then
   652.             (the_execution_mode /= boot_mode or the_CPU_state = Director_state) then
   653.          act_on_pending_interrupts;
   654.       end if;
   655.       the_buffer.is_offline := set_offline;
   656.    end BUSY;
   657.
   658.    procedure PAR (the_buffer  : in out IOC.device'Class;
   659.                   Q_operand   : in KDF9.Q_register;
   660.                   set_offline : in Boolean;
   661.                   result      : out Boolean) is
   662.    begin
   663.       validate_device(the_buffer, Q_operand);
   664.       deal_with_a_busy_device(the_buffer, 13, set_offline);
   665.       result := the_buffer.is_abnormal;
   666.       take_note_of_test(the_buffer.device_name, Q_operand, result);
   667.       the_buffer.is_abnormal := False;
   668.       the_buffer.is_offline := set_offline;
   669.    end PAR;
   670.
   671.    subtype IO_mnemonic is String(1 .. 5);
   672.    type synonyms       is array (1 .. 2) of IO_mnemonic;
   673.    type synonym_list   is array (Positive range <>) of synonyms;
   674.
   675.    FW_synonyms  : constant synonym_list
   676.                 := (
   677.                     ("POA  ", "TW   "), ("POB  ", "TWE  "),
   678.                     ("PIA  ", "TR   "), ("PIB  ", "TRE  ")
   679.                    );
   680.
   681.    TR_synonyms  : constant synonym_list
   682.                 := (
   683.                     ("PIA  ", "PR   "), ("PIB  ", "PRE  "),
   684.                     ("PIC  ", "PRC  "), ("PID  ", "PRCE ")
   685.                    );
   686.
   687.    TP_synonyms  : constant synonym_list
   688.                 := (
   689.                     ("POA  ", "PW   "), ("POB  ", "PWE  "),
   690.                     ("POC  ", "PWC  "), ("POD  ", "PWCE "),
   691.                     ("POE  ", "PGAP ")
   692.                    );
   693.
   694.    LP_synonyms  : constant synonym_list
   695.                 := (
   696.                     ("POA  ", "LP   "), ("POB  ", "LPE  ")
   697.                    );
   698.
   699.    MT_synonyms  : constant synonym_list
   700.                 := (
   701.                     ("PIA  ", "MFR  "), ("PIB  ", "MFRE "),
   702.                     ("PIE  ", "MBR  "), ("PIF  ", "MBRE "),
   703.                     ("POA  ", "MW   "), ("POB  ", "MWE  "),
   704.                     ("POC  ", "MLW  "), ("POD  ", "MLWE "),
   705.                     ("POE  ", "MGAP "), ("POF  ", "MWIPE"),
   706.                     ("PMA  ", "MFSK "), ("PMB  ", "MBT  "),
   707.                     ("PMC  ", "MLB  "), ("PMD  ", "MRWD "),
   708.                     ("PME  ", "MBSK "), ("PMF  ", "MET  ")
   709.                    );
   710.
   711.    function mnemonic (order : in String; class : in IOC.device_name)
   712.    return String is
   713.
   714.       key : constant IO_mnemonic := just_left(order(order'First..order'First+2), 5);
   715.       Qij : constant String      := order(order'First+3..order'Last);
   716.
   717.       function choose (synonyms : synonym_list)
   718.       return String is
   719.       begin
   720.          for s of synonyms loop
   721.             if s(1) = key then return trimmed(s(2)) & Qij; end if;
   722.          end loop;
   723.          return order;
   724.       end choose;
   725.
   726.       XY : constant String(1..2) := class(class'First..class'First+1);
   727.
   728.    begin
   729.       if key(1..3) in "TLO" | "CLO" | "PMH" | "SLO" then
   730.          -- These orders do not necessarily involve a device.
   731.          return order;
   732.       end if;
   733.       if XY in "CP" | "CR" | "DR" | "FD" | "GP" | "ST" | "SI" | "??" then
   734.          return order;
   735.       elsif XY = "FW" then -- FlexoWriter
   736.          return choose(FW_synonyms);
   737.       elsif XY = "LP" then -- Line Printer
   738.          return choose(LP_synonyms);
   739.       elsif XY = "MT" then -- Magnetic Tape
   740.          return choose(MT_synonyms);
   741.       elsif XY = "TP" then -- Tape Punch
   742.          return choose(TP_synonyms);
   743.       elsif XY = "TR" then -- Tape Reader
   744.          return choose(TR_synonyms);
   745.       else
   746.          raise emulation_failure with "in IOC.mnemonic for '" & order & "' on " & class;
   747.       end if;
   748.    end mnemonic;
   749.
   750.    procedure trap_failing_IO_operation (the_buffer : in out IOC.device; the_message : in String) is
   751.       the_diagnostic : constant String := "%" & the_message & " on " & the_buffer.device_name;
   752.    begin
   753.       if the_execution_mode in program_mode | test_program_mode then
   754.          raise IO_error with the_diagnostic;
   755.       elsif the_CPU_state = program_state then
   756.          the_buffer.is_abnormal := True;
   757.          raise abandon_this_order with the_diagnostic;
   758.       else
   759.          -- The Director itself has gone seriously wrong.
   760.          raise Director_IO_error with the_diagnostic;
   761.       end if;
   762.    end trap_failing_IO_operation;
   763.
   764.    procedure trap_illegal_IO_operation (order : in String; buffer : in IOC.device) is
   765.    begin
   766.       trap_illegal_instruction(order & " cannot be used on " & buffer.device_name);
   767.    end trap_illegal_IO_operation;
   768.
   769.    procedure PIA (the_buffer  : in out IOC.device;
   770.                   Q_operand   : in KDF9.Q_register;
   771.                   set_offline : in Boolean) is
   772.       pragma Unreferenced(Q_operand);
   773.       pragma Unreferenced(set_offline);
   774.    begin
   775.       trap_illegal_IO_operation("PIA", the_buffer);
   776.    end PIA;
   777.
   778.    procedure PIB (the_buffer  : in out IOC.device;
   779.                   Q_operand   : in KDF9.Q_register;
   780.                   set_offline : in Boolean) is
   781.       pragma Unreferenced(Q_operand);
   782.       pragma Unreferenced(set_offline);
   783.    begin
   784.       trap_illegal_IO_operation("PIB", the_buffer);
   785.    end PIB;
   786.
   787.    procedure PIC (the_buffer  : in out IOC.device;
   788.                   Q_operand   : in KDF9.Q_register;
   789.                   set_offline : in Boolean) is
   790.       pragma Unreferenced(Q_operand);
   791.       pragma Unreferenced(set_offline);
   792.    begin
   793.       trap_illegal_IO_operation("PIC", the_buffer);
   794.    end PIC;
   795.
   796.    procedure PID (the_buffer  : in out IOC.device;
   797.                   Q_operand   : in KDF9.Q_register;
   798.                   set_offline : in Boolean) is
   799.       pragma Unreferenced(Q_operand);
   800.       pragma Unreferenced(set_offline);
   801.    begin
   802.       trap_illegal_IO_operation("PID", the_buffer);
   803.    end PID;
   804.
   805.    procedure PIE (the_buffer  : in out IOC.device;
   806.                   Q_operand   : in KDF9.Q_register;
   807.                   set_offline : in Boolean) is
   808.       pragma Unreferenced(Q_operand);
   809.       pragma Unreferenced(set_offline);
   810.    begin
   811.       trap_illegal_IO_operation("PIE", the_buffer);
   812.    end PIE;
   813.
   814.    procedure PIF (the_buffer  : in out IOC.device;
   815.                   Q_operand   : in KDF9.Q_register;
   816.                   set_offline : in Boolean) is
   817.       pragma Unreferenced(Q_operand);
   818.       pragma Unreferenced(set_offline);
   819.    begin
   820.       trap_illegal_IO_operation("PIF", the_buffer);
   821.    end PIF;
   822.
   823.    procedure PIG (the_buffer  : in out IOC.device;
   824.                   Q_operand   : in KDF9.Q_register;
   825.                   set_offline : in Boolean) is
   826.       pragma Unreferenced(Q_operand);
   827.       pragma Unreferenced(set_offline);
   828.    begin
   829.       trap_illegal_IO_operation("PIG", the_buffer);
   830.    end PIG;
   831.
   832.    procedure PIH (the_buffer  : in out IOC.device;
   833.                   Q_operand   : in KDF9.Q_register;
   834.                   set_offline : in Boolean) is
   835.       pragma Unreferenced(Q_operand);
   836.       pragma Unreferenced(set_offline);
   837.    begin
   838.       trap_illegal_IO_operation("PIH", the_buffer);
   839.    end PIH;
   840.
   841.    procedure PMA (the_buffer  : in out IOC.device;
   842.                   Q_operand   : in KDF9.Q_register;
   843.                   set_offline : in Boolean) is
   844.       pragma Unreferenced(Q_operand);
   845.       pragma Unreferenced(set_offline);
   846.    begin
   847.       trap_illegal_IO_operation("PMA", the_buffer);
   848.    end PMA;
   849.
   850.    procedure PMB (the_buffer  : in out IOC.device;
   851.                   Q_operand   : in KDF9.Q_register;
   852.                   set_offline : in Boolean) is
   853.       pragma Unreferenced(the_buffer);
   854.       pragma Unreferenced(Q_operand);
   855.       pragma Unreferenced(set_offline);
   856.    begin
   857.       null;
   858.    end PMB;
   859.
   860.    procedure PMC (the_buffer  : in out IOC.device;
   861.                   Q_operand   : in KDF9.Q_register;
   862.                   set_offline : in Boolean) is
   863.       pragma Unreferenced(the_buffer);
   864.       pragma Unreferenced(Q_operand);
   865.       pragma Unreferenced(set_offline);
   866.    begin
   867.       null;
   868.    end PMC;
   869.
   870.    procedure PMD (the_buffer  : in out IOC.device;
   871.                   Q_operand   : in KDF9.Q_register;
   872.                   set_offline : in Boolean) is
   873.       pragma Unreferenced(Q_operand);
   874.       pragma Unreferenced(set_offline);
   875.    begin
   876.       trap_illegal_IO_operation("PMD", the_buffer);
   877.    end PMD;
   878.
   879.    procedure PME (the_buffer  : in out IOC.device;
   880.                   Q_operand   : in KDF9.Q_register;
   881.                   set_offline : in Boolean) is
   882.       pragma Unreferenced(Q_operand);
   883.       pragma Unreferenced(set_offline);
   884.    begin
   885.       trap_illegal_IO_operation("PME", the_buffer);
   886.    end PME;
   887.
   888.    procedure PMF (the_buffer  : in out IOC.device;
   889.                   Q_operand   : in KDF9.Q_register;
   890.                   set_offline : in Boolean) is
   891.       pragma Unreferenced(the_buffer);
   892.       pragma Unreferenced(Q_operand);
   893.       pragma Unreferenced(set_offline);
   894.    begin
   895.       null;
   896.    end PMF;
   897.
   898.    procedure PMG (the_buffer  : in out IOC.device;
   899.                   Q_operand   : in KDF9.Q_register;
   900.                   set_offline : in Boolean) is
   901.       pragma Unreferenced(Q_operand);
   902.       pragma Unreferenced(set_offline);
   903.    begin
   904.       trap_illegal_IO_operation("PMG", the_buffer);
   905.    end PMG;
   906.
   907. -- procedure PMH is subsumed by SLOC.
   908.
   909.    procedure PMK (the_buffer  : in out IOC.device;
   910.                   Q_operand   : in KDF9.Q_register;
   911.                   set_offline : in Boolean) is
   912.       pragma Unreferenced(Q_operand);
   913.       pragma Unreferenced(set_offline);
   914.    begin
   915.       trap_illegal_IO_operation("PMK", the_buffer);
   916.    end PMK;
   917.
   918.    procedure PML (the_buffer  : in out IOC.device;
   919.                   Q_operand   : in KDF9.Q_register;
   920.                   set_offline : in Boolean) is
   921.       pragma Unreferenced(Q_operand);
   922.       pragma Unreferenced(set_offline);
   923.    begin
   924.       trap_illegal_IO_operation("PML", the_buffer);
   925.    end PML;
   926.
   927.    procedure POA (the_buffer  : in out IOC.device;
   928.                   Q_operand   : in KDF9.Q_register;
   929.                   set_offline : in Boolean) is
   930.       pragma Unreferenced(Q_operand);
   931.       pragma Unreferenced(set_offline);
   932.    begin
   933.       trap_illegal_IO_operation("POA", the_buffer);
   934.    end POA;
   935.
   936.    procedure POB (the_buffer  : in out IOC.device;
   937.                   Q_operand   : in KDF9.Q_register;
   938.                   set_offline : in Boolean) is
   939.       pragma Unreferenced(Q_operand);
   940.       pragma Unreferenced(set_offline);
   941.    begin
   942.       trap_illegal_IO_operation("POB", the_buffer);
   943.    end POB;
   944.
   945.    procedure POC (the_buffer  : in out IOC.device;
   946.                   Q_operand   : in KDF9.Q_register;
   947.                   set_offline : in Boolean) is
   948.       pragma Unreferenced(Q_operand);
   949.       pragma Unreferenced(set_offline);
   950.    begin
   951.       trap_illegal_IO_operation("POC", the_buffer);
   952.    end POC;
   953.
   954.    procedure POD (the_buffer  : in out IOC.device;
   955.                   Q_operand   : in KDF9.Q_register;
   956.                   set_offline : in Boolean) is
   957.       pragma Unreferenced(Q_operand);
   958.       pragma Unreferenced(set_offline);
   959.    begin
   960.       trap_illegal_IO_operation("POD", the_buffer);
   961.    end POD;
   962.
   963.    procedure POE (the_buffer  : in out IOC.device;
   964.                   Q_operand   : in KDF9.Q_register;
   965.                   set_offline : in Boolean) is
   966.       pragma Unreferenced(Q_operand);
   967.       pragma Unreferenced(set_offline);
   968.    begin
   969.       trap_illegal_IO_operation("POE", the_buffer);
   970.    end POE;
   971.
   972.    procedure POF (the_buffer  : in out IOC.device;
   973.                   Q_operand   : in KDF9.Q_register;
   974.                   set_offline : in Boolean) is
   975.       pragma Unreferenced(Q_operand);
   976.       pragma Unreferenced(set_offline);
   977.    begin
   978.       trap_illegal_IO_operation("POF", the_buffer);
   979.    end POF;
   980.
   981.    procedure POG (the_buffer  : in out IOC.device;
   982.                   Q_operand   : in KDF9.Q_register;
   983.                   set_offline : in Boolean) is
   984.       pragma Unreferenced(Q_operand);
   985.       pragma Unreferenced(set_offline);
   986.    begin
   987.       trap_illegal_IO_operation("POG", the_buffer);
   988.    end POG;
   989.
   990.    procedure POH (the_buffer  : in out IOC.device;
   991.                   Q_operand   : in KDF9.Q_register;
   992.                   set_offline : in Boolean) is
   993.       pragma Unreferenced(Q_operand);
   994.       pragma Unreferenced(set_offline);
   995.    begin
   996.       trap_illegal_IO_operation("POH", the_buffer);
   997.    end POH;
   998.
   999.    procedure POK (the_buffer  : in out IOC.device;
  1000.                   Q_operand   : in KDF9.Q_register;
  1001.                   set_offline : in Boolean) is
  1002.       pragma Unreferenced(Q_operand);
  1003.       pragma Unreferenced(set_offline);
  1004.    begin
  1005.       trap_illegal_IO_operation("POK", the_buffer);
  1006.    end POK;
  1007.
  1008.    procedure POL (the_buffer  : in out IOC.device;
  1009.                   Q_operand   : in KDF9.Q_register;
  1010.                   set_offline : in Boolean) is
  1011.       pragma Unreferenced(Q_operand);
  1012.       pragma Unreferenced(set_offline);
  1013.    begin
  1014.       trap_illegal_IO_operation("POL", the_buffer);
  1015.    end POL;
  1016.
  1017. end IOC;

Compiling: ../Source/ioc.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:19

     1. -- ioc.ads
     2. --
     3. -- Emulation of the common functionality of a KDF9 IOC "buffer" (DMA channel),
     4. --    with fail-stop stubs for operations having device-specific behaviour.
     5. --
     6. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     7. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     8. --
     9. -- The ee9 program is free software; you can redistribute it and/or
    10. -- modify it under terms of the GNU General Public License as published
    11. -- by the Free Software Foundation; either version 3, or (at your option)
    12. -- any later version. This program is distributed in the hope that it
    13. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    14. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    15. -- See the GNU General Public License for more details. You should have
    16. -- received a copy of the GNU General Public License distributed with
    17. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    18. --
    19.
    20. with Ada.Finalization;
    21. --
    22. with KDF9;
    23.
    24. private with Ada.Characters.Latin_1;
    25. --
    26. private with exceptions;
    27. private with formatting;
    28. private with host_IO;
    29. private with KDF9_char_sets;
    30. private with KDF9.store;
    31. private with POSIX;
    32. private with settings;
    33.
    34. use  Ada.Finalization;
    35. --
    36. use  KDF9;
    37.
    38. package IOC is
    39.
    40.    -- N.B. the KDF9 'buffer' is a DMA controller in more modern terminology.
    41.
    42.    -- Each KDF9 buffer is externally characterized by:
    43.    --    its (absolute) number,
    44.    --    its (attached-device) kind, and
    45.    --    its unit (the number of that device within its kind).
    46.
    47.    -- A device of ND_kind is attached to a buffer with No Device connected.
    48.    -- If commanded, it performs a basic default action,
    49.    --    which is to cause a LIV interrupt in the case of transfers,
    50.    --       but is both benign and appropriate for all other operations.
    51.
    52.    type device_kind is
    53.       (CP_kind,  -- Card Punch
    54.        CR_kind,  -- Card Reader
    55.        DR_kind,  -- Drum
    56.        FD_kind,  -- Fixed Disc
    57.        FW_kind,  -- FlexoWriter (monitor typewriter)
    58.        GP_kind,  -- Graph Plotter (Calcomp 120' by 29.5" model)
    59.        LP_kind,  -- Line Printer
    60.        MT_kind,  -- Magnetic Tape
    61.        SI_kind,  -- Standard Interface buffer
    62.        ST_kind,  -- Seven Track (IBM) magnetic Tape
    63.        TP_kind,  -- Tape Punch
    64.        TR_kind,  -- Tape Reader
    65.        ND_kind   -- No Device
    66.       );
    67.
    68.    -- An absent device has number 16 (not a valid buffer number).
    69.    subtype device_number is KDF9.Q_part range 0 .. 16;
    70.
    71.    -- There are at most 10 devices of a type (this is an ee9 limit, not imposed by KDF9 hardware).
    72.    subtype unit_number is KDF9.Q_part range 0 .. 9;
    73.
    74.    -- An IOC.device_name is of the form XYu, where XY is a two-letter device-type
    75.    --    code (e.g., "LP" or "CR"); and u is the one-digit logical unit number
    76.    --       of a device within its category.
    77.
    78.    subtype device_name is String(1..3);
    79.
    80. --
    81. --
    82.    -- This is the root for all I/O device types.
    83. --
    84. --
    85.
    86.    -- The quantum is the time, in µs, taken to transfer a basic datum.
    87.    -- For unit-record devices (CR, CP, LP) this is the card/line, respectively.
    88.    -- For other devices it is the KDF9 character.
    89.    -- A device is slow if it transfers data byte-by-byte; fast devices transfer whole words.
    90.
    91.    type device (
    92.                 number  : IOC.device_number;
    93.                 kind    : IOC.device_kind;
    94.                 unit    : IOC.unit_number;
    95.                 quantum : KDF9.us
    96.                )
    97.    is abstract new Limited_Controlled with private;
    98.
    99.    -- True iff the_buffer has been opened but not yet closed.
   100.    function is_open (the_buffer : IOC.device)
   101.    return Boolean;
   102.
   103.    -- A measure of the I/O volume transferred by the_buffer, so far.
   104.    function usage (the_buffer : IOC.device)
   105.    return KDF9.word;
   106.
   107.    -- Ensure that all output to the_buffer has been transmitted.
   108.    procedure flush (the_buffer : in out IOC.device);
   109.
   110.    -- Make the_buffer unavailable for further I/O use, after flushing if necessary.
   111.    procedure close (the_buffer : in out IOC.device);
   112.
   113.    -- A IOC.device_name is of the form XYu, where XY is a two-letter device-type
   114.    --    code (e.g., "LP" or "CR"); and u is the one-digit logical unit number
   115.    --       of a device within its category.
   116.
   117.    function device_name_of (the_buffer : IOC.device)
   118.    return IOC.device_name;
   119.
   120.    function device_name_of (the_number : IOC.device_number)
   121.    return IOC.device_name;
   122.
   123.    function device_kind_of (the_number : IOC.device_number)
   124.    return IOC.device_kind;
   125.
   126.    function mnemonic (order : in String; class : in IOC.device_name)
   127.    return String;
   128.
   129.    -- An I/O operation may fail for two distict reasons:
   130.    -- 1. the order is illegal per se
   131.    -- 2. the order is legal, but is attempting an impossible effect.
   132.
   133.    -- trap_illegal_IO_operation fails the run because of an attempt to use an I/O order
   134.    --   that is illegal or undefined for the device concerned.
   135.    procedure trap_illegal_IO_operation (order : in String; buffer : in IOC.device);
   136.
   137.    -- trap_failing_IO_operation fails the run iff either:
   138.    -- 1. ee9 is running in a non-boot mode, because nothing more can usefully be done
   139.    -- OR
   140.    -- 2. Director is running, because an impossible operation implies a serious failure in Director.
   141.    --
   142.    -- In boot mode, when Director is not running, it sets the buffer abnormal and abandons the order.
   143.    -- It is then up to the problem program to act accordingly.  Failure to do so may LIV.
   144.    procedure trap_failing_IO_operation (the_buffer : in out IOC.device; the_message : in String);
   145.
   146.    -- The elapsed time for the I/O of the given number of atomic_items
   147.    --    which may be, e.g., bytes, or card images, or printer lines.
   148.    function IO_elapsed_time (the_buffer   : IOC.device;
   149.                              atomic_items : KDF9.word)
   150.    return KDF9.us;
   151.
   152.    -- The total elapsed time taken, so far, by transfers on the attached device.
   153.    function IO_elapsed_time_total (the_buffer : IOC.device)
   154.    return KDF9.us;
   155.
   156.
   157.    --
   158.    -- The CLOQq, SLOQq and TLOQq operations do NOT address a buffer,
   159.    --    and so are fully implemented elsewhere.
   160.    --
   161.
   162.    --
   163.    -- The INTQq, BUSYQq, PARQq and MANUALQq/CTQq operations DO address a buffer,
   164.    --    but do NOT initiate an I/O transfer, and are common to all devices,
   165.    --       so they operate on a class-wide parameter.
   166.    --
   167.
   168.    procedure INT (the_buffer  : in out IOC.device'Class;
   169.                   Q_operand   : in KDF9.Q_register;
   170.                   set_offline : in Boolean);
   171.
   172.    procedure BUSY (the_buffer  : in out IOC.device'Class;
   173.                    Q_operand   : in KDF9.Q_register;
   174.                    set_offline : in Boolean;
   175.                    result      : out Boolean);
   176.
   177.    procedure PAR (the_buffer   : in out IOC.device'Class;
   178.                    Q_operand   : in KDF9.Q_register;
   179.                    set_offline : in Boolean;
   180.                    result      : out Boolean);
   181.
   182.    procedure MANUAL_CT (the_buffer  : in out IOC.device'Class;
   183.                         Q_operand   : in KDF9.Q_register;
   184.                         set_offline : in Boolean);
   185.
   186.    -- These KDF9 data-transfer operations must be overridden for non-trivial functionality.
   187.    -- Invoking any of them raises a LIV exception. This exactly mirrors the action of the
   188.    --    KDF9 in causing a LIV interrupt when an invalid operation was applied to a device.
   189.    -- A device without some of these operations inherits them from this list and so
   190.    --    implements correctly the original semantics of the KDF9.
   191.
   192.    --
   193.    -- The PI* are input operations.
   194.    --
   195.
   196.    procedure PIA (the_buffer  : in out IOC.device;
   197.                   Q_operand   : in KDF9.Q_register;
   198.                   set_offline : in Boolean);
   199.
   200.    procedure PIB (the_buffer  : in out IOC.device;
   201.                   Q_operand   : in KDF9.Q_register;
   202.                   set_offline : in Boolean);
   203.
   204.    procedure PIC (the_buffer  : in out IOC.device;
   205.                   Q_operand   : in KDF9.Q_register;
   206.                   set_offline : in Boolean);
   207.
   208.    procedure PID (the_buffer  : in out IOC.device;
   209.                   Q_operand   : in KDF9.Q_register;
   210.                   set_offline : in Boolean);
   211.
   212.    procedure PIE (the_buffer  : in out IOC.device;
   213.                   Q_operand   : in KDF9.Q_register;
   214.                   set_offline : in Boolean);
   215.
   216.    procedure PIF (the_buffer  : in out IOC.device;
   217.                   Q_operand   : in KDF9.Q_register;
   218.                   set_offline : in Boolean);
   219.
   220.    procedure PIG (the_buffer  : in out IOC.device;
   221.                   Q_operand   : in KDF9.Q_register;
   222.                   set_offline : in Boolean);
   223.
   224.    procedure PIH (the_buffer  : in out IOC.device;
   225.                   Q_operand   : in KDF9.Q_register;
   226.                   set_offline : in Boolean);
   227.
   228.    --
   229.    -- The PM* are device-status operations.
   230.    --
   231.
   232.    procedure PMA (the_buffer  : in out IOC.device;
   233.                   Q_operand   : in KDF9.Q_register;
   234.                   set_offline : in Boolean);
   235.
   236.    procedure PMB (the_buffer  : in out IOC.device;
   237.                   Q_operand   : in KDF9.Q_register;
   238.                   set_offline : in Boolean);
   239.
   240.    procedure PMC (the_buffer  : in out IOC.device;
   241.                   Q_operand   : in KDF9.Q_register;
   242.                   set_offline : in Boolean);
   243.
   244.    procedure PMD (the_buffer  : in out IOC.device;
   245.                   Q_operand   : in KDF9.Q_register;
   246.                   set_offline : in Boolean);
   247.
   248.    procedure PME (the_buffer  : in out IOC.device;
   249.                   Q_operand   : in KDF9.Q_register;
   250.                   set_offline : in Boolean);
   251.
   252.    procedure PMF (the_buffer  : in out IOC.device;
   253.                   Q_operand   : in KDF9.Q_register;
   254.                   set_offline : in Boolean);
   255.
   256.    procedure PMG (the_buffer  : in out IOC.device;
   257.                   Q_operand   : in KDF9.Q_register;
   258.                   set_offline : in Boolean);
   259.
   260. -- procedure PMH is implemented by SLO
   261.
   262.    procedure PMK (the_buffer  : in out IOC.device;
   263.                   Q_operand   : in KDF9.Q_register;
   264.                   set_offline : in Boolean);
   265.
   266.    procedure PML (the_buffer  : in out IOC.device;
   267.                   Q_operand   : in KDF9.Q_register;
   268.                   set_offline : in Boolean);
   269.
   270.    --
   271.    -- The PO* are output operations.
   272.    --
   273.
   274.    procedure POA (the_buffer  : in out IOC.device;
   275.                   Q_operand   : in KDF9.Q_register;
   276.                   set_offline : in Boolean);
   277.
   278.    procedure POB (the_buffer  : in out IOC.device;
   279.                   Q_operand   : in KDF9.Q_register;
   280.                   set_offline : in Boolean);
   281.
   282.    procedure POC (the_buffer  : in out IOC.device;
   283.                   Q_operand   : in KDF9.Q_register;
   284.                   set_offline : in Boolean);
   285.
   286.    procedure POD (the_buffer  : in out IOC.device;
   287.                   Q_operand   : in KDF9.Q_register;
   288.                   set_offline : in Boolean);
   289.
   290.    procedure POE (the_buffer  : in out IOC.device;
   291.                   Q_operand   : in KDF9.Q_register;
   292.                   set_offline : in Boolean);
   293.
   294.    procedure POF (the_buffer  : in out IOC.device;
   295.                   Q_operand   : in KDF9.Q_register;
   296.                   set_offline : in Boolean);
   297.
   298.    procedure POG (the_buffer  : in out IOC.device;
   299.                   Q_operand   : in KDF9.Q_register;
   300.                   set_offline : in Boolean);
   301.
   302.    procedure POH (the_buffer  : in out IOC.device;
   303.                   Q_operand   : in KDF9.Q_register;
   304.                   set_offline : in Boolean);
   305.
   306.    procedure POK (the_buffer  : in out IOC.device;
   307.                   Q_operand   : in KDF9.Q_register;
   308.                   set_offline : in Boolean);
   309.
   310.    procedure POL (the_buffer  : in out IOC.device;
   311.                   Q_operand   : in KDF9.Q_register;
   312.                   set_offline : in Boolean);
   313.
   314.
   315. --
   316. --
   317.    -- The buffer_configuration type enables the dynamic setting-up of a complement of I/O devices.
   318. --
   319. --
   320.
   321.    type device_class_access  is access all IOC.device'Class;
   322.
   323.    type buffer_configuration is array (KDF9.buffer_number) of IOC.device_class_access;
   324.
   325.    -- These are the I/O devices installed in this configuration.
   326.    -- Each device installs itself into the configuration when the device is initialized.
   327.
   328.    buffer : buffer_configuration;
   329.
   330. --
   331.    -- These operations are used by Directors to manage device allocation to problem programs.
   332. --
   333.
   334.    procedure set_state_of (the_buffer : in device_class_access;
   335.                            allocated  : in Boolean);
   336.
   337.    function is_allocated (the_buffer : device_class_access)  -- N.B. IS_allocated.
   338.    return Boolean;
   339.
   340.    function is_unallocated (the_buffer : device_class_access)  -- N.B. is_UNallocated.
   341.    return Boolean;
   342.
   343. --
   344.    -- These buffer-implementation operations are used outside IOC and apply to all device types.
   345. --
   346.
   347.    -- Complete all extant transfers, then Finalize each buffer.
   348.    procedure finalize_all_KDF9_buffers;
   349.
   350.    -- Advance the elapsed time to a point after all extant transfer have terminated.
   351.    procedure complete_all_extant_transfers;
   352.
   353.    -- Complete any terminated transfer operations and take any needed interrupts.
   354.    procedure act_on_pending_interrupts;
   355.
   356.    -- Handle non-data transfer operations on busy device.
   357.    procedure deal_with_a_busy_device (the_buffer  : in out IOC.device'Class;
   358.                                       order_time  : in KDF9.us;
   359.                                       set_offline : in Boolean);
   360.
   361.    -- A LOV interupt caused by an attempted store access must arrange
   362.    --    for the interrupted instruction to be resumed.
   363.    -- In boot mode, effect the LOV interrupt to Director.
   364.    -- In other modes, advance the elapsed time to the end-of-transfer time
   365.    --    for the_locked_out_address, then act on pending interrupts.
   366.    procedure handle_a_main_store_lockout;
   367.
   368.    type transfer_kind  is (input_operation,
   369.                            output_operation,
   370.                            control_operation,
   371.                            some_other_operation);
   372.
   373.    -- Take note of the start of a transfer.
   374.    -- For I/O operations that do not entail an actual data transfer,
   375.    --    such as testing a buffer for a graph plotter,
   376.    --    set the busy time to the order's MC execution time.
   377.    -- This keeps elapsed time in sync with CPU time,
   378.    --    and ensures that the operation waits for any preceding transfer
   379.    --    on the same buffer to complete before the test is actioned.
   380.    procedure start_data_transfer (the_buffer  : in out IOC.device'Class;
   381.                                   Q_operand   : in KDF9.Q_register;
   382.                                   set_offline : in Boolean;
   383.                                   busy_time   : in KDF9.us;
   384.                                   operation   : in IOC.transfer_kind := IOC.some_other_operation);
   385.
   386.    -- True iff the buffer is busy and the current operation is reading oe writing.
   387.    function is_DMAing (the_buffer  : in IOC.device'Class)
   388.    return Boolean;
   389.
   390.    -- Gives a short summary of the buffer state, showing some transfer parameters.
   391.    function image (the_buffer : in IOC.device'Class)
   392.    return String;
   393.
   394. private
   395.
   396.    -- The following packages are hereby made available to all children of IOC.
   397.
   398.    use exceptions;             pragma Warnings(Off, exceptions);
   399.    use formatting;             pragma Warnings(Off, formatting);
   400.    use host_IO;                pragma Warnings(Off, host_IO);
   401.    use KDF9_char_sets;         pragma Warnings(Off, KDF9_char_sets);
   402.    use KDF9.store;             pragma Warnings(Off, KDF9.store);
   403.    use settings;               pragma Warnings(Off, settings);
   404.    use POSIX;                  -- Used here, so no need to suppress warnings.
   405.
   406.    type device (
   407.                 number  : IOC.device_number;
   408.                 kind    : IOC.device_kind;
   409.                 unit    : IOC.unit_number;
   410.                 quantum : KDF9.us
   411.                )
   412.    is abstract new Limited_Controlled with
   413.                record
   414.                   is_abnormal,
   415.                   is_busy,
   416.                   is_offline,
   417.                   is_allocated,
   418.                   is_for_Director : Boolean := False;
   419.                   operation       : IOC.transfer_kind := IOC.some_other_operation;
   420.                   initiation_time : KDF9.us := KDF9.us'Last;
   421.                   transfer_time   : KDF9.us := KDF9.us'Last;
   422.                   completion_time : KDF9.us := KDF9.us'Last;
   423.                   priority_level  : KDF9.priority := 0;
   424.                   control_word    : KDF9.Q_register;
   425.                   decoded_order   : KDF9.decoded_order;
   426.                   device_name     : IOC.device_name;
   427.                   order_address   : KDF9.syllable_address := (0, 0);
   428.                   order_count     : KDF9.order_counter;
   429.                   stream          : host_IO.stream;
   430.                end record;
   431.
   432.    overriding
   433.    procedure Initialize (the_buffer : in out IOC.device);
   434.
   435.    procedure open (the_buffer : in out IOC.device'Class;
   436.                    the_mode   : in POSIX.access_mode);
   437.
   438.    overriding
   439.    procedure Finalize (the_buffer : in out IOC.device);
   440.
   441.    -- Operations, used only within the IOC hierarchy, that apply to all device types.
   442.
   443.    -- Check that the buffer for the_device is unused, then set it to the_device.
   444.    procedure install (the_device : in out IOC.device'Class);
   445.
   446.    -- LIV if the_buffer is in the abnormal state.
   447.    procedure validate_parity (the_buffer : in IOC.device'Class);
   448.
   449.    -- Check that the_buffer is online, validly identified by the Q_operand,
   450.    --    and that access to it is permitted by the (perhaps simulated) Director;
   451.    --       LIV if not.
   452.    procedure validate_device (the_buffer : in IOC.device'Class;
   453.                               Q_operand  : in KDF9.Q_register);
   454.
   455.    -- Check that the device and the transfer address bounds are valid;
   456.    --    LIV if not.
   457.    procedure validate_transfer (the_buffer : in IOC.device'Class;
   458.                                 Q_operand  : in KDF9.Q_register);
   459.
   460.    -- When the real duration of a variable-length transfer is known,
   461.    --    its completion time can be made accurate by giving its actual_time.
   462.    -- correct_transfer_time must be called before finalize_transfer is called.
   463.    procedure correct_transfer_time (the_buffer  : in out IOC.device'Class;
   464.                                     actual_time : in KDF9.us);
   465.
   466.    procedure correct_transfer_time (the_buffer    : in out IOC.device'Class;
   467.                                     actual_length : in KDF9.word);
   468.
   469.    -- Account for the CPU (i.e., core store) time taken by the buffer's DMA cycles.
   470.    procedure add_in_the_IO_CPU_time (IO_CPU_time : in KDF9.us);
   471.
   472.    procedure add_in_the_IO_CPU_time (the_buffer  : in IOC.device'Class;
   473.                                      bytes_moved : in KDF9.word);
   474.
   475.    -- LIV if the repetition count is negative.
   476.    procedure require_nonnegative_count (count : in KDF9.Q_part);
   477.
   478.    -- LIV if the repetition count is negative or zero.
   479.    procedure require_positive_count (count : in KDF9.Q_part);
   480.
   481.    -- Account for the CPU time taken by the buffer in setting store lockouts.
   482.    procedure add_in_the_IO_lockout_CPU_time (Q_operand : in KDF9.Q_register);
   483.
   484.    -- These are handy, and also prevent a unreferenced warning for Ada.Characters.Latin_1.
   485.    LF : constant Character := Ada.Characters.Latin_1.LF;
   486.    SP : constant Character := Ada.Characters.Latin_1.Space;
   487.
   488. end IOC;

 1017 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-equipment.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:20

     1. -- IOC.equipment.adb
     2. --
     3. -- Data supporting the definition of a KDF9 I/O equipment configuration.
     4. --
     5. --
     6. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     7. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     8. --
     9. -- The ee9 program is free software; you can redistribute it and/or
    10. -- modify it under terms of the GNU General Public License as published
    11. -- by the Free Software Foundation; either version 3, or (at your option)
    12. -- any later version. This program is distributed in the hope that it
    13. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    14. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    15. -- See the GNU General Public License for more details. You should have
    16. -- received a copy of the GNU General Public License distributed with
    17. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    18. --
    19.
    20. with IOC.absent;
    21. with IOC.fast.DR;
    22. with IOC.fast.FD;
    23. with IOC.fast.MT;
    24. with IOC.slow.shift.FW;
    25. with IOC.slow.shift.GP;
    26. with IOC.slow.shift.SI;
    27. with IOC.slow.shift.TP;
    28. with IOC.slow.shift.TR;
    29. with IOC.slow.unit.CP;
    30. with IOC.slow.unit.CR;
    31. with IOC.slow.unit.LP;
    32. with settings;
    33.
    34. package body IOC.equipment is
    35.
    36.    procedure configure is
    37.    begin
    38.       for b in KDF9.buffer_number loop
    39.          case equipment.choice(b) is
    40.             when CP => IOC.slow.unit.CP.enable(b);
    41.             when CR => IOC.slow.unit.CR.enable(b);
    42.             when DR => IOC.fast.DR.enable(b);
    43.             when FD => IOC.fast.FD.enable(b);
    44.             when FW => IOC.slow.shift.FW.enable(b);
    45.             when GP => IOC.slow.shift.GP.enable(b);
    46.             when LP => IOC.slow.unit.LP.enable(b);
    47.             when MT => IOC.fast.MT.enable_MT_deck(b);
    48.             when NA => IOC.absent.enable(b);
    49.             when SI => IOC.slow.shift.SI.enable(b);
    50.             when ST => IOC.fast.MT.enable_ST_deck(b);
    51.             when TP => IOC.slow.shift.TP.enable(b);
    52.             when TR => IOC.slow.shift.TR.enable(b);
    53.          end case;
    54.       end loop;
    55.       if IOC.buffer(0) = null              or else
    56.             IOC.buffer(0).kind /= IOC.FW_kind then
    57.          trap_operator_error("buffer #00", "is not a FW");
    58.       end if;
    59.       if IOC.buffer(1) = null              or else
    60.             IOC.buffer(1).kind /= IOC.TR_kind then
    61.          trap_operator_error("buffer #01", "is not a TR");
    62.       end if;
    63.       if the_graph_plotter_is_enabled then
    64.          install_GP0;
    65.       end if;
    66.       for b in IOC.equipment.choices'Range loop
    67.          if IOC.buffer(b) = null then
    68.             IOC.absent.enable(b);
    69.          end if;
    70.       end loop;
    71.    end configure;
    72.
    73.    procedure re_configure is
    74.    begin
    75.       for b in KDF9.buffer_number loop
    76.          case equipment.choice(b) is
    77.             when DR => IOC.fast.DR.re_enable(b);
    78.             when FD => IOC.fast.FD.re_enable(b);
    79.             when SI => IOC.slow.shift.SI.re_enable(b);
    80.             when others => null;
    81.          end case;
    82.       end loop;
    83.    end re_configure;
    84.
    85.    procedure install_GP0 is
    86.       b : KDF9.buffer_number;
    87.    begin
    88.       if the_graph_plotter_is_enabled then
    89.          IOC.slow.shift.TP.disable_TP1(b);
    90.          IOC.slow.shift.GP.enable(b);
    91.       end if;
    92.    end install_GP0;
    93.
    94. end IOC.equipment;

Compiling: ../Source/ioc-equipment.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:20

     1. -- IOC.equipment.ads
     2. --
     3. -- Enable the devices included in the chosen KDF9 I/O configuration.
     4. --
     5. --
     6. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     7. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     8. --
     9. -- The ee9 program is free software; you can redistribute it and/or
    10. -- modify it under terms of the GNU General Public License as published
    11. -- by the Free Software Foundation; either version 3, or (at your option)
    12. -- any later version. This program is distributed in the hope that it
    13. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    14. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    15. -- See the GNU General Public License for more details. You should have
    16. -- received a copy of the GNU General Public License distributed with
    17. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    18. --
    19.
    20. with KDF9;
    21.
    22. package IOC.equipment is
    23.
    24.    -- These variables are used in the emulation of OUT 5.
    25.    -- They are set to the device buffer number at the start of each run by configure.
    26.    -- A value of 0 indicates that the device is not included in the configuration for the run.
    27.    -- Fast devices are not allocated by this mechanism and so do not appear here.
    28.
    29.    CP0_number  : KDF9.buffer_number := 0;
    30.    CP1_number  : KDF9.buffer_number := 0;
    31.    CR0_number  : KDF9.buffer_number := 0;
    32.    CR1_number  : KDF9.buffer_number := 0;
    33.    GP0_number  : KDF9.buffer_number := 0;
    34.    LP0_number  : KDF9.buffer_number := 0;
    35.    LP1_number  : KDF9.buffer_number := 0;
    36.    SI0_number  : KDF9.buffer_number := 0;
    37.    SI1_number  : KDF9.buffer_number := 0;
    38.    TP0_number  : KDF9.buffer_number := 0;
    39.    TP1_number  : KDF9.buffer_number := 0;
    40.    TR0_number  : KDF9.buffer_number := 0;
    41.    TR1_number  : KDF9.buffer_number := 0;
    42.
    43.    type device_kinds is (CP, CR, DR, FD, FW, GP, LP, MT, NA, SI, ST, TP, TR);
    44.
    45.    type choices      is array (KDF9.buffer_number) of equipment.device_kinds;
    46.
    47.    -- These are the buffer numbers for the devices in the default configuration.
    48.    -- The Fixed Disc drive was on buffer 14 (#16) of Eldon 2 KDF9s, so I adopt that here.
    49.
    50.    FW0_default : constant KDF9.buffer_number := 0;
    51.    TR0_default : constant KDF9.buffer_number := 1;
    52.    TR1_default : constant KDF9.buffer_number := 2;
    53.    TP0_default : constant KDF9.buffer_number := 3;
    54.    TP1_default : constant KDF9.buffer_number := 4;
    55.    LP0_default : constant KDF9.buffer_number := 5;
    56.    CR0_default : constant KDF9.buffer_number := 6;
    57.    CP0_default : constant KDF9.buffer_number := 7;
    58.    MT0_default : constant KDF9.buffer_number := 8;
    59.    MT1_default : constant KDF9.buffer_number := 9;
    60.    MT2_default : constant KDF9.buffer_number := 10;
    61.    MT3_default : constant KDF9.buffer_number := 11;
    62.    MT4_default : constant KDF9.buffer_number := 12;
    63.    MT5_default : constant KDF9.buffer_number := 13;
    64.    FD0_default : constant KDF9.buffer_number := 14;
    65.    ST0_default : constant KDF9.buffer_number := 15;
    66.
    67.    default     : constant equipment.choices
    68.                := (
    69.                    CP0_default => CP,
    70.                    CR0_default => CR,
    71.                    FD0_default => FD,
    72.                    FW0_default => FW,
    73.                    LP0_default => LP,
    74.                    MT0_default => MT,
    75.                    MT1_default => MT,
    76.                    MT2_default => MT,
    77.                    MT3_default => MT,
    78.                    MT4_default => MT,
    79.                    MT5_default => MT,
    80.                    ST0_default => ST,
    81.                    TP0_default => TP,
    82.                    TP1_default => TP,
    83.                    TR0_default => TR,
    84.                    TR1_default => TR
    85.                   );
    86.
    87.    choice      : equipment.choices := default;
    88.
    89.    -- Attach the chosen devices to their buffers.
    90.    procedure configure;
    91.
    92.    -- If a drum or disc has been enabled, replace it on the buffer used by the other.
    93.    procedure re_configure;
    94.
    95.    procedure install_GP0;
    96.
    97. end IOC.equipment;

 94 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-slow.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:20

     1. -- ioc-slow_devices.adb
     2. --
     3. -- Emulation of the common functionality of a KDF9 "slow", byte-by-byte, devices.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with HCI;
    20. with OS_specifics;
    21. with environmental_value_of;
    22.
    23. use HCI;
    24.
    25. package body IOC.slow is
    26.
    27.    procedure display_device_usage (the_buffer  : in slow.device;
    28.                                    the_action  : in String;
    29.                                    the_amount  : in KDF9.word;
    30.                                    the_quantum : in String) is
    31.    begin
    32.          if the_final_state_is_wanted and then
    33.                the_log_is_wanted      and then
    34.                   the_buffer.is_open  and then
    35.                the_amount /= 0            then
    36.          if (the_buffer.number = 0) and not (API_logging_is_wanted or the_log_is_wanted) then
    37.             -- Take a new line at the head of the list, for low-visibility modes.
    38.             log_new_line;
    39.          end if;
    40.          log_line(
    41.                   the_buffer.device_name
    42.                 & " on buffer #"
    43.                 & oct_of(KDF9.Q_part(the_buffer.number), 2)
    44.                 & " "
    45.                 & the_action
    46.                 & the_amount'Image
    47.                 & " "
    48.                 & the_quantum
    49.                 & "."
    50.                  );
    51.       end if;
    52.    end display_device_usage;
    53.
    54.    procedure close (the_buffer  : in out slow.device;
    55.                     the_action  : in String;
    56.                     the_amount  : in KDF9.word;
    57.                     the_quantum : in String) is
    58.    begin
    59.       display_device_usage (the_buffer, the_action, the_amount, the_quantum);
    60.       IOC.device(the_buffer).close;
    61.    end close;
    62.
    63.    function atomic_item_count (the_buffer : slow.device;
    64.                                Q_operand  : KDF9.Q_register)
    65.    return KDF9.word is
    66.       words : constant KDF9.Q_part := Q_operand.M - Q_operand.I + 1;
    67.    begin
    68.       if the_buffer.is_open then
    69.          return KDF9.word(words) * 8;
    70.       else
    71.          return 0;
    72.       end if;
    73.    end atomic_item_count;
    74.
    75.    procedure reattach (the_buffer   : in out slow.device;
    76.                        the_file     : in String) is
    77.    begin
    78.       reattach(the_buffer.stream, the_file, read_mode);
    79.    end reattach;
    80.
    81.    procedure deal_with_end_of_data (the_buffer : in out slow.device) is
    82.       BEL      : constant String := (1 => Character'Val(7));   -- Audible prompt
    83.       response : response_kind;
    84.
    85.       procedure reattach_the_text_file (name : in String) is
    86.       begin
    87.          if name = "" then
    88.             the_buffer.is_abnormal := True;
    89.             raise end_of_stream;
    90.          elsif exists(name) then
    91.             reattach(the_buffer, name);
    92.             return;
    93.          elsif exists(name & ".txt") then
    94.             reattach(the_buffer, name & ".txt");
    95.             return;
    96.          else
    97.             the_buffer.is_abnormal := True;
    98.             raise end_of_stream;
    99.          end if;
   100.       end reattach_the_text_file;
   101.
   102.    begin
   103.       output_line(BEL & "");
   104.       output_line("ee9: End of given data for " & the_buffer.device_name & ".");
   105.       loop
   106.          POSIX.data_prompt(
   107.                            noninteractive_usage_is_enabled,
   108.                            "Type @ or / to name a file, = to type the data, ENTER key for EOF, Q or q to quit",
   109.                            response
   110.                           );
   111.          if response = wrong_response then
   112.             null;  -- repeat the prompt
   113.          elsif response = quit_response then
   114.             trap_failing_IO_operation(the_buffer, "end of data indicated");
   115.          elsif response = EOF_response then
   116.             the_buffer.is_abnormal := True;
   117.             raise end_of_stream;
   118.          elsif response = here_response then
   119.             reattach(the_buffer, OS_specifics.UI_in_name);
   120.             return;
   121.          elsif response = at_response then
   122.             declare
   123.                here : constant String := environmental_value_of("KDF9_DATA", default => "Data") & "/";
   124.                next : constant String := next_file_name(BEL & "Give the name of a file in " & here);
   125.             begin
   126.                reattach_the_text_file(here & next);
   127.                return;
   128.             end;
   129.          elsif response = name_response then
   130.             reattach_the_text_file(next_file_name(BEL & "Give the pathname of the file"));
   131.             return;
   132.          end if;
   133.       end loop;
   134.    end deal_with_end_of_data;
   135.
   136.    procedure start_slow_transfer (the_buffer   : in out slow.device;
   137.                                   Q_operand    : in KDF9.Q_register;
   138.                                   set_offline  : in Boolean;
   139.                                   operation    : in IOC.transfer_kind := some_other_operation) is
   140.       atomic_items : constant KDF9.word := atomic_item_count(the_buffer, Q_operand);
   141.       time_needed  : constant KDF9.us := IO_elapsed_time(the_buffer, atomic_items);
   142.    begin
   143.       start_data_transfer(the_buffer, Q_operand, set_offline,
   144.                           busy_time => time_needed,
   145.                           operation => start_slow_transfer.operation);
   146.    end start_slow_transfer;
   147.
   148.    procedure get_byte_from_stream (byte       : out Character;
   149.                                    the_buffer : in out slow.device) is
   150.    begin
   151.       loop
   152.          begin
   153.             get_byte(byte, the_buffer.stream);
   154.             return;
   155.          exception
   156.             when end_of_stream =>
   157.                deal_with_end_of_data(the_buffer);
   158.          end;
   159.       end loop;
   160.    end get_byte_from_stream;
   161.
   162.    procedure get_char_from_stream (char       : out Character;
   163.                                    the_buffer : in out slow.device) is
   164.    begin
   165.       loop
   166.          begin
   167.             get_char(char, the_buffer.stream);
   168.             return;
   169.          exception
   170.             when end_of_stream =>
   171.                deal_with_end_of_data(the_buffer);
   172.          end;
   173.       end loop;
   174.    end get_char_from_stream;
   175.
   176. end IOC.slow;

Compiling: ../Source/ioc-slow.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:20

     1. -- ioc-slow.ads
     2. --
     3. -- Emulation of the common functionality of a KDF9 "slow", i.e. byte-by-byte, devices.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.slow is
    20.
    21.    --
    22.    -- This is the root type for all slow I/O device types.
    23.    --
    24.
    25.    type device is abstract new IOC.device with private;
    26.
    27.    -- Log the usage statistics for the device on the buffer.
    28.    procedure display_device_usage (the_buffer  : in slow.device;
    29.                                    the_action  : in String;
    30.                                    the_amount  : in KDF9.word;
    31.                                    the_quantum : in String);
    32.
    33.    -- Change the file associated with a device.
    34.    procedure reattach (the_buffer : in out slow.device;
    35.                        the_file   : in String);
    36.
    37. private
    38.
    39.    type device is abstract new IOC.device with
    40.       record
    41.          is_transcribing : Boolean := True;
    42.          byte_count      : KDF9.word := 0;
    43.       end record;
    44.
    45.    -- Optionally log an activity message for the device; close its I/O stream.
    46.    procedure close (the_buffer  : in out slow.device;
    47.                     the_action  : in String;
    48.                     the_amount  : in KDF9.word;
    49.                     the_quantum : in String);
    50.
    51.    -- The number of timed transfer units in the designated core-store area.
    52.    -- In the case of unit-record devices, such as card readers and line printers,
    53.    --    this is the number of unit records (cards, or lines, respectively).
    54.    -- In all other cases it is the number of characters in the designated core-store area.
    55.    function atomic_item_count (the_buffer : slow.device;
    56.                                Q_operand  : KDF9.Q_register)
    57.    return KDF9.word;
    58.
    59.    -- Check the IO parameters and the buffer state, and handle any old lockout.
    60.    -- Set the new buffer state, and project the next interrupt time.
    61.    procedure start_slow_transfer (the_buffer   : in out slow.device;
    62.                                   Q_operand    : in KDF9.Q_register;
    63.                                   set_offline  : in Boolean;
    64.                                   operation    : in IOC.transfer_kind := some_other_operation);
    65.
    66.    -- Read a character from the stream and deal with any input file concatenation.
    67.    procedure get_char_from_stream (char       : out Character;
    68.                                    the_buffer : in out slow.device);
    69.
    70.    -- Read a raw byte from the stream and deal with any input file concatenation.
    71.    procedure get_byte_from_stream (byte       : out Character;
    72.                                    the_buffer : in out slow.device);
    73.
    74. end IOC.slow;

 176 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-slow-shift.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:21

     1. -- ioc-slow-shift.adb
     2. --
     3. -- Emulation of the common functionality of a 2-case (Normal/Shift) buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package body IOC.slow.shift is
    20.
    21.    use KDF9_char_sets;
    22.
    23.    overriding
    24.    procedure Initialize (the_device : in out shift.device) is
    25.    begin
    26.       -- Open the associated file.
    27.       open(the_device, read_mode);
    28.    end Initialize;
    29.
    30.    procedure do_input_housekeeping (the_device : in out shift.device;
    31.                                     read_in,
    32.                                     stored     : in KDF9.word) is
    33.    begin
    34.       add_in_the_IO_CPU_time(the_device, stored);
    35.       correct_transfer_time(the_device, read_in);
    36.       the_device.byte_count := the_device.byte_count + read_in;
    37.    end do_input_housekeeping;
    38.
    39.    procedure get_symbols (the_device    : in out shift.device;
    40.                           Q_operand     : in KDF9.Q_register;
    41.                           reading_to_EM : in Boolean) is
    42.       start_address : constant KDF9.address := Q_operand.I;
    43.       end_address   : constant KDF9.address := Q_operand.M;
    44.       fill   : KDF9.word := 0;
    45.       size   : KDF9.word := 0;
    46.       symbol : KDF9_char_sets.symbol;
    47.       char   : Character;
    48.    begin
    49.       check_addresses_and_lockouts(start_address, end_address);
    50.    word_loop:
    51.       for w in start_address .. end_address loop
    52.          store_word(0, w);
    53.          for c in KDF9_char_sets.symbol_index'Range loop
    54.             get_char_from_stream(char, the_device);
    55.             size := size + 1;
    56.             if char = KDF9_char_sets.W_F then
    57.                -- Filler was suppressed on normal input from the slow devices.
    58.                fill := fill + 1;
    59.             elsif case_of(char) /= both                   and then
    60.                      case_of(char) /= the_device.current_case then
    61.                store_symbol(CN_TR(next_case(the_device.current_case)), w, c);
    62.                the_device.current_case := the_device.current_case xor 1;
    63.                back_off(the_device.stream);
    64.             else
    65.                symbol := CN_TR(char) or CS_TR(char);
    66.                store_symbol(symbol, w, c);
    67.                if reading_to_EM and symbol = KDF9_char_sets.End_Message then
    68.                   for d in 1 .. 7-c loop
    69.                      store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
    70.                   end loop;
    71.                   exit word_loop;
    72.                end if;
    73.             end if;
    74.          end loop;
    75.       end loop word_loop;
    76.       do_input_housekeeping(the_device, read_in => size, stored => size-fill);
    77.    exception
    78.       when end_of_stream =>
    79.          flush(the_device.stream);
    80.          do_input_housekeeping(the_device, read_in => size, stored => size-fill);
    81.    end get_symbols;
    82.
    83.    procedure read (the_device : in out shift.device;
    84.                    Q_operand  : in KDF9.Q_register) is
    85.    begin
    86.       get_symbols(the_device, Q_operand, reading_to_EM => False);
    87.    end read;
    88.
    89.    procedure read_to_EM (the_device : in out shift.device;
    90.                          Q_operand  : in KDF9.Q_register) is
    91.    begin
    92.       get_symbols(the_device, Q_operand, reading_to_EM => True);
    93.    end read_to_EM;
    94.
    95.    procedure get_words (the_device    : in out shift.device;
    96.                         Q_operand     : in KDF9.Q_register;
    97.                         reading_to_EM : in Boolean) is
    98.       start_address : constant KDF9.address := Q_operand.I;
    99.       end_address   : constant KDF9.address := Q_operand.M;
   100.       size : KDF9.word := 0;
   101.       word : KDF9.word;
   102.       char : Character;
   103.    begin
   104.       check_addresses_and_lockouts(start_address, end_address);
   105.       for w in start_address .. end_address loop
   106.          get_char_from_stream(char, the_device);
   107.          word := KDF9.word(Character'Pos(char));
   108.          size := size + 1;
   109.          store_word(word, w);
   110.       exit when reading_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   111.       end loop;
   112.       do_input_housekeeping(the_device, read_in => size, stored => size);
   113.    exception
   114.       when end_of_stream =>
   115.          flush(the_device.stream);
   116.          do_input_housekeeping(the_device, read_in => size, stored => size);
   117.    end get_words;
   118.
   119.    procedure words_read (the_device : in out shift.device;
   120.                          Q_operand  : in KDF9.Q_register) is
   121.    begin
   122.       get_words(the_device, Q_operand, reading_to_EM => False);
   123.    end words_read;
   124.
   125.    procedure words_read_to_EM (the_device : in out shift.device;
   126.                                Q_operand  : in KDF9.Q_register) is
   127.    begin
   128.       get_words(the_device, Q_operand, reading_to_EM => True);
   129.    end words_read_to_EM;
   130.
   131.    procedure put_symbols (the_device    : in out shift.device;
   132.                           Q_operand     : in KDF9.Q_register;
   133.                           writing_to_EM : in Boolean) is
   134.       start_address : constant KDF9.address := Q_operand.I;
   135.       end_address   : constant KDF9.address := Q_operand.M;
   136.       fill   : KDF9.word := 0;
   137.       size   : KDF9.word := 0;
   138.       symbol : KDF9_char_sets.symbol;
   139.       char   : Character;
   140.    begin
   141.       check_addresses_and_lockouts(start_address, end_address);
   142.    word_loop:
   143.       for w in start_address .. end_address loop
   144.          for c in KDF9_char_sets.symbol_index'Range loop
   145.             symbol := fetch_symbol(w, c);
   146.             size := size + 1;
   147.             if symbol = KDF9_char_sets.Word_Filler then
   148.                -- Filler was suppressed on normal output to the slow devices.
   149.                fill := fill + 1;
   150.             elsif symbol = KDF9_char_sets.Case_Shift then
   151.                the_device.current_case := KDF9_char_sets.Case_Shift;
   152.             elsif  symbol = KDF9_char_sets.Case_Normal then
   153.                the_device.current_case := KDF9_char_sets.Case_Normal;
   154.             else
   155.                if the_device.current_case = KDF9_char_sets.Case_Normal then
   156.                   char := TP_CN(symbol);
   157.                else
   158.                   char := TP_CS(symbol);
   159.                end if;
   160.                put_char(char, the_device.stream);
   161.                exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
   162.             end if;
   163.          end loop;
   164.       end loop word_loop;
   165.       do_output_housekeeping(the_device, written => size-fill, fetched => size);
   166.    exception
   167.       when end_of_stream =>
   168.          do_output_housekeeping(the_device, written => size-fill, fetched => size);
   169.    end put_symbols;
   170.
   171.    procedure write (the_device : in out shift.device;
   172.                     Q_operand  : in KDF9.Q_register) is
   173.    begin
   174.       put_symbols(the_device, Q_operand, writing_to_EM => False);
   175.    end write;
   176.
   177.    procedure write_to_EM (the_device : in out shift.device;
   178.                           Q_operand  : in KDF9.Q_register) is
   179.    begin
   180.       put_symbols(the_device, Q_operand, writing_to_EM => True);
   181.    end write_to_EM;
   182.
   183.    procedure put_words (the_device    : in out shift.device;
   184.                         Q_operand     : in KDF9.Q_register;
   185.                         writing_to_EM : in Boolean) is
   186.       start_address : constant KDF9.address := Q_operand.I;
   187.       end_address   : constant KDF9.address := Q_operand.M;
   188.       size : KDF9.word := 0;
   189.       word : KDF9.word;
   190.       char : Character;
   191.    begin
   192.       check_addresses_and_lockouts(start_address, end_address);
   193.       for w in start_address .. end_address loop
   194.          word := fetch_word(w) and 8#377#;
   195.          char := Character'Val(word);
   196.          put_byte(char, the_device.stream);
   197.          size := size + 1;
   198.       exit when writing_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   199.       end loop;
   200.       do_output_housekeeping(the_device, written => size, fetched => size);
   201.    exception
   202.       when end_of_stream =>
   203.          do_output_housekeeping(the_device, written => size, fetched => size);
   204.    end put_words;
   205.
   206.    procedure words_write (the_device : in out shift.device;
   207.                           Q_operand  : in KDF9.Q_register) is
   208.    begin
   209.       put_words(the_device, Q_operand, writing_to_EM => False);
   210.    end words_write;
   211.
   212.    procedure words_write_to_EM (the_device : in out shift.device;
   213.                                 Q_operand  : in KDF9.Q_register) is
   214.    begin
   215.       put_words(the_device, Q_operand, writing_to_EM => True);
   216.    end words_write_to_EM;
   217.
   218.    procedure output_a_gap (the_device   : in out shift.device;
   219.                            Q_operand    : in KDF9.Q_register;
   220.                            set_offline  : in Boolean;
   221.                            word_mode    : in Boolean := False;
   222.                            text_mode    : in Boolean := False) is
   223.       length : constant KDF9.word :=  KDF9.word(Q_operand.M) * (if word_mode then 8 else 1);
   224.       char   : constant Character := Character'Val(0);
   225.       size   : KDF9.word := 0;
   226.    begin
   227.       require_positive_count(Q_operand.M);
   228.       for i in 1 .. length loop
   229.          size := size + 1;
   230.          if text_mode then
   231.             do_not_put_byte(char, the_device.stream);
   232.          else
   233.             put_byte(char, the_device.stream);
   234.          end if;
   235.       end loop;
   236.       start_data_transfer(
   237.                           the_device,
   238.                           (Q_operand.C, 0, Q_operand.M),
   239.                           set_offline,
   240.                           busy_time => IO_elapsed_time(the_device, length)
   241.                          );
   242.       do_output_housekeeping(the_device, written => length, fetched => 0);
   243.    exception
   244.       when end_of_stream =>
   245.          do_output_housekeeping(the_device, written => size, fetched => 0);
   246.    end output_a_gap;
   247.
   248.    procedure do_output_housekeeping (the_device : in out shift.device;
   249.                                      written,
   250.                                      fetched    : in KDF9.word) is
   251.    begin
   252.       flush(the_device.stream);
   253.       add_in_the_IO_CPU_time(the_device, fetched);
   254.       correct_transfer_time(the_device, written);
   255.       the_device.byte_count := the_device.byte_count + fetched;
   256.    end do_output_housekeeping;
   257.
   258.    procedure set_case (the_device  : in out shift.device;
   259.                        the_setting : in KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal) is
   260.    begin
   261.       the_device.current_case := the_setting;
   262.    end set_case;
   263.
   264.    function uses_Latin_1 (the_device : in shift.device)
   265.    return Boolean
   266.    is (the_device.is_transcribing);
   267.
   268.    overriding
   269.    procedure Finalize (the_device : in out shift.device) is
   270.    begin
   271.       close(the_device, "transferred", the_device.byte_count, "character(s)");
   272.    end Finalize;
   273.
   274. end IOC.slow.shift;

Compiling: ../Source/ioc-slow-shift.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:21

     1. -- ioc-slow-shift.ads
     2. --
     3. -- Emulation of the common functionality of a 2-case (Normal/Shift) buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with KDF9_char_sets;
    20.
    21. package IOC.slow.shift is
    22.
    23.    --
    24.    -- Abstract common functionality of Case Normal / Case Shift devices, e.g.,
    25.    --    the paper tape reader (TR), punch (TP) and console Flexowriter (FW).
    26.    --
    27.
    28.    type device is abstract new IOC.slow.device with private;
    29.
    30.    procedure set_case (the_device  : in out shift.device;
    31.                        the_setting : in KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal);
    32.
    33.    function uses_Latin_1 (the_device : in shift.device)
    34.    return Boolean;
    35.
    36. private
    37.
    38.    type device is abstract new IOC.slow.device with
    39.       record
    40.          current_case : KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal;
    41.       end record;
    42.
    43.    overriding
    44.    procedure Finalize (the_device : in out shift.device);
    45.
    46.    overriding
    47.    procedure Initialize (the_device : in out shift.device);
    48.
    49.    procedure do_input_housekeeping (the_device : in out shift.device;
    50.                                     read_in,
    51.                                     stored     : in KDF9.word);
    52.
    53.    procedure do_output_housekeeping (the_device : in out shift.device;
    54.                                      written,
    55.                                      fetched    : in KDF9.word);
    56.
    57.     procedure write (the_device : in out shift.device;
    58.                      Q_operand  : in KDF9.Q_register);
    59.
    60.     procedure read (the_device : in out shift.device;
    61.                     Q_operand  : in KDF9.Q_register);
    62.
    63.     procedure write_to_EM (the_device : in out shift.device;
    64.                            Q_operand  : in KDF9.Q_register);
    65.
    66.     procedure read_to_EM (the_device : in out shift.device;
    67.                           Q_operand  : in KDF9.Q_register);
    68.
    69.     procedure words_write (the_device : in out shift.device;
    70.                            Q_operand  : in KDF9.Q_register);
    71.
    72.     procedure words_read (the_device : in out shift.device;
    73.                           Q_operand  : in KDF9.Q_register);
    74.
    75.     procedure words_write_to_EM (the_device : in out shift.device;
    76.                                  Q_operand  : in KDF9.Q_register);
    77.
    78.     procedure words_read_to_EM (the_device : in out shift.device;
    79.                                 Q_operand  : in KDF9.Q_register);
    80.
    81.    procedure output_a_gap (the_device   : in out shift.device;
    82.                            Q_operand    : in KDF9.Q_register;
    83.                            set_offline  : in Boolean;
    84.                            word_mode    : in Boolean := False;
    85.                            text_mode    : in Boolean := False);
    86.
    87. end IOC.slow.shift;

 274 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-slow-shift-tp.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:21

     1. -- ioc-slow-shift-tp.ads
     2. --
     3. -- Emulation of a tape punch buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with IOC.equipment;
    20. with tracing;
    21.
    22. use  IOC.equipment;
    23. use  tracing;
    24.
    25. package body IOC.slow.shift.TP is
    26.
    27.    use KDF9_char_sets;
    28.
    29.    overriding
    30.    procedure Initialize (the_TP : in out TP.device) is
    31.    begin
    32.       open(the_TP, write_mode);
    33.    end Initialize;
    34.
    35.    -- the_T_bit_is_set := (the buffer has been switched from a tape punch to a graph plotter)
    36.    overriding
    37.    procedure PMB (the_TP      : in out TP.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean) is
    40.    begin
    41.       validate_device(the_TP, Q_operand);
    42.       validate_parity(the_TP);
    43.       deal_with_a_busy_device(the_TP, 13, set_offline);
    44.       the_T_bit_is_set := False;  -- We never get here if GP0 is enabled.
    45.       take_note_of_test(the_TP.device_name, Q_operand, the_T_bit_is_set);
    46.    end PMB;
    47.
    48. --
    49. --
    50.    --
    51.    -- See Manual, §17.4 for paper tape 8-bit frame format.
    52.    --
    53. --
    54. --
    55.
    56.    procedure write_KDF9_tape_code (the_TP        : in out TP.device;
    57.                                    Q_operand     : in KDF9.Q_register;
    58.                                    writing_to_EM : in Boolean := False) is
    59.
    60.       function framed (symbol : KDF9_char_sets.symbol)
    61.       return Natural is
    62.
    63.          SP : constant := 8#000#;
    64.
    65.          function channel_8
    66.          return KDF9.syllable
    67.          is (if symbol = SP then 2#10_000_000# else 0);
    68.
    69.          function parity
    70.          return KDF9.syllable is
    71.             frame  : KDF9.syllable := KDF9.syllable(KDF9_char_sets.symbol'Pos(symbol)) or channel_8;
    72.             parity : KDF9.syllable := 0;
    73.          begin -- parity
    74.             while frame /= 0 loop
    75.                parity := parity xor (frame and 1);
    76.                frame  := frame / 2;
    77.             end loop;
    78.             return (if parity = 0 then 0 else 2#00_010_000#);
    79.          end parity;
    80.
    81.          low_4_bits : constant KDF9.syllable := KDF9.syllable(symbol)   and 2#00_001_111#;
    82.          bits_5and6 : constant KDF9.syllable := KDF9.syllable(symbol)*2 and 2#01_100_000#;
    83.
    84.       begin -- framed
    85.          return KDF9.syllable'Pos(channel_8 or bits_5and6 or parity or low_4_bits);
    86.       end framed;
    87.
    88.       start_address : constant KDF9.address := Q_operand.I;
    89.       end_address   : constant KDF9.address := Q_operand.M;
    90.       size   : KDF9.word := 0;
    91.       symbol : KDF9_char_sets.symbol;
    92.       char   : Character;
    93.
    94.    begin -- write_KDF9_tape_code
    95.       check_addresses_and_lockouts(start_address, end_address);
    96.    word_loop:
    97.       for w in start_address .. end_address loop
    98.          for c in KDF9_char_sets.symbol_index'Range loop
    99.             symbol := fetch_symbol(w, c);
   100.             size := size + 1;
   101.             char := Character'Val(framed(symbol));
   102.             put_byte(char, the_TP.stream);
   103.          exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
   104.          end loop;
   105.       end loop word_loop;
   106.       do_output_housekeeping(the_TP, written => size, fetched => size);
   107.    exception
   108.       when end_of_stream =>
   109.          do_output_housekeeping(the_TP, written => size, fetched => size);
   110.    end write_KDF9_tape_code;
   111.
   112.    -- PWQq
   113.    overriding
   114.    procedure POA (the_TP      : in out TP.device;
   115.                   Q_operand   : in KDF9.Q_register;
   116.                   set_offline : in Boolean) is
   117.    begin
   118.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   119.       if the_TP.is_transcribing then
   120.          write(the_TP, Q_operand);
   121.       else
   122.          write_KDF9_tape_code(the_TP, Q_operand);
   123.       end if;
   124.       lock_out_relative_addresses(Q_operand);
   125.    end POA;
   126.
   127.    -- PWEQq
   128.    overriding
   129.    procedure POB (the_TP      : in out TP.device;
   130.                   Q_operand   : in KDF9.Q_register;
   131.                   set_offline : in Boolean) is
   132.    begin
   133.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   134.       if the_TP.is_transcribing then
   135.          write_to_EM(the_TP, Q_operand);
   136.       else
   137.          write_KDF9_tape_code(the_TP, Q_operand, writing_to_EM => True);
   138.       end if;
   139.       lock_out_relative_addresses(Q_operand);
   140.    end POB;
   141.
   142.    -- PWCQq
   143.    overriding
   144.    procedure POC (the_TP      : in out TP.device;
   145.                   Q_operand   : in KDF9.Q_register;
   146.                   set_offline : in Boolean) is
   147.    begin
   148.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   149.       words_write(the_TP, Q_operand);
   150.       lock_out_relative_addresses(Q_operand);
   151.    end POC;
   152.
   153.    -- PWCEQq
   154.    overriding
   155.    procedure POD (the_TP      : in out TP.device;
   156.                   Q_operand   : in KDF9.Q_register;
   157.                   set_offline : in Boolean) is
   158.    begin
   159.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   160.       words_write_to_EM(the_TP, Q_operand);
   161.       lock_out_relative_addresses(Q_operand);
   162.    end POD;
   163.
   164.    -- PGAPQq
   165.    overriding
   166.    procedure POE (the_TP      : in out TP.device;
   167.                   Q_operand   : in KDF9.Q_register;
   168.                   set_offline : in Boolean) is
   169.    begin
   170.       require_nonnegative_count(Q_operand.M);
   171.       output_a_gap(
   172.                    the_TP,
   173.                    Q_operand,
   174.                    set_offline,
   175.                    word_mode => False,
   176.                    text_mode => the_TP.is_transcribing
   177.                   );
   178.    end POE;
   179.
   180.    -- "word gap"
   181.    overriding
   182.    procedure POF (the_TP      : in out TP.device;
   183.                   Q_operand   : in KDF9.Q_register;
   184.                   set_offline : in Boolean) is
   185.    begin
   186.       require_nonnegative_count(Q_operand.M);
   187.       output_a_gap(
   188.                    the_TP,
   189.                    Q_operand,
   190.                    set_offline,
   191.                    word_mode => True,
   192.                    text_mode => the_TP.is_transcribing
   193.                   );
   194.    end POF;
   195.
   196.    overriding
   197.    procedure Finalize (the_TP : in out TP.device) is
   198.    begin
   199.       close(
   200.             the_TP,
   201.             "punched",
   202.             the_TP.byte_count,
   203.             "character" & plurality(the_TP.byte_count)
   204.           & " in "
   205.           & (if the_TP.is_transcribing then "Latin-1" else "KDF9")
   206.           & " code"
   207.            );
   208.    end Finalize;
   209.
   210.    TP_quantum : constant := 1E6 / 110;  -- 110 characters per second.
   211.
   212.    type TP_access is access TP.device;
   213.
   214.    TP0  : TP_access with Warnings => Off;
   215.    TP1  : TP_access with Warnings => Off;
   216.
   217.    unit : IOC.unit_number := 0;
   218.
   219.    procedure enable (b : in KDF9.buffer_number) is
   220.    begin
   221.       case unit is
   222.          when 0 =>
   223.             TP0 := new TP.device (number  => b,
   224.                                   kind    => TP_kind,
   225.                                   unit    => 0,
   226.                                   quantum => TP_quantum);
   227.             TP0_number := b;
   228.          when 1 =>
   229.             TP1 := new TP.device (number  => b,
   230.                                   kind    => TP_kind,
   231.                                   unit    => 1,
   232.                                   quantum => TP_quantum);
   233.             TP1_number := b;
   234.             GP0_number := b;
   235.          when others =>
   236.             trap_operator_error("TP:", "more than two units specified");
   237.       end case;
   238.       unit := unit + 1;
   239.    end enable;
   240.
   241.    procedure disable_TP1 (b : out KDF9.buffer_number) is
   242.    begin
   243.       if TP1 /= null then
   244.          Finalize(TP1.all);
   245.       end if;
   246.       b := GP0_number;
   247.    end disable_TP1;
   248.
   249.    -- Set the character code to be used by the designated TP.
   250.    procedure set_unit_code (unit : in Natural; is_transcribing : in Boolean) is
   251.    begin
   252.       if set_unit_code.unit < Natural(IOC.slow.shift.TP.unit) then
   253.          if unit = 0 then
   254.             TP0.is_transcribing := set_unit_code.is_transcribing;
   255.          else
   256.             TP1.is_transcribing := set_unit_code.is_transcribing;
   257.          end if;
   258.       end if;
   259.    end set_unit_code;
   260.
   261. end IOC.slow.shift.TP;

Compiling: ../Source/ioc-slow-shift-tp.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:21

     1. -- ioc-slow-shift-tp.ads
     2. --
     3. -- Emulation of a tape punch buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.slow.shift.TP is
    20.
    21.    type device is new IOC.slow.shift.device with private;
    22.
    23.    -- PWQq
    24.    overriding
    25.    procedure POA (the_TP      : in out TP.device;
    26.                   Q_operand   : in KDF9.Q_register;
    27.                   set_offline : in Boolean);
    28.
    29.    -- PWEQq
    30.    overriding
    31.    procedure POB (the_TP      : in out TP.device;
    32.                   Q_operand   : in KDF9.Q_register;
    33.                   set_offline : in Boolean);
    34.
    35.    -- PWCQq
    36.    overriding
    37.    procedure POC (the_TP      : in out TP.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    -- PWCEQq
    42.    overriding
    43.    procedure POD (the_TP      : in out TP.device;
    44.                   Q_operand   : in KDF9.Q_register;
    45.                   set_offline : in Boolean);
    46.
    47.    -- PGAPQq
    48.    overriding
    49.    procedure POE (the_TP      : in out TP.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    -- This is called "word gap" in the Manual, but never defined.
    54.    -- Assume this acts exactly like POE. ??
    55.    overriding
    56.    procedure POF (the_TP      : in out TP.device;
    57.                   Q_operand   : in KDF9.Q_register;
    58.                   set_offline : in Boolean);
    59.
    60.    -- the_T_bit_is_set (the buffer has been switched from a tape punch to a graph plotter)
    61.    overriding
    62.    procedure PMB (the_TP      : in out TP.device;
    63.                   Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean);
    65.
    66.    procedure enable (b : in KDF9.buffer_number);
    67.
    68.    -- Finalize TP1 if necessary and yield its buffer number for use by GP0.
    69.    procedure disable_TP1 (b : out KDF9.buffer_number);
    70.
    71.    -- Set the character code to be used by the TP unit.
    72.    procedure set_unit_code(unit : in Natural; is_transcribing : in Boolean);
    73.
    74. private
    75.
    76.    type device is new IOC.slow.shift.device with null record;
    77.
    78.    overriding
    79.    procedure Initialize (the_TP : in out TP.device);
    80.
    81.    overriding
    82.    procedure Finalize (the_TP : in out TP.device);
    83.
    84. end IOC.slow.shift.TP;

 261 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-slow-shift-tr.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:21

     1. -- ioc-slow-shift-tr.adb
     2. --
     3. -- Emulation of a paper tape reader buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Exceptions;
    20. --
    21. with IOC.equipment;
    22. with KDF9.Directors;
    23. with KDF9.TOD_clock;
    24. with KDF9_char_sets;
    25. with tracing;
    26.
    27. use  IOC.equipment;
    28. use  KDF9.TOD_clock;
    29. use  KDF9_char_sets;
    30. use  tracing;
    31.
    32. package body IOC.slow.shift.TR is
    33.
    34.    use KDF9_char_sets;
    35.
    36.    overriding
    37.    procedure Initialize (the_TR : in out TR.device) is
    38.    begin
    39.       -- Open the associated file.
    40.       open(IOC.device(the_TR), read_mode);
    41.    end Initialize;
    42.
    43.    --
    44.    -- See Manual, §17.4 for paper tape 8-bit frame format.
    45.    --
    46.
    47.    function has_even_parity (octet : KDF9.syllable)
    48.    return Boolean is
    49.       frame  : KDF9.syllable := octet;
    50.       parity : KDF9.syllable := 0;
    51.    begin
    52.       while frame /= 0 loop
    53.          parity := parity xor (frame and 1);
    54.          frame  := frame / 2;
    55.       end loop;
    56.       return parity = 0;
    57.    end has_even_parity;
    58.
    59.    function symbol_from (octet : KDF9.syllable)
    60.    return KDF9_char_sets.symbol
    61.    is (KDF9_char_sets.symbol((octet and 2#01_100_000#)/2 or (octet and 2#00_001_111#)));
    62.
    63.    DEL_frame : constant := 8#377#;
    64.    NUL_frame : constant := 8#000#;
    65.
    66.    -- Read 8-bit paper tape frames, compress to 6-bit byteacters, and pack into words.
    67.    procedure read_KDF9_tape_code (the_TR        : in out TR.device;
    68.                                   Q_operand     : in KDF9.Q_register;
    69.                                   reading_to_EM,
    70.                                   loading_code  : in Boolean := False) is
    71.       c      : KDF9_char_sets.symbol_index := 0;
    72.       w      : KDF9.Q_part := Q_operand.I;
    73.       size   : KDF9.word := 0;
    74.       octet  : KDF9.syllable;
    75.       symbol : KDF9_char_sets.symbol;
    76.       byte   : Character;
    77.    begin
    78.       check_addresses_and_lockouts(Q_operand.I, Q_operand.M);
    79.    word_loop:
    80.       loop
    81.          loop
    82.             get_byte_from_stream(byte, the_TR);
    83.             octet := KDF9.syllable(Character'Pos(byte));
    84.          exit when octet not in NUL_frame | DEL_frame;
    85.          end loop;
    86.          if has_even_parity(octet) then
    87.             symbol := symbol_from(octet);
    88.          else
    89.             trap_invalid_paper_tape("probably not in KDF9 code (parity error detected)");
    90.          end if;
    91.          store_symbol(symbol, w, c);
    92.          size := size + 1;
    93.          c := c + 1;
    94.          if c = 0 then
    95.       exit word_loop when reading_to_EM and symbol = KDF9_char_sets.End_Message;
    96.             w := w + 1;
    97.       exit word_loop when w > Q_operand.M;
    98.          end if;
    99.          if reading_to_EM and then symbol = KDF9_char_sets.End_Message then
   100.             for d in c .. 7 loop
   101.                store_symbol(KDF9_char_sets.Blank_Space, w, d);
   102.             end loop;
   103.       exit word_loop;
   104.          end if;
   105.       exit word_loop when w > Q_operand.M;
   106.       end loop word_loop;
   107.       if not loading_code then
   108.          do_input_housekeeping(the_TR, read_in => size, stored => size);
   109.       end if;
   110.    exception
   111.       when end_of_stream =>
   112.          if size = 0 then
   113.             trap_invalid_paper_tape("there was no data on the tape");
   114.          end if;
   115.          if not loading_code then
   116.             do_input_housekeeping(the_TR, read_in => size, stored => size);
   117.          end if;
   118.          the_TR.is_abnormal := True;
   119.          if not reading_to_EM and c /= 0 then
   120.             trap_invalid_paper_tape("the last word on the tape was incomplete");
   121.          end if;
   122.    end read_KDF9_tape_code;
   123.
   124.    -- PRQq
   125.    overriding
   126.    procedure PIA (the_TR      : in out TR.device;
   127.                   Q_operand   : in KDF9.Q_register;
   128.                   set_offline : in Boolean) is
   129.    begin
   130.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   131.       if the_TR.is_transcribing then
   132.          read(the_TR, Q_operand);
   133.       else
   134.          read_KDF9_tape_code(the_TR, Q_operand);
   135.       end if;
   136.       lock_out_relative_addresses(Q_operand);
   137.    end PIA;
   138.
   139.    -- PREQq
   140.    overriding
   141.    procedure PIB (the_TR      : in out TR.device;
   142.                   Q_operand   : in KDF9.Q_register;
   143.                   set_offline : in Boolean) is
   144.    begin
   145.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   146.       if the_TR.is_transcribing then
   147.          read_to_EM(the_TR, Q_operand);
   148.       else
   149.          read_KDF9_tape_code(the_TR, Q_operand, reading_to_EM => True);
   150.       end if;
   151.       lock_out_relative_addresses(Q_operand);
   152.    end PIB;
   153.
   154.    -- PRCQq
   155.    overriding
   156.    procedure PIC (the_TR      : in out TR.device;
   157.                   Q_operand   : in KDF9.Q_register;
   158.                   set_offline : in Boolean) is
   159.    begin
   160.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   161.       words_read(the_TR, Q_operand);
   162.       lock_out_relative_addresses(Q_operand);
   163.    end PIC;
   164.
   165.    -- PRCEQq
   166.    overriding
   167.    procedure PID (the_TR      : in out TR.device;
   168.                   Q_operand   : in KDF9.Q_register;
   169.                   set_offline : in Boolean) is
   170.    begin
   171.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   172.       words_read_to_EM(the_TR, Q_operand);
   173.       lock_out_relative_addresses(Q_operand);
   174.    end PID;
   175.
   176.    -- as PIA
   177.    overriding
   178.    procedure PIE (the_TR      : in out TR.device;
   179.                   Q_operand   : in KDF9.Q_register;
   180.                   set_offline : in Boolean) is
   181.    begin
   182.       PIA(the_TR, Q_operand, set_offline);
   183.    end PIE;
   184.
   185.    -- as PIB
   186.    overriding
   187.    procedure PIF (the_TR      : in out TR.device;
   188.                   Q_operand   : in KDF9.Q_register;
   189.                   set_offline : in Boolean) is
   190.    begin
   191.       PIB(the_TR, Q_operand, set_offline);
   192.    end PIF;
   193.
   194.    -- as PIC
   195.    overriding
   196.    procedure PIG (the_TR      : in out TR.device;
   197.                   Q_operand   : in KDF9.Q_register;
   198.                   set_offline : in Boolean) is
   199.    begin
   200.       PIC(the_TR, Q_operand, set_offline);
   201.    end PIG;
   202.
   203.    -- as PID
   204.    overriding
   205.    procedure PIH (the_TR      : in out TR.device;
   206.                   Q_operand   : in KDF9.Q_register;
   207.                   set_offline : in Boolean) is
   208.    begin
   209.       PID(the_TR, Q_operand, set_offline);
   210.    end PIH;
   211.
   212.    -- the_T_bit_is_set := (the reader is set to 8-track mode);
   213.    --    it is always in 8-track mode, as 5-track input is not supported by ee9.
   214.    overriding
   215.    procedure PMB (the_TR      : in out TR.device;
   216.                   Q_operand   : in KDF9.Q_register;
   217.                   set_offline : in Boolean) is
   218.    begin
   219.       validate_device(the_TR, Q_operand);
   220.       validate_parity(the_TR);
   221.       deal_with_a_busy_device(the_TR, 13, set_offline);
   222.       the_T_bit_is_set := True;
   223.       take_note_of_test(the_TR.device_name, Q_operand, the_T_bit_is_set);
   224.    end PMB;
   225.
   226.
   227.
   228.    overriding
   229.    procedure Finalize (the_TR : in out TR.device) is
   230.    begin
   231.       close(
   232.             the_TR,
   233.             "read",
   234.             the_TR.byte_count,
   235.             "character" & plurality(the_TR.byte_count)
   236.           & " in "
   237.           & (if the_TR.is_transcribing then "Latin-1" else "KDF9")
   238.           & " code"
   239.            );
   240.    end Finalize;
   241.
   242.    type TR_access is access TR.device;
   243.
   244.    TR0  : TR_access with Warnings => Off;
   245.    TR1  : TR_access with Warnings => Off;
   246.
   247.    TR_quantum : constant := 1E6 / 1_000;  -- 1000 characters per second.
   248.
   249.    unit : IOC.unit_number := 0;
   250.
   251.    procedure enable (b : in KDF9.buffer_number) is
   252.    begin
   253.       case unit is
   254.          when 0 =>
   255.             TR0 := new TR.device (number  => b,
   256.                                   kind    => TR_kind,
   257.                                   unit    => 0,
   258.                                   quantum => TR_quantum);
   259.             TR0_number := b;
   260.          when 1 =>
   261.             TR1 := new TR.device (number  => b,
   262.                                   kind    => TR_kind,
   263.                                   unit    => 1,
   264.                                   quantum => TR_quantum);
   265.             TR1_number := b;
   266.          when others =>
   267.             trap_operator_error("TR:", "more than two units specified");
   268.       end case;
   269.       unit := unit + 1;
   270.    end enable;
   271.
   272.    -- Set the character code to be used by the designated TR.
   273.    procedure set_unit_code (unit : in Natural; is_transcribing : in Boolean) is
   274.    begin
   275.       if unit = 0 then
   276.          TR0.is_transcribing := set_unit_code.is_transcribing;
   277.       else
   278.          TR1.is_transcribing := set_unit_code.is_transcribing;
   279.       end if;
   280.    end set_unit_code;
   281.
   282.    --
   283.    -- Support for loading programs and for bootstrapping the KDF9.
   284.    --
   285.
   286.    procedure reattach (unit : in Natural; next_file_name : in String) is
   287.       the_reader  : constant TR_access := (if unit = 0 then TR0 else TR1);
   288.    begin
   289.       reattach(the_reader.all, next_file_name);
   290.       if the_reader.is_open then
   291.          the_reader.current_case := KDF9_char_sets.Case_Normal;
   292.       else
   293.          trap_operator_error("'" & next_file_name & "'",  "cannot be found");
   294.       end if;
   295.    end reattach;
   296.
   297.    procedure reset_loader_usage (unit : in Natural) is
   298.       the_reader  : constant TR_access := (if unit = 0 then TR0 else TR1);
   299.    begin
   300.       correct_transfer_time(the_reader.all, KDF9.us(0));
   301.       the_reader.byte_count := 0;
   302.       unlock_absolute_addresses((0, 0, 32767));
   303.    end reset_loader_usage;
   304.
   305.    -- This emulates the Director's program load from a designated  paper tape reader.
   306.    -- Once the loading is done, the tape reader is reattached to TR<unit>.
   307.
   308.    procedure load_a_program  (program_file_name : in String) is
   309.
   310.       -- This is the call sign for a program on Disc or Drum.
   311.       CN_LS_D_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   312.                                       or (KDF9.word(Line_Shift)   * 2**12)
   313.                                       or (KDF9.word(Upper_Case_D) * 2** 6)
   314.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   315.
   316.       -- This is the call sign for a program on Magnetic Tape.
   317.       CN_LS_M_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   318.                                       or (KDF9.word(Line_Shift)   * 2**12)
   319.                                       or (KDF9.word(Upper_Case_M) * 2** 6)
   320.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   321.
   322.       -- This is the call sign for a program on Paper Tape.
   323.       CN_LS_P_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   324.                                       or (KDF9.word(Line_Shift)   * 2**12)
   325.                                       or (KDF9.word(Upper_Case_P) * 2** 6)
   326.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   327.
   328.       threshold  : constant KDF9.word := 32767 * 2**24;
   329.       substitute : constant KDF9.word := 32736 * 2**24;
   330.       get_a_word : constant KDF9.Q_register := (TR0.number, 0, 0);
   331.
   332.       descriptor : KDF9.Q_register := (TR0.number, 1, 7);
   333.       word_count : Positive := 2;
   334.
   335.    begin -- load_a_program
   336.
   337.       loading_was_successful := False;
   338.
   339.       -- Access the program file as TR0.
   340.       reattach(0, program_file_name);
   341.
   342.       --
   343.       -- For the structure of a compiled program, see Manual §26.3.
   344.       --
   345.
   346.       -- Get the first word of the file into E0: it may start an A block or a B block.
   347.       read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True);
   348.
   349.       -- Check for an A block.  If one is found, check its validity, but otherwise ignore it.
   350.       if fetch_halfword(0, 0)/2**24 in CN_LS_D_LS | CN_LS_M_LS | CN_LS_P_LS then
   351.          -- We have an A block.
   352.          -- The next word completes the program name used by Director.  Ignore it.
   353.          read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True);
   354.
   355.       block_loop:
   356.          -- An A block is at most 8 words long but can end sooner with a word containing EM.
   357.          loop
   358.             word_count := word_count + 1;
   359.          exit block_loop when word_count > 8;
   360.             read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True, reading_to_EM => True);
   361.             for c in KDF9_char_sets.symbol_index loop
   362.          exit block_loop when fetch_symbol(0, c) = End_Message;
   363.             end loop;
   364.          end loop block_loop;
   365.
   366.          if word_count > 8 then
   367.             -- The file is not a valid program tape.
   368.             trap_invalid_paper_tape("excessively long A block");
   369.          end if;
   370.
   371.          -- Read the first word of the following B block.
   372.          read_KDF9_tape_code(TR0.all, (TR0.number, 0, 0), loading_code => True);
   373.       end if;
   374.
   375.       -- Check for an unconditional jump at the start of the B block.
   376.       if (fetch_word(0)/ 2**32 and 2#1111_0000_1111_0000#) /= 2#1000_0000_1011_0000# then
   377.          -- The file is not a valid program tape.
   378.          trap_invalid_paper_tape("no jump was found in E0H");
   379.       end if;
   380.
   381.       -- At this point, E0 contains the first word of the B block, so get the rest of it in E1-E7.
   382.       read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   383.
   384.       descriptor := as_Q(fetch_word(descriptor.M));
   385.       -- Read the non-final C blocks; the validity of the designated descriptors cannot be assumed.
   386.       while descriptor.C /= 0 loop
   387.          validate_address_range(descriptor.I, descriptor.M);
   388.          read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   389.          descriptor := as_Q(fetch_word(descriptor.M));
   390.       end loop;
   391.
   392.       -- Read the final C block.
   393.       validate_address_range(descriptor.I, descriptor.M);
   394.       read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   395.
   396.       -- Set up the rest of the stored image.
   397.
   398.       -- Preserve the initial jump in case of corruption by a buggy program.
   399.       save_the_initial_jump;
   400.
   401.       -- Set the (virtual) date in E7.
   402.       store_word(todays_date_28n_years_ago, 7);
   403.
   404.       -- Ensure valid parameters in E1 (some binaries may have invalid entries).
   405.       if fetch_halfword(1, 0) > threshold or else fetch_halfword(1, 0) = 0 then
   406.          store_halfword(substitute, 1, 0);
   407.       end if;
   408.       if fetch_halfword(1, 1) > threshold or else fetch_halfword(1, 1) = 0 then
   409.          store_halfword(substitute, 1, 1);
   410.       end if;
   411.
   412.       -- Do not set the time if we are computing a signature, so as to get a repeatable hash.
   413.       if not the_signature_is_enabled then
   414.          KDF9.Directors.set_the_time_of_loading(the_time_of_day);
   415.       end if;
   416.
   417.       loading_was_successful := True;
   418.
   419.       -- Clear up the I/O system.
   420.       reattach(0, "TR0");
   421.       clear_IOC_FIFO;
   422.       reset_loader_usage(0);
   423.    exception
   424.       when invalid_paper_tape_file
   425.          | operator_error =>
   426.          raise;
   427.       when error : others =>
   428.          raise emulation_failure with "in load_a_program: " & Ada.Exceptions.Exception_Message(error);
   429.    end load_a_program;
   430.
   431.    -- TR0 is the hardware bootstrap device for reading initial orders.
   432.    procedure boot_the_KDF9 (program_file_name : in String) is
   433.       boot_descriptor : constant KDF9.Q_register := (C => TR0.number, I => 0, M => 8);
   434.    begin
   435.       loading_was_successful := False;
   436.       reattach(0, program_file_name);
   437.
   438.       -- The bootstrap is 9 words of instruction code, which reads in the rest of its file.
   439.       -- The validity of the bootstrap descriptor is hardware defined.
   440.       read_KDF9_tape_code(TR0.all, boot_descriptor, loading_code => True);
   441.
   442.       -- Reset the I/O system for execution of the Director.
   443.       clear_IOC_FIFO;
   444.       reset_loader_usage(0);
   445.       loading_was_successful := True;
   446.    exception
   447.       when invalid_paper_tape_file =>
   448.          raise;
   449.       when error : others =>
   450.          raise emulation_failure with "in boot_the_KDF9: " & Ada.Exceptions.Exception_Message(error);
   451.    end boot_the_KDF9;
   452.
   453. end IOC.slow.shift.TR;

Compiling: ../Source/ioc-slow-shift-tr.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:21

     1. -- ioc-slow-shift-tr.ads
     2. --
     3. -- Emulation of a paper tape reader buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.slow.shift.TR is
    20.
    21.    type device is new IOC.slow.shift.device with private;
    22.
    23.    -- PRQq
    24.    overriding
    25.    procedure PIA (the_TR      : in out TR.device;
    26.                   Q_operand   : in KDF9.Q_register;
    27.                   set_offline : in Boolean);
    28.
    29.    -- PREQq
    30.    overriding
    31.    procedure PIB (the_TR      : in out TR.device;
    32.                   Q_operand   : in KDF9.Q_register;
    33.                   set_offline : in Boolean);
    34.
    35.    --PRCQq
    36.    overriding
    37.    procedure PIC (the_TR      : in out TR.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    -- PRCEQq
    42.    overriding
    43.    procedure PID (the_TR      : in out TR.device;
    44.                   Q_operand   : in KDF9.Q_register;
    45.                   set_offline : in Boolean);
    46.
    47.    -- as PIA
    48.    overriding
    49.    procedure PIE (the_TR      : in out TR.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    -- as PIB
    54.    overriding
    55.    procedure PIF (the_TR      : in out TR.device;
    56.                   Q_operand   : in KDF9.Q_register;
    57.                   set_offline : in Boolean);
    58.
    59.    -- as PIC
    60.    overriding
    61.    procedure PIG (the_TR      : in out TR.device;
    62.                   Q_operand   : in KDF9.Q_register;
    63.                   set_offline : in Boolean);
    64.
    65.    -- as PID
    66.    overriding
    67.    procedure PIH (the_TR      : in out TR.device;
    68.                   Q_operand   : in KDF9.Q_register;
    69.                   set_offline : in Boolean);
    70.
    71.    -- the_T_bit_is_set (the reader is set to 8-track mode)
    72.    overriding
    73.    procedure PMB (the_TR      : in out TR.device;
    74.                   Q_operand   : in KDF9.Q_register;
    75.                   set_offline : in Boolean);
    76.
    77.    procedure enable (b : in KDF9.buffer_number);
    78.
    79.    -- Reattach the designated TR to the specified file and set CASE NORMAL (may be irrelevant).
    80.    -- This is done after loading a binary program, to allow access any TR data file(s);
    81.    --    also to access a binary program for loading as an overlay.
    82.    procedure reattach (unit : in Natural; next_file_name : in String);
    83.
    84.    -- Read the 9-word bootstrap.
    85.    procedure boot_the_KDF9 (program_file_name : in String);
    86.
    87.    -- Read a binary program.
    88.    procedure load_a_program (program_file_name : in String);
    89.
    90.    -- Set the character code to be used by the TR unit.
    91.    procedure set_unit_code(unit : in Natural; is_transcribing : in Boolean);
    92.
    93. private
    94.
    95.    type device is new IOC.slow.shift.device with null record;
    96.
    97.    overriding
    98.    procedure Initialize (the_TR : in out TR.device);
    99.
   100.    overriding
   101.    procedure Finalize (the_TR : in out TR.device);
   102.
   103. end IOC.slow.shift.TR;

 453 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/say_goodbye.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:21

     1. -- say_goodbye.adb
     2. --
     3. -- Finalize emulation with a helpful message derived from exception information.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Command_Line;
    20. with Ada.Strings.Fixed;
    21. with finalize_ee9;
    22. with HCI;
    23. with settings;
    24.
    25. use  Ada.Command_Line;
    26. use  Ada.Strings.Fixed;
    27.
    28. use  HCI;
    29. use  settings;
    30.
    31. procedure say_goodbye (
    32.                        reason : in String;
    33.                        cause  : in String := "";
    34.                        status : in Exit_Status := Failure
    35.                       ) is
    36.    function explanation
    37.    return String is
    38.       CR   : constant Character := Character'Val(16#D#);
    39.       LF   : constant Character := Character'Val(16#A#);
    40.       L, R : Natural;
    41.    begin  -- explanation
    42.       if cause'Length < 3 then
    43.          return cause;
    44.       end if;
    45.       L := Index(cause, "%", from => cause'First) + 1;
    46.       if cause(cause'Last-1) = CR then
    47.          R := cause'Last - 2;
    48.       elsif cause(cause'Last) in LF | CR then
    49.          R := cause'Last - 1;
    50.       else
    51.          R := cause'Last;
    52.       end if;
    53.       return ": " & cause(L .. R);
    54.    end explanation;
    55.
    56. begin  -- say_goodbye
    57.    finalize_ee9(reason & explanation);
    58.    if the_log_is_wanted then
    59.       log_new_line;
    60.    end if;
    61.    Set_Exit_Status(status);
    62. end say_goodbye;

 62 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/settings.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:22

     1. -- settings.adb
     2. --
     3. -- execution mode, diagnostic mode, and other emulation-control settings
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Exceptions;
    20. with Ada.Long_Float_Text_IO;
    21. with Ada.Text_IO;
    22. --
    23. with dumping;
    24. with exceptions;
    25. with formatting;
    26. with HCI;
    27. with IOC.equipment;
    28. with KDF9.store;
    29. with postscript;
    30. with settings.IO;
    31. with tracing;
    32.
    33. use  Ada.Exceptions;
    34. use  Ada.Long_Float_Text_IO;
    35. use  Ada.Text_IO;
    36. --
    37. use  dumping;
    38. use  exceptions;
    39. use  formatting;
    40. use  HCI;
    41. use  KDF9.store;
    42. use  settings.IO;
    43. use  tracing;
    44.
    45. package body settings is
    46.
    47.    function is_invalid_miscellany_flag (option : in Character)
    48.    return Boolean is
    49.    begin
    50.       for f of miscellany_flags loop
    51.          if f = option then
    52.             return False;
    53.          end if;
    54.       end loop;
    55.       if option = '-' then  -- Ignore hyphens to make the calling scripts easier.
    56.          return False;
    57.       end if;
    58.       return True;
    59.    end is_invalid_miscellany_flag;
    60.
    61.    procedure set_this_miscellany_flag (option : in Character) is
    62.       use IOC.equipment;
    63.    begin
    64.       if is_invalid_miscellany_flag(option) then
    65.          log_line(
    66.                   "***** Error in a miscellany specification: '"
    67.                 & option
    68.                 & "'."
    69.                  );
    70.          return;
    71.       end if;
    72.       case option is
    73.          when '-'        =>
    74.             null;  -- Ignore hyphens, to make the calling scripts easier.
    75.          when '.'        =>
    76.             time_limit := 1_000_000;
    77.          when '0' .. '9' =>
    78.             time_limit := (Character'Pos(option) - Character'Pos('0') + 1) * 100_000_000;
    79.          when 'a' | 'A' =>
    80.             API_logging_is_wanted := False;
    81.          when 'b' | 'B' =>
    82.             choice(KDF9.buffer_number'(15)) := SI;
    83.          when 'd' | 'D' =>
    84.             debugging_is_enabled := True;
    85.          when 'e' | 'E' =>
    86.             the_log_is_wanted := False;
    87.          when 'f' | 'F' =>
    88.             the_final_state_is_wanted := False;
    89.          when 'g' | 'G' =>
    90.             the_graph_plotter_is_enabled := True;
    91.          when 'h' | 'H' =>
    92.             any_histogram_is_wanted := False;
    93.          when 'i' | 'I' =>
    94.             interrupt_tracing_is_wanted := False;
    95.          when 'k' | 'K' =>
    96.             choice(KDF9.buffer_number'(14)) := DR;
    97.          when 'm' | 'M' =>
    98.             the_terminal_is_ANSI_compatible := False;
    99.          when 'n' | 'N' =>
   100.             noninteractive_usage_is_enabled := True;
   101.             time_limit := offline_time_limit;
   102.           when 'o' |'O' =>
   103.             pre_overlay_state_is_enabled := True;
   104.          when 'p' |'P' =>
   105.             peripheral_tracing_is_wanted := False;
   106.          when 'q' | 'Q' =>
   107.             do_not_execute := True;
   108.          when 'r' | 'R' =>
   109.             retrospective_tracing_is_wanted := False;
   110.          when 's' | 'S' =>
   111.             the_signature_is_wanted := False;
   112.          when 't' | 'T' =>
   113.             authentic_timing_is_enabled := True;
   114.          when 'w' | 'W' =>
   115.             flexowriter_output_is_wanted := False;
   116.          when 'x' | 'X' =>
   117.             only_signature_tracing := True;
   118.          when 'z' | 'Z' =>
   119.             the_log_is_wanted := False;
   120.             debugging_is_enabled := False;
   121.             API_logging_is_wanted := False;
   122.             any_histogram_is_wanted := False;
   123.             the_signature_is_wanted := False;
   124.             the_final_state_is_wanted := False;
   125.             interrupt_tracing_is_wanted := False;
   126.             peripheral_tracing_is_wanted := False;
   127.             retrospective_tracing_is_wanted := False;
   128.          when others =>
   129.             raise emulation_failure with "invalid miscellany flag not previously failed";
   130.       end case;
   131.       set_diagnostic_mode(the_diagnostic_mode);
   132.    end set_this_miscellany_flag;
   133.
   134.    procedure display_execution_modes (for_this_run : in String := "") is
   135.       needs_comma : Boolean := False;
   136.
   137.       procedure append_option (flag : in Boolean; name : in String) is
   138.       begin
   139.          if flag then
   140.             if needs_comma then
   141.                log(", ");
   142.             end if;
   143.             log(name);
   144.             needs_comma := True;
   145.          end if;
   146.       end append_option;
   147.
   148.       function description_of (type_of_run, name_of_code : String)
   149.       return String
   150.       is (if name_of_code = "" then type_of_run else type_of_run & " " & name_of_code);
   151.
   152.    begin -- display_execution_modes
   153.       if not the_log_is_wanted then return; end if;
   154.       if for_this_run = "" then
   155.          log("Resuming the run");
   156.       else
   157.          log(
   158.              case the_execution_mode is
   159.                when boot_mode         => "Booting the KDF9 " & description_of("Director", for_this_run),
   160.                when program_mode      => "Running the KDF9 " & description_of("problem program", for_this_run),
   161.                when test_program_mode => "Running the KDF9 " & description_of("privileged program", for_this_run)
   162.             );
   163.       end if;
   164.       log(" in ");
   165.       log(
   166.           case the_diagnostic_mode is
   167.              when trace_mode    =>
   168.                 (if the_external_trace_is_enabled then "external trace mode" else "trace mode"),
   169.              when fast_mode     => "fast mode",
   170.              when pause_mode    => "pause mode",
   171.              when external_mode => "external trace mode"
   172.          );
   173.       if the_histogram_is_enabled           or else
   174.          the_interrupt_trace_is_enabled     or else
   175.          the_peripheral_trace_is_enabled    or else
   176.          the_retrospective_trace_is_enabled or else
   177.          the_signature_is_enabled           or else
   178.          the_external_trace_is_enabled      or else
   179.          authentic_timing_is_enabled        or else
   180.          debugging_is_enabled               or else
   181.          noninteractive_usage_is_enabled       then
   182.
   183.          log_line(", with option(s):");
   184.          log("   ");
   185.          append_option(authentic_timing_is_enabled,        "authentic timing");
   186.          append_option(debugging_is_enabled,               "debugging output");
   187.          append_option(the_histogram_is_enabled,           "histogram(s)");
   188.          append_option(the_interrupt_trace_is_enabled,     "interrupt trace");
   189.          append_option(noninteractive_usage_is_enabled,    "noninteractive");
   190.          append_option(the_peripheral_trace_is_enabled,    "peripheral trace");
   191.          append_option(the_retrospective_trace_is_enabled, "retro trace");
   192.          append_option(the_signature_is_enabled,           "signature hash");
   193.       end if;
   194.       log_line(".");
   195.       log_rule;
   196.    end display_execution_modes;
   197.
   198.    procedure quit_if_requested is
   199.    begin
   200.       if quit_was_requested then
   201.          raise quit_request;
   202.       end if;
   203.    end quit_if_requested;
   204.
   205.    procedure change_diagnostic_mode_if_requested is
   206.    begin
   207.       if the_diagnostic_mode_changed then
   208.          the_diagnostic_mode_changed := False;
   209.          raise mode_change_request;
   210.       end if;
   211.    end change_diagnostic_mode_if_requested;
   212.
   213.    procedure set_diagnostic_mode (a_diagnostic_mode : in settings.diagnostic_mode) is
   214.       the_signature_is_appropriate,
   215.       the_histogram_is_appropriate,
   216.       retrospective_tracing_is_appropriate,
   217.       peripheral_tracing_is_appropriate,
   218.       interrupt_tracing_is_appropriate : Boolean;
   219.    begin
   220.       if a_diagnostic_mode = external_mode then
   221.          if (the_diagnostic_mode /= external_mode) and (not the_external_trace_is_enabled) then
   222.             open(the_external_trace_file, the_external_trace_file_name);
   223.          end if;
   224.          the_diagnostic_mode := trace_mode;
   225.          the_external_trace_is_enabled := True;
   226.       else
   227.          the_diagnostic_mode := a_diagnostic_mode;
   228.       end if;
   229.       case a_diagnostic_mode is
   230.          when fast_mode =>
   231.             debugging_is_enabled := False;
   232.             the_signature_is_appropriate := False;
   233.             the_histogram_is_appropriate := False;
   234.             retrospective_tracing_is_appropriate := False;
   235.             peripheral_tracing_is_appropriate := False;
   236.             interrupt_tracing_is_appropriate := False;
   237.          when trace_mode | external_mode | pause_mode =>
   238.             the_signature_is_appropriate := True;
   239.             the_histogram_is_appropriate := True;
   240.             retrospective_tracing_is_appropriate := True;
   241.             peripheral_tracing_is_appropriate := True;
   242.             interrupt_tracing_is_appropriate := (the_execution_mode = boot_mode);
   243.       end case;
   244.       the_signature_is_enabled :=
   245.          the_signature_is_wanted and the_signature_is_appropriate;
   246.       the_histogram_is_enabled :=
   247.          any_histogram_is_wanted and the_histogram_is_appropriate;
   248.       the_retrospective_trace_is_enabled :=
   249.          retrospective_tracing_is_wanted and retrospective_tracing_is_appropriate;
   250.       the_peripheral_trace_is_enabled :=
   251.          peripheral_tracing_is_wanted and peripheral_tracing_is_appropriate;
   252.       the_interrupt_trace_is_enabled :=
   253.          interrupt_tracing_is_wanted and interrupt_tracing_is_appropriate;
   254.    end set_diagnostic_mode;
   255.
   256.    procedure set_execution_mode (an_execution_mode : in settings.execution_mode) is
   257.    begin
   258.       the_execution_mode := an_execution_mode;
   259.    end set_execution_mode;
   260.
   261.    package diagnostic_mode_IO   is new Ada.Text_IO.Enumeration_IO(settings.diagnostic_mode);
   262.
   263.    package execution_mode_IO    is new Ada.Text_IO.Enumeration_IO(settings.execution_mode);
   264.
   265.    package authenticity_mode_IO is new Ada.Text_IO.Enumeration_IO(KDF9.authenticity_mode);
   266.
   267.    package equipment_IO         is new Ada.Text_IO.Enumeration_IO(IOC.equipment.device_kinds);
   268.
   269.    procedure get_settings_from_file (version : in String) is
   270.
   271.       the_settings_file_name : constant String := "settings_" & version & ".txt";
   272.       counts_are_set : Boolean := False;
   273.       settings_file  : File_Type;
   274.       flag           : Character;
   275.
   276.       procedure set_the_miscellany_flags is
   277.          option : Character;
   278.       begin
   279.          loop
   280.             get(settings_file, option);
   281.             if is_invalid_miscellany_flag(option) then
   282.                raise Data_Error;
   283.             else
   284.                set_this_miscellany_flag(option);
   285.             end if;
   286.          exit when End_Of_Line(settings_file);
   287.          end loop;
   288.       exception
   289.          when error : others =>
   290.             if not End_Of_Line(settings_file) then
   291.                Skip_Line(settings_file);
   292.             end if;
   293.             log_new_line;
   294.             log_line(
   295.                      "***** Error in a miscellany specification: '"
   296.                    & option
   297.                    & "' at "
   298.                    & Exception_Message(error)
   299.                     );
   300.       end set_the_miscellany_flags;
   301.
   302.       procedure set_breakpoints is
   303.          start, end_point : KDF9.order_word_number;
   304.       begin
   305.          begin
   306.             get_word(settings_file, KDF9.word(start));
   307.          exception
   308.             when others =>
   309.                log_new_line;
   310.                log_line("***** Error in lower address; no breakpoint set.");
   311.                return;
   312.          end;
   313.
   314.          log_new_line;
   315.          log_line(
   316.                   "Lower breakpoint: "
   317.                 & oct_of(KDF9.syllable_address'(start, 0))
   318.                 & " ("
   319.                 & dec_of(KDF9.syllable_address'(start, 0))
   320.                 & ")",
   321.                   iff => the_log_is_wanted
   322.                  );
   323.          breakpoints(start) := True;
   324.
   325.          begin
   326.             get_word(settings_file, KDF9.word(end_point));
   327.          exception
   328.             when Data_Error =>
   329.                log_line("      No upper address: one breakpoint set.", iff => the_log_is_wanted);
   330.                set_breakpoints(start, start);
   331.                return;
   332.          end;
   333.          log_line(
   334.                   "Upper breakpoint: "
   335.                 & oct_of(KDF9.syllable_address'(end_point, 5))
   336.                 & " (" & dec_of(KDF9.syllable_address'(end_point, 5))
   337.                 & ")",
   338.                   iff => the_log_is_wanted
   339.                  );
   340.          set_breakpoints(start, end_point);
   341.       exception
   342.          when others =>
   343.             log_line("***** Error setting breakpoints; ignored.");
   344.       end set_breakpoints;
   345.
   346.       procedure set_store_points is
   347.          start, end_point : KDF9.address;
   348.       begin
   349.          begin
   350.             get_word(settings_file, KDF9.word(start));
   351.          exception
   352.             when others =>
   353.                log_new_line;
   354.                log_line("***** Error in lower address; no storepoint set.");
   355.                return;
   356.          end;
   357.          log_new_line;
   358.          log_line(
   359.                   "Lower storepoint: #"
   360.                 & oct_of(start)
   361.                 & " ("
   362.                 & dec_of(start)
   363.                 & ")",
   364.                   iff => the_log_is_wanted
   365.                  );
   366.          begin
   367.             get_word(settings_file, KDF9.word(end_point));
   368.          exception
   369.             when Data_Error =>
   370.                log_line("      No upper address: one storepoint set.", iff => the_log_is_wanted);
   371.                set_store_points(start, start);
   372.                return;
   373.          end;
   374.          log_line(
   375.                   "Upper storepoint: #"
   376.                 & oct_of(end_point)
   377.                 & " ("
   378.                 & dec_of(end_point)
   379.                 & ")",
   380.                   iff => the_log_is_wanted
   381.                  );
   382.          set_store_points(start, end_point);
   383.       exception
   384.          when others =>
   385.             log_line("***** Error setting storepoints; ignored.");
   386.       end set_store_points;
   387.
   388.       procedure set_watchpoints is
   389.          start, end_point : KDF9.address;
   390.       begin
   391.          begin
   392.             get_word(settings_file, KDF9.word(start));
   393.          exception
   394.             when others =>
   395.                log_new_line;
   396.                log_line("***** Error in lower address; no watchpoint set.");
   397.                return;
   398.          end;
   399.          log_new_line;
   400.          log_line(
   401.                   "Lower watchpoint: #"
   402.                 & oct_of(start)
   403.                 & " ("
   404.                 & dec_of(start)
   405.                 & ")",
   406.                   iff => the_log_is_wanted
   407.                  );
   408.          begin
   409.             get_word(settings_file, KDF9.word(end_point));
   410.          exception
   411.             when Data_Error =>
   412.                log_line("      No upper address: one watchpoint set.", iff => the_log_is_wanted);
   413.                set_store_points(start, start);
   414.                set_fetch_points(start, start);
   415.                return;
   416.          end;
   417.          log_line("Upper watchpoint: #" & oct_of(end_point) & " (" & dec_of(end_point) & ")",
   418.                   iff => the_log_is_wanted);
   419.          set_fetch_points(start, end_point);
   420.          set_store_points(start, end_point);
   421.       exception
   422.          when others =>
   423.             log_line("***** Error setting watchpoints; ignored.");
   424.       end set_watchpoints;
   425.
   426.       procedure set_specified_dumping_ranges (epoch : in dumping.flag) is
   427.          use dumping.flag_support;
   428.          format       : dumping.format_set := no_dumping_flag or epoch;
   429.          first_address,
   430.          last_address : KDF9.address := 0;
   431.          bad_range    : Boolean := False;
   432.          data         : KDF9.word;
   433.          c            : Character;
   434.          OK           : Boolean;
   435.       begin
   436.          while not End_Of_Line(settings_file) loop
   437.             get(settings_file, c);
   438.          exit when c = ' ';
   439.             if is_parameter_flag/dumping_flag(to_upper(c)) then
   440.                format := format or dumping_flag(to_upper(c));
   441.             else
   442.                if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   443.                log_new_line;
   444.                log_line("***** Error: '" & c & "' is not a valid dump type");
   445.                return;
   446.             end if;
   447.          end loop;
   448.          log_new_line;
   449.          log_line("Dump: format " & format_image(format), iff => the_log_is_wanted);
   450.          if (format and is_parameter_flag) /= no_dumping_flag then
   451.             get_word(settings_file, data);
   452.             if data > max_address                     or else
   453.                   (format/Usercode_flag and data > 8191) then
   454.                log_line(
   455.                         "***** Error: Lower dump address  = #"
   456.                       & oct_of(data)
   457.                       & " =" & data'Image
   458.                       & " is too large for this option"
   459.                        );
   460.                bad_range := True;
   461.             else
   462.                first_address := KDF9.address(data);
   463.                last_address  := KDF9.address(data);
   464.                log_line(
   465.                         "      Lower dump address: #"
   466.                       & oct_of(first_address)
   467.                       & " (" & dec_of(first_address)
   468.                       & ")",
   469.                         iff => the_log_is_wanted
   470.                        );
   471.             end if;
   472.
   473.            skip_to_next_non_blank (settings_file);
   474.
   475.             if not end_of_line(settings_file) then
   476.                get_word(settings_file, data);
   477.                if data > max_address                     or else
   478.                   (format/Usercode_flag and data > 8191) then
   479.                   log_line(
   480.                            "***** Error: Upper dump address: #"
   481.                          & oct_of(data)
   482.                          & " =" & data'Image
   483.                          & " is too large for this option"
   484.                           );
   485.                   bad_range := True;
   486.                else
   487.                   last_address := KDF9.address(data);
   488.                   log_line(
   489.                            "      Upper dump address: #"
   490.                          & oct_of(last_address)
   491.                          & " ("
   492.                          & dec_of(last_address)
   493.                          & ")",
   494.                            iff => the_log_is_wanted
   495.                           );
   496.                end if;
   497.             end if;
   498.
   499.             if format/Usercode_flag then
   500.               if not end_of_line(settings_file) then
   501.                   get_word(settings_file, data);
   502.                   if data > 8190 then
   503.                      log_line(
   504.                               "***** Error: Scan start address: #"
   505.                             & oct_of(data)
   506.                             & " ="
   507.                             & data'Image
   508.                             & " > 8190, ignored"
   509.                              );
   510.                   else
   511.                      nominated_address := KDF9.order_word_number(data);
   512.                      log_line(
   513.                               "      Scan start address: #"
   514.                             & oct_of(nominated_address)
   515.                             & " ("
   516.                             & dec_of(nominated_address)
   517.                             & ")",
   518.                               iff => the_log_is_wanted
   519.                              );
   520.                   end if;
   521.                end if;
   522.             end if;
   523.
   524.          end if;
   525.
   526.          if bad_range then
   527.             log_line("***** Error: No dump specification set.");
   528.          else
   529.             request_a_dumping_area(format, first_address, last_address, OK);
   530.          if not OK then
   531.             log_line("***** Error: Too many dump specifications (ignored).");
   532.          end if;
   533.          end if;
   534.          if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   535.       exception
   536.          when others =>
   537.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   538.             log_new_line;
   539.             log_line(
   540.                      "***** Error in a dump area specification: format "
   541.                    & format_image(format)
   542.                    & "; Lower dump address = #"
   543.                    & oct_of(first_address)
   544.                    & " ("
   545.                    & dec_of(first_address)
   546.                    & ")"
   547.                    & "; Upper dump address = #"
   548.                    & oct_of(last_address)
   549.                    & " ("
   550.                    & dec_of(last_address)
   551.                    & ")"
   552.                     );
   553.       end set_specified_dumping_ranges;
   554.
   555.       procedure set_initial_dumping_ranges is
   556.       begin
   557.          set_specified_dumping_ranges(initial_flag);
   558.       end set_initial_dumping_ranges;
   559.
   560.       procedure set_final_dumping_ranges is
   561.       begin
   562.          set_specified_dumping_ranges(final_flag);
   563.       end set_final_dumping_ranges;
   564.
   565.       procedure set_histogram_options is
   566.          c : Character;
   567.       begin
   568.          while not End_Of_Line(settings_file) loop
   569.             get(settings_file, c);
   570.          exit when c = ' ';
   571.             if c not in 'P' | 'p' | 'T' | 't' then
   572.                raise Data_Error;
   573.             end if;
   574.             if c in 'P' | 'p' then
   575.                the_profile_is_wanted  := True;
   576.                clear_the_profile;
   577.             elsif c in  'T' | 't' then
   578.                the_INS_plot_is_wanted := True;
   579.                clear_the_histogram;
   580.             end if;
   581.          end loop;
   582.          ensure_not_at_end_of_line(settings_file);
   583.          get(settings_file, histogram_cutoff);
   584.          if histogram_cutoff >= 100.0 or histogram_cutoff < 0.0 then
   585.             raise Data_Error;
   586.          end if;
   587.          get(settings_file, c);
   588.          if c /= '%' then
   589.             raise Data_Error;
   590.          end if;
   591.       exception
   592.          when others =>
   593.             histogram_cutoff := cutoff_default;
   594.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   595.             log_new_line;
   596.             log_line("***** Error in the histogram option; default used.");
   597.       end set_histogram_options;
   598.
   599.       procedure set_time_limit is
   600.          begin
   601.             begin
   602.             get_decimal(settings_file, KDF9.word(time_limit));
   603.          exception
   604.             when others =>
   605.                if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   606.                time_limit := offline_time_limit;
   607.          end;
   608.
   609.          if not counts_are_set then
   610.             high_count := time_limit;
   611.          end if;
   612.
   613.          log_new_line;
   614.          log_line("Time limit (in instructions) =" & time_limit'Image,
   615.                   iff => the_log_is_wanted);
   616.       end set_time_limit;
   617.
   618.       procedure set_tracing_counts is
   619.
   620.          procedure show_counts is
   621.          begin
   622.             if not the_log_is_wanted then return; end if;
   623.             log_new_line;
   624.             log_line("Lower tracing count:" & low_count'Image);
   625.             log_line("Upper tracing count:" & high_count'Image);
   626.          end show_counts;
   627.
   628.       begin
   629.          get_decimal(settings_file, KDF9.word(low_count));
   630.          get_decimal(settings_file, KDF9.word(high_count));
   631.          show_counts;
   632.          if low_count > high_count then
   633.             log_new_line;
   634.             log_line("***** Error: Low count > high count");
   635.             raise Data_Error;
   636.          end if;
   637.          counts_are_set := True;
   638.       exception
   639.          when others =>
   640.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   641.             low_count  := low_count_default;
   642.             high_count := high_count_default;
   643.             log_new_line;
   644.             log_line("***** Error in a tracing count; defaults used.");
   645.             show_counts;
   646.       end set_tracing_counts;
   647.
   648.       procedure set_tracing_range is
   649.
   650.          procedure show_range is
   651.          begin
   652.             if not the_log_is_wanted then return; end if;
   653.             log_new_line;
   654.             log_line(
   655.                      "Lower trace address: #"
   656.                    & oct_of(KDF9.syllable_address'(low_bound, 0))
   657.                    & " ("
   658.                    & dec_of(KDF9.syllable_address'(low_bound, 0))
   659.                    & ")"
   660.                     );
   661.             log_line(
   662.                      "Upper trace address: #"
   663.                    & oct_of(KDF9.syllable_address'(high_bound, 5))
   664.                    & " ("
   665.                    & dec_of(KDF9.syllable_address'(high_bound, 5))
   666.                    & ")"
   667.                     );
   668.          end show_range;
   669.
   670.       begin
   671.          get_word(settings_file, KDF9.word(low_bound));
   672.          get_word(settings_file, KDF9.word(high_bound));
   673.          if low_bound > high_bound then
   674.             log_new_line;
   675.             log_line("***** Error: Low bound > high bound");
   676.             raise Data_Error;
   677.          end if;
   678.          show_range;
   679.       exception
   680.          when others =>
   681.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   682.             low_bound  := low_bound_default;
   683.             high_bound := high_bound_default;
   684.             log_new_line;
   685.             log_line("***** Error in a tracing address; defaults used.");
   686.             show_range;
   687.       end set_tracing_range;
   688.
   689.       procedure set_diagnostic_mode is
   690.          use diagnostic_mode_IO;
   691.          the_diagnostic_mode : settings.diagnostic_mode;
   692.       begin
   693.          ensure_not_at_end_of_line(settings_file);
   694.          get(settings_file, the_diagnostic_mode);
   695.          set_diagnostic_mode(the_diagnostic_mode);
   696.       exception
   697.          when others =>
   698.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   699.             set_diagnostic_mode(the_diagnostics_default);
   700.             log_new_line;
   701.             log_line("***** Error in the diagnostic mode; default used.");
   702.       end set_diagnostic_mode;
   703.
   704.       procedure set_execution_mode is
   705.          use execution_mode_IO;
   706.       begin
   707.          ensure_not_at_end_of_line(settings_file);
   708.          get(settings_file, the_execution_mode);
   709.       exception
   710.          when others =>
   711.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   712.             the_execution_mode := the_execution_default;
   713.             log_new_line;
   714.             log_line("***** Error in the testing mode; default used.");
   715.       end set_execution_mode;
   716.
   717.       procedure set_authenticity is
   718.          use authenticity_mode_IO;
   719.       begin
   720.          ensure_not_at_end_of_line(settings_file);
   721.          get(settings_file, the_authenticity_mode);
   722.          if the_authenticity_mode = authentic_time_mode then
   723.             authentic_timing_is_enabled := True;
   724.          end if;
   725.       exception
   726.          when others =>
   727.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   728.             the_authenticity_mode := the_authenticity_default;
   729.             log_new_line;
   730.             log_line("***** Error in the authenticity mode; default used.");
   731.       end set_authenticity;
   732.
   733.       procedure set_graph_plotting_pen is
   734.          use postscript;
   735.          use colour_IO;
   736.          use  width_IO;
   737.          the_colour   : pen_colour   := the_default_colour;
   738.          the_pen_size : pen_tip_size := the_default_tip_size;
   739.
   740.          procedure show_pen_options is
   741.          begin
   742.             if not the_log_is_wanted then return; end if;
   743.             log_new_line;
   744.             if the_colour /= the_default_colour then
   745.                log_line("The graph plotter pen colour is " & the_colour'Image & ".");
   746.             end if;
   747.             if the_pen_size /= the_default_tip_size then
   748.                log_line("The graph plotter pen tip is " & the_pen_size'Image & ".");
   749.             end if;
   750.          end show_pen_options;
   751.
   752.          procedure configure_the_plotter is
   753.          begin
   754.             if the_colour /= the_default_colour or the_pen_size /= the_default_tip_size then
   755.                set_the_pen_properties(the_colour, the_pen_size);
   756.                show_pen_options;
   757.             end if;
   758.          end configure_the_plotter;
   759.
   760.       begin  -- set_graph_plotting_pen
   761.          the_graph_plotter_is_enabled := True;
   762.          ensure_not_at_end_of_line(settings_file);
   763.          begin
   764.             Get(settings_file, the_colour);
   765.          exception
   766.             when others =>
   767.                log_new_line;
   768.                log_line("***** Error in the plotter pen the_colour; default used.");
   769.          end;
   770.          ensure_not_at_end_of_line(settings_file);
   771.          begin
   772.             Get(settings_file, the_pen_size);
   773.          exception
   774.             when others =>
   775.                log_new_line;
   776.                log_line("***** Error in the plotter pen tip; default used.");
   777.          end;
   778.          configure_the_plotter;
   779.       exception
   780.          when Data_Error =>
   781.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   782.             configure_the_plotter;
   783.       end set_graph_plotting_pen;
   784.
   785.       procedure set_non_interactivity is
   786.       begin
   787.          noninteractive_usage_is_enabled := True;
   788.          set_time_limit;
   789.       end set_non_interactivity;
   790.
   791.       procedure save_poke_value is
   792.          -- W: full Word, U: Upper halfword, L: Lower halfword, S: Syllable, C: Character
   793.          address  : KDF9.address;
   794.          sub_word : Character;
   795.          position : KDF9.address;
   796.          value    : KDF9.word;
   797.          OK       : Boolean;
   798.       begin
   799.          begin
   800.             get_word(settings_file, KDF9.word(address));
   801.          exception
   802.             when others =>
   803.                log_line("***** Error in poke word address.");
   804.                Skip_Line(settings_file);
   805.                return;
   806.          end;
   807.
   808.          get_char(settings_file, sub_word);
   809.          if sub_word not in 'S' | 's' | 'C' | 'c' | 'L' | 'l' | 'U' | 'u' | 'W' | 'w' then
   810.             log_line(
   811.                      "***** Error in (sub)word indicator; "
   812.                    & sub_word
   813.                    & " should be W, L, U, S, or C."
   814.                     );
   815.             Skip_Line(settings_file);
   816.             return;
   817.          end if;
   818.
   819.          if sub_word in 'S' | 's' | 'C' | 'c' then
   820.             begin
   821.                get_word(settings_file, KDF9.word(position));
   822.                if (sub_word in 'S' | 's' and position > 5) or else
   823.                   (sub_word in 'C' | 'c' and position > 7)    then
   824.                   log_line(
   825.                            "***** Error in position given for a "
   826.                          & (if sub_word in 'S' | 's' then "syllable:" else "character:")
   827.                          & position'Image
   828.                          & " is too large, poke request ignored."
   829.                           );
   830.                   Skip_Line(settings_file);
   831.                   return;
   832.                end if;
   833.             exception
   834.                when others =>
   835.                   log_line(
   836.                            "***** Error in position given for a "
   837.                          & (if sub_word in 'S' | 's' then "syllable" else "character")
   838.                          & ", poke request ignored."
   839.                           );
   840.                   Skip_Line(settings_file);
   841.                   return;
   842.             end;
   843.          else
   844.             position := 0;
   845.          end if;
   846.
   847.          begin
   848.             get_word(settings_file, value);
   849.          exception
   850.             when others =>
   851.                log_line("***** Error in poked value.");
   852.                Skip_Line(settings_file);
   853.                return;
   854.          end;
   855.
   856.          if (sub_word in 'L' | 'l' | 'U' | 'u' and value > 2**24-1) or else
   857.                (sub_word in 'S' | 's'          and value > 255)     or else
   858.                   (sub_word in 'C' | 'c'       and value > 63)      then
   859.             log_line(
   860.                      "***** Error in poked value #"
   861.                    & oct_of(value)
   862.                    & ": out of range for a "
   863.                    & (case sub_word is
   864.                          when 'L' | 'l' | 'U' | 'u' => "halfword",
   865.                          when 'S' | 's'             => "syllable",
   866.                          when 'C' | 'c'             => "character",
   867.                          when others                => "word")
   868.                    & ", poke request ignored."
   869.                     );
   870.             Skip_Line(settings_file);
   871.             return;
   872.          end if;
   873.
   874.          add_to_poke_list(address, sub_word, position, value, OK);
   875.
   876.          if not OK then
   877.             log_line("***** Error setting up a poke: poke list full; request ignored.");
   878.          end if;
   879.
   880.       exception
   881.
   882.          when others =>
   883.             null;  -- to skip line at end of input loop
   884.
   885.       end save_poke_value;
   886.
   887.       procedure set_KDF9_configuration is
   888.          use equipment_IO;
   889.          use IOC.equipment;
   890.          d : IOC.equipment.device_kinds := NA;
   891.          b : KDF9.buffer_number;
   892.       begin
   893.          if version = "1" then
   894.             for c in choices'Range loop
   895.             exit when end_of_line(settings_file);
   896.                get_word(settings_file, KDF9.word(b));
   897.                ensure_not_at_end_of_line(settings_file);
   898.                get(settings_file, d);
   899.                if d = GP then
   900.                   the_graph_plotter_is_enabled := True;
   901.                end if;
   902.                choice(KDF9.buffer_number'(b)) := d;
   903.             end loop;
   904.          else
   905.             log_new_line;
   906.             log_line("The previous KDF9 configuration is still being used.");
   907.          end if;
   908.          if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   909.       exception
   910.          when others =>
   911.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   912.             choice := default;
   913.             log_new_line;
   914.             log_line("***** Error in the device configuration; defaults used.");
   915.       end set_KDF9_configuration;
   916.
   917.    begin -- get_settings_from_file
   918.
   919.       do_not_execute := False;
   920.       high_count := time_limit;
   921.       open_options_file(settings_file, the_settings_file_name);
   922.       if end_of_file(settings_file) then
   923.          raise End_Error;
   924.       end if;
   925.
   926.       loop
   927.          skip_to_next_nonempty_line(settings_file);
   928.          get(settings_file, flag);
   929.          case flag is
   930.             when 'A' | 'a' =>
   931.                set_authenticity;
   932.             when 'B' | 'b' =>
   933.                set_breakpoints;
   934.             when 'C' | 'c' =>
   935.                set_tracing_counts;
   936.             when 'D' | 'd' =>
   937.                set_diagnostic_mode;
   938.             when 'F' | 'f' =>
   939.                set_final_dumping_ranges;
   940.             when 'G' | 'g' =>
   941.                set_graph_plotting_pen;
   942.             when 'H' | 'h' =>
   943.                set_histogram_options;
   944.             when 'I' | 'i' =>
   945.                set_initial_dumping_ranges;
   946.             when 'K' | 'k' =>
   947.                set_KDF9_configuration;
   948.             when 'L' | 'l' =>
   949.                set_time_limit;
   950.             when 'N' | 'n' =>
   951.                set_non_interactivity;
   952.                time_limit := offline_time_limit;
   953.             when 'O' |'o' =>
   954.                set_this_miscellany_flag(flag);
   955.             when 'P' | 'p' =>
   956.                save_poke_value;
   957.             when 'Q' | 'q' =>
   958.                do_not_execute := True;
   959.                raise End_Error;
   960.             when 'R' | 'r' =>
   961.                set_tracing_range;
   962.             when 'S' | 's' =>
   963.                set_store_points;
   964.             when 'T' | 't' =>
   965.                set_execution_mode;
   966.             when 'V' | 'v' =>
   967.                set_the_miscellany_flags;
   968.             when 'W' | 'w' =>
   969.                set_watchpoints;
   970.             when 'X' | 'x' =>
   971.                only_signature_tracing := True;
   972.             when '-' | '/' =>
   973.                Skip_Line(settings_file);
   974.             when others =>
   975.                log_new_line;
   976.                log_line(
   977.                         "Invalid flag: """
   978.                       & flag
   979.                       & """ at line/column "
   980.                       & line_number'Image
   981.                       & "/"
   982.                       & Ada.Text_IO.Count'Image(Col(settings_file))
   983.                       & " of the settings file!"
   984.                        );
   985.                log_line(" ...  the valid flags are A,B,C,D,F,G,I,L,N,O,P,Q,R,S,T,V,W,X, -, and /");
   986.                Skip_Line(settings_file);
   987.          end case;
   988.       end loop;
   989.
   990.    exception
   991.
   992.       when Status_Error =>
   993.          null;
   994.
   995.       when End_Error =>
   996.          close_options_file(settings_file, the_settings_file_name);
   997.
   998.       when Data_Error =>
   999.          close_options_file(settings_file, the_settings_file_name);
  1000.          log_new_line;
  1001.          log_line("***** Error: invalid data in the settings file.");
  1002.          log_line(
  1003.                   "Reading of settings abandoned at line "
  1004.                 & line_number'Image
  1005.                 & " of '"
  1006.                 & the_settings_file_name
  1007.                 & "'."
  1008.                  );
  1009.
  1010.       when quit_request =>
  1011.          close_options_file(settings_file, the_settings_file_name);
  1012.          log_new_line;
  1013.          log_line(
  1014.                   "Quit requested at line "
  1015.                 & line_number'Image
  1016.                 & " of '"
  1017.                 & the_settings_file_name
  1018.                 & "'."
  1019.                  );
  1020.          log_rule;
  1021.          raise;
  1022.
  1023.       when error : others =>
  1024.          close_options_file(settings_file, the_settings_file_name);
  1025.          log_new_line;
  1026.          log_line(
  1027.                   "Failure in ee9; unexpected exception: "
  1028.                 & Exception_Information(error)
  1029.                 & " in 'get_settings_from_file'!"
  1030.                  );
  1031.          log_line(
  1032.                   "Reading of settings abandoned at line "
  1033.                 & line_number'Image
  1034.                 & " of '"
  1035.                 & the_settings_file_name
  1036.                 & "'!"
  1037.                  );
  1038.          log_rule;
  1039.          raise emulation_failure with "reading settings from file";
  1040.
  1041.    end get_settings_from_file;
  1042.
  1043. end settings;

Compiling: ../Source/settings.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:22

     1. -- settings.ads
     2. --
     3. -- execution mode, diagnostic mode, and other emulation-control settings
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with KDF9;
    20. with logging.file;
    21.
    22. use  KDF9;
    23. use  logging.file;
    24.
    25. package settings is
    26.
    27. --
    28.    -- In fast mode: code runs as efficiently as possible, without diagnostics.
    29.
    30.    -- In trace mode: breakpoints, watchpoints, tracing address bounds and
    31.    --    tracing instruction count bounds are all honoured;
    32.    --       entries may be made in all the retrospective trace logs;
    33.    --          a digital execution signature may be computed,
    34.    --             and an instruction-frequency histogram may be generated.
    35.
    36.    -- In pause mode: execution proceeds as in trace mode;
    37.    --    additionally, breakpoints occur on every order executed within trace bounds.
    38.
    39.    -- The external mode is a user-interface value only. It requests the trace mode,
    40.    --    combined with the logging of a running trace to an external file.
    41. --
    42.
    43.    type diagnostic_mode is (fast_mode,
    44.                             trace_mode,
    45.                             pause_mode,
    46.                             external_mode);
    47.
    48.    procedure set_diagnostic_mode (a_diagnostic_mode : in settings.diagnostic_mode);
    49.
    50.    procedure change_diagnostic_mode_if_requested;
    51.
    52.    the_diagnostics_default  : constant settings.diagnostic_mode := fast_mode;
    53.    the_diagnostic_mode      : settings.diagnostic_mode := the_diagnostics_default;
    54.
    55.    the_external_trace_file_name : constant String := "trace.txt";
    56.    only_signature_tracing       : Boolean := False;
    57.    the_external_trace_file      : logging.file.output;
    58.
    59.    -- The diagnostic generation and display controls, inter alia.
    60.    -- The *_trace_is_wanted flags are set to True iff
    61.    --    they are both requested, and offered by the_diagnostic_mode.
    62.    -- These requests may be set by the miscellany and visibilty options.
    63.
    64.    miscellany_flags  : constant String := "abdefghikmnopqrstwxz.0123456789ABDEFGHIKMNOPQRSTWXZ";
    65.    miscellany_prompt : constant String := "{a|b|d|e|f|g|h|i|k|m|n|o|p|q|r|s|t|w|x|z|.|0..9}";
    66.
    67.    the_log_is_wanted,
    68.    API_logging_is_wanted,
    69.    the_signature_is_wanted,
    70.    any_histogram_is_wanted,
    71.    the_final_state_is_wanted,
    72.    interrupt_tracing_is_wanted,
    73.    peripheral_tracing_is_wanted,
    74.    flexowriter_output_is_wanted,
    75.    realistic_FW_output_is_wanted,
    76.    the_terminal_is_ANSI_compatible,
    77.    retrospective_tracing_is_wanted    : Boolean := True;
    78.
    79.    do_not_execute,
    80.    debugging_is_enabled,
    81.    the_signature_is_enabled,
    82.    the_histogram_is_enabled,
    83.    the_graph_plotter_is_enabled,
    84.    pre_overlay_state_is_enabled,
    85.    the_external_trace_is_enabled,
    86.    the_interrupt_trace_is_enabled,
    87.    noninteractive_usage_is_enabled,
    88.    the_peripheral_trace_is_enabled,
    89.    the_retrospective_trace_is_enabled : Boolean := False;
    90.
    91.    -- This option may also be set by an authenticity option (see KDF9).
    92.    authentic_timing_is_enabled : Boolean := False;
    93.
    94.    -- In boot_mode: a Director program is read from TR0 and executed
    95.    --    in Director state, with full use of the emulated hardware.
    96.    -- In program_mode: a user program is read from TR0 and executed
    97.    --    in program state, with basic OUTs implemented by the emulator.
    98.    -- In test_program_mode: a user program is read from TR0 and executed
    99.    --    in Director state, with basic OUTs implemented by the emulator,
   100.    --    this being useful for executing "hardware test" programs.
   101.
   102.    type execution_mode is (boot_mode, program_mode, test_program_mode);
   103.
   104.    procedure set_execution_mode (an_execution_mode : in settings.execution_mode);
   105.
   106.    the_execution_default : constant settings.execution_mode := program_mode;
   107.    the_execution_mode    :          settings.execution_mode := the_execution_default;
   108.
   109.    --
   110.    -- Tracing bound settings.
   111.    --
   112.
   113.    -- time_limit bounds the number of KDF9 instructions executed.
   114.
   115.    time_limit_default : constant KDF9.order_counter := KDF9.order_counter'Last;
   116.    time_slice         : constant KDF9.order_counter := 10_000;
   117.    offline_time_limit : constant KDF9.order_counter := 10_000 * time_slice;
   118.    time_limit         :          KDF9.order_counter := time_limit_default;
   119.
   120.
   121.    -- low_bound and high_bound bound the static scope of tracing.
   122.
   123.    low_bound_default  : constant KDF9.order_word_number := 0;
   124.    high_bound_default : constant KDF9.order_word_number := KDF9.order_word_number'Last;
   125.    low_bound          :          KDF9.order_word_number := low_bound_default;
   126.    high_bound         :          KDF9.order_word_number := high_bound_default;
   127.
   128.    -- nominated_address sets a flow analysis starting point for Usercode format dumps.
   129.    invalid_address    :          KDF9.order_word_number := 8191;
   130.    nominated_address  :          KDF9.order_word_number := invalid_address;
   131.
   132.    -- low_count and high_count bound the dynamic scope of tracing.
   133.
   134.    low_count_default  : constant KDF9.order_counter := 0;
   135.    high_count_default : constant KDF9.order_counter := time_limit_default;
   136.    low_count          :          KDF9.order_counter := low_count_default;
   137.    high_count         :          KDF9.order_counter := high_count_default;
   138.
   139.    -- Histogram bin frequencies less than histogram_cutoff are not logged.
   140.    the_profile_is_wanted  :          Boolean := False;
   141.    the_INS_plot_is_wanted :          Boolean := False;
   142.    cutoff_default         : constant Long_Float := 0.0;
   143.    histogram_cutoff       :          Long_Float := cutoff_default;
   144.
   145.    function is_invalid_miscellany_flag (option : in Character)
   146.    return Boolean;
   147.
   148.    procedure set_this_miscellany_flag (option : in Character);
   149.
   150.    -- do_not_execute is set if a quit is requested in the settings file.
   151.    -- The K option is not actioned unless version = "1".
   152.    procedure get_settings_from_file (version : in String);
   153.
   154.    procedure display_execution_modes (for_this_run : in String := "");
   155.
   156.    procedure quit_if_requested;
   157.
   158.    quit_was_requested          : Boolean := False;
   159.
   160.    the_diagnostic_mode_changed : Boolean := False;
   161.
   162.    loading_was_successful      : Boolean := False;
   163.
   164.    mode_change_request         : exception;
   165.
   166. end settings;

 1043 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/break_in.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:22

     1. -- break_in.adb
     2. --
     3. -- This communicates a break-in to the microcode.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with exceptions;
    20. with HCI;
    21. with KDF9;
    22. with POSIX;
    23. with finalize_ee9;
    24. with settings;
    25. with state_display;
    26.
    27. use  exceptions;
    28. use  HCI;
    29. use  KDF9;
    30. use  settings;
    31. use  state_display;
    32.
    33. package body break_in is
    34.
    35.    requested : Boolean := False
    36.       with Atomic, Volatile;
    37.
    38.    procedure note_user_interrupt is
    39.    begin
    40.       if requested then return; end if;  -- The handler is already running.
    41.       requested := True;
    42.    end note_user_interrupt;
    43.
    44.    function has_been_requested
    45.    return Boolean is
    46.    begin
    47.       return requested;
    48.    end has_been_requested;
    49.
    50.    procedure handler is
    51.    begin
    52.       requested := False;
    53.       interact("Break-in");
    54.       quit_if_requested;
    55.       if the_execution_mode = boot_mode then
    56.          effect(FLEX_interrupt);
    57.       else
    58.          show_current_state;
    59.       end if;
    60.       flush;
    61.    exception
    62.       when quit_request =>
    63.          finalize_ee9("Quit requested by the user");
    64.          POSIX.exit_program(0);
    65.    end handler;
    66.
    67. end break_in;

Compiling: ../Source/break_in.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:22

     1. -- break_in.ads
     2. --
     3. -- This conveys a break-in to the microcode.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package break_in is
    20.
    21.    function has_been_requested
    22.    return Boolean
    23.       with Inline;
    24.
    25.    procedure note_user_interrupt;
    26.
    27.    procedure handler;
    28.
    29. end break_in;

 67 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/dumping.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:22

     1. -- dumping.adb
     2. --
     3. -- Provide support for diagnostic core-dumping area descriptions.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with formatting;
    20. with state_display;
    21.
    22. use  formatting;
    23. use  state_display;
    24.
    25. package body dumping is
    26.
    27.    type poke_list_entry is
    28.       record
    29.          address  : KDF9.address;
    30.          sub_word : Character;
    31.          position : KDF9.address;
    32.          value    : KDF9.word;
    33.       end record;
    34.
    35.    length_of_poke_list : constant := 100;
    36.    poke_list_count     : Natural range 0 .. length_of_poke_list := 0;
    37.    poke_list           : array (Positive range 1 .. length_of_poke_list) of poke_list_entry;
    38.
    39.    use dumping.flag_support;
    40.
    41.    function dumping_flag (c : Character)
    42.    return dumping.flag
    43.    is (dumping.flag(to_upper(c)));
    44.
    45.    type area is
    46.       record
    47.          format_set  : dumping.format_set := no_dumping_flag;
    48.          first, last : KDF9.address;
    49.       end record;
    50.
    51.    no_dumping_area : constant dumping.area := (no_dumping_flag, 0, 0);
    52.
    53.    dumping_areas : array (dumping.area_number) of dumping.area := (others => no_dumping_area);
    54.
    55.    pre_dumping_area_count  : area_count := 0;
    56.    post_dumping_area_count : area_count := 0;
    57.
    58.    function nr_of_pre_dumping_areas
    59.    return dumping.area_count
    60.    is (pre_dumping_area_count);
    61.
    62.    function nr_of_post_dumping_areas
    63.    return dumping.area_count
    64.    is (post_dumping_area_count);
    65.
    66.    procedure request_a_dumping_area (format_set  : in dumping.format_set;
    67.                                      first, last : in KDF9.address;
    68.                                      was_stored  : out Boolean) is
    69.    begin
    70.       was_stored := False;
    71.       if pre_dumping_area_count+post_dumping_area_count = nr_of_dumping_areas then
    72.          return;
    73.       end if;
    74.       for d of dumping_areas loop
    75.          if d = (format_set, first, last) then
    76.             was_stored := True;
    77.             return;
    78.          end if;
    79.       end loop;
    80.       if format_set/expunge_flag then
    81.          remove_specified_areas(format_set - expunge_flag, first, last);
    82.       end if;
    83.       for d of dumping_areas loop
    84.          if d.format_set = no_dumping_flag then
    85.             d := (format_set, first, last);
    86.             was_stored := True;
    87.             if initial_flag/format_set then
    88.                pre_dumping_area_count := pre_dumping_area_count + 1;
    89.             end if;
    90.             if final_flag/format_set then
    91.                post_dumping_area_count := post_dumping_area_count + 1;
    92.             end if;
    93.             return;
    94.          end if;
    95.       end loop;
    96.    end request_a_dumping_area;
    97.
    98.    max_types : constant Positive := abs is_dumping_flag - 1; -- P XOR Q
    99.
   100.    function format_image (format_set : dumping.format_set)
   101.    return String is
   102.       image_set  : dumping.format_set := format_set;
   103.       result     : String(1 .. max_types) := (others => ' ');
   104.       p          : Positive range 2 .. max_types := 2;
   105.    begin
   106.       if image_set = no_dumping_flag then
   107.          return result;
   108.       elsif image_set/initial_flag then
   109.           image_set := image_set - initial_flag;
   110.           result(1) := Character(initial_flag);
   111.       else
   112.           image_set := image_set - final_flag;
   113.           result(1) := Character(final_flag);
   114.       end if;
   115.       for f in dumping.flag loop
   116.          if image_set/f then
   117.             result(p) := Character(f);
   118.             p := p + 1;
   119.          end if;
   120.       end loop;
   121.       return trimmed(result);
   122.    end format_image;
   123.
   124.    function area_image (d : dumping.area_number)
   125.    return String is
   126.       first       : constant KDF9.address := dumping_areas(d).first;
   127.       last        : constant KDF9.address := dumping_areas(d).last;
   128.       format_set  : constant dumping.format_set := dumping_areas(d).format_set;
   129.       result      : String(1 .. max_types+2*(7)) := (others => ' ');
   130.    begin
   131.       if pre_dumping_area_count+post_dumping_area_count = 0 then
   132.          return no_specification;
   133.       end if;
   134.       result(1 .. max_types)             := format_image(format_set);
   135.       result(max_types+2 .. max_types+7) := oct_of(first);
   136.       result(max_types+9 .. result'Last) := oct_of(last);
   137.       return result;
   138.    end area_image;
   139.
   140.    procedure remove_specified_areas (format_set  : in dumping.format_set;
   141.                                      first, last : in KDF9.address) is
   142.    begin
   143.       if pre_dumping_area_count+post_dumping_area_count = 0 then
   144.          return;
   145.       end if;
   146.       for d of dumping_areas loop
   147.          if d.first >= first and d.last <= last then
   148.             d.format_set := d.format_set - format_set;
   149.             if d.format_set-initial_flag-final_flag = no_dumping_flag then
   150.                d := no_dumping_area;
   151.             end if;
   152.             if initial_flag/d.format_set then
   153.                pre_dumping_area_count := Integer'Max(pre_dumping_area_count - 1, 0);
   154.             end if;
   155.             if final_flag/d.format_set then
   156.                post_dumping_area_count := Integer'Max(post_dumping_area_count - 1, 0);
   157.             end if;
   158.          end if;
   159.       end loop;
   160.    end remove_specified_areas;
   161.
   162.    procedure print_formatted_area (d : in dumping.area) is
   163.       format_set  : constant dumping.format_set := d.format_set;
   164.       first       : constant KDF9.address := d.first;
   165.       last        : constant KDF9.address := d.last;
   166.    begin
   167.       if format_set/tape_code_flag then
   168.          show_core_in_tape_code(first, last);
   169.       end if;
   170.       if format_set/normal_flag then
   171.          show_core_in_case_normal(first, last);
   172.       end if;
   173.       if format_set/shift_flag then
   174.          show_core_in_case_shift(first, last);
   175.       end if;
   176.       if format_set/ card_code_flag then
   177.          show_core_in_card_code(first, last);
   178.       end if;
   179.       if format_set/printer_flag then
   180.          show_core_in_print_code(first, last);
   181.       end if;
   182.       if format_set/ASCII_flag then
   183.          show_core_in_Latin_1(first, last);
   184.       end if;
   185.       if format_set/word_flag then
   186.          show_core_as_word_forms(first, last);
   187.       end if;
   188.       if format_set/Usercode_flag then
   189.          show_core_as_Usercode((KDF9.order_word_number(first), 0),
   190.                                (KDF9.order_word_number(last), 0),
   191.                                 octal_option => not format_set/decimal_flag);
   192.       end if;
   193.       if format_set/orders_flag then
   194.          show_core_as_syllables((KDF9.order_word_number(first), 0),
   195.                                 (KDF9.order_word_number( last), 0));
   196.       end if;
   197.    end print_formatted_area;
   198.
   199.    procedure print_dump_areas (flag : in dumping.flag; count : in dumping.area_count) is
   200.       Usercode_wanted : Boolean := False;
   201.    begin
   202.       if count = 0 then
   203.          return;
   204.       end if;
   205.       for d of dumping_areas loop
   206.          Usercode_wanted := Usercode_wanted or d.format_set/Usercode_flag;
   207.       end loop;
   208.       if Usercode_wanted then
   209.          mark_all_code_blocks_and_data_blocks;
   210.       end if;
   211.       for d of dumping_areas loop
   212.          if d.format_set/flag then
   213.             print_formatted_area(d);
   214.          end if;
   215.       end loop;
   216.    end print_dump_areas;
   217.
   218.    procedure print_prerun_dump_areas is
   219.    begin
   220.       print_dump_areas(initial_flag, pre_dumping_area_count);
   221.    end print_prerun_dump_areas;
   222.
   223.    procedure print_postrun_dump_areas is
   224.    begin
   225.       print_dump_areas(final_flag, post_dumping_area_count);
   226.    end print_postrun_dump_areas;
   227.
   228.    procedure remove_dump_areas (flag : in dumping.flag; count : in out dumping.area_count) is
   229.    begin
   230.       if count = 0 then
   231.          return;
   232.       end if;
   233.       for d of dumping_areas loop
   234.          if d.format_set/flag then
   235.             d := (no_dumping_flag, 0, 0);
   236.          end if;
   237.       end loop;
   238.       count := 0;
   239.    end remove_dump_areas;
   240.
   241.    procedure remove_prerun_dump_areas is
   242.    begin
   243.       remove_dump_areas(initial_flag, pre_dumping_area_count);
   244.    end remove_prerun_dump_areas;
   245.
   246.    procedure remove_postrun_dump_areas is
   247.    begin
   248.       remove_dump_areas(final_flag, post_dumping_area_count);
   249.    end remove_postrun_dump_areas;
   250.
   251.    procedure add_to_poke_list (address    : in KDF9.address;
   252.                                sub_word   : in Character;
   253.                                position   : in KDF9.address;
   254.                                value      : in KDF9.word;
   255.                                was_stored : out Boolean) is
   256.    begin
   257.       if poke_list_count < length_of_poke_list then
   258.          poke_list_count := poke_list_count + 1;
   259.          poke_list(poke_list_count) := (address, sub_word, position, value);
   260.          was_stored := True;
   261.       else
   262.          was_stored := False;
   263.       end if;
   264.    end add_to_poke_list;
   265.
   266.    procedure poke_all_amendments is
   267.    begin
   268.       for p in 1..poke_list_count loop
   269.          poke(poke_list(p).address, poke_list(p).sub_word, poke_list(p).position, poke_list(p).value);
   270.       end loop;
   271.       poke_list_count := 0;
   272.    end poke_all_amendments;
   273.
   274. end dumping;

Compiling: ../Source/dumping.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:22

     1. -- dumping.ads
     2. --
     3. -- Provide support for diagnostic core-dumping area descriptions.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with generic_sets;
    20. with KDF9;
    21.
    22. use  KDF9;
    23.
    24. package dumping is
    25.
    26.    type flag is new Character range '@' .. 'Z';
    27.
    28.    no_flag        : constant dumping.flag := '@';
    29.    ASCII_flag     : constant dumping.flag := 'A';
    30.    card_code_flag : constant dumping.flag := 'C';
    31.    decimal_flag   : constant dumping.flag := 'D';
    32.    single_flag    : constant dumping.flag := 'E';
    33.    final_flag     : constant dumping.flag := 'F';
    34.    half_flag      : constant dumping.flag := 'H';
    35.    initial_flag   : constant dumping.flag := 'I';
    36.    normal_flag    : constant dumping.flag := 'N';
    37.    orders_flag    : constant dumping.flag := 'O';
    38.    printer_flag   : constant dumping.flag := 'L';
    39.    shift_flag     : constant dumping.flag := 'S';
    40.    tape_code_flag : constant dumping.flag := 'T';
    41.    Usercode_flag  : constant dumping.flag := 'U';
    42.    word_flag      : constant dumping.flag := 'W';
    43.    expunge_flag   : constant dumping.flag := 'X';
    44.
    45.    function dumping_flag (c : Character)
    46.    return dumping.flag;
    47.
    48.    package flag_support is new generic_sets(member => dumping.flag);
    49.
    50.    subtype format_set is flag_support.set;
    51.    use type format_set;
    52.
    53.    is_parameter_flag : constant dumping.format_set
    54.                      := (  decimal_flag
    55.                          | single_flag
    56.                          | half_flag
    57.                          | ASCII_flag
    58.                          | orders_flag
    59.                          | printer_flag
    60.                          | tape_code_flag
    61.                          | Usercode_flag
    62.                          | card_code_flag
    63.                          | normal_flag
    64.                          | shift_flag
    65.                          | word_flag     => True,
    66.                            others        => False
    67.                         );
    68.
    69.
    70.    is_epoch_flag : constant dumping.format_set
    71.                  := (  initial_flag
    72.                      | final_flag => True,
    73.                        others     => False
    74.                     );
    75.
    76.    is_dumping_flag  : constant dumping.format_set
    77.                     := is_parameter_flag or is_epoch_flag;
    78.
    79.    no_dumping_flag  : constant dumping.format_set
    80.                     := flag_support.empty_set;
    81.
    82.    nr_of_dumping_areas : constant := 100;
    83.    subtype area_count  is Natural  range 0 .. nr_of_dumping_areas;
    84.    subtype area_number is Positive range 1 .. nr_of_dumping_areas;
    85.
    86.    procedure request_a_dumping_area (format_set  : in dumping.format_set;
    87.                                      first, last : in KDF9.address;
    88.                                      was_stored  : out Boolean);
    89.
    90.    procedure remove_specified_areas (format_set  : in dumping.format_set;
    91.                                      first, last : in KDF9.address);
    92.
    93.    procedure print_prerun_dump_areas;
    94.
    95.    procedure remove_prerun_dump_areas;
    96.
    97.    procedure print_postrun_dump_areas;
    98.
    99.    procedure remove_postrun_dump_areas;
   100.
   101.    function nr_of_pre_dumping_areas
   102.    return dumping.area_count;
   103.
   104.    function nr_of_post_dumping_areas
   105.    return dumping.area_count;
   106.
   107.    no_specification : constant String := "";
   108.
   109.    -- area_image returns no_specification if area(d) is undefined or empty.
   110.    function area_image (d : dumping.area_number)
   111.    return String;
   112.
   113.    -- format_image returns blanks if format_set is empty.
   114.    function format_image (format_set : dumping.format_set)
   115.    return String;
   116.
   117.    -- poke support is in dumping because it is needed at the same time during initialization.
   118.    -- was_stored := (the requested poke could not be saved); because the list is full.
   119.    procedure add_to_poke_list (address    : in KDF9.address;
   120.                                sub_word   : in Character;
   121.                                position   : in KDF9.address;
   122.                                value      : in KDF9.word;
   123.                                was_stored : out Boolean);
   124.
   125.    -- poke_all_amendments effects all stored pokes and then clears the poke list for reuse.
   126.    procedure poke_all_amendments;
   127.
   128. end dumping;

 274 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/kdf9.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:23

     1. -- kdf9.adb
     2. --
     3. -- The machine-state manipulations used by the CPU microcode.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Unchecked_Conversion;
    20. --
    21. with exceptions;
    22. with KDF9.decoding;
    23. with KDF9.CPU;
    24. with KDF9.PHU_store;
    25. with KDF9.store;
    26. with settings;
    27. with tracing;
    28.
    29. use  exceptions;
    30. use  KDF9.decoding;
    31. use  KDF9.CPU;
    32. use  KDF9.PHU_store;
    33. use  KDF9.store;
    34. use  settings;
    35. use  tracing;
    36.
    37. package body KDF9 is
    38.
    39.    C_part_scale : constant := 2**32;
    40.    I_part_scale : constant := 2**16;
    41.
    42.    function as_Q (the_word : KDF9.word)
    43.    return KDF9.Q_register
    44.    is (
    45.        (C => KDF9.Q_part(KDF9.word'(the_word / C_part_scale)),
    46.         I => KDF9.Q_part(KDF9.word'(the_word / I_part_scale) and Q_part_mask),
    47.         M => KDF9.Q_part(the_word and Q_part_mask)
    48.        )
    49.       );
    50.
    51.    function as_word (the_Q : KDF9.Q_register)
    52.    return KDF9.word
    53.    is (KDF9.word(the_Q.C)*C_part_scale + KDF9.word(the_Q.I)*I_part_scale + KDF9.word(the_Q.M));
    54.
    55.    function sign_extended (Q : KDF9.Q_part)
    56.    return KDF9.word
    57.    is (unsign(CPU.signed(resign(Q))));
    58.
    59.    function as_word (the_link : KDF9.sjns_link)
    60.    return KDF9.word is
    61.       function link_Q_part is new Ada.Unchecked_Conversion(KDF9.sjns_link, KDF9.Q_part);
    62.    begin
    63.       return KDF9.word(link_Q_part(the_link));
    64.    end as_word;
    65.
    66.    function as_link (the_word : KDF9.word)
    67.    return KDF9.sjns_link is
    68.       function Q_part_link is new Ada.Unchecked_Conversion(KDF9.Q_part, KDF9.sjns_link);
    69.    begin
    70.       return Q_part_link(KDF9.Q_part(the_word and Q_part_mask));
    71.    end as_link;
    72.
    73.    procedure ensure_that_the_sjns_is_not_empty is
    74.    begin
    75.       if the_sjns_depth > 0             or else
    76.             the_CPU_state = Director_state then
    77.          return;
    78.       end if;
    79.       effect(NOUV_interrupt, "empty SJNS");
    80.    end ensure_that_the_sjns_is_not_empty;
    81.
    82.    procedure ensure_that_the_sjns_is_not_full is
    83.    begin
    84.       if the_sjns_depth < 16             or else
    85.             the_CPU_state = Director_state  then
    86.          return;
    87.       end if;
    88.       effect(NOUV_interrupt, "full SJNS");
    89.    end ensure_that_the_sjns_is_not_full;
    90.
    91.    procedure push (the_link : in KDF9.syllable_address) is
    92.    begin
    93.       the_sjns(the_sjns_depth) := KDF9.sjns_link(the_link);
    94.       the_sjns_depth := the_sjns_depth + 1;
    95.    end push;
    96.
    97.    function pop
    98.    return KDF9.syllable_address is
    99.    begin
   100.       the_sjns_depth := the_sjns_depth - 1;
   101.       return KDF9.syllable_address(the_sjns(the_sjns_depth));
   102.    end pop;
   103.
   104.    function sjns_top
   105.    return KDF9.sjns_link
   106.    is (the_sjns(the_sjns_depth-1));
   107.
   108.    function words_needed (need : KDF9.nest_depth)
   109.    return String
   110.    is ("NEST lacks" & need'Image & " operand" & (if need > 1 then "s" else ""));
   111.
   112.    procedure ensure_that_the_nest_holds (at_least : in KDF9.nest_depth) is
   113.    begin
   114.       if the_nest_depth >= at_least          or else
   115.             the_CPU_state = Director_state      then
   116.          return;
   117.       end if;
   118.       effect(NOUV_interrupt, words_needed(need => at_least-the_nest_depth));
   119.    end ensure_that_the_nest_holds;
   120.
   121.    procedure ensure_that_the_nest_holds_an_operand is
   122.    begin
   123.       ensure_that_the_nest_holds (at_least => 1);
   124.    end ensure_that_the_nest_holds_an_operand;
   125.
   126.    procedure ensure_that_the_nest_holds_2_operands is
   127.    begin
   128.       ensure_that_the_nest_holds (at_least => 2);
   129.    end ensure_that_the_nest_holds_2_operands;
   130.
   131.    function space_needed (need : KDF9.nest_depth)
   132.    return String
   133.    is (if need = 1 then "full NEST" else "NEST too full for" & need'Image & " operands");
   134.
   135.    procedure ensure_that_the_nest_has_room_for (at_least : in KDF9.nest_depth) is
   136.    begin
   137.       if the_nest_depth <= 16-at_least     or else
   138.             the_CPU_state = Director_state    then
   139.          return;
   140.       end if;
   141.       effect(NOUV_interrupt, space_needed(need => at_least - (16-the_nest_depth)));
   142.    end ensure_that_the_nest_has_room_for;
   143.
   144.    procedure ensure_that_the_nest_has_room_for_a_result is
   145.    begin
   146.       ensure_that_the_nest_has_room_for (at_least => 1);
   147.    end ensure_that_the_nest_has_room_for_a_result;
   148.
   149.    procedure ensure_that_the_nest_has_room_for_2_results is
   150.    begin
   151.       ensure_that_the_nest_has_room_for (at_least => 2);
   152.    end ensure_that_the_nest_has_room_for_2_results;
   153.
   154.    procedure push (the_word : in KDF9.word) is
   155.    begin
   156.       the_nest(the_nest_depth) := the_word;
   157.       the_nest_depth := the_nest_depth + 1;
   158.    end push;
   159.
   160.    function pop
   161.    return KDF9.word is
   162.    begin
   163.       return result : constant KDF9.word := the_nest(the_nest_depth - 1) do
   164.          the_nest(the_nest_depth - 1) := 0;
   165.          the_nest_depth := the_nest_depth - 1;
   166.       end return;
   167.    end pop;
   168.
   169.    procedure pop is
   170.    begin
   171.       the_nest(the_nest_depth - 1) := 0;
   172.       the_nest_depth := the_nest_depth - 1;
   173.    end pop;
   174.
   175.    function read_top
   176.    return KDF9.word
   177.    is (the_nest(the_nest_depth-1));
   178.
   179.    procedure write_top (the_word : in KDF9.word) is
   180.    begin
   181.       the_nest(the_nest_depth-1) := the_word;
   182.    end write_top;
   183.
   184.    procedure push (the_pair : in KDF9.pair) is
   185.    begin
   186.       the_nest(the_nest_depth+0) := the_pair.lsw;
   187.       the_nest(the_nest_depth+1) := the_pair.msw;
   188.       the_nest_depth := the_nest_depth + 2;
   189.    end push;
   190.
   191.    function pop
   192.    return KDF9.pair is
   193.    begin
   194.       return result : constant KDF9.pair := (msw => the_nest(the_nest_depth-1),
   195.                                              lsw => the_nest(the_nest_depth-2)) do
   196.          the_nest(the_nest_depth-1) := 0;
   197.          the_nest(the_nest_depth-2) := 0;
   198.          the_nest_depth := the_nest_depth - 2;
   199.       end return;
   200.    end pop;
   201.
   202.    function read_top
   203.    return KDF9.pair
   204.    is ((msw => the_nest(the_nest_depth-1), lsw => the_nest(the_nest_depth-2)));
   205.
   206.    procedure write_top (the_pair : in KDF9.pair) is
   207.    begin
   208.       the_nest(the_nest_depth-1) := the_pair.msw;
   209.       the_nest(the_nest_depth-2) := the_pair.lsw;
   210.    end write_top;
   211.
   212.
   213. --
   214.    -- Support for Director-only operations.
   215. --
   216.
   217.    -- Set BA (bits D38:47), CPL (D34:35) and NOL (D24:33).
   218.
   219.    procedure set_K1_register (setting : in KDF9.word) is
   220.    begin
   221.       BA  := KDF9.address(setting mod 2**10) * 2**5;
   222.       CPL := KDF9.priority((setting / 2**12) and 2#11#);
   223.       NOL := KDF9.address((setting / 2**14) mod 2**10) * 2**5 + 31;
   224.    end set_K1_register;
   225.
   226.    -- Set CPDAR (bits D32:47).
   227.
   228.    procedure set_K2_register (setting : in KDF9.word) is
   229.       CPDAR_Q : KDF9.Q_part := as_Q(setting).M;
   230.    begin
   231.       for i in KDF9.buffer_number loop
   232.          the_CPDAR(i) := (CPDAR_Q mod 2) = 1;
   233.          CPDAR_Q := CPDAR_Q / 2;
   234.       end loop;
   235.    end set_K2_register;
   236.
   237.    -- Set context (bits D0:1), nest_depth (D2:6) and sjns_depth (D7:11).
   238.
   239.    procedure set_K3_register (setting : in KDF9.word) is
   240.    begin
   241.       -- Save the current register values in the register bank.
   242.       register_bank(the_context).NEST := the_nest;
   243.       register_bank(the_context).SJNS := the_sjns;
   244.       register_bank(the_context).Q_store := the_Q_store;
   245.       -- Set the new context.
   246.       the_context := KDF9.context(KDF9.word'(setting / 2**46));
   247.       the_nest_depth := KDF9.nest_depth(setting / 2**41 mod 2**5);
   248.       the_sjns_depth := KDF9.sjns_depth(setting / 2**36 mod 2**5);
   249.       -- Restore the register values for the new context.
   250.       the_nest := register_bank(the_context).NEST;
   251.       the_sjns := register_bank(the_context).SJNS;
   252.       the_Q_store := register_bank(the_context).Q_store;
   253.    end set_K3_register;
   254.
   255.    a_jiffy : constant := 1.0 / 2.0**20;  -- a bit less than a microsecond
   256.
   257.    type seconds is delta a_jiffy range 0.0 .. 1000.0*366.0*24.0*3600.0;  -- 1000 leap years!
   258.
   259.    procedure update_the_elapsed_time;
   260.
   261.    -- Let the real elapsed time catch up with the_real_time virtual seconds.
   262.
   263.    procedure delay_until (the_real_time : in KDF9.us) is
   264.       quantum : constant seconds := seconds(2**10) * a_jiffy;  -- ca. TR character-read time of 1ms
   265.       the_lag : seconds;
   266.    begin
   267.        if the_real_time < the_last_delay_time then
   268.           the_last_delay_time := the_real_time;
   269.        end if;
   270.       the_lag := seconds(the_real_time - the_last_delay_time) * a_jiffy;
   271.       if the_lag >= quantum then  -- More than a quantum of virtual elapsed time has passed.
   272.          delay Duration(the_lag);
   273.          the_last_delay_time := the_real_time;
   274.       end if;
   275.      -- the_elapsed_time := the_real_time;
   276.       update_the_elapsed_time;
   277.    end delay_until;
   278.
   279.    procedure delay_by (the_delay_time : in KDF9.us) is
   280.    begin
   281.       if authentic_timing_is_enabled then
   282.          delay_until(the_clock_time + the_delay_time);
   283.       end if;
   284.    end delay_by;
   285.
   286.    -- Advance to the larger of the_CPU_time, the_elapsed_time, and the_last_delay_time.
   287.    -- Cap the increase to prevent a spurious double-clock (RESET) interrupt in Director.
   288.
   289.    procedure update_the_elapsed_time is
   290.       max_elapsed_time : constant KDF9.us := the_last_K4_time + 2**20 - 1;
   291.    begin
   292.       the_elapsed_time := KDF9.us'Max(the_elapsed_time, the_last_delay_time);
   293.       the_elapsed_time := KDF9.us'Max(the_elapsed_time, the_CPU_time);
   294.       if the_execution_mode = boot_mode and the_CPU_state = Director_state then
   295.          the_elapsed_time := KDF9.us'Min(the_elapsed_time, max_elapsed_time);
   296.       end if;
   297.    end update_the_elapsed_time;
   298.
   299.    -- The virtual elapsed time.
   300.
   301.    function the_clock_time
   302.    return KDF9.us is
   303.    begin
   304.       update_the_elapsed_time;
   305.       return the_elapsed_time;
   306.    end the_clock_time;
   307.
   308.    procedure advance_the_clock (past : in KDF9.us) is
   309.    begin
   310.       the_elapsed_time := KDF9.us'Max(the_elapsed_time, past);
   311.       update_the_elapsed_time;
   312.       if authentic_timing_is_enabled then
   313.          delay_until(the_elapsed_time);
   314.       end if;
   315.    end advance_the_clock;
   316.
   317.    procedure synchronize_the_real_and_virtual_times is
   318.    begin
   319.       if authentic_timing_is_enabled then
   320.          update_the_elapsed_time;
   321.          delay_until(the_elapsed_time);
   322.       end if;
   323.    end synchronize_the_real_and_virtual_times;
   324.
   325.    -- Get clock (bits D0:15) and RFIR (D16:31).
   326.
   327.    function get_K4_operand
   328.    return KDF9.word is
   329.
   330.       function RFIR_in_a_word
   331.       return KDF9.word is
   332.          result : KDF9.word := 0;
   333.       begin
   334.          for r of the_RFIR loop
   335.             result := result*2;
   336.             if r then
   337.                result := result or 1;
   338.             end if;
   339.          end loop;
   340.          return result;
   341.       end RFIR_in_a_word;
   342.
   343.       -- The KDF9's interval timing clock ticks once per 32 µs;
   344.       --    the emulator virtual time has a resolution of 1 µs.
   345.
   346.       time_now : constant KDF9.us := the_clock_time;
   347.       interval : constant KDF9.us := (time_now - the_last_K4_time);
   348.
   349.    begin
   350.       the_last_K4_time := time_now;
   351.       if interval / 32 >= 2**16 then
   352.          effect(RESET_interrupt, "double clock");
   353.          the_RFIR(RESET_interrupt) := True;
   354.       elsif interval / 32 >= 2**15 then
   355.          effect(CLOCK_interrupt, "time since a K4" & interval'Image & "us");
   356.          the_RFIR(CLOCK_interrupt) := True;  --?? why is this needed?
   357.       end if;
   358.       return (KDF9.word(interval / 32) * 2**32) or (RFIR_in_a_word * 2**16);
   359.    end get_K4_operand;
   360.
   361.    -- Get PHUi (bits D6i:6i+5, i = 0 .. 3).
   362.
   363.    function get_K5_operand
   364.    return KDF9.word
   365.    is (K5_operand);
   366.
   367.    -- Get context (bits D0:1), nest_depth (D2:6) and sjns_depth (D7:11).
   368.
   369.    function get_K7_operand
   370.    return KDF9.word
   371.    is (
   372.        (KDF9.word(the_context)    * 2**46) or
   373.        (KDF9.word(the_nest_depth) * 2**41) or
   374.        (KDF9.word(the_sjns_depth) * 2**36)
   375.       );
   376.
   377.    procedure reset_the_internal_registers (the_new_state : in CPU_state) is
   378.    begin
   379.       -- Set the state of a newly bootstrapped CPU.
   380.       the_V_bit_is_set := False;
   381.       the_T_bit_is_set := False;
   382.       CIA := (0, 0);
   383.       CPL := 0;
   384.       BA  := 0;
   385.       NOL := max_address;
   386.       the_RFIR := (others => False);
   387.       ICR := 0;
   388.       the_CPU_time := 0;
   389.       the_elapsed_time := 0;
   390.       the_last_delay_time := 0;
   391.       the_last_K4_time := 0;
   392.       the_CPU_state := the_new_state;
   393.       the_CPDAR := (0 => True, others => False);  -- FW0 is always allocated.
   394.    end reset_the_internal_registers;
   395.
   396.    empty_nest : constant NEST := (others => 0);
   397.    empty_sjns : constant SJNS := (others => (0, 0));
   398.    empty_Q_s  : constant Q_store := (others => (0, 0, 0));
   399.
   400.    procedure reset_the_CPU_state is
   401.    begin
   402.       the_context := 0;
   403.       for bank of register_bank loop
   404.          bank := (NEST => empty_nest, SJNS => empty_sjns, Q_store => empty_Q_s);
   405.       end loop;
   406.       the_nest_depth := 0;
   407.       the_nest       := empty_nest;
   408.       the_sjns_depth := 0;
   409.       the_sjns       := empty_sjns;
   410.       the_Q_store    := empty_Q_s;
   411.       if the_execution_mode = program_mode then
   412.          reset_the_internal_registers(program_state);
   413.       else
   414.          reset_the_internal_registers(Director_state);
   415.       end if;
   416.       -- Setting NIA must follow program loading, as it fetches E0 into the IWBs.
   417.       set_NIA_to((0, 0));
   418.    end reset_the_CPU_state;
   419.
   420.    procedure reset_the_program_state is
   421.    begin
   422.       the_nest_depth := 0;
   423.       the_nest       := empty_nest;
   424.       the_sjns_depth := 0;
   425.       the_sjns := empty_sjns;
   426.       the_V_bit_is_set := False;
   427.       the_T_bit_is_set := False;
   428.       the_CPDAR := (0 => True, others => False);  -- FW0 is always allocated.
   429.       -- Setting NIA must follow program loading, as it fetches E0 into the IWBs.
   430.       set_NIA_to((0, 0));
   431.    end reset_the_program_state;
   432.
   433.    procedure effect (this_interrupt : in KDF9.interrupt_number; message : in String := "") is
   434.       return_address : KDF9.syllable_address;
   435.    begin
   436.       take_note_of_interrupt(this_interrupt, message);
   437.       the_RFIR(this_interrupt) := True;
   438.       case the_execution_mode is
   439.          when boot_mode =>
   440.             -- Interrupts are either effected or deferred to Director.
   441.             if the_CPU_state = program_state or else this_interrupt = RESET_interrupt then
   442.                -- Effect an actual interrupt into Director.
   443.                if this_interrupt in LOV_interrupt | OUT_interrupt then
   444.                   return_address := CIA;  -- Restart the interrupted instruction.
   445.                else
   446.                   return_address := NIA;  -- Proceed after the interrupted instruction.
   447.                end if;
   448.                if the_sjns_depth < 16 then
   449.                   push(return_address);                  -- The program link fits into the SJNS.
   450.                else
   451.                   JB := KDF9.sjns_link(return_address);  -- The program link overwrites JB.
   452.                end if;
   453.                BA := 0;
   454.                fetching_normally := True;
   455.                set_NIA_to((0, 0));
   456.                the_CPU_state := Director_state;
   457.                raise abandon_this_order;
   458.             else
   459.                -- Defer: Director will eventually find any request left in the_RFIR.
   460.                -- NOUV is completely suppressed in Director state.
   461.                the_RFIR(NOUV_interrupt) := False;
   462.             end if;
   463.
   464.          when test_program_mode =>
   465.             -- Interrupts other than LOV and RESET are ignored.
   466.             -- There is no need to accurately emulate the address placed by the hardware in JB.
   467.             case this_interrupt is
   468.                when LOV_interrupt =>
   469.                   raise LOV_trap with message;
   470.                when RESET_interrupt =>
   471.                   raise RESET_trap with message;
   472.                when others =>
   473.                   null;
   474.             end case;
   475.
   476.          when program_mode =>
   477.             -- Interrupts other than LOV are treated as failures.
   478.             -- There is no need to accurately emulate the address placed by the hardware in JB.
   479.             case this_interrupt is
   480.                when PR_interrupt =>
   481.                   raise PR_trap with message;
   482.                when FLEX_interrupt =>
   483.                   raise FLEX_trap with message;
   484.                when LIV_interrupt =>
   485.                   raise LIV_trap with message;
   486.                when NOUV_interrupt =>
   487.                   raise NOUV_trap with message;
   488.                when EDT_interrupt =>
   489.                   raise EDT_trap with message;
   490.                when OUT_interrupt =>
   491.                   raise OUT_trap with message;
   492.                when LOV_interrupt =>
   493.                   raise LOV_trap with message;
   494.                when RESET_interrupt =>
   495.                   raise RESET_trap with message;
   496.                when others =>
   497.                   raise emulation_failure with "invalid RFI in KDF9.effect";
   498.             end case;
   499.       end case;
   500.    end effect;
   501.
   502.    procedure effect_clock_interrupt (interval : in KDF9.us)
   503.       with Inline => False;
   504.
   505.    procedure effect_clock_interrupt (interval : in KDF9.us) is
   506.    begin
   507.       effect(CLOCK_interrupt, interval'Image & " KDF9 us");
   508.    end effect_clock_interrupt;
   509.
   510.    procedure check_for_a_clock_interrupt is
   511.       interval : KDF9.us;
   512.    begin
   513.       -- Clock ticks are ignored in program_mode and test_program_mode.
   514.       -- In boot_mode:
   515.       --    they are actioned in program_state;
   516.       --    they are deferred in Director_state: Director will eventually find the time for itself.
   517.       if the_execution_mode = boot_mode and then
   518.             the_CPU_state = program_state   then
   519.          interval := (the_clock_time - the_last_K4_time);
   520.          if interval >= 2**20 then
   521.             effect_clock_interrupt(interval);
   522.          end if;
   523.       end if;
   524.    end check_for_a_clock_interrupt;
   525.
   526.    procedure fail_in_problem_program_state is
   527.    begin
   528.       case the_execution_mode is
   529.          when program_mode =>
   530.             -- The unprivileged program has attempted a privileged operation.
   531.             raise LIV_trap with "%Director-only instruction";
   532.          when test_program_mode =>
   533.             -- The privileged program is allowed to use privileged instructions.
   534.             return;
   535.          when boot_mode =>
   536.             if the_CPU_state = program_state then
   537.                -- Punt the error to Director.
   538.                effect(LIV_interrupt);
   539.             else
   540.                -- All privileged operations are permitted to Director.
   541.                return;
   542.             end if;
   543.       end case;
   544.    end fail_in_problem_program_state;
   545.
   546.    procedure LOV_if_user_mode (device_name : in String) is
   547.    begin
   548.       -- LOV was TOTALLY suppressed in Director state.
   549.       if the_CPU_state /= Director_state then
   550.          set_NIA_to(CIA);
   551.          effect(LOV_interrupt, device_name);
   552.       end if;
   553.    end LOV_if_user_mode;
   554.
   555.    -- The %  prepended to the_message aids parsing of exception error messages in failure shutdown.
   556.
   557.    procedure trap_illegal_instruction (the_message : in String := "invalid opcode") is
   558.    begin
   559.       -- The program has failed in a manner that could cause a LIV interrupt.
   560.       case the_execution_mode is
   561.          when program_mode
   562.             | test_program_mode =>
   563.             raise LIV_trap with "%" & the_message;
   564.          when boot_mode =>
   565.             if the_CPU_state = program_state then
   566.                -- Punt the problem to Director.
   567.                effect(LIV_interrupt, the_message);
   568.             else
   569.                -- The Director itself has gone seriously wrong.
   570.                -- LIV is impossible in Director, so ee9 takes responsibility for stopping the run
   571.                --    to avert consequential emulation failure.
   572.                raise Director_failure with "%" & the_message;
   573.             end if;
   574.       end case;
   575.    end trap_illegal_instruction;
   576.
   577.    procedure trap_operator_error (the_device, the_message : in String) is
   578.    begin
   579.       -- The program has failed for a reason, such as a misconfigured environment,
   580.       --    that is beyond its control and prevents further execution.
   581.       raise operator_error with "%" & the_device & " " & the_message;
   582.    end trap_operator_error;
   583.
   584.    procedure trap_unimplemented_feature (the_message : in String) is
   585.    begin
   586.       -- The program has attempted to use something that ee9 does not (yet) support.
   587.       raise not_yet_implemented with "%" & the_message;
   588.    end trap_unimplemented_feature;
   589.
   590.    procedure fail_OUT (OUT_number : in KDF9.word; the_message : in String) is
   591.       OUT_name : constant String := "%OUT" & OUT_number'Image & ": ";
   592.    begin
   593.       raise IO_error with OUT_name & the_message;
   594.    end fail_OUT;
   595.
   596.    procedure trap_invalid_paper_tape (the_message : in String) is
   597.    begin
   598.       -- The paper tape file given to load or boot has defects.
   599.       raise invalid_paper_tape_file with "%" & the_message;
   600.    end trap_invalid_paper_tape;
   601.
   602.    procedure return_from_Director_to (new_IAR : in KDF9.syllable_address) is
   603.    begin
   604.       the_CPU_state := program_state;
   605.       set_NIA_to(new_IAR);
   606.    end return_from_Director_to;
   607.
   608.    procedure increment_by_1 (the_link : in out KDF9.syllable_address) is
   609.    begin
   610.       if the_link.syllable_index < 5 then
   611.          the_link.syllable_index := the_link.syllable_index + 1;
   612.       else
   613.          the_link.syllable_index := 0;
   614.          the_link.order_word_number     := the_link.order_word_number + 1;
   615.       end if;
   616.    end increment_by_1;
   617.
   618.    procedure increment_by_2 (the_link : in out KDF9.syllable_address) is
   619.    begin
   620.       if the_link.syllable_index < 4 then
   621.          the_link.syllable_index := the_link.syllable_index + 2;
   622.       else
   623.          the_link.syllable_index := the_link.syllable_index - 4;
   624.          the_link.order_word_number     := the_link.order_word_number + 1;
   625.       end if;
   626.    end increment_by_2;
   627.
   628.    procedure increment_by_3 (the_link : in out KDF9.syllable_address) is
   629.    begin
   630.       if the_link.syllable_index < 3 then
   631.          the_link.syllable_index := the_link.syllable_index + 3;
   632.       else
   633.          the_link.syllable_index := the_link.syllable_index - 3;
   634.          the_link.order_word_number     := the_link.order_word_number + 1;
   635.       end if;
   636.    end increment_by_3;
   637.
   638.    -- the_syllable_cache holds two instruction words, pre-split into syllables.
   639.    -- They would have been held in IWB0 and IWB1 by Main Control in the KDF9.
   640.
   641.    subtype syllable_cache_range is Natural range 0 .. 11;
   642.
   643.    the_syllable_cache  : array (syllable_cache_range) of KDF9.syllable;
   644.    the_cache_index     : syllable_cache_range   := 0;
   645.    the_cached_location : KDF9.order_word_number := 0;
   646.
   647.    function NIA
   648.    return KDF9.syllable_address
   649.    is (
   650.        if the_cache_index > 5 then
   651.           (the_cached_location, KDF9.syllable_index(the_cache_index-6))
   652.        else
   653.           (the_cached_location-1, KDF9.syllable_index(the_cache_index))
   654.       );
   655.
   656.    function NIA_word_number
   657.    return KDF9.order_word_number
   658.    is (the_cached_location - (if the_cache_index > 5 then 0 else 1));
   659.
   660.    procedure trap_an_invalid_order_address (new_NIA : in KDF9.syllable_address)
   661.       with Inline => False;
   662.
   663.    procedure trap_an_invalid_order_address (new_NIA : in KDF9.syllable_address) is
   664.    begin
   665.       if new_NIA.syllable_index = 6 then
   666.          effect(RESET_interrupt, "syllable number = 6");
   667.       elsif new_NIA.syllable_index = 7 then
   668.          effect(RESET_interrupt, "syllable number = 7");
   669.       else
   670.          effect(LIV_interrupt, "jump to 8191");  -- See EE Report K/GD y 82.
   671.       end if;
   672.    end trap_an_invalid_order_address;
   673.
   674.    procedure set_NIA_to (new_NIA : in KDF9.syllable_address) is
   675.       mask        : constant := 8#377#;
   676.       shift       : constant := 8#400#;
   677.       IWB0, IWB1  : KDF9.word;
   678.    begin
   679.       if new_NIA.order_word_number = 8191 or else
   680.             new_NIA.syllable_index > 5       then
   681.          trap_an_invalid_order_address(new_NIA);
   682.       end if;
   683.
   684.       IWB0 := fetch_word(KDF9.address(new_NIA.order_word_number) + 0);
   685.       IWB1 := fetch_word(KDF9.address(new_NIA.order_word_number) + 1);
   686.
   687.       the_cache_index := syllable_cache_range(new_NIA.syllable_index);
   688.       the_cached_location := new_NIA.order_word_number + 1;
   689.
   690.       the_syllable_cache(5+0) := KDF9.syllable(IWB0 and mask);
   691.       IWB0 := IWB0 / shift;
   692.       the_syllable_cache(4+0) := KDF9.syllable(IWB0 and mask);
   693.       IWB0 := IWB0 / shift;
   694.       the_syllable_cache(3+0) := KDF9.syllable(IWB0 and mask);
   695.       IWB0 := IWB0 / shift;
   696.       the_syllable_cache(2+0) := KDF9.syllable(IWB0 and mask);
   697.       IWB0 := IWB0 / shift;
   698.       the_syllable_cache(1+0) := KDF9.syllable(IWB0 and mask);
   699.       IWB0 := IWB0 / shift;
   700.       the_syllable_cache(0+0) := KDF9.syllable(IWB0);
   701.
   702.       the_syllable_cache(5+6) := KDF9.syllable(IWB1 and mask);
   703.       IWB1 := IWB1 / shift;
   704.       the_syllable_cache(4+6) := KDF9.syllable(IWB1 and mask);
   705.       IWB1 := IWB1 / shift;
   706.       the_syllable_cache(3+6) := KDF9.syllable(IWB1 and mask);
   707.       IWB1 := IWB1 / shift;
   708.       the_syllable_cache(2+6) := KDF9.syllable(IWB1 and mask);
   709.       IWB1 := IWB1 / shift;
   710.       the_syllable_cache(1+6) := KDF9.syllable(IWB1 and mask);
   711.       IWB1 := IWB1 / shift;
   712.       the_syllable_cache(0+6) := KDF9.syllable(IWB1);
   713.    end set_NIA_to;
   714.
   715.    procedure set_NIA_to_the_INS_target_address is
   716.    begin
   717.       set_NIA_to(INS.target);
   718.    end set_NIA_to_the_INS_target_address;
   719.
   720.    procedure set_IWB0_and_IWB1_for_a_JCqNZS_loop is
   721.    begin
   722.       set_NIA_to((order_word_number => CIA.order_word_number-1, syllable_index => 0));
   723.       fetching_normally := False;
   724.    end set_IWB0_and_IWB1_for_a_JCqNZS_loop;
   725.
   726.    procedure go_back_to_the_start_of_IWB0 is
   727.    begin
   728.       the_cache_index := 0;
   729.    end go_back_to_the_start_of_IWB0;
   730.
   731.    procedure continue_after_JCqNZS is
   732.    begin
   733.       if CIA.syllable_index = 4 and the_cached_location = CIA.order_word_number then
   734.          set_NIA_to((order_word_number => CIA.order_word_number+1, syllable_index => 0));
   735.       end if;
   736.       fetching_normally := True;
   737.    end continue_after_JCqNZS;
   738.
   739.    function next_order_syllable
   740.    return KDF9.syllable
   741.       with Inline;
   742.
   743.    -- The amount by which the_CPU_time is increased, for a refill of both Instruction Word Buffers.
   744.
   745.    the_IWB01_reload_time : constant KDF9.us := 7;  -- microseconds
   746.
   747.    function next_order_syllable
   748.    return KDF9.syllable is
   749.       the_next_syllable : KDF9.syllable;
   750.    begin
   751.       the_next_syllable := the_syllable_cache(the_cache_index);
   752.       if the_cache_index < 11 then
   753.          the_cache_index := the_cache_index + 1;
   754.       elsif fetching_normally then
   755.          set_NIA_to((order_word_number => CIA.order_word_number+1, syllable_index => 0));
   756.          -- Part-overlapped order-word fetch: can happen only once per instruction,
   757.          --    and only before the instruction is executed, so no need to ADD to the_CPU_delta.
   758.          if (CIA.order_word_number and 15) < 10 then
   759.             -- The fudge factor applied here gives the Whetstone Benchmark its historical run time.
   760.             the_CPU_delta := the_IWB01_reload_time + 1;
   761.          else
   762.             the_CPU_delta := the_IWB01_reload_time;
   763.          end if;
   764.       else
   765.          go_back_to_the_start_of_IWB0;
   766.       end if;
   767.       return the_next_syllable;
   768.    end next_order_syllable;
   769.
   770.    procedure decode_syllable_0 (decoded : in out KDF9.decoded_order)
   771.       with Inline;
   772.
   773.    procedure decode_syllable_1 (decoded : in out KDF9.decoded_order)
   774.       with Inline;
   775.
   776.    procedure decode_a_jump_order (decoded : in out KDF9.decoded_order)
   777.       with Inline;
   778.
   779.    procedure decode_a_store_access_order (decoded : in out KDF9.decoded_order)
   780.       with Inline;
   781.
   782.    procedure decode_a_set_literal_order (decoded : in out KDF9.decoded_order)
   783.       with Inline;
   784.
   785.    procedure decode_syllable_0 (decoded : in out KDF9.decoded_order) is
   786.    begin
   787.       decoded.compressed_opcode := decoded.order.syllable_0 and 8#77#;
   788.       decoded.kind := KDF9.INS_kind(decoded.order.syllable_0 / 2**6);
   789.    end decode_syllable_0;
   790.
   791.    procedure process_syllable_0_of_INS is
   792.    begin
   793.       if the_cache_index > 5 then
   794.          CIA.order_word_number := the_cached_location;
   795.          CIA.syllable_index   := KDF9.syllable_index(the_cache_index-6);
   796.       else
   797.          CIA.order_word_number := the_cached_location - 1;
   798.          CIA.syllable_index   := KDF9.syllable_index(the_cache_index);
   799.       end if;
   800.       INS.order.syllable_0 := next_order_syllable;
   801.       INS.compressed_opcode := INS.order.syllable_0 and 8#77#;
   802.       INS.kind := KDF9.INS_kind(INS.order.syllable_0 / 2**6);
   803.    end process_syllable_0_of_INS;
   804.
   805.    procedure decode_syllable_1 (decoded : in out KDF9.decoded_order) is
   806.    begin
   807.       decoded.Qq := KDF9.Q_number(decoded.order.syllable_1 / 2**4);
   808.       decoded.Qk := KDF9.Q_number(decoded.order.syllable_1 and 8#17#);
   809.    end decode_syllable_1;
   810.
   811.    procedure process_syllable_1_of_INS is
   812.    begin
   813.       INS.order.syllable_1 := next_order_syllable;
   814.       INS.Qq := KDF9.Q_number(INS.order.syllable_1 / 2**4);
   815.       INS.Qk := KDF9.Q_number(INS.order.syllable_1 and 8#17#);
   816.    end process_syllable_1_of_INS;
   817.
   818.    syllable_nr_mask : constant := 2#111#;
   819.    D4_mask          : constant := 2#1000#;
   820.    D2_mask          : constant := 2#00_100_000#;
   821.    D0_thru_3_mask   : constant := 2#11_110_000#;
   822.
   823.    procedure decode_a_jump_order (decoded : in out KDF9.decoded_order) is
   824.    begin
   825.       decoded.target.syllable_index
   826.          := KDF9.syllable_index(decoded.order.syllable_0 and syllable_nr_mask);
   827.       decoded.target.order_word_number
   828.          := KDF9.order_word_number(decoded.order.syllable_2)
   829.           + KDF9.order_word_number(decoded.Qk) * 2**8
   830.           + KDF9.order_word_number(decoded.order.syllable_0 and D4_mask) * 2**9;
   831.       if (decoded.compressed_opcode and D2_mask) /= 0 then -- not JrCq ...
   832.          decoded.compressed_opcode := decoded.compressed_opcode and D0_thru_3_mask;
   833.       else
   834.          decoded.compressed_opcode := (decoded.compressed_opcode and D0_thru_3_mask) or KDF9.syllable(decoded.Qq);
   835.       end if;
   836.       if decoded.compressed_opcode = EXIT_n then
   837.          -- The syllable part of EXIT is actually a halfword offset,
   838.          --    so convert it to an actual syllable number.
   839.          if decoded.target.syllable_index = 2 then
   840.             decoded.target.syllable_index := 0;
   841.          else
   842.             decoded.target.syllable_index := 3;
   843.          end if;
   844.       end if;
   845.    end decode_a_jump_order;
   846.
   847.    procedure process_syllables_1_and_2_of_a_jump_order is
   848.    begin
   849.       process_syllable_1_of_INS;
   850.       INS.order.syllable_2 := next_order_syllable;
   851.       decode_a_jump_order(INS);
   852.    end process_syllables_1_and_2_of_a_jump_order;
   853.
   854.    D5_thru_7_mask : constant := 2#111#;
   855.    D5_and_7_mask  : constant := 2#101#;
   856.    D2_thru_4_mask : constant := 2#111000#;
   857.
   858.    procedure decode_a_store_access_order (decoded : in out KDF9.decoded_order) is
   859.    begin
   860.       decoded.operand := KDF9.Q_part(decoded.order.syllable_2) + KDF9.Q_part(decoded.Qk)*2**8
   861.                        + KDF9.Q_part((decoded.order.syllable_0 and D2_thru_4_mask)) * 2**9;
   862.       decoded.compressed_opcode := decoded.compressed_opcode and D5_thru_7_mask;
   863.    end decode_a_store_access_order;
   864.
   865.    procedure decode_a_set_literal_order (decoded : in out KDF9.decoded_order) is
   866.    begin
   867.       decoded.operand := KDF9.Q_part(decoded.order.syllable_2)
   868.                        + KDF9.Q_part(decoded.order.syllable_1)*2**8;
   869.       decoded.compressed_opcode := 2#100#;
   870.    end decode_a_set_literal_order;
   871.
   872.    procedure process_syllables_1_and_2_of_a_data_access_order is
   873.    begin
   874.       if (INS.compressed_opcode and D5_thru_7_mask) < SET then
   875.          process_syllable_1_of_INS;
   876.          INS.order.syllable_2 := next_order_syllable;
   877.          decode_a_store_access_order(INS);
   878.       elsif (INS.compressed_opcode and D5_and_7_mask) = SET then
   879.          -- SET n
   880.          INS.order.syllable_1 := next_order_syllable;
   881.          INS.order.syllable_2 := next_order_syllable;
   882.          decode_a_set_literal_order(INS);
   883.       else
   884.          INS.order.syllable_1 := next_order_syllable;
   885.          INS.order.syllable_2 := next_order_syllable;
   886.          decode_a_set_literal_order(INS);
   887.          INS.compressed_opcode := 7;  -- an invalid compression.
   888.       end if;
   889.    end process_syllables_1_and_2_of_a_data_access_order;
   890.
   891.    procedure decode_the_next_order is
   892.    begin
   893.       -- The CPU time is adjusted by a fudge factor to account for
   894.       --    the instruction-fetch time being partly overlapped.
   895.       process_syllable_0_of_INS;
   896.       case INS.kind is
   897.          when one_syllable_order =>
   898.             return;
   899.          when two_syllable_order =>
   900.             process_syllable_1_of_INS;
   901.          when normal_jump_order =>
   902.             process_syllables_1_and_2_of_a_jump_order;
   903.          when data_access_order =>
   904.             process_syllables_1_and_2_of_a_data_access_order;
   905.       end case;
   906.    end decode_the_next_order;
   907.
   908.    procedure decode (the_order : in out KDF9.decoded_order) is
   909.    begin
   910.       decode_syllable_0(the_order);
   911.       case the_order.kind is
   912.          when one_syllable_order =>
   913.             null;
   914.          when two_syllable_order =>
   915.             decode_syllable_1(the_order);
   916.          when normal_jump_order =>
   917.             decode_syllable_1(the_order);
   918.             decode_a_jump_order(the_order);
   919.          when data_access_order =>
   920.             if (the_order.compressed_opcode and D5_thru_7_mask) < SET then
   921.                decode_syllable_1(the_order);
   922.                decode_a_store_access_order(the_order);
   923.             elsif (INS.compressed_opcode and D5_and_7_mask) = SET then
   924.                -- SET n
   925.                decode_a_set_literal_order(the_order);
   926.             else
   927.                decode_a_set_literal_order(the_order);
   928.                INS.compressed_opcode := 7;  -- an invalid compression.
   929.             end if;
   930.       end case;
   931.    end decode;
   932.
   933.    -- the_order_at_NIA gets three syllables starting at [NIA].  It is FOR DIAGNOSTIC USE ONLY!
   934.    -- It does NOT update the CPU time properly and MUST NOT be used inside an instruction cycle.
   935.
   936.    function the_order_at_NIA
   937.    return KDF9.syllable_group is
   938.       saved_NIA : constant KDF9.syllable_address := NIA;
   939.       result    : KDF9.syllable_group;
   940.    begin
   941.       result.syllable_0 := next_order_syllable;
   942.       result.syllable_1 := next_order_syllable;
   943.       result.syllable_2 := next_order_syllable;
   944.       set_NIA_to(saved_NIA);
   945.       return result;
   946.    end the_order_at_NIA;
   947.
   948.    -- This is the initial jump from the top halfword of E0 just after loading.
   949.
   950.    E0U : KDF9.word := 0;  -- N.B. the lower halfword is used for option flags.
   951.
   952.    procedure save_the_initial_jump is
   953.    begin
   954.       E0U := fetch_halfword(0, 0);
   955.    end save_the_initial_jump;
   956.
   957.    procedure restore_the_initial_jump is
   958.    begin
   959.        store_halfword(E0U, 0, 0);
   960.    end restore_the_initial_jump;
   961.
   962.    function the_initial_jump_was_corrupted
   963.    return Boolean
   964.    is (E0U /= fetch_halfword(0, 0));
   965.
   966.    function is_an_invalid_order (decoded : KDF9.decoded_order)
   967.    return Boolean
   968.    is (
   969.        (decoded.kind = data_access_order and then (decoded.order.syllable_0 and 2#101#) > 2#100#)
   970.          or else (decoded.kind = normal_jump_order and decoded.target.syllable_index > 5)
   971.             -- 0 is now treated as a valid DUMMY0 order for KAlgol
   972.                or else decoded.order.syllable_0 = 8#006#
   973.                   or else decoded.order.syllable_0 = 8#040#
   974.                      or else decoded.order.syllable_0 = 8#046#
   975.                         or else decoded.order.syllable_0 = 8#055#
   976.                            or else decoded.order.syllable_0 = 8#073#
   977.                               or else decoded.order.syllable_0 = 8#076#
   978.                                  or else decoded.order.syllable_0 = 8#150#
   979.       );
   980.
   981.    the_signature_hash : KDF9.word := 0;
   982.
   983.    function the_digital_signature
   984.    return KDF9.word
   985.    is (the_signature_hash);
   986.
   987.    function visible_state_hash
   988.    return KDF9.word
   989.       with Inline;
   990.
   991.    function visible_state_hash
   992.    return KDF9.word is
   993.       hash : KDF9.word;
   994.    begin
   995.       hash := rotate_word_right(the_signature_hash, 1) xor KDF9.word(ICR);
   996.       hash := rotate_word_right(hash, 1) xor as_word(the_Q_store(INS.Qq));
   997.       hash := rotate_word_right(hash, 1) xor as_word(the_Q_store(INS.Qk));
   998.       if the_sjns_depth > 0 then
   999.          for s in reverse KDF9.sjns_depth range 0 .. the_sjns_depth-1 loop
  1000.                hash := rotate_word_right(hash, 1) xor as_word(the_sjns(s));
  1001.          end loop;
  1002.       end if;
  1003.       if the_nest_depth > 0 then
  1004.          for n in reverse KDF9.nest_depth range 0 .. the_nest_depth-1 loop
  1005.                hash := rotate_word_right(hash, 1) xor the_nest(n);
  1006.          end loop;
  1007.       end if;
  1008.       return hash;
  1009.    end visible_state_hash;
  1010.
  1011.    procedure update_the_digital_signature is
  1012.    begin
  1013.       the_signature_hash := visible_state_hash;
  1014.    end update_the_digital_signature;
  1015.
  1016. end KDF9;

Compiling: ../Source/kdf9.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:23

     1. -- kdf9.ads
     2. --
     3. -- The architecturally-defined data and register formats of the KDF9 computer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with System;
    20.
    21. package KDF9 is
    22.
    23.    --
    24.    --
    25.    -- The fundamental storage unit is the 48-bit word.
    26.    --
    27.    --
    28.
    29.    --
    30.    -- The 48-bit word, considered as an unsigned integer.
    31.    --
    32.
    33.    type word is mod 2**48;  -- Let the compiler choose the best Size for this.
    34.
    35.    word_mask : constant := 8#7777777777777777#;
    36.    min_word  : constant := 8#4000000000000000#;
    37.    max_word  : constant := 8#3777777777777777#;
    38.
    39.    all_zero_bits : constant KDF9.word := 0;
    40.    sign_bit      : constant KDF9.word := KDF9.min_word;
    41.    not_sign_bit  : constant KDF9.word := KDF9.max_word;
    42.    all_one_bits  : constant KDF9.word := KDF9.word_mask;
    43.
    44.
    45.    --
    46.    -- The 96-bit double word, considered as a pair of words.
    47.    --
    48.
    49.    type pair is
    50.       record
    51.          msw, lsw : KDF9.word;
    52.       end record;
    53.
    54.
    55.    --
    56.    -- The basic 16-bit operand.
    57.    --
    58.
    59.    type field_of_16_bits is mod 2**16;
    60.
    61.    --
    62.    -- The 16-bit word, considered as a field of a Q register.
    63.    --
    64.
    65.    type Q_part is new KDF9.field_of_16_bits;
    66.
    67.    Q_part_mask : constant := KDF9.Q_part'Last;
    68.
    69.    function sign_extended (Q : KDF9.Q_part)
    70.    return KDF9.word
    71.       with Inline;
    72.
    73.    --
    74.    -- The 16-bit word, considered as a buffer (DMA channel) number.
    75.    --
    76.
    77.    subtype buffer_number is KDF9.Q_part range 0 .. 15;
    78.
    79.    buffer_number_mask : constant := buffer_number'Last;
    80.
    81.    --
    82.    -- The 16-bit word, considered as a core-store address.
    83.    --
    84.
    85.    subtype address is KDF9.Q_part range 0 .. 8#77777#;
    86.
    87.    --
    88.    -- The Q-store element.
    89.    --
    90.
    91.    type Q_register is
    92.       record
    93.          C, I, M : KDF9.Q_part;
    94.       end record;
    95.
    96.    function as_Q (the_word : KDF9.word)
    97.    return KDF9.Q_register
    98.       with Inline;
    99.
   100.    function as_word (the_Q : KDF9.Q_register)
   101.    return KDF9.word
   102.       with Inline;
   103.
   104.
   105.    --
   106.    -- The 8-bit instruction syllable and its components.
   107.    --
   108.
   109.    type syllable is mod 2**8;
   110.
   111.    subtype compressed_opcode is KDF9.syllable range 0 .. 63;
   112.    subtype Q_number          is KDF9.syllable range 0 .. 15;
   113.
   114.    type syllable_group is
   115.       record
   116.          syllable_0, syllable_1, syllable_2 : KDF9.syllable := 0;
   117.       end record;
   118.
   119.
   120.    --
   121.    -- An instruction address.
   122.    --
   123.    -- N.B. 5 is the hardware's largest valid syllable address.
   124.    -- The values 6 and 7 are used as diagnostic flags by ee9.
   125.    -- They cause a RESET trap if encountered during execution.
   126.    --
   127.
   128.    type syllable_index    is mod 2**3;
   129.    type order_word_number is mod 2**13;
   130.
   131.    type syllable_address is
   132.       record
   133.          order_word_number : KDF9.order_word_number;
   134.          syllable_index    : KDF9.syllable_index;
   135.       end record;
   136.
   137.    --
   138.    -- An instruction address, in the packed format of a hardware (SJNS) link.
   139.    --
   140.
   141.    type sjns_link is new KDF9.syllable_address
   142.       with Size => 16;
   143.    for sjns_link'Bit_Order use System.Low_Order_First;
   144.    for sjns_link use
   145.       record
   146.          order_word_number at 0 range  0 .. 12;
   147.          syllable_index    at 0 range 13 .. 15;
   148.       end record;
   149.
   150.    function as_word (the_link : KDF9.sjns_link)
   151.    return KDF9.word;
   152.
   153.    function as_link (the_word : KDF9.word)
   154.    return KDF9.sjns_link;
   155.
   156.    procedure increment_by_1 (the_link : in out KDF9.syllable_address)
   157.       with Inline;
   158.
   159.    procedure increment_by_2 (the_link : in out KDF9.syllable_address)
   160.       with Inline;
   161.
   162.    procedure increment_by_3 (the_link : in out KDF9.syllable_address)
   163.       with Inline;
   164.
   165.
   166.    --
   167.    -- The KDF9 halfword. Each occupies 24 bits, packed 2 per word.
   168.    --
   169.
   170.    type halfword is mod 2**24;
   171.    halfword_mask : constant := 8#77_77_77_77#;
   172.
   173.    subtype halfword_number is KDF9.address range 0 .. 1;
   174.
   175.
   176.    --
   177.    -- The KDF9 character occupies six bits, and they are packed 8 per word.
   178.    -- The various character sets, and the symbol type, are defined in the package KDF9_char_sets.
   179.    --
   180.
   181.
   182.    --
   183.    --
   184.    --
   185.    -- The following types define the structure of the KDF9's programmable registers.
   186.    --
   187.    --
   188.    --
   189.
   190.
   191.    --
   192.    -- authenticity_mode is declared here instead of in settings, to avoid a cyclic dependency.
   193.    --
   194.
   195.    type authenticity_mode is (modern_times_mode, authentic_time_mode);
   196.
   197.    the_authenticity_default : constant KDF9.authenticity_mode := modern_times_mode;
   198.    the_authenticity_mode    :          KDF9.authenticity_mode := the_authenticity_default;
   199.
   200.
   201.    --
   202.    --
   203.    --
   204.    -- The following variables (the_nest, the_sjns and the_Q_store) constitute
   205.    --    the emulation microcode's fixed working set of registers.
   206.    -- ee9 (unlike the real KDF9) swaps them with register_bank(the_context)
   207.    --    when a context switch is made by the =K3 instruction.
   208.    -- The real KDF9 used register_bank(the_context) directly for operands.
   209.    -- ee9's approach improves host cache locality and avoids indexing overheads,
   210.    --    the trade off being microscopically increased context-switching time.
   211.    --
   212.    --
   213.    --
   214.
   215.    --
   216.    -- The NEST.
   217.    --
   218.
   219.    type nest_depth is mod 19;
   220.
   221.    type NEST is array (KDF9.nest_depth) of KDF9.word;
   222.
   223.    the_nest       : KDF9.NEST;
   224.    the_nest_depth : KDF9.nest_depth  := 0;
   225.
   226.    -- The ensure_that_the_nest_holds* procedures trap NOUV.
   227.    -- They are used to validate operations that reduce the NEST depth.
   228.
   229.    procedure ensure_that_the_nest_holds (at_least : in KDF9.nest_depth)
   230.       with Inline;
   231.
   232.    procedure ensure_that_the_nest_holds_an_operand
   233.       with Inline;
   234.
   235.    procedure ensure_that_the_nest_holds_2_operands
   236.       with Inline;
   237.
   238.    function words_needed (need : KDF9.nest_depth)
   239.    return String
   240.       with Inline => False;
   241.
   242.    function space_needed (need : KDF9.nest_depth)
   243.    return String
   244.       with Inline => False;
   245.
   246.    function pop
   247.    return KDF9.word
   248.       with Inline;
   249.
   250.    procedure pop
   251.       with Inline;
   252.
   253.    procedure write_top (the_word : in KDF9.word)
   254.       with Inline;
   255.
   256.    function read_top
   257.    return KDF9.word
   258.       with Inline;
   259.
   260.
   261.    function pop
   262.    return KDF9.pair
   263.       with Inline;
   264.
   265.    procedure write_top (the_pair : in KDF9.pair)
   266.       with Inline;
   267.
   268.    function read_top
   269.    return KDF9.pair
   270.       with Inline;
   271.
   272.    -- The ensure_that_the_nest_has_room_for* procedures trap NOUV.
   273.    -- They are used to validate operations that increase the NEST depth.
   274.
   275.    procedure ensure_that_the_nest_has_room_for (at_least : in KDF9.nest_depth)
   276.       with Inline;
   277.
   278.    procedure ensure_that_the_nest_has_room_for_a_result
   279.       with Inline;
   280.
   281.    procedure push (the_word : in KDF9.word)
   282.       with Inline;
   283.
   284.    procedure ensure_that_the_nest_has_room_for_2_results
   285.       with Inline;
   286.
   287.    procedure push (the_pair : in KDF9.pair)
   288.       with Inline;
   289.
   290.
   291.    --
   292.    -- The SJNS.
   293.    --
   294.
   295.    type sjns_depth is mod 17;
   296.
   297.    type SJNS is array (KDF9.sjns_depth) of KDF9.sjns_link;
   298.
   299.    the_sjns       : KDF9.SJNS;
   300.    JB             : KDF9.sjns_link renames the_sjns(16);
   301.    the_sjns_depth : KDF9.sjns_depth := 0;
   302.
   303.    procedure ensure_that_the_sjns_is_not_empty
   304.       with Inline;
   305.
   306.    function pop
   307.    return KDF9.syllable_address
   308.       with Inline;
   309.
   310.    function sjns_top
   311.    return KDF9.sjns_link
   312.       with Inline;
   313.
   314.    procedure ensure_that_the_sjns_is_not_full
   315.       with Inline;
   316.
   317.    procedure push (the_link : in KDF9.syllable_address)
   318.       with Inline;
   319.
   320.
   321.    --
   322.    -- The Q Store.
   323.    -- Q0 is kept permanently zeroised.
   324.    --
   325.
   326.    type Q_store is array (KDF9.Q_number) of KDF9.Q_register;
   327.
   328.    the_Q_store : KDF9.Q_store;
   329.
   330.
   331.    --
   332.    -- The Boolean registers.
   333.    --
   334.
   335.    the_V_bit_is_set : Boolean := False;
   336.    the_T_bit_is_set : Boolean := False;
   337.
   338.
   339.    --
   340.    --
   341.    -- The following are to do with maintaining the virtual time.
   342.    --
   343.    --
   344.
   345.    type us is mod 2**64;  -- The emulation clocks tick in microseconds (unlike KDF9's clock).
   346.
   347.    -- The virtual processor time.
   348.
   349.    the_CPU_time  : KDF9.us := 0;
   350.
   351.    -- The amount by which the_CPU_time is increased by an instruction execution.
   352.
   353.    the_CPU_delta : KDF9.us := 0;
   354.
   355.    -- The virtual elapsed time, capped to prevent a spurious double-clock (RESET) interrupt.
   356.
   357.    function the_clock_time
   358.    return KDF9.us
   359.       with Inline;
   360.
   361.    -- Advance to the largest of the_CPU_time, the_elapsed_time, the_last_delay_time, and past.
   362.    -- Cap the increase to prevent a spurious double-clock (RESET) interrupt in Director.
   363.    -- If necessary, pause execution until the real time equals the virtual elapsed time.
   364.
   365.    procedure advance_the_clock (past : in KDF9.us);
   366.
   367.    -- The virtual clock time at which the next IO interrupt is expected.
   368.
   369.    the_next_interrupt_time : KDF9.us := KDF9.us'Last;
   370.
   371.    -- Pause execution for the_delay_time in virtual microseconds.
   372.
   373.    procedure delay_by (the_delay_time : in KDF9.us);
   374.
   375.    -- If necessary, pause execution until the real time equals the virtual elapsed time.
   376.
   377.    procedure synchronize_the_real_and_virtual_times;
   378.
   379. ------------------------------------------------------------------------------------------------
   380.
   381.    --
   382.    --
   383.    -- The following registers are used only in Director state.
   384.    --
   385.    --
   386.
   387.
   388.    --
   389.    -- The following are to do with the K1 order.
   390.    --
   391.
   392.    type priority is mod 2**2;
   393.
   394.    -- CPL = priority level of the currently-executing problem program.
   395.
   396.    CPL : KDF9.priority;
   397.
   398.    -- BA = word address of first allocated word (NOT group number as in the KDF9).
   399.
   400.    BA  : KDF9.address;
   401.
   402.    -- NOL = word address of last allocated word (NOT group number as in the KDF9).
   403.
   404.    NOL : KDF9.address;
   405.
   406.    -- Set BA (setting bits D38:47), CPL (D34:35) and NOL (D24:33).
   407.
   408.    procedure set_K1_register (setting : in KDF9.word);
   409.
   410.
   411.    --
   412.    -- The following are to do with the =K2 order.
   413.    --
   414.
   415.    -- The Current Peripheral Device Allocation Register.
   416.
   417.    type CPDAR is array (KDF9.buffer_number) of Boolean
   418.       with Component_Size => 8, Convention => C;
   419.
   420.    the_CPDAR : KDF9.CPDAR;
   421.
   422.    -- Set CPDAR (setting bits D32 .. D47).
   423.
   424.    procedure set_K2_register (setting : in KDF9.word);
   425.
   426.
   427.    --
   428.    -- The following are to do with the =K3 and K7 orders.
   429.    --
   430.
   431.    type user_register_set is
   432.       record
   433.          NEST     : KDF9.NEST;
   434.          SJNS     : KDF9.SJNS;
   435.          Q_store  : KDF9.Q_store;
   436.       end record;
   437.
   438.
   439.    -- There are 4 sets of user registers.
   440.    -- The execution context is the number of the register set in active use.
   441.
   442.    type context is mod 2**2;
   443.
   444.    -- register_bank holds the currently inactive register sets.
   445.
   446.    register_bank : array(KDF9.context) of KDF9.user_register_set;
   447.
   448.    -- KDF9 actually indexed the register bank with the value of the_context,
   449.    --   but the emulator swaps register sets between register_bank and
   450.    --      the_nest, the_sjns, and the_Q_store (q.v.).
   451.
   452.    the_context : KDF9.context := 0;
   453.
   454.    -- Set context (bits D46:47), nest_depth (D41:45) and sjns_depth (D36:41).
   455.
   456.    procedure set_K3_register (setting : in KDF9.word);
   457.
   458.    -- Get BA (bits D0 .. D9), CPL (D12 .. D13) and NOL (D14 .. D23).
   459.
   460.    function get_K7_operand
   461.    return KDF9.word;
   462.
   463.
   464.    --
   465.    -- The following are to do with the K4 order.
   466.    --
   467.
   468.    type interrupt_number is range 22 .. 31;
   469.
   470.    -- higher PRiority PRogram unblocked by end of I/O, or INTQq on busy device
   471.    PR_interrupt    : constant KDF9.interrupt_number := 22;
   472.    PR_trap         : exception;
   473.
   474.    -- FLEXowriter interrupt from operator
   475.    FLEX_interrupt  : constant KDF9.interrupt_number := 23;
   476.    FLEX_trap       : exception;
   477.
   478.    -- Lock-In Violation (attempt at a disallowed operation)
   479.    LIV_interrupt   : constant KDF9.interrupt_number := 24;
   480.    LIV_trap        : exception;
   481.
   482.    -- Nest (or SJNS) Over/Underflow Violation
   483.    NOUV_interrupt  : constant KDF9.interrupt_number := 25;
   484.    NOUV_trap       : exception;
   485.
   486.    -- End of Director Transfer, or I/O priority inversion
   487.    EDT_interrupt   : constant KDF9.interrupt_number := 26;
   488.    EDT_trap        : exception;
   489.
   490.    -- OUT system call
   491.    OUT_interrupt   : constant KDF9.interrupt_number := 27;
   492.    OUT_trap        : exception;
   493.
   494.    -- Lock-Out Violation
   495.    LOV_interrupt   : constant KDF9.interrupt_number := 28;
   496.    LOV_trap        : exception;
   497.
   498.    -- invalid syllable number or 'double-clock'
   499.    RESET_interrupt : constant KDF9.interrupt_number := 29;
   500.    RESET_trap      : exception;
   501.
   502.    type RFIR is array (KDF9.interrupt_number) of Boolean;
   503.
   504.    the_RFIR : KDF9.RFIR := (others => False);
   505.
   506.    -- The time at which the last K4 order was executed.
   507.    the_last_K4_time : KDF9.us := 0;
   508.
   509.    -- Get clock (bits D0:15) and RFIR (D16:31), clearing both.
   510.    function get_K4_operand
   511.    return KDF9.word;
   512.
   513.    -- An interrupt is raised when 1 second expires outside Director;
   514.    --    the flag does not correspond to any RFIR bit.
   515.    CLOCK_interrupt : constant KDF9.interrupt_number := 31;
   516.    CLOCK_trap      : exception;
   517.
   518.    -- This is for tracing a return from Director;
   519.    --    the flag does not correspond to any RFIR bit.
   520.    EXITD_flag : constant KDF9.interrupt_number := 30;
   521.
   522.    -- abandon_this_order is raised
   523.    -- 1. when an interrupt is punted to Director
   524.    -- OR
   525.    -- 2. when an operation is attempted, in a program running under Director,
   526.    --    that is invalid but is not defined to cause a LIV interrupt.
   527.    abandon_this_order : exception;
   528.
   529.    --
   530.    -- The following are to do with the K5 order.
   531.    --
   532.
   533.    -- The Program Hold-Up register is internal to I/O Control.
   534.    -- Get PHUi (bits D6i .. 6i+5), i = 0 .. 3.
   535.
   536.    function get_K5_operand
   537.    return KDF9.word;
   538.
   539.
   540.    --
   541.    -- The following are to do with management of the CPU's internal state.
   542.    --
   543.
   544.    type CPU_state is (Director_state, program_state);
   545.
   546.    the_CPU_state : KDF9.CPU_state;
   547.
   548.    procedure reset_the_CPU_state;
   549.
   550.    procedure reset_the_internal_registers (the_new_state : in CPU_state);
   551.
   552.    procedure fail_in_problem_program_state;
   553.
   554.    procedure LOV_if_user_mode (device_name : in String);
   555.
   556.    procedure return_from_Director_to (new_IAR : in KDF9.syllable_address);
   557.
   558.    procedure effect (this_interrupt : in KDF9.interrupt_number; message : in String := "")
   559.       with Inline => False;
   560.
   561.    procedure check_for_a_clock_interrupt
   562.       with Inline;
   563.
   564.    procedure trap_illegal_instruction (the_message : in String := "invalid opcode")
   565.       with Inline => False;
   566.
   567.    procedure trap_operator_error (the_device, the_message : in String)
   568.       with Inline => False, No_Return;
   569.
   570.    procedure trap_unimplemented_feature (the_message : in String)
   571.       with Inline => False, No_Return;
   572.
   573.    procedure fail_OUT (OUT_number : in KDF9.word; the_message : in String)
   574.       with Inline => False, No_Return;
   575.
   576.    procedure trap_invalid_paper_tape (the_message : in String)
   577.       with Inline => False, No_Return;
   578.
   579.    procedure reset_the_program_state;
   580.
   581.
   582.    --
   583.    --
   584.    -- Instruction fetch and decode.
   585.    --
   586.    --
   587.
   588.    -- These Instruction Address Registers are the nearest KDF9 has
   589.    --    to a conventional 'Program Counter' register.
   590.    -- NIA is significant only after an instruction has been decoded.
   591.
   592.    function NIA
   593.    return KDF9.syllable_address  -- the Next Instruction Address
   594.       with Inline;
   595.
   596.    function NIA_word_number
   597.    return KDF9.order_word_number
   598.       with Inline;
   599.
   600.    CIA : KDF9.syllable_address;  -- the Current Instruction Address
   601.
   602.    -- IWB0 and IWB1 in KDF9 contained the current 2 instruction words.
   603.    -- A 'short' loop, initiated by the JCqNZS instruction, ran entirely
   604.    --    inside the IWBs, obviating repeated instruction-fetch overhead.
   605.    -- Director exploits this in a loop that zeroizes the whole of core,
   606.    --    including that loop, which runs, immune to overwriting, in the IWBs.
   607.
   608.    procedure set_NIA_to (new_NIA : in KDF9.syllable_address)
   609.       with Inline;
   610.
   611.    procedure set_NIA_to_the_INS_target_address
   612.       with Inline;
   613.
   614.    procedure set_IWB0_and_IWB1_for_a_JCqNZS_loop
   615.       with Inline;
   616.
   617.    procedure go_back_to_the_start_of_IWB0
   618.       with Inline;
   619.
   620.    procedure continue_after_JCqNZS
   621.       with Inline;
   622.
   623.    -- Bits 0-1 of every order indicate its type as follows.
   624.
   625.    type INS_kind is mod 2**2;
   626.
   627.    one_syllable_order : constant := 0;
   628.    two_syllable_order : constant := 1;
   629.    normal_jump_order  : constant := 2;
   630.    data_access_order  : constant := 3;
   631.
   632.    type decoded_order is
   633.       record
   634.          order : KDF9.syllable_group := (0, 0, 0);
   635.          kind  : KDF9.INS_kind := 0;
   636.
   637.          -- The compressed_opcode is:
   638.          --    bits 2-7 of 1- and 2-syllable orders
   639.          --    bits 2-3|8-11 of normal jumps
   640.          --    bits 5-7 of SET and directly-addressed store access orders.
   641.          -- See the KDF9.decoding package.
   642.          compressed_opcode : KDF9.compressed_opcode := 0;
   643.
   644.           -- Qq is bits 8-11, Qk is bits 12-15.
   645.          Qq, Qk : KDF9.Q_number := 0;
   646.
   647.          -- For an jump instruction, syllable_index is bits 5-7.
   648.          target : KDF9.syllable_address;
   649.
   650.          -- For a data address or value (SET), operand is bits 2-4|12-23.
   651.          operand : KDF9.Q_part := 0;
   652.       end record;
   653.
   654.    INS : KDF9.decoded_order;  -- analogous to the INS register in Main Control
   655.
   656.    -- After decode_the_next_order:
   657.    --    INS contains the whole instruction at the address given by CIA,
   658.    --       with its components unpacked (not all are significant in every case).
   659.
   660.    procedure decode_the_next_order
   661.       with Inline;
   662.
   663.    procedure decode (the_order : in out KDF9.decoded_order)
   664.       with Inline;
   665.
   666.    procedure process_syllable_0_of_INS
   667.       with Inline;
   668.
   669.    procedure process_syllable_1_of_INS
   670.       with Inline;
   671.
   672.    procedure process_syllables_1_and_2_of_a_jump_order
   673.       with Inline;
   674.
   675.    procedure process_syllables_1_and_2_of_a_data_access_order
   676.       with Inline;
   677.
   678.    -- the_order_at_NIA gets three syllables starting at [NIA].
   679.    -- It is FOR DIAGNOSTIC USE ONLY!
   680.    -- It does NOT update the CPU time properly and must not be used inside an instruction cycle!
   681.
   682.    function the_order_at_NIA
   683.    return KDF9.syllable_group
   684.       with Inline;
   685.
   686.    -- Save E0U, lest the initial jump in E0 be corrupted during the run.
   687.    procedure save_the_initial_jump;
   688.
   689.    -- Restore E0U to its saved value.
   690.    procedure restore_the_initial_jump;
   691.
   692.    -- Check whether E0U has changed.
   693.    function the_initial_jump_was_corrupted
   694.    return Boolean;
   695.
   696.    -- True if the parameter is not a valid KDF9 instruction.
   697.
   698.    function is_an_invalid_order (decoded : KDF9.decoded_order)
   699.    return Boolean;
   700.
   701.
   702.    --
   703.    -- The Instruction Counter Register, ICR, (N.B. NOT a 'PROGRAM counter')
   704.    --   indicates the number of instructions executed by the KDF9.
   705.    --
   706.
   707.    type order_counter is mod 2**64;
   708.
   709.    ICR : KDF9.order_counter := 0;
   710.
   711.
   712.    --
   713.    -- The following support hashed execution-signature checking,
   714.    --    mainly for self-checking of new versions and ports.
   715.    --
   716.
   717.    function the_digital_signature
   718.    return KDF9.word;
   719.
   720.    procedure update_the_digital_signature
   721.       with Inline;
   722.
   723. private
   724.
   725.    the_elapsed_time    : KDF9.us := 0;
   726.    the_last_delay_time : KDF9.us := 0;
   727.
   728.    fetching_normally   : Boolean := True;
   729.
   730. end KDF9;

 1016 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/kdf9-microcode.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:23

     1. -- kdf9-microcode.adb
     2. --
     3. -- KDF9 ISP emulation - CPU microcode routines.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with break_in;
    20. with exceptions;
    21. with IOC;
    22. with IOC.dispatcher;
    23. with KDF9.CPU;
    24. with KDF9.Directors;
    25. with KDF9.decoding;
    26. with KDF9.store;
    27. with POSIX;
    28. with settings;
    29. with state_display;
    30. with tracing;
    31.
    32. use  exceptions;
    33. use  IOC;
    34. use  IOC.dispatcher;
    35. use  KDF9.CPU;
    36. use  KDF9.Directors;
    37. use  KDF9.decoding;
    38. use  KDF9.store;
    39. use  POSIX;
    40. use  settings;
    41. use  state_display;
    42. use  tracing;
    43.
    44. package body KDF9.microcode is
    45.
    46.    procedure do_a_one_syllable_order is
    47.       A, B, C, E : KDF9.word;
    48.       bit_count  : KDF9.word;
    49.       AB, CD     : KDF9.pair;
    50.       X, Y       : CPU.f48;
    51.       XY, ZT     : CPU.f96;
    52.    begin
    53.       case INS.compressed_opcode is
    54.
    55.          when 0 =>
    56.             -- The DUMMY order originally had code 0, before being changed to #17.
    57.             -- The Kidsgrove compiler continued to use code 0, so we must assume that,
    58.             --    despite the Manual, 0 continued to be a valid no-op order.
    59.             the_CPU_delta := the_CPU_delta + 1;
    60.
    61.          when VR =>
    62.             the_V_bit_is_set := False;
    63.             the_CPU_delta := the_CPU_delta + 1;
    64.
    65.          when TO_TR =>
    66.             ensure_that_the_nest_holds_an_operand;
    67.             if resign(pop) < 0 then
    68.                the_T_bit_is_set := True;
    69.             end if;
    70.             the_CPU_delta := the_CPU_delta + 2;
    71.
    72.          when BITS =>
    73.             write_top(cardinality(read_top));
    74.             the_CPU_delta := the_CPU_delta + 27;
    75.
    76.          when XF =>
    77.             ensure_that_the_nest_holds_2_operands;
    78.             X := pop;
    79.             Y := read_top;
    80.             write_top(CPU.f48'(Y * X));
    81.             the_CPU_delta := the_CPU_delta + 15;
    82.
    83.          when XDF =>
    84.             ensure_that_the_nest_holds_2_operands;
    85.             XY := read_top;
    86.             ZT := XY.lsw * XY.msw;
    87.             write_top(ZT);
    88.             the_CPU_delta := the_CPU_delta + 16;
    89.
    90.          when XPLUSF =>
    91.             ensure_that_the_nest_holds(at_least => 4);
    92.             XY := pop;
    93.             ZT := XY.lsw * XY.msw;
    94.             XY := read_top;
    95.             write_top(XY + ZT);
    96.             the_CPU_delta := the_CPU_delta + 18;
    97.
    98.          when NEGD =>
    99.             AB := read_top;
   100.             write_top( - AB);
   101.             the_CPU_delta := the_CPU_delta + 2;
   102.
   103.          when OR_9 =>
   104.             ensure_that_the_nest_holds_2_operands;
   105.             A := pop;
   106.             write_top(read_top or A);
   107.             the_CPU_delta := the_CPU_delta + 1;
   108.
   109.          when PERM =>
   110.             A := pop;
   111.             CD := pop;
   112.             push(A);
   113.             push(CD);
   114.             the_CPU_delta := the_CPU_delta + 2;
   115.
   116.          when TOB =>
   117.             ensure_that_the_nest_holds_2_operands;
   118.             A := pop;      -- the value
   119.             bit_count := cardinality(A);
   120.             B := read_top; -- the radixes
   121.             C := 0;
   122.
   123.             for i in 1 .. 8 loop
   124.                A := rotate_word_left(A, 6);
   125.                B := rotate_word_left(B, 6);
   126.                E := B and 8#77#; -- this radix
   127.                C := C*E + (A and 8#77#);
   128.             end loop;
   129.
   130.             write_top(C);
   131.             the_CPU_delta := the_CPU_delta + 2 + 4*KDF9.us(bit_count);
   132.
   133.          when ROUNDH =>
   134.             A := read_top;
   135.             write_top(resign(A) + 2**23);
   136.             the_CPU_delta := the_CPU_delta + 22;
   137.
   138.          when NEV =>
   139.             ensure_that_the_nest_holds_2_operands;
   140.             A := pop;
   141.             write_top(read_top xor A);
   142.             the_CPU_delta := the_CPU_delta + 2;
   143.
   144.          when ROUND =>
   145.             ensure_that_the_nest_holds_2_operands;
   146.             A := pop;
   147.             write_top(resign(A) + resign(shift_word_right(read_top, 46) and 1));
   148.             the_CPU_delta := the_CPU_delta + 1;
   149.
   150.          when DUMMY =>
   151.             the_CPU_delta := the_CPU_delta + 1;
   152.
   153.          when ROUNDF =>
   154.             ensure_that_the_nest_holds_2_operands;
   155.             XY := pop;
   156.             ZT := XY;
   157.             push(narrowed(XY));
   158.             the_CPU_delta := the_CPU_delta + 3;
   159.
   160.          when ROUNDHF =>
   161.             X := pop;
   162.             push(narrowed(X));
   163.             the_CPU_delta := the_CPU_delta + 3;
   164.
   165.          when MINUSDF =>
   166.             ensure_that_the_nest_holds(at_least => 4);
   167.             XY := pop;
   168.             ZT := read_top;
   169.             write_top(ZT - XY);
   170.             the_CPU_delta := the_CPU_delta + 12;
   171.
   172.          when PLUSDF =>
   173.             ensure_that_the_nest_holds(at_least => 4);
   174.             XY := pop;
   175.             ZT := read_top;
   176.             write_top(ZT + XY);
   177.             the_CPU_delta := the_CPU_delta + 12;
   178.
   179.          when FLOAT_9 =>
   180.             ensure_that_the_nest_holds_2_operands;
   181.             -- There is great uncertainty as to how the FLOAT/FLOATD orders handled scale factors
   182.             --   in N1 that lie outside the range allowed by the Manual, namely -128 <= N1 <= +127.
   183.             -- ee9 here takes a safety-first approach which is consistent with the
   184.             --    behaviour of the Kidsgrove sqrt function with arguments < 0.5º0.
   185.             A := shift_arithmetic(shift_logical(pop, +40), -40);
   186.             B := read_top;
   187.             write_top(KDF9.word(normalized(full_fraction => B, scaler => A)));
   188.
   189.          when FLOATD =>
   190.             ensure_that_the_nest_holds(at_least => 3);
   191.             A := shift_arithmetic(shift_logical(pop, +40), -40);
   192.             CD := read_top;
   193.             -- See §3.4 of Report K/GD.y.83, dated 6/12/1962.  It would seem to require this:
   194.             -- CD.lsw := CD.lsw and not 8#77#;  -- The 6 l.s.b. are lost.
   195.             -- The above is commented out because it gives the wrong answer with KAA01.
   196.             -- A post-document hardware modification is suspected.
   197.             reconstruct(CD, scaler => A);
   198.             write_top(CD);
   199.             the_CPU_delta := the_CPU_delta + 8;
   200.
   201.          when ABS_9 =>
   202.             write_top( abs resign(read_top));
   203.             the_CPU_delta := the_CPU_delta + 1;
   204.
   205.          when NEG =>
   206.             write_top( - resign(read_top));
   207.             the_CPU_delta := the_CPU_delta + 1;
   208.
   209.          when ABSF =>
   210.             X := read_top;
   211.             if resign(KDF9.word(X)) < 0 then
   212.                write_top( - X);
   213.                the_CPU_delta := the_CPU_delta + 4;
   214.             else
   215.                the_CPU_delta := the_CPU_delta + 1;
   216.             end if;
   217.
   218.          when NEGF =>
   219.             X := read_top;
   220.             write_top( - X);
   221.             the_CPU_delta := the_CPU_delta + 3;
   222.
   223.          when MAX =>
   224.             AB := read_top;
   225.             if resign(AB.lsw) >= resign(AB.msw) then
   226.                write_top(KDF9.pair'(msw => AB.lsw, lsw =>AB.msw));
   227.                the_V_bit_is_set := True;
   228.             end if;
   229.             the_CPU_delta := the_CPU_delta + 4;
   230.
   231.          when NOT_9 =>
   232.             A := read_top;
   233.             write_top(not A);
   234.             the_CPU_delta := the_CPU_delta + 1;
   235.
   236.          when XD =>
   237.             AB := read_top;
   238.             CD := AB.msw * AB.lsw;
   239.             write_top(CD);
   240.             the_CPU_delta := the_CPU_delta + 14;
   241.
   242.          when X_frac =>
   243.             ensure_that_the_nest_holds_2_operands;
   244.             A := pop;
   245.             write_top(as_word(CPU.fraction'(read_top * A)));
   246.             the_CPU_delta := the_CPU_delta + 15;
   247.
   248.          when MINUS =>
   249.             ensure_that_the_nest_holds_2_operands;
   250.             A := pop;
   251.             B := read_top;
   252.             write_top(resign(B) - resign(A));
   253.             the_CPU_delta := the_CPU_delta + 1;
   254.
   255.          when SIGN =>
   256.             ensure_that_the_nest_holds_2_operands;
   257.             A := pop;
   258.             B := read_top;
   259.             if B = A then
   260.                write_top(KDF9.word'(0));
   261.             elsif resign(B) > resign(A) then
   262.                write_top(KDF9.word'(1));
   263.             else
   264.                write_top(all_one_bits);
   265.             end if;
   266.             the_CPU_delta := the_CPU_delta + 3;
   267.
   268.          when ZERO =>
   269.             ensure_that_the_nest_has_room_for_a_result;
   270.             push(all_zero_bits);
   271.             the_CPU_delta := the_CPU_delta + 2;
   272.
   273.          when DUP =>
   274.             ensure_that_the_nest_has_room_for_a_result;
   275.             A := read_top;
   276.             push(A);
   277.             the_CPU_delta := the_CPU_delta + 2;
   278.
   279.          when DUPD =>
   280.             ensure_that_the_nest_has_room_for_2_results;
   281.             AB := read_top;
   282.             push(AB);
   283.             the_CPU_delta := the_CPU_delta + 4;
   284.
   285.          when DIVI =>
   286.             AB := read_top;
   287.             do_DIVI(L => AB.lsw,
   288.                     R => AB.msw,
   289.                     Quotient  => CD.lsw,
   290.                     Remainder => CD.msw);
   291.             write_top(CD);
   292.             the_CPU_delta := the_CPU_delta + 36;
   293.
   294.          when FIX =>
   295.             ensure_that_the_nest_holds_an_operand;
   296.             ensure_that_the_nest_has_room_for_a_result;
   297.             X := read_top;
   298.             write_top(fraction_word(X));
   299.             push(scaler(X));
   300.             the_CPU_delta := the_CPU_delta + 6;
   301.
   302.          when STR =>
   303.             ensure_that_the_nest_has_room_for_a_result;
   304.             A := read_top;
   305.             if resign(A) < 0 then
   306.                write_top(A and not_sign_bit);
   307.                push(all_one_bits);
   308.             else
   309.                push(all_zero_bits);
   310.             end if;
   311.             the_CPU_delta := the_CPU_delta + 3;
   312.
   313.          when CONT =>
   314.             ensure_that_the_nest_holds_2_operands;
   315.             A := pop;
   316.             B := read_top;
   317.             write_top(contracted(msw => A, lsw => B));
   318.             the_CPU_delta := the_CPU_delta + 2;
   319.
   320.          when REVD =>
   321.             AB := pop;
   322.             CD := pop;
   323.             push(AB);
   324.             push(CD);
   325.             the_CPU_delta := the_CPU_delta + 4;
   326.
   327.          when ERASE =>
   328.             ensure_that_the_nest_holds_an_operand;
   329.             pop;
   330.             the_CPU_delta := the_CPU_delta + 1;
   331.
   332.          when MINUSD =>
   333.             ensure_that_the_nest_holds(at_least => 4);
   334.             AB := pop;
   335.             CD := read_top;
   336.             write_top(CD - AB);
   337.             the_CPU_delta := the_CPU_delta + 3;
   338.
   339.          when AND_9 =>
   340.             ensure_that_the_nest_holds_2_operands;
   341.             A := pop;
   342.             write_top(read_top and A);
   343.             the_CPU_delta := the_CPU_delta + 1;
   344.
   345.          when PLUS =>
   346.             ensure_that_the_nest_holds_2_operands;
   347.             A := pop;
   348.             B := read_top;
   349.             write_top(resign(B) + resign(A));
   350.             the_CPU_delta := the_CPU_delta + 1;
   351.
   352.          when PLUSD =>
   353.             ensure_that_the_nest_holds(at_least => 4);
   354.             AB := pop;
   355.             CD := read_top;
   356.             write_top(CD + AB);
   357.             the_CPU_delta := the_CPU_delta + 3;
   358.
   359.          when DIV =>
   360.             ensure_that_the_nest_holds_2_operands;
   361.             AB := pop;
   362.             push(as_word(CPU.fraction'(AB.lsw / AB.msw)));
   363.             the_CPU_delta := the_CPU_delta + 36;
   364.
   365.          when DIVD =>
   366.             ensure_that_the_nest_holds(at_least => 3);
   367.             A := pop;
   368.             CD := pop;
   369.             do_DIVD(L => CD,
   370.                     R => A,
   371.                     Q => E);
   372.             push(E);
   373.             the_CPU_delta := the_CPU_delta + 36;
   374.
   375.          when DIVF =>
   376.             X := pop;
   377.             Y := read_top;
   378.             write_top(Y / X);
   379.             the_CPU_delta := the_CPU_delta + 36;
   380.
   381.          when DIVDF =>
   382.             ensure_that_the_nest_holds(at_least => 3);
   383.             Y := pop;
   384.             XY := pop;
   385.             push(XY / Y);
   386.             the_CPU_delta := the_CPU_delta + 35;
   387.
   388.          when DIVR =>
   389.             ensure_that_the_nest_holds(at_least => 3);
   390.             A := pop;
   391.             CD := read_top;
   392.             do_DIVR(L => CD,
   393.                     R => A,
   394.                     Quotient  => AB.msw,
   395.                     Remainder => AB.lsw);
   396.             write_top(AB);
   397.             the_CPU_delta := the_CPU_delta + 36;
   398.
   399.          when REV =>
   400.             AB := read_top;
   401.             write_top(KDF9.pair'(msw => AB.lsw, lsw =>AB.msw));
   402.             the_CPU_delta := the_CPU_delta + 1;
   403.
   404.          when CAB =>
   405.             AB := pop;
   406.             C := pop;
   407.             push(AB);
   408.             push(C);
   409.             the_CPU_delta := the_CPU_delta + 2;
   410.
   411.          when FRB =>
   412.             ensure_that_the_nest_holds_2_operands;
   413.             A := pop;      -- the value
   414.             bit_count := cardinality(A);
   415.             B := read_top; -- the radixes
   416.             C := 0;
   417.
   418.             for i in 1 .. 8 loop
   419.                E := B and 8#77#;
   420.                if E /= 0 then
   421.                   C := C or (A mod E);
   422.                   A := A / E;
   423.                else
   424.                   if A /= 0 then the_V_bit_is_set := True; end if;
   425.                end if;
   426.                B := shift_word_right(B, 6);
   427.                C := rotate_word_right(C, 6);
   428.             end loop;
   429.
   430.             if A /= 0 then
   431.                -- The value was too big for the representation; see Manual.
   432.                the_V_bit_is_set := True;
   433.             end if;
   434.             write_top(C);
   435.             the_CPU_delta := the_CPU_delta + 8 + 3*KDF9.us(bit_count);
   436.
   437.          when STAND =>
   438.             X := read_top;
   439.             write_top(normalized(X));
   440.             the_CPU_delta := the_CPU_delta + 5;
   441.
   442.          when NEGDF =>
   443.             XY := read_top;
   444.             write_top( - XY);
   445.             the_CPU_delta := the_CPU_delta + 9;
   446.
   447.          when MAXF =>
   448.             XY := read_top;
   449.             if XY.lsw >= XY.msw then
   450.                write_top(CPU.f96'(msw => XY.lsw, lsw =>XY.msw));
   451.                the_V_bit_is_set := True;
   452.             end if;
   453.             the_CPU_delta := the_CPU_delta + 6;
   454.
   455.          when PLUSF =>
   456.             ensure_that_the_nest_holds_2_operands;
   457.             X := pop;
   458.             Y := read_top;
   459.             write_top(Y + X);
   460.             the_CPU_delta := the_CPU_delta + 7;
   461.
   462.          when MINUSF =>
   463.             ensure_that_the_nest_holds_2_operands;
   464.             X := pop;
   465.             Y := read_top;
   466.             write_top(Y - X);
   467.             the_CPU_delta := the_CPU_delta + 7;
   468.
   469.          when SIGNF =>
   470.             ensure_that_the_nest_holds_2_operands;
   471.             XY := pop;
   472.             if KDF9.word(XY.lsw) = KDF9.word(XY.msw) then
   473.                push(all_zero_bits);
   474.             elsif XY.lsw < XY.msw then
   475.                push(all_one_bits);
   476.             else
   477.                push(KDF9.word(1));
   478.             end if;
   479.             the_CPU_delta := the_CPU_delta + 5;
   480.
   481.          when others =>
   482.             trap_illegal_instruction;
   483.
   484.       end case;
   485.    end do_a_one_syllable_order;
   486.
   487.
   488.    procedure do_an_IO_order is
   489.       IO_opcode   : constant KDF9.compressed_opcode := (INS.Qk and not manual_bit);
   490.       IO_operand  : constant KDF9.Q_register := the_Q_store(INS.Qq);
   491.       set_offline : constant Boolean         := (INS.Qk and manual_bit) /= 0;
   492.    begin
   493.       case INS.compressed_opcode is
   494.
   495.          when PAR_Qq =>
   496.             the_CPU_delta := the_CPU_delta + 11;
   497.             PAR(IO_operand, set_offline, the_T_bit_is_set);
   498.             the_CPU_delta := the_CPU_delta + 3;
   499.
   500.          when PIA_PIC_CLO_TLO_Qq =>
   501.             the_CPU_delta := the_CPU_delta + 15;
   502.             case IO_opcode is
   503.                when PIA_bits =>
   504.                   PIA(IO_operand, set_offline);
   505.                   the_CPU_delta := the_CPU_delta + 7;
   506.                when PIC_bits =>
   507.                   PIC(IO_operand, set_offline);
   508.                   the_CPU_delta := the_CPU_delta + 7;
   509.                when CLO_bits =>
   510.                   fail_in_problem_program_state;
   511.                   CLO(IO_operand, set_offline);
   512.                   the_CPU_delta := the_CPU_delta + 1;
   513.                when TLO_bits =>
   514.                   TLO(IO_operand, the_T_bit_is_set);
   515.                when others =>
   516.                   trap_illegal_instruction;
   517.             end case;
   518.
   519.          when PIB_PID_Qq =>
   520.             the_CPU_delta := the_CPU_delta + 15;
   521.             case IO_opcode is
   522.                when PIB_bits =>
   523.                   PIB(IO_operand, set_offline);
   524.                   the_CPU_delta := the_CPU_delta + 7;
   525.                when PID_bits =>
   526.                   PID(IO_operand, set_offline);
   527.                   the_CPU_delta := the_CPU_delta + 7;
   528.                when others =>
   529.                   trap_illegal_instruction;
   530.             end case;
   531.
   532.          when PIE_PIG_Qq =>
   533.             the_CPU_delta := the_CPU_delta + 15;
   534.             case IO_opcode is
   535.                when PIE_bits =>
   536.                   PIE(IO_operand, set_offline);
   537.                   the_CPU_delta := the_CPU_delta + 7;
   538.                when PIG_bits =>
   539.                   PIG(IO_operand, set_offline);
   540.                   the_CPU_delta := the_CPU_delta + 7;
   541.                when others =>
   542.                   trap_illegal_instruction;
   543.             end case;
   544.
   545.          when PIF_PIH_Qq =>
   546.             the_CPU_delta := the_CPU_delta + 15;
   547.             case IO_opcode is
   548.                when PIF_bits =>
   549.                   PIF(IO_operand, set_offline);
   550.                   the_CPU_delta := the_CPU_delta + 7;
   551.                when PIH_bits =>
   552.                   PIH(IO_operand, set_offline);
   553.                   the_CPU_delta := the_CPU_delta + 7;
   554.                when others =>
   555.                   trap_illegal_instruction;
   556.             end case;
   557.
   558.          when PMA_PMK_INT_Qq =>
   559.             the_CPU_delta := the_CPU_delta + 11;
   560.             case IO_opcode is
   561.                when PMA_bits =>
   562.                   PMA(IO_operand, set_offline);
   563.                when PMK_bits =>
   564.                   PMK(IO_operand, set_offline);
   565.                when INT_bits =>
   566.                   INT(IO_operand, set_offline);
   567.                when others =>
   568.                   trap_illegal_instruction;
   569.             end case;
   570.
   571.          when CT_PMB_PMC_BUSY_Qq =>
   572.             the_CPU_delta := the_CPU_delta + 11;
   573.             case IO_opcode is
   574.                when CTQ_bits =>
   575.                   -- if set_offline then MANUALQq else CTQq
   576.                   if set_offline                      or else
   577.                         the_CPU_state = Director_state   then
   578.                      MANUAL_CT(IO_operand, set_offline);
   579.                      the_CPU_delta := the_CPU_delta + 2;
   580.                   else
   581.                      trap_illegal_instruction; -- This will always LIV, as we are not in Director.
   582.                   end if;
   583.                when PMB_bits =>
   584.                   PMB(IO_operand, set_offline);
   585.                   the_CPU_delta := the_CPU_delta + 3;
   586.                when PMC_bits =>
   587.                   PMC(IO_operand, set_offline);
   588.                   the_CPU_delta := the_CPU_delta + 3;
   589.                when BUSY_bits =>
   590.                   BUSY(IO_operand, set_offline, the_T_bit_is_set);
   591.                   the_CPU_delta := the_CPU_delta + 2;
   592.                when others =>
   593.                   trap_illegal_instruction;
   594.             end case;
   595.
   596.          when PMD_PME_PML_Qq =>
   597.             the_CPU_delta := the_CPU_delta + 14;
   598.             case IO_opcode is
   599.                when PMD_bits =>
   600.                   PMD(IO_operand, set_offline);
   601.                   the_CPU_delta := the_CPU_delta + 5;
   602.                when PME_bits =>
   603.                   PME(IO_operand, set_offline);
   604.                   the_CPU_delta := the_CPU_delta + 5;
   605.                when PML_bits =>
   606.                   PML(IO_operand, set_offline);
   607.                   the_CPU_delta := the_CPU_delta + 5;
   608.                when others =>
   609.                   trap_illegal_instruction;
   610.             end case;
   611.
   612.          when PMF_PMG_Qq =>
   613.             the_CPU_delta := the_CPU_delta + 11;
   614.             case IO_opcode is
   615.                when PMF_bits =>
   616.                   PMF(IO_operand, set_offline);
   617.                   the_CPU_delta := the_CPU_delta + 3;
   618.                when PMG_bits =>
   619.                   fail_in_problem_program_state;
   620.                   the_CPU_delta := the_CPU_delta + 14;  -- ??
   621.                   PMG(IO_operand, set_offline);
   622.                 when others =>
   623.                   trap_illegal_instruction;
   624.             end case;
   625.
   626.          when POA_POC_POE_POF_PMH_Qq =>
   627.             the_CPU_delta := the_CPU_delta + 15;
   628.             case IO_opcode is
   629.                when POA_bits =>
   630.                   POA(IO_operand, set_offline);
   631.                   the_CPU_delta := the_CPU_delta + 7;
   632.                when POC_bits =>
   633.                   POC(IO_operand, set_offline);
   634.                   the_CPU_delta := the_CPU_delta + 7;
   635.                when POE_bits =>
   636.                   POE(IO_operand, set_offline);
   637.                   the_CPU_delta := the_CPU_delta + 4;
   638.                when POF_bits =>
   639.                   POF(IO_operand, set_offline);
   640.                   the_CPU_delta := the_CPU_delta + 4;
   641.                when PMH_bits =>
   642.                   fail_in_problem_program_state;
   643.                   SLO(IO_operand, set_offline);
   644.                   the_CPU_delta := the_CPU_delta + 1;
   645.                when others =>
   646.                   trap_illegal_instruction;
   647.             end case;
   648.
   649.          when POB_POD_Qq =>
   650.             the_CPU_delta := the_CPU_delta + 15;
   651.             case IO_opcode is
   652.                when POB_bits =>
   653.                   POB(IO_operand, set_offline);
   654.                   the_CPU_delta := the_CPU_delta + 7;
   655.                when POD_bits =>
   656.                   POD(IO_operand, set_offline);
   657.                   the_CPU_delta := the_CPU_delta + 7;
   658.                when others =>
   659.                   trap_illegal_instruction;
   660.             end case;
   661.
   662.          when POG_POL_Qq =>
   663.             the_CPU_delta := the_CPU_delta + 15;
   664.             case IO_opcode is
   665.                when POG_bits =>
   666.                   POG(IO_operand, set_offline);
   667.                   the_CPU_delta := the_CPU_delta + 7;
   668.                when POL_bits =>
   669.                   POL(IO_operand, set_offline);
   670.                   the_CPU_delta := the_CPU_delta + 7;
   671.                when others =>
   672.                   trap_illegal_instruction;
   673.             end case;
   674.
   675.          when POH_POK_Qq =>
   676.             the_CPU_delta := the_CPU_delta + 15;
   677.             case IO_opcode is
   678.                when POH_bits =>
   679.                   POH(IO_operand, set_offline);
   680.                   the_CPU_delta := the_CPU_delta + 7;
   681.                when POK_bits =>
   682.                   POK(IO_operand, set_offline);
   683.                   the_CPU_delta := the_CPU_delta + 7;
   684.                when others =>
   685.                   trap_illegal_instruction;
   686.             end case;
   687.
   688.          when others =>
   689.             trap_illegal_instruction;
   690.
   691.       end case;
   692.    end do_an_IO_order;
   693.
   694.
   695.    all_zero_Q_store : constant KDF9.Q_register := (C | I | M => 0);
   696.
   697.    procedure ensure_that_Q0_contains_zero (suspect : KDF9.Q_number)
   698.       with Inline;
   699.
   700.    procedure ensure_that_Q0_contains_zero (suspect : KDF9.Q_number) is
   701.    begin
   702.       if suspect = 0 then
   703.          the_Q_store(0) := all_zero_Q_store;  -- Override any assignment to Q0.
   704.       end if;
   705.    end ensure_that_Q0_contains_zero;
   706.
   707.    procedure auto_increment
   708.       with Inline;
   709.
   710.    procedure auto_increment is
   711.    begin
   712.       if INS.Qq /= 0 then
   713.          the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M + the_Q_store(INS.Qq).I;
   714.          the_Q_store(INS.Qq).C := the_Q_store(INS.Qq).C - 1;
   715.       end if;
   716.    end auto_increment;
   717.
   718.    function shift_count
   719.    return CPU.signed_Q_part
   720.       with Inline;
   721.
   722.    function shift_count
   723.    return CPU.signed_Q_part
   724.    is (
   725.        if (INS.order.syllable_1 and constant_bit) /= 0  then
   726.           resign(KDF9.Q_part(INS.order.syllable_1/2 xor 64)) - 64
   727.        else
   728.           resign((the_Q_store(INS.Qq).C and 255) xor 128) - 128
   729.       );
   730.
   731.
   732.    procedure do_a_two_syllable_order is
   733.       A  : KDF9.word;
   734.       AB : KDF9.pair;
   735.       CD : KDF9.pair;
   736.    begin
   737.       case INS.compressed_opcode is
   738.
   739.          when JCqNZS =>
   740.             if CIA.syllable_index = 5 then
   741.                -- KDF9 did not actually detect this error, and the JCqNZS instruction often worked,
   742.                --    unless broken-into by an interrupt, which returned to the word following that
   743.                --       containing the first syllable of the JCqNZS instruction.
   744.                -- I see no case for reproducing this behaviour.
   745.                trap_illegal_instruction ("JCqNZS instruction at syllable 5");
   746.             end if;
   747.             if the_Q_store(INS.Qq).C /= 0 then
   748.                if fetching_normally then
   749.                   set_IWB0_and_IWB1_for_a_JCqNZS_loop;
   750.                   the_CPU_delta := the_CPU_delta + 7;  -- Takes 11µs the first time it jumps.
   751.                end if;
   752.                -- The IWBs now contain the loop, so go to syllable 0 of IWB0.
   753.                go_back_to_the_start_of_IWB0;
   754.             else
   755.                continue_after_JCqNZS;
   756.             end if;
   757.             the_CPU_delta := the_CPU_delta + 4;
   758.
   759.          when MkMq =>
   760.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   761.             check_address_and_lockout(the_trace_address);
   762.             ensure_that_the_nest_has_room_for_a_result;
   763.             the_trace_operand := fetch_word(the_trace_address);
   764.             push(the_trace_operand);
   765.             the_CPU_delta := the_CPU_delta + 7;
   766.
   767.          when MkMqQ =>
   768.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   769.             check_address_and_lockout(the_trace_address);
   770.             ensure_that_the_nest_has_room_for_a_result;
   771.             the_trace_operand := fetch_word(the_trace_address);
   772.             push(the_trace_operand);
   773.             auto_increment;
   774.             the_CPU_delta := the_CPU_delta + 8;
   775.
   776.          when MkMqH =>
   777.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   778.             check_address_and_lockout(the_trace_address);
   779.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   780.             ensure_that_the_nest_has_room_for_a_result;
   781.             push(the_trace_operand);
   782.             the_CPU_delta := the_CPU_delta + 7;
   783.
   784.          when MkMqQH =>
   785.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   786.             check_address_and_lockout(the_trace_address);
   787.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   788.             ensure_that_the_nest_has_room_for_a_result;
   789.             push(the_trace_operand);
   790.             auto_increment;
   791.             the_CPU_delta := the_CPU_delta + 8;
   792.
   793.          when MkMqN =>
   794.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   795.             check_address_and_lockout(the_trace_address);
   796.             ensure_that_the_nest_has_room_for_a_result;
   797.             the_trace_operand := fetch_word(the_trace_address);
   798.             push(the_trace_operand);
   799.             the_CPU_delta := the_CPU_delta + 7;
   800.
   801.          when MkMqQN =>
   802.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   803.             check_address_and_lockout(the_trace_address);
   804.             ensure_that_the_nest_has_room_for_a_result;
   805.             the_trace_operand := fetch_word(the_trace_address);
   806.             push(the_trace_operand);
   807.             auto_increment;
   808.             the_CPU_delta := the_CPU_delta + 8;
   809.
   810.          when MkMqHN =>
   811.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   812.             check_address_and_lockout(the_trace_address);
   813.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   814.             ensure_that_the_nest_has_room_for_a_result;
   815.             push(the_trace_operand);
   816.             the_CPU_delta := the_CPU_delta + 7;
   817.
   818.          when MkMqQHN =>
   819.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   820.             check_address_and_lockout(the_trace_address);
   821.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   822.             ensure_that_the_nest_has_room_for_a_result;
   823.             push(the_trace_operand);
   824.             auto_increment;
   825.             the_CPU_delta := the_CPU_delta + 8;
   826.
   827.          when TO_MkMq =>
   828.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   829.             check_address_and_lockout(the_trace_address);
   830.             ensure_that_the_nest_holds_an_operand;
   831.             the_trace_operand := pop;
   832.             store_word(the_trace_operand, the_trace_address);
   833.             the_CPU_delta := the_CPU_delta + 7;
   834.
   835.          when TO_MkMqQ =>
   836.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   837.             check_address_and_lockout(the_trace_address);
   838.             ensure_that_the_nest_holds_an_operand;
   839.             the_trace_operand := pop;
   840.             store_word(the_trace_operand, the_trace_address);
   841.             auto_increment;
   842.             the_CPU_delta := the_CPU_delta + 8;
   843.
   844.          when TO_MkMqH =>
   845.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   846.             check_address_and_lockout(the_trace_address);
   847.             ensure_that_the_nest_holds_an_operand;
   848.             the_trace_operand := pop;
   849.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   850.             the_CPU_delta := the_CPU_delta + 7;
   851.
   852.          when TO_MkMqQH =>
   853.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   854.             check_address_and_lockout(the_trace_address);
   855.             ensure_that_the_nest_holds_an_operand;
   856.             the_trace_operand := pop;
   857.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   858.             auto_increment;
   859.             the_CPU_delta := the_CPU_delta + 8;
   860.
   861.          when TO_MkMqN =>
   862.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   863.             check_address_and_lockout(the_trace_address);
   864.             ensure_that_the_nest_holds_an_operand;
   865.             the_trace_operand := pop;
   866.             store_word(the_trace_operand, the_trace_address);
   867.             the_CPU_delta := the_CPU_delta + 7;
   868.
   869.          when TO_MkMqQN =>
   870.             the_trace_address := valid_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   871.             check_address_and_lockout(the_trace_address);
   872.             ensure_that_the_nest_holds_an_operand;
   873.             the_trace_operand := pop;
   874.             store_word(the_trace_operand, the_trace_address);
   875.             auto_increment;
   876.             the_CPU_delta := the_CPU_delta + 8;
   877.
   878.          when TO_MkMqHN =>
   879.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   880.             check_address_and_lockout(the_trace_address);
   881.             ensure_that_the_nest_holds_an_operand;
   882.             the_trace_operand := pop;
   883.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   884.             the_CPU_delta := the_CPU_delta + 7;
   885.
   886.          when TO_MkMqQHN =>
   887.             the_trace_address := valid_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   888.             check_address_and_lockout(the_trace_address);
   889.             ensure_that_the_nest_holds_an_operand;
   890.             the_trace_operand := pop;
   891.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   892.             auto_increment;
   893.             the_CPU_delta := the_CPU_delta + 8;
   894.
   895.          when M_PLUS_Iq =>
   896.             the_CPU_delta := the_CPU_delta + 4;
   897.             the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M + the_Q_store(INS.Qq).I;
   898.
   899.          when M_MINUS_Iq =>
   900.             the_CPU_delta := the_CPU_delta + 5;
   901.             the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M - the_Q_store(INS.Qq).I;
   902.
   903.          when NCq =>
   904.             the_CPU_delta := the_CPU_delta + 5;
   905.             the_Q_store(INS.Qq).C := - the_Q_store(INS.Qq).C;
   906.
   907.          when DCq =>
   908.             the_CPU_delta := the_CPU_delta + 3;
   909.             if INS.Qq /= 0 then
   910.                the_Q_store(INS.Qq).C := the_Q_store(INS.Qq).C - 1;
   911.             end if;
   912.
   913.          when POS1_TO_Iq =>
   914.             the_CPU_delta := the_CPU_delta + 3;
   915.             if INS.Qq /= 0 then
   916.                the_Q_store(INS.Qq).I := + 1;
   917.             end if;
   918.
   919.          when NEG1_TO_Iq =>
   920.             the_CPU_delta := the_CPU_delta + 3;
   921.             if INS.Qq /= 0 then
   922.                the_Q_store(INS.Qq).I := - 1;
   923.             end if;
   924.
   925.          when POS2_TO_Iq =>
   926.             the_CPU_delta := the_CPU_delta + 3;
   927.             if INS.Qq /= 0 then
   928.                the_Q_store(INS.Qq).I := + 2;
   929.             end if;
   930.
   931.          when NEG2_TO_Iq =>
   932.             the_CPU_delta := the_CPU_delta + 3;
   933.             if INS.Qq /= 0 then
   934.                the_Q_store(INS.Qq).I := - 2;
   935.             end if;
   936.
   937.          when CqTOQk =>
   938.             the_CPU_delta := the_CPU_delta + 4;
   939.             if INS.Qk /= 0 then
   940.                the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   941.             end if;
   942.
   943.          when IqTOQk =>
   944.             the_CPU_delta := the_CPU_delta + 4;
   945.             if INS.Qk /= 0 then
   946.                the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   947.             end if;
   948.
   949.          when MqTOQk =>
   950.             the_CPU_delta := the_CPU_delta + 4;
   951.             if INS.Qk /= 0 then
   952.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   953.             end if;
   954.
   955.          when QqTOQk =>
   956.             the_CPU_delta := the_CPU_delta + 4;
   957.             if INS.Qk /= 0 then
   958.                the_Q_store(INS.Qk) := the_Q_store(INS.Qq);
   959.             end if;
   960.
   961.          when CIqTOQk =>
   962.            the_CPU_delta := the_CPU_delta + 4;
   963.            if INS.Qk /= 0 then
   964.               the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   965.               the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   966.            end if;
   967.
   968.          when IMqTOQk =>
   969.             the_CPU_delta := the_CPU_delta + 4;
   970.             if INS.Qk /= 0 then
   971.                the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   972.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   973.             end if;
   974.
   975.          when CMqTOQk =>
   976.             the_CPU_delta := the_CPU_delta + 4;
   977.             if INS.Qk /= 0 then
   978.                the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   979.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   980.             end if;
   981.
   982.          when QCIMq =>
   983.             ensure_that_the_nest_has_room_for_a_result;
   984.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- Qq
   985.                push(as_word(the_Q_store(INS.Qq)));
   986.                the_CPU_delta := the_CPU_delta + 4;
   987.             elsif (INS.Qk and M_part_choice) /= 0 then       -- Mq
   988.                push(sign_extended(the_Q_store(INS.Qq).M));
   989.                the_CPU_delta := the_CPU_delta + 4;
   990.             elsif (INS.Qk and C_part_choice) /= 0 then       -- Cq
   991.                push(sign_extended(the_Q_store(INS.Qq).C));
   992.                the_CPU_delta := the_CPU_delta + 5;
   993.             elsif (INS.Qk and I_part_choice) /= 0 then       -- Iq
   994.                push(sign_extended(the_Q_store(INS.Qq).I));
   995.                the_CPU_delta := the_CPU_delta + 6;
   996.             else
   997.                trap_illegal_instruction;
   998.             end if;
   999.
  1000.          when TO_RCIMq =>
  1001.             ensure_that_the_nest_holds_an_operand;
  1002.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- =Qq
  1003.                the_Q_store(INS.Qq) := as_Q(pop);
  1004.                the_CPU_delta := the_CPU_delta + 2;
  1005.             elsif (INS.Qk and M_part_choice) /= 0 then       -- =[R]Mq
  1006.                the_Q_store(INS.Qq).M := KDF9.Q_part(pop and Q_part_mask);
  1007.                if (INS.Qk and reset_choice) /= 0 then
  1008.                   the_Q_store(INS.Qq).C := 0;
  1009.                   the_Q_store(INS.Qq).I := 1;
  1010.                   the_CPU_delta := the_CPU_delta + 3;
  1011.                else
  1012.                   the_CPU_delta := the_CPU_delta + 2;
  1013.                end if;
  1014.             elsif (INS.Qk and C_part_choice) /= 0 then       -- =[R]Cq
  1015.                the_Q_store(INS.Qq).C := KDF9.Q_part(pop and Q_part_mask);
  1016.                if (INS.Qk and reset_choice) /= 0 then
  1017.                   the_Q_store(INS.Qq).I := 1;
  1018.                   the_Q_store(INS.Qq).M := 0;
  1019.                   the_CPU_delta := the_CPU_delta + 3;
  1020.                else
  1021.                   the_CPU_delta := the_CPU_delta + 2;
  1022.                end if;
  1023.             elsif (INS.Qk and I_part_choice) /= 0 then       -- =[R]Iq
  1024.                the_Q_store(INS.Qq).I := KDF9.Q_part(pop and Q_part_mask);
  1025.                if (INS.Qk and reset_choice) /= 0 then
  1026.                   the_Q_store(INS.Qq).C := 0;
  1027.                   the_Q_store(INS.Qq).M := 0;
  1028.                   the_CPU_delta := the_CPU_delta + 3;
  1029.                else
  1030.                   the_CPU_delta := the_CPU_delta + 2;
  1031.                end if;
  1032.             else
  1033.                trap_illegal_instruction;
  1034.             end if;
  1035.             ensure_that_Q0_contains_zero(suspect => INS.Qq);
  1036.
  1037.          when ADD_TO_QCIMq =>
  1038.             ensure_that_the_nest_has_room_for_a_result;
  1039.             ensure_that_the_nest_holds_an_operand;
  1040.
  1041.             -- Because the following does not push the Q operand on to the NEST,
  1042.             --   it will not leave an authentic bit pattern in the NEST core stack,
  1043.             --      in the event of a subsequent NOUV.
  1044.             -- I take this to be of no importance.
  1045.
  1046.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- =+Qq
  1047.                the_Q_store(INS.Qq) := as_Q(as_word(the_Q_store(INS.Qq)) + pop);
  1048.                the_CPU_delta := the_CPU_delta + 5;
  1049.             elsif (INS.Qk and M_part_choice) /= 0 then       -- =+Mq
  1050.                the_Q_store(INS.Qq).M := KDF9.Q_part(Q_part_mask and
  1051.                                              (sign_extended(the_Q_store(INS.Qq).M) + pop));
  1052.                the_CPU_delta := the_CPU_delta + 5;
  1053.             elsif (INS.Qk and C_part_choice) /= 0 then       -- =+Cq
  1054.                the_Q_store(INS.Qq).C := KDF9.Q_part(Q_part_mask and
  1055.                                              (sign_extended(the_Q_store(INS.Qq).C) + pop));
  1056.                the_CPU_delta := the_CPU_delta + 6;
  1057.             elsif (INS.Qk and I_part_choice) /= 0 then       -- =+Iq
  1058.                the_Q_store(INS.Qq).I := KDF9.Q_part(Q_part_mask and
  1059.                                              (sign_extended(the_Q_store(INS.Qq).I) + pop));
  1060.                the_CPU_delta := the_CPU_delta + 7;
  1061.             else
  1062.                trap_illegal_instruction;
  1063.             end if;
  1064.             ensure_that_Q0_contains_zero(suspect => INS.Qq);
  1065.
  1066.          when SHA =>
  1067.             A := read_top;
  1068.             write_top(KDF9.word'(shift_arithmetic(A, shift_count)));
  1069.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1070.
  1071.          when SHAD =>
  1072.             AB := read_top;
  1073.             write_top(KDF9.pair'(shift_arithmetic(AB, shift_count)));
  1074.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1075.
  1076.          when MACC =>
  1077.             ensure_that_the_nest_holds(at_least => 4);
  1078.             AB := pop;
  1079.             AB := AB.msw * AB.lsw;
  1080.             CD := read_top;
  1081.             write_top(CD + shift_arithmetic(AB, shift_count));
  1082.             the_CPU_delta := the_CPU_delta + 15 + shift_time(Natural(abs shift_count));
  1083.
  1084.          when SHL =>
  1085.             write_top(KDF9.word'(shift_logical(read_top, shift_count)));
  1086.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1087.
  1088.          when SHLD =>
  1089.             write_top(KDF9.pair'(shift_logical(read_top, shift_count)));
  1090.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1091.
  1092.          when SHC =>
  1093.             write_top(shift_circular(read_top, shift_count));
  1094.             the_CPU_delta := the_CPU_delta + 3 + shift_time(Natural(abs shift_count));
  1095.
  1096.          when TO_Kq =>
  1097.             fail_in_problem_program_state;
  1098.             case INS.Qq is
  1099.                when K0 =>
  1100.                   if read_top /= all_zero_bits then
  1101.                      for w in all_zero_bits .. read_top mod 8 loop
  1102.                         POSIX.output_line("BLEEP!");
  1103.                      end loop;
  1104.                      delay 10.0;
  1105.                   end if;
  1106.                when K1 =>
  1107.                   set_K1_register(read_top);
  1108.                when K2 =>
  1109.                   set_K2_register(read_top);
  1110.                when K3 =>
  1111.                   set_K3_register(read_top);
  1112.                when others =>
  1113.                   trap_illegal_instruction;
  1114.             end case;
  1115.             the_CPU_delta := the_CPU_delta + 3;
  1116.
  1117.          when Kk =>
  1118.             fail_in_problem_program_state;
  1119.             ensure_that_the_nest_has_room_for_a_result;
  1120.             case INS.Qk is
  1121.                when K4 =>
  1122.                   push(get_K4_operand);
  1123.                   the_RFIR := (others => False);
  1124.                when K5 =>
  1125.                   push(get_K5_operand);
  1126.                when K7 =>
  1127.                   push(get_K7_operand);
  1128.                when others =>
  1129.                   trap_illegal_instruction;
  1130.             end case;
  1131.             the_CPU_delta := the_CPU_delta + 3;
  1132.
  1133.          when LINK =>
  1134.             if the_CPU_state = Director_state and the_sjns_depth = 0 then -- clear out JB
  1135.                push(all_zero_bits);
  1136.                the_sjns_depth := 0 - 1;
  1137.             else
  1138.                ensure_that_the_nest_has_room_for_a_result;
  1139.                ensure_that_the_sjns_is_not_empty;
  1140.                push(as_word(KDF9.sjns_link(KDF9.syllable_address'(pop))));
  1141.             end if;
  1142.             the_CPU_delta := the_CPU_delta + 4;
  1143.
  1144.          when TO_LINK =>
  1145.             ensure_that_the_sjns_is_not_full;
  1146.             ensure_that_the_nest_holds_an_operand;
  1147.             push(KDF9.syllable_address(as_link(pop)));
  1148.             the_CPU_delta := the_CPU_delta + 3;
  1149.
  1150.          when others =>
  1151.             do_an_IO_order;
  1152.
  1153.       end case;
  1154.    end do_a_two_syllable_order;
  1155.
  1156.    procedure do_a_jump_order is
  1157.       RA        : KDF9.syllable_address;
  1158.       A         : KDF9.word;
  1159.    begin
  1160.       fetching_normally := True;
  1161.
  1162.       case INS.compressed_opcode is
  1163.
  1164.          when Jr =>
  1165.             set_NIA_to_the_INS_target_address;
  1166.             the_CPU_delta := the_CPU_delta + 8;
  1167.
  1168.          when JSr =>
  1169.             if the_sjns_depth < 16 or else the_CPU_state = Director_state  then
  1170.                push(CIA);
  1171.                set_NIA_to_the_INS_target_address;
  1172.                the_CPU_delta := the_CPU_delta + 11;
  1173.             else
  1174.                effect(NOUV_interrupt, "full SJNS");
  1175.             end if;
  1176.
  1177.          when JrEQ =>
  1178.             if the_nest_depth >= 2 or else the_CPU_state = Director_state then
  1179.                A := pop;
  1180.                if A = read_top then
  1181.                   set_NIA_to_the_INS_target_address;
  1182.                   the_CPU_delta := the_CPU_delta + 12;
  1183.                else
  1184.                   the_CPU_delta := the_CPU_delta + 5;
  1185.                end if;
  1186.             else
  1187.                effect(NOUV_interrupt, words_needed(need => 2-the_nest_depth));
  1188.             end if;
  1189.
  1190.          when JrNE =>
  1191.             if the_nest_depth >= 2 or else the_CPU_state = Director_state then
  1192.                A := pop;
  1193.                if A /= read_top then
  1194.                   set_NIA_to_the_INS_target_address;
  1195.                   the_CPU_delta := the_CPU_delta + 12;
  1196.                else
  1197.                   the_CPU_delta := the_CPU_delta + 5;
  1198.                end if;
  1199.             else
  1200.                effect(NOUV_interrupt, words_needed(need => 2-the_nest_depth));
  1201.             end if;
  1202.
  1203.          when JrGTZ =>
  1204.             if the_nest_depth >= 1 or else the_CPU_state = Director_state then
  1205.                if resign(pop) > 0 then
  1206.                   set_NIA_to_the_INS_target_address;
  1207.                   the_CPU_delta := the_CPU_delta + 11;
  1208.                else
  1209.                   the_CPU_delta := the_CPU_delta + 4;
  1210.                end if;
  1211.             else
  1212.                effect(NOUV_interrupt, "empty NEST");
  1213.             end if;
  1214.
  1215.          when JrLTZ =>
  1216.             if the_nest_depth >= 1 or else the_CPU_state = Director_state then
  1217.                A := pop;
  1218.                if resign(A) < 0 then
  1219.                   set_NIA_to_the_INS_target_address;
  1220.                   the_CPU_delta := the_CPU_delta + 11;
  1221.                else
  1222.                   the_CPU_delta := the_CPU_delta + 4;
  1223.                end if;
  1224.             else
  1225.                effect(NOUV_interrupt, "empty NEST");
  1226.             end if;
  1227.
  1228.          when JrEQZ =>
  1229.             if the_nest_depth >= 1 or else the_CPU_state = Director_state then
  1230.                 if pop = all_zero_bits then
  1231.                   set_NIA_to_the_INS_target_address;
  1232.                   the_CPU_delta := the_CPU_delta + 11;
  1233.                else
  1234.                   the_CPU_delta := the_CPU_delta + 4;
  1235.                end if;
  1236.             else
  1237.                effect(NOUV_interrupt, "empty NEST");
  1238.             end if;
  1239.
  1240.          when JrLEZ =>
  1241.             if the_nest_depth >= 1 or else the_CPU_state = Director_state then
  1242.                if resign(pop) <= 0 then
  1243.                   set_NIA_to_the_INS_target_address;
  1244.                   the_CPU_delta := the_CPU_delta + 11;
  1245.                else
  1246.                   the_CPU_delta := the_CPU_delta + 4;
  1247.                end if;
  1248.             else
  1249.                effect(NOUV_interrupt, "empty NEST");
  1250.             end if;
  1251.
  1252.          when JrGEZ =>
  1253.             if the_nest_depth >= 1 or else the_CPU_state = Director_state then
  1254.                if resign(pop) >= 0 then
  1255.                   set_NIA_to_the_INS_target_address;
  1256.                   the_CPU_delta := the_CPU_delta + 11;
  1257.                else
  1258.                   the_CPU_delta := the_CPU_delta + 4;
  1259.                end if;
  1260.             else
  1261.                effect(NOUV_interrupt, "empty NEST");
  1262.             end if;
  1263.
  1264.          when JrNEZ =>
  1265.             if the_nest_depth >= 1 or else the_CPU_state = Director_state then
  1266.                if pop /= all_zero_bits then
  1267.                   set_NIA_to_the_INS_target_address;
  1268.                   the_CPU_delta := the_CPU_delta + 11;
  1269.                else
  1270.                   the_CPU_delta := the_CPU_delta + 4;
  1271.                end if;
  1272.             else
  1273.                effect(NOUV_interrupt, "empty NEST");
  1274.             end if;
  1275.
  1276.          when JrV =>
  1277.             if the_V_bit_is_set then
  1278.                the_V_bit_is_set := False;
  1279.                set_NIA_to_the_INS_target_address;
  1280.                the_CPU_delta := the_CPU_delta + 10;
  1281.             else
  1282.                the_CPU_delta := the_CPU_delta + 3;
  1283.             end if;
  1284.
  1285.          when JrNV =>
  1286.             if the_V_bit_is_set then
  1287.                the_V_bit_is_set := False;
  1288.                the_CPU_delta := the_CPU_delta + 3;
  1289.             else
  1290.                set_NIA_to_the_INS_target_address;
  1291.                the_CPU_delta := the_CPU_delta + 10;
  1292.             end if;
  1293.
  1294.          when JrEN =>
  1295.             the_trace_operand := KDF9.word(the_nest_depth);
  1296.             if the_nest_depth = 0 then
  1297.                set_NIA_to_the_INS_target_address;
  1298.                the_CPU_delta := the_CPU_delta + 10;
  1299.             else
  1300.                the_CPU_delta := the_CPU_delta + 3;
  1301.             end if;
  1302.
  1303.          when JrNEN =>
  1304.             the_trace_operand := KDF9.word(the_nest_depth);
  1305.             if the_nest_depth /= 0 then
  1306.                set_NIA_to_the_INS_target_address;
  1307.                the_CPU_delta := the_CPU_delta + 10;
  1308.             else
  1309.                the_CPU_delta := the_CPU_delta + 3;
  1310.             end if;
  1311.
  1312.          when JrEJ =>
  1313.             the_trace_operand := KDF9.word(the_sjns_depth);
  1314.             if the_sjns_depth = 0 then
  1315.                set_NIA_to_the_INS_target_address;
  1316.                the_CPU_delta := the_CPU_delta + 10;
  1317.             end if;
  1318.             the_CPU_delta := the_CPU_delta + 3;
  1319.
  1320.          when JrNEJ =>
  1321.             the_trace_operand := KDF9.word(the_sjns_depth);
  1322.             if the_sjns_depth /= 0 then
  1323.                set_NIA_to_the_INS_target_address;
  1324.                the_CPU_delta := the_CPU_delta + 10;
  1325.             end if;
  1326.             the_CPU_delta := the_CPU_delta + 3;
  1327.
  1328.          when JrTR =>
  1329.             if the_T_bit_is_set then
  1330.                the_T_bit_is_set := False;
  1331.                set_NIA_to_the_INS_target_address;
  1332.                the_CPU_delta := the_CPU_delta + 10;
  1333.             else
  1334.                the_CPU_delta := the_CPU_delta + 3;
  1335.             end if;
  1336.
  1337.          when JrNTR =>
  1338.             if the_T_bit_is_set then
  1339.                the_T_bit_is_set := False;
  1340.                the_CPU_delta := the_CPU_delta + 3;
  1341.             else
  1342.                set_NIA_to_the_INS_target_address;
  1343.                the_CPU_delta := the_CPU_delta + 10;
  1344.             end if;
  1345.
  1346.          when EXIT_n =>
  1347.             if the_sjns_depth > 0 or else the_CPU_state = Director_state then
  1348.                RA := pop;
  1349.                if INS.target.syllable_index = 3 then  -- c.f. decode_a_jump_order.
  1350.                   increment_by_3(RA);
  1351.                end if;
  1352.                RA.order_word_number := RA.order_word_number+INS.target.order_word_number;
  1353.                set_NIA_to(RA);
  1354.                the_CPU_delta := the_CPU_delta + 12 + KDF9.us(INS.target.syllable_index mod 2);
  1355.             else
  1356.                effect(NOUV_interrupt, "empty SJNS");
  1357.             end if;
  1358.
  1359.          when EXITD =>
  1360.             fail_in_problem_program_state;
  1361.             if the_sjns_depth = 0 then
  1362.                -- This indicates a serious failure in Director; best to abandon it at once.
  1363.                trap_illegal_instruction("empty SJNS in Director");
  1364.             end if;
  1365.             RA := pop;
  1366.             the_CPU_delta := the_CPU_delta + 11;
  1367.             return_from_Director_to(RA);
  1368.
  1369.          when JrCqZ =>
  1370.             if the_Q_store(INS.Qq).C = 0 then
  1371.                set_NIA_to_the_INS_target_address;
  1372.                the_CPU_delta := the_CPU_delta + 11;
  1373.             else
  1374.                the_CPU_delta := the_CPU_delta + 4;
  1375.             end if;
  1376.
  1377.          when JrCqNZ =>
  1378.             if the_Q_store(INS.Qq).C /= 0 then
  1379.                set_NIA_to_the_INS_target_address;
  1380.                the_CPU_delta := the_CPU_delta + 11;
  1381.             else
  1382.                the_CPU_delta := the_CPU_delta + 4;
  1383.             end if;
  1384.
  1385.          when OS_OUT =>
  1386.             the_CPU_delta := the_CPU_delta + 13;
  1387.             if the_sjns_depth < 16 or else the_CPU_state = Director_state then
  1388.                A := (if the_nest_depth = 0 then 0 else read_top);
  1389.                if the_execution_mode = boot_mode then
  1390.                   effect(OUT_interrupt, A'Image);
  1391.                   -- We get here only in Director state, when the OUT does not interrupt.
  1392.                   -- Arguably, this should be notified as an error.
  1393.                   return; -- OUT has the effect of a no-op in Director state.
  1394.                end if;
  1395.                -- Emulate a subset of the appropriate Director's API.
  1396.                if A < 100 then
  1397.                   do_a_TSD_OUT(OUT_number => A);
  1398.                elsif A < 200 then
  1399.                   do_an_EGDON_OUT(OUT_number => A);
  1400.                else
  1401.                   do_some_other_OUT(OUT_number => A);
  1402.                end if;
  1403.             else
  1404.                effect(NOUV_interrupt, "full SJNS in OUT");
  1405.             end if;
  1406.
  1407.          when others =>
  1408.             trap_illegal_instruction;
  1409.
  1410.       end case;
  1411.    end do_a_jump_order;
  1412.
  1413.    procedure do_a_data_access_order is
  1414.    begin
  1415.       case INS.compressed_opcode is
  1416.
  1417.          when EaMq =>
  1418.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1419.             check_address_and_lockout(the_trace_address);
  1420.             ensure_that_the_nest_has_room_for_a_result;
  1421.             the_trace_operand := fetch_word(the_trace_address);
  1422.             push(the_trace_operand);
  1423.             the_CPU_delta := the_CPU_delta + 6;
  1424.
  1425.          when TO_EaMq =>
  1426.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1427.             check_address_and_lockout(the_trace_address);
  1428.             ensure_that_the_nest_holds_an_operand;
  1429.             the_trace_operand := pop;
  1430.             store_word(the_trace_operand, the_trace_address);
  1431.             the_CPU_delta := the_CPU_delta + 6;
  1432.
  1433.          when EaMqQ =>
  1434.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1435.             check_address_and_lockout(the_trace_address);
  1436.             ensure_that_the_nest_has_room_for_a_result;
  1437.             the_trace_operand := fetch_word(the_trace_address);
  1438.             push(the_trace_operand);
  1439.             auto_increment;
  1440.             the_CPU_delta := the_CPU_delta + 7;
  1441.
  1442.          when TO_EaMqQ =>
  1443.             the_trace_address := valid_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1444.             check_address_and_lockout(the_trace_address);
  1445.             ensure_that_the_nest_holds_an_operand;
  1446.             the_trace_operand := pop;
  1447.             store_word(the_trace_operand, the_trace_address);
  1448.             auto_increment;
  1449.             the_CPU_delta := the_CPU_delta + 7;
  1450.
  1451.          when SET =>
  1452.             ensure_that_the_nest_has_room_for_a_result;
  1453.             the_trace_operand := sign_extended(INS.operand);
  1454.             push(the_trace_operand);
  1455.             the_CPU_delta := the_CPU_delta + 4;
  1456.
  1457.          when others =>
  1458.             trap_illegal_instruction;
  1459.
  1460.       end case;
  1461.    end do_a_data_access_order;
  1462.
  1463.    procedure update_the_virtual_clocks
  1464.       with Inline;
  1465.
  1466.    procedure update_the_virtual_clocks is
  1467.    begin
  1468.       the_CPU_time := the_CPU_time + the_CPU_delta;
  1469.       the_elapsed_time := the_elapsed_time + the_CPU_delta;
  1470.       if the_CPU_time > the_elapsed_time then
  1471.          the_elapsed_time := the_CPU_time;
  1472.       end if;
  1473.       ICR := ICR + 1;
  1474.    end update_the_virtual_clocks;
  1475.
  1476.    procedure do_a_fast_time_slice is
  1477.    begin
  1478.
  1479.       if break_in.has_been_requested then
  1480.          break_in.handler;
  1481.       end if;
  1482.
  1483.       for i in 1 .. time_slice loop
  1484.
  1485.          the_CPU_delta := 0;
  1486.
  1487.          process_syllable_0_of_INS;
  1488.          case INS.kind is
  1489.             when one_syllable_order =>
  1490.                do_a_one_syllable_order;
  1491.             when two_syllable_order =>
  1492.                process_syllable_1_of_INS;
  1493.                do_a_two_syllable_order;
  1494.             when normal_jump_order =>
  1495.                process_syllables_1_and_2_of_a_jump_order;
  1496.                do_a_jump_order;
  1497.             when data_access_order =>
  1498.                process_syllables_1_and_2_of_a_data_access_order;
  1499.                do_a_data_access_order;
  1500.          end case;
  1501.
  1502.          update_the_virtual_clocks;
  1503.          check_for_a_clock_interrupt;
  1504.          if the_elapsed_time > the_next_interrupt_time then
  1505.             act_on_pending_interrupts;
  1506.          end if;
  1507.
  1508.       end loop;
  1509.
  1510.    exception
  1511.
  1512.       when program_exit =>
  1513.          complete_all_extant_transfers;
  1514.          update_the_virtual_clocks;
  1515.          synchronize_the_real_and_virtual_times;
  1516.          raise;
  1517.
  1518.       when program_restart =>
  1519.          complete_all_extant_transfers;
  1520.          update_the_virtual_clocks;
  1521.          synchronize_the_real_and_virtual_times;
  1522.          complete_TSD_OUT_2(the_trace_operand);
  1523.
  1524.    end do_a_fast_time_slice;
  1525.
  1526.    procedure do_a_traced_instruction_cycle is
  1527.       use tracing.order_flags;
  1528.
  1529.       procedure finalize_the_traced_instruction_execution is
  1530.       begin
  1531.          update_the_virtual_clocks;
  1532.          synchronize_the_real_and_virtual_times;
  1533.
  1534.          if ICR in low_count .. high_count            and then
  1535.                NIA_word_number in low_bound .. high_bound then
  1536.             take_note_of(the_trace_operand);
  1537.             if the_signature_is_enabled then
  1538.                update_the_digital_signature;
  1539.             end if;
  1540.             if the_histogram_is_enabled then
  1541.                add_INS_to_the_histogram;
  1542.                add_CIA_to_the_profile;
  1543.             end if;
  1544.             if the_external_trace_is_enabled then
  1545.                log_to_external_trace;
  1546.             end if;
  1547.             case INS.kind is
  1548.                when two_syllable_order =>
  1549.                   act_on_any_two_syllable_order_watchpoints;
  1550.                when data_access_order =>
  1551.                   act_on_any_data_access_order_watchpoints;
  1552.                when others =>
  1553.                   null;
  1554.             end case;
  1555.          end if;
  1556.       end finalize_the_traced_instruction_execution;
  1557.
  1558.    begin  -- do_a_traced_instruction_cycle
  1559.
  1560.       if break_in.has_been_requested then
  1561.          break_in.handler;
  1562.       end if;
  1563.
  1564.       the_trace_operand := 0;
  1565.       the_trace_address := 0;
  1566.       the_CPU_delta := 0;
  1567.
  1568.       process_syllable_0_of_INS;
  1569.
  1570.       case INS.kind is
  1571.          when one_syllable_order =>
  1572.             preview_a_one_syllable_order;
  1573.                do_a_one_syllable_order;
  1574.             look_back_at_a_one_syllable_order;
  1575.          when two_syllable_order =>
  1576.             process_syllable_1_of_INS;
  1577.             preview_a_two_syllable_order;
  1578.                do_a_two_syllable_order;
  1579.             look_back_at_a_two_syllable_order;
  1580.          when normal_jump_order =>
  1581.             process_syllables_1_and_2_of_a_jump_order;
  1582.             preview_a_jump_order;
  1583.                do_a_jump_order;
  1584.             look_back_at_a_jump_order;
  1585.          when data_access_order =>
  1586.             process_syllables_1_and_2_of_a_data_access_order;
  1587.             preview_a_data_access_order;
  1588.                do_a_data_access_order;
  1589.             look_back_at_a_data_access_order;
  1590.       end case;
  1591.
  1592.       finalize_the_traced_instruction_execution;
  1593.
  1594.       if ICR >= time_limit then
  1595.          raise time_expired;
  1596.       end if;
  1597.
  1598.       if (NIA_word_number / breakpoints      and then
  1599.              ICR in low_count .. high_count)  or else
  1600.                 the_diagnostic_mode = pause_mode then
  1601.          handle_breakpoint;
  1602.       end if;
  1603.
  1604.       check_for_a_clock_interrupt;
  1605.       if the_elapsed_time > the_next_interrupt_time then
  1606.          act_on_pending_interrupts;
  1607.       end if;
  1608.
  1609.    exception
  1610.
  1611.       when program_exit =>
  1612.          case INS.kind is
  1613.             when one_syllable_order =>
  1614.                look_back_at_a_one_syllable_order;
  1615.             when two_syllable_order =>
  1616.                look_back_at_a_two_syllable_order;
  1617.             when normal_jump_order =>
  1618.                look_back_at_a_jump_order;
  1619.             when data_access_order =>
  1620.                look_back_at_a_data_access_order;
  1621.          end case;
  1622.          complete_all_extant_transfers;
  1623.          finalize_the_traced_instruction_execution;
  1624.          raise;
  1625.
  1626.       when program_restart =>
  1627.          complete_all_extant_transfers;
  1628.          finalize_the_traced_instruction_execution;
  1629.          complete_TSD_OUT_2(the_trace_operand);
  1630.
  1631.    end do_a_traced_instruction_cycle;
  1632.
  1633. end KDF9.microcode;

Compiling: ../Source/kdf9-microcode.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:23

     1. -- kdf9-microcode.ads
     2. --
     3. -- KDF9 ISP emulation - CPU microcode routines.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package KDF9.microcode is
    20.
    21.    procedure do_a_fast_time_slice;
    22.
    23.    procedure do_a_traced_instruction_cycle;
    24.
    25. end KDF9.microcode;

 1633 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/state_display.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:24

     1. -- state_display.adb
     2. --
     3. -- Provide the comprehensive machine-state display panel KDF9 never had.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Characters.Latin_1;
    20. with Ada.Exceptions;
    21. with Ada.Long_Float_Text_IO;
    22. --
    23. with disassembly;
    24. with dumping;
    25. with exceptions;
    26. with formatting;
    27. with generic_sets;
    28. with HCI;
    29. with IOC;
    30. with IOC.fast.DR;
    31. with IOC.fast.FD;
    32. with KDF9_char_sets;
    33. with KDF9.CPU;
    34. with KDF9.decoding;
    35. with KDF9.PHU_store;
    36. with KDF9.store;
    37. with logging.file;
    38. with settings;
    39. with tracing;
    40.
    41. with IOC.diagnostics;
    42.
    43. use  Ada.Characters.Latin_1;
    44. use  Ada.Exceptions;
    45. use  Ada.Long_Float_Text_IO;
    46. --
    47. use  disassembly;
    48. use  dumping;
    49. use  exceptions;
    50. use  formatting;
    51. use  HCI;
    52. use  IOC;
    53. use  IOC.fast.DR;
    54. use  IOC.fast.FD;
    55. use  KDF9_char_sets;
    56. use  KDF9.CPU;
    57. use  KDF9.decoding;
    58. use  KDF9.PHU_store;
    59. use  KDF9.store;
    60. use  logging.file;
    61. use  settings;
    62. use  tracing;
    63.
    64. package body state_display is
    65.
    66.    procedure show_IM_parts (the_Q_register : in KDF9.Q_register;
    67.                             width          : in Positive := 8) is
    68.    begin
    69.       log(
    70.           "/"
    71.         & just_right("#" & oct_of(the_Q_register.I, width-2), width)
    72.         & "/"
    73.         & just_right("#" & oct_of(the_Q_register.M, width-2), width)
    74.          );
    75.    end show_IM_parts;
    76.
    77.    procedure show_IO_register (the_Q_register : in KDF9.Q_register;
    78.                                width          : in Positive := 8;
    79.                                for_DR,
    80.                                for_FD,
    81.                                for_FH,
    82.                                for_seek,
    83.                                for_OUT         : in Boolean  := False) is
    84.    begin
    85.       log('Q');
    86.       if for_FD then
    87.          log(just_right(as_FD_command(the_Q_register, for_FD and for_seek, for_FD and for_FH), width));
    88.       elsif for_DR then
    89.          log(just_right(as_DR_command(the_Q_register, for_OUT), width));
    90.       else
    91.          log(just_right("#" & oct_of(the_Q_register.C, width-2), width));
    92.       end if;
    93.       show_IM_parts(the_Q_register, width);
    94.    end show_IO_register;
    95.
    96.    procedure show_Q_register (the_Q_register : in KDF9.Q_register;
    97.                               width          : in Positive := 8) is
    98.    begin
    99.       log('Q' & just_right("#" & oct_of(the_Q_register.C, width-2), width));
   100.       show_IM_parts(the_Q_register, width);
   101.    end show_Q_register;
   102.
   103.    procedure show_Q_in_decimal (the_Q_register : in KDF9.Q_register;
   104.                                 width          : in Positive := 7) is
   105.    begin
   106.       log(
   107.           'Q'
   108.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.C)), width)
   109.         & "/"
   110.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.I)), width)
   111.         & "/"
   112.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.M)), width)
   113.          );
   114.    end show_Q_in_decimal;
   115.
   116.    procedure show_in_syllables_form (the_word : in KDF9.word) is
   117.       word : KDF9.word := the_word;
   118.       syllable : KDF9.syllable;
   119.    begin
   120.       for b in 0 .. 5 loop
   121.          word := rotate_word_left(word, 8);
   122.          syllable := KDF9.syllable(word and 8#377#);
   123.          log("#" & just_right(oct_of(syllable), 3) & " ");
   124.       end loop;
   125.    end show_in_syllables_form;
   126.
   127.    procedure show_as_characters (the_word : in KDF9.word) is
   128.       word : KDF9.word := the_word;
   129.       data : String(1 .. 8);
   130.    begin
   131.       for b of reverse data loop
   132.          b := glyph_for(to_CP(KDF9_char_sets.symbol(word and 8#77#)));
   133.          word := shift_logical(word, -6);
   134.       end loop;
   135.       log(data);
   136.    end show_as_characters;
   137.
   138.   procedure show_in_various_formats (the_word : in KDF9.word;
   139.                                      column   : in Positive := 5) is
   140.       image : String(1 .. 21);
   141.    begin
   142.       log_octal(the_word);
   143.       log(" = " & just_right(trimmed(CPU.signed'Image(resign(the_word))), 16) & " = ");
   144.       Put(image, host_float(CPU.f48(the_word)), Aft => 12, Exp => 2);
   145.       log(trimmed(image) & " = ");
   146.       log(as_fraction(the_word)'Image);
   147.       log_new_line;
   148.       tab_log_to(column);
   149.       log(" = ");
   150.       show_Q_register(as_Q(the_word));
   151.       log("   = ");
   152.       show_Q_in_decimal(as_Q(the_word));
   153.       log_new_line;
   154.       tab_log_to(column);
   155.       log(" = ");
   156.       show_in_syllables_form(the_word);
   157.       log("= """);
   158.       show_as_characters(the_word);
   159.       log("""");
   160.    end show_in_various_formats;
   161.
   162.    procedure show_progress is
   163.
   164.       function readable (t : KDF9.us)
   165.       return String is
   166.          t_plus_5E2 : constant KDF9.us := (t + 5E2)/ 1E3;
   167.          t_plus_5E5 : constant KDF9.us := (t + 5E5)/ 1E6;
   168.       begin
   169.          return (if t < 1E3 then
   170.                     ""
   171.               elsif t < 1E6 then
   172.                     " about" & t_plus_5E2'Image & " ms"
   173.               else  " about" & t_plus_5E5'Image & " sec" );
   174.       end readable;
   175.
   176.       CPU : constant String := " KDF9 us. (RAN)" & readable(the_CPU_time);
   177.       EL  : constant String := " KDF9 us. (EL) " & readable(the_clock_time);
   178.
   179.    begin
   180.       log_line("ORDERS:     " & just_right(ICR'Image, 10) & " executed (ICR)");
   181.       log_line("CPU TIME:   " & just_right(the_CPU_time'Image, 10) & CPU);
   182.       log_line("CLOCK TIME: " & just_right(KDF9.us'Image(the_clock_time), 10) & EL);
   183.    end show_progress;
   184.
   185.    slot_name : constant array (KDF9.context) of String(1..1)  := ("P", "Q", "R", "S");
   186.
   187.    procedure show_Director_registers is
   188.       interval : constant KDF9.us := the_clock_time - the_last_K4_time;
   189.    begin
   190.       log_line("The CPU is in " & the_CPU_state'Image);
   191.       log_line("CONTEXT:  " & slot_name(the_context));
   192.       log_line("PRIORITY: " & just_right(CPL'Image, 1));
   193.       log_line("BA:       " & just_right("#" & oct_of(BA), 6));
   194.       log_line("NOL:      " & just_right("#" & oct_of(NOL), 6));
   195.       log("CPDAR:    ");
   196.       for i in KDF9.buffer_number loop
   197.          log(if the_CPDAR(i) then device_name_of(buffer(i).all) & " " else "");
   198.       end loop;
   199.       log_new_line;
   200.       log_new_line;
   201.       log_line("PHU stores:");
   202.       for p in KDF9.priority loop
   203.          log("PHU" & p'Image & " is ");
   204.          if PHU(p).is_held_up then
   205.             if PHU(p).blockage.reason = buffer_busy then
   206.                log("waiting for " & device_name_of(IOC.device_number(PHU(p).blockage.buffer_nr)));
   207.                log(" on buffer #" & oct_of(PHU(p).blockage.buffer_nr, 2));
   208.                if PHU(p).blockage.by_INTQq then
   209.                   log(", because of INTQq");
   210.                end if;
   211.             else
   212.                log("locked out of group" & KDF9.store.group_address'Image(PHU(p).blockage.group_nr));
   213.             end if;
   214.          else
   215.             log("idle");
   216.          end if;
   217.          log_new_line;
   218.       end loop;
   219.       log_new_line;
   220.       log_line("RFIR (Interrupt Flags):");
   221.       log_line(
   222.                "CLOCK:    "
   223.              & Boolean'Image(interval >= 2**20)
   224.              & "; time since last CLOCK interrupt ="
   225.              & KDF9.us'Image(interval)
   226.              & " KDF9 us."
   227.               );
   228.       log_line("PR:       " & Boolean'Image(the_RFIR(PR_interrupt)));
   229.       log_line("FLEX:     " & Boolean'Image(the_RFIR(FLEX_interrupt)));
   230.       log_line("LIV:      " & Boolean'Image(the_RFIR(LIV_interrupt)));
   231.       log_line("NOUV:     " & Boolean'Image(the_RFIR(NOUV_interrupt)));
   232.       log_line("EDT:      " & Boolean'Image(the_RFIR(EDT_interrupt)));
   233.       log_line("OUT:      " & Boolean'Image(the_RFIR(OUT_interrupt)));
   234.       log_line("LOV:      " & Boolean'Image(the_RFIR(LOV_interrupt)));
   235.       log_line("RESET:    " & Boolean'Image(the_RFIR(RESET_interrupt)));
   236.    end show_Director_registers;
   237.
   238.    procedure show_V_and_T is
   239.    begin
   240.       if the_V_bit_is_set or the_T_bit_is_set then
   241.          log_new_line;
   242.          if the_V_bit_is_set then
   243.             log("V is set. ");
   244.          else
   245.             log("V is clear. ");
   246.          end if;
   247.          if the_T_bit_is_set then
   248.             log("T is set. ");
   249.          else
   250.             log("T is clear. ");
   251.          end if;
   252.          log_new_line;
   253.       end if;
   254.    end show_V_and_T;
   255.
   256.    procedure show_nest (when_empty : Boolean := True) is
   257.    begin
   258.       if the_nest_depth = 0 then
   259.          if when_empty then
   260.             log_line("The NEST is empty.");
   261.          end if;
   262.       else
   263.          log_line("NEST:");
   264.          for i in reverse KDF9.nest_depth loop
   265.             if i < the_nest_depth then
   266.                log(just_right("N" & trimmed(KDF9.nest_depth'Image(the_nest_depth-i)), 3) & ": ");
   267.                log_new_line;
   268.                show_in_various_formats(the_nest(i));
   269.                log_new_line;
   270.             end if;
   271.          end loop;
   272.       end if;
   273.    end show_nest;
   274.
   275.    procedure show_sjns (when_empty : Boolean := True) is
   276.    begin
   277.       if the_sjns_depth = 0 then
   278.          if when_empty then
   279.             log_line("The SJNS is empty.");
   280.          end if;
   281.       else
   282.          log_line("SJNS:");
   283.       end if;
   284.       for i in reverse KDF9.sjns_depth loop
   285.          if i < the_sjns_depth then
   286.             log(just_right("S" & trimmed(KDF9.sjns_depth'Image(the_sjns_depth-i)), 3) & ": ");
   287.             log_line(oct_of(the_sjns(i)) & " (" & dec_of(KDF9.syllable_address(the_sjns(i))) & ")");
   288.          end if;
   289.       end loop;
   290.    end show_sjns;
   291.
   292.    procedure show_Q_store is
   293.       Q_bits  : KDF9.word := 0;
   294.    begin
   295.       for Qq of the_Q_store loop
   296.          Q_bits := Q_bits or as_word(Qq);
   297.       end loop;
   298.       if Q_bits = 0 then
   299.          log_line("Q store: all zero.");
   300.          return;
   301.       else
   302.          log_line("Q store:");
   303.       end if;
   304.       for q in KDF9.Q_store'Range loop
   305.          if as_word(the_Q_store(q)) /= KDF9.word'(0) then
   306.             log(just_right("Q" & trimmed(q'Image), 3) & ": ");
   307.             show_Q_register(the_Q_store(q));
   308.             log("  = ");
   309.             show_Q_in_decimal(the_Q_store(q));
   310.             log_new_line;
   311.          end if;
   312.       end loop;
   313.    end show_Q_store;
   314.
   315.    procedure show_registers is
   316.    begin
   317.       show_progress;
   318.       log_new_line;
   319.       if the_execution_mode = boot_mode then
   320.          show_Director_registers;
   321.          log_new_line;
   322.       end if;
   323.       show_sjns;
   324.       log_new_line;
   325.       show_Q_store;
   326.       show_V_and_T;
   327.       log_new_line;
   328.       show_nest;
   329.    end show_registers;
   330.
   331.    procedure show_order is
   332.    begin
   333.       log(the_code_and_name_of_INS);
   334.    end show_order;
   335.
   336.    procedure show_execution_context is
   337.    begin
   338.       log("At "
   339.         & oct_of(CIA)
   340.         & " ("
   341.         & dec_of(CIA)
   342.         & ")"
   343.         & "; ICR ="
   344.         & ICR'Image
   345.         & "; EL ="
   346.         & the_clock_time'Image
   347.         & "; the instruction was ");
   348.       show_order;
   349.       log_new_line;
   350.    end show_execution_context;
   351.
   352.    procedure log_to_external_trace is
   353.    begin
   354.       log(the_external_trace_file, oct_of(CIA));
   355.       tab_log_to(the_external_trace_file, 10);
   356.       log(the_external_trace_file, ICR'Image);
   357.       tab_log_to(the_external_trace_file, 20);
   358.       if only_signature_tracing then
   359.          log(
   360.              the_external_trace_file,
   361.              "#"
   362.            & oct_of(the_digital_signature)
   363.            & (if the_V_bit_is_set then "V" else " ")
   364.            & (if the_T_bit_is_set then "T" else " ")
   365.             );
   366.          tab_log_to(the_external_trace_file, 40);
   367.          if the_nest_depth > 0 then
   368.             log(the_external_trace_file, "#" & oct_of(read_top));
   369.          end if;
   370.          tab_log_to(the_external_trace_file, 58);
   371.       else
   372.          log(the_external_trace_file, the_CPU_time'Image);
   373.          tab_log_to(the_external_trace_file, 40);
   374.          log(the_external_trace_file, the_nest_depth'Image);
   375.          tab_log_to(the_external_trace_file, 43);
   376.          log(the_external_trace_file, the_sjns_depth'Image);
   377.          tab_log_to(the_external_trace_file, 46);
   378.          log(the_external_trace_file, (if the_V_bit_is_set then "V" else " "));
   379.          log(the_external_trace_file, (if the_T_bit_is_set then "T" else " "));
   380.          tab_log_to(the_external_trace_file, 50);
   381.          if the_nest_depth > 0 then
   382.             log(the_external_trace_file, "#" & oct_of(read_top));
   383.          end if;
   384.          tab_log_to(the_external_trace_file, 68);
   385.       end if;
   386.       log(the_external_trace_file, " |" & the_full_name_of(INS));
   387.       tab_log_to(the_external_trace_file, 90);
   388.       log(the_external_trace_file, KDF9.us'Image(the_clock_time));
   389.       log_new_line(the_external_trace_file);
   390.    end log_to_external_trace;
   391.
   392.    procedure log_an_external_trace_header is
   393.    begin
   394.       log(the_external_trace_file, "LOCATION");
   395.       tab_log_to(the_external_trace_file, 11);
   396.       log(the_external_trace_file, "ICR");
   397.       tab_log_to(the_external_trace_file, 20);
   398.       if only_signature_tracing then
   399.          log(the_external_trace_file, "DIGITAL SIGNATURE");
   400.          tab_log_to(the_external_trace_file, 40);
   401.          log(the_external_trace_file, "[N1]");
   402.          tab_log_to(the_external_trace_file, 58);
   403.       else
   404.          log(the_external_trace_file, " CPU");
   405.          tab_log_to(the_external_trace_file, 40);
   406.          log(the_external_trace_file, "ND");
   407.          tab_log_to(the_external_trace_file, 43);
   408.          log(the_external_trace_file, "SD");
   409.          tab_log_to(the_external_trace_file, 46);
   410.          log(the_external_trace_file, "VT");
   411.          tab_log_to(the_external_trace_file, 50);
   412.          log(the_external_trace_file, "[N1]");
   413.          tab_log_to(the_external_trace_file, 68);
   414.       end if;
   415.       log(the_external_trace_file, " |INSTRUCTION");
   416.       log_new_line(the_external_trace_file);
   417.    end log_an_external_trace_header;
   418.
   419.    procedure show_CIA_and_NIA is
   420.    begin
   421.       log_line("CIA:        " & just_right(oct_of(CIA), 10) & " (" & just_right(dec_of(CIA) & ")"));
   422.       log_line("NIA:        " & just_right(oct_of(NIA), 10) & " (" & just_right(dec_of(NIA) & ")"));
   423.    end show_CIA_and_NIA;
   424.
   425.    procedure long_witness is
   426.    begin
   427.       log_new_line;
   428.       log("At " & oct_of(CIA) & " (" & dec_of(CIA) & ") the instruction was ");
   429.       show_order;
   430.       log_new_line;
   431.       show_registers;
   432.    end long_witness;
   433.
   434.    procedure short_witness is
   435.
   436.       type register_usage is array (KDF9.compressed_opcode) of Boolean
   437.          with Size => 64, Component_Size => 1;
   438.
   439.       it_uses_JB : constant register_usage
   440.                  := (
   441.                       LINK
   442.                     | TO_LINK
   443.                     | OS_OUT
   444.                     | JrNEJ
   445.                     | JSr
   446.                     | EXIT_n
   447.                     | JrEJ
   448.                     | EXITD     => True,
   449.                       others    => False
   450.                     );
   451.
   452.       it_uses_Qq : constant register_usage
   453.                  := (
   454.                       MkMq
   455.                     | MkMqQ
   456.                     | MkMqH
   457.                     | MkMqQH
   458.                     | MkMqN
   459.                     | MkMqQN
   460.                     | MkMqHN
   461.                     | MkMqQHN
   462.                     | TO_MkMq
   463.                     | TO_MkMqQ
   464.                     | TO_MkMqH
   465.                     | TO_MkMqQH
   466.                     | TO_MkMqN
   467.                     | TO_MkMqQN
   468.                     | TO_MkMqHN
   469.                     | TO_MkMqQHN
   470.                     | MqTOQk
   471.                     | IqTOQk
   472.                     | IMqTOQk
   473.                     | CqTOQk
   474.                     | CMqTOQk
   475.                     | CIqTOQk
   476.                     | QqTOQk
   477.                     | M_PLUS_Iq
   478.                     | M_MINUS_Iq
   479.                     | NCq
   480.                     | DCq
   481.                     | POS1_TO_Iq
   482.                     | NEG1_TO_Iq
   483.                     | POS2_TO_Iq
   484.                     | NEG2_TO_Iq
   485.                     | SHA
   486.                     | SHAD
   487.                     | MACC
   488.                     | SHL
   489.                     | SHLD
   490.                     | SHC
   491.                     | TO_RCIMq
   492.                     | QCIMq
   493.                     | ADD_TO_QCIMq
   494.                     | JCqNZS
   495.                     | PAR_Qq
   496.                     | PIA_PIC_CLO_TLO_Qq
   497.                     | PIB_PID_Qq
   498.                     | PIE_PIG_Qq
   499.                     | PIF_PIH_Qq
   500.                     | PMA_PMK_INT_Qq
   501.                     | CT_PMB_PMC_BUSY_Qq
   502.                     | PMD_PME_PML_Qq
   503.                     | PMF_PMG_Qq
   504.                     | POA_POC_POE_POF_PMH_Qq
   505.                     | POB_POD_Qq
   506.                     | POG_POL_Qq
   507.                     | POH_POK_Qq
   508.                     | JrCqNZ    => True,
   509.                       others    => False
   510.                     );
   511.
   512.       is_modified : constant register_usage
   513.                   := (
   514.                        EaMq
   515.                      | TO_EaMq
   516.                      | EaMqQ
   517.                      | TO_EaMqQ  => True,
   518.                        others    => False
   519.                      );
   520.
   521.       it_uses_Qk : constant register_usage
   522.                  := (
   523.                       MkMq
   524.                     | MkMqQ
   525.                     | MkMqH
   526.                     | MkMqQH
   527.                     | MkMqN
   528.                     | MkMqQN
   529.                     | MkMqHN
   530.                     | MkMqQHN
   531.                     | TO_MkMq
   532.                     | TO_MkMqQ
   533.                     | TO_MkMqH
   534.                     | TO_MkMqQH
   535.                     | TO_MkMqN
   536.                     | TO_MkMqQN
   537.                     | TO_MkMqHN
   538.                     | TO_MkMqQHN
   539.                     | MqTOQk
   540.                     | IqTOQk
   541.                     | IMqTOQk
   542.                     | CqTOQk
   543.                     | CMqTOQk
   544.                     | CIqTOQk
   545.                     | QqTOQk    => True,
   546.                       others    => False
   547.                     );
   548.
   549.       function INS_uses_Qq
   550.       return Boolean is
   551.          (
   552.           -- A compressed_opcode may be ambiguous: to know which opcode it represents,
   553.           --   further attributes of the order may need to be considered.
   554.           case INS.kind is
   555.              when two_syllable_order =>
   556.                 it_uses_Qq(INS.compressed_opcode)
   557.                   and
   558.                 -- If a shift, exclude fixed-amount shifts.
   559.                 ((INS.order.syllable_1 and 1) = 0 or else INS.compressed_opcode not in SHA..SHC),
   560.              when normal_jump_order =>
   561.                 INS.compressed_opcode in JrCqZ | JrCqNZ,
   562.              when data_access_order =>
   563.                 is_modified(INS.compressed_opcode),
   564.              when others =>
   565.                 False
   566.          );
   567.
   568.    begin  -- short_witness
   569.       log_new_line;
   570.       show_execution_context;
   571.       if the_CPU_state = Director_state then
   572.          show_Director_registers;
   573.       end if;
   574.       if it_uses_JB(INS.compressed_opcode)                     and then
   575.             INS.kind in two_syllable_order | normal_jump_order and then
   576.                the_sjns_depth > 0                                  then
   577.          log_line(
   578.                   " JB: "
   579.                 & oct_of(the_sjns(the_sjns_depth-1))
   580.                 & "; SJNS depth: " & just_right(the_sjns_depth'Image, 3)
   581.                  );
   582.       end if;
   583.       if INS.Qq /= 0 and then
   584.             INS_uses_Qq  then
   585.          log(just_right("Q" & trimmed(INS.Qq'Image), 3) & ": ");
   586.          show_Q_register(the_Q_store(INS.Qq));
   587.          log("  = ");
   588.          show_Q_in_decimal(the_Q_store(INS.Qq));
   589.          log_new_line;
   590.       end if;
   591.       if INS.Qk /= 0                       and then
   592.             INS.kind in two_syllable_order and then
   593.                it_uses_Qk(INS.compressed_opcode)    and then
   594.                   INS.Qq /= INS.Qk             then
   595.          log(just_right("Q" & trimmed(INS.Qk'Image), 3) & ": ");
   596.          show_Q_register(the_Q_store(INS.Qk));
   597.          log("  = ");
   598.          show_Q_in_decimal(the_Q_store(INS.Qk));
   599.          log_new_line;
   600.          log_new_line;
   601.       end if;
   602.       show_V_and_T;
   603.       show_nest(when_empty => False);
   604.       log_rule;
   605.    end short_witness;
   606.
   607.    procedure show_frequency_plots is
   608.
   609.       function summed_counts (from, to : KDF9.syllable)
   610.       return KDF9.order_counter is
   611.          sum : KDF9.order_counter := 0;
   612.       begin
   613.          for i in from .. to loop
   614.             sum := sum + the_histogram(i);
   615.          end loop;
   616.          return sum;
   617.       end summed_counts;
   618.
   619.       procedure log_opcode_bin (bin    : in KDF9.syllable;
   620.                                 sum    : in KDF9.order_counter;
   621.                                 bound  : in Long_Float) is
   622.          percent : Long_Float;
   623.          image   : String(1 .. 6);
   624.       begin
   625.          if sum /= 0 then
   626.             percent := Long_Float(sum)/Long_Float(ICR)*100.0;
   627.             if percent < bound then
   628.                return;
   629.             end if;
   630.             log(oct_of(bin) & ": " & the_short_name_of(bin));
   631.             tab_log_to(32);
   632.             log(sum'Image);
   633.             tab_log_to(42);
   634.             Put(image, percent, Aft => 2, Exp => 0);
   635.             log(image & "% :");
   636.             for i in 1 .. Integer(percent) loop
   637.                log("|");
   638.             end loop;
   639.             log_new_line;
   640.          end if;
   641.       end log_opcode_bin;
   642.
   643.       procedure log_opcode_usage (bound : in Long_Float) is
   644.       begin
   645.          for i in KDF9.syllable'(0) .. 8#167# loop
   646.             log_opcode_bin(i, the_histogram(i), bound);
   647.          end loop;
   648.          for i in KDF9.syllable'(8#170#) .. 8#237# loop
   649.             log_opcode_bin(i, the_histogram(i), bound);
   650.          end loop;
   651.          log_opcode_bin(8#240#, summed_counts(from => 8#240#, to => 8#257#), bound);
   652.          log_opcode_bin(8#260#, summed_counts(from => 8#240#, to => 8#277#), bound);
   653.          for i in KDF9.syllable'(8#300#) .. 8#377# loop
   654.             log_opcode_bin(i, the_histogram(i), bound);
   655.          end loop;
   656.       end log_opcode_usage;
   657.
   658.       accounted_for : Long_Float;
   659.       cutoff_image  : String(1 .. 7) := "      %";
   660.       percent_image : String(1 .. 7) := "      %";
   661.
   662.       procedure log_order_word_bin (bin    : in KDF9.order_word_number;
   663.                                     sum    : in KDF9.order_counter;
   664.                                     bound  : in Long_Float) is
   665.          percent : Long_Float;
   666.       begin
   667.          if sum /= 0 then
   668.             percent := Long_Float(sum)/Long_Float(ICR)*100.0;
   669.             if percent < bound then
   670.                return;
   671.             end if;
   672.             accounted_for := accounted_for + percent;
   673.             log("#" & oct_of(bin) & ": ");
   674.             tab_log_to(32);
   675.             log(sum'Image);
   676.             tab_log_to(42);
   677.             Put(percent_image, percent, Aft => 2, Exp => 0);
   678.             percent_image(7) := '%';
   679.             log(percent_image);
   680.             log(" :");
   681.             for i in 1 .. Integer(percent) loop
   682.                log("|");
   683.             end loop;
   684.             log_new_line;
   685.          end if;
   686.       end log_order_word_bin;
   687.
   688.       procedure log_profile (bound : in Long_Float) is
   689.       begin
   690.          accounted_for := 0.0;
   691.          for w in KDF9.order_word_number loop
   692.             if the_profile(w) /= 0 then
   693.                log_order_word_bin(w, the_profile(w), bound);
   694.             end if;
   695.          end loop;
   696.       end log_profile;
   697.
   698.       procedure sum_logged_frequencies (bound  : in Long_Float) is
   699.          percent : Long_Float;
   700.       begin
   701.          accounted_for := 0.0;
   702.          for w in KDF9.order_word_number loop
   703.             percent := Long_Float(the_profile(w))/Long_Float(ICR)*100.0;
   704.             if percent >= bound then
   705.                accounted_for := accounted_for + percent;
   706.             end if;
   707.          end loop;
   708.       end sum_logged_frequencies;
   709.
   710.    begin -- show_frequency_plots
   711.       Put(cutoff_image(1..6), histogram_cutoff, Aft => 2, Exp => 0);
   712.       cutoff_image(7) := '%';
   713.       if the_INS_plot_is_wanted and ICR /= 0 and the_diagnostic_mode /= fast_mode then
   714.          -- Print the instruction execution-frequency histogram.
   715.          log_title(
   716.                    "Histogram of the opcodes of"
   717.                  & ICR'Image
   718.                  & " executed instructions with frequency >="
   719.                  & cutoff_image
   720.                   );
   721.          log_opcode_usage(bound => histogram_cutoff);
   722.          log_new_line;
   723.       end if;
   724.       if the_profile_is_wanted and ICR /= 0 and the_diagnostic_mode /= fast_mode then
   725.          log_title(
   726.                    "Histogram of the loci of"
   727.                  & ICR'Image
   728.                  & " executed instructions with frequency >="
   729.                  & cutoff_image
   730.                   );
   731.          log_profile(bound => histogram_cutoff);
   732.          log_new_line;
   733.       end if;
   734.       sum_logged_frequencies(bound => histogram_cutoff);
   735.       Put(percent_image(1..6), accounted_for, Aft =>1, Exp => 0);
   736.       log_line("Executions accounted for in the profile:" & percent_image);
   737.       log_rule;
   738.    end show_frequency_plots;
   739.
   740.    function as_RFIR (K4_word : KDF9.word)
   741.    return KDF9.RFIR is
   742.       mask : KDF9.word := 2**16;
   743.       RFIR : KDF9.RFIR := (others => False);
   744.    begin
   745.       for r in reverse KDF9.interrupt_number loop
   746.          if (K4_word and mask) /= 0 then
   747.             RFIR(r) := True;
   748.          end if;
   749.          mask := 2 * mask;
   750.       end loop;
   751.       return RFIR;
   752.    end as_RFIR;
   753.
   754.    function for_FH_disc (compressed_opcode : KDF9.compressed_opcode; Pxy_bits : KDF9.Q_number)
   755.    return Boolean
   756.    is (case compressed_opcode is
   757.           when PIA_PIC_CLO_TLO_Qq     => Pxy_bits = PIC_bits,
   758.           when PIB_PID_Qq             => Pxy_bits = PID_bits,
   759.           when PIE_PIG_Qq             => Pxy_bits = PIG_bits,
   760.           when PIF_PIH_Qq             => Pxy_bits = PIH_bits,
   761.           when POA_POC_POE_POF_PMH_Qq => Pxy_bits = POC_bits,
   762.           when POB_POD_Qq             => Pxy_bits = POD_bits,
   763.           when POG_POL_Qq             => Pxy_bits = POL_bits,
   764.           when POH_POK_Qq             => Pxy_bits = POK_bits,
   765.           when others                 => False
   766.       );
   767.
   768.
   769.    first_col   : constant := 17;
   770.    device_col  : constant := first_col + 20;
   771.    operand_col : constant := device_col;
   772.    event_col   : constant := operand_col + 4;
   773.    is_D_col    : constant := event_col + 29;
   774.    depth_col   : constant := operand_col + 29;
   775.    time_col    : constant := depth_col + 11;
   776.    ICR_col     : constant := time_col + 13;
   777.
   778.    procedure show_retro_FIFO is
   779.
   780.       RFIR_id : constant array (KDF9.interrupt_number) of Character
   781.               := ('P', 'F', 'I', 'N', 'E', 'S', 'O', 'R', 'Y', 'Z');
   782.       image   : String(1 .. 21);
   783.       RFIR    : KDF9.RFIR;
   784.    begin
   785.       if retro_FIFO_count = 0 then
   786.          return;
   787.       end if;
   788.       log_title("Retrospective trace of all instructions.");
   789.       tab_log_to(depth_col);
   790.       log_line("ND SD VTD   CPU TIME     ICR");
   791.       for i in 1 .. retro_FIFO_count loop
   792.          if i = 1 then
   793.             log("Ended ");
   794.          else
   795.             log("After ");
   796.          end if;
   797.          declare
   798.             this      : tracing.retro_FIFO_entry renames retro_FIFO(retro_FIFO_index);
   799.             Q         : constant KDF9.Q_register := as_Q(this.parameter);
   800.             decoded   : KDF9.decoded_order;
   801.          begin
   802.             log(oct_of(this.location) & ":");
   803.             tab_log_to(first_col);
   804.             decoded.order := this.order;
   805.             decode(decoded);
   806.             log(the_full_name_of(decoded,
   807.                                  octal_option => decoded.kind = normal_jump_order,
   808.                                  both_bases   => False));
   809.             tab_log_to(operand_col);
   810.             case decoded.kind is
   811.                when one_syllable_order =>
   812.                   if this.nested > 0 then
   813.                      case decoded.compressed_opcode is
   814.                         when DIV
   815.                            | DIVD
   816.                            | X_frac =>
   817.                            log(CPU.fraction'Image(as_fraction(this.parameter)));
   818.                         when DIVI =>
   819.                            log(CPU.signed'Image(resign(this.parameter)));
   820.                         when STAND
   821.                            | ABSF
   822.                            | DIVDF
   823.                            | DIVF
   824.                            | FLOAT_9
   825.                            | FLOATD
   826.                            | MINUSDF
   827.                            | MINUSF
   828.                            | NEGDF
   829.                            | NEGF
   830.                            | PLUSDF
   831.                            | PLUSF
   832.                            | ROUNDF
   833.                            | ROUNDHF
   834.                            | XDF
   835.                            | XF
   836.                            | XPLUSF
   837.                            | MAXF =>
   838.                            Put(image, host_float(CPU.f48(this.parameter)), Aft => 12, Exp => 2);
   839.                            log(trimmed(image));
   840.                         when others =>
   841.                            if this.nested > 0 then
   842.                               log_octal(this.parameter);
   843.                            end if;
   844.                      end case;
   845.                   end if;
   846.                when two_syllable_order =>
   847.                   case decoded.compressed_opcode is
   848.                      when PAR_Qq =>
   849.                         show_IO_register(Q, for_DR => False, for_FD => False);
   850.                      when CT_PMB_PMC_BUSY_Qq
   851.                         | PMA_PMK_INT_Qq
   852.                         | PMD_PME_PML_Qq
   853.                         | PMF_PMG_Qq =>
   854.                         show_IO_register(
   855.                                          Q,
   856.                                          for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
   857.                                          for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
   858.                                          for_seek => decoded.Qk = PMA_bits
   859.                                         );
   860.                      when PIA_PIC_CLO_TLO_Qq
   861.                         | PIB_PID_Qq
   862.                         | PIE_PIG_Qq
   863.                         | PIF_PIH_Qq
   864.                         | POA_POC_POE_POF_PMH_Qq
   865.                         | POB_POD_Qq
   866.                         | POG_POL_Qq
   867.                         | POH_POK_Qq =>
   868.                         show_IO_register(
   869.                                          Q,
   870.                                          for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
   871.                                          for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
   872.                                          for_FH   => for_FH_disc(decoded.compressed_opcode, decoded.Qk)
   873.                                         );
   874.                      when M_PLUS_Iq
   875.                         | M_MINUS_Iq
   876.                         | NCq
   877.                         | DCq
   878.                         | POS1_TO_Iq
   879.                         | NEG1_TO_Iq
   880.                         | POS2_TO_Iq
   881.                         | NEG2_TO_Iq
   882.                         | CqTOQk
   883.                         | IqTOQk
   884.                         | MqTOQk
   885.                         | QqTOQk
   886.                         | CIqTOQk
   887.                         | IMqTOQk
   888.                         | CMqTOQk
   889.                         | TO_RCIMq
   890.                         | ADD_TO_QCIMq
   891.                         | JCqNZS =>
   892.                         show_Q_register(Q);
   893.                      when Kk =>
   894.                         case decoded.Qk is
   895.                            when K4 =>
   896.                               log(KDF9.word'Image(32*KDF9.word(Q.C)));
   897.                               log("us");
   898.                               if Q.I /= 0 then
   899.                                  log("; RFIR: ");
   900.                                  RFIR := as_RFIR(this.parameter);
   901.                                  for r in KDF9.interrupt_number loop
   902.                                     if RFIR(r) then
   903.                                        log(RFIR_id(r)&"");
   904.                                     end if;
   905.                                  end loop;
   906.                               end if;
   907.                               if resign(this.parameter) < 0 then
   908.                                  log("C");
   909.                               end if;
   910.                            when K5 | K7 =>
   911.                               log_octal(this.parameter);
   912.                            when others =>
   913.                               raise emulation_failure
   914.                                  with "invalid K order: #" & oct_of(decoded.compressed_opcode);
   915.                         end case;
   916.                      when TO_LINK =>
   917.                         log(oct_of(as_link(this.parameter)));
   918.                      when LINK =>
   919.                         log(oct_of(as_link(this.parameter)));
   920.                      when TO_MkMq
   921.                         | TO_MkMqQ
   922.                         | TO_MkMqH
   923.                         | TO_MkMqQH
   924.                         | TO_MkMqN
   925.                         | TO_MkMqQN
   926.                         | TO_MkMqHN
   927.                         | TO_MkMqQHN =>
   928.                         log_octal(this.parameter);
   929.                      when others =>
   930.                         if this.nested > 0 then
   931.                            log_octal(this.parameter);
   932.                         end if;
   933.                   end case;
   934.                when normal_jump_order =>
   935.                   case decoded.compressed_opcode is
   936.                      when Jr
   937.                         | JSr =>
   938.                         log(oct_of(as_link(this.parameter)));
   939.                      when EXIT_n =>
   940.                         if this.parameter < 8 then
   941.                            log(this.parameter'Image);
   942.                         else
   943.                            log(oct_of(as_link(this.parameter)));
   944.                         end if;
   945.                      when EXITD =>
   946.                         log(oct_of(as_link(this.parameter)));
   947.                      when JrCqZ
   948.                         | JrCqNZ =>
   949.                         show_Q_register(Q);
   950.                      when OS_OUT =>
   951.                         if this.parameter < 16 then
   952.                            log_octal(this.parameter);
   953.                         elsif this.parameter < 64 then
   954.                            log(this.parameter'Image);
   955.                         elsif this.parameter > 2**47 then
   956.                            log_octal(this.parameter);
   957.                         else
   958.                            show_Q_register(Q);
   959.                         end if;
   960.                      when JrEJ
   961.                         | JrNEJ
   962.                         | JrEN
   963.                         | JrNEN =>
   964.                            log(this.parameter'Image);
   965.                      when JrTR
   966.                         | JrV =>
   967.                            log(Boolean'Image(Boolean'Val(this.parameter)));
   968.                      when JrNTR
   969.                         | JrNV =>
   970.                            log(Boolean'Image(not Boolean'Val(this.parameter)));
   971.                      when others =>
   972.                         if this.nested > 0 then
   973.                            log_octal(this.parameter);
   974.                         end if;
   975.                      end case;
   976.                when others =>
   977.                   if this.nested > 0 then
   978.                      log_octal(this.parameter);
   979.                   end if;
   980.             end case;
   981.             tab_log_to(depth_col);
   982.             log(just_right(this.nested'Image,2));
   983.             log(" ");
   984.             log(just_right(this.called'Image,2));
   985.             log(" ");
   986.             log(if this.V then "V" else " ");
   987.             log(if this.T then "T" else " ");
   988.             log(if this.D then "D" else " ");
   989.             tab_log_to(time_col);
   990.             log(this.CPU_time'Image);
   991.             tab_log_to(ICR_col);
   992.             log(this.ICR_value'Image);
   993.             log_new_line;
   994.          end;
   995.          retro_FIFO_index := retro_FIFO_index - 1;
   996.       end loop;
   997.       if retro_FIFO_count = FIFO_size then
   998.          log("After earlier instructions, whose tracing is now lost.");
   999.       else
  1000.          log("After the start of traced execution.");
  1001.       end if;
  1002.       log_new_line;
  1003.       log_rule;
  1004.    end show_retro_FIFO;
  1005.
  1006.    the_final_ICR : KDF9.order_counter := 0;
  1007.
  1008.    procedure notify_termination is
  1009.    begin
  1010.       the_final_ICR := ICR;
  1011.    end notify_termination;
  1012.
  1013.    procedure show_IOC_FIFO is
  1014.    begin
  1015.       if IOC_FIFO_count = 0 then return; end if;
  1016.       log_title("Retrospective trace of peripheral I/O events.");
  1017.       tab_log_to(is_D_col);
  1018.       log_line("CPL T   EL. TIME     ICR");
  1019.       for i in 1 .. IOC_FIFO_count loop
  1020.          if i = 1 then
  1021.             log("Ended ");
  1022.          else
  1023.             log("After ");
  1024.          end if;
  1025.
  1026.          declare
  1027.             this    : tracing.IOC_FIFO_entry renames IOC_FIFO(IOC_FIFO_index);
  1028.             decoded : constant KDF9.decoded_order := this.decoded_order;
  1029.
  1030.             procedure show_transfer (
  1031.                                      Q                 : in KDF9.Q_register;
  1032.                                      for_OUT, for_seek : in Boolean := False
  1033.                                     ) is
  1034.             begin
  1035.                case decoded.compressed_opcode is
  1036.                   when PAR_Qq =>
  1037.                      show_IO_register(Q, for_DR => False, for_FD => False);
  1038.                   when CT_PMB_PMC_BUSY_Qq
  1039.                      | PMA_PMK_INT_Qq
  1040.                      | PMD_PME_PML_Qq
  1041.                      | PMF_PMG_Qq =>
  1042.                      show_IO_register(
  1043.                                       Q,
  1044.                                       for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
  1045.                                       for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
  1046.                                       for_seek => (decoded.Qk in PMA_bits) or show_transfer.for_seek,
  1047.                                       for_OUT  => show_transfer.for_OUT
  1048.                                      );
  1049.                   when PIA_PIC_CLO_TLO_Qq
  1050.                      | PIB_PID_Qq
  1051.                      | PIE_PIG_Qq
  1052.                      | PIF_PIH_Qq
  1053.                      | POA_POC_POE_POF_PMH_Qq
  1054.                      | POB_POD_Qq
  1055.                      | POG_POL_Qq
  1056.                      | POH_POK_Qq
  1057.                      | OS_OUT =>
  1058.                      show_IO_register(
  1059.                                       Q,
  1060.                                       for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
  1061.                                       for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
  1062.                                       for_FH   => for_FH_disc(decoded.compressed_opcode, decoded.Qk),
  1063.                                       for_OUT  => show_transfer.for_OUT
  1064.                                      );
  1065.                   when others =>
  1066.                      raise emulation_failure
  1067.                         with "invalid IO order: #" & oct_of(decoded.compressed_opcode);
  1068.                end case;
  1069.             end show_transfer;
  1070.
  1071.             shown_ICR : KDF9.order_counter := this.ICR_value;
  1072.             FD_seek   : Boolean := False;
  1073.             FD_xfer   : Boolean := False;
  1074.
  1075.          begin -- show_IOC_FIFO
  1076.             log(oct_of(this.order_address) & ":");
  1077.             tab_log_to(first_col);
  1078.             if the_full_name_of(this.decoded_order) = "OUT"  then
  1079.                 if this.device_name(1..2) in "MT" | "ST" and then
  1080.                       this.ICR_value >= the_final_ICR        then
  1081.                   log("OUT 0/2 rewind");
  1082.                   shown_ICR := the_final_ICR + 1;
  1083.                elsif this.device_name(1..2) in "MT" | "ST" then
  1084.                   log("OUT 6/7 rewind");
  1085.                elsif this.device_name(1..2) in "LP" | "TP" then
  1086.                   log("OUT 8");
  1087.                elsif this.device_name(1..2) = "DR" then
  1088.                   if this.kind in start_transfer | finis_transfer | buffer_lockout | store_lockout then
  1089.                      log(if this.operation = output_operation then "OUT 11" else "OUT 12");
  1090.                   else
  1091.                      log("OUT 11/12");
  1092.                   end if;
  1093.                elsif this.device_name(1..2) = "FD" then
  1094.                   if this.kind in start_transfer | finis_transfer | buffer_lockout | store_lockout then
  1095.                      log(if this.operation = output_operation then "OUT 41" else "OUT 42");
  1096.                   else
  1097.                      log("OUT 41/42 seek"); FD_seek := True;
  1098.                   end if;
  1099.                elsif this.device_name(1..2) = "FW" then
  1100.                   log("OUT 8/16");
  1101.                else
  1102.                   log("OUT ?");
  1103.                end if;
  1104.             else
  1105.                log(mnemonic(the_full_name_of(this.decoded_order), this.device_name));
  1106.             end if;
  1107.             tab_log_to(device_col);
  1108.             log(this.device_name);
  1109.             case this.kind is
  1110.                when store_lockout =>
  1111.                   tab_log_to(event_col);
  1112.                   log("locks out #");
  1113.                   log(oct_of(this.data_address));
  1114.                   log(" = E");
  1115.                   log(dec_of(this.data_address));
  1116.                   tab_log_to(is_D_col);
  1117.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1118.                   log(this.priority_level'Image);
  1119.                   tab_log_to(time_col);
  1120.                   log(this.initiation_time'Image);
  1121.                   tab_log_to(ICR_col);
  1122.                   log(shown_ICR'Image);
  1123.                 when buffer_lockout =>
  1124.                   tab_log_to(event_col);
  1125.                   log("buffer lockout");
  1126.                   tab_log_to(is_D_col);
  1127.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1128.                   log(this.priority_level'Image);
  1129.                   tab_log_to(time_col);
  1130.                   log(this.initiation_time'Image);
  1131.                   tab_log_to(ICR_col);
  1132.                   log(shown_ICR'Image);
  1133.                when start_transfer =>
  1134.                   tab_log_to(event_col);
  1135.                   show_transfer(this.control_word);
  1136.                   tab_log_to(is_D_col);
  1137.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1138.                   log(this.priority_level'Image);
  1139.                   tab_log_to(time_col-2);
  1140.                   log(" S" & this.initiation_time'Image);
  1141.                   tab_log_to(ICR_col);
  1142.                   log(shown_ICR'Image);
  1143.                when finis_transfer =>
  1144.                   tab_log_to(event_col);
  1145.                   show_transfer(this.control_word);
  1146.                   tab_log_to(is_D_col);
  1147.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1148.                   log(this.priority_level'Image);
  1149.                   tab_log_to(time_col-2);
  1150.                   log(" E" & this.completion_time'Image);
  1151.                   tab_log_to(ICR_col);
  1152.                   log(shown_ICR'Image);
  1153.                when buffer_status =>
  1154.                   tab_log_to(event_col);
  1155.                   FD_xfer := this.device_name(1..2) = "FD";
  1156.                   -- PMFQq entails no data transfer or seek, but has a sector address parameter.
  1157.                   FD_seek := (FD_seek or (decoded.Qk in PMA_bits)) and FD_xfer;
  1158.                   FD_seek := FD_seek and decoded.compressed_opcode /= PMF_PMG_Qq;
  1159.                   show_IO_register(this.Q_register, for_FD => FD_xfer, for_seek => FD_seek);
  1160.                   tab_log_to(is_D_col);
  1161.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1162.                   log(this.priority_level'Image);
  1163.                   log(if this.status then " Y" else " N");
  1164.                   tab_log_to(time_col);
  1165.                   log(this.initiation_time'Image);
  1166.                   tab_log_to(ICR_col);
  1167.                   log(shown_ICR'Image);
  1168.             end case;
  1169.             log_new_line;
  1170.          end;
  1171.          IOC_FIFO_index := IOC_FIFO_index - 1;
  1172.       end loop;
  1173.       if IOC_FIFO_count = FIFO_size then
  1174.          log_line("After earlier instructions, whose tracing is now lost.");
  1175.       else
  1176.          log_line("After the start of traced execution.");
  1177.       end if;
  1178.       log_line("Total time waiting for unoverlapped I/O to finish ="
  1179.              & KDF9.us'Image((the_clock_time-the_CPU_time+500) / 1000)
  1180.              & " ms.");
  1181.       log_rule;
  1182.    end show_IOC_FIFO;
  1183.
  1184.    procedure show_interrupt_FIFO is
  1185.    begin
  1186.       if interrupt_FIFO_count = 0 then return; end if;
  1187.       log_title("Retrospective trace of interrupt requests.");
  1188.       tab_log_to(is_D_col);
  1189.       log_line("CPL     EL. TIME     ICR");
  1190.       for i in 1 .. interrupt_FIFO_count loop
  1191.          log(if i = 1 then "Ended " else "After ");
  1192.          declare
  1193.             this : tracing.interrupt_FIFO_entry renames interrupt_FIFO(interrupt_FIFO_index);
  1194.          begin
  1195.             log(oct_of(this.order_address) & ": ");
  1196.             tab_log_to(first_col);
  1197.             log(case this.interrupt_code is
  1198.                    when PR_interrupt     => "PR   ",
  1199.                    when FLEX_interrupt   => "FLEX ",
  1200.                    when LIV_interrupt    => "LIV  ",
  1201.                    when NOUV_interrupt   => "NOUV ",
  1202.                    when EDT_interrupt    => "EDT  ",
  1203.                    when OUT_interrupt    => "OUT  ",
  1204.                    when LOV_interrupt    => "LOV  ",
  1205.                    when RESET_interrupt  => "RESET",
  1206.                    when CLOCK_interrupt  => "CLOCK",
  1207.                    when EXITD_flag       => "EXITD"
  1208.                );
  1209.             tab_log_to(event_col-4);
  1210.             log(trimmed(this.message));
  1211.             tab_log_to(is_D_col);
  1212.             log(slot_name(this.context));
  1213.             log(this.priority_level'Image);
  1214.             tab_log_to(time_col);
  1215.             log(this.busy_time'Image);
  1216.             tab_log_to(ICR_col);
  1217.             log(this.ICR_value'Image);
  1218.             log_new_line;
  1219.          end;
  1220.          interrupt_FIFO_index := interrupt_FIFO_index - 1;
  1221.       end loop;
  1222.       log(
  1223.           if interrupt_FIFO_count = FIFO_size then
  1224.              "After earlier interrupts, whose tracing is now lost."
  1225.           else
  1226.             "After the start of traced execution."
  1227.          );
  1228.       log_new_line;
  1229.       log_new_line;
  1230.    end show_interrupt_FIFO;
  1231.
  1232.    procedure show_retrospective_traces is
  1233.    begin
  1234.       if the_peripheral_trace_is_enabled then
  1235.          pragma Debug(IOC.diagnostics);
  1236.       end if;
  1237.       if the_interrupt_trace_is_enabled then
  1238.          show_interrupt_FIFO;
  1239.       end if;
  1240.       if the_peripheral_trace_is_enabled then
  1241.          show_IOC_FIFO;
  1242.       end if;
  1243.       if the_retrospective_trace_is_enabled then
  1244.          show_retro_FIFO;
  1245.       end if;
  1246.    end show_retrospective_traces;
  1247.
  1248.    procedure show_current_state is
  1249.    begin
  1250.       show_execution_context;
  1251.       log_rule;
  1252.       show_registers;
  1253.       log_rule;
  1254.    end show_current_state;
  1255.
  1256.    procedure show_final_state (because : in String) is
  1257.    begin
  1258.       if the_final_state_is_wanted then
  1259.          if loading_was_successful then
  1260.             -- make sure there is at least one NL after any FW output.
  1261.             if the_log_is_wanted then
  1262.                log_new_line;
  1263.                log_rule;
  1264.             else
  1265.                log_new_line;
  1266.             end if;
  1267.             log_line("Final State: " & because & ".");
  1268.             if not the_log_is_wanted then return; end if;
  1269.             long_witness;
  1270.             log_rule;
  1271.
  1272.             if nr_of_post_dumping_areas /= 0 then
  1273.                log_title("Post-run Dump:");
  1274.                print_postrun_dump_areas;
  1275.             end if;
  1276.
  1277.             if the_INS_plot_is_wanted or the_profile_is_wanted then
  1278.                if the_histogram_is_enabled then
  1279.                   show_frequency_plots;
  1280.                end if;
  1281.             end if;
  1282.
  1283.             if the_peripheral_trace_is_enabled       or else
  1284.                   the_interrupt_trace_is_enabled     or else
  1285.                      the_retrospective_trace_is_enabled then
  1286.                log_title("Traces:");
  1287.             end if;
  1288.
  1289.             show_retrospective_traces;
  1290.
  1291.             if the_signature_is_enabled then
  1292.                log_title("Digital signature of traced orders = #"
  1293.                        & oct_of(the_digital_signature)
  1294.                        & ".");
  1295.             end if;
  1296.          else
  1297.             log_line("ee9 cannot run: " & because & ".");
  1298.             show_all_prerun_dump_areas;
  1299.             return;
  1300.          end if;
  1301.       end if;
  1302.    end show_final_state;
  1303.
  1304.    procedure show_all_prerun_dump_areas is
  1305.    begin
  1306.       if the_log_is_wanted and nr_of_pre_dumping_areas /= 0 then
  1307.          log_title("Pre-run Dump:");
  1308.          print_prerun_dump_areas;
  1309.          remove_prerun_dump_areas;
  1310.       end if;
  1311.    end show_all_prerun_dump_areas;
  1312.
  1313.    quantum     : constant := 8;
  1314.    jump_tab    : constant := 12;
  1315.    first_tab   : constant := 16;
  1316.    last_column : constant := 80;
  1317.
  1318.    function is_non_blank (first : in KDF9.address)
  1319.    return Boolean is
  1320.       result : Boolean := False;
  1321.    begin
  1322.       for address in first .. first+quantum-1 loop
  1323.          result := result or (fetch_word(address) /= 0);
  1324.       end loop;
  1325.       return result;
  1326.    end is_non_blank;
  1327.
  1328.    subtype converted_word is String(1..8);
  1329.
  1330.    type convertor is
  1331.       not null access function (address : KDF9.address) return converted_word;
  1332.
  1333.    procedure show_core (first, last : in KDF9.address;
  1334.                         head, side  : in String;
  1335.                         converted   : in convertor) is
  1336.
  1337.       procedure show_group (first : in KDF9.address) is
  1338.          address : KDF9.address := first;
  1339.       begin
  1340.          while address <= first+quantum-1 loop
  1341.             log(converted(address));
  1342.             address := address + 1;
  1343.             exit when address < first;
  1344.          end loop;
  1345.       end show_group;
  1346.
  1347.       address : KDF9.address := first;
  1348.
  1349.    begin
  1350.       if (last-first+1) < 1 then
  1351.          return;
  1352.       end if;
  1353.       BA := 0; -- Ensure that physical store is examined when running in boot mode.
  1354.       log_title("Core store [#" & oct_of(first) & " .. #" & oct_of(last) & "] interpreted as " & head & ":");
  1355.       while address <= last loop
  1356.          if is_non_blank(address) then
  1357.             log_octal(KDF9.field_of_16_bits(address));
  1358.             log(":");
  1359.             tab_log_to(jump_tab);
  1360.             log(side);
  1361.             log(" """);
  1362.             show_group(address);
  1363.             log("""");
  1364.             log_new_line;
  1365.          else
  1366.             log_line("========  blank  ========");
  1367.          end if;
  1368.       exit when address >= KDF9.address'Last - quantum;
  1369.          address := address + quantum;
  1370.       end loop;
  1371.       log_new_line;
  1372.    end show_core;
  1373.
  1374.    function encoding_of (address : KDF9.address; code_table : output_code_table)
  1375.    return converted_word is
  1376.       result : converted_word;
  1377.    begin
  1378.       for b in KDF9_char_sets.symbol_index loop
  1379.          result(Natural(b)+1) := glyph_for(code_table(fetch_symbol(address, b)));
  1380.       end loop;
  1381.       return result;
  1382.    end encoding_of;
  1383.
  1384.    current_case : KDF9_char_sets.symbol := KDF9_char_sets.Case_Normal;
  1385.
  1386.    function interpretation_of (address : KDF9.address)
  1387.    return converted_word is
  1388.       result : converted_word;
  1389.       symbol : KDF9_char_sets.symbol;
  1390.       char   : Character;
  1391.    begin
  1392.       for b in KDF9_char_sets.symbol_index loop
  1393.          symbol := fetch_symbol(address, b);
  1394.          if current_case = KDF9_char_sets.Case_Normal then
  1395.             char := TP_CN(symbol);
  1396.          else
  1397.             char := TP_CS(symbol);
  1398.          end if;
  1399.          if symbol = KDF9_char_sets.Case_Normal then
  1400.             current_case := KDF9_char_sets.Case_Normal;
  1401.          elsif symbol = KDF9_char_sets.Case_Shift then
  1402.             current_case := KDF9_char_sets.Case_Shift;
  1403.          end if;
  1404.          result(Natural(b)+1) := glyph_for(char);
  1405.       end loop;
  1406.       return result;
  1407.    end interpretation_of;
  1408.
  1409.    function case_visible (address : KDF9.address)
  1410.    return converted_word
  1411.    is (interpretation_of(address));
  1412.
  1413.    function case_normal (address : KDF9.address)
  1414.    return converted_word
  1415.    is (encoding_of(address, code_table => TP_CN));
  1416.
  1417.    function case_shift (address : KDF9.address)
  1418.    return converted_word
  1419.    is (encoding_of(address, code_table => TP_CS));
  1420.
  1421.    function printer_code (address : KDF9.address)
  1422.    return converted_word
  1423.    is (encoding_of(address, code_table => to_LP));
  1424.
  1425.    function card_code (address : KDF9.address)
  1426.    return converted_word
  1427.    is (encoding_of(address, code_table => to_CP));
  1428.
  1429.    function Latin_1_code (address : KDF9.address)
  1430.    return converted_word
  1431.    is (converted_word'(1..7 => Space,
  1432.                        8    => glyph_for(Character'Val(fetch_word(address) and 8#377#))));
  1433.
  1434.    procedure show_core_in_case_visible (first, last : in KDF9.address) is
  1435.    begin
  1436.       show_core(first, last,
  1437.                 head => "characters in TR/TP code with case shifting",
  1438.                 side => "  ",
  1439.                 converted => case_visible'Access);
  1440.    end show_core_in_case_visible;
  1441.
  1442.    procedure show_core_in_case_normal (first, last : in KDF9.address) is
  1443.    begin
  1444.       show_core(first, last,
  1445.                 head => "characters in TR/TP Normal Case code",
  1446.                 side => "NC",
  1447.                 converted => case_normal'Access);
  1448.    end show_core_in_case_normal;
  1449.
  1450.    procedure show_core_in_case_shift (first, last : in KDF9.address) is
  1451.    begin
  1452.       show_core(first, last,
  1453.                 head => "characters in TR/TP Shift Case code",
  1454.                 side => "SC",
  1455.                 converted => case_shift'Access);
  1456.    end show_core_in_case_shift;
  1457.
  1458.    procedure show_core_in_print_code (first, last : in KDF9.address) is
  1459.    begin
  1460.       show_core(first, last,
  1461.                 head => "characters in LP code",
  1462.                 side => "LP",
  1463.                 converted => printer_code'Access);
  1464.    end show_core_in_print_code;
  1465.
  1466.    procedure show_core_in_card_code (first, last : in KDF9.address) is
  1467.    begin
  1468.       show_core(first, last,head => "characters in CR/CP code",
  1469.                 side => "CP",
  1470.                 converted => card_code'Access);
  1471.    end show_core_in_card_code;
  1472.
  1473.    procedure show_core_in_Latin_1 (first, last : in KDF9.address) is
  1474.    begin
  1475.       show_core(first, last,
  1476.                 head => "words with bits 40-47 of each in Latin-1 code",
  1477.                 side => "L1",
  1478.                 converted => Latin_1_code'Access);
  1479.    end show_core_in_Latin_1;
  1480.
  1481.    procedure show_core_in_tape_code (first, last : in KDF9.address) is
  1482.    begin
  1483.       show_core_in_case_visible(first, last);
  1484.    end show_core_in_tape_code;
  1485.
  1486.    procedure show_core_as_word_forms (first, last  : KDF9.address) is
  1487.
  1488.       procedure show_word (address : KDF9.address) is
  1489.          word : constant KDF9.word := fetch_word(address);
  1490.       begin
  1491.          log_octal(KDF9.field_of_16_bits(address));
  1492.          log(":");
  1493.          tab_log_to(jump_tab);
  1494.          show_in_various_formats(word, column => jump_tab);
  1495.          log_new_line;
  1496.       end show_word;
  1497.
  1498.       procedure show_word_group (first, last  : KDF9.address) is
  1499.          last_address : KDF9.address := first;
  1500.          this_word, last_word : KDF9.word;
  1501.       begin
  1502.          if last = first or last = 0 then
  1503.             show_word(last);
  1504.             return;
  1505.          end if;
  1506.          this_word := fetch_word(first);
  1507.          last_word := this_word;
  1508.          show_word(first);
  1509.          for address in first+1 .. last-1 loop
  1510.             this_word := fetch_word(address);
  1511.             if this_word = last_word and address = last_address+1 then
  1512.                log_line("==========  ditto  ========");
  1513.             elsif this_word /= last_word then
  1514.                show_word(address);
  1515.                last_word := this_word;
  1516.                last_address := address;
  1517.             end if;
  1518.          end loop;
  1519.          if last > first then
  1520.             show_word(last);
  1521.          end if;
  1522.       end show_word_group;
  1523.
  1524.    begin
  1525.       if first > last then
  1526.          return;
  1527.       end if;
  1528.       BA := 0; -- Ensure that physical store is examined when running in boot mode.
  1529.       log_title("Core store interpreted as 48-bit words:");
  1530.       show_word_group(first, last);
  1531.       log_new_line;
  1532.    end show_core_as_word_forms;
  1533.
  1534.    -- Each word of code space is described by a set of flags.
  1535.    -- Flags 0 .. 5 are set iff a jump order has that syllable as target.
  1536.    -- Flag 6 is set if the word is thought to be code, but not a target.
  1537.    -- Flag 7 is set if the word is thought to be addressed as data.
  1538.
  1539.    is_a_code_word : constant KDF9.syllable_index := 6;
  1540.    is_a_data_word : constant KDF9.syllable_index := 7;
  1541.
  1542.    package word_flags is new generic_sets(member => KDF9.syllable_index);
  1543.    use word_flags;
  1544.
  1545.    all_jump_targets : constant word_flags.set := (0 .. 5 => True, 6|7 => False);
  1546.
  1547.    analysis_flags : array (KDF9.order_word_number) of word_flags.set;
  1548.
  1549.    function "/" (word : KDF9.order_word_number; flag : KDF9.syllable_index)
  1550.    return Boolean
  1551.    is (analysis_flags(word)(flag));
  1552.
  1553.    function is_a_jump_target (the_point : in KDF9.syllable_address)
  1554.    return Boolean
  1555.    is (analysis_flags(the_point.order_word_number)(the_point.syllable_index));
  1556.
  1557.    function is_a_jump_target (the_operand : in KDF9.order_word_number)
  1558.    return Boolean
  1559.    is ((analysis_flags(the_operand) and all_jump_targets) /= empty_set);
  1560.
  1561.    procedure clear_all_analysis_flags is
  1562.    begin
  1563.       analysis_flags := (others => empty_set);
  1564.    end clear_all_analysis_flags;
  1565.
  1566.    procedure unmark_as_a_data_word (the_operand : in KDF9.order_word_number) is
  1567.    begin
  1568.       analysis_flags(the_operand)(is_a_data_word) := False;
  1569.    end unmark_as_a_data_word;
  1570.
  1571.    procedure unmark_as_a_code_word (the_operand : in KDF9.order_word_number) is
  1572.    begin
  1573.       analysis_flags(the_operand)(is_a_code_word) := False;
  1574.    end unmark_as_a_code_word;
  1575.
  1576.    procedure mark_as_a_code_word (the_operand : in KDF9.order_word_number) is
  1577.    begin
  1578.       analysis_flags(the_operand)(is_a_code_word) := True;
  1579.       unmark_as_a_data_word(the_operand);
  1580.    end mark_as_a_code_word;
  1581.
  1582.    procedure mark_as_a_jump_target (the_point : in KDF9.syllable_address) is
  1583.    begin
  1584.       analysis_flags(the_point.order_word_number)(the_point.syllable_index) := True;
  1585.       mark_as_a_code_word(the_point.order_word_number);
  1586.    end mark_as_a_jump_target;
  1587.
  1588.    procedure mark_as_a_data_word (the_operand : in KDF9.order_word_number) is
  1589.    begin
  1590.       analysis_flags(the_operand)(is_a_data_word) := True;
  1591.       unmark_as_a_code_word(the_operand);
  1592.    end mark_as_a_data_word;
  1593.
  1594.    procedure mark_all_code_blocks_and_data_blocks is
  1595.
  1596.       procedure mark_all_code_blocks (the_beginning : in KDF9.syllable_address) is
  1597.          address : KDF9.syllable_address := the_beginning;
  1598.       begin
  1599.          if address.syllable_index > 5 then
  1600.             return;  -- We have blundered into non-code words.
  1601.          end if;
  1602.          -- Mark the first syllable of the block.
  1603.          mark_as_a_jump_target(the_beginning);
  1604.          -- Mark the destinations of all jumps in the block as code.
  1605.          loop
  1606.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1607.          exit when address.order_word_number = 8191;
  1608.             set_NIA_to(address);
  1609.             decode_the_next_order;
  1610.             if is_an_invalid_order(INS)                                                  or else
  1611.                   (address.order_word_number/is_a_data_word and address.syllable_index = 0) then
  1612.                return;
  1613.             else
  1614.                -- Assuming a valid code word, act on it.
  1615.                mark_as_a_code_word(address.order_word_number);
  1616.                case INS.kind is
  1617.                   when normal_jump_order =>
  1618.                      if not is_a_jump_target((INS.target.order_word_number, INS.target.syllable_index)) then
  1619.                         -- Mark the jump's destination recursively.
  1620.                         -- N.B. EXIT is actioned only if it is of EXIT ARr type.
  1621.                         mark_all_code_blocks((INS.target.order_word_number, INS.target.syllable_index));
  1622.                      end if;
  1623.                      increment_by_3(address);
  1624.                      if INS.compressed_opcode = JSr  then
  1625.                         -- Mark its return point.
  1626.                         mark_as_a_jump_target(address);
  1627.                      end if;
  1628.                   when one_syllable_order =>
  1629.                      increment_by_1(address);
  1630.                   when two_syllable_order =>
  1631.                      if INS.compressed_opcode = JCqNZS then
  1632.                         -- Mark the preceding word.
  1633.                         mark_as_a_jump_target((address.order_word_number-1, 0));
  1634.                      end if;
  1635.                      increment_by_2(address);
  1636.                   when data_access_order =>
  1637.                      increment_by_3(address);
  1638.                end case;
  1639.             end if;
  1640.          end loop;
  1641.       end mark_all_code_blocks;
  1642.
  1643.       procedure mark_all_data_blocks (the_beginning : in KDF9.syllable_address) is
  1644.          address : KDF9.syllable_address := the_beginning;
  1645.       begin
  1646.          if address.syllable_index > 5 then
  1647.             return;  -- We have blundered into non-code words.
  1648.          end if;
  1649.          the_code_block_handler: loop
  1650.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1651.          exit when address.order_word_number = 8191;
  1652.             -- Process orders, starting at an established code word.
  1653.             set_NIA_to(address); -- **
  1654.             decode_the_next_order;
  1655.             if (is_an_invalid_order(INS)                         or else
  1656.                   address.order_word_number/is_a_data_word)     and then
  1657.                      not (address.order_word_number/is_a_code_word) then
  1658.                -- This word is data: make sure it is not designated as code;
  1659.                --    and find the start of the next code block.
  1660.                for a in address.order_word_number .. 8190 loop
  1661.                   address := (a, 0);
  1662.                   exit when is_a_jump_target(a);
  1663.                   unmark_as_a_code_word(a);
  1664.                   mark_as_a_data_word(a);
  1665.                end loop;
  1666.
  1667.                exit the_code_block_handler
  1668.                   when address.order_word_number = 8190;
  1669.
  1670.                -- Find the syllable at which the block starts.
  1671.                for s in KDF9.syllable_index'(0) .. 5 loop
  1672.                   address.syllable_index := s;
  1673.                   exit when is_a_jump_target(address);
  1674.                end loop;
  1675.
  1676.             else
  1677.
  1678.                -- Assuming a valid code word, act on it.
  1679.                case INS.kind is
  1680.                   when data_access_order =>
  1681.                      if INS.operand < 8192 then
  1682.                         declare
  1683.                            operand : constant KDF9.order_word_number
  1684.                                    := KDF9.order_word_number(INS.operand);
  1685.                         begin
  1686.                            if INS.compressed_opcode /= KDF9.decoding.SET and then
  1687.                                  not is_a_jump_target(operand)               then
  1688.                               mark_as_a_data_word(operand);
  1689.                            end if;
  1690.                         end;
  1691.                      end if;
  1692.                      increment_by_3(address);
  1693.                   when one_syllable_order =>
  1694.                      increment_by_1(address);
  1695.                   when two_syllable_order =>
  1696.                      increment_by_2(address);
  1697.                   when normal_jump_order =>
  1698.                      increment_by_3(address);
  1699.                end case;
  1700.             end if;
  1701.
  1702.             exit the_code_block_handler
  1703.                when address.order_word_number = KDF9.order_word_number'Last;
  1704.
  1705.          end loop the_code_block_handler;
  1706.       end mark_all_data_blocks;
  1707.
  1708.       procedure reset_wrong_data_marks (the_beginning : in KDF9.syllable_address) is
  1709.          address : KDF9.syllable_address := the_beginning;
  1710.          locus   : KDF9.order_word_number;
  1711.       begin
  1712.          if address.syllable_index > 5 then
  1713.             return;  -- We have blundered into non-code words.
  1714.          end if;
  1715.          -- Unmark the first instruction of the block.
  1716.          unmark_as_a_data_word(address.order_word_number);
  1717.
  1718.          -- Unmark data marks on destinations of jumps.
  1719.          loop
  1720.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1721.          exit when address.order_word_number = 8191;
  1722.             set_NIA_to(address);
  1723.             decode_the_next_order;
  1724.             if is_an_invalid_order(INS)                          or else
  1725.                   address.order_word_number/is_a_data_word       or else
  1726.                      not (address.order_word_number/is_a_code_word) then
  1727.                -- We have reached the end of the code block.
  1728.                return;
  1729.             else
  1730.                -- Assuming a valid code word, act on it.
  1731.                case INS.kind is
  1732.                   when normal_jump_order =>
  1733.                      locus := address.order_word_number;
  1734.                      increment_by_3(address);
  1735.                      if INS.target.order_word_number/is_a_data_word    then
  1736.                         -- UNmark the jump's destination recursively.
  1737.                         reset_wrong_data_marks((INS.target.order_word_number, INS.target.syllable_index));
  1738.                      end if;
  1739.                      if INS.compressed_opcode /= Jr          and then
  1740.                            INS.compressed_opcode /= EXIT_n   and then
  1741.                               locus /= address.order_word_number then
  1742.                         -- It flows on, so the next word cannot be data.
  1743.                         unmark_as_a_data_word(address.order_word_number);
  1744.                      elsif not (address.order_word_number/is_a_data_word) then
  1745.                         -- The next syllable starts a block, iff it is not the end of a block.
  1746.                         set_NIA_to(address);
  1747.                         decode_the_next_order;
  1748.                         if not is_an_invalid_order(INS) then
  1749.                            mark_as_a_jump_target(address);
  1750.                         end if;
  1751.                      end if;
  1752.                   when one_syllable_order =>
  1753.                      increment_by_1(address);
  1754.                   when two_syllable_order =>
  1755.                      increment_by_2(address);
  1756.                   when data_access_order =>
  1757.                      increment_by_3(address);
  1758.                end case;
  1759.             end if;
  1760.             exit when address.order_word_number = KDF9.order_word_number'Last;
  1761.          end loop;
  1762.       end reset_wrong_data_marks;
  1763.
  1764.       procedure mark_the_words_reachable_from (address : in KDF9.syllable_address) is
  1765.          start_point : KDF9.syllable_address;
  1766.       begin
  1767.          mark_as_a_jump_target(address);
  1768.          set_NIA_to(address);
  1769.          decode_the_next_order;
  1770.          if INS.kind =normal_jump_order then
  1771.          start_point := (INS.target.order_word_number, INS.target.syllable_index);
  1772.          mark_all_code_blocks(start_point);
  1773.          mark_all_data_blocks(start_point);
  1774.          reset_wrong_data_marks(start_point);
  1775.          end if;
  1776.       end mark_the_words_reachable_from;
  1777.
  1778.       procedure markup_a_problem_program is
  1779.       begin
  1780.          if the_initial_jump_was_corrupted then
  1781.             -- We cannot sensibly locate the order words using E0  ...
  1782.             log_new_line;
  1783.             log_line("The initial jump, in E0U, has been corrupted!");
  1784.             log_new_line;
  1785.             show_core_as_syllables((0, 0), (5, 0));
  1786.             --  ... so restore it to the value it had on loading.
  1787.             restore_the_initial_jump;
  1788.             log_line("E0U has been restored to the value it had on loading.");
  1789.             log_new_line;
  1790.          end if;
  1791.
  1792.          -- Mark all orders reachable from the initial jump in E0 and the restart jumps in E4.
  1793.
  1794.          mark_the_words_reachable_from((0, 0));
  1795.          mark_the_words_reachable_from((0, 4));
  1796.          mark_the_words_reachable_from((1, 4));
  1797.
  1798.          -- Mark the words between E0 and P0 as data, skipping E4.
  1799.          mark_as_a_data_word(1);
  1800.          mark_as_a_data_word(2);
  1801.          mark_as_a_data_word(3);
  1802.          set_NIA_to((0, 0));
  1803.          decode_the_next_order;
  1804.          for d in 5 .. INS.target.order_word_number-1 loop
  1805.             mark_as_a_data_word(d);
  1806.          end loop;
  1807.
  1808.          the_program_has_been_analysed := True;
  1809.       end markup_a_problem_program;
  1810.
  1811.       -- This analysis assumes that the Director has much the same structure as KKT40E007UPU.
  1812.       procedure markup_a_Director is
  1813.
  1814.       begin
  1815.          BA := 0;  -- Director starts at physical word 0.
  1816.
  1817.          mark_as_a_code_word(0);
  1818.          mark_as_a_code_word(1);
  1819.          mark_as_a_code_word(2);
  1820.          mark_as_a_data_word(3);
  1821.          mark_as_a_code_word(4);
  1822.
  1823.          for a in nominated_address .. 3200 loop  -- 3200 was the size of the Eldon 2 Director.
  1824.             -- mark_as_a_code_word(a);
  1825.             -- mark_as_a_jump_target((a, 0));
  1826.             set_NIA_to((a, 0));
  1827.             decode_the_next_order;
  1828.             if INS.kind = normal_jump_order then
  1829.                mark_the_words_reachable_from((a, 0));
  1830.             elsif INS.kind = data_access_order then
  1831.                if INS.operand < 8192 then
  1832.                   declare
  1833.                      operand : constant KDF9.order_word_number
  1834.                              := KDF9.order_word_number(INS.operand);
  1835.                   begin
  1836.                      if INS.compressed_opcode /= KDF9.decoding.SET and then
  1837.                            not is_a_jump_target(operand)               then
  1838.                         mark_as_a_data_word(operand);
  1839.                      end if;
  1840.                   end;
  1841.                end if;
  1842.              else
  1843.                 mark_as_a_jump_target((a, 0));
  1844.             end if;
  1845.             set_NIA_to((a, 3));
  1846.             decode_the_next_order;
  1847.             if INS.kind = normal_jump_order then
  1848.                mark_the_words_reachable_from((a, 3));
  1849.             elsif INS.kind = data_access_order then
  1850.                if INS.operand < 8192 then
  1851.                   declare
  1852.                      operand : constant KDF9.order_word_number
  1853.                              := KDF9.order_word_number(INS.operand);
  1854.                   begin
  1855.                      if INS.compressed_opcode /= KDF9.decoding.SET and then
  1856.                            not is_a_jump_target(operand)               then
  1857.                         mark_as_a_data_word(operand);
  1858.                      end if;
  1859.                   end;
  1860.                end if;
  1861.              else
  1862.                 mark_as_a_jump_target((a, 3));
  1863.             end if;
  1864.          end loop;
  1865.
  1866.          -- Mark all orders reachable from the initial jump(s).
  1867.
  1868.          set_NIA_to((order_word_number => 2, syllable_index => 0));
  1869.          decode_the_next_order;
  1870.          if INS.kind /= normal_jump_order then
  1871.             log_line("An initial jump, in E2U, has not been found!");
  1872.          else
  1873.             mark_the_words_reachable_from((0, 2));
  1874.             -- Mark the words between E4 and P0 as data.
  1875.             set_NIA_to((0, 2));
  1876.             decode_the_next_order;
  1877.             for d in 5 .. INS.target.order_word_number-1 loop
  1878.                mark_as_a_data_word(d);
  1879.             end loop;
  1880.             the_program_has_been_analysed := True;
  1881.          end if;
  1882.
  1883.          set_NIA_to((0, 4));
  1884.          decode_the_next_order;
  1885.          if INS.kind /= normal_jump_order then
  1886.             log_line("An expected jump, in E4U, has not been found!");
  1887.             return;
  1888.          else
  1889.             mark_the_words_reachable_from((0, 4));
  1890.             the_program_has_been_analysed := True;
  1891.          end if;
  1892.
  1893.          set_NIA_to((1, 4));
  1894.          decode_the_next_order;
  1895.          if INS.kind /= normal_jump_order then
  1896.             log_line("An expected jump, in E4L, has not been found!");
  1897.             return;
  1898.          else
  1899.             mark_the_words_reachable_from((1, 4));
  1900.             the_program_has_been_analysed := True;
  1901.          end if;
  1902.       end markup_a_Director;
  1903.
  1904.    begin -- mark_all_code_blocks_and_data_blocks
  1905.       if the_program_has_been_analysed then
  1906.          return;
  1907.       end if;
  1908.
  1909.       clear_all_analysis_flags;
  1910.
  1911.       if the_execution_mode = boot_mode  then
  1912.          markup_a_Director;
  1913.       else
  1914.          markup_a_problem_program;
  1915.       end if;
  1916.
  1917.       if nominated_address < invalid_address then
  1918.          mark_the_words_reachable_from((nominated_address, 0));
  1919.       end if;
  1920.
  1921.    end mark_all_code_blocks_and_data_blocks;
  1922.
  1923.    procedure show_core_as_Usercode (first, last  : in KDF9.syllable_address;
  1924.                                     octal_option : in Boolean) is
  1925.
  1926.       six_DUMMIES : constant KDF9.word := 8#0360741703607417#;
  1927.       saved_CIA   : constant KDF9.syllable_address := CIA;
  1928.       last_word   : KDF9.word := 8#0706050403020100#; -- invalid opcodes
  1929.       comparator  : KDF9.word := last_word;
  1930.       this_word   : KDF9.word;
  1931.       address     : KDF9.syllable_address;
  1932.
  1933.       procedure show_a_block_of_orders is
  1934.
  1935.          function is_a_store_order (decoded : KDF9.decoded_order)
  1936.          return Boolean
  1937.          is (
  1938.              if decoded.kind = one_syllable_order then
  1939.                 False
  1940.              elsif decoded.kind = two_syllable_order then
  1941.                 (
  1942.                  case decoded.compressed_opcode is
  1943.                    when TO_MkMq   | TO_MkMqQ
  1944.                       | TO_MkMqH  | TO_MkMqQH
  1945.                       | TO_MkMqN  | TO_MkMqQN
  1946.                       | TO_MkMqHN | TO_MkMqQHN => True,
  1947.                    when others                 => False
  1948.                 )
  1949.              elsif decoded.kind = data_access_order then
  1950.                 (
  1951.                  case decoded.compressed_opcode is
  1952.                     when TO_EaMq | TO_EaMqQ => True,
  1953.                     when others             => False
  1954.                 )
  1955.              else
  1956.                 False
  1957.             );
  1958.
  1959.          procedure set_line_at_minimum (tab : in Natural) is
  1960.          begin
  1961.             if panel_logger.column < tab then
  1962.                tab_log_to(tab);
  1963.             end if;
  1964.          end set_line_at_minimum;
  1965.
  1966.          procedure set_line_at (tab : in Natural) is
  1967.          begin
  1968.             if panel_logger.column > tab then
  1969.                log_new_line;
  1970.             end if;
  1971.             if panel_logger.column < tab then
  1972.                tab_log_to(tab);
  1973.             end if;
  1974.          end set_line_at;
  1975.
  1976.          procedure set_at_new_line is
  1977.          begin
  1978.             if panel_logger.column > 1 then
  1979.                log_new_line;
  1980.             end if;
  1981.          end set_at_new_line;
  1982.
  1983.       last_nz_location : KDF9.syllable_address;
  1984.
  1985.       begin -- show_a_block_of_orders
  1986.          this_word := fetch_word(KDF9.address(address.order_word_number));
  1987.
  1988.          if this_word+1 < 2 or this_word = six_DUMMIES then
  1989.             -- The word is not worth logging.
  1990.             address := (address.order_word_number+1, 0);
  1991.             return;
  1992.          end if;
  1993.
  1994.          -- Log useful information about data words.
  1995.          if address.order_word_number/is_a_data_word then
  1996.             set_at_new_line;
  1997.          end if;
  1998.          loop
  1999.             if address.order_word_number/is_a_data_word then
  2000.                last_nz_location := address;
  2001.                -- Display a line of data.
  2002.                log(oct_or_dec_of(address, octal_option) & ": ");
  2003.                set_line_at(jump_tab);
  2004.                show_in_various_formats(fetch_word(KDF9.address(address.order_word_number)),
  2005.                                        column => jump_tab);
  2006.                log_new_line;
  2007.                loop
  2008.                   if address.order_word_number = last.order_word_number then
  2009.                      return;
  2010.                   end if;
  2011.                   address := (address.order_word_number+1, 0);
  2012.                exit when fetch_word(KDF9.address(address.order_word_number)) /= 0;
  2013.                end loop;
  2014.                if address.order_word_number > last_nz_location.order_word_number+1 then
  2015.                   log("========  zeros  ========");
  2016.                   log_new_line;
  2017.                end if;
  2018.             else
  2019.                log_new_line;
  2020.                exit;
  2021.             end if;
  2022.          end loop;
  2023.
  2024.          loop
  2025.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  2026.          exit when address.order_word_number = 8191;
  2027.             this_word := fetch_word(KDF9.address(address.order_word_number));
  2028.             if this_word = comparator and this_word = last_word then
  2029.                -- The word is not worth logging.
  2030.                address := (address.order_word_number+1, 0);
  2031.                return;
  2032.             end if;
  2033.
  2034.             if this_word+1 < 2 or this_word = six_DUMMIES then
  2035.                comparator := this_word;
  2036.             end if;
  2037.
  2038.             set_NIA_to(address);
  2039.             decode_the_next_order;
  2040.             if is_an_invalid_order(INS) then
  2041.                -- The word is not worth logging.
  2042.                address := (address.order_word_number+1, 0);
  2043.                return;
  2044.             end if;
  2045.
  2046.             if is_a_jump_target(address) then
  2047.                -- Start a code paragraph, with its address for easy reference.
  2048.                set_at_new_line;
  2049.                log(oct_or_dec_of(address, octal_option) & ": ");
  2050.                log_new_line;
  2051.             end if;
  2052.
  2053.             -- Set the tab position appropriately for the order type.
  2054.             case INS.kind is
  2055.                when one_syllable_order | data_access_order =>
  2056.                   set_line_at_minimum(first_tab);
  2057.                when two_syllable_order =>
  2058.                   case INS.compressed_opcode is
  2059.                      when JCqNZS =>
  2060.                         set_line_at(jump_tab);
  2061.                      when  CT_PMB_PMC_BUSY_Qq
  2062.                         |  PAR_Qq
  2063.                         |  PMF_PMG_Qq
  2064.                         |  PIA_PIC_CLO_TLO_Qq
  2065.                         |  PIB_PID_Qq
  2066.                         |  PIE_PIG_Qq
  2067.                         |  PIF_PIH_Qq
  2068.                         |  POA_POC_POE_POF_PMH_Qq
  2069.                         |  POB_POD_Qq
  2070.                         |  POG_POL_Qq
  2071.                         |  POH_POK_Qq
  2072.                         |  PMA_PMK_INT_Qq
  2073.                         |  PMA_PMK_INT_Qq+1
  2074.                         |  PMD_PME_PML_Qq
  2075.                         |  PMD_PME_PML_Qq+1 =>
  2076.                         set_line_at(first_tab);
  2077.                      when others =>
  2078.                         if panel_logger.column < first_tab then
  2079.                            set_line_at_minimum(first_tab);
  2080.                         end if;
  2081.                   end case;
  2082.                when normal_jump_order =>
  2083.                   set_line_at(jump_tab);
  2084.             end case;
  2085.
  2086.             -- Show the order in pseudo-Usercode format.
  2087.             log(the_full_name_of(INS, octal_option) &  "; ");
  2088.
  2089.             case INS.kind is
  2090.                when one_syllable_order =>
  2091.                   increment_by_1(address);
  2092.                when two_syllable_order =>
  2093.                   increment_by_2(address);
  2094.                when normal_jump_order | data_access_order =>
  2095.                   increment_by_3(address);
  2096.             end case;
  2097.
  2098.             if address.order_word_number = last.order_word_number then
  2099.                log_new_line;
  2100.                return;
  2101.             end if;
  2102.
  2103.             if (address.order_word_number+1)/is_a_data_word or
  2104.                   address.order_word_number > last.order_word_number then
  2105.                return;
  2106.             end if;
  2107.
  2108.             if is_a_store_order(INS)                   or else
  2109.                   INS.compressed_opcode = JCqNZS                or else
  2110.                      INS.kind = normal_jump_order      or else
  2111.                         panel_logger.column > last_column then
  2112.                log_new_line;
  2113.             elsif this_word = comparator and this_word /= last_word then
  2114.                log_new_line;
  2115.                log_line("==========  #"
  2116.                       & oct_of(KDF9.syllable(this_word and 255))
  2117.                       & "  ==========");
  2118.                address := (address.order_word_number+1, 0);
  2119.                if address.order_word_number > last.order_word_number or
  2120.                      address.order_word_number/is_a_data_word then
  2121.                   return;
  2122.                end if;
  2123.             end if;
  2124.
  2125.             last_word := this_word;
  2126.
  2127.          end loop;
  2128.
  2129.       end show_a_block_of_orders;
  2130.
  2131.    begin
  2132.       if the_program_has_been_analysed then
  2133.          log_line("Core store interpreted as instructions.");
  2134.          BA := 0; -- Ensure that physical store is examined when running in boot mode.
  2135.          address := first;
  2136.          loop
  2137.             show_a_block_of_orders;
  2138.             exit when address.order_word_number >= last.order_word_number;
  2139.          end loop;
  2140.          log_new_line;
  2141.          log_rule;
  2142.          CIA := saved_CIA;
  2143.          decode_the_next_order;
  2144.       else
  2145.          log_line(" ... Core store cannot be interpreted as instructions!");
  2146.          log_new_line;
  2147.       end if;
  2148.    end show_core_as_Usercode;
  2149.
  2150.    procedure show_core_as_syllables (first, last  : KDF9.syllable_address) is
  2151.
  2152.       address     :   KDF9.syllable_address;
  2153.
  2154.       procedure show_a_block is
  2155.
  2156.          procedure set_line_at (tab : Natural) is
  2157.          begin  -- set_line_at
  2158.             if panel_logger.column > tab then
  2159.                log_new_line;
  2160.             end if;
  2161.             if panel_logger.column < tab then
  2162.                tab_log_to(tab);
  2163.             end if;
  2164.          end set_line_at;
  2165.
  2166.       begin  -- show_a_block
  2167.          loop
  2168.             if address.syllable_index = 0 then
  2169.                log_new_line;
  2170.                log(oct_of(address) & ": ");
  2171.                set_line_at(jump_tab);
  2172.             end if;
  2173.             log(oct_of(fetch_syllable(address)) &  "; ");
  2174.             increment_by_1(address);
  2175.          exit when address.order_word_number > last.order_word_number;
  2176.          end loop;
  2177.          log_new_line;
  2178.       end show_a_block;
  2179.
  2180.     begin  -- show_core_as_syllables
  2181.        BA := 0; -- Ensure that physical store is examined when running in boot mode.
  2182.       log_line("Core store interpreted as order syllables.");
  2183.       address := first;
  2184.       loop
  2185.          show_a_block;
  2186.          exit when address.order_word_number > last.order_word_number;
  2187.       end loop;
  2188.       log_new_line;
  2189.       log_rule;
  2190.    end show_core_as_syllables;
  2191.
  2192.    procedure poke (address    : in KDF9.address;
  2193.                    sub_word   : in Character;
  2194.                    position   : in KDF9.address;
  2195.                    value      : in KDF9.word) is
  2196.    begin
  2197.       case sub_word is
  2198.          when 'W' | 'w' =>
  2199.             store_word(value, address);
  2200.          when 'U' | 'u' =>
  2201.             store_halfword(value*2**24, address, 0);
  2202.          when 'L' | 'l' =>
  2203.             store_halfword(value*2**24, address, 1);
  2204.          when 'S' | 's' =>
  2205.             store_syllable(KDF9.syllable(value), address, KDF9.syllable_index(position));
  2206.          when 'C' | 'c' =>
  2207.             store_symbol(KDF9_char_sets.symbol(value), address, KDF9_char_sets.symbol_index(position));
  2208.          when others =>
  2209.             raise emulation_failure with "invalid poke position " & sub_word & ".";
  2210.       end case;
  2211.    exception
  2212.       when error : others =>
  2213.          raise emulation_failure
  2214.             with "invalid poke operation: " & Ada.Exceptions.Exception_Information(error);
  2215.    end poke;
  2216.
  2217. end state_display;

Compiling: ../Source/state_display.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:24

     1. -- state_display.ads
     2. --
     3. -- Provide the comprehensive machine-state display panel KDF9 never had.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with KDF9;
    20.
    21. use  KDF9;
    22.
    23. package state_display is
    24.
    25.    procedure show_all_prerun_dump_areas;
    26.
    27.    procedure show_CIA_and_NIA;
    28.
    29.    procedure show_V_and_T;
    30.
    31.    procedure show_nest (when_empty : Boolean := True);
    32.
    33.    procedure show_sjns (when_empty : Boolean := True);
    34.
    35.    procedure show_IO_register (the_Q_register : in KDF9.Q_register;
    36.                                width          : in Positive := 8;
    37.                                for_DR,
    38.                                for_FD,
    39.                                for_FH,
    40.                                for_seek,
    41.                                for_OUT         : in Boolean  := False);
    42.
    43.    procedure show_Q_register (the_Q_register : in KDF9.Q_register;
    44.                               width          : in Positive := 8);
    45.
    46.    procedure show_Q_store;
    47.
    48.    procedure show_registers;
    49.
    50.    procedure show_execution_context;
    51.
    52.    procedure long_witness;
    53.
    54.    procedure short_witness;
    55.
    56.    procedure log_an_external_trace_header;
    57.
    58.    procedure log_to_external_trace;
    59.
    60.    procedure show_progress;
    61.
    62.    procedure show_Director_registers;
    63.
    64.    procedure show_retrospective_traces;
    65.
    66.    procedure show_current_state;
    67.
    68.    procedure show_final_state (because : String);
    69.
    70.    procedure mark_all_code_blocks_and_data_blocks;
    71.
    72.    the_program_has_been_analysed : Boolean := False;
    73.
    74.    procedure show_core_as_word_forms (first, last : in KDF9.address);
    75.
    76.    procedure show_core_as_syllables (first, last : in KDF9.syllable_address);
    77.
    78.    procedure show_core_as_Usercode (first, last  : in KDF9.syllable_address;
    79.                                     octal_option : in Boolean);
    80.
    81.    procedure show_core_in_print_code (first, last : in KDF9.address);
    82.
    83.    procedure show_core_in_card_code (first, last : in KDF9.address);
    84.
    85.    procedure show_core_in_tape_code (first, last : in KDF9.address);
    86.
    87.    procedure show_core_in_case_normal (first, last : in KDF9.address);
    88.
    89.    procedure show_core_in_case_shift (first, last : in KDF9.address);
    90.
    91.    procedure show_core_in_Latin_1 (first, last : in KDF9.address);
    92.
    93.    -- poke is included here as it has the same relationship to dumping as show_core_*.
    94.    procedure poke (address    : in KDF9.address;
    95.                    sub_word   : in Character;
    96.                    position   : in KDF9.address;
    97.                    value      : in KDF9.word);
    98.
    99.    -- Take note that an OUT 2 or OUT 0 has been obeyed.
   100.    procedure notify_termination;
   101.
   102. end state_display;

 2217 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/formatting.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:25

     1. -- formatting.adb
     2. --
     3. -- Provide basic data-formatting operations for KDF9 data types.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Characters.Handling;
    20. with Ada.Strings;
    21. with Ada.Strings.Fixed;
    22. --
    23. with KDF9_char_sets;
    24. with KDF9.CPU;
    25.
    26. use  Ada.Characters.Handling;
    27. use  Ada.Strings;
    28. use  Ada.Strings.Fixed;
    29. --
    30. use  KDF9_char_sets;
    31. use  KDF9.CPU;
    32.
    33. package body formatting is
    34.
    35.    digit_map : constant array (KDF9.halfword range 0 .. 15) of Character := "0123456789ABCDEF";
    36.
    37.    -- Return N as 3 octal digits.
    38.    function oct_of (N : KDF9.syllable)
    39.    return String
    40.    is (oct_of(KDF9.halfword(N))(6 .. 8));
    41.
    42.    -- Return N as 6 octal digits.
    43.    function oct_of (N : KDF9.field_of_16_bits)
    44.    return String is
    45.       value : KDF9.field_of_16_bits := N;
    46.       oct   : String(1 .. 6);
    47.    begin
    48.       for i in reverse oct'Range loop
    49.          oct(i) := digit_map(KDF9.halfword(value mod 8));
    50.          value := value / 8;
    51.       end loop;
    52.       return oct;
    53.    end oct_of;
    54.
    55.    -- Return N as 1 .. min_digits octal digits, with (partial) zero suppression.
    56.    function oct_of (N : KDF9.Q_part; min_digits : octal_width := 6)
    57.    return String is
    58.       oct : constant String(octal_width) := oct_of(KDF9.field_of_16_bits(N));
    59.    begin
    60.      if N = 0 then return (1..min_digits => '0'); end if;
    61.      for i in 1 .. 6-min_digits loop
    62.         if oct(i) /= '0' then
    63.            return oct(i .. 6);
    64.         end if;
    65.       end loop;
    66.       return oct(7-min_digits .. 6);
    67.    end oct_of;
    68.
    69.    -- Return N as 1 .. 5 decimal digits, with zero suppression and sign when neagtive.
    70.    function signed_dec_of (N : KDF9.Q_part)
    71.    return String is
    72.       dec : constant String := resign(N)'Image;
    73.    begin
    74.       return trimmed(dec);
    75.    end signed_dec_of;
    76.
    77.    -- Return N as decimal digits, with zero suppression.
    78.    function dec_of (N : KDF9.Q_part)
    79.    return String is
    80.       dec : constant String := N'Image;
    81.    begin
    82.       return trimmed(dec);
    83.    end dec_of;
    84.
    85.    -- Return N as up to 5 octal digits.
    86.    function oct_of (N : KDF9.order_word_number)
    87.    return String is
    88.       value : KDF9.order_word_number := N;
    89.       j     : Positive := 5;
    90.       oct   : String(1 .. 5);
    91.    begin
    92.       for i in reverse oct'Range loop
    93.          oct(i) := digit_map(KDF9.halfword(value mod 8));
    94.          value := value / 8;
    95.       end loop;
    96.       for i in oct'Range loop
    97.          if oct(i) /= '0' then j := i; exit; end if;
    98.       end loop;
    99.       return oct(j..5);
   100.    end oct_of;
   101.
   102.    -- Return N as decimal digits, with zero suppression.
   103.    function dec_of (N : KDF9.order_word_number)
   104.    return String
   105.    is (trimmed(N'Image));
   106.
   107.    -- Return N as 8 octal digits.
   108.    function oct_of (N : KDF9.halfword)
   109.    return String is
   110.       value : KDF9.halfword := N;
   111.       oct   : String(1 .. 8);
   112.    begin
   113.       for i in reverse oct'Range loop
   114.          oct(i) := digit_map(value mod 8);
   115.          value := value / 8;
   116.       end loop;
   117.       return oct;
   118.    end oct_of;
   119.
   120.    -- Return N as #wwwww/s, where w and s are octal digits.
   121.    function oct_of (N : KDF9.sjns_link)
   122.    return String
   123.    is (
   124.        "#"
   125.       &  oct_of(N.order_word_number)
   126.       & '/'
   127.       & digit_map(KDF9.halfword(N.syllable_index))
   128.       );
   129.
   130.    -- Return N as #wwwww/s, where w and s are octal digits.
   131.    function oct_of (N : KDF9.syllable_address)
   132.    return String
   133.    is (oct_of(KDF9.sjns_link(N)));
   134.
   135.    -- Return N as dddd/d, where d is a decimal digit.
   136.    function dec_of (N : KDF9.syllable_address)
   137.    return String
   138.    is (
   139.        trimmed(N.order_word_number'Image)
   140.             & '/'
   141.             & digit_map(KDF9.halfword(N.syllable_index))
   142.       );
   143.
   144.    -- Return N as #wwwww/s, where w and s are octal digits;
   145.    --    or as dddd/s, where d is a decimal digit, according to octal_option.
   146.    function oct_or_dec_of (N : KDF9.syllable_address; octal_option : Boolean)
   147.    return String
   148.    is (if octal_option then oct_of(N) else dec_of(N));
   149.
   150.    -- Return N as 16 octal digits
   151.    function oct_of (N : KDF9.word)
   152.    return String is
   153.       value : KDF9.word := N;
   154.       oct   : String(1 .. 16);
   155.    begin
   156.       for i in reverse oct'Range loop
   157.          oct(i) := digit_map(KDF9.halfword(value mod 8));
   158.          value := value / 8;
   159.       end loop;
   160.       return oct;
   161.    end oct_of;
   162.
   163.    -- Return "L', R'", or "L'" if R' is empty; "'" indicates removal of trailing blanks.
   164.    function "-" (L, R : String)
   165.    return String is
   166.       trim_R : constant String := trim(R, right);
   167.    begin
   168.       if trim_R /= "" then
   169.          return trim(L, right) & ", " & trim_R;
   170.       else
   171.          return trim(L, right);
   172.       end if;
   173.    end "-";
   174.
   175.    -- Return S with all leading an trailing blanks removed.
   176.    function trimmed (S : String)
   177.    return String
   178.    is (Trim(S, Ada.Strings.Both));
   179.
   180.    -- Return trimmed(S), right-just_right in a field of width at least W.
   181.    function just_right (S : String; W : Positive := 3)
   182.    return String is
   183.      image   : constant String   := Trim(S, Ada.Strings.Both);
   184.      columns : constant Positive := Positive'Max(W, image'Length);
   185.    begin
   186.      return Ada.Strings.Fixed.Tail(image, columns, ' ');
   187.    end just_right;
   188.
   189.    -- Return trimmed(S), left-justified in a field of width at least W.
   190.    function just_left (S : String; W : Positive := 3)
   191.    return String is
   192.      image   : constant String   := Trim(S, Ada.Strings.Both);
   193.      columns : constant Positive := Positive'Max(W, image'Length);
   194.    begin
   195.      return Ada.Strings.Fixed.Head(image, columns, ' ');
   196.    end just_left;
   197.
   198.    function plurality (count : KDF9.word; for_1 : String := ""; for_more : String := "s")
   199.    return String
   200.    is (if count /= 1 then for_more else for_1);
   201.
   202.    -- Return C converted to a 1-character string.
   203.    function "+" (C : Character)
   204.    return unit_string
   205.    is ((1 => C));
   206.
   207.    -- Return C with all Latin-1 lower-case letters converted to upper-case.
   208.    function to_upper (C : Character)
   209.    return Character
   210.    renames Ada.Characters.Handling.to_upper;
   211.
   212.    -- Return S with all Latin-1 lower-case letters converted to upper-case.
   213.    function to_upper (S : String)
   214.    return String
   215.    renames Ada.Characters.Handling.to_upper;
   216.
   217.    -- Return C with all Latin-1 upper-case letters converted to lower-case.
   218.    function to_lower (C : Character)
   219.    return Character
   220.    renames Ada.Characters.Handling.to_lower;
   221.
   222.    -- Return S with all Latin-1 upper-case letters converted to lower-case.
   223.    function to_lower (S : String)
   224.    return String
   225.    renames Ada.Characters.Handling.to_lower;
   226.
   227.    -- Return the 8-character Latin-1 string representing the 8 Case Normal characters in N.
   228.    function to_string (N : KDF9.word)
   229.    return word_as_byte_string is
   230.       word   : KDF9.word := N;
   231.       result : word_as_byte_string;
   232.    begin
   233.       for i in reverse 1 .. 8 loop
   234.          result(i) := KDF9_char_sets.TP_CN(KDF9_char_sets.symbol(word and 8#77#));
   235.          word := word / 64;
   236.       end loop;
   237.       return result;
   238.    end to_string;
   239.
   240.    -- Return the result of applying to_string to each word of a double-word.
   241.    function to_string (P : KDF9.pair)
   242.    return pair_as_byte_string is
   243.       result : pair_as_byte_string;
   244.    begin
   245.       result(1 ..  8) := to_string(P.msw);
   246.       result(9 .. 16) := to_string(P.lsw);
   247.       return result;
   248.    end to_string;
   249.
   250.    -- Take a string and ignore it.
   251.    procedure discard (S : String) is null;
   252.
   253. end formatting;

Compiling: ../Source/formatting.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:25

     1. -- formatting.ads
     2. --
     3. -- Provide basic data-formatting operations for KDF9 data types.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with KDF9;
    20.
    21. use  KDF9;
    22.
    23. package formatting is
    24.
    25.    subtype unit_string         is String(1 .. 1);
    26.    subtype word_as_byte_string is String(1 .. 8);
    27.    subtype pair_as_byte_string is String(1 .. 16);
    28.
    29.    -- Return N as 3 octal digits.
    30.    function oct_of (N : KDF9.syllable)
    31.    return String;
    32.
    33.    -- Return N as 6 octal digits.
    34.    function oct_of (N : KDF9.field_of_16_bits)
    35.    return String;
    36.
    37.    subtype octal_width is Positive range 1 .. 6;
    38.
    39.    -- Return N as octal digits, with (partial) zero suppression.
    40.    -- The first (6-min_digits) are elided if '0'; all remaining digits are returned.
    41.    -- Up to 6 digits can be returned if the result is longer than min_digits.
    42.    -- If N is 0, the String (1..min_digits => '0') is returned.
    43.    function oct_of (N : KDF9.Q_part; min_digits : octal_width := 6)
    44.    return String;
    45.
    46.    -- Return N as 1 .. 5 decimal digits, with zero suppression and sign when neagtive.
    47.    function signed_dec_of (N : KDF9.Q_part)
    48.    return String;
    49.
    50.    -- Return N as 1 .. 6 decimal digits, with zero suppression.
    51.    function dec_of (N : KDF9.Q_part)
    52.    return String;
    53.
    54.    -- Return N as up to 5 octal digits.
    55.    function oct_of (N : KDF9.order_word_number)
    56.    return String;
    57.
    58.    -- Return N as decimal digits, with zero suppression.
    59.    function dec_of (N : KDF9.order_word_number)
    60.    return String ;
    61.
    62.    -- Return N as 8 octal digits.
    63.    function oct_of (N : KDF9.halfword)
    64.    return String;
    65.
    66.    -- Return N as #wwwww/s, where w and s are octal digits.
    67.    function oct_of (N : KDF9.sjns_link)
    68.    return String;
    69.
    70.    -- Return N as #wwwww/s, where w and s are octal digits.
    71.    function oct_of (N : KDF9.syllable_address)
    72.    return String;
    73.
    74.    -- Return N as dddd/d, where d is a decimal digit.
    75.    function dec_of (N : KDF9.syllable_address)
    76.    return String;
    77.
    78.    -- Return N as #wwwww/s, where w and s are octal digits;
    79.    --    or as dddd/s, where d is a decimal digit, according to octal_option.
    80.    function oct_or_dec_of (N : KDF9.syllable_address; octal_option : Boolean)
    81.    return String;
    82.
    83.    -- Return N as 16 octal digits.
    84.    function oct_of (N : KDF9.word)
    85.    return String;
    86.
    87.    -- Return "L', R'", or "L'" if R' is empty: "'" indicates removal of trailing blanks.
    88.    function "-" (L, R : String)
    89.    return String;
    90.
    91.    -- Return S with all leading and trailing blanks removed.
    92.    function trimmed (S : String)
    93.    return String;
    94.
    95.    -- Return trimmed(S), right-justified in a field of width at least W.
    96.    function just_right (S : String; W : Positive := 3)
    97.    return String;
    98.
    99.    -- Return trimmed(S), left-justified in a field of width at least W.
   100.    function just_left (S : String; W : Positive := 3)
   101.    return String;
   102.
   103.    -- Return the (pluralizing) suffix if count /= 1.
   104.    function plurality (count : KDF9.word; for_1 : String := ""; for_more : String := "s")
   105.    return String;
   106.
   107.    -- Return C converted to a 1-character string.
   108.    function "+" (C : Character)
   109.    return unit_string;
   110.
   111.    -- Return C with all Latin-1 lower-case letters converted to upper-case.
   112.    function to_upper (C : Character)
   113.    return Character;
   114.
   115.    -- Return S with all Latin-1 lower-case letters converted to upper-case.
   116.    function to_upper (S : String)
   117.    return String;
   118.
   119.    -- Return C with all Latin-1 upper-case letters converted to lower-case.
   120.    function to_lower (C : Character)
   121.    return Character;
   122.
   123.    -- Return S with all Latin-1 upper-case letters converted to lower-case.
   124.    function to_lower (S : String)
   125.    return String;
   126.
   127.    -- Return the 8-character Latin-1 string representing the 8 Case Normal characters in N.
   128.    function to_string (N : KDF9.word)
   129.    return word_as_byte_string;
   130.
   131.    -- Return the result of applying to_string to each word of a double-word.
   132.    function to_string (P : KDF9.pair)
   133.    return pair_as_byte_string;
   134.
   135.    -- Take a string and ignore it.
   136.    procedure discard (S : String);
   137.
   138. end formatting;

 253 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/generic_logger.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:26

     1. -- generic_logger.adb
     2. --
     3. -- Provide operations supporting replicated output
     4. --    output to a list of logging interfaces.
     5. --
     6. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     7. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     8. --
     9. -- The ee9 program is free software; you can redistribute it and/or
    10. -- modify it under terms of the GNU General Public License as published
    11. -- by the Free Software Foundation; either version 3, or (at your option)
    12. -- any later version. This program is distributed in the hope that it
    13. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    14. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    15. -- See the GNU General Public License for more details. You should have
    16. -- received a copy of the GNU General Public License distributed with
    17. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    18. --
    19.
    20. -- generic
    21. --    max_logger_list_size : in Positive;
    22. package body generic_logger is
    23.
    24.    not overriding
    25.    procedure set_logger_list (logger : in out replicator; list : in distribution_list) is
    26.    begin
    27.       logger.data := (list'Length, list);
    28.    end set_logger_list;
    29.
    30.    overriding
    31.    procedure tab_log (logger   : in out replicator;
    32.                       at_least : in Natural;
    33.                       spacing  : in Positive;
    34.                       iff      : in Boolean := True) is
    35.    begin
    36.       for l in logger.data.list'Range loop
    37.          logger.data.list(l).tab_log(at_least, spacing, iff);
    38.       end loop;
    39.    end tab_log;
    40.
    41.    overriding
    42.    procedure tab_log_to (logger : in out replicator;
    43.                          column : in Positive;
    44.                          iff    : in Boolean := True) is
    45.    begin
    46.       for l in logger.data.list'Range loop
    47.          logger.data.list(l).tab_log_to(column, iff);
    48.       end loop;
    49.    end tab_log_to;
    50.
    51.    overriding
    52.    procedure log (logger : in out replicator;
    53.                   char   : in Character;
    54.                   iff    : in Boolean := True) is
    55.    begin
    56.       for l in logger.data.list'Range loop
    57.          logger.data.list(l).log(char, iff);
    58.       end loop;
    59.    end log;
    60.
    61.    overriding
    62.    procedure log (logger : in out replicator;
    63.                   text   : in String;
    64.                   iff    : in Boolean := True) is
    65.    begin
    66.       for l in logger.data.list'Range loop
    67.          logger.data.list(l).log(text, iff);
    68.       end loop;
    69.    end log;
    70.
    71.    overriding
    72.    procedure log_new_line (logger : in out replicator;
    73.                            iff    : in Boolean := True) is
    74.    begin
    75.       for l in logger.data.list'Range loop
    76.          logger.data.list(l).log_new_line(iff);
    77.       end loop;
    78.    end log_new_line;
    79.
    80.    overriding
    81.    procedure open (logger : in out replicator; log_name : in String) is
    82.    begin
    83.       for l in logger.data.list'Range loop
    84.          logger.data.list(l).open(log_name);
    85.       end loop;
    86.    end open;
    87.
    88.    overriding
    89.    procedure close (logger : in out replicator; log_name : in String) is
    90.    begin
    91.       for l in logger.data.list'Range loop
    92.          logger.data.list(l).close(log_name);
    93.       end loop;
    94.    end close;
    95.
    96.    overriding
    97.    procedure flush (logger : in out replicator; iff : in Boolean := True) is
    98.    begin
    99.       for l in logger.data.list'Range loop
   100.          logger.data.list(l).flush(iff);
   101.       end loop;
   102.    end flush;
   103.
   104. end generic_logger;

Compiling: ../Source/generic_logger.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:26

     1. -- generic_logger.ads
     2. --
     3. -- Provide operations supporting replicated output to a list of logging interfaces.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with logging;
    20.
    21. generic
    22.    max_logger_list_size : in Positive;
    23. package generic_logger is
    24.
    25.    type distribution_list is array (Positive range <>) of access logging.output'Class;
    26.
    27.    type replicator is new logging.output with private;
    28.
    29.    not overriding
    30.    procedure set_logger_list (logger : in out replicator; list : in distribution_list);
    31.
    32.    overriding
    33.    procedure tab_log (logger   : in out replicator;
    34.                       at_least : in Natural;
    35.                       spacing  : in Positive;
    36.                       iff      : in Boolean := True);
    37.
    38.    overriding
    39.    procedure tab_log_to (logger : in out replicator;
    40.                          column : in Positive;
    41.                          iff    : in Boolean := True);
    42.
    43.    overriding
    44.    procedure log (logger : in out replicator;
    45.                   char   : in Character;
    46.                   iff    : in Boolean := True);
    47.
    48.    overriding
    49.    procedure log (logger : in out replicator;
    50.                   text   : in String;
    51.                   iff    : in Boolean := True);
    52.
    53.    overriding
    54.    procedure log_new_line (logger : in out replicator;
    55.                            iff    : in Boolean := True);
    56.
    57.    overriding
    58.    procedure open  (logger : in out replicator; log_name : in String);
    59.
    60.    overriding
    61.    procedure close (logger : in out replicator; log_name : in String);
    62.
    63.    overriding
    64.    procedure flush (logger : in out replicator; iff : in Boolean := True);
    65.
    66. private
    67.
    68.    subtype logger_list_size is Natural range 0 .. max_logger_list_size;
    69.
    70.    -- This type is needed because tagged types cannot have discriminants.
    71.    type replica_list (length : logger_list_size := 0) is
    72.       record
    73.          list : distribution_list(1 .. length);
    74.       end record;
    75.
    76.    type replicator is new logging.output with
    77.       record
    78.          data : replica_list;
    79.       end record;
    80.
    81. end generic_logger;

 104 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/logging.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:26

     1. -- logging.ads
     2. --
     3. -- Define an abstract log output device.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package logging is
    20.
    21.    type output is interface;
    22.
    23.    procedure tab_log (logger   : in out logging.output;
    24.                       at_least : in Natural;
    25.                       spacing  : in Positive;
    26.                       iff      : in Boolean := True) is abstract;
    27.
    28.    procedure tab_log_to (logger : in out logging.output;
    29.                          column : in Positive;
    30.                          iff    : in Boolean := True) is abstract;
    31.
    32.    procedure log (logger : in out logging.output;
    33.                   char   : in Character;
    34.                   iff    : in Boolean := True) is abstract;
    35.
    36.    procedure log (logger : in out logging.output;
    37.                   text   : in String;
    38.                   iff    : in Boolean := True) is abstract;
    39.
    40.    procedure log_new_line (logger : in out logging.output;
    41.                            iff    : in Boolean := True) is abstract;
    42.
    43.    procedure open  (logger : in out logging.output; log_name : in String) is abstract;
    44.
    45.    procedure close (logger : in out logging.output; log_name : in String) is abstract;
    46.
    47.    procedure flush (logger : in out logging.output; iff : in Boolean := True) is abstract;
    48.
    49. end logging;

 49 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/logging-file.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:26

     1. -- file.adb
     2. --
     3. -- Provide logging output to a named text file.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Text_IO;
    20. with Ada.Unchecked_Deallocation;
    21. --
    22. with file_interfacing;
    23.
    24. use  Ada.Text_IO;
    25. --
    26. use  file_interfacing;
    27.
    28. package body logging.file is
    29.
    30.    overriding
    31.    procedure tab_log (logger   : in out file.output;
    32.                       at_least : in Natural;
    33.                       spacing  : in Positive;
    34.                       iff      : in Boolean := True) is
    35.       column_nr : constant Positive_Count := Col(logger.the_log.all) + Count(at_least);
    36.       excess    : constant Count          := column_nr mod Count(spacing);
    37.    begin
    38.       if not iff or logger.log_file_is_shut then return; end if;
    39.       Set_Col(logger.the_log.all, column_nr);
    40.       if excess /= 0 then
    41.          Set_Col(logger.the_log.all, column_nr + Count(spacing) - excess);
    42.       end if;
    43.    end tab_log;
    44.
    45.    overriding
    46.    procedure tab_log_to (logger : in out file.output;
    47.                          column : in Positive;
    48.                          iff    : in Boolean := True) is
    49.    begin
    50.       if not iff or logger.log_file_is_shut then return; end if;
    51.       Set_Col(logger.the_log.all, Positive_Count(column));
    52.    end tab_log_to;
    53.
    54.    overriding
    55.    procedure log_new_line (logger : in out file.output;
    56.                            iff    : in Boolean := True) is
    57.    begin
    58.       if not iff or logger.log_file_is_shut then return; end if;
    59.       New_Line(logger.the_log.all);
    60.    end log_new_line;
    61.
    62.    overriding
    63.    procedure log (logger : in out file.output;
    64.                   char   : in Character;
    65.                   iff    : in Boolean := True) is
    66.    begin
    67.       if not iff or logger.log_file_is_shut then return; end if;
    68.       Put(logger.the_log.all, char);
    69.    end log;
    70.
    71.    overriding
    72.    procedure log (logger : in out file.output;
    73.                   text   : in String;
    74.                   iff    : in Boolean := True) is
    75.    begin
    76.       if not iff or logger.log_file_is_shut then return; end if;
    77.       Put(logger.the_log.all, text);
    78.    end log;
    79.
    80.    overriding
    81.    procedure open (logger : in out file.output; logfile_name : in String) is
    82.    begin
    83.       if logger.log_file_is_shut then
    84.          logger.the_log := new Ada.Text_IO.File_Type;
    85.          file_interfacing.initialize(logger.the_log.all, out_file, logfile_name);
    86.          logger.log_file_is_shut := False;
    87.       end if;
    88.    end open;
    89.
    90.    overriding
    91.    procedure close (logger : in out file.output; logfile_name : in String) is
    92.
    93.       procedure free_log_file is
    94.          new Ada.Unchecked_Deallocation(Ada.Text_IO.File_Type, File_Type_access);
    95.
    96.    begin
    97.       if logger.log_file_is_shut then return; end if;
    98.       file_interfacing.finalize(logger.the_log.all, logfile_name);
    99.       free_log_file(logger.the_log);
   100.       logger.log_file_is_shut := True;
   101.    end close;
   102.
   103.    overriding
   104.    procedure flush (logger : in out file.output; iff : in Boolean := True) is
   105.    begin
   106.       if not iff or logger.log_file_is_shut then return; end if;
   107.       Flush(logger.the_log.all);
   108.    end flush;
   109.
   110. end logging.file;

Compiling: ../Source/logging-file.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:26

     1. -- logging-file.ads
     2. --
     3. -- Provide logging output to a named text file.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. private with Ada.Text_IO;
    20.
    21. package logging.file is
    22.
    23.    type output is new logging.output with private;
    24.
    25.    overriding
    26.    procedure tab_log (logger   : in out file.output;
    27.                       at_least : in Natural;
    28.                       spacing  : in Positive;
    29.                       iff      : in Boolean := True);
    30.
    31.    overriding
    32.    procedure tab_log_to (logger : in out file.output;
    33.                          column : in Positive;
    34.                          iff    : in Boolean := True);
    35.
    36.    overriding
    37.    procedure log (logger : in out file.output;
    38.                   char   : in Character;
    39.                   iff    : in Boolean := True);
    40.
    41.    overriding
    42.    procedure log (logger : in out file.output;
    43.                   text   : in String;
    44.                   iff    : in Boolean := True);
    45.
    46.    overriding
    47.    procedure log_new_line (logger : in out file.output;
    48.                            iff    : in Boolean := True);
    49.
    50.    overriding
    51.    procedure open  (logger : in out file.output; logfile_name : in String);
    52.
    53.    overriding
    54.    procedure close (logger : in out file.output; logfile_name : in String);
    55.
    56.    overriding
    57.    procedure flush (logger : in out file.output; iff    : in Boolean := True);
    58.
    59. private
    60.
    61.    type File_Type_access is access Ada.Text_IO.File_Type;
    62.
    63.    type output is new logging.output with
    64.       record
    65.          log_file_is_shut : Boolean := True;
    66.          the_log          : file.File_Type_access;
    67.       end record;
    68.
    69. end logging.file;

 110 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/logging-panel.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:26

     1. -- logging-panel.adb
     2. --
     3. -- Provide logging output to an interactive terminal/control panel.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with POSIX;
    20. with settings;
    21.
    22. use  POSIX;
    23. use  settings;
    24.
    25. package body logging.panel is
    26.
    27.    not overriding
    28.    function column (logger : panel.display)
    29.    return Positive
    30.    is (logger.column_number);
    31.
    32.    overriding
    33.    procedure tab_log (logger   : in out panel.display;
    34.                       at_least : in Natural;
    35.                       spacing  : in Positive;
    36.                       iff      : in Boolean := True) is
    37.       new_col : constant Natural := logger.column_number + at_least;
    38.       deficit : constant Natural := (spacing - new_col mod spacing) mod spacing;
    39.    begin
    40.       if not iff then return; end if;
    41.       for i in logger.column_number .. (new_col + deficit) loop
    42.          POSIX.output(' ');
    43.       end loop;
    44.       logger.column_number := new_col + deficit;
    45.    end tab_log;
    46.
    47.    overriding
    48.    procedure tab_log_to (logger : in out panel.display;
    49.                          column : in Positive;
    50.                          iff    : in Boolean := True) is
    51.    begin
    52.       if not iff then return; end if;
    53.       if column < logger.column_number then
    54.          logger.log_new_line;
    55.       end if;
    56.       for i in logger.column_number .. column-1 loop
    57.          POSIX.output(' ');
    58.       end loop;
    59.       logger.column_number := column;
    60.    end tab_log_to;
    61.
    62.    overriding
    63.    procedure log (logger : in out panel.display;
    64.                   char   : in Character;
    65.                   iff    : in Boolean := True) is
    66.    begin
    67.       if not iff then return; end if;
    68.       POSIX.output(char);
    69.       logger.column_number := logger.column_number + 1;
    70.    end log;
    71.
    72.    overriding
    73.    procedure log (logger : in out panel.display;
    74.                   text   : in String;
    75.                   iff    : in Boolean := True) is
    76.    begin
    77.       if not iff then return; end if;
    78.       if text /= "" then
    79.          POSIX.output(text);
    80.       end if;
    81.       logger.column_number := logger.column_number + text'Length;
    82.    end log;
    83.
    84.    overriding
    85.    procedure log_new_line (logger : in out panel.display;
    86.                            iff    : in Boolean := True) is
    87.    begin
    88.       if not iff then return; end if;
    89.       POSIX.output_line;
    90.       logger.column_number := 1;
    91.    end log_new_line;
    92.
    93.    not overriding
    94.    procedure show (logger : in out panel.display; message : in String := "") is
    95.    begin
    96.       if message /= "" then
    97.          logger.log(message);
    98.       end if;
    99.    end show;
   100.
   101.    not overriding
   102.    procedure show_line (logger : in out panel.display; message : in String := "") is
   103.    begin
   104.       if message /= "" then
   105.          logger.log(message);
   106.       end if;
   107.       logger.log_new_line;
   108.    end show_line;
   109.
   110.    not overriding
   111.    procedure interact (logger : in out panel.display; reason : in String := "Mode") is
   112.       old_mode : constant settings.diagnostic_mode := the_diagnostic_mode;
   113.       response : response_kind;
   114.       choice   : Character;
   115.    begin
   116.    interaction_loop:
   117.       loop
   118.          logger.column_number := 1;
   119.          POSIX.debug_prompt(noninteractive_usage_is_enabled, reason, response, choice);
   120.          if response = name_response then
   121.             case choice is
   122.                when 'q' | 'Q' =>
   123.                   quit_was_requested := True;
   124.                   exit interaction_loop;
   125.                when 'd' | 'D' =>
   126.                   debugging_is_enabled := not debugging_is_enabled;
   127.                   exit interaction_loop;
   128.                when 'f' | 'F' =>
   129.                   set_diagnostic_mode(fast_mode);
   130.                   exit interaction_loop;
   131.                when 'p' | 'P' =>
   132.                   set_diagnostic_mode(pause_mode);
   133.                   exit interaction_loop;
   134.                when 't' | 'T' =>
   135.                   set_diagnostic_mode(trace_mode);
   136.                   exit interaction_loop;
   137.                when others =>
   138.                   null; -- An invalid choice, try again.
   139.             end case;
   140.          elsif response = EOF_response then
   141.             exit;
   142.          end if;
   143.       end loop interaction_loop;
   144.       the_diagnostic_mode_changed := (the_diagnostic_mode /= old_mode) or quit_was_requested;
   145.    end interact;
   146.
   147. end logging.panel;

Compiling: ../Source/logging-panel.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:26

     1. -- logging-panel.ads
     2. --
     3. -- Provide logging output to an interactive terminal/control panel.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package logging.panel is
    20.
    21.    type display is new logging.output with private;
    22.
    23.    not overriding
    24.    function column (logger : panel.display)
    25.    return Positive;
    26.
    27.    overriding
    28.    procedure tab_log (logger   : in out panel.display;
    29.                       at_least : in Natural;
    30.                       spacing  : in Positive;
    31.                       iff      : in Boolean := True);
    32.
    33.    overriding
    34.    procedure tab_log_to (logger : in out panel.display;
    35.                          column : in Positive;
    36.                          iff    : in Boolean := True);
    37.
    38.    overriding
    39.    procedure log (logger : in out panel.display;
    40.                   char   : in Character;
    41.                   iff    : in Boolean := True);
    42.
    43.    overriding
    44.    procedure log (logger : in out panel.display;
    45.                   text   : in String;
    46.                   iff    : in Boolean := True);
    47.
    48.    overriding
    49.    procedure log_new_line (logger : in out panel.display;
    50.                            iff    : in Boolean := True);
    51.
    52.    not overriding
    53.    procedure show (logger : in out panel.display; message : in String := "");
    54.
    55.    not overriding
    56.    procedure show_line (logger : in out panel.display; message : in String := "");
    57.
    58.    not overriding
    59.    procedure interact (logger : in out panel.display; reason : in String := "Mode");
    60.
    61.    overriding
    62.    procedure open (logger : in out panel.display; logfile_name : in String) is null;
    63.
    64.    overriding
    65.    procedure close (logger : in out panel.display; logfile_name : in String) is null;
    66.
    67.    overriding
    68.    procedure flush (logger : in out panel.display; iff : in Boolean := True) is null;
    69.
    70. private
    71.
    72.    type display is new logging.output with
    73.       record
    74.          column_number : Positive := 1;
    75.       end record;
    76.
    77. end logging.panel;

 147 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-the_locker_of.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:26

     1. -- ioc-the_locker_of.adb
     2. --
     3. -- Identify the buffer that caused a store lockout.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. function IOC.the_locker_of (address : KDF9.Q_part)
    20. return KDF9.Q_part is
    21.    candidate_found  : Boolean := False;
    22.    candidate_time   : KDF9.us := KDF9.us'Last;
    23.    candidate_number : KDF9.buffer_number;
    24. begin
    25.    -- Select the buffer actively doing DMA in the_group;
    26.    --    if there is more than one, choose the buffer with the earliest completion time.
    27.    -- The latter case should not arise in practice, but is allowed by the hardware.
    28.    for b in buffer'Range loop
    29.       if buffer(b) /= null                                               and then
    30.             buffer(b).is_busy                                            and then
    31.                buffer(b).operation in input_operation | output_operation and then
    32.                   buffer(b).completion_time < candidate_time             and then
    33.                      group(address) in group(buffer(b).control_word.I)
    34.                                     .. group(buffer(b).control_word.M)       then
    35.          candidate_number := b;
    36.          candidate_time   := buffer(b).completion_time;
    37.          candidate_found  := True;
    38.       end if;
    39.    end loop;
    40.    if candidate_found then
    41.       return candidate_number;
    42.    else
    43.       return 16;
    44.    end if;
    45. end IOC.the_locker_of;

 45 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/kdf9-cpu.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:26

     1. -- kdf9-cpu.adb
     2. --
     3. -- Support for KDF9 CPU/ALU operations that are not automatically inherited from
     4. --   Ada types; and for types used in the internal functioning of the microcode.
     5. --
     6. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     7. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     8. --
     9. -- The ee9 program is free software; you can redistribute it and/or
    10. -- modify it under terms of the GNU General Public License as published
    11. -- by the Free Software Foundation; either version 3, or (at your option)
    12. -- any later version. This program is distributed in the hope that it
    13. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    14. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    15. -- See the GNU General Public License for more details. You should have
    16. -- received a copy of the GNU General Public License distributed with
    17. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    18. --
    19. --
    20.
    21. with exceptions;
    22.
    23. use  exceptions;
    24.
    25. package body KDF9.CPU is
    26.
    27. --
    28. --
    29.    --
    30.    -- KDF9 Arithmetic Control (AC) primitives representing Shift Control and associated units.
    31.    -- These units implement shifting, multiplication, division, and floating-point arithmetic.
    32.    --
    33. --
    34. --
    35.
    36.    -- Count the leading zeros of the absolute value of y, omitting the sign bit.
    37.    -- If y is 0, return 47.
    38.    function nr_leading_zeros (y : KDF9.word)
    39.    return Natural is
    40.       x : CPU.u_64;
    41.       r : Natural;
    42.    begin
    43.       if y = 0 then return 47; end if;
    44.       if resign(y) < 0 then
    45.          x := CPU.u_64(16#FFFF_FFFF_FFFF# and not y);
    46.       else
    47.          x := CPU.u_64(y);
    48.       end if;
    49.       -- Only 48 bits of x need be tested.
    50.       if (x and 16#FFFF_0000_0000#) /= 0 then
    51.          r := 32; x := shift_right(x, 32);
    52.       elsif (x and 16#FFFF_0000#) /= 0 then
    53.          r := 16; x := shift_right(x, 16);
    54.       else
    55.          r := 0;
    56.       end if;
    57.       if (x and 16#FF00#) /= 0 then
    58.          r := r + 8; x := shift_right(x, 8);
    59.       end if;
    60.       if (x and 16#F0#) /= 0 then
    61.          r := r + 4; x := shift_right(x, 4);
    62.       end if;
    63.       if (x and 16#C#) /= 0 then
    64.          r := r + 2; x := shift_right(x, 2);
    65.       end if;
    66.       if (x and 16#2#) /= 0 then
    67.          r := r + 1;
    68.       end if;
    69.       r := 47 - r - 1;  -- -1 discounts the sign bit.
    70.       return r;
    71.    end nr_leading_zeros;
    72.
    73.    function nr_one_bits (u : CPU.u_64)
    74.    return CPU.u_64 is
    75.       n : CPU.u_64 := shift_right(u, 1) and 16#77_77_77_77_77_77_77_77#;
    76.       x : CPU.u_64 := u - n;
    77.    begin
    78.       n := shift_right(n, 1) and 16#77_77_77_77_77_77_77_77#;
    79.       x := x - n;
    80.       n := shift_right(n, 1) and 16#77_77_77_77_77_77_77_77#;
    81.       x := x - n;
    82.       x := (x + shift_right(x, 4)) and 16#0F_0F_0F_0F_0F_0F_0F_0F#;
    83.       x := x * 16#01_01_01_01_01_01_01_01#;
    84.       return shift_right(x, CPU.u_64'Size-8);
    85.    end nr_one_bits;
    86.
    87.    KDF9_max_signed : constant CPU.s_64 := CPU.s_64(CPU.signed'Last);
    88.    KDF9_min_signed : constant CPU.s_64 := CPU.s_64(CPU.signed'First);
    89.
    90.    function as_word (u : CPU.u_64)
    91.    return KDF9.word
    92.    is (KDF9.word(u and KDF9.word_mask));
    93.
    94.    function as_word (s : CPU.s_64)
    95.    return KDF9.word is
    96.    begin
    97.       if s > KDF9_max_signed or s < KDF9_min_signed then
    98.          the_V_bit_is_set := True;
    99.       end if;
   100.       return as_word(unsign(s));
   101.    end as_word;
   102.
   103.    function contracted (msw, lsw : KDF9.word)
   104.    return KDF9.word is
   105.    begin
   106.       if resign(lsw) < 0 or (msw+1) > 1 then
   107.          the_V_bit_is_set := True;
   108.       end if;
   109.       return (lsw and not_sign_bit) or (msw and sign_bit);
   110.    end contracted;
   111.
   112.    function contracted (P : KDF9.pair)
   113.    return KDF9.word
   114.    is (contracted(msw => P.msw, lsw => P.lsw));
   115.
   116.    function shift_time (amount : Natural)
   117.    return KDF9.us
   118.    is (KDF9.us(amount/16 + amount/8 mod 2 + (if amount mod 8 > 0 then 1 else 0)));
   119.
   120.    function normalize_time (amount : Natural)
   121.    return KDF9.us
   122.    is (KDF9.us(amount/8 + (if amount mod 8 > 0 then 1 else 0)));
   123.
   124.    function shift_word_left (W : KDF9.word; amount : word_shift_length)
   125.    return KDF9.word
   126.    is (as_word(shift_left(CPU.u_64(W), amount)));
   127.
   128.    function shift_word_right (W : KDF9.word; amount : word_shift_length)
   129.    return KDF9.word
   130.    is (KDF9.word(shift_right(CPU.u_64(W), amount)));  -- This cannot be out of range.
   131.
   132.    function rotate_word_left (W : KDF9.word; amount : word_shift_length)
   133.    return KDF9.word
   134.    is (shift_word_left(W, amount) or shift_word_right(W, 48-amount));
   135.
   136.    function rotate_word_right (W : KDF9.word; amount : word_shift_length)
   137.    return KDF9.word
   138.    is (shift_word_right(W, amount) or shift_word_left(W, 48-amount));
   139.
   140.    function shift_circular (W : KDF9.word; L : CPU.signed_Q_part)
   141.    return KDF9.word
   142.       -- The logic here conforms to ¶1.1 of EE Report K/GD.y.80, entitled
   143.       --    "KDF 9: SHIFTING AND SHIFT CONTROL".
   144.       -- Circular shifts were implemented by duplicating the operand, doing a double-length
   145.       --    shift of the two words, and selecting the appropriate word from the result.
   146.    is (
   147.        if abs L > 95 then 0
   148.        elsif L < -48 then shift_word_right(W, Natural(-L-48))
   149.        elsif L > +48 then shift_word_left(W, Natural(+L-48))
   150.        elsif L < 0   then rotate_word_right(W, Natural(-L))
   151.        else               rotate_word_left(W, Natural(L))
   152.       );
   153.
   154.    function shift_logical (W : KDF9.word; L : CPU.signed_Q_part)
   155.    return KDF9.word
   156.    is
   157.       (
   158.        if abs L > 47 then 0
   159.        elsif  L < 0  then shift_word_right(W, Natural(-L))
   160.        else               shift_word_left(W, Natural(L))
   161.       );
   162.
   163.    function shift_pair_left (P : KDF9.pair; L : Natural)
   164.    return KDF9.pair
   165.       with Inline;
   166.
   167.    function shift_pair_left (P : KDF9.pair; L : Natural)
   168.    return KDF9.pair is
   169.       result    : KDF9.pair;
   170.       crossover : KDF9.word;
   171.    begin
   172.       -- The logic here conforms to ¶3.2 of EE Report K/GD.y.80.
   173.       if L < 48 then
   174.          result.lsw := shift_word_left(P.lsw, L);
   175.          crossover  := shift_word_right(P.lsw, 48-L);
   176.          result.msw := shift_word_left(P.msw, L) or crossover;
   177.       else
   178.          result.lsw := 0;
   179.          result.msw := shift_word_left(P.lsw, L-48);
   180.       end if;
   181.       return result;
   182.    end shift_pair_left;
   183.
   184.    function shift_pair_right (P : KDF9.pair; L : Natural)
   185.    return KDF9.pair
   186.       with Inline;
   187.
   188.    function shift_pair_right (P : KDF9.pair; L : Natural)
   189.    return KDF9.pair is
   190.       result    : KDF9.pair;
   191.       crossover : KDF9.word;
   192.    begin
   193.       -- The logic here conforms to ¶3.2 of EE Report K/GD.y.80.
   194.       if L < 48 then
   195.          result.msw := shift_word_right(P.msw, L);
   196.          crossover  := shift_word_left(P.msw, 48-L);
   197.          result.lsw := shift_word_right(P.lsw, L) or crossover;
   198.       else
   199.          result.msw := 0;
   200.          result.lsw := shift_word_right(P.msw, L-48);
   201.       end if;
   202.       return result;
   203.    end shift_pair_right;
   204.
   205.    function shift_logical (P : KDF9.pair; L : CPU.signed_Q_part)
   206.    return KDF9.pair
   207.    is (
   208.        if    L > 0 then shift_pair_left(P, Natural(L))
   209.        elsif L < 0 then shift_pair_right(P, Natural(-L))
   210.        else        P
   211.       );
   212.
   213.    function scale_down (W : KDF9.word; amount : Natural)
   214.    return KDF9.word is
   215.       unrounded, clearing : CPU.u_64;
   216.    begin
   217.       if amount = 0 then
   218.          return W;
   219.       elsif amount > 46 then
   220.          if resign(W) < 0 then
   221.             return KDF9.all_one_bits;
   222.          else
   223.             return 0;
   224.          end if;
   225.       else
   226.          -- It is undefined whether the intrinsic shift_right_arithmetic function,
   227.          --    operating on CPU.u_64, yields a rounded result.
   228.          -- So, any rounding it might do is completely suppressed.
   229.          unrounded := shift_right_arithmetic(shift_left(CPU.u_64(W),16), 16);
   230.          clearing  := - shift_left(1, amount);
   231.          return as_word(shift_right_arithmetic(unrounded and clearing, amount));
   232.       end if;
   233.    end scale_down;
   234.
   235.    function scale_down_and_round (W : KDF9.word; amount : Natural)
   236.    return KDF9.word is
   237.       unrounded, clearing, rounding : CPU.u_64;
   238.    begin
   239.       if amount = 0 then
   240.          return W;
   241.       elsif amount > 46 then
   242.          if resign(W) < 0 then
   243.             return KDF9.all_one_bits;
   244.          else
   245.             return 0;
   246.          end if;
   247.       else
   248.          -- It is undefined whether the intrinsic shift_right_arithmetic,
   249.          --    operating on CPU.u_64, yields a rounded result.
   250.          -- So, any rounding it might do is suppressed,
   251.          --    and correct rounding is explicitly computed.
   252.          unrounded := shift_right_arithmetic(shift_left(CPU.u_64(W),16), 16);
   253.          rounding  := shift_right(unrounded, amount-1) and 1;
   254.          clearing  := - shift_left(1, amount);
   255.          unrounded := unrounded and clearing;
   256.          return as_word(shift_right_arithmetic(unrounded, amount) + rounding);
   257.       end if;
   258.    end scale_down_and_round;
   259.
   260.    function scale_up (W : KDF9.word; amount : Natural)
   261.    return KDF9.word is
   262.       M : constant Natural := Natural'Min(amount, 47);
   263.    begin
   264.       if resign(W) < 0 then
   265.          if scale_down(W, 47-M) /= all_one_bits or
   266.                resign(shift_word_left(W, M)) >= 0 then
   267.             -- See EE Report K/GD.y.80., ¶ 1.1.
   268.             the_V_bit_is_set := True;
   269.          end if;
   270.          return shift_word_left(W, M);
   271.       else
   272.          if shift_word_right(W, 47-M) /= all_zero_bits or
   273.                resign(shift_word_left(W, M)) < 0 then
   274.             -- See EE Report K/GD.y.80., ¶ 1.1.
   275.             the_V_bit_is_set := True;
   276.          end if;
   277.          return shift_word_left(W, M);
   278.       end if;
   279.    end scale_up;
   280.
   281.    function shift_arithmetic (I : KDF9.word; L : CPU.signed_Q_part)
   282.    return KDF9.word
   283.    is (
   284.        if L < 0 then scale_down_and_round(I, Natural(-L))
   285.        else          scale_up(I, Natural(L))
   286.       );
   287.
   288.    function scale_up (P : KDF9.pair; L : Natural)
   289.    return KDF9.pair is
   290.       result    : KDF9.pair;
   291.       crossover : KDF9.word;
   292.    begin
   293.       -- The logic here conforms to ¶3.2 of EE Report K/GD.y.80.
   294.       if L < 48 then
   295.          result.lsw := shift_word_left(P.lsw, L) and KDF9.max_word;
   296.          crossover  := shift_word_right(P.lsw and KDF9.max_word, 47-L);
   297.          result.msw := scale_up(P.msw, L) or crossover;
   298.       else
   299.          result.lsw := 0;
   300.          result.msw := scale_up(P.msw, 47) or P.lsw;
   301.          result.msw := scale_up(result.msw, Natural'Min(L, 94)-47);
   302.      end if;
   303.       return result;
   304.    end scale_up;
   305.
   306.    function scale_down (P : KDF9.pair; L : Natural)
   307.    return KDF9.pair is
   308.       result    : KDF9.pair;
   309.       crossover : KDF9.word;
   310.    begin
   311.       -- The logic here conforms to ¶3.2 of EE Report K/GD.y.80.
   312.       -- SHAD-n does NOT round, according to the Manual.
   313.       if L < 48 then
   314.          result.msw := scale_down(P.msw, L);
   315.          crossover  := shift_word_left(P.msw, 47-L) and KDF9.max_word;
   316.          -- It is not clear whether D0 of the lsw should be cleared before or after shifting.
   317.          -- I now clear it before shifting for compatibility with D. Holdsworth's "kdf9".
   318.          result.lsw := shift_word_right(P.lsw and KDF9.max_word, L) or crossover;
   319.       else
   320.          result.msw := scale_down(P.msw, 47);
   321.          result.lsw := shift_word_right(P.msw, Natural'Min(L, +94)-47) and KDF9.max_word;
   322.       end if;
   323.       return result;
   324.    end scale_down;
   325.
   326.    function shift_arithmetic (P : KDF9.pair; L : CPU.signed_Q_part)
   327.    return KDF9.pair
   328.    is (
   329.        if    L < 0 then scale_down(P, Natural(-L))
   330.        elsif L > 0 then scale_up(P, Natural(L))
   331.        else             P -- See ¶1.1 of EE Report K/GD.y.80: this avoids clearing D0 of P.lsw.
   332.       );
   333.
   334.    procedure normalize (fraction, exponent : in out KDF9.word) is
   335.       sign_flag  : constant KDF9.word := shift_word_right(fraction and sign_bit, 1);
   336.       normalizer : Natural;
   337.    begin
   338.       if fraction = 0 then
   339.          exponent := 2#10_000_000#;  -- This yields 0 when biased positive.
   340.          return;
   341.       end if;
   342.
   343.       normalizer := nr_leading_zeros(fraction);
   344.       exponent := exponent - KDF9.word(normalizer);
   345.
   346.       -- shift_word_left is used, not _arithmetic, as D[1..normalizer] = D0
   347.       fraction := shift_word_left(fraction, normalizer);
   348.
   349.       the_CPU_delta := the_CPU_delta + normalize_time(normalizer);
   350.
   351.       -- scale_down_and_round may round up and overflow the fraction bits ...
   352.       fraction := scale_down_and_round(fraction, 8);
   353.       if (fraction and overflow_mask) /= shift_word_right(sign_flag, 7) then
   354.           -- ... so re-normalize; scale_down cannot round here.
   355.          fraction := scale_down(fraction, 1);
   356.          the_CPU_delta := the_CPU_delta + normalize_time(1);
   357.          exponent := exponent + 1;
   358.          the_CPU_delta := the_CPU_delta + 1;
   359.       end if;
   360.       fraction := fraction and mantissa_mask;
   361.
   362.       if resign(exponent) < -128 then
   363.          -- Deal with underflow.
   364.          fraction := 0;
   365.          exponent := 2#10_000_000#;  -- This yields 0 when biased positive.
   366.       elsif resign(exponent) > +127 then
   367.          -- Deal with overflow.
   368.          the_V_bit_is_set := True;
   369.          exponent := 2#01_111_111#;
   370.       end if;
   371.    end normalize;
   372.
   373.    function fraction_word (mantissa : CPU.f48)
   374.    return KDF9.word
   375.     -- shift_word_left must be used instead of scale_up to avoid a spurious overflow.
   376.    is (
   377.        (shift_word_left(as_word(mantissa), 8) and KDF9.max_word)
   378.           or
   379.        (as_word(mantissa) and sign_bit)
   380.       );
   381.
   382.    function masked_mantissa (F : CPU.f48)
   383.    return CPU.f48
   384.    is (as_f48(as_word(F) and mantissa_mask));
   385.
   386.    function scaler (F : CPU.f48)
   387.    return KDF9.word
   388.    is ((shift_word_right(as_word(F), 39) and 2#11_111_111#) - 128);
   389.
   390.    function normalized (full_fraction, scaler : KDF9.word)
   391.    return CPU.f48 is
   392.       E : KDF9.word := scaler;
   393.       F : KDF9.word := full_fraction;
   394.    begin
   395.       normalize(fraction => F, exponent => E);
   396.       return CPU.f48(shift_word_left((E + 128) and 2#11_111_111#, 39) or F);
   397.    end normalized;
   398.
   399.    function normalized  (R : CPU.f48)
   400.    return CPU.f48
   401.    is (normalized(full_fraction => fraction_word(R), scaler => scaler(R)));
   402.
   403.    function cardinality (W : KDF9.word)
   404.    return KDF9.word
   405.    is (KDF9.word(nr_one_bits(CPU.u_64(W))));
   406.
   407.    function "-" (I : CPU.signed)
   408.    return KDF9.word
   409.    is (as_word(-CPU.s_64(I)));
   410.
   411.    function "abs" (I : CPU.signed)
   412.    return KDF9.word
   413.    is (as_word(abs CPU.s_64(I)));
   414.
   415.    function "+" (L, R : CPU.signed)
   416.    return KDF9.word
   417.    is (as_word(CPU.s_64(L) + CPU.s_64(R)));
   418.
   419.    function "-" (L, R : CPU.signed)
   420.    return KDF9.word
   421.    is (as_word(CPU.s_64(L) - CPU.s_64(R)));
   422.
   423.    function "*" (L, R : CPU.signed)
   424.    return KDF9.word
   425.    is (contracted(KDF9.pair'(unsign(L) * unsign(R))));
   426.
   427.    procedure do_DIVI (L : in KDF9.word;
   428.                       R : in KDF9.word;
   429.                       Quotient, Remainder : out KDF9.word) is
   430.    begin
   431.       if R /= 0 then
   432.          Remainder := as_word(CPU.s_64(resign(L)) mod CPU.s_64(resign(R)));
   433.          Quotient  :=
   434.             as_word((CPU.s_64(resign(L)) - CPU.s_64(resign(Remainder))) / CPU.s_64(resign(R)));
   435.       else
   436.          the_V_bit_is_set := True;
   437.          Quotient  := L;  -- ??
   438.          Remainder := R;  -- ??
   439.       end if;
   440.    end do_DIVI;
   441.
   442.    function "*" (L, R : KDF9.word)
   443.    return CPU.fraction is
   444.    begin
   445.       if L = sign_bit and R = sign_bit then
   446.          the_V_bit_is_set := True;
   447.          return as_fraction(sign_bit);  -- The only case is L = R = -1.0 = L*R.
   448.       else
   449.          return as_fraction(L) * as_fraction(R);
   450.       end if;
   451.    end "*";
   452.
   453.    function "/" (L, R : KDF9.word)
   454.    return CPU.fraction is
   455.    begin
   456.       if R = 0 or L = sign_bit then
   457.          the_V_bit_is_set := True;
   458.          return as_fraction(L); -- ??
   459.       elsif R = sign_bit then
   460.          return -as_fraction(L);
   461.       elsif abs as_fraction(L) < abs as_fraction(R) then  -- abs is safe now.
   462.          return as_fraction(L) / as_fraction(R);
   463.       else
   464.          the_V_bit_is_set := True;
   465.          return as_fraction(L); -- ??
   466.       end if;
   467.    end "/";
   468.
   469.    function "+" (L, R : KDF9.pair)
   470.    return KDF9.pair is
   471.       carry, sum : CPU.s_64;
   472.       result     : KDF9.pair;
   473.    begin
   474.       sum := CPU.s_64(L.lsw) + CPU.s_64(R.lsw);
   475.       if unsign(sum) > KDF9.max_word then -- carry into msw
   476.          carry := 1;
   477.          result.lsw := KDF9.word(unsign(sum) and KDF9.max_word);
   478.       else
   479.          carry := 0;
   480.          result.lsw := KDF9.word(sum);
   481.       end if;
   482.       sum := CPU.s_64(resign(L.msw)) + CPU.s_64(resign(R.msw)) + carry;
   483.       result.msw := as_word(sum);
   484.       return result;
   485.    end "+";
   486.
   487.    function "-" (J : KDF9.pair)
   488.    return KDF9.pair is
   489.       borrow,
   490.       negative : CPU.s_64;
   491.       result   : KDF9.pair;
   492.    begin
   493.       negative := - CPU.s_64(J.lsw);
   494.       if unsign(negative) > KDF9.max_word then -- borrow from msw
   495.          borrow := 1;
   496.          result.lsw := KDF9.word(unsign(negative) and KDF9.max_word);
   497.       else
   498.          borrow := 0;
   499.          result.lsw := KDF9.word(negative);
   500.       end if;
   501.       negative := - CPU.s_64(resign(J.msw)) - borrow;
   502.       result.msw := as_word(negative);
   503.       return result;
   504.    end "-";
   505.
   506.    function "-" (L, R : KDF9.pair)
   507.    return KDF9.pair is
   508.       borrow,
   509.       difference : CPU.s_64;
   510.       result     : KDF9.pair;
   511.    begin
   512.       difference := CPU.s_64(L.lsw) - CPU.s_64(R.lsw);
   513.       if unsign(difference) > KDF9.max_word then -- borrow from msw
   514.          borrow := 1;
   515.          result.lsw := KDF9.word(unsign(difference) and KDF9.max_word);
   516.       else
   517.          borrow := 0;
   518.          result.lsw := KDF9.word(difference);
   519.       end if;
   520.       difference := CPU.s_64(resign(L.msw)) - CPU.s_64(resign(R.msw)) - borrow;
   521.       result.msw := as_word(difference);
   522.       return result;
   523.    end "-";
   524.
   525.    function "*" (L, R : KDF9.word)
   526.    return KDF9.pair is
   527.       S, T, U, V, W : KDF9.word;
   528.       H, M, B       : KDF9.pair;
   529.    begin
   530.       if L = sign_bit then
   531.          if R = L then
   532.             -- L*R = (+1.0), which is not a valid fraction, so deal with overflow.
   533.             the_V_bit_is_set := True;
   534.             return (L, 0);
   535.          else
   536.             -- L*R = -R.
   537.             return - (R, 0);
   538.          end if;
   539.       end if;
   540.       if R = sign_bit then
   541.          -- L*R = -L.
   542.          return - (L, 0);
   543.       end if;
   544.       -- Now it is safe to take absolute values, as they cannot overflow.
   545.       S := scale_down(abs resign(L), 24);
   546.       T := abs resign(L) and halfword_mask;
   547.       U := scale_down(abs resign(R), 24);
   548.       V := abs resign(R) and halfword_mask;
   549.       H := ((S*U)*2, 0);
   550.       M := scale_down((KDF9.word'(S*V), 0), 1) + scale_down((KDF9.word'(T*U), 0), 1);
   551.       M := scale_down(M, 22);
   552.       W := rotate_word_left(KDF9.word'(T*V), 1);
   553.       B := (W and 1, shift_word_right(W, 1));
   554.       if resign(L xor R) < 0 then
   555.          return - (H + M + B);
   556.       else
   557.          return    H + M + B;
   558.       end if;
   559.    end "*";
   560.
   561.    f_64_small : constant := 2.0**(-63);
   562.    type f_64 is delta f_64_small range -1.0 .. +1.0 - f_64_small with Size => 64;
   563.
   564.    function scale_down (f : CPU.f_64; N : Natural)
   565.    return f_64
   566.    is (if N > 62 then 0.0 else f / 2**N);
   567.
   568.    function to_f_64 (w : KDF9.word)
   569.    return CPU.f_64
   570.    is (CPU.f_64(as_fraction(w)));
   571.
   572.    function to_word (f : CPU.f_64)
   573.    return KDF9.word
   574.    is (as_word(CPU.fraction(f)));
   575.
   576.    procedure do_DIVD (L : in KDF9.pair;
   577.                       R : in KDF9.word;
   578.                       Q : out KDF9.word
   579.                      ) is
   580.       to_normalize_L : Natural;
   581.       to_normalize_R : Natural;
   582.       to_normalize_Q : Integer;
   583.       N              : KDF9.pair;
   584.       D              : KDF9.word;
   585.       Ls, Rs, Qs     : CPU.f_64;
   586.    begin
   587.       -- Deal very quickly with a zero result.
   588.       if (L.msw or L.lsw) = 0 then
   589.          Q := 0;
   590.          return;
   591.       end if;
   592.
   593.       -- Deal with division by 0.
   594.       if R = 0 then
   595.          the_V_bit_is_set := True;
   596.          Q := L.msw;  -- This is a guess at the result for division by zero ?? !!
   597.          return;
   598.       end if;
   599.
   600.       -- Check for an invalid numerator; D0 of L.lsw must be 0.
   601.       if resign(L.lsw) < 0 then -- L is not a valid double-length number.
   602.          the_V_bit_is_set := True;
   603.          Q := L.msw;  -- This is a guess at the result for an invalid numerator ?? !!
   604.          return;
   605.       end if;
   606.
   607.       to_normalize_L := nr_leading_zeros(L.msw);
   608.       if to_normalize_L > 46 then -- insignificant top half
   609.          N := scale_up(L, 47);
   610.          to_normalize_L := nr_leading_zeros(N.msw);
   611.          N := scale_up(N, to_normalize_L);
   612.          to_normalize_L := to_normalize_L + 47;
   613.       else
   614.          N := scale_up(L, to_normalize_L);
   615.       end if;
   616.
   617.       to_normalize_R := nr_leading_zeros(R);
   618.       D := scale_up(R, to_normalize_R);
   619.
   620.       -- Scale Ls and Rs so that the Ada fractional division cannot overflow.
   621.       Ls := scale_down(to_f_64(N.msw), 2);
   622.       Rs := scale_down(to_f_64(D), 1);
   623.
   624.       Qs := Ls / Rs;  -- "/" cannot overflow here.
   625.
   626.       to_normalize_Q := 1 + to_normalize_R - to_normalize_L;
   627.
   628.       if to_normalize_Q <= 0 then
   629.          -- Overflow is impossible.
   630.          Qs := scale_down(Qs, -to_normalize_Q);
   631.          Q := to_word(Qs);
   632.       else
   633.          -- If Qs >= 0.5, then L/R >= 1.0 is not a representable result fraction.
   634.          -- If Qs < -0.5, then L/R < -1.0 is not a representable result fraction.
   635.          if Qs >= 0.5 or Qs < -0.5 then
   636.             the_V_bit_is_set := True;
   637.             Q := L.msw / R;  -- This is a guess at the result when it overflows ?? !!
   638.             return;
   639.          end if;
   640.          Q := scale_up(to_word(Qs), to_normalize_Q);
   641.       end if;
   642.    end do_DIVD;
   643.
   644.    procedure do_DIVR (L : in KDF9.pair;
   645.                       R : in KDF9.word;
   646.                       Quotient, Remainder : out KDF9.word
   647.                      ) is
   648.       correction_count_limit : constant := 3;
   649.       correction_count       : Natural  := 0;
   650.       V  : constant Boolean := the_V_bit_is_set;
   651.       N  : KDF9.pair := L;
   652.       D  : KDF9.word := R;
   653.       S  : KDF9.word := +1;
   654.       P,
   655.       T  : KDF9.pair;
   656.    begin
   657.       if (N.msw or N.lsw) = 0 then
   658.          Quotient  := 0;
   659.          Remainder := 0;
   660.          return;
   661.       end if;
   662.
   663.       if D = 0 then
   664.          the_V_bit_is_set := True;
   665.          Quotient  := L.msw;  -- This is a guess at the result for division by zero ?? !!
   666.          Remainder := L.lsw;  -- This is a guess at the result for division by zero ?? !!
   667.          return;
   668.       end if;
   669.
   670.       -- Check for an invalid numerator; D0 of N1 must be 0.
   671.       if resign(L.lsw) < 0 then -- L is not a valid double-length number.
   672.          the_V_bit_is_set := True;
   673.          Quotient  := L.msw;  -- This is a guess at the result for invalid numerator ?? !!
   674.          Remainder := L.lsw;  -- This is a guess at the result for invalid numerator ?? !!
   675.          return;
   676.       end if;
   677.
   678.       -- Convert to an unsigned division problem, and note whether it needs to be be converted back.
   679.       if resign(N.msw) < 0 then -- L is negative.
   680.          N := - N;
   681.          S := - S;
   682.       end if;
   683.
   684.       if resign(D) < 0 then  -- R is negative.
   685.          D := - D;
   686.          S := - S;
   687.       end if;
   688.
   689.       -- Check for inevitable overflow, and deal with it separately.
   690.       if N.msw > D then
   691.          Quotient := N.msw / D * S;  -- This is a guess at the result when it overflows ?? !!
   692.          T := L - (msw => Quotient*R, lsw => 0);
   693.          Remainder := T.msw;         -- This is a guess at the result when it overflows ?? !!
   694.          the_V_bit_is_set := True;
   695.          return;
   696.       end if;
   697.
   698.       -- Overflow should not now be possible.
   699.       -- Ensure that an overflow in DIVD is trapped as a failure
   700.       the_V_bit_is_set := False;
   701.       do_DIVD(N, D, Quotient);
   702.       if the_V_bit_is_set then
   703.          raise emulation_failure with "DIVR overflows in DIVD";
   704.       end if;
   705.       -- Restore the input value of the overflow register.
   706.       the_V_bit_is_set := V;
   707.
   708.       -- Adjust Quotient until the difference between N and Quotient*D fits in one word.
   709.       correction_count := 0;
   710.       loop
   711.          P := Quotient * D;
   712.          T := N - P;
   713.       exit when T.msw = 0;
   714.          correction_count := correction_count + 1;
   715.          if correction_count > correction_count_limit then
   716.              raise emulation_failure with "DIVR exceeds correction_count_limit A";
   717.          end if;
   718.          Quotient := Quotient + 1;
   719.       end loop;
   720.
   721.       Remainder := T.lsw;
   722.
   723.       -- Adjust Quotient and Remainder until Remainder is less than the divisor in absolute value.
   724.       correction_count := 0;
   725.       while Remainder >= D loop
   726.          correction_count := correction_count + 1;
   727.          if resign(Remainder) > 0 then
   728.             Remainder := Remainder - D;
   729.             Quotient := Quotient + 1;
   730.          else
   731.             Remainder := Remainder + D;
   732.             Quotient := Quotient - 1;
   733.          end if;
   734.          if correction_count > correction_count_limit then
   735.              raise emulation_failure with "DIVR exceeds correction_count_limit B";
   736.          end if;
   737.       end loop;
   738.
   739.       Quotient  := Quotient * S;
   740.       Remainder := contracted(L - Quotient*R);
   741.    end do_DIVR;
   742.
   743.    function host_float (X : CPU.f48)
   744.    return Long_Float is
   745.       -- Warn if Long_Float does not have at least the range of a KDF9 floating point number.
   746.       pragma Compile_Time_Warning(Long_Float'Last < 2.0**127,
   747.                                   "Long_Float does not have enough range for KDF9 f.p.");
   748.       -- Warn if Long_Float does not have at least the precision of a KDF9 floating point number.
   749.       pragma Compile_Time_Warning(Long_Float'Small > 1.0/2.0**39,
   750.                                   "Long_Float does not have enough precision for KDF9 f.p.");
   751.       W : constant KDF9.word  := fraction_word(masked_mantissa(X));
   752.       S : constant Long_Float := 2.0**Integer(resign(scaler(X)));
   753.    begin
   754.       return Long_Float(as_fraction(W)) * S;  -- Cannot overflow if warnings are absent.
   755.    end host_float;
   756.
   757.    -- Round a 48-bit floating-point number to 24-bit format.
   758.    function narrowed (R : CPU.f48)
   759.    return CPU.f48
   760.    is (normalized(fraction_word(R) + 2**23, scaler(R)));
   761.
   762.    overriding
   763.    function "-" (R : CPU.f48)
   764.    return CPU.f48 is
   765.       -- F is made half of a true fraction to prevent overflow when negating:
   766.       --    the result exponent is offset by 1, accordingly.
   767.       E : constant KDF9.word := scaler(R) + 1;
   768.       F : KDF9.word := scale_down_and_round(fraction_word(R), 1);
   769.    begin
   770.       F := as_word(CPU.u_64(-F));  -- "-" cannot overflow here.
   771.       return normalized(full_fraction => F, scaler => E);
   772.    end "-";
   773.
   774.    overriding
   775.    function "abs" (R : CPU.f48)
   776.    return CPU.f48
   777.    is (if resign(KDF9.word(R)) < 0 then - R else + R);
   778.
   779.    overriding
   780.    function "+" (L, R : CPU.f48)
   781.    return CPU.f48 is
   782.       -- B and D are made half of a true fraction to prevent overflow when
   783.       --    adding; the result exponent is offset by 1, accordingly.
   784.       A : constant KDF9.word := scaler(R);
   785.       B : KDF9.word := scale_down(fraction_word(R), 1);
   786.       C : constant KDF9.word := scaler(L);
   787.       D : KDF9.word := scale_down(fraction_word(L), 1);
   788.       E : KDF9.word;
   789.       F : KDF9.word;
   790.       N : Natural;
   791.    begin
   792.       if resign(A) >= resign(C) then
   793.          N := Natural'Min(Natural(resign(A-C)), 48);
   794.          D := scale_down_and_round(D, N);
   795.          E := A + 1;
   796.       else
   797.          N := Natural'Min(Natural(resign(C-A)), 48);
   798.          B := scale_down_and_round(B, N);
   799.          E := C + 1;
   800.       end if;
   801.       the_CPU_delta := the_CPU_delta + shift_time(N);
   802.       F := as_word(CPU.u_64(D + B));  -- "+" cannot overflow here.
   803.       return normalized(full_fraction => F, scaler => E);
   804.    end "+";
   805.
   806.    overriding
   807.    function "-" (L, R : CPU.f48)
   808.    return CPU.f48 is
   809.       -- See "+".
   810.       A : constant KDF9.word := scaler(R);
   811.       B : KDF9.word := scale_down(fraction_word(R), 1);
   812.       C : constant KDF9.word := scaler(L);
   813.       D : KDF9.word := scale_down(fraction_word(L), 1);
   814.       E : KDF9.word;
   815.       F : KDF9.word;
   816.       N : Natural;
   817.    begin
   818.       if resign(A) >= resign(C) then
   819.          N := Natural'Min(Natural(resign(A-C)), 48);
   820.          D := scale_down_and_round(D, N);
   821.          E := A + 1;
   822.       else
   823.          N := Natural'Min(Natural(resign(C-A)), 48);
   824.          B := scale_down_and_round(B, N);
   825.          E := C + 1;
   826.       end if;
   827.       the_CPU_delta := the_CPU_delta + shift_time(N);
   828.       F := as_word(CPU.u_64(D - B));  -- "-" cannot overflow here.
   829.       return normalized(full_fraction => F, scaler => E);
   830.    end "-";
   831.
   832.    overriding
   833.    function "*" (L, R : CPU.f48)
   834.    return CPU.f48 is
   835.       B, D, E, F : KDF9.word;
   836.    begin
   837.       if (KDF9.word(L) or KDF9.word(R)) = 0 then
   838.          return 0;
   839.       end if;
   840.       B := fraction_word(R);
   841.       D := fraction_word(L);
   842.       E := scaler(L) + scaler(R);
   843.       if (B = sign_bit) and (B = D) then
   844.           -- D*B = (+1), which is not a valid fraction, so treat specially.
   845.           B := B / 2;
   846.           D := D / 2;
   847.           E := E + 2;
   848.        end if;
   849.       F := as_word(as_fraction(D) * as_fraction(B));  -- "*" cannot overflow here.
   850.       return normalized(full_fraction => F, scaler => E);
   851.    end "*";
   852.
   853.    overriding
   854.    function "/" (L, R : CPU.f48)
   855.    return CPU.f48 is
   856.       D, N   : CPU.fraction;
   857.       Ls, Rs : KDF9.word;
   858.       E, F   : KDF9.word;
   859.    begin
   860.       if R = 0 then
   861.          the_V_bit_is_set := True;
   862.          return L;  -- ?? This result is not well defined in the Manual.
   863.       end if;
   864.       -- If L>=R, L/R>= 1, which is not a valid fraction; so Ls and Rs are
   865.       --    scaled so that the division cannot overflow.
   866.       Ls := scale_down(fraction_word(L), 3);
   867.       Rs := scale_down(fraction_word(R), 1);
   868.       N := abs as_fraction(Ls);  -- Ls is scaled down by 1/8, so "abs" cannot overflow.
   869.       D := abs as_fraction(Rs);  -- Rs is scaled down by 1/2, so "abs" cannot overflow.
   870.       -- E is increased by 2 to compensate the quotient's scaling by 1/4.
   871.       E := scaler(L) - scaler(R) + 2;
   872.       F := as_word(N / D);  -- "/" cannot overflow here.
   873.       if resign(KDF9.word(L) xor KDF9.word(R)) < 0 then
   874.          -- The result is negative.
   875.          F := -F;
   876.       end if;
   877.       return normalized(full_fraction => F, scaler => E);
   878.    end "/";
   879.
   880.    overriding
   881.    function "<" (L, R : CPU.f48)
   882.    return Boolean is
   883.       s : constant KDF9.word := KDF9.word(L) xor KDF9.word(R);
   884.    begin
   885.       if resign(s) < 0 then
   886.          -- The signs differ: L<R iff L is negative.
   887.          return resign(KDF9.word(L)) < 0;
   888.       elsif resign(KDF9.word(L)) < 0 then
   889.          -- L and R are both negative, so invert lexicographical order.
   890.          return not (KDF9.word(L) < KDF9.word(R));
   891.       else
   892.          -- L and R are both non-negative: so use lexicographical order.
   893.          return KDF9.word(L) < KDF9.word(R);
   894.       end if;
   895.    end "<";
   896.
   897.    function fraction_pair (DF : CPU.f96)
   898.    return KDF9.pair
   899.    is (scale_up((msw => scale_down(fraction_word(DF.msw), 8), lsw => fraction_word(DF.lsw)), 8));
   900.
   901.    function scaler (DF : CPU.f96)
   902.    return KDF9.word
   903.    is (scaler(DF.msw));
   904.
   905.    function narrowed (DF : CPU.f96)
   906.    return CPU.f48 is
   907.       fraction : KDF9.pair := fraction_pair(DF) + (0, 2**46);
   908.    begin
   909.       reconstruct(fraction, scaler(DF));
   910.       return CPU.f48(fraction.msw);
   911.    end narrowed;
   912.
   913.    procedure reconstruct (frac   : in out KDF9.pair;
   914.                           scaler : in KDF9.word) is
   915.       KDF9_exponent :  KDF9.word := scaler + 128;
   916.       normalizer    : Natural;
   917.    begin
   918.       if (frac.msw or frac.lsw) = 0 then
   919.          return; -- frac is already normalized.
   920.       end if;
   921.
   922.       normalizer := nr_leading_zeros(frac.msw);
   923.
   924.       if normalizer = 47 then  -- frac.msw is zero, so frac.lsw is non-zero.
   925.          normalizer := 47 + nr_leading_zeros(frac.lsw);
   926.       end if;
   927.
   928.       KDF9_exponent := KDF9_exponent - KDF9.word(normalizer);
   929.
   930.       frac := scale_up(frac, normalizer);
   931.       the_CPU_delta := the_CPU_delta + shift_time(normalizer);
   932.
   933.       -- 96-bit shift_arithmetic does not round and so cannot overflow here.
   934.       frac := scale_down(frac, 8);
   935.       frac.lsw := scale_down(frac.lsw, 8);
   936.       -- Clear both scaler fields.
   937.       frac.msw := frac.msw and mantissa_mask;
   938.       frac.lsw := frac.lsw and mantissa_mask;
   939.       if resign(KDF9_exponent) < 0 then
   940.          -- Deal with underflow.
   941.          frac := (0, 0);
   942.          return;
   943.       elsif KDF9_exponent > 255 then
   944.          -- Deal with overflow.
   945.          the_V_bit_is_set := True;
   946.          KDF9_exponent := 255;
   947.       end if;
   948.
   949.       frac.msw := frac.msw or shift_word_left(KDF9_exponent and 8#377#, 39);
   950.       if KDF9_exponent < 39 then
   951.          frac.lsw := 0;
   952.       else
   953.          frac.lsw := frac.lsw or shift_word_left((KDF9_exponent-39) and 8#377#, 39);
   954.       end if;
   955.    end reconstruct;
   956.
   957.    function "-" (R : CPU.f96)
   958.    return CPU.f96
   959.    is (CPU.f96'(0, 0) - R);
   960.
   961.    function "+" (L, R : CPU.f96)
   962.    return CPU.f96 is
   963.       -- Scale fractions to prevent overflow; must adjust exponent accordingly.
   964.       L_exponent : constant KDF9.word := scaler(L);
   965.       R_exponent : constant KDF9.word := scaler(R);
   966.       L_fraction : KDF9.pair := scale_down(fraction_pair(L), 1);
   967.       R_fraction : KDF9.pair := scale_down(fraction_pair(R), 1);
   968.       exponent   : KDF9.word;
   969.       the_result : KDF9.pair;
   970.       aligner    : Natural;
   971.    begin
   972.       if resign(R_exponent) >= resign(L_exponent) then
   973.          aligner := Natural(resign(R_exponent-L_exponent));
   974.          aligner := Natural'Min(95, aligner);
   975.          L_fraction := scale_down(L_fraction, aligner);
   976.          exponent := R_exponent + 1;
   977.       else
   978.          aligner := Natural(resign(L_exponent-R_exponent));
   979.          aligner := Natural'Min(95, aligner);
   980.          R_fraction := scale_down(R_fraction, aligner);
   981.          exponent := L_exponent + 1;
   982.       end if;
   983.       the_CPU_delta := the_CPU_delta + shift_time(aligner);
   984.       the_result := L_fraction + R_fraction;  -- "+" cannot overflow here.
   985.       reconstruct(the_result, scaler => exponent);
   986.       return as_f96(the_result);
   987.    end "+";
   988.
   989.    function "-" (L, R : CPU.f96)
   990.    return CPU.f96 is
   991.       -- See "+".
   992.       L_exponent : constant KDF9.word := scaler(L);
   993.       R_exponent : constant KDF9.word := scaler(R);
   994.       L_fraction : KDF9.pair := scale_down(fraction_pair(L), 1);
   995.       R_fraction : KDF9.pair := scale_down(fraction_pair(R), 1);
   996.       exponent   : KDF9.word;
   997.       the_result : KDF9.pair;
   998.       aligner    : Natural;
   999.    begin
  1000.       if resign(R_exponent) >= resign(L_exponent) then
  1001.          aligner := Natural(resign(R_exponent-L_exponent));
  1002.          aligner := Natural'Min(95, aligner);
  1003.          L_fraction := scale_down(L_fraction, aligner);
  1004.          exponent := R_exponent + 1;
  1005.       else
  1006.          aligner := Natural(resign(L_exponent-R_exponent));
  1007.          aligner := Natural'Min(95, aligner);
  1008.          R_fraction := scale_down(R_fraction, aligner);
  1009.          exponent := L_exponent + 1;
  1010.       end if;
  1011.       the_CPU_delta := the_CPU_delta + shift_time(aligner);
  1012.       the_result := L_fraction - R_fraction;  -- "-" cannot overflow here.
  1013.       reconstruct(the_result, scaler => exponent);
  1014.       return as_f96(the_result);
  1015.    end "-";
  1016.
  1017.    function "*" (L, R : CPU.f48)
  1018.    return CPU.f96 is
  1019.       V_was_set : constant Boolean := the_V_bit_is_set;
  1020.       LR        : KDF9.pair;
  1021.    begin
  1022.       the_V_bit_is_set := False;
  1023.       LR := fraction_word(L) * fraction_word(R);
  1024.       if the_V_bit_is_set then
  1025.          -- The product is not a valid fixed-point fraction, but is actually OK,
  1026.          --    so restore the orginal overflow state, and  ...
  1027.          the_V_bit_is_set := V_was_set;
  1028.          --  ... construct +1.0 in double-precision floating-point.
  1029.          return as_f96((shift_word_left(2#0_10_000_001_1#, 38), 0));
  1030.       end if;
  1031.       reconstruct(LR, scaler => scaler(L) + scaler(R));
  1032.       return as_f96(LR);
  1033.    end "*";
  1034.
  1035.    function "/" (L : CPU.f96;
  1036.                  R : CPU.f48)
  1037.    return CPU.f48 is  -- aka DIVDF
  1038.       -- If L>=R, L/R>= 1, which is not a valid fraction; so Ls and Rs are
  1039.       --    scaled so that the division cannot overflow.
  1040.       Ls     : constant KDF9.pair := scale_down(fraction_pair(L), 3);
  1041.       Rs     : constant KDF9.word := scale_down(fraction_word(R), 1);
  1042.       -- E is increased by 2 to compensate the quotient's scaling by 1/4.
  1043.       E      : constant KDF9.word := scaler(L) - scaler(R) + 2;
  1044.       F      : KDF9.word;
  1045.    begin
  1046.       if R = 0 then
  1047.          the_V_bit_is_set := True;
  1048.          return L.msw;  -- ?? This result is not well defined in the Manual.
  1049.       end if;
  1050.       do_DIVD(Ls, Rs, F);  -- Division cannot overflow here.
  1051.       return normalized(full_fraction => F, scaler => E);
  1052.    end "/";
  1053.
  1054.    procedure push (F : in CPU.f48) is
  1055.    begin
  1056.       push(KDF9.word(F));
  1057.    end push;
  1058.
  1059.    function pop
  1060.    return CPU.f48
  1061.    is (CPU.f48(KDF9.word'(pop)));
  1062.
  1063.    function read_top
  1064.    return CPU.f48
  1065.    is (CPU.f48(KDF9.word'(read_top)));
  1066.
  1067.    procedure write_top (F : in CPU.f48) is
  1068.    begin
  1069.       write_top(KDF9.word(F));
  1070.    end write_top;
  1071.
  1072.    procedure push (DF : in CPU.f96) is
  1073.       AB : constant KDF9.pair := as_pair(DF);
  1074.    begin
  1075.       push(AB);
  1076.    end push;
  1077.
  1078.    function pop
  1079.    return CPU.f96
  1080.    is (as_f96(pop));
  1081.
  1082.    function read_top
  1083.    return CPU.f96
  1084.    is (as_f96(read_top));
  1085.
  1086.    procedure write_top (DF : in CPU.f96) is
  1087.       AB : constant KDF9.pair := as_pair(DF);
  1088.    begin
  1089.       write_top(AB);
  1090.    end write_top;
  1091.
  1092. end KDF9.CPU;

Compiling: ../Source/kdf9-cpu.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:26

     1. -- kdf9-cpu.ads
     2. --
     3. -- Support for KDF9 CPU/ALU operations that are not automatically inherited from
     4. --   Ada types; and for types used in the internal functioning of the microcode.
     5. --
     6. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     7. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     8. --
     9. -- The ee9 program is free software; you can redistribute it and/or
    10. -- modify it under terms of the GNU General Public License as published
    11. -- by the Free Software Foundation; either version 3, or (at your option)
    12. -- any later version. This program is distributed in the hope that it
    13. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    14. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    15. -- See the GNU General Public License for more details. You should have
    16. -- received a copy of the GNU General Public License distributed with
    17. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    18. --
    19.
    20. with Ada.Unchecked_Conversion;
    21.
    22. package KDF9.CPU is
    23.
    24. --
    25. --
    26.    --
    27.    -- 48-bit integer and fractional ALU types and operations
    28.    --
    29. --
    30. --
    31.
    32.    type signed is range -2**47 .. +2**47 - 1 with Size => KDF9.word'Size;
    33.
    34.    function unsign is new Ada.Unchecked_Conversion (CPU.signed, KDF9.word);
    35.
    36.    function resign is new Ada.Unchecked_Conversion (KDF9.word, CPU.signed);
    37.
    38.    function "-" (I : CPU.signed)
    39.    return KDF9.word
    40.       with Inline;
    41.
    42.    function "abs" (I : CPU.signed)
    43.    return KDF9.word
    44.       with Inline;
    45.
    46.    function "+" (L, R : CPU.signed)
    47.    return KDF9.word
    48.       with Inline;
    49.
    50.    function "-" (L, R : CPU.signed)
    51.    return KDF9.word
    52.       with Inline;
    53.
    54.    function "*" (L, R : CPU.signed)
    55.    return KDF9.word;
    56.
    57.    -- Determine the Quotient and Remainder of L/R, where:
    58.    --    sign(Remainder) = sign(R) and |Remainder| < |R|, i.e. Remainder = L mod R;
    59.    --    Quotient = (L - Remainder) / R.
    60.
    61.    procedure do_DIVI (L : in KDF9.word;
    62.                       R : in KDF9.word;
    63.                       Quotient, Remainder : out KDF9.word);
    64.
    65.    -- Signed single-length integer substrate division is removed from consideration.
    66.
    67.    function "/" (L, R : CPU.signed)
    68.    return KDF9.word is abstract;
    69.
    70.    function "mod" (L, R : CPU.signed)
    71.    return KDF9.word is abstract;
    72.
    73.    -- Contract a double-word, setting the V bit if necessary.
    74.
    75.    function contracted (P : KDF9.pair)
    76.    return KDF9.word
    77.       with Inline;
    78.
    79.    -- Contract a double-word, represented by its components, setting the V bit if necessary.
    80.
    81.    function contracted (msw, lsw : KDF9.word)
    82.    return KDF9.word
    83.       with Inline;
    84.
    85. --
    86. --
    87.    -- Shifting operations with KDF9 semantics.
    88. --
    89. --
    90.
    91.    type signed_Q_part is range  -2**15 .. +2**15 - 1 with Size => KDF9.Q_part'Size;
    92.
    93.    function resign is new Ada.Unchecked_Conversion (KDF9.Q_part, CPU.signed_Q_part);
    94.
    95.    -- L>0 for left-shift, L<0 for right-shift.
    96.
    97.    function shift_logical (W : KDF9.word; L : CPU.signed_Q_part)
    98.    return KDF9.word
    99.       with Inline;
   100.
   101.    function shift_circular (W : KDF9.word; L : CPU.signed_Q_part)
   102.    return KDF9.word
   103.       with Inline;
   104.
   105.    -- shift_arithmetic rounds the result correctly.
   106.    function shift_arithmetic (I : KDF9.word; L : CPU.signed_Q_part)
   107.    return KDF9.word
   108.       with Inline;
   109.
   110.    -- cardinality yields the number of 1-bits in W.
   111.    function cardinality (W : KDF9.word)
   112.    return KDF9.word
   113.       with Inline;
   114.
   115. --
   116. --
   117.    -- A fraction is a word W interpreted as the value W / 2**47;
   118. --
   119. --
   120.
   121.    KDF9_small : constant := 2.0**(-47);
   122.
   123.    type fraction is delta KDF9_small range -1.0 .. +1.0 - KDF9_small with Size => KDF9.word'Size;
   124.
   125.    function as_fraction is new Ada.Unchecked_Conversion (KDF9.word, CPU.fraction);
   126.
   127.    function as_word     is new Ada.Unchecked_Conversion (CPU.fraction, KDF9.word);
   128.
   129.    -- These operations treat the KDF9.word operands as full-word fractions,
   130.
   131.    function "*" (L, R : KDF9.word)
   132.    return CPU.fraction;
   133.
   134.    function "/" (L, R : KDF9.word)
   135.    return CPU.fraction;
   136.
   137.
   138. --
   139. --
   140.    --
   141.    -- 48-bit integer and fractional ALU operations
   142.    --
   143. --
   144. --
   145.
   146.    function "+" (L, R : KDF9.pair)
   147.    return KDF9.pair
   148.       with Inline;
   149.
   150.    function "-" (J : KDF9.pair)
   151.    return KDF9.pair
   152.       with Inline;
   153.
   154.    function "-" (L, R : KDF9.pair)
   155.    return KDF9.pair
   156.       with Inline;
   157.
   158.    -- 48 * 48 -> 96-bit, for XD, etc.
   159.
   160.    function "*" (L, R : KDF9.word)
   161.    return KDF9.pair;
   162.
   163.    -- 96 / 48 -> 48-bit, for DIVD, DIVR and DIVDF.
   164.
   165.    procedure do_DIVD (L : in KDF9.pair;
   166.                       R : in KDF9.word;
   167.                       Q : out KDF9.word
   168.                      );
   169.
   170.    procedure do_DIVR (L : in KDF9.pair;
   171.                       R : in KDF9.word;
   172.                       Quotient,
   173.                       Remainder : out KDF9.word
   174.                      );
   175.
   176.    function shift_logical (P : KDF9.pair; L : CPU.signed_Q_part)
   177.    return KDF9.pair
   178.       with Inline;
   179.
   180.    function shift_arithmetic (P : KDF9.pair; L : CPU.signed_Q_part)
   181.    return KDF9.pair
   182.       with Inline;
   183.
   184.
   185. --
   186. --
   187.    --
   188.    -- 48-bit floating point ALU types and operations
   189.    --
   190. --
   191. --
   192.
   193.    -- This is a substrate for KDF9 floating point, not an Ada f.p. type.
   194.
   195.    type f48 is mod 2**48 with Size => KDF9.word'Size;
   196.
   197.    -- Remove useless substrate modular operations not, and, or, xor and mod.
   198.
   199.    overriding
   200.    function "not" (R : CPU.f48)
   201.    return CPU.f48 is abstract;
   202.
   203.    overriding
   204.    function "and" (L, R : CPU.f48)
   205.    return CPU.f48 is abstract;
   206.
   207.    overriding
   208.    function "or" (L, R : CPU.f48)
   209.    return CPU.f48 is abstract;
   210.
   211.    overriding
   212.    function "xor" (L, R : CPU.f48)
   213.    return CPU.f48 is abstract;
   214.
   215.    overriding
   216.    function "mod" (L, R : CPU.f48)
   217.    return CPU.f48 is abstract;
   218.
   219.    function as_word is new Ada.Unchecked_Conversion (CPU.f48, KDF9.word);
   220.
   221.    function as_f48  is new Ada.Unchecked_Conversion (KDF9.word, CPU.f48);
   222.
   223.    procedure push (F : in CPU.f48);
   224.
   225.    function pop
   226.    return CPU.f48
   227.       with Inline;
   228.
   229.    procedure write_top (F : in CPU.f48)
   230.       with Inline;
   231.
   232.    function read_top
   233.    return CPU.f48
   234.       with Inline;
   235.
   236.     -- Standardize a (possibly) non-normalized floating-point number.
   237.
   238.    function normalized  (R : CPU.f48)
   239.    return CPU.f48;
   240.
   241.    -- Convert a 47-bit fraction to a rounded, standardized 39-bit mantissa,
   242.    --    and adjust its exponent accordingly, setting overflow when necessary.
   243.
   244.    procedure normalize (fraction, exponent : in out KDF9.word)
   245.       with Inline;
   246.
   247.    -- Convert a 39-bit mantissa to a 47-bit fraction, preserving the sign.
   248.
   249.    function fraction_word (mantissa : CPU.f48)
   250.    return KDF9.word
   251.       with Inline;
   252.
   253.    -- The floating-point number with the exponent field set to 0.
   254.
   255.    function masked_mantissa (F : CPU.f48)
   256.    return CPU.f48
   257.       with Inline;
   258.
   259.    -- The algebraic scale-factor, not the hardware exponent, -128 <= scaler < +128.
   260.
   261.    function scaler (F : CPU.f48)
   262.    return KDF9.word
   263.       with Inline;
   264.
   265.     -- Synthesize a normalized floating-point number from its components.
   266.
   267.    function normalized (full_fraction, scaler : KDF9.word)
   268.    return CPU.f48
   269.       with Inline;
   270.
   271.    -- Round a 48-bit floating-point number to 24-bit format.
   272.
   273.    function narrowed (R : CPU.f48)
   274.    return CPU.f48;
   275.
   276.    overriding
   277.    function "-" (R : CPU.f48)
   278.    return CPU.f48;
   279.
   280.    overriding
   281.    function "abs" (R : CPU.f48)
   282.    return CPU.f48;
   283.
   284.    overriding
   285.    function "+" (L, R : CPU.f48)
   286.    return CPU.f48;
   287.
   288.    overriding
   289.    function "-" (L, R : CPU.f48)
   290.    return CPU.f48;
   291.
   292.    overriding
   293.    function "*" (L, R : CPU.f48)
   294.    return CPU.f48;
   295.
   296.    overriding
   297.    function "/" (L, R : CPU.f48)
   298.    return CPU.f48;
   299.
   300.    overriding
   301.    function "<" (L, R : CPU.f48)
   302.    return Boolean;
   303.
   304.    function host_float (X : CPU.f48)
   305.    return Long_Float;
   306.
   307.    exponent_mask : constant KDF9.word := KDF9.word'(2#11_111_111#) * 2**39;
   308.    mantissa_mask : constant KDF9.word := not exponent_mask;
   309.    frac_msb_mask : constant KDF9.word := 2**46;  -- M.S.B. of a 47-bit fraction
   310.    mant_msb_mask : constant KDF9.word := 2**38;  -- M.S.B. of a 39-bit mantissa
   311.    overflow_mask : constant KDF9.word := 2**39;  -- bit set on rounding overflow
   312.
   313.
   314. --
   315. --
   316.    --
   317.    -- 96-bit floating point ALU types and operations
   318.    --
   319. --
   320. --
   321.
   322.    type f96 is
   323.       record
   324.          msw, lsw : CPU.f48;
   325.       end record;
   326.
   327.    function as_pair is new Ada.Unchecked_Conversion (CPU.f96, KDF9.pair);
   328.
   329.    function as_f96  is new Ada.Unchecked_Conversion (KDF9.pair, CPU.f96);
   330.
   331.    procedure push (DF : in CPU.f96)
   332.       with Inline,
   333.            Pre => the_nest_depth < 15
   334.                or else the_CPU_state = Director_state;
   335.
   336.    function pop
   337.    return CPU.f96
   338.       with Inline;
   339.
   340.    procedure write_top (DF : in CPU.f96)
   341.       with Inline;
   342.
   343.    function read_top
   344.    return CPU.f96
   345.       with Inline;
   346.
   347.    -- The algebraic scale-factor, not the hardware exponent, -128 <= scaler < +128.
   348.
   349.    function scaler (DF : CPU.f96)
   350.    return KDF9.word
   351.       with Inline;
   352.
   353.    -- Round a 96-bit double-precision floating-point number to 48 bit format.
   354.
   355.    function narrowed (DF : CPU.f96)
   356.    return CPU.f48
   357.       with Inline;
   358.
   359.    -- Derive a 96-bit fraction from the double-precision floating-point number,
   360.    --    with the mantissa bits in D9-D47 and D49-D87,
   361.    --       and with D1-D8 copies of the sign, D48 zero, and D87-D95 zero.
   362.
   363.    function fraction_pair (DF : CPU.f96)
   364.    return KDF9.pair
   365.       with Inline;
   366.
   367.    -- Convert 96-bit fraction, and an algebraic scale-factor exponent,
   368.    --    into a 96-bit floating point number, setting overflow when necessary.
   369.
   370.    procedure reconstruct (frac   : in out KDF9.pair;
   371.                           scaler : in KDF9.word);
   372.
   373.    function "-" (R : CPU.f96)
   374.    return CPU.f96;
   375.
   376.    function "+" (L, R : CPU.f96)
   377.    return CPU.f96;
   378.
   379.    function "-" (L, R : CPU.f96)
   380.    return CPU.f96;
   381.
   382.    function "*" (L, R : CPU.f48)
   383.    return CPU.f96;
   384.
   385.    function "/" (L : CPU.f96;
   386.                  R : CPU.f48)
   387.    return CPU.f48;
   388.
   389. ------------------------------------------------------------------------------------------------
   390.
   391. --
   392. --
   393.    --
   394.    -- These are the emulation host's register types and their operations.
   395.    --
   396. --
   397. --
   398.
   399.    type u_64 is mod 2**64 with Size => 64;
   400.
   401.    pragma Provide_Shift_Operators (u_64);
   402.
   403.    function as_word (u : CPU.u_64)
   404.    return KDF9.word
   405.       with Inline;
   406.
   407.    type s_64 is range -2**63 .. +2**63-1 with Size => 64;
   408.
   409.    -- The signed as_word sets the V bit if necessary.
   410.
   411.    function as_word (s : CPU.s_64)
   412.    return KDF9.word
   413.       with Inline;
   414.
   415.    function unsign is new Ada.Unchecked_Conversion(CPU.s_64, CPU.u_64);
   416.
   417.    function resign is new Ada.Unchecked_Conversion(CPU.u_64, CPU.s_64);
   418.
   419. --
   420. --
   421.    --
   422.    -- These are the 48-bit primitive, fixed-direction, shift operations.
   423.    --
   424. --
   425. --
   426.
   427.    function shift_time (amount : Natural)
   428.    return KDF9.us
   429.       with Inline;
   430.
   431.    subtype word_shift_length is Natural range 0..48;
   432.
   433.    function shift_word_left (W : KDF9.word; amount : word_shift_length)
   434.    return KDF9.word
   435.       with Inline;
   436.
   437.    function shift_word_right (W : KDF9.word; amount : word_shift_length)
   438.    return KDF9.word
   439.       with Inline;
   440.
   441.    function rotate_word_left (W : KDF9.word; amount : word_shift_length)
   442.    return KDF9.word
   443.       with Inline;
   444.
   445.    function rotate_word_right (W : KDF9.word; amount : word_shift_length)
   446.    return KDF9.word
   447.       with Inline;
   448.
   449.    -- scale_up may set the V bit.
   450.
   451.    function scale_up (W : KDF9.word; amount : Natural)
   452.    return KDF9.word
   453.       with Inline;
   454.
   455.    -- scale_down_and_round rounds correctly.
   456.
   457.    function scale_down_and_round (W : KDF9.word; amount : Natural)
   458.    return KDF9.word
   459.       with Inline;
   460.
   461.    -- scale_down never rounds.
   462.
   463.    function scale_down (W : KDF9.word; amount : Natural)
   464.    return KDF9.word
   465.       with Inline;
   466.
   467. end KDF9.CPU;

 1092 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/kdf9-phu_store.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:27

     1. -- kdf9-PHU_store.adb
     2. --
     3. -- The K5 operation data formats.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Unchecked_Conversion;
    20. --
    21. with KDF9.CPU;
    22.
    23. package body KDF9.PHU_store is
    24.
    25.    function short_PHU (p : KDF9.priority)
    26.    return KDF9.word is
    27.
    28.       use type KDF9.store.group_address;
    29.
    30.       type PHU_as_6_bits is mod 2**6
    31.          with Size => 6;
    32.
    33.       function as_6_bits is new Ada.Unchecked_Conversion(Source => PHU_store.PHU_subset,
    34.                                                          Target => short_PHU.PHU_as_6_bits);
    35.
    36.       the_reason    : PHU_store.blockage_kind;
    37.       the_parameter : KDF9.buffer_number;
    38.
    39.    begin
    40.       if not PHU(p).is_held_up then
    41.          return 0;  -- All fields are non-significant.
    42.       end if;
    43.
    44.       -- PHU(p).is_held_up, so other fields are valid.
    45.       the_reason := PHU(p).blockage.reason;
    46.       if the_reason = buffer_busy then
    47.          the_parameter := PHU(p).blockage.buffer_nr;
    48.       else
    49.          -- This is next to useless, but is what the K5 order actually did.
    50.          the_parameter := KDF9.buffer_number(PHU(p).blockage.group_nr mod 2**4);
    51.       end if;
    52.
    53.       return KDF9.word(as_6_bits((the_parameter, the_reason, True)));
    54.    end short_PHU;
    55.
    56.    function K5_operand
    57.    return KDF9.word
    58.    is (
    59.        KDF9.CPU.shift_word_left(short_PHU(0), 48-06) or
    60.        KDF9.CPU.shift_word_left(short_PHU(1), 48-12) or
    61.        KDF9.CPU.shift_word_left(short_PHU(2), 48-18) or
    62.        KDF9.CPU.shift_word_left(short_PHU(3), 48-24)
    63.       );
    64.
    65. end KDF9.PHU_store;

Compiling: ../Source/kdf9-phu_store.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:27

     1. -- kdf9-PHU_store.ads
     2. --
     3. -- The K5 operation data formats.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with System;
    20. --
    21. with KDF9.store;
    22.
    23. package KDF9.PHU_store is
    24.
    25.    -- PHU, the Program Hold-Up register is internal to I/O Control.
    26.    -- It has one element for each of the 4 program priority levels, 0..3.
    27.    -- A subset of its content is exposed to Director by means of the K5 order.
    28.
    29.    type blockage_kind is (buffer_busy, locked_core) with Size => 1;
    30.
    31.    type PHU_reason (reason : PHU_store.blockage_kind := buffer_busy) is
    32.       record
    33.          case reason is
    34.             when buffer_busy =>
    35.                buffer_nr : KDF9.buffer_number;
    36.                by_INTQq  : Boolean;
    37.             when locked_core =>
    38.                group_nr  : KDF9.store.group_address;
    39.          end case;
    40.       end record;
    41.
    42.    type PHU_register (is_held_up : Boolean := False) is
    43.       record
    44.          case is_held_up is
    45.             when False =>
    46.                null;
    47.             when True =>
    48.                blockage : PHU_reason;
    49.          end case;
    50.       end record;
    51.
    52.    idle_PHU : constant PHU_register := (is_held_up => False);
    53.
    54.    PHU : array (KDF9.priority) of PHU_store.PHU_register := (others => idle_PHU);
    55.
    56.    type PHU_subset is
    57.       record
    58.          parameter  : KDF9.buffer_number;
    59.          reason     : PHU_store.blockage_kind;
    60.          is_held_up : Boolean;
    61.       end record
    62.    with Size => 6, Bit_Order => System.Low_Order_First;
    63.
    64.    for  PHU_subset use
    65.       record
    66.          parameter  at 0 range 0 .. 3;
    67.          reason     at 0 range 4 .. 4;
    68.          is_held_up at 0 range 5 .. 5;
    69.       end record;
    70.
    71.    -- A K5_operand is a KDF9 word, D00-D47, with the content:
    72.    --    PHU_subset(0) in D00 .. D05
    73.    --    PHU_subset(1) in D06 .. D11
    74.    --    PHU_subset(2) in D12 .. D17
    75.    --    PHU_subset(3) in D18 .. D23
    76.    --    zeros         in D24 .. D47
    77.
    78.    function K5_operand
    79.    return KDF9.word;
    80.
    81. end KDF9.PHU_store;

 65 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/tracing.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:27

     1. -- tracing.adb
     2. --
     3. -- Provide diagnostic trace, breakpoint, and watchpoint support.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with exceptions;
    20. with formatting;
    21. with HCI;
    22. with KDF9.decoding;
    23. with KDF9.store;
    24. with state_display;
    25.
    26. use exceptions;
    27. use formatting;
    28. use HCI;
    29. use KDF9;
    30. use KDF9.decoding;
    31. use KDF9.store;
    32. use state_display;
    33.
    34. package body tracing is
    35.
    36.    procedure clear_the_histogram is
    37.    begin
    38.       the_histogram := (others => 0);
    39.    end clear_the_histogram;
    40.
    41.    procedure clear_the_profile is
    42.    begin
    43.       the_profile := (others => 0);
    44.    end clear_the_profile;
    45.
    46.    procedure set_breakpoints (first, last : in KDF9.order_word_number) is
    47.    begin
    48.       for p in first .. last loop
    49.          breakpoints(p) := True;
    50.       end loop;
    51.    end set_breakpoints;
    52.
    53.    procedure handle_breakpoint is
    54.    begin
    55.       short_witness;
    56.       interact;
    57.       quit_if_requested;
    58.       change_diagnostic_mode_if_requested;
    59.    end handle_breakpoint;
    60.
    61.    procedure clear_all_watchpoints is
    62.    begin
    63.       fetchpoints := (others => False);
    64.       storepoints := (others => False);
    65.    end clear_all_watchpoints;
    66.
    67.    procedure set_fetch_points (first, last : in KDF9.address) is
    68.    begin
    69.       for p in first .. last loop
    70.          fetchpoints(p) := True;
    71.       end loop;
    72.    end set_fetch_points;
    73.
    74.    procedure set_store_points (first, last : in KDF9.address) is
    75.    begin
    76.       for p in first .. last loop
    77.          storepoints(p) := True;
    78.       end loop;
    79.    end set_store_points;
    80.
    81.    procedure clear_retro_FIFO is
    82.    begin
    83.       retro_FIFO_count := 0; retro_FIFO_index := 0;
    84.    end clear_retro_FIFO;
    85.
    86.    procedure take_note_of (the_IAR   : in KDF9.syllable_address;
    87.                            the_value : in KDF9.word) is
    88.    begin
    89.       if the_retrospective_trace_is_enabled           and then
    90.             ICR in low_count .. high_count            and then
    91.                NIA_word_number in low_bound .. high_bound then
    92.          declare
    93.             the_note : constant retro_FIFO_entry
    94.                      := (
    95.                          location   => the_IAR,
    96.                          order      => INS.order,
    97.                          parameter  => the_value,
    98.                          ICR_value  => ICR,
    99.                          CPU_time   => the_CPU_time,
   100.                          nested     => the_nest_depth,
   101.                          called     => the_sjns_depth,
   102.                          V          => the_V_bit_is_set,
   103.                          T          => the_T_bit_is_set,
   104.                          D          => the_CPU_state = Director_state,
   105.                          level      => CPL
   106.                         );
   107.          begin
   108.             if retro_FIFO_count = 0 then
   109.                retro_FIFO(0) := the_note;
   110.                retro_FIFO_count := 1;
   111.             else
   112.                retro_FIFO_index := retro_FIFO_index + 1;
   113.                retro_FIFO(retro_FIFO_index) := the_note;
   114.                if retro_FIFO_count < FIFO_size then
   115.                   retro_FIFO_count := retro_FIFO_count + 1;
   116.                end if;
   117.             end if;
   118.          end;
   119.       end if;
   120.    end take_note_of;
   121.
   122.    procedure take_note_of (the_value : in KDF9.word) is
   123.    begin
   124.       take_note_of(CIA, the_value);
   125.    end take_note_of;
   126.
   127.    procedure clear_IOC_FIFO is
   128.    begin
   129.       IOC_FIFO_count := 0; IOC_FIFO_index := 0;
   130.    end clear_IOC_FIFO;
   131.
   132.    procedure register_IO_event (the_note : in IOC_FIFO_entry) is
   133.    begin
   134.       if the_peripheral_trace_is_enabled              and then
   135.             ICR in low_count .. high_count            and then
   136.                NIA_word_number in low_bound .. high_bound then
   137.          if IOC_FIFO_count = 0 then
   138.             IOC_FIFO(0) := the_note;
   139.             IOC_FIFO_count := 1;
   140.          else
   141.             IOC_FIFO_index := IOC_FIFO_index + 1;
   142.             IOC_FIFO(IOC_FIFO_index) := the_note;
   143.             if IOC_FIFO_count < FIFO_size then
   144.                IOC_FIFO_count := IOC_FIFO_count + 1;
   145.             end if;
   146.          end if;
   147.       end if;
   148.    end register_IO_event;
   149.
   150.    procedure take_note_of_IO_start (
   151.                                     device_name     : in IOC.device_name;
   152.                                     completion_time : in KDF9.us;
   153.                                     control_word    : in KDF9.Q_register;
   154.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   155.                                    )
   156.    is
   157.       the_note : constant  IOC_FIFO_entry
   158.                :=
   159.                 (
   160.                  kind            => start_transfer,
   161.                  ICR_value       => ICR,
   162.                  order_address   => CIA,
   163.                  decoded_order   => INS,
   164.                  initiation_time => the_clock_time,
   165.                  device_name     => take_note_of_IO_start.device_name,
   166.                  completion_time => take_note_of_IO_start.completion_time,
   167.                  is_for_Director => (the_CPU_state = Director_state),
   168.                  priority_level  => CPL,
   169.                  context         => the_context,
   170.                  control_word    => take_note_of_IO_start.control_word,
   171.                  operation       => take_note_of_IO_start.operation
   172.                 );
   173.    begin
   174.       register_IO_event(the_note);
   175.    end take_note_of_IO_start;
   176.
   177.    procedure take_note_of_IO_finis (
   178.                                     ICR_value       : in KDF9.order_counter;
   179.                                     order_address   : in KDF9.syllable_address;
   180.                                     decoded_order   : in KDF9.decoded_order;
   181.                                     initiation_time : in KDF9.us;
   182.                                     device_name     : in IOC.device_name;
   183.                                     is_for_Director : Boolean;
   184.                                     priority_level  : in KDF9.priority;
   185.                                     completion_time : in KDF9.us;
   186.                                     control_word    : in KDF9.Q_register;
   187.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   188.                                    )
   189.    is
   190.       the_note : constant  IOC_FIFO_entry
   191.                :=
   192.                 (
   193.                  kind            => finis_transfer,
   194.                  ICR_value       => take_note_of_IO_finis.ICR_value,
   195.                  order_address   => take_note_of_IO_finis.order_address,
   196.                  decoded_order   => take_note_of_IO_finis.decoded_order,
   197.                  initiation_time => take_note_of_IO_finis.initiation_time,
   198.                  device_name     => take_note_of_IO_finis.device_name,
   199.                  is_for_Director => take_note_of_IO_finis.is_for_Director,
   200.                  priority_level  => take_note_of_IO_finis.priority_level,
   201.                  context         => the_context,
   202.                  completion_time => take_note_of_IO_finis.completion_time,
   203.                  control_word    => take_note_of_IO_finis.control_word,
   204.                  operation       => take_note_of_IO_finis.operation
   205.                 );
   206.
   207.    begin
   208.       register_IO_event(the_note);
   209.    end take_note_of_IO_finis;
   210.
   211.    procedure take_note_of_store_lockout (device_name : in IOC.device_name) is
   212.       the_note : constant  IOC_FIFO_entry
   213.                :=
   214.                 (
   215.                  kind            => store_lockout,
   216.                  ICR_value       => ICR,
   217.                  order_address   => CIA,
   218.                  decoded_order   => INS,
   219.                  initiation_time => the_clock_time,
   220.                  device_name     => take_note_of_store_lockout.device_name,
   221.                  is_for_Director => False,
   222.                  priority_level  => CPL,
   223.                  context         => the_context,
   224.                  data_address    => the_locked_out_address,
   225.                  operation       => IOC.some_other_operation
   226.                 );
   227.    begin
   228.       register_IO_event(the_note);
   229.    end take_note_of_store_lockout;
   230.
   231.    procedure take_note_of_buffer_lockout (device_name : in IOC.device_name;
   232.                                           operation   : in IOC.transfer_kind := IOC.some_other_operation) is
   233.       the_note : constant  IOC_FIFO_entry
   234.                :=
   235.                 (
   236.                  kind            => buffer_lockout,
   237.                  ICR_value       => ICR,
   238.                  order_address   => CIA,
   239.                  decoded_order   => INS,
   240.                  initiation_time => the_clock_time,
   241.                  device_name     => take_note_of_buffer_lockout.device_name,
   242.                  is_for_Director => False,
   243.                  priority_level  => CPL,
   244.                  context         => the_context,
   245.                  operation       => take_note_of_buffer_lockout.operation
   246.                 );
   247.    begin
   248.       register_IO_event(the_note);
   249.    end take_note_of_buffer_lockout;
   250.
   251.    procedure take_note_of_test (
   252.                                 device_name : in IOC.device_name;
   253.                                 Q_register  : in KDF9.Q_register;
   254.                                 status      : in Boolean
   255.                                )
   256.    is
   257.       the_note : constant  IOC_FIFO_entry
   258.                :=
   259.                 (
   260.                  kind            => buffer_status,
   261.                  ICR_value       => ICR+1,  -- ICR is not incremented until the end of an order.
   262.                  order_address   => CIA,
   263.                  decoded_order   => INS,
   264.                  initiation_time => the_clock_time,
   265.                  device_name     => take_note_of_test.device_name,
   266.                  is_for_Director => (the_CPU_state = Director_state),
   267.                  priority_level  => CPL,
   268.                  context         => the_context,
   269.                  Q_register      => take_note_of_test.Q_register,
   270.                  status          => take_note_of_test.status,
   271.                  operation       => IOC.some_other_operation
   272.                 );
   273.    begin
   274.       register_IO_event(the_note);
   275.    end take_note_of_test;
   276.
   277.    procedure clear_interrupt_FIFO is
   278.    begin
   279.       interrupt_FIFO_count := 0; interrupt_FIFO_index := 0;
   280.    end clear_interrupt_FIFO;
   281.
   282.    procedure take_note_of_interrupt (interrupt_code : in KDF9.interrupt_number; message : in String)
   283.    is
   284.       length : constant Natural := message'Length;
   285.       memo   : String(1..max_interrupt_message_length) := (others => ' ');
   286.    begin
   287.       if length > max_interrupt_message_length then
   288.          raise emulation_failure with "interrupt message too long: '" & message & "'" & length'Image;
   289.       end if;
   290.       memo(1..length) := message;
   291.       declare
   292.          the_note : constant interrupt_FIFO_entry
   293.                   :=
   294.                    (
   295.                     interrupt_code => take_note_of_interrupt.interrupt_code,
   296.                     ICR_value      => ICR,
   297.                     order_address  => CIA,
   298.                     busy_time      => the_clock_time,
   299.                     priority_level => CPL,
   300.                     context        => the_context,
   301.                     message        => memo
   302.                    );
   303.       begin
   304.          if the_interrupt_trace_is_enabled               and then
   305.                ICR in low_count .. high_count            and then
   306.                   NIA_word_number in low_bound .. high_bound then
   307.             if interrupt_FIFO_count = 0 then
   308.                interrupt_FIFO(0) := the_note;
   309.                interrupt_FIFO_count := 1;
   310.             else
   311.                interrupt_FIFO_index := interrupt_FIFO_index + 1;
   312.                interrupt_FIFO(interrupt_FIFO_index) := the_note;
   313.                if interrupt_FIFO_count < FIFO_size then
   314.                   interrupt_FIFO_count := interrupt_FIFO_count + 1;
   315.                end if;
   316.             end if;
   317.          end if;
   318.       end;
   319.    end take_note_of_interrupt;
   320.
   321.    procedure add_INS_to_the_histogram is
   322.       syllable_0 : KDF9.syllable := INS.order.syllable_0;
   323.    begin
   324.       if INS.kind = normal_jump_order then
   325.          syllable_0 := (syllable_0 and 2#1111_0000#) or INS.Qq;
   326.       elsif INS.kind = data_access_order then
   327.          syllable_0 := (syllable_0 and 2#11_000_111#);
   328.       end if;
   329.       the_histogram(syllable_0) := the_histogram(syllable_0) + 1;
   330.    end add_INS_to_the_histogram;
   331.
   332.    procedure add_CIA_to_the_profile is
   333.    begin
   334.       the_profile(CIA.order_word_number) := the_profile(CIA.order_word_number) + 1;
   335.    end add_CIA_to_the_profile;
   336.
   337.    procedure preview_a_one_syllable_order is null;
   338.
   339.    procedure preview_a_two_syllable_order is
   340.    begin
   341.       case INS.compressed_opcode is
   342.          when TO_MkMq
   343.             | TO_MkMqQ
   344.             | TO_MkMqH
   345.             | TO_MkMqQH
   346.             | TO_MkMqN
   347.             | TO_MkMqQN
   348.             | TO_MkMqHN
   349.             | TO_MkMqQHN =>
   350.             the_trace_operand := read_top;
   351.          when others =>
   352.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   353.       end case;
   354.    end preview_a_two_syllable_order;
   355.
   356.    procedure preview_a_jump_order is
   357.    begin
   358.       case INS.compressed_opcode is
   359.          when JrEQ
   360.             | JrNE
   361.             | JrGTZ
   362.             | JrLTZ
   363.             | JrEQZ
   364.             | JrLEZ
   365.             | JrGEZ
   366.             | JrNEZ
   367.             | OS_OUT =>
   368.             if the_nest_depth > 0 then
   369.                the_trace_operand := read_top;
   370.             end if;
   371.          when JrEN
   372.             | JrNEN =>
   373.             the_trace_operand := KDF9.word(the_nest_depth);
   374.          when JrEJ
   375.             | JrNEJ =>
   376.             the_trace_operand := KDF9.word(the_sjns_depth);
   377.          when EXIT_n
   378.             | EXITD =>
   379.             if the_sjns_depth > 0 then
   380.                the_trace_operand := as_word(sjns_top);
   381.             else
   382.                the_trace_operand := -1;
   383.             end if;
   384.          when JrCqZ
   385.             | JrCqNZ =>
   386.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   387.          when JrV
   388.             | JrNV =>
   389.             the_trace_operand := (if the_V_bit_is_set then 1 else 0);
   390.          when JrTR
   391.             | JrNTR =>
   392.             the_trace_operand := (if the_T_bit_is_set then 1 else 0);
   393.          when others =>
   394.             null;
   395.       end case;
   396.    end preview_a_jump_order;
   397.
   398.    procedure preview_a_data_access_order is
   399.    begin
   400.       case INS.compressed_opcode is
   401.          when TO_EaMq
   402.             | TO_EaMqQ =>
   403.             the_trace_operand := read_top;
   404.          when others =>
   405.             null;
   406.       end case;
   407.    end preview_a_data_access_order;
   408.
   409.    procedure look_back_at_a_one_syllable_order is
   410.       AB : KDF9.pair;
   411.    begin
   412.       case INS.compressed_opcode is
   413.          when XDF
   414.             | XPLUSF
   415.             | MINUSDF
   416.             | PLUSDF
   417.             | FLOATD
   418.             | NEGDF
   419.             | MAXF
   420.             | PERM
   421.             | CAB
   422.             | MAX
   423.             | XD
   424.             | NEGD
   425.             | DUPD
   426.             | DIVI
   427.             | STR
   428.             | REVD
   429.             | MINUSD
   430.             | PLUSD
   431.             | DIVR =>
   432.             AB := read_top;
   433.             the_trace_operand := AB.msw;
   434.          when others =>
   435.             if the_nest_depth > 0 then
   436.                the_trace_operand := read_top;
   437.             end if;
   438.       end case;
   439.    end look_back_at_a_one_syllable_order;
   440.
   441.    procedure look_back_at_an_IO_order is null;
   442.
   443.    procedure look_back_at_a_two_syllable_order is
   444.       AB : KDF9.pair;
   445.    begin
   446.       case INS.compressed_opcode is
   447.          when MkMq
   448.             | MkMqQ
   449.             | MkMqH
   450.             | MkMqQH
   451.             | MkMqQN
   452.             | MkMqHN
   453.             | MkMqQHN
   454.             | QCIMq
   455.             | SHA
   456.             | SHL
   457.             | SHC
   458.             | TO_Kq
   459.             | Kk
   460.             | LINK =>
   461.             the_trace_operand := read_top;
   462.          when TO_MkMq
   463.             | TO_MkMqQ
   464.             | TO_MkMqH
   465.             | TO_MkMqQH
   466.             | TO_MkMqN
   467.             | TO_MkMqQN
   468.             | TO_MkMqHN
   469.             | TO_MkMqQHN =>
   470.             null;
   471.          when M_PLUS_Iq
   472.             | M_MINUS_Iq
   473.             | NCq
   474.             | DCq
   475.             | POS1_TO_Iq
   476.             | NEG1_TO_Iq
   477.             | POS2_TO_Iq
   478.             | NEG2_TO_Iq
   479.             | TO_RCIMq
   480.             | ADD_TO_QCIMq
   481.             | JCqNZS =>
   482.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   483.          when CqTOQk
   484.             | IqTOQk
   485.             | MqTOQk
   486.             | QqTOQk
   487.             | CIqTOQk
   488.             | IMqTOQk
   489.             | CMqTOQk =>
   490.             the_trace_operand := as_word(the_Q_store(INS.Qk));
   491.          when SHLD
   492.             | SHAD
   493.             | MACC =>
   494.             AB := read_top;
   495.             the_trace_operand := AB.msw;
   496.          when TO_LINK =>
   497.             the_trace_operand := as_word(sjns_top);
   498.          when others =>
   499.             look_back_at_an_IO_order;
   500.       end case;
   501.    end look_back_at_a_two_syllable_order;
   502.
   503.    procedure look_back_at_a_jump_order is
   504.       BA_image  : constant String := "BA #" & oct_of(BA);
   505.       NOL_image : constant String := "NOL"  & NOL'Image;
   506.    begin
   507.       case INS.compressed_opcode is
   508.          when Jr =>
   509.             the_trace_operand := as_word(sjns_link(NIA));
   510.          when JSr =>
   511.             the_trace_operand := as_word(sjns_top);
   512.          when EXITD =>
   513.             take_note_of_interrupt(EXITD_flag, BA_image & " " & NOL_image & " @ " & oct_of(NIA));
   514.          when others =>
   515.             null;
   516.       end case;
   517.    end look_back_at_a_jump_order;
   518.
   519.    procedure look_back_at_a_data_access_order is
   520.    begin
   521.       case INS.compressed_opcode is
   522.          when EaMq
   523.             | EaMqQ
   524.             | SET =>
   525.             the_trace_operand := read_top;
   526.          when others =>
   527.             null;
   528.       end case;
   529.    end look_back_at_a_data_access_order;
   530.
   531.    procedure act_on_any_fetchpoint is
   532.       use type watch_flags.set;
   533.    begin
   534.       if the_trace_address/fetchpoints then
   535.          log_new_line;
   536.          log("Fetch watchhpoint: N1 := [#" & oct_of(the_trace_address) & "]");
   537.          short_witness;
   538.          interact;
   539.          quit_if_requested;
   540.          change_diagnostic_mode_if_requested;
   541.       end if;
   542.    end act_on_any_fetchpoint;
   543.
   544.    procedure act_on_any_storepoint is
   545.       use type watch_flags.set;
   546.    begin
   547.       if the_trace_address/storepoints then
   548.          log_new_line;
   549.          log(
   550.              "Store watchpoint: #"
   551.            & oct_of(the_trace_address)
   552.            & " := [N1] = #"
   553.            & oct_of(the_trace_operand)
   554.             );
   555.          short_witness;
   556.          interact;
   557.          quit_if_requested;
   558.          change_diagnostic_mode_if_requested;
   559.       end if;
   560.    end act_on_any_storepoint;
   561.
   562.    procedure act_on_any_two_syllable_order_watchpoints is
   563.    begin
   564.       case INS.compressed_opcode is
   565.          when MkMq
   566.             | MkMqQ
   567.             | MkMqH
   568.             | MkMqQH
   569.             | MkMqQN
   570.             | MkMqHN
   571.             | MkMqQHN =>
   572.             act_on_any_fetchpoint;
   573.          when TO_MkMq
   574.             | TO_MkMqQ
   575.             | TO_MkMqH
   576.             | TO_MkMqQH
   577.             | TO_MkMqN
   578.             | TO_MkMqQN
   579.             | TO_MkMqHN
   580.             | TO_MkMqQHN =>
   581.             act_on_any_storepoint;
   582.          when others =>
   583.             null;
   584.       end case;
   585.    end act_on_any_two_syllable_order_watchpoints;
   586.
   587.    procedure act_on_any_data_access_order_watchpoints is
   588.    begin
   589.       case INS.compressed_opcode is
   590.          when EaMq
   591.             | EaMqQ =>
   592.             act_on_any_fetchpoint;
   593.          when TO_EaMq
   594.             | TO_EaMqQ =>
   595.             act_on_any_storepoint;
   596.          when others =>
   597.             null;
   598.       end case;
   599.    end act_on_any_data_access_order_watchpoints;
   600.
   601. end tracing;

Compiling: ../Source/tracing.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:27

     1. -- tracing.ads
     2. --
     3. -- Provide diagnostic trace, breakpoint, and watchpoint support.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with generic_sets;
    20. with IOC;
    21. with KDF9;
    22. with settings;
    23.
    24. use  settings;
    25.
    26. package tracing is
    27.
    28.    -- Support for significant-operand evaluation and tracing.
    29.
    30.    the_trace_operand : KDF9.word;
    31.    the_trace_address : KDF9.address;
    32.
    33.    procedure preview_a_one_syllable_order;
    34.
    35.    procedure preview_a_two_syllable_order;
    36.
    37.    procedure preview_a_jump_order;
    38.
    39.    procedure preview_a_data_access_order;
    40.
    41.    procedure look_back_at_a_one_syllable_order;
    42.
    43.    procedure look_back_at_a_two_syllable_order;
    44.
    45.    procedure look_back_at_a_jump_order;
    46.
    47.    procedure look_back_at_a_data_access_order;
    48.
    49.    -- Support for breakpoints.
    50.
    51.    package order_flags is new generic_sets(member => KDF9.order_word_number);
    52.
    53.    breakpoints : order_flags.set := order_flags.empty_set;
    54.
    55.    procedure set_breakpoints (first, last : in KDF9.order_word_number);
    56.
    57.    procedure handle_breakpoint;
    58.
    59.    -- Support for watchpoints.
    60.
    61.    package watch_flags is new generic_sets(member => KDF9.address);
    62.
    63.    fetchpoints : watch_flags.set := watch_flags.empty_set;
    64.    storepoints : watch_flags.set := watch_flags.empty_set;
    65.
    66.    procedure clear_all_watchpoints;
    67.
    68.    procedure set_fetch_points (first, last : in KDF9.address);
    69.
    70.    procedure set_store_points (first, last : in KDF9.address);
    71.
    72.    procedure act_on_any_two_syllable_order_watchpoints
    73.       with Pre => the_diagnostic_mode /= fast_mode;
    74.
    75.    procedure act_on_any_data_access_order_watchpoints
    76.       with Pre => the_diagnostic_mode /= fast_mode;
    77.
    78.
    79.    --
    80.    -- Retrospective tracing.
    81.    --
    82.
    83.    FIFO_size : constant := 256;
    84.
    85.    type FIFO_index is mod FIFO_size;
    86.
    87.    -- Support for all-instruction retrospective tracing.
    88.
    89.    type retro_FIFO_entry is
    90.       record
    91.          location  : KDF9.syllable_address;
    92.          order     : KDF9.syllable_group;
    93.          parameter : KDF9.word;
    94.          ICR_value : KDF9.order_counter;
    95.          CPU_time  : KDF9.us;
    96.          nested    : KDF9.nest_depth;
    97.          called    : KDF9.sjns_depth;
    98.          V, T, D   : Boolean;
    99.          level     : KDF9.priority;
   100.       end record;
   101.
   102.    retro_FIFO  : array (tracing.FIFO_index) of tracing.retro_FIFO_entry;
   103.
   104.    retro_FIFO_index : tracing.FIFO_index := 0;
   105.
   106.    retro_FIFO_count : Natural range 0 .. FIFO_size := 0;
   107.
   108.    procedure clear_retro_FIFO;
   109.
   110.    procedure take_note_of (the_value : in KDF9.word);
   111.
   112.    -- Support for retrospective peripheral I/O tracing.
   113.
   114.    type IOC_event_kind is (start_transfer,
   115.                            finis_transfer,
   116.                            buffer_lockout,
   117.                            store_lockout,
   118.                            buffer_status);
   119.
   120.
   121.    type IOC_FIFO_entry (kind : IOC_event_kind := start_transfer) is
   122.       record
   123.          ICR_value       : KDF9.order_counter;
   124.          order_address   : KDF9.syllable_address;
   125.          decoded_order   : KDF9.decoded_order;
   126.          initiation_time : KDF9.us;
   127.          device_name     : IOC.device_name;
   128.          is_for_Director : Boolean;
   129.          priority_level  : KDF9.priority;
   130.          context         : KDF9.context;
   131.          operation       : IOC.transfer_kind := IOC.some_other_operation;
   132.          case kind is
   133.             when start_transfer | finis_transfer =>
   134.                completion_time : KDF9.us;
   135.                control_word    : KDF9.Q_register;
   136.             when store_lockout =>
   137.                data_address : KDF9.Q_part;
   138.             when buffer_lockout =>
   139.                null;
   140.             when buffer_status =>
   141.                Q_register : KDF9.Q_register;
   142.                status     : Boolean;
   143.          end case;
   144.       end record;
   145.
   146.    IOC_FIFO  : array (tracing.FIFO_index) of tracing.IOC_FIFO_entry;
   147.
   148.    IOC_FIFO_index : tracing.FIFO_index := 0;
   149.
   150.    IOC_FIFO_count : Natural range 0 .. FIFO_size := 0;
   151.
   152.    procedure clear_IOC_FIFO;
   153.
   154.    procedure take_note_of_IO_start (
   155.                                     device_name     : in IOC.device_name;
   156.                                     completion_time : in KDF9.us;
   157.                                     control_word    : in KDF9.Q_register;
   158.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   159.                                    );
   160.
   161.    procedure take_note_of_IO_finis (
   162.                                     ICR_value       : in KDF9.order_counter;
   163.                                     order_address   : in KDF9.syllable_address;
   164.                                     decoded_order   : in KDF9.decoded_order;
   165.                                     initiation_time : in KDF9.us;
   166.                                     device_name     : in IOC.device_name;
   167.                                     is_for_Director : Boolean;
   168.                                     priority_level  : in KDF9.priority;
   169.                                     completion_time : in KDF9.us;
   170.                                     control_word    : in KDF9.Q_register;
   171.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   172.                                    );
   173.
   174.    procedure take_note_of_store_lockout  (device_name : in IOC.device_name);
   175.
   176.    procedure take_note_of_buffer_lockout (device_name : in IOC.device_name;
   177.                                           operation   : in IOC.transfer_kind := IOC.some_other_operation);
   178.
   179.    procedure take_note_of_test (
   180.                                 device_name : in IOC.device_name;
   181.                                 Q_register  : in KDF9.Q_register;
   182.                                 status      : in Boolean
   183.                                 );
   184.
   185.
   186.    -- Support for retrospective interrupt-request tracing.
   187.
   188.    max_interrupt_message_length : constant := 100;
   189.    type interrupt_FIFO_entry is
   190.       record
   191.          interrupt_code : KDF9.interrupt_number;
   192.          ICR_value      : KDF9.order_counter;
   193.          order_address  : KDF9.syllable_address;
   194.          busy_time      : KDF9.us;
   195.          priority_level : KDF9.priority;
   196.          context        : KDF9.context;
   197.          message        : String (1..max_interrupt_message_length);
   198.       end record;
   199.
   200.    interrupt_FIFO  : array (tracing.FIFO_index) of tracing.interrupt_FIFO_entry;
   201.
   202.    interrupt_FIFO_index : tracing.FIFO_index := 0;
   203.
   204.    interrupt_FIFO_count : Natural range 0 .. FIFO_size := 0;
   205.
   206.    procedure clear_interrupt_FIFO;
   207.
   208.    procedure take_note_of_interrupt (interrupt_code : in KDF9.interrupt_number; message : in String);
   209.
   210.
   211.    -- Support for the instruction-type and instruction-word frequency histograms.
   212.
   213.    the_histogram : array (KDF9.syllable) of KDF9.order_counter;
   214.
   215.    procedure clear_the_histogram;
   216.
   217.    procedure add_INS_to_the_histogram
   218.       with Inline;
   219.
   220.    the_profile   : array (KDF9.order_word_number) of KDF9.order_counter;
   221.
   222.    procedure clear_the_profile;
   223.
   224.    procedure add_CIA_to_the_profile
   225.       with Inline;
   226.
   227. end tracing;

 601 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/host_io.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:27

     1. -- host_IO.adb
     2. --
     3. -- Buffered I/O streams to support KDF9 device I/O.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Characters.Latin_1;
    20. with Ada.Exceptions;
    21. --
    22. with exceptions;
    23. with OS_specifics;
    24.
    25. use  Ada.Characters.Latin_1;
    26. --
    27. use  exceptions;
    28. use  OS_specifics;
    29.
    30. package body host_IO is
    31.
    32.    function fd_of (the_stream : host_IO.stream)
    33.    return Natural
    34.    is (the_stream.fd);
    35.
    36.    NL : constant String := OS_specifics.EOL;
    37.
    38.    function image_of (the_stream : host_IO.stream;
    39.                       caption    : String := "")
    40.    return String
    41.    is (if the_stream.is_open then
    42.           caption
    43.         & ":"
    44.         & NL
    45.         & "base_name = "
    46.         & the_stream.base_name
    47.         & NL
    48.         & "is_open = "
    49.         & the_stream.is_open'Image
    50.         & NL
    51.         & "block_size ="
    52.         & the_stream.block_size'Image
    53.         & NL
    54.         & "bytes_moved ="
    55.         & the_stream.bytes_moved'Image
    56.         & NL
    57.         & "fd ="
    58.         & the_stream.fd'Image
    59.         & NL
    60.         & "IO_mode ="
    61.         & the_stream.IO_mode'Image
    62.         & NL
    63.         & "last_IO ="
    64.         & the_stream.last_IO'Image
    65.         & NL
    66.         & "next_byte ="
    67.         & the_stream.next_byte'Image
    68.         & NL
    69.         & "position ="
    70.         & the_stream.position'Image
    71.         & NL
    72.         & "column = "
    73.         & the_stream.column'Image
    74.        else
    75.           caption
    76.       );
    77.
    78.    procedure diagnose (the_stream : host_IO.stream;
    79.                        caption    : String := "")
    80.       with Inline => False;
    81.
    82.    procedure diagnose (the_stream : host_IO.stream;
    83.                        caption    : String := "") is
    84.    begin
    85.       raise stream_IO_error with image_of(the_stream, caption);
    86.    end diagnose;
    87.
    88.    procedure open (the_stream : in out host_IO.stream;
    89.                    file_name  : in String;
    90.                    mode       : in POSIX.access_mode;
    91.                    fd         : in Integer) is
    92.    begin
    93.       if fd >= 0 then
    94.          make_transparent(fd);
    95.          the_stream.base_name := file_name(file_name'First .. file_name'First+2);
    96.          the_stream.IO_mode := mode;
    97.          the_stream.last_IO := read_mode;
    98.          the_stream.fd := fd;
    99.          the_stream.is_open := True;
   100.       else
   101.          the_stream.is_open := False;
   102.       end if;
   103.    end open;
   104.
   105.    procedure open (the_stream : in out host_IO.stream;
   106.                    file_name  : in String;
   107.                    mode       : in POSIX.access_mode) is
   108.       fd : Integer;
   109.    begin -- open
   110.       fd := POSIX.open(file_name, mode);
   111.       open(the_stream, file_name, mode, fd);
   112.    exception
   113.       when POSIX_IO_error =>
   114.          trap_operator_error(file_name,
   115.                              " cannot be "
   116.                            & (case mode is
   117.                                  when read_mode  => "read",
   118.                                  when write_mode => "written",
   119.                                  when rd_wr_mode => "read or written")
   120.                             );
   121.    end open;
   122.
   123.    procedure truncate (the_stream : in out host_IO.stream;
   124.                        to_length  : in KDF9.word := 0) is
   125.    begin
   126.       truncate(the_stream.fd, POSIX.file_position(to_length));
   127.    end truncate;
   128.
   129.    procedure close (the_stream : in out host_IO.stream) is
   130.       response : Integer;
   131.    begin
   132.       if the_stream.is_open then
   133.          flush(the_stream);
   134.          response := close(the_stream.fd);
   135.          pragma Unreferenced(response);
   136.          the_stream.is_open := False;
   137.       end if;
   138.    end close;
   139.
   140.    procedure flush (the_stream  : in out host_IO.stream;
   141.                     a_byte_time : in KDF9.us := 0) is
   142.       response : Integer;
   143.    begin
   144.       if the_stream.is_open      and then
   145.             the_stream.next_byte > 0 then
   146.          if the_stream.IO_mode > read_mode and the_stream.last_IO = write_mode then
   147.             if a_byte_time = 0 then
   148.                response := write(the_stream.fd, the_stream.buffer, the_stream.next_byte);
   149.             else
   150.                for p in 1 .. the_stream.next_byte loop
   151.                   response := write(the_stream.fd, the_stream.buffer(p..p), 1);
   152.                   KDF9.delay_by(a_byte_time);
   153.                end loop;
   154.             end if;
   155.             pragma Unreferenced(response);
   156.          end if;
   157.          the_stream.next_byte := 0;
   158.          the_stream.block_size := 0;
   159.       end if;
   160.    exception
   161.       when error : others =>
   162.          diagnose(the_stream, "FLUSH: " & Ada.Exceptions.Exception_Message(error));
   163.    end flush;
   164.
   165.    function a_LF_was_just_read (the_stream : host_IO.stream)
   166.    return Boolean
   167.    is (
   168.        the_stream.is_open                   and then
   169.           the_stream.bytes_moved > 0        and then
   170.              the_stream.last_IO = read_mode and then
   171.                 the_stream.next_byte = 0    and then
   172.                    the_stream.block_size = 0
   173.       );
   174.
   175.    function a_LF_was_just_written (the_stream : host_IO.stream)
   176.    return Boolean
   177.    is (
   178.        the_stream.is_open                    and then
   179.           the_stream.bytes_moved > 0         and then
   180.              the_stream.last_IO /= read_mode and then
   181.                 the_stream.column = 0
   182.       );
   183.
   184.    procedure reattach (the_stream : in out host_IO.stream;
   185.                        file_name  : in String;
   186.                        mode       : in POSIX.access_mode) is
   187.       old_fd   : constant Integer := the_stream.fd;
   188.    begin
   189.       if mode /= the_stream.IO_mode      and then
   190.             the_stream.IO_mode /= rd_wr_mode then
   191.          diagnose(the_stream, "REATTACH: the new mode is incompatible");
   192.       end if;
   193.       close(the_stream);
   194.       open(the_stream, file_name, (if the_stream.IO_mode = rd_wr_mode then rd_wr_mode else mode));
   195.        if old_fd = 0 and the_stream.fd /= 0 then
   196.          diagnose(the_stream, "REATTACH: standard input cannot be reopened");
   197.       end if;
   198.       if the_stream.is_open then
   199.          the_stream.last_char := ' ';
   200.          the_stream.block_size := 0;
   201.          the_stream.next_byte := 0;
   202.          the_stream.position := 0;
   203.       end if;
   204.    exception
   205.       when stream_IO_error =>
   206.          raise;
   207.       when error : operator_error =>
   208.          raise operator_error with Ada.Exceptions.Exception_Information(error);
   209.       when error : others =>
   210.          diagnose(the_stream, "REATTACH: " & Ada.Exceptions.Exception_Information(error));
   211.    end reattach;
   212.
   213.    function is_open (the_stream : host_IO.stream)
   214.    return Boolean
   215.    is (the_stream.is_open);
   216.
   217.    function bytes_moved (the_stream : host_IO.stream)
   218.    return KDF9.word
   219.    is (the_stream.bytes_moved);
   220.
   221.    function file_size (the_stream : host_IO.stream)
   222.    return Natural is
   223.       here  : constant POSIX.file_position := seek(the_stream.fd, 0, from_here);
   224.       size  : constant POSIX.file_position := seek(the_stream.fd, 0, from_end);
   225.       there : constant POSIX.file_position := seek(the_stream.fd, here, from_start);
   226.    begin
   227.       if here /= there then
   228.          diagnose(the_stream, "FILE_SIZE: seek failure");
   229.       end if;
   230.       return Natural(size);
   231.    end file_size;
   232.
   233.    function column (the_stream : host_IO.stream)
   234.    return Natural
   235.    is (the_stream.column);
   236.
   237.    procedure get_position (position   : out Natural;
   238.                            the_stream : in out host_IO.stream) is
   239.    begin
   240.       flush(the_stream);
   241.       position := the_stream.position;
   242.    end get_position;
   243.
   244.    function buffer_is_empty (the_stream : host_IO.stream)
   245.    return Boolean
   246.    is (not the_stream.is_open or else the_stream.next_byte >= the_stream.block_size);
   247.
   248.    function buffer_is_full (the_stream : host_IO.stream)
   249.    return Boolean
   250.    is (the_stream.is_open and then the_stream.next_byte = the_stream.buffer'Last);
   251.
   252.    procedure set_position (position   : in Natural;
   253.                            the_stream : in out host_IO.stream;
   254.                            whence     : in POSIX.seek_origin := from_start) is
   255.       response : POSIX.file_position;
   256.    begin
   257.       flush(the_stream);
   258.       response := seek(the_stream.fd, POSIX.file_position(position), whence);
   259.       pragma Unreferenced(response);
   260.       the_stream.position := position;
   261.    exception
   262.       when error : others =>
   263.          diagnose(the_stream, "SET_POSITION: " & Ada.Exceptions.Exception_Message(error));
   264.    end set_position;
   265.
   266.    procedure clear (the_stream : in out host_IO.stream) is
   267.    begin
   268.       the_stream.next_byte := 0;
   269.       the_stream.block_size := 0;
   270.    end clear;
   271.
   272.    procedure reset (the_stream : in out host_IO.stream) is
   273.    begin
   274.       flush(the_stream);
   275.       if the_stream.is_open then
   276.          the_stream.last_IO := read_mode;
   277.          the_stream.position := 0;
   278.          the_stream.next_byte := 0;
   279.          the_stream.block_size := 0;
   280.       end if;
   281.    end reset;
   282.
   283.    procedure back_off (the_stream : in out host_IO.stream) is
   284.    begin
   285.       if the_stream.is_open                   and then
   286.             the_stream.next_byte > 0          and then
   287.                the_stream.last_IO = read_mode     then
   288.          the_stream.next_byte := the_stream.next_byte - 1;
   289.          the_stream.position := the_stream.position - 1;
   290.       else
   291.          diagnose(the_stream, "cannot back_off");
   292.       end if;
   293.    end back_off;
   294.
   295.    procedure get_byte (char       : out Character;
   296.                        the_stream : in out host_IO.stream) is
   297.       response : Integer;
   298.    begin
   299.       if not the_stream.is_open then
   300.          raise end_of_stream;
   301.       end if;
   302.       if buffer_is_empty(the_stream) then
   303.          response := read(the_stream.fd, the_stream.buffer, the_stream.buffer'Size);
   304.          the_stream.block_size := response;
   305.          if response <= 0 then
   306.             raise end_of_stream;
   307.          end if;
   308.          the_stream.next_byte := 0;
   309.       end if;
   310.       the_stream.next_byte := the_stream.next_byte + 1;
   311.       the_stream.position := the_stream.position + 1;
   312.       the_stream.bytes_moved := the_stream.bytes_moved + 1;
   313.       the_stream.last_IO := read_mode;
   314.       char := the_stream.buffer(the_stream.next_byte);
   315.       if char = LF then
   316.          the_stream.column := 0;
   317.       else
   318.          the_stream.column := the_stream.column + 1;
   319.       end if;
   320.    exception
   321.       when end_of_stream =>
   322.          raise;
   323.       when POSIX_IO_error =>
   324.          diagnose(the_stream, "GET_BYTE: POSIX_IO_error");
   325.       when error : others =>
   326.          diagnose(the_stream, Ada.Exceptions.Exception_Message(error));
   327.    end get_byte;
   328.
   329.    procedure get_bytes (the_string : out String;
   330.                         the_stream : in out host_IO.stream;
   331.                         uncounted  : in Boolean := True) is
   332.       old_bytes_moved : constant KDF9.word := the_stream.bytes_moved;
   333.    begin
   334.       for b of the_string loop
   335.          get_byte(b, the_stream);
   336.       end loop;
   337.       if uncounted then
   338.          the_stream.bytes_moved := old_bytes_moved;
   339.       end if;
   340.    end get_bytes;
   341.
   342.    procedure get_char (char       : out Character;
   343.                        the_stream : in out host_IO.stream) is
   344.    begin
   345.       get_byte(char, the_stream);
   346.       if char = CR then
   347.          char := LF;
   348.          the_stream.last_char := CR;
   349.       elsif char = LF and the_stream.last_char = CR then
   350.          the_stream.last_char := LF;
   351.          get_byte(char, the_stream);
   352.       else
   353.          the_stream.last_char := char;
   354.       end if;
   355.    end get_char;
   356.
   357.    procedure peek_at_char (char       : out Character;
   358.                            the_stream : in out host_IO.stream) is
   359.    begin
   360.       get_char(char, the_stream);
   361.       back_off(the_stream);
   362.    end peek_at_char;
   363.
   364.    -- put_escape_code writes directly to the stream's device, avoiding the stream's buffers.
   365.    procedure put_escape_code (the_string : in String;
   366.                               the_stream : in out host_IO.stream) is
   367.       response : Integer;
   368.    begin
   369.       if not the_stream.is_open then
   370.          raise end_of_stream;
   371.       end if;
   372.       response := write(the_stream.fd,
   373.                         the_string,
   374.                         the_string'Length);
   375.       if response <= 0 then
   376.          raise end_of_stream;
   377.       end if;
   378.    exception
   379.       when POSIX_IO_error =>
   380.          diagnose(the_stream, "PUT_ESCAPE_CODE: POSIX_IO_error");
   381.       when error : others =>
   382.          diagnose(the_stream, Ada.Exceptions.Exception_Message(error));
   383.    end put_escape_code;
   384.
   385.    procedure put_byte (char       : in Character;
   386.                        the_stream : in out host_IO.stream) is
   387.       response : Integer;
   388.    begin
   389.       if not the_stream.is_open then
   390.          raise end_of_stream;
   391.       end if;
   392.       if the_stream.buffer_is_full then
   393.          response := write(the_stream.fd,
   394.                            the_stream.buffer,
   395.                            the_stream.buffer'Size);
   396.          if response <= 0 then
   397.             raise end_of_stream;
   398.          end if;
   399.          the_stream.next_byte := 0;
   400.       end if;
   401.       the_stream.next_byte := the_stream.next_byte + 1;
   402.       the_stream.position := the_stream.position + 1;
   403.       the_stream.bytes_moved := the_stream.bytes_moved + 1;
   404.       the_stream.buffer(the_stream.next_byte) := char;
   405.       the_stream.last_IO := write_mode;
   406.       if char = LF then
   407.          the_stream.column := 0;
   408.       else
   409.          the_stream.column := the_stream.column + 1;
   410.       end if;
   411.    exception
   412.       when POSIX_IO_error =>
   413.          diagnose(the_stream, "PUT_BYTE: POSIX_IO_error");
   414.       when error : others =>
   415.          diagnose(the_stream, Ada.Exceptions.Exception_Message(error));
   416.    end put_byte;
   417.
   418.    procedure do_not_put_byte (char       : in Character;
   419.                               the_stream : in out host_IO.stream) is
   420.    begin
   421.       if not the_stream.is_open then
   422.          raise end_of_stream;
   423.       end if;
   424.       the_stream.bytes_moved := the_stream.bytes_moved + 1;
   425.       the_stream.last_IO := write_mode;
   426.       if char = LF then
   427.          the_stream.column := 0;
   428.       else
   429.          the_stream.column := the_stream.column + 1;
   430.       end if;
   431.    exception
   432.       when error : others =>
   433.          diagnose(the_stream, Ada.Exceptions.Exception_Message(error));
   434.    end do_not_put_byte;
   435.
   436.    procedure put_bytes (the_string : in String;
   437.                         the_stream : in out host_IO.stream;
   438.                         uncounted  : in Boolean := True) is
   439.       old_bytes_moved : constant KDF9.word := the_stream.bytes_moved;
   440.    begin
   441.       for c of the_string loop
   442.          put_byte(c, the_stream);
   443.       end loop;
   444.       if uncounted then
   445.          the_stream.bytes_moved := old_bytes_moved;
   446.       end if;
   447.    end put_bytes;
   448.
   449.    procedure put_EOL (the_stream : in out host_IO.stream;
   450.                       uncounted  : in Boolean := True) is
   451.    begin
   452.       put_bytes(NL, the_stream, uncounted);
   453.    end put_EOL;
   454.
   455.    procedure put_char (char       : in Character;
   456.                        the_stream : in out host_IO.stream) is
   457.    begin
   458.       if char = LF then
   459.          put_EOL(the_stream, uncounted => False);
   460.       else
   461.          put_byte(char, the_stream);
   462.       end if;
   463.    end put_char;
   464.
   465.    procedure put_chars (the_string : in String;
   466.                         the_stream : in out host_IO.stream) is
   467.    begin
   468.       for c of the_string loop
   469.          put_char(c, the_stream);
   470.       end loop;
   471.    end put_chars;
   472.
   473.    function contents (the_stream : host_IO.stream)
   474.    return String is
   475.    begin
   476.       return the_stream.buffer(1..the_stream.next_byte);
   477.    end contents;
   478.
   479.    procedure inject (the_string : in String;
   480.                      the_stream : in out host_IO.stream) is
   481.       the_length : constant Natural := the_string'Length;
   482.    begin
   483.       if not the_stream.is_open then
   484.          diagnose(the_stream,
   485.                   NL
   486.                 & "injecting:"
   487.                 & NL
   488.                 & the_string
   489.                 & NL
   490.                 & "into the closed "
   491.                 & the_stream.base_name
   492.                  );
   493.       end if;
   494.       if the_length + 1 > IO_buffer_size then
   495.          diagnose(the_stream,
   496.                   NL
   497.                 & "injecting a string of excessive length ="
   498.                 & the_length'Image
   499.                 & " into the stream "
   500.                 & the_stream.base_name
   501.                  );
   502.       elsif the_length > 0 then
   503.          the_stream.block_size := the_length + 1;
   504.          the_stream.buffer(1 .. the_length) := the_string;
   505.          the_stream.buffer(the_length + 1)  := LF;
   506.       else
   507.          diagnose(the_stream,
   508.                   NL
   509.                 & "injecting a string of length = 0 into the stream "
   510.                 & the_stream.base_name
   511.                  );
   512.       end if;
   513.    end inject;
   514.
   515. end host_IO;

Compiling: ../Source/host_io.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:27

     1. -- host_IO.ads
     2. --
     3. -- Buffered I/O streams to support KDF9 device I/O.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with KDF9;
    20. with POSIX;
    21.
    22. use  KDF9;
    23. use  POSIX;
    24.
    25. package host_IO is
    26.
    27.    stream_IO_error, end_of_stream : exception;
    28.
    29.    type stream is tagged limited private;
    30.
    31.    function image_of (the_stream : host_IO.stream;
    32.                       caption    : String := "")
    33.    return String
    34.       with Inline => False;
    35.
    36.    function fd_of (the_stream : host_IO.stream)
    37.    return Natural;
    38.
    39.    -- Open a stream with an established fd.
    40.    procedure open (the_stream : in out host_IO.stream;
    41.                    file_name  : in String;
    42.                    mode       : in POSIX.access_mode;
    43.                    fd         : in Integer);
    44.
    45.    -- Open a base file then use its fd to open a stream.
    46.    procedure open (the_stream : in out host_IO.stream;
    47.                    file_name  : in String;
    48.                    mode       : in POSIX.access_mode);
    49.
    50.    procedure truncate (the_stream : in out host_IO.stream;
    51.                        to_length  : in KDF9.word := 0);
    52.
    53.    procedure close (the_stream : in out host_IO.stream);
    54.
    55.    procedure flush (the_stream  : in out host_IO.stream;
    56.                     a_byte_time : in KDF9.us := 0);
    57.
    58.    -- Reassign an open stream to another file.
    59.    procedure reattach (the_stream : in out host_IO.stream;
    60.                        file_name  : in String;
    61.                        mode       : in POSIX.access_mode);
    62.
    63.    function is_open(the_stream : host_IO.stream)
    64.    return Boolean;
    65.
    66.    function bytes_moved(the_stream : host_IO.stream)
    67.    return KDF9.word;
    68.
    69.    function file_size (the_stream : host_IO.stream)
    70.    return Natural;
    71.
    72.    function column (the_stream : host_IO.stream)
    73.    return Natural;
    74.
    75.    procedure get_position (position   : out Natural;
    76.                            the_stream : in out host_IO.stream);
    77.
    78.    procedure set_position (position   : in Natural;
    79.                            the_stream : in out host_IO.stream;
    80.                            whence     : in POSIX.seek_origin := from_start);
    81.
    82.    procedure clear (the_stream : in out host_IO.stream);
    83.
    84.    procedure reset (the_stream : in out host_IO.stream);
    85.
    86.    procedure back_off (the_stream : in out host_IO.stream)
    87.       with Inline;
    88.
    89.    procedure get_byte (char       : out Character;
    90.                        the_stream : in out host_IO.stream);
    91.
    92.    -- get_bytes iterates get_byte over the_string, for convenience.
    93.    -- If uncounted then the output is not included in the_stream.bytes_moved.
    94.    procedure get_bytes (the_string : out String;
    95.                         the_stream : in out host_IO.stream;
    96.                         uncounted  : in Boolean := True);
    97.
    98.    -- True iff the last get_byte obtained a LF.
    99.    function a_LF_was_just_read (the_stream : host_IO.stream)
   100.    return Boolean;
   101.
   102.    -- get_char differs from get_byte in the treatment of line terminators.
   103.    -- CR, LF, and CRLF are all returned as a single LF character, so catering
   104.    --    for old MacOS, MSDOS, and macOS/UNIX/Linux external text-file formats.
   105.    procedure get_char (char       : out Character;
   106.                        the_stream : in out host_IO.stream);
   107.
   108.    -- peek_at_char uses get_char to inspect the next char to be delivered,
   109.    --    then invokes back_off so that it is left in the input stream.
   110.    procedure peek_at_char (char       : out Character;
   111.                            the_stream : in out host_IO.stream);
   112.
   113.    -- do_not_put_byte does the same as put_byte, except for actually writing it to the_stream.
   114.    procedure do_not_put_byte (char       : in Character;
   115.                               the_stream : in out host_IO.stream);
   116.
   117.    procedure put_byte (char       : in Character;
   118.                        the_stream : in out host_IO.stream);
   119.
   120.    -- put_escape_code writes directly to the stream's device, avoiding the stream's buffers.
   121.    procedure put_escape_code (the_string : in String;
   122.                               the_stream : in out host_IO.stream);
   123.
   124.    -- put_bytes iterates put_byte over the_string, for convenience.
   125.    -- If uncounted then the output is not included in the_stream.bytes_moved.
   126.    procedure put_bytes (the_string : in String;
   127.                         the_stream : in out host_IO.stream;
   128.                         uncounted  : in Boolean := True);
   129.
   130.    -- put_EOL writes the host-appropriate line terminator (CRLF, or just LF)
   131.    procedure put_EOL (the_stream : in out host_IO.stream;
   132.                       uncounted  : in Boolean := True);
   133.
   134.    -- put_char differs from put_byte only in the treatment of line terminators.
   135.    -- If char is LF, then put_EOL is used to output a host-appropriate line terminator.
   136.    procedure put_char (char       : in Character;
   137.                        the_stream : in out host_IO.stream);
   138.
   139.    -- put_chars iterates put_bytes over the_string, for convenience.
   140.    procedure put_chars (the_string : in String;
   141.                         the_stream : in out host_IO.stream);
   142.
   143.    -- True iff the last put_byte wrote out a LF.
   144.    function a_LF_was_just_written (the_stream : host_IO.stream)
   145.    return Boolean;
   146.
   147.    function buffer_is_empty (the_stream : host_IO.stream)
   148.    return Boolean
   149.       with Inline;
   150.
   151.    function buffer_is_full (the_stream : host_IO.stream)
   152.    return Boolean
   153.       with Inline;
   154.
   155.    -- Return the currently buffered output as a single string.
   156.    function contents (the_stream : host_IO.stream)
   157.    return String;
   158.
   159.    -- Make the_string appear to be input for the_stream (which must be empty).
   160.    procedure inject (the_string : in String;
   161.                      the_stream : in out host_IO.stream);
   162.
   163. private
   164.
   165.    -- N.B. in host_IO the term 'buffer' is used conventionally.
   166.    -- It does NOT refer to a KDF9 DMA channel.
   167.
   168.    -- IO_buffer_size is enough for a complete FD sector, lacking any better criterion.
   169.    IO_buffer_size : constant Positive := 320;
   170.
   171.    type stream is tagged limited
   172.       record
   173.          base_name   : String (1 .. 3) := "???";
   174.          is_open     : Boolean := False;
   175.          last_char   : Character := ' ';
   176.          block_size,
   177.          next_byte,
   178.          saved_size,
   179.          position,
   180.          column      : Natural := 0;
   181.          bytes_moved : KDF9.word := 0;
   182.          fd          : Natural := Natural'Last;
   183.          IO_mode     : POSIX.access_mode range read_mode .. rd_wr_mode;
   184.          last_IO     : POSIX.access_mode range read_mode .. write_mode;
   185.          buffer,
   186.          look_behind : String(1 .. IO_buffer_size);
   187.       end record;
   188.
   189. end host_IO;

 515 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/kdf9-store.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:28

     1. -- kdf9-store.adb
     2. --
     3. -- KDF9 core store operations.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Unchecked_Conversion;
    20. --
    21. with formatting;
    22. with KDF9.CPU;
    23.
    24. use formatting;
    25. use  KDF9.CPU;
    26.
    27. package body KDF9.store is
    28.
    29.    -- diagnose_invalid_address avoids secondary stack usage in the address validation procedures.
    30.    procedure diagnose_invalid_address (message : in String; address : in KDF9.word)
    31.       with Inline => False;
    32.
    33.    procedure diagnose_invalid_address (message : in String; address : in KDF9.word) is
    34.    begin
    35.       trap_illegal_instruction(message & " =" & address'Image);
    36.    end diagnose_invalid_address;
    37.
    38.    -- Check that EA, EA+BA are valid; LIV if invalid.
    39.    procedure validate_virtual_and_real_addresses (EA : in KDF9.Q_part)
    40.       with Inline;
    41.
    42.    procedure validate_virtual_and_real_addresses (EA : in KDF9.Q_part) is
    43.       PA : constant KDF9.word := (KDF9.word(EA) + KDF9.word(BA)) and Q_part_mask;
    44.    begin
    45.       if EA > NOL and then the_CPU_state = program_state then
    46.          diagnose_invalid_address("NOL < virtual address", KDF9.word(EA));
    47.       end if;
    48.       if PA > max_address and then the_CPU_state = program_state then
    49.          diagnose_invalid_address("32K-1 < physical address", PA);
    50.       end if;
    51.    end validate_virtual_and_real_addresses;
    52.
    53.    procedure if_user_mode_then_LOV (address_1 : KDF9.Q_part;
    54.                                     address_2 : KDF9.Q_part := 0;
    55.                                     solo      : Boolean     := True) is
    56.    begin
    57.       LOV_if_user_mode(
    58.                        if solo
    59.                        then "at #" & oct_of(address_1) & " (E" & dec_of(address_1) & ")"
    60.                        else "in #" & oct_of(address_1) & "/#" & oct_of(address_2)
    61.                       );
    62.    end if_user_mode_then_LOV;
    63.
    64.    function group (PA : KDF9.Q_part)
    65.    return KDF9.Q_part
    66.    is (PA / group_size);
    67.
    68.    procedure check_address_and_lockout (EA : in KDF9.Q_part) is
    69.       PA : constant KDF9.Q_part := EA + BA;
    70.    begin
    71.       validate_virtual_and_real_addresses(EA);
    72.       if locked_out(group(PA)) then
    73.          the_locked_out_address := PA;
    74.          if the_CPU_state /= Director_state then
    75.             if_user_mode_then_LOV(PA);
    76.          end if;
    77.       end if;
    78.    end check_address_and_lockout;
    79.
    80.    procedure validate_address_range (EA1, EA2 : in KDF9.Q_part) is
    81.    begin
    82.       validate_virtual_and_real_addresses(EA1);
    83.       validate_virtual_and_real_addresses(EA2);
    84.       if EA1 > EA2 then
    85.          diagnose_invalid_address("initial address > final address", KDF9.word(EA2));
    86.       end if;
    87.    end validate_address_range;
    88.
    89.    procedure check_addresses_and_lockouts (EA1, EA2 : in KDF9.Q_part) is
    90.        PA1 : constant KDF9.Q_part := EA1 + BA;
    91.        PA2 : constant KDF9.Q_part := EA2 + BA;
    92.    begin
    93.       validate_address_range (EA1, EA2);
    94.
    95.       if there_are_locks_in_physical_addresses(KDF9.Q_register'(C => 0, I => PA1, M => PA2)) then
    96.          if the_CPU_state /= Director_state then
    97.             if_user_mode_then_LOV(PA1, PA2, solo => False);
    98.          end if;
    99.       end if;
   100.    end check_addresses_and_lockouts;
   101.
   102.    -- Check that A1+A2 is valid; trap if it is invalid.
   103.    function valid_word_address (A1, A2 : in KDF9.Q_part)
   104.    return KDF9.address is
   105.       V : constant KDF9.word := (KDF9.word(A1) + KDF9.word(A2)) and Q_part_mask;
   106.    begin
   107.       if V > max_address then
   108.          diagnose_invalid_address("32K-1 < virtual address", V);
   109.       end if;
   110.       return KDF9.address(V);
   111.    end valid_word_address;
   112.
   113.    function signed is new Ada.Unchecked_Conversion (KDF9.Q_part, CPU.signed_Q_part);
   114.    function design is new Ada.Unchecked_Conversion (CPU.signed_Q_part, KDF9.Q_part);
   115.
   116.    -- Check that A1+A2/2 is valid; trap if it is invalid.  A2 must be treated as a signed number.
   117.    function valid_halfword_address (A1, A2 : in KDF9.Q_part)
   118.    return KDF9.address is
   119.       V : constant KDF9.word := (KDF9.word(A1) + KDF9.word(design(signed(A2)/2))) and Q_part_mask;
   120.    begin
   121.       if V > max_address then
   122.          diagnose_invalid_address("32K-1 < virtual address", V);
   123.       end if;
   124.       return KDF9.address(V);
   125.    end valid_halfword_address;
   126.
   127.    function fetch_symbol (EA : KDF9.address; index : KDF9_char_sets.symbol_index)
   128.    return KDF9_char_sets.symbol
   129.    is (KDF9_char_sets.symbol(shift_word_right(core(EA+BA), 42 - 6*Natural(index)) and 8#77#));
   130.
   131.    procedure store_symbol (value : in KDF9_char_sets.symbol;
   132.                            EA    : in KDF9.address;
   133.                            index : in KDF9_char_sets.symbol_index) is
   134.       place  : constant Natural   := 42 - 6*Natural(index);
   135.       mask   : constant KDF9.word := not shift_word_left(8#77#, place);
   136.       symbol : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   137.    begin
   138.       core(EA+BA) := (core(EA+BA) and mask) or symbol;
   139.    end store_symbol;
   140.
   141.    function fetch_octet (EA : KDF9.address; index : KDF9_char_sets.octet_index)
   142.    return KDF9_char_sets.octet is
   143.       place : constant Natural := 40 - 8*Natural(index);
   144.    begin
   145.       return KDF9_char_sets.octet(shift_word_right(core(EA+BA), place) and 8#377#);
   146.    end fetch_octet;
   147.
   148.    procedure store_octet  (value : in KDF9_char_sets.octet;
   149.                            EA    : in KDF9.address;
   150.                            index : in KDF9_char_sets.octet_index) is
   151.       place : constant Natural   := 40 - 8*Natural(index);
   152.       octet : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   153.       mask  : constant KDF9.word := not shift_word_left(8#377#, place);
   154.    begin
   155.       core(EA+BA) := (core(EA+BA) and mask) or octet;
   156.    end store_octet;
   157.
   158.    function fetch_syllable (EA : KDF9.syllable_address)
   159.    return KDF9.syllable is
   160.       address : constant KDF9.address := Q_part(EA.order_word_number) + BA;
   161.       place   : constant Natural      := 40 - 8*Natural(EA.syllable_index);
   162.    begin
   163.       return KDF9.syllable(shift_word_right(core(address), place) and 8#377#);
   164.    end fetch_syllable;
   165.
   166.    procedure store_syllable (value : in KDF9.syllable;
   167.                              EA    : in KDF9.address;
   168.                              index : in KDF9.syllable_index) is
   169.       place    : constant Natural   := 40 - 8*Natural(index);
   170.       syllable : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   171.       mask     : constant KDF9.word := not shift_word_left(8#377#, place);
   172.    begin
   173.       core(EA+BA) := (core(EA+BA) and mask) or syllable;
   174.    end store_syllable;
   175.
   176.    function fetch_halfword (EA : KDF9.address; index : KDF9.halfword_number)
   177.    return KDF9.word
   178.    is (shift_word_left(shift_word_right(core(EA+BA), 24 - 24*Natural(index)), 24));
   179.
   180.    procedure store_halfword (value : in KDF9.word;
   181.                              EA    : in KDF9.address;
   182.                              index : in KDF9.halfword_number) is
   183.       place   : constant Natural   := 24 - 24*Natural(index);
   184.       half    : constant KDF9.word := shift_word_left(shift_word_right(value, 24), place);
   185.       mask    : constant KDF9.word := not shift_word_left(halfword_mask, place);
   186.    begin
   187.       core(EA+BA) := (core(EA+BA) and mask) or half;
   188.    end store_halfword;
   189.
   190.    function fetch_word (EA : KDF9.address)
   191.    return KDF9.word
   192.    is (core(EA+BA));
   193.
   194.    procedure store_word (value : in KDF9.word; EA : in KDF9.address) is
   195.    begin
   196.       core(EA+BA) := value;
   197.    end store_word;
   198.
   199.    function there_are_locks_in_relative_addresses (Q : KDF9.Q_register)
   200.    return Boolean is
   201.    begin
   202.       validate_address_range (Q.I, Q.M);
   203.       return there_are_locks_in_physical_addresses((0, Q.I+BA, Q.M+BA));
   204.    end there_are_locks_in_relative_addresses;
   205.
   206.    function there_are_locks_in_physical_addresses (Q : KDF9.Q_register)
   207.    return Boolean is
   208.    begin
   209.       for g in group(Q.I) .. group(Q.M) loop
   210.          if locked_out(g) then
   211.             the_locked_out_address := g * group_size;
   212.             return True;
   213.          end if;
   214.       end loop;
   215.       return False;
   216.    end there_are_locks_in_physical_addresses;
   217.
   218.    function is_unlocked (G : KDF9.store.group_address)
   219.    return Boolean is
   220.    begin
   221.       return not locked_out(KDF9.Q_part(G));
   222.    end is_unlocked;
   223.
   224.    procedure lock_out_relative_addresses (Q : in KDF9.Q_register) is
   225.    begin
   226.       validate_address_range (Q.I, Q.M);
   227.       lock_out_absolute_addresses((0, Q.I+BA, Q.M+BA));
   228.    end lock_out_relative_addresses;
   229.
   230.    procedure lock_out_absolute_addresses (Q : in KDF9.Q_register) is
   231.    begin
   232.       for g in group(Q.I) .. group(Q.M) loop
   233.          locked_out(g) := True;
   234.       end loop;
   235.    end lock_out_absolute_addresses;
   236.
   237.    procedure unlock_absolute_addresses (Q : in KDF9.Q_register) is
   238.    begin
   239.       for g in group(Q.I) .. group(Q.M) loop
   240.          locked_out(g) := False;
   241.       end loop;
   242.    end unlock_absolute_addresses;
   243.
   244. end KDF9.store;

Compiling: ../Source/kdf9-store.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:28

     1. -- kdf9-store.ads
     2. --
     3. -- KDF9 core store operations.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with KDF9_char_sets;
    20.
    21. use  KDF9_char_sets;
    22.
    23. package KDF9.store is
    24.
    25.    --
    26.    -- Relative addresses may be either virtual or physical.
    27.    -- Virtual addresses are generated by problem programs and must be relativized by adding BA.
    28.    -- These addresses must also be validated to ensure they do not breach store limits.
    29.    -- Physical "relative" addresses are generated by Director, when BA is guaranteed to be 0,
    30.    --   so it has no effect, thus allowing the relative address routines to be used.
    31.    --
    32.    -- Absolute addresses are generated by I/O Control, which may be doing a transfer for either
    33.    --   a Director or a problem program, and must therefore ensure that BA is not added.
    34.    --
    35.
    36.    --
    37.    -- Parameters named EA are Effective "relative" Addresses.
    38.    --
    39.
    40.    function fetch_symbol (EA : KDF9.address; index : KDF9_char_sets.symbol_index)
    41.    return KDF9_char_sets.symbol;
    42.
    43.    function fetch_octet (EA : KDF9.address; index : KDF9_char_sets.octet_index)
    44.    return KDF9_char_sets.octet
    45.       with Inline;
    46.
    47.    function fetch_syllable (EA : KDF9.syllable_address)
    48.    return KDF9.syllable
    49.       with Inline;
    50.
    51.    function fetch_halfword (EA : KDF9.address; index : KDF9.halfword_number)
    52.    return KDF9.word
    53.       with Inline;
    54.
    55.    function fetch_word (EA : KDF9.address)
    56.    return KDF9.word
    57.       with Inline;
    58.
    59.    procedure store_symbol (value : in KDF9_char_sets.symbol;
    60.                            EA    : in KDF9.address;
    61.                            index : in KDF9_char_sets.symbol_index)
    62.       with Inline;
    63.
    64.    procedure store_octet  (value : in KDF9_char_sets.octet;
    65.                            EA    : in KDF9.address;
    66.                            index : in KDF9_char_sets.octet_index)
    67.       with Inline;
    68.
    69.    procedure store_syllable (value : in KDF9.syllable;
    70.                              EA    : in KDF9.address;
    71.                              index : in KDF9.syllable_index)
    72.       with Inline;
    73.
    74.    procedure store_halfword (value : in KDF9.word;
    75.                              EA    : in KDF9.address;
    76.                              index : in KDF9.halfword_number)
    77.       with Inline;
    78.
    79.    procedure store_word (value : in KDF9.word; EA : in KDF9.address)
    80.       with Inline;
    81.
    82.    -- Check that A1+A2 is a valid word address; LIV if it is invalid.
    83.    function valid_word_address (A1, A2 : in KDF9.Q_part)
    84.    return KDF9.address
    85.       with Inline;
    86.
    87.    -- Check that A1+A2/2 is valid; LIV if it is invalid.  A2 is treated as a signed number.
    88.    function valid_halfword_address (A1, A2 : in KDF9.Q_part)
    89.    return KDF9.address
    90.       with Inline;
    91.
    92.    -- If a store access is locked out, its physical address is left here.
    93.    the_locked_out_address : KDF9.Q_part;
    94.
    95.    procedure if_user_mode_then_LOV (address_1 : KDF9.Q_part;
    96.                                     address_2 : KDF9.Q_part := 0;
    97.                                     solo      : Boolean     := True)
    98.       with Inline => False;
    99.
   100.    -- Check EA and lockout for EA.
   101.    procedure check_address_and_lockout (EA : in KDF9.Q_part)
   102.       with Inline;
   103.
   104.    -- Check that EA1, EA2, EA1+BA, EA2+BA are valid, and EA1 <= EA2.
   105.    --    LIV in any invalid case.
   106.    procedure validate_address_range (EA1, EA2 : in KDF9.Q_part);
   107.
   108.    -- Check EA1, EA2, and lockouts for EA1+BA .. EA2+BA.
   109.    procedure check_addresses_and_lockouts (EA1, EA2 : in KDF9.Q_part);
   110.
   111.    function there_are_locks_in_relative_addresses (Q : KDF9.Q_register)
   112.    return Boolean;
   113.
   114.    function there_are_locks_in_physical_addresses (Q : KDF9.Q_register)
   115.    return Boolean;
   116.
   117.    procedure lock_out_relative_addresses (Q : in KDF9.Q_register);
   118.
   119.    procedure lock_out_absolute_addresses (Q : in KDF9.Q_register);
   120.
   121.    procedure unlock_absolute_addresses (Q : in KDF9.Q_register);
   122.
   123.    -- The maximum size KDF9 core store has 32Kibiwords.
   124.    max_address   : constant := 2**15 - 1;
   125.
   126.    -- The group size of 32 words is 1 physical core allocation unit and physical lockout unit.
   127.    group_size : constant := 32;
   128.
   129.    type group_address is mod 1024;
   130.
   131.     -- is_unlocked yields True if the designated group is NOT locked out.
   132.    function is_unlocked (G : KDF9.store.group_address)
   133.    return Boolean;
   134.
   135.    function group (PA : KDF9.Q_part)
   136.    return KDF9.Q_part
   137.       with Inline;
   138.
   139. private
   140.
   141.    type word_array is array (KDF9.Q_part range <>) of KDF9.word
   142.       with Component_Size => 64, Convention => C;
   143.
   144.    -- The core store of KDF9.  Must be zeroized before loading any software.
   145.    core : word_array (KDF9.Q_part range 0 .. max_address) := (others => 0);
   146.
   147.    -- The lockout store has one bit for every group_size words.
   148.    last_lockout : constant := max_address / group_size;
   149.    locked_out   : array (KDF9.Q_part range 0 .. last_lockout) of Boolean := (others => False);
   150.
   151. end KDF9.store;

 244 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-absent.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:28

     1. -- ioc-absent.adb
     2. --
     3. -- Handle attempted usage of a buffer with No Attached device.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with formatting;
    20.
    21. use formatting;
    22.
    23. package body IOC.absent is
    24.
    25.    procedure disavow (the_device  : in out absent.device;
    26.                       Q_operand   : in KDF9.Q_register;
    27.                       set_offline : in Boolean) is
    28.       pragma Unreferenced(the_device);
    29.       pragma Unreferenced(set_offline);
    30.    begin
    31.       trap_operator_error("buffer #" & oct_of(Q_operand.C, 2), "has no I/O device");
    32.    end disavow;
    33.
    34.    overriding
    35.    procedure PIA (the_device  : in out absent.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean) is
    38.    begin disavow(the_device, Q_operand, set_offline); end PIA;
    39.
    40.    overriding
    41.    procedure PIB (the_device  : in out absent.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean) is
    44.    begin disavow(the_device, Q_operand, set_offline); end PIB;
    45.
    46.    overriding
    47.    procedure PIC (the_device  : in out absent.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean) is
    50.    begin disavow(the_device, Q_operand, set_offline); end PIC;
    51.
    52.    overriding
    53.    procedure PID (the_device  : in out absent.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean) is
    56.    begin disavow(the_device, Q_operand, set_offline); end PID;
    57.
    58.    overriding
    59.    procedure PIE (the_device  : in out absent.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean) is
    62.    begin disavow(the_device, Q_operand, set_offline); end PIE;
    63.
    64.    overriding
    65.    procedure PIF (the_device  : in out absent.device;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean) is
    68.    begin disavow(the_device, Q_operand, set_offline); end PIF;
    69.
    70.    overriding
    71.    procedure PIG (the_device  : in out absent.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean) is
    74.    begin disavow(the_device, Q_operand, set_offline); end PIG;
    75.
    76.    overriding
    77.    procedure PIH (the_device  : in out absent.device;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean) is
    80.    begin disavow(the_device, Q_operand, set_offline); end PIH;
    81.
    82.    overriding
    83.    procedure PMA (the_device  : in out absent.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean) is
    86.    begin disavow(the_device, Q_operand, set_offline); end PMA;
    87.
    88.    overriding
    89.    procedure PMB (the_device  : in out absent.device;
    90.                   Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean) is
    92.    begin disavow(the_device, Q_operand, set_offline); end PMB;
    93.
    94.    overriding
    95.    procedure PMC (the_device  : in out absent.device;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean) is
    98.    begin disavow(the_device, Q_operand, set_offline); end PMC;
    99.    overriding
   100.    procedure PMD (the_device  : in out absent.device;
   101.                   Q_operand   : in KDF9.Q_register;
   102.                   set_offline : in Boolean) is
   103.    begin disavow(the_device, Q_operand, set_offline); end PMD;
   104.
   105.    overriding
   106.    procedure PME (the_device  : in out absent.device;
   107.                   Q_operand   : in KDF9.Q_register;
   108.                   set_offline : in Boolean) is
   109.    begin disavow(the_device, Q_operand, set_offline); end PME;
   110.
   111.    overriding
   112.    procedure PMF (the_device  : in out absent.device;
   113.                   Q_operand   : in KDF9.Q_register;
   114.                   set_offline : in Boolean) is
   115.    begin disavow(the_device, Q_operand, set_offline); end PMF;
   116.
   117.
   118.    overriding
   119.    procedure PMG (the_device  : in out absent.device;
   120.                   Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean) is
   122.    begin disavow(the_device, Q_operand, set_offline); end PMG;
   123.
   124.    overriding
   125.    procedure PMK (the_device  : in out absent.device;
   126.                   Q_operand   : in KDF9.Q_register;
   127.                   set_offline : in Boolean) is
   128.    begin disavow(the_device, Q_operand, set_offline); end PMK;
   129.
   130.    overriding
   131.    procedure PML (the_device  : in out absent.device;
   132.                   Q_operand   : in KDF9.Q_register;
   133.                   set_offline : in Boolean) is
   134.    begin disavow(the_device, Q_operand, set_offline); end PML;
   135.
   136.    overriding
   137.    procedure POA (the_device  : in out absent.device;
   138.                   Q_operand   : in KDF9.Q_register;
   139.                   set_offline : in Boolean) is
   140.    begin disavow(the_device, Q_operand, set_offline); end POA;
   141.
   142.    overriding
   143.    procedure POB (the_device  : in out absent.device;
   144.                   Q_operand   : in KDF9.Q_register;
   145.                   set_offline : in Boolean) is
   146.    begin disavow(the_device, Q_operand, set_offline); end POB;
   147.
   148.    overriding
   149.    procedure POC (the_device  : in out absent.device;
   150.                   Q_operand   : in KDF9.Q_register;
   151.                   set_offline : in Boolean) is
   152.    begin disavow(the_device, Q_operand, set_offline); end POC;
   153.
   154.    overriding
   155.    procedure POD (the_device  : in out absent.device;
   156.                   Q_operand   : in KDF9.Q_register;
   157.                   set_offline : in Boolean) is
   158.    begin disavow(the_device, Q_operand, set_offline); end POD;
   159.
   160.    overriding
   161.    procedure POE (the_device  : in out absent.device;
   162.                   Q_operand   : in KDF9.Q_register;
   163.                   set_offline : in Boolean) is
   164.    begin disavow(the_device, Q_operand, set_offline); end POE;
   165.
   166.    overriding
   167.    procedure POF (the_device  : in out absent.device;
   168.                   Q_operand   : in KDF9.Q_register;
   169.                   set_offline : in Boolean) is
   170.    begin disavow(the_device, Q_operand, set_offline); end POF;
   171.
   172.    overriding
   173.    procedure POG (the_device  : in out absent.device;
   174.                   Q_operand   : in KDF9.Q_register;
   175.                   set_offline : in Boolean) is
   176.    begin disavow(the_device, Q_operand, set_offline); end POG;
   177.
   178.    overriding
   179.    procedure POH (the_device  : in out absent.device;
   180.                   Q_operand   : in KDF9.Q_register;
   181.                   set_offline : in Boolean) is
   182.    begin disavow(the_device, Q_operand, set_offline); end POH;
   183.
   184.    overriding
   185.    procedure POK (the_device  : in out absent.device;
   186.                   Q_operand   : in KDF9.Q_register;
   187.                   set_offline : in Boolean) is
   188.    begin disavow(the_device, Q_operand, set_offline); end POK;
   189.
   190.    overriding
   191.    procedure POL (the_device  : in out absent.device;
   192.                   Q_operand   : in KDF9.Q_register;
   193.                   set_offline : in Boolean) is
   194.    begin disavow(the_device, Q_operand, set_offline); end POL;
   195.
   196.
   197.    type ND_access is access absent.device;
   198.    ND_list         : array (IOC.unit_number) of ND_access with Warnings => Off;
   199.
   200.    unit : IOC.unit_number := 0;
   201.
   202.    procedure enable (b : in KDF9.buffer_number) is
   203.    begin
   204.       ND_list(unit) := new absent.device (number => b, kind =>ND_kind, unit => unit, quantum => 0);
   205.       unit := unit + 1;
   206.    end enable;
   207.
   208. end IOC.absent;
   209.

Compiling: ../Source/ioc-absent.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:28

     1. -- ioc-absent.ads
     2. --
     3. -- Handle attempted usage of a buffer with No Attached device.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.absent is
    20.
    21.    type device is new IOC.device with null record;
    22.
    23.    -- All the operations of an absent device terminate the run.
    24.
    25.    overriding
    26.    procedure PIA (the_device  : in out absent.device;
    27.                   Q_operand   : in KDF9.Q_register;
    28.                   set_offline : in Boolean);
    29.
    30.    overriding
    31.    procedure PIB (the_device  : in out absent.device;
    32.                   Q_operand   : in KDF9.Q_register;
    33.                   set_offline : in Boolean);
    34.
    35.    overriding
    36.    procedure PIC (the_device  : in out absent.device;
    37.                   Q_operand   : in KDF9.Q_register;
    38.                   set_offline : in Boolean);
    39.
    40.    overriding
    41.    procedure PID (the_device  : in out absent.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    overriding
    46.    procedure PIE (the_device  : in out absent.device;
    47.                   Q_operand   : in KDF9.Q_register;
    48.                   set_offline : in Boolean);
    49.
    50.    overriding
    51.    procedure PIF (the_device  : in out absent.device;
    52.                   Q_operand   : in KDF9.Q_register;
    53.                   set_offline : in Boolean);
    54.
    55.    overriding
    56.    procedure PIG (the_device  : in out absent.device;
    57.                   Q_operand   : in KDF9.Q_register;
    58.                   set_offline : in Boolean);
    59.
    60.    overriding
    61.    procedure PIH (the_device  : in out absent.device;
    62.                   Q_operand   : in KDF9.Q_register;
    63.                   set_offline : in Boolean);
    64.
    65.    overriding
    66.    procedure PMA (the_device  : in out absent.device;
    67.                   Q_operand   : in KDF9.Q_register;
    68.                   set_offline : in Boolean);
    69.
    70.    overriding
    71.    procedure PMB (the_device  : in out absent.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    overriding
    76.    procedure PMC (the_device  : in out absent.device;
    77.                   Q_operand   : in KDF9.Q_register;
    78.                   set_offline : in Boolean);
    79.    overriding
    80.    procedure PMD (the_device  : in out absent.device;
    81.                   Q_operand   : in KDF9.Q_register;
    82.                   set_offline : in Boolean);
    83.
    84.    overriding
    85.    procedure PME (the_device  : in out absent.device;
    86.                   Q_operand   : in KDF9.Q_register;
    87.                   set_offline : in Boolean);
    88.
    89.    overriding
    90.    procedure PMF (the_device  : in out absent.device;
    91.                   Q_operand   : in KDF9.Q_register;
    92.                   set_offline : in Boolean);
    93.
    94.    overriding
    95.    procedure PMG (the_device  : in out absent.device;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean);
    98.
    99.    overriding
   100.    procedure PMK (the_device  : in out absent.device;
   101.                   Q_operand   : in KDF9.Q_register;
   102.                   set_offline : in Boolean);
   103.
   104.    overriding
   105.    procedure PML (the_device  : in out absent.device;
   106.                   Q_operand   : in KDF9.Q_register;
   107.                   set_offline : in Boolean);
   108.
   109.    overriding
   110.    procedure POA (the_device  : in out absent.device;
   111.                   Q_operand   : in KDF9.Q_register;
   112.                   set_offline : in Boolean);
   113.
   114.    overriding
   115.    procedure POB (the_device  : in out absent.device;
   116.                   Q_operand   : in KDF9.Q_register;
   117.                   set_offline : in Boolean);
   118.
   119.    overriding
   120.    procedure POC (the_device  : in out absent.device;
   121.                   Q_operand   : in KDF9.Q_register;
   122.                   set_offline : in Boolean);
   123.
   124.    overriding
   125.    procedure POD (the_device  : in out absent.device;
   126.                   Q_operand   : in KDF9.Q_register;
   127.                   set_offline : in Boolean);
   128.
   129.    overriding
   130.    procedure POE (the_device  : in out absent.device;
   131.                   Q_operand   : in KDF9.Q_register;
   132.                   set_offline : in Boolean);
   133.
   134.    overriding
   135.    procedure POF (the_device  : in out absent.device;
   136.                   Q_operand   : in KDF9.Q_register;
   137.                   set_offline : in Boolean);
   138.
   139.    overriding
   140.    procedure POG (the_device  : in out absent.device;
   141.                   Q_operand   : in KDF9.Q_register;
   142.                   set_offline : in Boolean);
   143.
   144.    overriding
   145.    procedure POH (the_device  : in out absent.device;
   146.                   Q_operand   : in KDF9.Q_register;
   147.                   set_offline : in Boolean);
   148.
   149.    overriding
   150.    procedure POK (the_device  : in out absent.device;
   151.                   Q_operand   : in KDF9.Q_register;
   152.                   set_offline : in Boolean);
   153.
   154.    overriding
   155.    procedure POL (the_device  : in out absent.device;
   156.                   Q_operand   : in KDF9.Q_register;
   157.                   set_offline : in Boolean);
   158.
   159.    -- Register the absence of a device in case of future attempted access to buffer b.
   160.    procedure enable (b : in KDF9.buffer_number);
   161.
   162. end IOC.absent;

 209 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-fast.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:28

     1. -- ioc-fast.ads
     2. --
     3. -- Emulation of the common functionality of a KDF9 "fast", i.e. word-by-word, devices.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.fast is
    20.
    21.    --
    22.    -- This is the root type for all fast I/O device types.
    23.    --
    24.
    25.    type device is abstract new IOC.device with private;
    26.
    27. private
    28.
    29.    type device is abstract new IOC.device with
    30.       record
    31.          switch_time,
    32.          latency_time,
    33.          elapsed_time  : KDF9.us := 0;
    34.          word_count,
    35.          switch_count,
    36.          latency_count : KDF9.word := 0;
    37.       end record;
    38.
    39. end IOC.fast;

 39 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-fast-dr.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:29

     1. -- ioc-fast-dr.adb
     2. --
     3. -- Emulation of a drum store.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with formatting;
    20. with HCI;
    21.
    22. use  formatting;
    23. use  HCI;
    24.
    25. package body IOC.fast.DR is
    26.
    27.    use KDF9_char_sets;
    28.
    29.    function as_DR_command (Q_operand : KDF9.Q_register; for_OUT : Boolean := False)
    30.    return String is
    31.       C, sector, track, drive :KDF9.Q_part;
    32.    begin
    33.       if for_OUT then
    34.          -- There is no buffer number.
    35.          C := Q_operand.C;
    36.       else
    37.          -- Get rid of the buffer number.
    38.          C := Q_operand.C / 16;
    39.       end if;
    40.       drive := C mod drums_per_system;
    41.       C := C  /  drums_per_system;
    42.       sector := C mod sectors_per_track;
    43.       track := C mod sectors_per_drum;
    44.       return "D"
    45.            & dec_of(drive)
    46.            & "T"
    47.            & dec_of(track)
    48.            & "S"
    49.            & dec_of(sector);
    50.    end as_DR_command;
    51.
    52.    -- The host_IO stream for DR0 is used only to open and close the file.
    53.    -- I/O operations for the DR0 file are done with unmediated POSIX system calls.
    54.
    55.    function file_offset (sector_number : DR.drum_index)
    56.    return POSIX.file_position
    57.    is (bytes_per_sector * POSIX.file_position(sector_number));
    58.
    59.    procedure get (the_DR : in out DR.device; s : out sector; the_index : in KDF9.word) is
    60.       byte_address : constant POSIX.file_position := file_offset(the_index);
    61.       result       : POSIX.file_position;
    62.    begin
    63.       result := seek(fd_of(the_DR.stream), file_offset(the_index));
    64.       if result /= byte_address then
    65.          raise emulation_failure
    66.             with "POSIX seek failure in DR.get at sector" & the_index'Image & ", new position =" & result'Image;
    67.       end if;
    68.       result := POSIX.file_position(read(fd_of(the_DR.stream), s, bytes_per_sector));
    69.       if result /= bytes_per_sector then
    70.          raise emulation_failure
    71.             with "POSIX read failure in DR.get at sector" & the_index'Image & ", bytes read =" & result'Image;
    72.       end if;
    73.    end get;
    74.
    75.    procedure put (the_DR : in out DR.device; s : in sector; the_index : in KDF9.word) is
    76.       byte_address : constant POSIX.file_position := file_offset(the_index);
    77.       result       : POSIX.file_position;
    78.    begin
    79.       result := seek(fd_of(the_DR.stream), file_offset(the_index));
    80.       if result /= byte_address then
    81.          raise emulation_failure
    82.             with "POSIX seek failure in DR.put at" & the_index'Image & ", new position =" & result'Image;
    83.       end if;
    84.       result := POSIX.file_position(write(fd_of(the_DR.stream), s, bytes_per_sector));
    85.       if result /= bytes_per_sector then
    86.          raise emulation_failure
    87.             with "POSIX write failure in DR.put at" & the_index'Image & ", bytes written =" & result'Image;
    88.       end if;
    89.    end put;
    90.
    91.    overriding
    92.    procedure Initialize (the_DR : in out DR.device) is
    93.    begin
    94.       open(IOC.device(the_DR), rd_wr_mode);
    95.    exception
    96.       when others =>
    97.          trap_operator_error(the_DR.device_name, "cannot be opened for reading and writing");
    98.    end Initialize;
    99.
   100.    procedure keep_house (the_DR        : in out DR.device;
   101.                          transfer_size : in KDF9.word;
   102.                          busy_time     : out KDF9.us;
   103.                          from_core     : Boolean := True) is
   104.       full_sectors  : constant KDF9.word := transfer_size / bytes_per_sector;
   105.       residue       : constant KDF9.word := transfer_size mod bytes_per_sector;
   106.       total_sectors : constant KDF9.word := (if residue /= 0 then 1 else 0) + full_sectors;
   107.       gapping_time  : constant KDF9.word := short_gap_time * (total_sectors-1)
   108.                                           + long_gap_time  * (total_sectors/sectors_per_track);
   109.    begin
   110.       the_DR.latency_count := the_DR.latency_count + 1;
   111.       the_DR.word_count := the_DR.word_count + transfer_size / 8;
   112.       if from_core then
   113.          add_in_the_IO_CPU_time(the_DR, bytes_moved => transfer_size);
   114.       end if;
   115.       busy_time :=  KDF9.us(gapping_time +transfer_size * us_per_char);
   116.    end keep_house;
   117.
   118.    procedure update_statistics (the_DR       : in out DR.device;
   119.                                 latency_time : in KDF9.us) is
   120.    begin
   121.       the_DR.latency_time := the_DR.latency_time + latency_time;
   122.    end update_statistics;
   123.
   124.    function angular_position (sector_number : sector_range)
   125.    return KDF9.us
   126.    is (KDF9.us(sector_number mod sectors_per_track * sector_time));
   127.
   128.    function latent_time (index : drum_index)
   129.    return KDF9.us is
   130.       sector_number : constant sector_range := sector_range(index mod sectors_per_track);
   131.       new_angle     : constant KDF9.us      := angular_position(sector_number);
   132.       old_angle     : constant KDF9.us      := the_clock_time mod track_time;
   133.       gap_time      : constant KDF9.us
   134.                     := (if old_angle > critical_time then short_gap_time else long_gap_time);
   135.       offset        : constant KDF9.us
   136.                     := (if   new_angle > old_angle
   137.                         then new_angle - old_angle
   138.                         else new_angle + track_time - old_angle);
   139.    begin
   140.       -- Hypothesis: we can pick up the next complete sector without a full latency delay,
   141.       --    if we are no closer to it than the start of its preceding inter-block gap.
   142.       return (if offset > gap_time then offset else track_time - offset);
   143.    end latent_time;
   144.
   145.    procedure validate_the_sector_number (the_DR : in out DR.device; sector_number : in KDF9.word) is
   146.    begin
   147.       if sector_number > sectors_per_system then
   148.          trap_failing_IO_operation(the_DR, "sector number too big =" & sector_number'Image);
   149.       end if;
   150.    end validate_the_sector_number;
   151.
   152.    function validated_drum_address (the_DR : in out DR.device; C_operand : KDF9.Q_part)
   153.    return KDF9.word is
   154.       result : constant KDF9.word := KDF9.word(C_operand / 16);
   155.    begin
   156.       -- We assume that the least significant 4 bits of the C operand are the buffer number,
   157.       --    that the next 2 bits specify one of 4 drums that can be fitted to the buffer,
   158.       --       and that the rest of the C operand is the sector number.
   159.       -- See the Drum Director KKT02E003UPU listing, routine P143 at label 1 et seq.
   160.       -- Returning C_operand / 16 treats the drums as consecutive sectors.
   161.       validate_the_sector_number(the_DR, result);
   162.       return result;
   163.    end validated_drum_address;
   164.
   165.    procedure increment (word_address : in out KDF9.address;
   166.                         symbol_nr    : in out KDF9_char_sets.symbol_index)
   167.       with Inline => True;
   168.
   169.    procedure increment (word_address : in out KDF9.address;
   170.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   171.    begin
   172.       if symbol_nr < 7 then
   173.          symbol_nr := symbol_nr + 1;
   174.       else
   175.          symbol_nr := 0;
   176.          word_address := word_address + 1;
   177.       end if;
   178.    end increment;
   179.
   180.    procedure read_drum (the_DR    : in out DR.device;
   181.                         Q_operand : in KDF9.Q_register) is
   182.       end_address  : constant KDF9.address := Q_operand.M;
   183.       next_address : KDF9.address := Q_operand.I;
   184.       the_sector   : DR.sector := (others => Character'Val(0));
   185.       symbol_nr    : KDF9_char_sets.symbol_index;
   186.       size         : KDF9.word := 0;
   187.       the_index    : KDF9.word;
   188.       latency,
   189.       busy_time    : KDF9.us;
   190.    begin
   191.       check_addresses_and_lockouts(next_address, end_address);
   192.       the_index := validated_drum_address(the_DR, Q_operand.C);
   193.       latency := latent_time(the_index);
   194.       get(the_DR, the_sector, the_index);
   195.    sector_loop:
   196.       loop
   197.          if the_index > DR.drum_index'Last then
   198.             trap_failing_IO_operation(the_DR, "reading more would exceed the storage available");
   199.          end if;
   200.          symbol_nr := 0;
   201.       byte_loop:
   202.          for i in 1 .. bytes_per_sector loop
   203.             if symbol_nr = 0 then
   204.                store_word(0, next_address);
   205.             end if;
   206.             store_symbol(CN_TR(the_sector(i)), next_address, symbol_nr);
   207.             size := size + 1;
   208.          exit byte_loop when next_address = end_address and symbol_nr = 7;
   209.             increment(next_address, symbol_nr);
   210.          end loop byte_loop;
   211.       exit sector_loop when next_address = end_address and symbol_nr = 7;
   212.          validate_the_sector_number(the_DR, the_index);
   213.          get(the_DR, the_sector, the_index);
   214.          the_index := the_index + 1;
   215.       end loop sector_loop;
   216.       keep_house(the_DR, size, busy_time);
   217.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, input_operation);
   218.       update_statistics(the_DR, latency);
   219.       lock_out_relative_addresses(Q_operand);
   220.    end read_drum;
   221.
   222.    overriding
   223.    procedure PIA (the_DR      : in out DR.device;
   224.                   Q_operand   : in KDF9.Q_register;
   225.                   set_offline : in Boolean) is
   226.       pragma Unreferenced(set_offline);
   227.    begin
   228.       validate_transfer(the_DR, Q_operand);
   229.       validate_parity(the_DR);
   230.       read_drum(the_DR, Q_operand);
   231.    end PIA;
   232.
   233.    procedure read_drum_to_EM (the_DR    : in out DR.device;
   234.                               Q_operand : in KDF9.Q_register) is
   235.       end_address  : constant KDF9.address := Q_operand.M;
   236.       next_address : KDF9.address := Q_operand.I;
   237.       the_sector   : DR.sector := (others => Character'Val(0));
   238.       at_EM     : Boolean := False;
   239.       symbol_nr : KDF9_char_sets.symbol_index;
   240.       size      : KDF9.word := 0;
   241.       the_index : KDF9.word;
   242.       latency,
   243.       busy_time : KDF9.us;
   244.    begin
   245.       check_addresses_and_lockouts(next_address, end_address);
   246.       the_index := validated_drum_address(the_DR, Q_operand.C);
   247.       latency := latent_time(the_index);
   248.       get(the_DR, the_sector, the_index);
   249.    sector_loop:
   250.       loop
   251.          if the_index > DR.drum_index'Last then
   252.             trap_failing_IO_operation(the_DR, "reading more would exceed the storage available");
   253.          end if;
   254.          symbol_nr := 0;
   255.       byte_loop:
   256.          for i in 1 .. bytes_per_sector loop
   257.             if symbol_nr = 0 then
   258.                store_word(0, next_address);
   259.             end if;
   260.             store_symbol(CN_TR(the_sector(i)), next_address, symbol_nr);
   261.             size := size + 1;
   262.          at_EM := the_sector(i) = KDF9_char_sets.E_M;
   263.          exit byte_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   264.             increment(next_address, symbol_nr);
   265.          end loop byte_loop;
   266.          exit sector_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   267.          validate_the_sector_number(the_DR, the_index);
   268.          get(the_DR, the_sector, the_index);
   269.          the_index := the_index + 1;
   270.       end loop sector_loop;
   271.       keep_house(the_DR, size, busy_time);
   272.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, input_operation);
   273.       lock_out_relative_addresses(Q_operand);
   274.       update_statistics(the_DR, latency);
   275.    end read_drum_to_EM;
   276.
   277.    overriding
   278.    procedure PIB (the_DR      : in out DR.device;
   279.                   Q_operand   : in KDF9.Q_register;
   280.                   set_offline : in Boolean) is
   281.        pragma Unreferenced(set_offline);
   282.   begin
   283.       validate_transfer(the_DR, Q_operand);
   284.       validate_parity(the_DR);
   285.       read_drum_to_EM(the_DR, Q_operand);
   286.    end PIB;
   287.
   288.    overriding
   289.    procedure PIC (the_DR      : in out DR.device;
   290.                   Q_operand   : in KDF9.Q_register;
   291.                   set_offline : in Boolean) is
   292.    begin
   293.       PIA(the_DR, Q_operand, set_offline);
   294.    end PIC;
   295.
   296.    overriding
   297.    procedure PID (the_DR      : in out DR.device;
   298.                   Q_operand   : in KDF9.Q_register;
   299.                   set_offline : in Boolean) is
   300.    begin
   301.       PIB(the_DR, Q_operand, set_offline);
   302.    end PID;
   303.
   304.    overriding
   305.    procedure PIE (the_DR      : in out DR.device;
   306.                   Q_operand   : in KDF9.Q_register;
   307.                   set_offline : in Boolean) is
   308.    begin
   309.       PIA(the_DR, Q_operand, set_offline);
   310.    end PIE;
   311.
   312.    overriding
   313.    procedure PIF (the_DR      : in out DR.device;
   314.                   Q_operand   : in KDF9.Q_register;
   315.                   set_offline : in Boolean) is
   316.    begin
   317.       PIB(the_DR, Q_operand, set_offline);
   318.    end PIF;
   319.
   320.    overriding
   321.    procedure PIG (the_DR      : in out DR.device;
   322.                   Q_operand   : in KDF9.Q_register;
   323.                   set_offline : in Boolean) is
   324.    begin
   325.       PIA(the_DR, Q_operand, set_offline);
   326.    end PIG;
   327.
   328.    overriding
   329.    procedure PIH (the_DR      : in out DR.device;
   330.                   Q_operand   : in KDF9.Q_register;
   331.                   set_offline : in Boolean) is
   332.    begin
   333.       PIB(the_DR, Q_operand, set_offline);
   334.    end PIH;
   335.
   336.    procedure write_drum (the_DR    : in out DR.device;
   337.                          Q_operand : in KDF9.Q_register) is
   338.       end_address  : constant KDF9.address := Q_operand.M;
   339.       next_address : KDF9.address := Q_operand.I;
   340.       the_sector   : DR.sector := (others => Character'Val(0));
   341.       symbol_nr : KDF9_char_sets.symbol_index;
   342.       size      : KDF9.word := 0;
   343.       the_index : KDF9.word;
   344.       latency,
   345.       busy_time : KDF9.us;
   346.    begin
   347.       check_addresses_and_lockouts(next_address, end_address);
   348.       the_index := validated_drum_address(the_DR, Q_operand.C);
   349.       latency := latent_time(the_index);
   350.    sector_loop:
   351.       loop
   352.          symbol_nr := 0;
   353.       byte_loop:
   354.          for i in 1 .. bytes_per_sector loop
   355.             the_sector(i) := TP_CN(fetch_symbol(next_address, symbol_nr));
   356.             size := size + 1;
   357.          exit byte_loop when next_address = end_address and symbol_nr = 7;
   358.             increment(next_address, symbol_nr);
   359.          end loop byte_loop;
   360.          validate_the_sector_number(the_DR, the_index);
   361.          put(the_DR, the_sector, the_index);
   362.       exit sector_loop when next_address = end_address and symbol_nr = 7;
   363.          if the_index = DR.drum_index'Last then
   364.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   365.          else
   366.             the_index := the_index + 1;
   367.          end if;
   368.       end loop sector_loop;
   369.       keep_house(the_DR, size, busy_time);
   370.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   371.       lock_out_relative_addresses(Q_operand);
   372.       update_statistics(the_DR, latency);
   373.    end write_drum;
   374.
   375.    overriding
   376.    procedure POA (the_DR      : in out DR.device;
   377.                   Q_operand   : in KDF9.Q_register;
   378.                   set_offline : in Boolean) is
   379.       pragma Unreferenced(set_offline);
   380.    begin
   381.       validate_transfer(the_DR, Q_operand);
   382.       validate_parity(the_DR);
   383.       write_drum(the_DR, Q_operand);
   384.    end POA;
   385.
   386.    procedure write_drum_to_EM (the_DR    : in out DR.device;
   387.                                Q_operand : in KDF9.Q_register) is
   388.       end_address  : constant KDF9.address := Q_operand.M;
   389.       next_address : KDF9.address := Q_operand.I;
   390.       the_sector   : DR.sector := (others => Character'Val(0));
   391.       at_EM     : Boolean := False;
   392.       size      : KDF9.word := 0;
   393.       symbol_nr : KDF9_char_sets.symbol_index;
   394.       the_index : KDF9.word;
   395.       latency,
   396.       busy_time : KDF9.us;
   397.    begin
   398.       check_addresses_and_lockouts(next_address, end_address);
   399.       the_index := validated_drum_address(the_DR, Q_operand.C);
   400.       latency := latent_time(the_index);
   401.    sector_loop:
   402.       loop
   403.          if the_index > DR.drum_index'Last then
   404.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   405.          end if;
   406.          symbol_nr := 0;
   407.       byte_loop:
   408.          for i in 1 .. bytes_per_sector loop
   409.             the_sector(i) := TP_CN(fetch_symbol(next_address, symbol_nr));
   410.             size := size + 1;
   411.          at_EM := the_sector(i) = KDF9_char_sets.E_M;
   412.          exit byte_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   413.             increment(next_address, symbol_nr);
   414.          end loop byte_loop;
   415.          validate_the_sector_number(the_DR, the_index);
   416.          put(the_DR, the_sector, the_index);
   417.          exit sector_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   418.          the_index := the_index + 1;
   419.       end loop sector_loop;
   420.       keep_house(the_DR, size, busy_time);
   421.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   422.       lock_out_relative_addresses(Q_operand);
   423.       update_statistics(the_DR, latency);
   424.    end write_drum_to_EM;
   425.
   426.    overriding
   427.    procedure POB (the_DR      : in out DR.device;
   428.                   Q_operand   : in KDF9.Q_register;
   429.                   set_offline : in Boolean) is
   430.       pragma Unreferenced(set_offline);
   431.    begin
   432.       validate_transfer(the_DR, Q_operand);
   433.       validate_parity(the_DR);
   434.       write_drum_to_EM(the_DR, Q_operand);
   435.    end POB;
   436.
   437.    overriding
   438.    procedure POC (the_DR      : in out DR.device;
   439.                   Q_operand   : in KDF9.Q_register;
   440.                   set_offline : in Boolean) is
   441.    begin
   442.       POA(the_DR, Q_operand, Set_offline);
   443.    end POC;
   444.
   445.    overriding
   446.    procedure POD (the_DR      : in out DR.device;
   447.                   Q_operand   : in KDF9.Q_register;
   448.                   set_offline : in Boolean) is
   449.    begin
   450.       POB(the_DR, Q_operand, Set_offline);
   451.    end POD;
   452.
   453.    procedure write_zeroes (the_DR      : in out DR.device;
   454.                            Q_operand   : in KDF9.Q_register;
   455.                            set_offline : in Boolean) is
   456.       pragma Unreferenced(set_offline);
   457.       start_address : constant KDF9.address := Q_operand.I;
   458.       end_address   : constant KDF9.address := Q_operand.M;
   459.       the_sector    : constant DR.sector := (others => Character'Val(0));
   460.       size      : KDF9.word := 0;
   461.       the_index : KDF9.word;
   462.       latency,
   463.       busy_time : KDF9.us;
   464.    begin
   465.       check_addresses_and_lockouts(start_address, end_address);
   466.       the_index := validated_drum_address(the_DR, Q_operand.C);
   467.       latency := latent_time(the_index);
   468.       for s in 1 .. (KDF9.word(end_address) - KDF9.word(start_address) + 128) / 128 loop
   469.          if the_index > DR.drum_index'Last then
   470.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   471.          end if;
   472.          validate_the_sector_number(the_DR, the_index);
   473.          put(the_DR, the_sector, the_index);
   474.          size := size + bytes_per_sector;
   475.          the_index := the_index + 1;
   476.       end loop;
   477.       keep_house(the_DR, size, busy_time, from_core => False);
   478.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   479.       lock_out_relative_addresses(Q_operand);
   480.       update_statistics(the_DR, latency);
   481.    end write_zeroes;
   482.
   483.    overriding
   484.    procedure POE (the_DR      : in out DR.device;
   485.                   Q_operand   : in KDF9.Q_register;
   486.                   set_offline : in Boolean) is
   487.    begin
   488.       validate_transfer(the_DR, Q_operand);
   489.       write_zeroes(the_DR, Q_operand, set_offline);
   490.    end POE;
   491.
   492.    overriding
   493.    procedure POF (the_DR      : in out DR.device;
   494.                   Q_operand   : in KDF9.Q_register;
   495.                   set_offline : in Boolean) is
   496.    begin
   497.       POE(the_DR, Q_operand, Set_offline);
   498.    end POF;
   499.
   500.    overriding
   501.    procedure Finalize (the_DR : in out DR.device) is
   502.       transfer_time : constant KDF9.us := KDF9.us(the_DR.word_count * 8 * us_per_char);
   503.    begin
   504.       if the_DR.is_open then
   505.
   506.          if (the_final_state_is_wanted and the_log_is_wanted)    and then
   507.                (the_DR.word_count /= 0 or the_DR.latency_count /= 0) then
   508.             log_line
   509.                 (
   510.                  the_DR.device_name
   511.                & " on buffer #"
   512.                & oct_of(KDF9.Q_part(the_DR.number), 2)
   513.                & " spent:"
   514.                 );
   515.             log_line
   516.                 (
   517.                  "    "
   518.                & just_right(KDF9.us'Image(transfer_time / 1_000), 6)
   519.                & " ms in"
   520.                & the_DR.latency_count'Image
   521.                & " data transfer" & plurality(the_DR.latency_count)
   522.                & " totalling"
   523.                & KDF9.word'Image(the_DR.word_count)
   524.                & " word" & plurality(the_DR.word_count)
   525.                & ", and"
   526.                 );
   527.             log_line
   528.                 (
   529.                  "    "
   530.                & just_right(KDF9.us'Image(the_DR.latency_time / 1_000), 6)
   531.                & " ms in"
   532.                & the_DR.latency_count'Image
   533.                & plurality(the_DR.latency_count, " rotational latency.", " rotational latencies.")
   534.                 );
   535.          end if;
   536.
   537.          close(IOC.device(the_DR));
   538.       end if;
   539.    end Finalize;
   540.
   541.    DR_quantum : constant := us_per_char;
   542.
   543.    type DR_access is access DR.device;
   544.
   545.    DR0 : DR_access with Warnings => Off;
   546.
   547.    procedure enable (b : in KDF9.buffer_number) is
   548.    begin
   549.       if is_enabled then trap_operator_error("DR:", "more than one unit specified"); end if;
   550.       DR0 := new DR.device (number  => b,
   551.                             kind    => DR_kind,
   552.                             unit    => 0,
   553.                             quantum => DR_quantum);
   554.       is_enabled := True;
   555.       DR0_number := b;
   556.    end enable;
   557.
   558.    procedure re_enable (b : in KDF9.buffer_number) is
   559.    begin
   560.       if is_enabled and then
   561.          b = DR0.number then
   562.          return;
   563.       end if;
   564.       buffer(b) := null;
   565.       enable(b);
   566.    end re_enable;
   567.
   568. end IOC.fast.DR;

Compiling: ../Source/ioc-fast-dr.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:29

     1. -- ioc-fast-dr.ads
     2. --
     3. -- Emulation of a drum store buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.fast.DR is
    20.
    21.    type device is new IOC.fast.device with private;
    22.
    23.    overriding
    24.    procedure PIA (the_DR      : in out DR.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    overriding
    29.    procedure PIB (the_DR      : in out DR.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    overriding
    34.    procedure PIC (the_DR      : in out DR.device;
    35.                   Q_operand   : in KDF9.Q_register;
    36.                   set_offline : in Boolean);
    37.
    38.    overriding
    39.    procedure PID (the_DR      : in out DR.device;
    40.                   Q_operand   : in KDF9.Q_register;
    41.                   set_offline : in Boolean);
    42.
    43.    overriding
    44.    procedure PIE (the_DR      : in out DR.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    overriding
    49.    procedure PIF (the_DR      : in out DR.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    overriding
    54.    procedure PIG (the_DR      : in out DR.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    overriding
    59.    procedure PIH (the_DR      : in out DR.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63. -- PMA-PML, and POG-POL are inherited, as they have no new semantics for the drum.
    64.
    65.    overriding
    66.    procedure POA (the_DR      : in out DR.device;
    67.                   Q_operand   : in KDF9.Q_register;
    68.                   set_offline : in Boolean);
    69.
    70.    overriding
    71.    procedure POB (the_DR      : in out DR.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    overriding
    76.    procedure POC (the_DR      : in out DR.device;
    77.                   Q_operand   : in KDF9.Q_register;
    78.                   set_offline : in Boolean);
    79.    overriding
    80.    procedure POD (the_DR      : in out DR.device;
    81.                   Q_operand   : in KDF9.Q_register;
    82.                   set_offline : in Boolean);
    83.
    84.    overriding
    85.    procedure POE (the_DR      : in out DR.device;
    86.                   Q_operand   : in KDF9.Q_register;
    87.                   set_offline : in Boolean);
    88.
    89.    overriding
    90.    procedure POF (the_DR      : in out DR.device;
    91.                   Q_operand   : in KDF9.Q_register;
    92.                   set_offline : in Boolean);
    93.
    94.    procedure enable (b : in KDF9.buffer_number);
    95.
    96.    procedure re_enable (b : in KDF9.buffer_number);
    97.
    98.    is_enabled         : Boolean := False;
    99.
   100.    DR0_number         : KDF9.buffer_number;
   101.
   102.    function as_DR_command (Q_operand : KDF9.Q_register; for_OUT : Boolean := False)
   103.    return String;
   104.
   105. private
   106.
   107.    -- For what little we know from EE of the drum geometry, see the Manual, App. 6, §4.
   108.    -- An additional and more helpful source is the SRLM, §103, Appendix 2, p.10-59-0,
   109.    --   which describes the drum used with the non-Time Sharing Director.
   110.    -- It says:
   111.    --   Drum revolution time     = 20.4   ms
   112.    --   Transfer time per sector =  2.15  ms
   113.    --   Short gap time           =  0.034 ms between successive sectors
   114.    --   Long gap time            =  2.97  ms after every 8th sector
   115.    -- Hence: Mean time per sector = revolution time/8 - short gap time - long gap time/8
   116.    --                             = 20.4 ms / 8       - 0.034          - 2.970 / 8
   117.    --                             = 2.145 ms, rounding correctly to 2.15 ms
   118.    -- This confirms 8 sectors per track, or 8192 characters per track, for 40 tracks per drum.
   119.
   120.    bytes_per_sector   : constant := 1024;
   121.    subtype byte_range is KDF9.word range 0 .. bytes_per_sector - 1;
   122.    subtype sector     is String(1..bytes_per_sector);
   123.
   124.    sectors_per_track  : constant := 8;
   125.    subtype sector_range is KDF9.word range 0 .. sectors_per_track - 1;
   126.
   127.    sectors_per_drum   : constant := 320;
   128.    drums_per_system   : constant := 4;
   129.    sectors_per_system : constant := sectors_per_drum * drums_per_system;
   130.    subtype drum_index is KDF9.word range 0 .. sectors_per_system - 1;
   131.
   132.    tracks_per_system   : constant := sectors_per_system / sectors_per_track;
   133.    subtype track_range is KDF9.word range 0 .. tracks_per_system - 1;
   134.
   135.    data_rate      : constant := 477_445;         -- chars/s
   136.    us_per_char    : constant := 1E6 / data_rate; -- ~2.1 µs/char
   137.
   138.    -- The following times are in microseconds.
   139.    short_gap_time : constant := 34;
   140.    sector_time    : constant := bytes_per_sector * us_per_char + short_gap_time;
   141.    long_gap_time  : constant := 2_970;
   142.    track_time     : constant := sector_time * sectors_per_track + long_gap_time;
   143.    critical_time  : constant := sector_time * (sectors_per_track-1) - short_gap_time;
   144.
   145.    type drum is array (drum_index) of DR.sector;
   146.
   147.    type device is new IOC.fast.device with null record;
   148.
   149.    overriding
   150.    procedure Initialize (the_DR : in out DR.device);
   151.
   152.    overriding
   153.    procedure Finalize (the_DR : in out DR.device);
   154.
   155. end IOC.fast.DR;

 568 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-fast-fd.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:29

     1. -- ioc-fast-fd.adb
     2. --
     3. -- Emulation of a (fixed-platter) disc drive.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Exceptions;
    20. --
    21. with formatting;
    22. with HCI;
    23. with tracing;
    24.
    25. use formatting;
    26. use  HCI;
    27. use  tracing;
    28.
    29. package body IOC.fast.FD is
    30.
    31.    use KDF9_char_sets;
    32.
    33.    function as_FD_command (Q_operand : KDF9.Q_register; for_seek, for_FH : Boolean := False)
    34.    return String is
    35.       parameter : constant KDF9.Q_part := Q_operand.C / 16;
    36.       cylinder  : constant KDF9.Q_part := parameter mod seek_areas_per_platter;
    37.       residue   : constant KDF9.Q_part := parameter  /  seek_areas_per_platter;
    38.       platter   : constant KDF9.Q_part := residue mod main_discs_per_drive;
    39.       drive     : constant KDF9.Q_part := residue  /  main_discs_per_drive;
    40.    begin
    41.       -- The disc geometry and I/O command bits are as defined in the FD package.
    42.       if for_seek then
    43.          return "D" & dec_of(drive)
    44.               & "P" & dec_of(if for_FH then KDF9.Q_part'(the_fixed_head_platter) else platter)
    45.               & "C" & dec_of(cylinder);
    46.       else -- for data transfer, parameter is sector #, with maximum 96 sectors per track.
    47.          return " S" & (if parameter < 10 then "0" else "") & dec_of(parameter);
    48.       end if;
    49.    end as_FD_command;
    50.
    51.    overriding
    52.    procedure Initialize (the_FD : in out FD.device) is
    53.    begin
    54.       open(the_FD, rd_wr_mode);
    55.    exception
    56.       when others =>
    57.          trap_operator_error(the_FD.device_name, "cannot be opened for reading and writing");
    58.    end Initialize;
    59.
    60.    -- Hypothesis:
    61.    -- Where a specification of the Fixed Disc subsystem cannot be inferred from extant software,
    62.    -- such as the Eldon 2 Director, or the EE KDF9 Programming Manual,
    63.    -- then it is reasonable to extrapolate from the Data Products Corporation documents:
    64.    --    "SPECIFICATION FOR MODEL 5022 DISCfILE STORAGE SYSTEM", of December 1964, and
    65.    --    "GENERAL INFORMATION MANUAL dp/f-5022 DISCfILE STORAGE SYSTEM", of March 1965,
    66.    -- which describe an (at least) very similar model.
    67.    -- These document are referred to herein as "GIM".
    68.    -- Confirmation of much of this material has been gained from the ICT document:
    69.    --    "Data Disc Store 1956", of September 1964",
    70.    -- which describes the same device, offered as a fixed disc drive for the 1900 Series.
    71.    -- All three depict the drive as having a different division of tracks into sectors.
    72.
    73.    -- Hypothesis:
    74.    -- The locus is set by a PMA or PMD operation; the sector number is updated by a transfer.
    75.
    76.    -- Hypothesis:
    77.    -- A PMA or PMD command sets the sector number to 0.
    78.
    79.    -- Hypothesis:
    80.    -- If a transfer would increase the sector number past 95, the end-of-area flag is set,
    81.    --    and the sector number is set to 95.
    82.
    83.    function locus_from (Q_operand : KDF9.Q_register)
    84.    return FD.locus is
    85.       parameter : constant KDF9.Q_part := Q_operand.C / 16; -- remove the buffer number
    86.       seek_area : constant KDF9.Q_part := parameter mod seek_areas_per_platter;
    87.       platter   : constant KDF9.Q_part
    88.                 := parameter / seek_areas_per_platter mod platters_per_drive;
    89.       drive     : constant KDF9.Q_part
    90.                 := parameter / seek_areas_per_platter / platters_per_drive;
    91.    begin
    92.       -- Hypothesis:
    93.       -- Seeking to a new locus zeroizes the sector number and clears the end-of-area flag.
    94.       return (
    95.               drive_number      => drive,
    96.               platter_number    => platter,
    97.               seek_area_number  => seek_area,
    98.               sector_number     => 0,
    99.               has_fixed_heads   => False,
   100.               is_at_end_of_area => False
   101.              );
   102.    end locus_from;
   103.
   104.    function sector_span (Q_operand : KDF9.Q_register)
   105.    return KDF9.Q_part
   106.    is ((Q_operand.M - Q_operand.I + words_per_sector - 1) / words_per_sector);
   107.
   108.    procedure advance_the_sector_number (the_FD : in out FD.device) is
   109.    begin
   110.       if the_FD.locus.sector_number = FD.sector_range'Last then
   111.          the_FD.locus.is_at_end_of_area := True;
   112.       else
   113.          the_FD.locus.is_at_end_of_area := False;
   114.          the_FD.locus.sector_number := the_FD.locus.sector_number + 1;
   115.       end if;
   116.    end advance_the_sector_number;
   117.
   118.    procedure set_the_new_sector_number (the_FD    : in out FD.device;
   119.                                     Q_operand : in KDF9.Q_register) is
   120.       the_sector_number : constant KDF9.Q_part := (Q_operand.C / 16) and 8#177#;
   121.    begin
   122.       if the_sector_number in FD.sector_range then
   123.          the_FD.locus.is_at_end_of_area := False;
   124.          the_FD.locus.sector_number := the_sector_number;
   125.       else
   126.          the_FD.locus.is_at_end_of_area := True;
   127.          the_FD.locus.sector_number := FD.sector_range'Last;
   128.       end if;
   129.    end set_the_new_sector_number;
   130.
   131.    sectors_per_platter : constant := sectors_per_seek_area * seek_areas_per_platter;
   132.    sectors_per_drive   : constant := platters_per_drive  * sectors_per_platter;
   133.
   134.    function file_offset (locus : FD.locus)
   135.    return POSIX.file_position
   136.    is (
   137.        bytes_per_sector *
   138.                         ( POSIX.file_position(locus.drive_number)     * sectors_per_drive
   139.                         + POSIX.file_position(locus.platter_number)   * sectors_per_platter
   140.                         + POSIX.file_position(locus.seek_area_number) * sectors_per_seek_area
   141.                         + POSIX.file_position(locus.sector_number)    * 1
   142.                         )
   143.       );
   144.
   145.    function disc_busy_time (first : FD.sector_range; size : KDF9.word)
   146.    return KDF9.us is
   147.
   148.       function ceiling (first : FD.sector_range; size : KDF9.word)
   149.       return FD.sector_range is
   150.          length : constant KDF9.Q_part := sector_span((0, 1, KDF9.Q_part(size)));
   151.       begin
   152.          return FD.sector_range'Min(first + length - 1, FD.sector_range'Last);
   153.       end ceiling;
   154.
   155.       function time_for (bytes : KDF9.word; in_outer_zone : Boolean)
   156.       return KDF9.word
   157.       is (1E6 * bytes / (if in_outer_zone then outer_rate else inner_rate));
   158.
   159.       boundary   : constant := sectors_per_seek_area / 3 * 2;
   160.       last       : constant FD.sector_range := ceiling(first, size);
   161.       bytes_left : KDF9.word := size * 8;
   162.       total_time : KDF9.word := 0;
   163.
   164.    begin
   165.       for s in first .. last loop
   166.       exit when bytes_left < bytes_per_sector;
   167.          total_time := total_time + time_for(bytes_per_sector, in_outer_zone => s < boundary);
   168.          bytes_left := bytes_left - bytes_per_sector;
   169.       end loop;
   170.       if bytes_left /= 0 then
   171.          total_time := total_time + time_for(bytes_left, in_outer_zone => last < boundary);
   172.       end if;
   173.       return KDF9.us(total_time);
   174.    end disc_busy_time;
   175.
   176.    -- The rotational position of the disc is measured in term of the time,
   177.    --    in microseconds, taken to get to that position from sector 0.
   178.
   179.    rotation_time : constant := 60E3;  -- 1000 RPM => 60 ms = 60_000 KDF9.us
   180.    track_size    : constant := 16;    -- There are only 8 sectors per track in the inner zone.
   181.    sector_time   : constant := rotation_time / track_size;
   182.
   183.    function angular_position (sector_number : FD.sector_range)
   184.    return KDF9.us
   185.    is (-- This is <= rotation_time.
   186.        if sector_number < sectors_in_outer_zone then
   187.           KDF9.us(sector_number * sector_time)
   188.        else
   189.           -- Inner zone sectors are twice as long as in the outer zone.
   190.           -- Assumes (without evidence) that the inner zone is offset 1/2 sector from the outer.
   191.           KDF9.us((sector_number - sectors_in_outer_zone) * sector_time * 2 - sector_time/2)
   192.       );
   193.
   194.    function latent_time (the_FD : FD.device; latency_start_time : in KDF9.us)
   195.    return KDF9.us is
   196.       new_angle  : constant KDF9.us := angular_position(the_FD.locus.sector_number);
   197.       old_angle  : constant KDF9.us := latency_start_time mod rotation_time;
   198.       offset     : constant KDF9.us
   199.                  := (if   new_angle > old_angle
   200.                      then new_angle - old_angle
   201.                      else new_angle + rotation_time - old_angle);
   202.    begin
   203.       -- According to GIM, the minimum latency is one sector;
   204.       --    if less we have to go all the way around.
   205.       return (if offset > sector_time then offset else rotation_time - offset );
   206.    end latent_time;
   207.
   208.    -- These times come from the Manual, §6.1, and from GIM.
   209.    checking_time  : constant :=   47E3;
   210.    min_seek_time  : constant :=  109E3;
   211.    max_seek_time  : constant :=  321E3;
   212.    per_track_time : constant KDF9.us
   213.                   := KDF9.us(max_seek_time - min_seek_time) / seek_areas_per_platter;
   214.
   215.    -- A seek distance of 1 takes the minimum seek time: zero_seek_time + per_track_time.
   216.    zero_seek_time : constant KDF9.us := min_seek_time - per_track_time;
   217.
   218.    subtype seek_time_range is KDF9.us range 0 .. max_seek_time + checking_time;
   219.
   220.    function arm_seek_time (the_FD : FD.device)
   221.    return seek_time_range is
   222.       next   : FD.locus renames the_FD.target;
   223.       drive  : FD.drive_range renames next.drive_number;
   224.       here   : constant FD.seek_area_range := the_FD.comb(drive, next.platter_number);
   225.       there  : constant FD.seek_area_range := next.seek_area_number;
   226.       span   : constant FD.seek_area_range := (if here > there then here - there else there - here);
   227.       cost   : constant KDF9.us := KDF9.us(span) * per_track_time;
   228.    begin
   229.       if cost > 0 and next.platter_number /= the_fixed_head_platter then
   230.          -- Hypothesis:
   231.          return KDF9.us'Min(zero_seek_time + cost, max_seek_time) + checking_time;
   232.       else
   233.          -- Hypothesis:
   234.          -- A seek to the present position takes no time.
   235.          return 0;
   236.       end if;
   237.    end arm_seek_time;
   238.
   239.    -- These times come from GIM.
   240.    -- A switch to a different platter takes 26 ms on average, as specified in GIM.
   241.    -- This time is needed to power-down then power-up the arm actuators for the R/W heads.
   242.    drive_switch_time : constant :=  5_000;
   243.    arm_switch_time   : constant := 26_000;
   244.
   245.    function platter_switch_time (the_FD : FD.device)
   246.    return KDF9.us is
   247.       the_drive_time : KDF9.us;
   248.    begin
   249.       if the_FD.target.drive_number /= the_FD.locus.drive_number then
   250.          the_drive_time := drive_switch_time;
   251.       else
   252.          the_drive_time := 0;
   253.       end if;
   254.       -- Hypothesis:
   255.       -- Operating successively on the current platter, or working on the fixed-head platter,
   256.       --    incurs no arm switch time.
   257.       if the_FD.target.platter_number = the_FD.locus.platter_number or else
   258.             the_FD.target.platter_number = the_fixed_head_platter      then
   259.           return the_drive_time;
   260.        else
   261.           return the_drive_time + arm_switch_time;
   262.       end if;
   263.    end platter_switch_time;
   264.
   265.    procedure set_seek_target (the_FD       : in out FD.device;
   266.                               Q_operand    : in KDF9.Q_register;
   267.                               it_will_seek : out Boolean) is
   268.       here : FD.locus renames the_FD.locus;
   269.       next : FD.locus renames the_FD.target;
   270.    begin
   271.       it_will_seek := False;
   272.       next := locus_from(Q_operand);
   273.       next.has_fixed_heads := False;
   274.       if next.platter_number /= here.platter_number then
   275.          the_FD.switch_count := the_FD.switch_count +1;
   276.       end if;
   277.       if the_FD.comb(next.drive_number, here.platter_number) /= next.seek_area_number then
   278.          the_FD.seek_count := the_FD.seek_count + 1;
   279.          it_will_seek := True;
   280.       end if;
   281.     end set_seek_target;
   282.
   283.    procedure seek_to_the_target_area (the_FD      : in out FD.device;
   284.                                       seek_time,
   285.                                       switch_time : out seek_time_range) is
   286.       here : FD.locus renames the_FD.locus;
   287.       next : FD.locus renames the_FD.target;
   288.    begin
   289.       seek_time := arm_seek_time(the_FD);
   290.       switch_time := platter_switch_time(the_FD);
   291.       here := the_FD.target;
   292.       the_FD.comb(here.drive_number, here.platter_number) := next.seek_area_number;
   293.     end seek_to_the_target_area;
   294.
   295.    subtype sector_image is String(1 .. bytes_per_sector);
   296.
   297.    empty_sector : constant sector_image := (others => ' ');
   298.    this_sector  : sector_image;
   299.
   300.    procedure get_next_sector (the_FD : in out FD.device) is
   301.       byte_address : constant POSIX.file_position := file_offset(the_FD.locus);
   302.       byte_count   : Integer;
   303.    begin
   304.       if seek(fd_of(the_FD.stream), byte_address) /= byte_address then
   305.          raise emulation_failure with "POSIX seek failure in FD.get_next_sector";
   306.       end if;
   307.       byte_count := read(fd_of(the_FD.stream), this_sector, bytes_per_sector);
   308.       if byte_count /= bytes_per_sector and then  -- A short transfer ..
   309.             byte_count /= 0                 then  -- ... is OK at EOF with a 0 count.
   310.          raise emulation_failure with "POSIX read failure in FD.get_next_sector";
   311.       end if;
   312.       the_FD.sector_count := the_FD.sector_count + 1;
   313.       advance_the_sector_number(the_FD);
   314.
   315.    end get_next_sector;
   316.
   317.    procedure keep_house (the_FD        : in out FD.device;
   318.                          transfer_size : in KDF9.word;
   319.                          busy_time     : out KDF9.us) is
   320.    begin
   321.       the_FD.latency_count := the_FD.latency_count + 1;
   322.       the_FD.word_count := the_FD.word_count + transfer_size;
   323.       add_in_the_IO_CPU_time(the_FD, bytes_moved => transfer_size*8);
   324.       busy_time := disc_busy_time(the_FD.locus.sector_number, transfer_size);
   325.    end keep_house;
   326.
   327.    procedure update_statistics (the_FD        : in out FD.device;
   328.                                 switch_time,
   329.                                 seek_time,
   330.                                 latency_time,
   331.                                 data_time     : in KDF9.us := 0) is
   332.    begin
   333.       the_FD.switch_time := the_FD.switch_time + switch_time;
   334.       the_FD.seek_time := the_FD.seek_time + seek_time;
   335.       the_FD.latency_time := the_FD.latency_time + latency_time;
   336.       the_FD.data_time := the_FD.data_time + data_time;
   337.       the_FD.elapsed_time := the_FD.elapsed_time
   338.                                  + switch_time
   339.                                  + seek_time
   340.                                  + latency_time
   341.                                  + data_time;
   342.     end update_statistics;
   343.
   344.    procedure read (the_FD        : in out FD.device;
   345.                    start_address,
   346.                    end_address   : in  KDF9.address;
   347.                    busy_time     : out KDF9.us;
   348.                    reading_to_EM : in  Boolean := False) is
   349.       size : KDF9.word := 0;
   350.       next : Natural := 0;
   351.       char : Character;
   352.    begin
   353.       check_addresses_and_lockouts(start_address, end_address);
   354.    word_loop:
   355.       for w in start_address .. end_address loop
   356.          if size mod bytes_per_sector = 0 then
   357.             this_sector := empty_sector;
   358.             get_next_sector(the_FD);
   359.          exit word_loop when the_FD.locus.is_at_end_of_area;
   360.             next := 0;
   361.          end if;
   362.          for c in KDF9_char_sets.symbol_index'Range loop
   363.             next := next + 1;
   364.             char := this_sector(next);
   365.             store_symbol(CN_TR(char), w, c);
   366.             size := size + 1;
   367.          exit word_loop when reading_to_EM and char = E_M;
   368.          end loop;
   369.       end loop word_loop;
   370.       keep_house(the_FD, (size+7)/8, busy_time);
   371.    end read;
   372.
   373.    procedure PI_all (the_FD         : in out FD.device;
   374.                      Q_operand      : in KDF9.Q_register;
   375.                      transfer_to_EM : in Boolean := False) is
   376.       the_present_time   : constant KDF9.us := the_clock_time;
   377.       latency_start_time : KDF9.us;
   378.       seek_duration,
   379.       switch_duration,
   380.       latency_duration,
   381.       data_duration,
   382.       total_duration     : KDF9.us;
   383.    begin
   384.       validate_device(the_FD, Q_operand);
   385.       validate_parity(the_FD);
   386.       seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   387.       set_the_new_sector_number(the_FD, Q_operand);
   388.       latency_start_time := the_present_time + seek_duration + switch_duration;
   389.       latency_duration := latent_time(the_FD, latency_start_time);
   390.
   391.       if the_FD.locus.is_at_end_of_area then
   392.          -- Cannot transfer past the last sector in a seek area.
   393.          trap_failing_IO_operation(the_FD, "attempt to read FD at the end of a seek area");
   394.       end if;
   395.
   396.       -- Read from the newly established position.
   397.       read(
   398.            the_FD,
   399.            Q_operand.I, Q_operand.M,
   400.            data_duration,
   401.            reading_to_EM => transfer_to_EM
   402.           );
   403.
   404.       total_duration := seek_duration + switch_duration + latency_duration + data_duration;
   405.       start_data_transfer(the_FD, Q_operand, False, total_duration, input_operation);
   406.       lock_out_relative_addresses(Q_operand);
   407.       update_statistics(
   408.                         the_FD,
   409.                         switch_time  => switch_duration,
   410.                         seek_time    => seek_duration,
   411.                         latency_time => latency_duration,
   412.                         data_time    => data_duration
   413.                        );
   414.    end PI_all;
   415.
   416.    overriding
   417.    procedure PIA (the_FD      : in out FD.device;
   418.                   Q_operand   : in KDF9.Q_register;
   419.                   set_offline : in Boolean) is
   420.       pragma Unreferenced(set_offline);
   421.    begin
   422.       PI_all(the_FD, Q_operand);
   423.    end PIA;
   424.
   425.    overriding
   426.    procedure PIB (the_FD      : in out FD.device;
   427.                   Q_operand   : in KDF9.Q_register;
   428.                   set_offline : in Boolean) is
   429.       pragma Unreferenced(set_offline);
   430.    begin
   431.       PI_all(the_FD, Q_operand, transfer_to_EM => True);
   432.    end PIB;
   433.
   434.    -- Set up FD parameters for a transfer in the fixed-head platter.
   435.    procedure prepare_fixed_head_transfer (the_FD      : in out FD.device;
   436.                                           Q_operand   : in KDF9.Q_register) is
   437.    begin
   438.       the_FD.target := locus_from(Q_operand);
   439.       the_FD.target.has_fixed_heads := True;
   440.       the_FD.target.platter_number := 16;
   441.       the_FD.switch_time := platter_switch_time(the_FD);
   442.       the_FD.locus := the_FD.target;
   443.       the_FD.switch_count := the_FD.switch_count + (if the_FD.switch_time = 0 then 0 else 1);
   444.    end prepare_fixed_head_transfer;
   445.
   446.    overriding
   447.    procedure PIC (the_FD      : in out FD.device;
   448.                   Q_operand   : in KDF9.Q_register;
   449.                   set_offline : in Boolean) is
   450.       pragma Unreferenced(set_offline);
   451.    begin
   452.       prepare_fixed_head_transfer(the_FD, Q_operand);
   453.       PI_all(the_FD, Q_operand);
   454.    end PIC;
   455.
   456.    overriding
   457.    procedure PID (the_FD      : in out FD.device;
   458.                   Q_operand   : in KDF9.Q_register;
   459.                   set_offline : in Boolean) is
   460.       pragma Unreferenced(set_offline);
   461.    begin
   462.       prepare_fixed_head_transfer(the_FD, Q_operand);
   463.       PI_all(the_FD, Q_operand, transfer_to_EM => True);
   464.    end PID;
   465.
   466.    -- Find the number of the next (first) sector to rotate into an accessible position.
   467.    function next_sector_number (the_FD : FD.device)
   468.    return FD.sector_range is
   469.       now        : constant KDF9.us := the_clock_time;
   470.       best_time  : KDF9.us          := KDF9.us'Last;
   471.       the_sector : FD.sector_range  := FD.sector_range'Last;
   472.    begin
   473.       for s in FD.sector_range loop
   474.          if latent_time(the_FD, now) in sector_time+1 .. 2*sector_time then
   475.             if latent_time(the_FD, now) <= best_time then
   476.                the_sector := s;
   477.                best_time := latent_time(the_FD, now);
   478.             end if;
   479.          end if;
   480.       end loop;
   481.       return the_sector;
   482.    end next_sector_number;
   483.
   484.    -- Modify the given command to apply to the next sector to come under the heads.
   485.    function for_next_sector (the_FD : FD.device; Q : KDF9.Q_register)
   486.    return KDF9.Q_register
   487.    is (
   488.        C => (Q.C and 8#174000#) or (Q.C and 8#17#) or (next_sector_number(the_FD)*16),
   489.        I => Q.I,
   490.        M => Q.M
   491.       );
   492.
   493.    overriding
   494.    procedure PIE (the_FD      : in out FD.device;
   495.                   Q_operand   : in KDF9.Q_register;
   496.                   set_offline : in Boolean) is
   497.       pragma Unreferenced(set_offline);
   498.    begin
   499.       validate_transfer(the_FD, Q_operand);
   500.       PI_all(the_FD, for_next_sector(the_FD, Q_operand));
   501.    end PIE;
   502.
   503.    overriding
   504.    procedure PIF (the_FD      : in out FD.device;
   505.                   Q_operand   : in KDF9.Q_register;
   506.                   set_offline : in Boolean) is
   507.       pragma Unreferenced(set_offline);
   508.    begin
   509.       validate_transfer(the_FD, Q_operand);
   510.       PI_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   511.    end PIF;
   512.
   513.    overriding
   514.    procedure PIG (the_FD      : in out FD.device;
   515.                   Q_operand   : in KDF9.Q_register;
   516.                   set_offline : in Boolean) is
   517.       pragma Unreferenced(set_offline);
   518.    begin
   519.       validate_transfer(the_FD, Q_operand);
   520.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   521.       PI_all(the_FD, for_next_sector(the_FD, Q_operand));
   522.    end PIG;
   523.
   524.    overriding
   525.    procedure PIH (the_FD      : in out FD.device;
   526.                   Q_operand   : in KDF9.Q_register;
   527.                   set_offline : in Boolean) is
   528.       pragma Unreferenced(set_offline);
   529.    begin
   530.       validate_transfer(the_FD, Q_operand);
   531.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   532.       PI_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   533.    end PIH;
   534.
   535.    -- Set up, but do not yet effect, a seek to the locus specified by the Q_operand.
   536.    -- This follows advice from David Holdsworth that seeks were not effected
   537.    --    until a data transfer operation was obeyed.
   538.    -- PMA does not lockout for a busy device.  This may not be authentic.
   539.    overriding
   540.    procedure PMA (the_FD      : in out FD.device;
   541.                   Q_operand   : in KDF9.Q_register;
   542.                   set_offline : in Boolean) is
   543.       a_seek_is_needed : Boolean := False;
   544.    begin
   545.       validate_device(the_FD, Q_operand);
   546.       validate_parity(the_FD);
   547.       set_seek_target(the_FD, Q_operand, a_seek_is_needed);
   548.       deal_with_a_busy_device(the_FD, 19, set_offline);
   549.       take_note_of_test(the_FD.device_name, Q_operand, a_seek_is_needed);
   550.    end PMA;
   551.
   552.    overriding
   553.    procedure PMB (the_FD      : in out FD.device;
   554.                   Q_operand   : in KDF9.Q_register;
   555.                   set_offline : in Boolean) is
   556.       pragma Unreferenced(set_offline);
   557.    begin
   558.       validate_device(the_FD, Q_operand);
   559.       validate_parity(the_FD);
   560.       null;
   561.    end PMB;
   562.
   563.    overriding
   564.    procedure PMC (the_FD      : in out FD.device;
   565.                   Q_operand   : in KDF9.Q_register;
   566.                   set_offline : in Boolean) is
   567.       pragma Unreferenced(set_offline);
   568.    begin
   569.       validate_device(the_FD, Q_operand);
   570.       validate_parity(the_FD);
   571.       null;
   572.    end PMC;
   573.
   574.    overriding
   575.    procedure PMD (the_FD      : in out FD.device;
   576.                   Q_operand   : in KDF9.Q_register;
   577.                   set_offline : in Boolean) is
   578.       -- clear out seek area # and platter #, leaving buffer # and drive #
   579.       platter_0        : constant KDF9.Q_part := Q_operand.C and 16#C00F#;
   580.       control_word     : KDF9.Q_register;
   581.       a_seek_is_needed : Boolean;
   582.       seek_duration,
   583.       switch_duration  : KDF9.us;
   584.    begin
   585.       validate_device(the_FD, Q_operand);
   586.       -- Hypothesis: drive reset clears the parity flag.
   587.       the_FD.is_abnormal := False;
   588.       -- In effect, do 16 PMA operations, but treat them as a single operation.
   589.       for p in KDF9.Q_part range 0..15 loop -- p is platter #
   590.          control_word := (platter_0 + p*16#400#, Q_operand.I, Q_operand.M);
   591.          set_seek_target(the_FD, control_word, a_seek_is_needed);
   592.          seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   593.          update_statistics(
   594.                            the_FD,
   595.                            switch_time  => switch_duration,
   596.                            seek_time    => seek_duration
   597.                           );
   598.       end loop;
   599.       deal_with_a_busy_device(the_FD, 16, set_offline);
   600.    end PMD;
   601.
   602.    overriding
   603.    procedure PMF (the_FD      : in out FD.device;
   604.                   Q_operand   : in KDF9.Q_register;
   605.                   set_offline : in Boolean) is
   606.    begin
   607.       validate_device(the_FD, Q_operand);
   608.       validate_parity(the_FD);
   609.       deal_with_a_busy_device(the_FD, 13, set_offline);
   610.       the_T_bit_is_set := the_FD.locus.is_at_end_of_area;
   611.       take_note_of_test(the_FD.device_name, Q_operand, the_T_bit_is_set);
   612.    end PMF;
   613.
   614.    procedure put_next_sector (the_FD : in out FD.device) is
   615.       byte_address : constant POSIX.file_position := file_offset(the_FD.locus);
   616.    begin
   617.       if seek(fd_of(the_FD.stream), byte_address) /= byte_address then
   618.          raise emulation_failure with "POSIX seek failure in FD.put_next_sector";
   619.       end if;
   620.       if write(fd_of(the_FD.stream), this_sector, bytes_per_sector) /= bytes_per_sector then
   621.          raise emulation_failure with "POSIX write failure in FD.put_next_sector";
   622.       end if;
   623.       the_FD.sector_count := the_FD.sector_count + 1;
   624.       advance_the_sector_number(the_FD);
   625.       this_sector := empty_sector;
   626.    end put_next_sector;
   627.
   628.    procedure write (the_FD       : in out FD.device;
   629.                    start_address,
   630.                    end_address   : in KDF9.address;
   631.                    busy_time     : out KDF9.us;
   632.                    writing_to_EM : in  Boolean := False) is
   633.       size   : KDF9.word := 0;
   634.       next   : Natural := 0;
   635.       symbol : KDF9_char_sets.symbol;
   636.       char   : Character;
   637.    begin
   638.       check_addresses_and_lockouts(start_address, end_address);
   639.       this_sector := empty_sector;
   640.    word_loop:
   641.       for w in start_address .. end_address loop
   642.          for c in KDF9_char_sets.symbol_index'Range loop
   643.             symbol := fetch_symbol(w, c);
   644.             char := TP_CN(symbol);
   645.             next := next + 1;
   646.             this_sector(next) := char;
   647.             size := size + 1;
   648.             exit when writing_to_EM and char = E_M;
   649.          end loop;
   650.          if writing_to_EM and char = E_M then
   651.             put_next_sector(the_FD);
   652.             next := 0;
   653.             exit word_loop;
   654.          elsif size mod bytes_per_sector = 0 then
   655.             put_next_sector(the_FD);
   656.             next := 0;
   657.             exit word_loop when the_FD.locus.is_at_end_of_area;
   658.          end if;
   659.       end loop word_loop;
   660.       if next > 0 then
   661.          -- Write out any untransferred residue of less than a full sector.
   662.          put_next_sector(the_FD);
   663.       end if;
   664.       keep_house(the_FD, (size+7)/8, busy_time);
   665.    end write;
   666.
   667.    procedure PO_all (the_FD         : in out FD.device;
   668.                      Q_operand      : in KDF9.Q_register;
   669.                      transfer_to_EM : in Boolean := False) is
   670.       the_present_time   : constant KDF9.us := the_clock_time;
   671.       seek_duration,
   672.       switch_duration,
   673.       latency_duration,
   674.       data_duration,
   675.       total_duration     : KDF9.us;
   676.       latency_start_time : KDF9.us;
   677.    begin
   678.       validate_device(the_FD, Q_operand);
   679.       validate_parity(the_FD);
   680.       seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   681.       set_the_new_sector_number(the_FD, Q_operand);
   682.       latency_start_time := the_present_time + seek_duration + switch_duration;
   683.       latency_duration := latent_time(the_FD, latency_start_time);
   684.
   685.       if the_FD.locus.is_at_end_of_area then
   686.          -- Cannot transfer past the last sector in a seek area.
   687.          trap_failing_IO_operation(the_FD, "attempt to read FD at the end of a seek area");
   688.       end if;
   689.
   690.       -- Write to the newly established position.
   691.       write(
   692.             the_FD,
   693.             Q_operand.I, Q_operand.M,
   694.             data_duration,
   695.             writing_to_EM => transfer_to_EM
   696.            );
   697.
   698.       total_duration := seek_duration + switch_duration + latency_duration + data_duration;
   699.       start_data_transfer(the_FD, Q_operand, False, total_duration, output_operation);
   700.       lock_out_relative_addresses(Q_operand);
   701.       update_statistics(
   702.                         the_FD,
   703.                         seek_time    => seek_duration,
   704.                         switch_time  => switch_duration,
   705.                         latency_time => latency_duration,
   706.                         data_time    => data_duration
   707.                        );
   708.    end PO_all;
   709.
   710.    overriding
   711.    procedure POA (the_FD      : in out FD.device;
   712.                   Q_operand   : in KDF9.Q_register;
   713.                   set_offline : in Boolean) is
   714.       pragma Unreferenced(set_offline);
   715.    begin
   716.       PO_all(the_FD, Q_operand);
   717.    end POA;
   718.
   719.    overriding
   720.    procedure POB (the_FD      : in out FD.device;
   721.                   Q_operand   : in KDF9.Q_register;
   722.                   set_offline : in Boolean) is
   723.       pragma Unreferenced(set_offline);
   724.    begin
   725.       PO_all(the_FD, Q_operand, transfer_to_EM => True);
   726.    end POB;
   727.
   728.    overriding
   729.    procedure POC (the_FD      : in out FD.device;
   730.                   Q_operand   : in KDF9.Q_register;
   731.                   set_offline : in Boolean) is
   732.       pragma Unreferenced(set_offline);
   733.    begin
   734.       prepare_fixed_head_transfer(the_FD, Q_operand);
   735.       PO_all(the_FD, Q_operand);
   736.    end POC;
   737.
   738.    overriding
   739.    procedure POD (the_FD      : in out FD.device;
   740.                   Q_operand   : in KDF9.Q_register;
   741.                   set_offline : in Boolean) is
   742.       pragma Unreferenced(set_offline);
   743.    begin
   744.       prepare_fixed_head_transfer(the_FD, Q_operand);
   745.       PO_all(the_FD, Q_operand, transfer_to_EM => True);
   746.    end POD;
   747.
   748.    overriding
   749.    procedure POE (the_FD      : in out FD.device;
   750.                   Q_operand   : in KDF9.Q_register;
   751.                   set_offline : in Boolean) is
   752.    begin
   753.       POC(the_FD, Q_operand, set_offline);
   754.    end POE;
   755.
   756.    overriding
   757.    procedure POF (the_FD      : in out FD.device;
   758.                   Q_operand   : in KDF9.Q_register;
   759.                   set_offline : in Boolean) is
   760.    begin
   761.       POA(the_FD, Q_operand, set_offline);
   762.    end POF;
   763.
   764.    overriding
   765.    procedure POG (the_FD      : in out FD.device;
   766.                   Q_operand   : in KDF9.Q_register;
   767.                   set_offline : in Boolean) is
   768.       pragma Unreferenced(set_offline);
   769.    begin
   770.       validate_transfer(the_FD, Q_operand);
   771.       PO_all(the_FD, for_next_sector(the_FD, Q_operand));
   772.    end POG;
   773.
   774.    overriding
   775.    procedure POH (the_FD      : in out FD.device;
   776.                   Q_operand   : in KDF9.Q_register;
   777.                   set_offline : in Boolean) is
   778.       pragma Unreferenced(set_offline);
   779.    begin
   780.       validate_transfer(the_FD, Q_operand);
   781.       PO_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   782.    end POH;
   783.
   784.    overriding
   785.    procedure POK (the_FD      : in out FD.device;
   786.                   Q_operand   : in KDF9.Q_register;
   787.                   set_offline : in Boolean) is
   788.       pragma Unreferenced(set_offline);
   789.    begin
   790.       validate_transfer(the_FD, Q_operand);
   791.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   792.       PO_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   793.    end POK;
   794.
   795.    overriding
   796.    procedure POL (the_FD      : in out FD.device;
   797.                   Q_operand   : in KDF9.Q_register;
   798.                   set_offline : in Boolean) is
   799.       pragma Unreferenced(set_offline);
   800.    begin
   801.       validate_transfer(the_FD, Q_operand);
   802.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   803.       PO_all(the_FD, for_next_sector(the_FD, Q_operand));
   804.    end POL;
   805.
   806.    overriding
   807.    procedure Finalize (the_FD : in out FD.device) is
   808.       buffer : constant String := oct_of(KDF9.Q_part(the_FD.number), 2);
   809.    begin
   810.       if the_FD.is_open then
   811.          if (the_final_state_is_wanted and the_log_is_wanted)    and then
   812.                (the_FD.word_count /= 0 or the_FD.latency_count /= 0  or
   813.                 the_FD.seek_count /= 0 or the_FD.switch_time   /= 0) then
   814.             log_line
   815.                    (
   816.                     the_FD.device_name
   817.                   & " on buffer #"
   818.                   & buffer
   819.                   & " spent:"
   820.                    );
   821.             log_line
   822.                    (
   823.                     "    "
   824.                   & just_right(KDF9.us'Image(the_FD.data_time / 1_000), 6)
   825.                   & " ms in"
   826.                   & the_FD.latency_count'Image
   827.                   & " data transfer" & plurality(the_FD.latency_count)
   828.                   & " totalling"
   829.                   & KDF9.word'Image(the_FD.word_count)
   830.                   & " word" & plurality(the_FD.word_count)
   831.                   & ","
   832.                    );
   833.             log_line
   834.                    (
   835.                     "    "
   836.                   & just_right(KDF9.us'Image(the_FD.switch_time / 1_000), 6)
   837.                   & " ms in"
   838.                   & the_FD.switch_count'Image
   839.                   & plurality(the_FD.switch_count, " platter switch", " platter switches")
   840.                   & ","
   841.                    );
   842.             log_line
   843.                    (
   844.                     "    "
   845.                   & just_right(KDF9.us'Image(the_FD.latency_time / 1_000), 6)
   846.                   & " ms in"
   847.                   & the_FD.latency_count'Image
   848.                   & plurality(the_FD.latency_count, " rotational latency", " rotational latencies")
   849.                   & ", and"
   850.                    );
   851.             log_line
   852.                    (
   853.                     "    "
   854.                   & just_right(KDF9.us'Image(the_FD.seek_time / 1_000), 6)
   855.                   & " ms in"
   856.                   & the_FD.seek_count'Image
   857.                   & " seek" & plurality(the_FD.seek_count) & "."
   858.                    );
   859.          end if;
   860.          IOC.device(the_FD).Finalize;
   861.          close(the_FD);
   862.       end if;
   863.    exception
   864.       when error : others =>
   865.          raise emulation_failure
   866.             with "Finalizing FD buffer #" & buffer & "; " & Ada.Exceptions.Exception_Message(error);
   867.    end Finalize;
   868.
   869.    FD_quantum : constant := (1E6 + outer_rate - 1) / outer_rate;
   870.
   871.    type FD_access is access FD.device;
   872.
   873.    FD0 : FD_access with Warnings => Off;
   874.
   875.    procedure enable (b : in KDF9.buffer_number) is
   876.    begin
   877.       if is_enabled then trap_operator_error("FD:", "more than one unit specified"); end if;
   878.       FD0 := new FD.device (number  => b,
   879.                             kind    => FD_kind,
   880.                             unit    => 0,
   881.                             quantum => FD_quantum);
   882.       is_enabled := True;
   883.       FD0_number := b;
   884.    end enable;
   885.
   886.    procedure re_enable (b : in KDF9.buffer_number) is
   887.    begin
   888.       if is_enabled and then
   889.          b = FD0.number then
   890.          return;
   891.       end if;
   892.       buffer(b) := null;
   893.       enable(b);
   894.    end re_enable;
   895.
   896. end IOC.fast.FD;

Compiling: ../Source/ioc-fast-fd.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:29

     1. -- ioc-fast-fd.ads
     2. --
     3. -- Emulation of a (fixed-platter) disc drive.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.fast.FD is
    20.
    21.    type device is new IOC.fast.device with private;
    22.
    23.    overriding
    24.    procedure PIA (the_FD      : in out FD.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    overriding
    29.    procedure PIB (the_FD      : in out FD.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    overriding
    34.    procedure PIC (the_FD      : in out FD.device;
    35.                   Q_operand   : in KDF9.Q_register;
    36.                   set_offline : in Boolean);
    37.
    38.    overriding
    39.    procedure PID (the_FD      : in out FD.device;
    40.                   Q_operand   : in KDF9.Q_register;
    41.                   set_offline : in Boolean);
    42.
    43.    overriding
    44.    procedure PIE (the_FD      : in out FD.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    overriding
    49.    procedure PIF (the_FD      : in out FD.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    overriding
    54.    procedure PIG (the_FD      : in out FD.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    overriding
    59.    procedure PIH (the_FD      : in out FD.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    overriding
    64.    procedure PMA (the_FD      : in out FD.device;
    65.                   Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    overriding
    69.    procedure PMB (the_FD      : in out FD.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean);
    72.
    73.    overriding
    74.    procedure PMC (the_FD      : in out FD.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.
    78.    overriding
    79.    procedure PMD (the_FD      : in out FD.device;
    80.                   Q_operand   : in KDF9.Q_register;
    81.                   set_offline : in Boolean);
    82.
    83.    overriding
    84.    procedure PMF (the_FD      : in out FD.device;
    85.                   Q_operand   : in KDF9.Q_register;
    86.                   set_offline : in Boolean);
    87.
    88.    overriding
    89.    procedure POA (the_FD      : in out FD.device;
    90.                   Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean);
    92.
    93.    overriding
    94.    procedure POB (the_FD      : in out FD.device;
    95.                   Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean);
    97.
    98.    overriding
    99.    procedure POC (the_FD      : in out FD.device;
   100.                   Q_operand   : in KDF9.Q_register;
   101.                   set_offline : in Boolean);
   102.
   103.    overriding
   104.    procedure POD (the_FD      : in out FD.device;
   105.                   Q_operand   : in KDF9.Q_register;
   106.                   set_offline : in Boolean);
   107.
   108.    overriding
   109.    procedure POE (the_FD      : in out FD.device;
   110.                   Q_operand   : in KDF9.Q_register;
   111.                   set_offline : in Boolean);
   112.
   113.    overriding
   114.    procedure POF (the_FD      : in out FD.device;
   115.                   Q_operand   : in KDF9.Q_register;
   116.                   set_offline : in Boolean);
   117.
   118.    overriding
   119.    procedure POG (the_FD      : in out FD.device;
   120.                   Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean);
   122.
   123.    overriding
   124.    procedure POH (the_FD      : in out FD.device;
   125.                   Q_operand   : in KDF9.Q_register;
   126.                   set_offline : in Boolean);
   127.
   128.    overriding
   129.    procedure POK (the_FD      : in out FD.device;
   130.                   Q_operand   : in KDF9.Q_register;
   131.                   set_offline : in Boolean);
   132.
   133.    overriding
   134.    procedure POL (the_FD      : in out FD.device;
   135.                   Q_operand   : in KDF9.Q_register;
   136.                   set_offline : in Boolean);
   137.
   138.    is_enabled : Boolean := False;
   139.
   140.    procedure enable (b : in KDF9.buffer_number);
   141.
   142.    procedure re_enable (b : in KDF9.buffer_number);
   143.
   144.    FD0_number : KDF9.buffer_number;
   145.
   146.    main_discs_per_drive    : constant := 16;
   147.    seek_areas_per_platter  : constant := 64;
   148.    the_fixed_head_platter  : constant := 16;
   149.
   150.    function as_FD_command (Q_operand : KDF9.Q_register; for_seek, for_FH : Boolean := False)
   151.    return String;
   152.
   153. private
   154.
   155.    words_per_sector      : constant := 40;
   156.    bytes_per_sector      : constant := 8 * words_per_sector;
   157.
   158.    type sector_data      is array (KDF9.address range 0 .. bytes_per_sector-1)
   159.                          of KDF9_char_sets.symbol;
   160.
   161.    sectors_per_seek_area  : constant := 96;
   162.    sectors_in_outer_zone  : constant := 64;
   163.
   164.    subtype sector_range  is KDF9.Q_part range 0 .. sectors_per_seek_area-1;
   165.
   166.    type sector_array     is array (KDF9.Q_part range <>) of FD.sector_data;
   167.
   168.    subtype head_range    is KDF9.Q_part range 0 .. 7;
   169.
   170.    subtype inner_track   is FD.sector_array(FD.sector_range range 0 ..  7);
   171.    subtype outer_track   is FD.sector_array(FD.sector_range range 0 .. 15);
   172.
   173.    last_sector_for_head  : constant array (FD.head_range) of FD.sector_range
   174.                          := (0 .. 3 => FD.outer_track'Last,
   175.                              4 .. 7 => FD.inner_track'Last);
   176.
   177.    type outer_data       is array (FD.head_range range 0 .. 3) of FD.outer_track;
   178.    type inner_data       is array (FD.head_range range 4 .. 7) of FD.inner_track;
   179.
   180.    -- These rates come from the Manual, §6.1.
   181.    outer_rate : constant := 84_800;          -- bytes per second in the outer zone
   182.    inner_rate : constant := outer_rate / 2;  -- bytes per second in the outer zone
   183.
   184.    type track_set is
   185.       record
   186.          outer_zone : FD.outer_data;
   187.          inner_zone : FD.inner_data;
   188.       end record;
   189.
   190.    subtype seek_area_range is KDF9.Q_part range 0 .. seek_areas_per_platter-1;
   191.
   192.    platters_per_drive      : constant := main_discs_per_drive + 1;
   193.
   194.    subtype platter_range   is KDF9.Q_part range 0 .. platters_per_drive-1;
   195.
   196.    -- The Eldon 2 KDF9 at Leeds University had a 2-drive disc system.
   197.    -- This allows for the maximum number of drives possible.
   198.    number_of_drives : constant := 4;
   199.
   200.    subtype drive_range is KDF9.Q_part range 0 .. number_of_drives-1;
   201.
   202.    type locus is
   203.       record
   204.          drive_number      : FD.drive_range     := 0;
   205.          platter_number    : FD.platter_range   := 0;
   206.          seek_area_number  : FD.seek_area_range := 0;
   207.          sector_number     : FD.sector_range    := 0;
   208.          has_fixed_heads,
   209.          is_at_end_of_area : Boolean            := False;
   210.       end record;
   211.
   212.    -- The disc storage is actually implemented in an external file.
   213.    -- The comb and locus variables shadow the physical state of the drives.
   214.    -- They are used to derive a file address from the position established
   215.    --    by seek and transfer operations.
   216.
   217.    type comb_data is array (FD.drive_range, FD.platter_range) of FD.seek_area_range;
   218.
   219.    type device is new IOC.fast.device with
   220.       record
   221.          comb         : FD.comb_data := (others => (others => 0));
   222.          locus,
   223.          target       : FD.locus;
   224.          data_time,
   225.          seek_time    : KDF9.us := 0;
   226.          seek_count,
   227.          sector_count : KDF9.word := 0;
   228.       end record;
   229.
   230.    overriding
   231.    procedure Initialize (the_FD : in out FD.device);
   232.
   233.    overriding
   234.    procedure Finalize (the_FD : in out FD.device);
   235.
   236. end IOC.fast.FD;

 896 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-fast-mt.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:30

     1. -- ioc-fast-MT.adb
     2. --
     3. -- Emulation of magnetic tape decks and buffers.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Exceptions;
    20. with Ada.IO_Exceptions;
    21. --
    22. with HCI;
    23. with tracing;
    24.
    25. use  HCI;
    26. use  tracing;
    27.
    28. package body IOC.fast.MT is
    29.
    30.    --
    31.    -- Ada direct-access file management.
    32.    --
    33.
    34.    procedure open_RO (the_tape : in out MT.file; name : in String) is
    35.    begin
    36.       MT_slice_IO.Open(the_tape.reel, In_File, name);
    37.       the_tape.has_a_WP_ring := False;
    38.    exception
    39.       when others =>
    40.          trap_operator_error(name, "cannot be opened for reading or writing");
    41.    end open_RO;
    42.
    43.    procedure open_RW (the_tape : in out MT.file; name : in String) is
    44.    begin
    45.       MT_slice_IO.Open(the_tape.reel, Inout_File, name);
    46.       the_tape.has_a_WP_ring := True;
    47.    exception
    48.       when Ada.IO_Exceptions.Use_Error =>
    49.          the_tape.has_a_WP_ring := False;
    50.          open_RO(the_tape, name);
    51.       when Ada.IO_Exceptions.Name_Error =>
    52.          trap_operator_error(name, "cannot be found");
    53.       when error : others =>
    54.          trap_operator_error(name, "failed to open: " &  Ada.Exceptions.Exception_Message(error));
    55.    end open_RW;
    56.
    57.    procedure close (the_tape : in out MT.file) is
    58.    begin
    59.       if the_tape.has_a_WP_ring then
    60.          MT_slice_IO.Flush(the_tape.reel);
    61.       end if;
    62.       MT_slice_IO.Close(the_tape.reel);
    63.    end close;
    64.
    65.    function is_open (the_tape : in MT.file)
    66.    return Boolean
    67.    is (Is_Open(the_tape.reel));
    68.
    69.    -- Slice management.
    70.
    71.    end_of_tape : exception;
    72.
    73.    procedure write_slice (the_tape : in out MT.file;
    74.                           slice    : in MT.slice) is
    75.    begin
    76.       the_tape.position := the_tape.position + 1;
    77.       MT_slice_IO.Write(the_tape.reel, slice, to => the_tape.position);
    78.       if slice.kind not in tape_gap_kind then
    79.          the_tape.last_data_index := Count'Max(the_tape.last_data_index, the_tape.position);
    80.       end if;
    81.    exception
    82.       when End_Error =>
    83.          raise emulation_failure with "End_Error writing MT slice" & the_tape.position'Image;
    84.    end write_slice;
    85.
    86.    procedure read_next_slice (the_tape : in out MT.file;
    87.                               slice    : out MT.slice) is
    88.    begin
    89.       if the_tape.last_data_index > 0 then
    90.          the_tape.position := the_tape.position + 1;
    91.          MT_slice_IO.Read(the_tape.reel, slice, from => the_tape.position);
    92.       else
    93.          raise end_of_tape with "read_next_slice";
    94.       end if;
    95.     exception
    96.        when End_Error =>
    97.           raise emulation_failure with "End_Error reading MT slice" & the_tape.position'Image;
    98.    end read_next_slice;
    99.
   100.    procedure read_prev_slice (the_tape : in out MT.file;
   101.                               slice    : out MT.slice) is
   102.    begin
   103.       if the_tape.position > 0 then
   104.          MT_slice_IO.Read(the_tape.reel, slice, from => the_tape.position);
   105.          the_tape.position := the_tape.position - 1;
   106.       else
   107.          raise end_of_tape with "read_prev_slice";
   108.       end if;
   109.     exception
   110.        when End_Error =>
   111.           raise end_of_tape with "End_Error reading MT slice number" & the_tape.position'Image;
   112.    end read_prev_slice;
   113.
   114.    procedure bound_the_written_data (the_tape : in out MT.file) is
   115.       the_slice : MT.slice;
   116.    begin
   117.       the_tape.position := Size(the_tape.reel);
   118.       if the_tape.position = 0 then
   119.          -- There is no data in the file.
   120.          the_tape.last_data_index := 0;
   121.          return;
   122.       end if;
   123.       -- Locate the last data slice (if any).
   124.       while the_tape.position > 0 loop
   125.          read_prev_slice(the_tape, the_slice);
   126.       exit when the_slice.kind not in MT.tape_gap_kind;
   127.       end loop;
   128.       if the_slice.kind in MT.tape_gap_kind then
   129.          the_tape.last_data_index := 0;
   130.       else
   131.          the_tape.last_data_index := the_tape.position + 1;
   132.       end if;
   133.       the_tape.position := 0;
   134.    end bound_the_written_data;
   135.
   136.    procedure reset (the_deck : in out MT.deck) is
   137.     begin
   138.       bound_the_written_data(the_deck.tape);
   139.       the_deck.is_LBM_flagged := False;
   140.       the_deck.is_abnormal := False;
   141.       the_deck.unwound_frames := 0;
   142.    exception
   143.       when end_of_tape =>
   144.          the_deck.is_abnormal := True;
   145.          the_deck.is_LBM_flagged := False;
   146.          the_deck.unwound_frames := 0;
   147.    end reset;
   148.
   149.    -- Tape physical characteristics.
   150.
   151.    -- The physical end of tape (PET) is signalled one maximum block length before the tape runs out.
   152.    --  So PET is signalled at max_block_size before the absolute maximum position
   153.    --    to avoid running past the end of the tape when a very large block is written.
   154.
   155.    -- There could be as little as 60 inches of tape between the End of Tape Warning (ETW) and PET.
   156.    -- See the Manual, §22.1.3, p.182.
   157.
   158.    overriding
   159.    procedure Initialize (the_deck : in out MT.deck) is
   160.    begin
   161.       the_deck.device_name := device_name_of(the_deck);
   162.       open_RW(the_deck.tape, the_deck.device_name);
   163.       Initialize(IOC.device(the_deck));
   164.       if the_deck.kind = MT_kind then
   165.          the_deck.terminator        := End_Message;
   166.          the_deck.recording_density := max_bits_per_inch;  -- bits / inch
   167.          the_deck.max_reel_length   := max_reel_length;    -- inches
   168.       else
   169.          the_deck.terminator        := Group_Mark;
   170.          the_deck.recording_density := max_bits_per_inch/2;  -- bits / inch
   171.          the_deck.max_reel_length   := max_reel_length;      -- inches
   172.       end if;
   173.       the_deck.inter_block_gap := the_deck.recording_density / 3;
   174.       the_deck.tape_capacity   := the_deck.max_reel_length * the_deck.recording_density;
   175.       the_deck.PET_position    := the_deck.tape_capacity - max_block_size;
   176.       the_deck.ETW_position    := the_deck.PET_position - 60 * the_deck.recording_density;
   177.       reset(the_deck);
   178.    exception
   179.       when end_of_tape =>
   180.          the_deck.is_abnormal := True;
   181.    end Initialize;
   182.
   183.    function is_at_BTW (the_deck : MT.deck)
   184.    return Boolean
   185.    is (the_deck.is_open and then the_deck.tape.position = 0);
   186.
   187.    function holds_data (the_deck : MT.deck)
   188.    return Boolean
   189.    is (the_deck.is_open and then the_deck.tape.last_data_index > 0);
   190.
   191.    function is_at_ETW (the_deck : MT.deck)
   192.    return Boolean
   193.    is (the_deck.is_open and then the_deck.unwound_frames >= the_deck.ETW_position);
   194.
   195.    function is_at_PET (the_deck : MT.deck)
   196.    return Boolean
   197.    is (the_deck.is_open and then the_deck.unwound_frames >= the_deck.PET_position);
   198.
   199.    procedure deal_with_trying_to_pass_PET (the_deck : in out MT.deck;
   200.                                            do_this  : String) is
   201.    begin
   202.       if is_at_PET (the_deck) then
   203.          trap_failing_IO_operation(the_deck, "an attempt was made to " & do_this & " past PET");
   204.       end if;
   205.    end deal_with_trying_to_pass_PET;
   206.
   207.    -- There are cases that are invalid iff the tape is positioned beyond the last written block.
   208.    function is_at_EOD (the_deck : MT.deck)
   209.    return Boolean
   210.    is (the_deck.is_open and then the_deck.tape.position > the_deck.tape.last_data_index);
   211.
   212.    function tape_traversal_time (the_deck : MT.deck; tape_crossed : KDF9.word)
   213.    return KDF9.us
   214.    is (the_deck.quantum * KDF9.us(tape_crossed));
   215.
   216.    function data_transfer_time (the_deck   : MT.deck;
   217.                                 byte_count : KDF9.word)
   218.    return KDF9.us
   219.    is (the_deck.quantum * KDF9.us(byte_count));
   220.
   221.    -- This is the time the MT deck is busy traversing the interblock gap and the data block.
   222.    function MT_IO_time (the_deck  : MT.deck;
   223.                         Q_operand : in KDF9.Q_register)
   224.    return KDF9.us
   225.    is (KDF9.us(the_deck.inter_block_gap) + 8*KDF9.us(Q_operand.M-Q_operand.I+1) * the_deck.quantum);
   226.
   227.    overriding
   228.    function is_open (the_deck : MT.deck)
   229.    return Boolean
   230.    is (the_deck.tape.is_open);
   231.
   232.    overriding
   233.    function usage (the_deck : MT.deck)
   234.    return KDF9.word
   235.    is (the_deck.bytes_moved);
   236.
   237.    overriding
   238.    procedure close (the_deck : in out MT.deck) is
   239.    begin
   240.       the_deck.tape.close;
   241.    end close;
   242.
   243.    procedure update_statistics (the_deck    : in out MT.deck;
   244.                                 tape_crossed,
   245.                                 bytes_moved : in length_in_frames) is
   246.       real_time : KDF9.us;
   247.    begin
   248.       the_deck.bytes_moved := the_deck.bytes_moved + KDF9.word(bytes_moved);
   249.       real_time := tape_traversal_time(the_deck, KDF9.word(tape_crossed))
   250.                  + data_transfer_time (the_deck, KDF9.word(bytes_moved));
   251.       the_deck.elapsed_time := the_deck.elapsed_time + real_time;
   252.       add_in_the_IO_CPU_time(the_deck, KDF9.word(bytes_moved));
   253.       correct_transfer_time(the_deck, real_time);
   254.    end update_statistics;
   255.
   256.    type movement is (forwards, backwards);
   257.
   258.    procedure note_tape_position (the_deck    : in out MT.deck;
   259.                                  direction   : in MT.movement;
   260.                                  tape_crossed,
   261.                                  bytes_moved : in length_in_frames) is
   262.    begin
   263.       if direction = forwards then
   264.          the_deck.unwound_frames := the_deck.unwound_frames
   265.                                   + MT.length_in_frames(tape_crossed + bytes_moved);
   266.       elsif MT.length_in_frames(tape_crossed + bytes_moved) > the_deck.unwound_frames then
   267.          the_deck.unwound_frames := 0;
   268.       else
   269.          the_deck.unwound_frames := the_deck.unwound_frames
   270.                                   - MT.length_in_frames(tape_crossed + bytes_moved);
   271.       end if;
   272.    end note_tape_position;
   273.
   274.    -- KDF9 MT operations.
   275.
   276.    -- Skip back over erased tape, leaving the_slice containing the next preceding data.
   277.    -- Postcondition: the_deck.is_at_BTW or else the_slice.kind not in tape_gap_kind
   278.    procedure skip_back_over_erasure (the_deck  : in out MT.deck;
   279.                                      the_slice : in out MT.slice;
   280.                                      crossed   : in out length_in_frames) is
   281.    begin
   282.       if the_deck.is_at_BTW then
   283.          return; -- We are as far back as we can go;
   284.       end if;
   285.       if the_slice.kind in data_kind then
   286.          return;  -- We have already found the preceding data block.
   287.       end if;
   288.       loop
   289.          read_prev_slice(the_deck.tape, the_slice);
   290.       exit when the_deck.is_at_BTW or else the_slice.kind not in tape_gap_kind;
   291.          crossed := crossed + the_slice.size;
   292.       end loop;
   293.    end skip_back_over_erasure;
   294.
   295.    -- Skip forward over erased tape, leaving the_slice containing the next following data.
   296.    -- Postcondition: the_deck.is_at_EOD or else the_slice.kind not in tape_gap_kind
   297.    procedure skip_forward_over_erasure (the_deck  : in out MT.deck;
   298.                                         the_slice : in out MT.slice;
   299.                                         crossed   : in out length_in_frames;
   300.                                         caller    : in String := "") is
   301.    begin
   302.       if the_slice.kind in data_slice then
   303.          return;
   304.       end if;
   305.       loop
   306.          read_next_slice(the_deck.tape, the_slice);
   307.       exit when the_deck.is_at_EOD or else the_slice.kind not in MT.tape_gap_kind;
   308.          crossed := crossed + the_slice.size;
   309.       end loop;
   310.    exception
   311.       when end_of_tape =>
   312.          the_deck.is_abnormal := True;
   313.          raise end_of_tape with "in skip_forward_over_erasure for " & caller;
   314.    end skip_forward_over_erasure;
   315.
   316.    -- Deal with blocks of invalid sizes.
   317.    -- 1081 buffers always write and read a whole number of words;
   318.    --    see Manual §22.1.5, p184, ¶2; and Appendix 7 ¶3, p318.
   319.    -- §3.4.7 of the EGDON 3 manual says that the 7-track tape buffer, due to a hardware
   320.    --    limitation, rejects blocks (other than tape marks) of less than 6 characters.
   321.    procedure handle_any_abnormality (the_deck : in out MT.deck;
   322.                                      the_size : in length_in_frames) is
   323.    begin
   324.       case the_deck.kind is
   325.          when MT_kind =>
   326.             the_deck.is_abnormal := the_deck.is_abnormal or (the_size mod 8 /= 0);
   327.          when ST_kind =>
   328.             the_deck.is_abnormal := the_deck.is_abnormal or (the_size < 6);
   329.          when others  =>
   330.             raise emulation_failure
   331.                with "handle_any_abnormality with a deck kind given as "
   332.                   & the_deck.kind'Image
   333.                   & " by "
   334.                   & the_deck.device_name
   335.                   & " with block size"
   336.                   & the_size'Image;
   337.       end case;
   338.    end handle_any_abnormality;
   339.
   340.    procedure read_block (the_deck  : in out MT.deck;
   341.                          the_data  : out MT.block_storage;
   342.                          the_size  : out length_in_frames;
   343.                          direction : in movement := forwards) is
   344.
   345.       left,
   346.       right      : length_in_frames := 1;
   347.       block_size,
   348.       crossed    : length_in_frames := 0;
   349.       is_last,
   350.       is_flagged : Boolean := False;
   351.       the_slice  : MT.slice := a_NULL_slice;
   352.    begin
   353.       the_deck.is_LBM_flagged := False;
   354.
   355.       skip_forward_over_erasure(the_deck, the_slice, crossed, caller => "read_block");
   356.
   357.       -- Ensure that we are not beyond the end of valid data.
   358.       if the_deck.is_at_EOD then
   359.          trap_failing_IO_operation(
   360.                                    the_deck,
   361.                                    "there is no data past slice" & the_deck.tape.position'Image
   362.                                   );
   363.       end if;
   364.
   365.       if the_slice.kind in MT.tape_mark_kind then
   366.          -- Deal with a tape mark block; according to the Maual, Appendix 7, §2, p.317,
   367.          --    it reads as a single character with value #17.
   368.          block_size := 8;
   369.          the_data(1)    := KDF9_char_sets.TP_CN(KDF9_char_sets.Tape_Mark);
   370.          the_data(2..8) := (others => KDF9_char_sets.TP_CN(KDF9_char_sets.Blank_Space));
   371.          the_deck.is_LBM_flagged := True;
   372.       else
   373.          -- We have a bona fide data block.
   374.          the_size := 0;
   375.          -- Accumulate a series of slicefuls.
   376.          loop
   377.             right := left + the_slice.size - 1;
   378.             the_data(left .. right) := the_slice.data(1..the_slice.size);
   379.             block_size := block_size + the_slice.size;
   380.             left := left + the_slice.size;
   381.             is_flagged := is_flagged or the_slice.is_LBM_flagged;
   382.             is_last  := the_slice.is_last;
   383.          exit when is_last or block_size = max_block_size;
   384.             read_next_slice(the_deck.tape, the_slice);
   385.          end loop;
   386.          the_deck.is_LBM_flagged := is_flagged;
   387.       end if;
   388.       the_size := block_size;
   389.
   390.       note_tape_position(the_deck, direction,
   391.                         crossed + the_deck.inter_block_gap, bytes_moved => the_size);
   392.       update_statistics(the_deck,
   393.                         crossed + the_deck.inter_block_gap, bytes_moved => the_size);
   394.
   395.      if not is_last and block_size = max_block_size then
   396.          raise emulation_failure with block_size'Image & " > max_block_size in MT read_block";
   397.       end if;
   398.       handle_any_abnormality(the_deck, block_size);
   399.    end read_block;
   400.
   401.    procedure increment (word_address : in out KDF9.address;
   402.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   403.    begin
   404.       if symbol_nr < 7 then
   405.          symbol_nr := symbol_nr + 1;
   406.       else
   407.          symbol_nr := 0;
   408.          word_address := word_address + 1;
   409.       end if;
   410.    end increment;
   411.
   412.    tape_mark_data_word : constant KDF9.word := 8#17_00_00_00_00_00_00_00#;
   413.
   414.    procedure read (the_deck       : in out MT.deck;
   415.                    Q_operand      : in KDF9.Q_register;
   416.                    to_terminator  : in Boolean := False) is
   417.       start_address : constant KDF9.address := Q_operand.I;
   418.       end_address   : constant KDF9.address := Q_operand.M;
   419.       the_data : MT.block_storage;
   420.       s        : KDF9_char_sets.symbol_index;
   421.       w        : KDF9.address;
   422.       stored   : KDF9.word := 0;
   423.       the_size : length_in_frames;
   424.    begin
   425.       validate_device(the_deck, Q_operand);
   426.       check_addresses_and_lockouts(start_address, end_address);
   427.
   428.       read_block(the_deck, the_data, the_size);
   429.
   430.       if the_size mod 8 /= 0 and the_deck.kind = MT_kind then
   431.          -- Disregard an incomplete final word; see Manual, §22.1.5, p184, ¶2.
   432.          the_deck.is_abnormal := True;
   433.          the_size := the_size - the_size mod 8;
   434.       end if;
   435.
   436.       -- Store the relevant words.
   437.       w := start_address;
   438.       s := 0;
   439.       for i in 1 .. the_size loop
   440.          if s = 0 then
   441.             store_word(0, w);
   442.          end if;
   443.          store_symbol(CN_TR(the_data(i)), w, s);
   444.          stored := stored + 1;
   445.       exit when (w = end_address) and (s = 7);
   446.       exit when to_terminator and CN_TR(the_data(i)) = the_deck.terminator;
   447.          increment(w, s);
   448.       end loop;
   449.       if to_terminator then
   450.          correct_transfer_time(the_deck, stored);
   451.       end if;
   452.    exception
   453.       when end_of_tape =>
   454.          deal_with_trying_to_pass_PET(the_deck, "reading");
   455.    end read;
   456.
   457.    procedure find_start_of_earlier_block (the_deck : in out MT.deck;
   458.                                           crossed  : in out length_in_frames) is
   459.       the_slice  : MT.slice := a_NULL_slice;
   460.       block_size : length_in_frames;
   461.    begin
   462.       if the_deck.is_at_BTW then
   463.          return; -- We have already gone as far back as possible.
   464.       end if;
   465.
   466.       -- Skip back over any erasures or tape marks.
   467.       skip_back_over_erasure(the_deck, the_slice, crossed);
   468.       crossed := crossed + the_deck.inter_block_gap;
   469.
   470.       if the_deck.is_at_BTW and the_slice.kind in tape_gap_kind then
   471.          the_deck.is_abnormal := True;
   472.          -- This cannot happen if the tape has (at least) a label.
   473.          raise emulation_failure with "no earlier block, at BTW on " & the_deck.device_name;
   474.       end if;
   475.
   476.       if not the_slice.is_last then
   477.          raise emulation_failure
   478.             with "find_start_of_earlier_block at slice "
   479.                & the_deck.tape.position'Image
   480.                & " of "
   481.                & the_deck.device_name
   482.                & " failed to locate the last slice of a block";
   483.       end if;
   484.
   485.       -- We have reached the last slice of the block.
   486.       if the_deck.kind = ST_kind and the_slice.kind in tape_mark_kind then
   487.          block_size := 1;
   488.       else
   489.          block_size := the_slice.size;
   490.          -- Jump backwards over data slices until we reach the first of the block.
   491.          while not the_slice.is_first and then the_deck.tape.position > 0 loop
   492.             read_prev_slice(the_deck.tape, the_slice);
   493.             block_size := block_size + the_slice.size;
   494.          end loop;
   495.          handle_any_abnormality(the_deck, block_size);
   496.       end if;
   497.
   498.       crossed := crossed + block_size;
   499.    end find_start_of_earlier_block;
   500.
   501.    procedure decrement (word_address : in out KDF9.address;
   502.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   503.    begin
   504.       if symbol_nr > 0 then
   505.          symbol_nr := symbol_nr - 1;
   506.       else
   507.          symbol_nr := 7;
   508.          word_address := word_address + 1;
   509.       end if;
   510.    end decrement;
   511.
   512.    procedure read_backwards (the_deck       : in out MT.deck;
   513.                              Q_operand      : in KDF9.Q_register;
   514.                              to_terminator  : in Boolean := False) is
   515.       start_address : constant KDF9.address := Q_operand.I;
   516.       end_address   : constant KDF9.address := Q_operand.M;
   517.       terminator    : constant KDF9_char_sets.symbol := the_deck.terminator;
   518.       the_data  : MT.block_storage;
   519.       s         : KDF9_char_sets.symbol_index;
   520.       w         : KDF9.address;
   521.       the_first,
   522.       the_last  : length_in_frames;
   523.       crossed   : length_in_frames := 0 with Warnings => Off;  -- Because its value is never used.
   524.    begin
   525.       validate_device(the_deck, Q_operand);
   526.       check_addresses_and_lockouts(start_address, end_address);
   527.
   528.       -- Locate the start of the previous block.
   529.       find_start_of_earlier_block(the_deck, crossed);
   530.
   531.       -- Read it normally, i.e. forwards.
   532.       read_block(the_deck, the_data, the_last, backwards);
   533.
   534.       -- And retrace our steps, to position the tape as if the block had been read backwards.
   535.       find_start_of_earlier_block(the_deck, crossed);
   536.
   537.       -- Disregard an incomplete first word; see Manual §22.1.5, p184, ¶2; and Appendix 7 ¶3, p318.
   538.       if the_last mod 8 = 0 or the_deck.kind = ST_kind then
   539.          the_first := the_data'First;
   540.       elsif the_last = 1 and the_deck.kind = ST_kind then
   541.          -- See Manual, Appendix 7 ¶2, p317.
   542.          store_word(tape_mark_data_word, start_address);
   543.       else
   544.          the_deck.is_abnormal := True;
   545.          the_first := the_data'First + the_last mod 8;
   546.       end if;
   547.
   548.       -- Store the relevant words.
   549.       w := start_address;
   550.       s := 7;
   551.       for i in reverse the_first .. the_last loop
   552.          if s = 7 then
   553.             store_word(0, w);
   554.          end if;
   555.          store_symbol(CN_TR(the_data(i)), w, s);
   556.       exit when to_terminator and CN_TR(the_data(i)) = terminator;
   557.          decrement(w, s);
   558.       end loop;
   559.    end read_backwards;
   560.
   561.    -- MFRQq
   562.    overriding
   563.    procedure PIA (the_deck    : in out MT.deck;
   564.                   Q_operand   : in KDF9.Q_register;
   565.                   set_offline : in Boolean) is
   566.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   567.    begin
   568.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   569.       read(the_deck, Q_operand, to_terminator => False);
   570.       lock_out_relative_addresses(Q_operand);
   571.    end PIA;
   572.
   573.    -- MFREQq
   574.    overriding
   575.    procedure PIB (the_deck    : in out MT.deck;
   576.                   Q_operand   : in KDF9.Q_register;
   577.                   set_offline : in Boolean) is
   578.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   579.    begin
   580.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   581.       read(the_deck, Q_operand, to_terminator => True);
   582.       lock_out_relative_addresses(Q_operand);
   583.    end PIB;
   584.
   585.    -- as PIA
   586.    overriding
   587.    procedure PIC (the_deck    : in out MT.deck;
   588.                   Q_operand   : in KDF9.Q_register;
   589.                   set_offline : in Boolean) is
   590.    begin
   591.       the_deck.PIA(Q_operand, set_offline);
   592.    end PIC;
   593.
   594.    -- as PIB
   595.    overriding
   596.    procedure PID (the_deck    : in out MT.deck;
   597.                   Q_operand   : in KDF9.Q_register;
   598.                   set_offline : in Boolean) is
   599.    begin
   600.       the_deck.PIB(Q_operand, set_offline);
   601.    end PID;
   602.
   603.    -- MBRQq
   604.    overriding
   605.    procedure PIE (the_deck    : in out MT.deck;
   606.                   Q_operand   : in KDF9.Q_register;
   607.                   set_offline : in Boolean) is
   608.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   609.    begin
   610.       if the_deck.is_at_BTW then
   611.          trap_illegal_instruction("MBRQq at BTW on " & the_deck.device_name);
   612.       end if;
   613.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   614.       read_backwards(the_deck, Q_operand, to_terminator => False);
   615.       if the_deck.kind = ST_kind then
   616.          the_deck.is_LBM_flagged := False;
   617.       end if;
   618.       lock_out_relative_addresses(Q_operand);
   619.    end PIE;
   620.
   621.    -- MBREQq
   622.    overriding
   623.    procedure PIF (the_deck    : in out MT.deck;
   624.                   Q_operand   : in KDF9.Q_register;
   625.                   set_offline : in Boolean) is
   626.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   627.    begin
   628.       if the_deck.is_at_BTW then
   629.          trap_illegal_instruction("MBREQq at BTW on " & the_deck.device_name);
   630.       end if;
   631.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   632.       read_backwards(the_deck, Q_operand, to_terminator => True);
   633.       if the_deck.kind = ST_kind then
   634.          the_deck.is_LBM_flagged := False;
   635.       end if;
   636.       lock_out_relative_addresses(Q_operand);
   637.    end PIF;
   638.
   639.    -- as PIE
   640.    overriding
   641.    procedure PIG (the_deck    : in out MT.deck;
   642.                   Q_operand   : in KDF9.Q_register;
   643.                   set_offline : in Boolean) is
   644.    begin
   645.       the_deck.PIE(Q_operand, set_offline);
   646.    end PIG;
   647.
   648.    -- as PIF
   649.    overriding
   650.    procedure PIH (the_deck    : in out MT.deck;
   651.                   Q_operand   : in KDF9.Q_register;
   652.                   set_offline : in Boolean) is
   653.    begin
   654.       the_deck.PIF(Q_operand, set_offline);
   655.    end PIH;
   656.
   657.    procedure find_start_of_later_block (the_deck : in out MT.deck;
   658.                                         crossed  : in out length_in_frames) is
   659.       the_slice  : MT.slice := a_NULL_slice;
   660.       block_size : length_in_frames := 0;
   661.    begin
   662.       -- Skip over any erasures or tape marks.
   663.       skip_forward_over_erasure(the_deck, the_slice, crossed, caller => "find_start_of_later_block");
   664.       crossed := crossed + the_deck.inter_block_gap;
   665.
   666.       if not the_slice.is_first then
   667.          raise emulation_failure
   668.             with "find_start_of_later_block at slice"
   669.                & the_deck.tape.position'Image
   670.                & " of "
   671.                & the_deck.device_name
   672.                & " failed to locate the first slice of a block";
   673.       end if;
   674.
   675.       -- We have reached the first slice of the block.
   676.       if the_deck.kind = ST_kind and the_slice.kind in tape_mark_kind then
   677.          block_size := 1;
   678.       else
   679.          block_size := the_slice.size;
   680.          -- Ignore data slices until we get to the last slice of the block.
   681.          while not the_slice.is_last loop
   682.             read_next_slice(the_deck.tape, the_slice);
   683.             block_size := block_size + the_slice.size;
   684.          end loop;
   685.          handle_any_abnormality(the_deck, block_size);
   686.       end if;
   687.
   688.       the_deck.is_LBM_flagged := the_slice.is_LBM_flagged;
   689.       crossed := crossed + block_size;
   690.    exception
   691.       when end_of_tape =>
   692.          the_deck.is_abnormal := True;
   693.          raise end_of_tape with "find_start_of_later_block";
   694.    end find_start_of_later_block;
   695.
   696.    procedure skip_forwards (the_deck       : in out MT.deck;
   697.                             blocks_skipped : in KDF9.word) is
   698.       crossed : length_in_frames := 0;
   699.    begin
   700.       for i in 1 .. blocks_skipped loop
   701.          find_start_of_later_block(the_deck, crossed);
   702.       -- MFSKQq stops at an LBM-flagged block, or on count expiry.
   703.       -- Unlike MBSKQq it does record having seen an LBM-flagged block during the skipping.
   704.       -- See the Manual, §22.1.3, p.183, ¶1 and §22.1.9, p.188, ¶-2.
   705.       exit when the_deck.is_LBM_flagged;
   706.       end loop;
   707.       note_tape_position(the_deck, forwards, crossed, bytes_moved => 0);
   708.       update_statistics(the_deck, crossed, bytes_moved => 0);
   709.    end skip_forwards;
   710.
   711.    -- MFSKQq
   712.    overriding
   713.    procedure PMA (the_deck    : in out MT.deck;
   714.                   Q_operand   : in KDF9.Q_register;
   715.                   set_offline : in Boolean) is
   716.    begin
   717.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   718.       if Q_operand.M = 0 then
   719.          skip_forwards(the_deck, 32768);  -- See Manual §22.1.9, p188, ¶1.
   720.       else
   721.          require_positive_count(Q_operand.M);
   722.          skip_forwards(the_deck, KDF9.word(Q_operand.M));
   723.       end if;
   724.    end PMA;
   725.
   726.    -- MBTQq
   727.    overriding
   728.    procedure PMB (the_deck    : in out MT.deck;
   729.                   Q_operand   : in KDF9.Q_register;
   730.                   set_offline : in Boolean) is
   731.    begin
   732.       validate_device(the_deck, Q_operand);
   733.       validate_parity(the_deck);
   734.       deal_with_a_busy_device(the_deck, 14, set_offline);
   735.       the_T_bit_is_set := the_deck.is_at_BTW and the_deck.holds_data;
   736.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   737.    end PMB;
   738.
   739.    -- MLBQq
   740.    overriding
   741.    procedure PMC (the_deck    : in out MT.deck;
   742.                   Q_operand   : in KDF9.Q_register;
   743.                   set_offline : in Boolean) is
   744.    begin
   745.       validate_device(the_deck, Q_operand);
   746.       validate_parity(the_deck);
   747.       deal_with_a_busy_device(the_deck, 14, set_offline);
   748.       the_T_bit_is_set := the_deck.is_LBM_flagged;
   749.       the_deck.is_LBM_flagged := False;
   750.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   751.    end PMC;
   752.
   753.    procedure skip_backwards (the_deck       : in out MT.deck;
   754.                              blocks_skipped : in KDF9.word) is
   755.       crossed : length_in_frames := 0;
   756.    begin
   757.       for i in 1 .. blocks_skipped loop
   758.       exit when the_deck.is_at_BTW;  -- I.e., the tape is fully rewound.
   759.          find_start_of_earlier_block(the_deck, crossed);
   760.       -- MBSKQq does not stop at an LBM-flagged block, only at BTW or count expiry.
   761.       -- It ignores LBM flags encountered during the skipping.
   762.       -- See the Manual, §22.1.3, p.183, ¶1 and §22.1.9, p.188, ¶-2.
   763.       end loop;
   764.       note_tape_position(the_deck, backwards, crossed, bytes_moved => 0);
   765.       update_statistics(the_deck, crossed, bytes_moved => 0);
   766.    end skip_backwards;
   767.
   768.    -- MRWDQq
   769.    overriding
   770.    procedure PMD (the_deck    : in out MT.deck;
   771.                   Q_operand   : in KDF9.Q_register;
   772.                   set_offline : in Boolean) is
   773.       byte_count,
   774.       tape_length : length_in_frames := 0;
   775.       the_slice   : MT.slice;
   776.    begin  -- PMD
   777.       the_deck.is_abnormal := False;  -- See Manual §22.1.9, p.189, ¶-2.
   778.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   779.       -- No motion takes place if the tape is at BTW; see Manual §22.1.9, p.190, ¶1.
   780.       if the_deck.tape.position > 0 then
   781.          -- Make sure we dont try to read past the end of data.
   782.          -- Spool back to the BTW, accumulating distances.
   783.          while the_deck.tape.position > 0 loop
   784.             read_prev_slice(the_deck.tape, the_slice);
   785.             case the_slice.kind is
   786.                when data_slice =>
   787.                   byte_count := byte_count + the_slice.size;
   788.                   if the_slice.is_first then
   789.                      tape_length := tape_length + the_deck.inter_block_gap;
   790.                   end if;
   791.                when GAP_slice
   792.                   | WIPE_slice =>
   793.                   tape_length := tape_length + the_slice.size;
   794.                when others =>
   795.                   null;
   796.             end case;
   797.          end loop;
   798.       else
   799.          -- No motion takes place; see Manual §22.1.9, p.190, ¶1.
   800.          null;
   801.       end if;
   802.
   803.       update_statistics(the_deck, tape_length + byte_count, bytes_moved => 0);
   804.
   805.       reset(the_deck);
   806.    end PMD;
   807.
   808.    -- MBSKQq
   809.    overriding
   810.    procedure PME (the_deck    : in out MT.deck;
   811.                   Q_operand   : in KDF9.Q_register;
   812.                   set_offline : in Boolean) is
   813.    begin
   814.       if the_deck.is_at_BTW then
   815.          trap_illegal_instruction("MBSKQq at BTW on " & the_deck.device_name);
   816.       end if;
   817.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   818.       if Q_operand.M = 0 then
   819.          skip_backwards(the_deck, 32768);  -- See Manual §22.1.9, p188, ¶1.
   820.       else
   821.          require_positive_count(Q_operand.M);
   822.          skip_backwards(the_deck, KDF9.word(Q_operand.M));
   823.       end if;
   824.    end PME;
   825.
   826.    -- METQq
   827.    overriding
   828.    procedure PMF (the_deck    : in out MT.deck;
   829.                   Q_operand   : in KDF9.Q_register;
   830.                   set_offline : in Boolean) is
   831.    begin
   832.       validate_device(the_deck, Q_operand);
   833.       validate_parity(the_deck);
   834.       deal_with_a_busy_device(the_deck, 13, set_offline);
   835.       the_T_bit_is_set := the_deck.is_at_ETW;
   836.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   837.    end PMF;
   838.
   839.    -- PMKQq, forward skip, even parity, for character data with "group mark" (8#77#)
   840.    overriding
   841.    procedure PMK (the_deck    : in out MT.deck;
   842.                   Q_operand   : in KDF9.Q_register;
   843.                   set_offline : in Boolean) is
   844.    begin
   845.       if the_deck.kind = MT_kind then
   846.          trap_illegal_instruction("PMKQq on 1081 deck " & the_deck.device_name);
   847.       else
   848.          the_deck.PMA(Q_operand, set_offline);
   849.       end if;
   850.    end PMK;
   851.
   852.    -- PMLQq, backward skip, even parity, for character data with "group mark" (8#77#)
   853.    overriding
   854.    procedure PML (the_deck    : in out MT.deck;
   855.                   Q_operand   : in KDF9.Q_register;
   856.                   set_offline : in Boolean) is
   857.    begin
   858.       if the_deck.kind = MT_kind then
   859.          trap_illegal_instruction("PMLQq on 1081 deck " & the_deck.device_name);
   860.       else
   861.          the_deck.PMB(Q_operand, set_offline);
   862.       end if;
   863.    end PML;
   864.
   865.    procedure put_data_slice (the_deck   : in out MT.deck;
   866.                              data       : in MT.data_storage;
   867.                              size       : in length_in_frames;
   868.                              is_first,
   869.                              is_last,
   870.                              is_flagged : in Boolean) is
   871.       the_slice : MT.slice;
   872.    begin
   873.       the_slice := (
   874.                     data_slice,
   875.                     is_LBM_flagged => is_flagged,
   876.                     is_first => put_data_slice.is_first,
   877.                     is_last  => put_data_slice.is_last,
   878.                     size     => put_data_slice.size,
   879.                     data     => erased_gap_data
   880.                    );
   881.       the_slice.data(1 .. put_data_slice.size) := put_data_slice.data;
   882.       write_slice(the_deck.tape, the_slice);
   883.    exception
   884.       when end_of_tape =>
   885.          deal_with_trying_to_pass_PET(the_deck, "write " & the_deck.device_name);
   886.    end put_data_slice;
   887.
   888.    procedure write_block (the_deck       : in out MT.deck;
   889.                           the_data       : in MT.data_storage;
   890.                           is_LBM_flagged : in Boolean) is
   891.       remnant  : length_in_frames := the_data'Length;
   892.       from     : length_in_frames;
   893.       the_size : length_in_frames;
   894.    begin
   895.       if not the_deck.tape.has_a_WP_ring then
   896.          trap_operator_error(the_deck.device_name, "does not have a Write Permit Ring");
   897.       end if;
   898.
   899.       deal_with_trying_to_pass_PET(the_deck, "write");
   900.
   901.       the_deck.is_LBM_flagged := False;
   902.
   903.       -- Write the first (and possibly final) slice of the block.
   904.       the_size := (if remnant > slice_size_limit then slice_size_limit else remnant);
   905.       remnant := remnant - the_size;
   906.       from := the_data'First;
   907.       put_data_slice (
   908.                       the_deck,
   909.                       the_data(from .. the_size),
   910.                       the_size,
   911.                       is_first   => True,
   912.                       is_last    => remnant = 0,
   913.                       is_flagged => write_block.is_LBM_flagged
   914.                      );
   915.
   916.       -- Write any full slices, the last of which may be final.
   917.       while remnant >= slice_size_limit loop
   918.          deal_with_trying_to_pass_PET(the_deck, "write");
   919.          remnant := remnant - slice_size_limit;
   920.          from := from + slice_size_limit;
   921.          put_data_slice (
   922.                          the_deck,
   923.                          the_data(from .. from+slice_size_limit-1),
   924.                          slice_size_limit,
   925.                          is_first   => False,
   926.                          is_last    => remnant = 0,
   927.                          is_flagged => write_block.is_LBM_flagged
   928.                         );
   929.       end loop;
   930.
   931.       -- Write the residue as a final slice of the block.
   932.       if remnant > 0 then
   933.          put_data_slice (
   934.                          the_deck,
   935.                          the_data(from+slice_size_limit .. the_data'Last),
   936.                          remnant,
   937.                          is_first   => False,
   938.                          is_last    => True,
   939.                          is_flagged => write_block.is_LBM_flagged
   940.                         );
   941.       end if;
   942.
   943.       note_tape_position(the_deck, forwards,
   944.                         the_deck.inter_block_gap, bytes_moved => the_data'Length);
   945.       update_statistics(the_deck,
   946.                         the_deck.inter_block_gap, bytes_moved => the_data'Length);
   947.
   948.    exception
   949.       when end_of_tape =>
   950.          deal_with_trying_to_pass_PET(the_deck, "write " & the_deck.device_name);
   951.    end write_block;
   952.
   953.    procedure write (the_deck       : in out MT.deck;
   954.                     Q_operand      : in KDF9.Q_register;
   955.                     is_LBM_flagged : in Boolean := False) is
   956.       start_address : constant KDF9.address := Q_operand.I;
   957.       end_address   : constant KDF9.address := Q_operand.M;
   958.    begin
   959.       validate_device(the_deck, Q_operand);
   960.       check_addresses_and_lockouts(start_address, end_address);
   961.       declare
   962.          next_byte : length_in_frames := 1;
   963.          the_data  : MT.data_storage(1 .. length_in_frames(end_address-start_address+1)*8);
   964.       begin
   965.       word_loop:
   966.          for w in start_address .. end_address loop
   967.             for c in KDF9_char_sets.symbol_index'Range loop
   968.                the_data(next_byte) := TP_CN(fetch_symbol(w, c));
   969.                next_byte := next_byte + 1;
   970.             end loop;
   971.          end loop word_loop;
   972.          write_block(the_deck, the_data, is_LBM_flagged);
   973.       end;
   974.    end write;
   975.
   976.    procedure write_to_terminator (the_deck       : in out MT.deck;
   977.                                   Q_operand      : in KDF9.Q_register;
   978.                                   is_LBM_flagged : in Boolean := False) is
   979.       start_address : constant KDF9.address := Q_operand.I;
   980.       end_address   : constant KDF9.address := Q_operand.M;
   981.    begin
   982.       validate_device(the_deck, Q_operand);
   983.       check_addresses_and_lockouts(start_address, end_address);
   984.       declare
   985.          next_byte : length_in_frames := 1;
   986.          the_data  : MT.data_storage(1 .. length_in_frames(end_address-start_address+1)*8);
   987.          symbol    : KDF9_char_sets.symbol;
   988.       begin
   989.       word_loop:
   990.          for w in start_address .. end_address loop
   991.             for c in KDF9_char_sets.symbol_index'Range loop
   992.                symbol := fetch_symbol(w, c);
   993.                the_data(next_byte) := TP_CN(symbol);
   994.                next_byte := next_byte + 1;
   995.          exit word_loop when symbol = the_deck.terminator;
   996.             end loop;
   997.          end loop word_loop;
   998.          if the_deck.kind = MT_kind then
   999.             -- Pad out the last word to a full 8 symbols; 7-track decks do not do this.
  1000.             while next_byte mod 8 /= 1 loop
  1001.                the_data(next_byte) := TP_CN(0);
  1002.                next_byte := next_byte + 1;
  1003.             end loop;
  1004.          end if;
  1005.          write_block(the_deck, the_data(1 .. next_byte-1), is_LBM_flagged);
  1006.          correct_transfer_time(the_deck, KDF9.word(next_byte-1));
  1007.       end;
  1008.    end write_to_terminator;
  1009.
  1010.    -- MWQq
  1011.    overriding
  1012.    procedure POA (the_deck    : in out MT.deck;
  1013.                   Q_operand   : in KDF9.Q_register;
  1014.                   set_offline : in Boolean) is
  1015.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1016.    begin
  1017.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1018.       write(the_deck, Q_operand);
  1019.       lock_out_relative_addresses(Q_operand);
  1020.    end POA;
  1021.
  1022.    -- MWEQq
  1023.    overriding
  1024.    procedure POB (the_deck    : in out MT.deck;
  1025.                   Q_operand   : in KDF9.Q_register;
  1026.                   set_offline : in Boolean) is
  1027.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1028.    begin
  1029.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1030.       write_to_terminator(the_deck, Q_operand);
  1031.       lock_out_relative_addresses(Q_operand);
  1032.    end POB;
  1033.
  1034.    procedure put_ST_tapemark_slice (the_deck    : in out MT.deck;
  1035.                                     Q_operand   : in KDF9.Q_register;
  1036.                                     set_offline : in Boolean;
  1037.                                     the_slice   : in MT.slice) is
  1038.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, (Q_operand.C, 0, 0));
  1039.    begin
  1040.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1041.       write_slice(the_deck.tape, the_slice);
  1042.    exception
  1043.       when end_of_tape =>
  1044.          deal_with_trying_to_pass_PET(the_deck, "write " & the_deck.device_name);
  1045.    end put_ST_tapemark_slice;
  1046.
  1047.    -- MLWQq
  1048.    overriding
  1049.    procedure POC (the_deck    : in out MT.deck;
  1050.                   Q_operand   : in KDF9.Q_register;
  1051.                   set_offline : in Boolean) is
  1052.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1053.    begin
  1054.       if the_deck.kind = MT_kind then
  1055.          start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1056.          write(the_deck, Q_operand, is_LBM_flagged => True);
  1057.          lock_out_relative_addresses(Q_operand);
  1058.       else
  1059.          put_ST_tapemark_slice(the_deck, Q_operand, set_offline, odd_parity_tape_mark);
  1060.       end if;
  1061.    end POC;
  1062.
  1063.    -- MLWEQq
  1064.    overriding
  1065.    procedure POD (the_deck    : in out MT.deck;
  1066.                   Q_operand   : in KDF9.Q_register;
  1067.                   set_offline : in Boolean) is
  1068.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1069.    begin
  1070.       if the_deck.kind = MT_kind then
  1071.          start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1072.          write_to_terminator(the_deck, Q_operand, is_LBM_flagged => True);
  1073.          lock_out_relative_addresses(Q_operand);
  1074.       else
  1075.          put_ST_tapemark_slice(the_deck, Q_operand, set_offline, even_parity_tape_mark);
  1076.       end if;
  1077.    end POD;
  1078.
  1079.    procedure erase_tape_gap (the_deck   : in out MT.deck;
  1080.                              the_length : in KDF9.Q_part; -- the_length is a number of words.
  1081.                              gap_kind   : in tape_gap_kind) is
  1082.       crossing  : constant length_in_frames := length_in_frames(the_length) * 8;
  1083.       the_slice : MT.slice := (if gap_kind = GAP_slice then a_GAP_slice else a_WIPE_slice);
  1084.       remnant   : length_in_frames := crossing;
  1085.       old_slice : MT.slice;
  1086.       the_size  : length_in_frames;
  1087.    begin
  1088.       loop
  1089.          deal_with_trying_to_pass_PET(the_deck, "erase");
  1090.          the_size := length_in_frames'Min(remnant, slice_size_limit);
  1091.          remnant  := remnant - the_size;
  1092.
  1093.          the_slice.size := the_size;
  1094.
  1095.          if gap_kind = GAP_slice  and then
  1096.                not the_deck.is_at_EOD then
  1097.             -- Safety rules apply to erasing gaps; see the Manual, Appendix 6.8, p.314.
  1098.             read_next_slice(the_deck.tape, old_slice);
  1099.             if old_slice.kind /= WIPE_slice then
  1100.                trap_failing_IO_operation(
  1101.                                          the_deck,
  1102.                                          "a GAP of length"
  1103.                                        & the_length'Image
  1104.                                        & " words would overwrite data at slice"
  1105.                                        & the_deck.tape.position'Image
  1106.                                         );
  1107.             end if;
  1108.             -- Restore the writing position.
  1109.             read_prev_slice(the_deck.tape, old_slice);
  1110.          end if;
  1111.
  1112.          write_slice(the_deck.tape, the_slice);
  1113.       exit when remnant = 0;
  1114.       end loop;
  1115.
  1116.       the_deck.is_LBM_flagged := False;
  1117.       note_tape_position(the_deck, forwards, crossing, bytes_moved => 0);
  1118.       update_statistics(the_deck, crossing, bytes_moved => 0);
  1119.    exception
  1120.       when end_of_tape =>
  1121.          deal_with_trying_to_pass_PET(the_deck, "WIPE/GAP " & the_deck.device_name);
  1122.    end erase_tape_gap;
  1123.
  1124.    -- MGAPQq
  1125.    overriding
  1126.    procedure POE (the_deck    : in out MT.deck;
  1127.                   Q_operand   : in KDF9.Q_register;
  1128.                   set_offline : in Boolean) is
  1129.       time : constant KDF9.us := 19+IO_elapsed_time(the_deck, KDF9.word(Q_operand.M));
  1130.    begin
  1131.       if not the_deck.tape.has_a_WP_ring then
  1132.          trap_operator_error(the_deck.device_name, "does not have a Write Permit Ring");
  1133.       end if;
  1134.       require_positive_count(Q_operand.M);
  1135.       start_data_transfer(the_deck, Q_operand, set_offline, time);
  1136.       erase_tape_gap(the_deck, Q_operand.M, gap_kind => GAP_slice);
  1137.    end POE;
  1138.
  1139.    -- MWIPEQq
  1140.    overriding
  1141.    procedure POF (the_deck    : in out MT.deck;
  1142.                   Q_operand   : in KDF9.Q_register;
  1143.                   set_offline : in Boolean) is
  1144.       time : constant KDF9.us := 19+IO_elapsed_time(the_deck, KDF9.word(Q_operand.M));
  1145.    begin
  1146.       if not the_deck.tape.has_a_WP_ring then
  1147.          trap_operator_error(the_deck.device_name, "does not have a Write Permit Ring");
  1148.       end if;
  1149.       require_positive_count(Q_operand.M);
  1150.       start_data_transfer(the_deck, Q_operand, set_offline, time);
  1151.       erase_tape_gap(the_deck, Q_operand.M, gap_kind => WIPE_slice);
  1152.    end POF;
  1153.
  1154.    overriding
  1155.    procedure Finalize (the_deck : in out MT.deck) is
  1156.       the_deck_was_used : constant Boolean := the_deck.bytes_moved /= 0 or not the_deck.is_at_BTW;
  1157.       buffer            : constant String  := oct_of(KDF9.Q_part(the_deck.number), 2);
  1158.    begin
  1159.       if the_deck.is_open then
  1160.          if (the_final_state_is_wanted and the_log_is_wanted) and then
  1161.                the_deck_was_used                                  then
  1162.             log_line(
  1163.                      the_deck.device_name
  1164.                    & " on buffer #"
  1165.                    & buffer
  1166.                    & " transferred"
  1167.                    & the_deck.bytes_moved'Image
  1168.                    & " characters"
  1169.                    & (
  1170.                       if    the_deck.is_at_PET then ", and is now at PET."
  1171.                       elsif the_deck.is_at_ETW then ", and is now at ETW."
  1172.                       else                          "."
  1173.                      )
  1174.                    );
  1175.          end if;
  1176.          close(the_deck.tape);
  1177.       end if;
  1178.    exception
  1179.       when error : others =>
  1180.          raise emulation_failure
  1181.             with "Finalizing MT buffer #" & buffer & "; " & Ada.Exceptions.Exception_Message(error);
  1182.    end Finalize;
  1183.
  1184.    MT_quantum : constant := 1E6 / 40E3;  -- for 40_000 characters per second.
  1185.    ST_quantum : constant := 1E6 / 15E3;  -- for 15_000 characters per second.
  1186.
  1187.    type MT_access is access MT.deck;
  1188.    MT_deck         : array (IOC.unit_number range 0..8) of MT_access with Warnings => Off;
  1189.
  1190.    MT_units : IOC.unit_number := 0;
  1191.    ST_units : IOC.unit_number := 0;
  1192.
  1193.    procedure enable_MT_deck (b : in KDF9.buffer_number) is
  1194.    begin
  1195.       if MT_units+ST_units > MT_deck'Last then
  1196.          trap_operator_error("MT:", "too many tape decks specified");
  1197.       end if;
  1198.       MT_deck(MT_units) := new deck (number  => b,
  1199.                                      kind    => MT_kind,
  1200.                                      unit    => MT_units,
  1201.                                      quantum => MT_quantum);
  1202.       MT_units := MT_units + 1;
  1203.    end enable_MT_deck;
  1204.
  1205.    procedure enable_ST_deck (b : in KDF9.buffer_number) is
  1206.    begin
  1207.       if ST_units >= 2 then
  1208.          trap_operator_error("MT:", "more than 2 ST decks specified");
  1209.       end if;
  1210.       if MT_units+ST_units > MT_deck'Last then
  1211.          trap_operator_error("MT:", "too many tape decks specified");
  1212.       end if;
  1213.       MT_deck(MT_units) := new deck (number  => b,
  1214.                                      kind    => ST_kind,
  1215.                                      unit    => ST_units,
  1216.                                      quantum => ST_quantum);
  1217.       ST_units := ST_units + 1;
  1218.       MT_units := MT_units + 1;
  1219.    end enable_ST_deck;
  1220.
  1221.    procedure find_tape (the_label  : in  MT.data_storage;
  1222.                         its_number : out KDF9.buffer_number;
  1223.                         its_serial : out KDF9.word;
  1224.                         requestor  : in  String) is
  1225.
  1226.       function as_word (the_serial : MT.data_storage)
  1227.       return KDF9.word is
  1228.          word : KDF9.word := 0;
  1229.       begin
  1230.          for b in the_serial'Range loop
  1231.             word := (word * 2**6) or KDF9.word(CN_TR(the_serial(b)));
  1232.          end loop;
  1233.          return word;
  1234.       end as_word;
  1235.
  1236.       the_block : MT.data_storage(1 .. max_block_size);
  1237.       the_size  : length_in_frames;
  1238.
  1239.    begin -- find_tape
  1240.       if the_label'Length < 1 then
  1241.          raise emulation_failure with "find_tape was given a null label by " & requestor;
  1242.       end if;
  1243.       for t in KDF9.buffer_number loop
  1244.          if buffer(t) /= null                      and then
  1245.                buffer(t).kind in MT_kind | ST_kind and then
  1246.                    is_unallocated(buffer(t))           then
  1247.             declare
  1248.                the_deck : MT.deck renames MT.deck(buffer(t).all);
  1249.             begin
  1250.                if the_deck.holds_data  and then
  1251.                      the_deck.is_at_BTW    then
  1252.                   -- Read the label.
  1253.                   -- After reading the label the tape must be set back to BTW,
  1254.                   -- as is required to emulate Director; see the Manual, §22.1, Ex. 1.
  1255.                   read_block(the_deck, the_block, the_size);
  1256.                   reset(the_deck);
  1257.                   if the_size >= 8+the_label'Length                and then
  1258.                         the_block(9 .. 8+the_label'Length) = the_label then
  1259.                      its_number := t;
  1260.                      its_serial := as_word(the_block(1 .. 8));
  1261.                      return;
  1262.                   end if;
  1263.                end if;
  1264.             end;
  1265.          end if;
  1266.       end loop;
  1267.       trap_operator_error("the MT labelled '" & String(the_label) & "'",  "has not been mounted");
  1268.    end find_tape;
  1269.
  1270.
  1271. end IOC.fast.MT;

Compiling: ../Source/ioc-fast-mt.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:30

     1. -- ioc-fast-MT.ads
     2. --
     3. -- Emulation of magnetic tape decks and buffers.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with KDF9_char_sets;
    20.
    21. private with Ada.Direct_IO;
    22. --
    23. private with magtape_data;
    24.
    25. use  KDF9_char_sets;
    26.
    27. package IOC.fast.MT is
    28.
    29.    -- Both the EE 1081 and the Ampex TM-4 decks are emulated.
    30.    --
    31.    -- EE 1081, 16-track tape deck.
    32.       -- The physical characteristics of the deck are taken from the Manual, §22.1.2, i.e.:
    33.       -- 0.3 inch interblock gap, 400 ch/inch density, 100 inch/s tape speed,
    34.       --    full-reel rewind time ~3 minutes.
    35.    --
    36.    -- Ampex TM-4, 7-track IBM-compatible, tape deck.
    37.       -- The physical characteristics of the deck are taken from the Ampex document:
    38.       --    TECHNICAL MANUAL FOR SDSTM-4 TAPE TRANSPORT of 1963/2/15.
    39.       -- Where alternative characteristics are described, this code uses those considered to be of
    40.       --    greatest data interchange compatibility, as this is how the deck was used on KDF9, i.e.:
    41.       -- 0.3 inch interblock gap, 200 ch/inch density, 75 inch/s tape speed,
    42.       --    full-reel rewind time ~3 minutes.
    43.    --
    44.
    45.    type deck is new IOC.fast.device with private;
    46.
    47.    -- MRFQq
    48.    overriding
    49.    procedure PIA (the_deck    : in out MT.deck;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    -- MFREQq
    54.    overriding
    55.    procedure PIB (the_deck    : in out MT.deck;
    56.                   Q_operand   : in KDF9.Q_register;
    57.                   set_offline : in Boolean);
    58.
    59.    -- as PIA
    60.    overriding
    61.    procedure PIC (the_deck    : in out MT.deck;
    62.                   Q_operand   : in KDF9.Q_register;
    63.                   set_offline : in Boolean);
    64.
    65.    -- as PID
    66.    overriding
    67.    procedure PID (the_deck    : in out MT.deck;
    68.                   Q_operand   : in KDF9.Q_register;
    69.                   set_offline : in Boolean);
    70.
    71.    -- MBRQq
    72.    overriding
    73.    procedure PIE (the_deck    : in out MT.deck;
    74.                   Q_operand   : in KDF9.Q_register;
    75.                   set_offline : in Boolean);
    76.
    77.    -- MBREQq
    78.    overriding
    79.    procedure PIF (the_deck    : in out MT.deck;
    80.                   Q_operand   : in KDF9.Q_register;
    81.                   set_offline : in Boolean);
    82.
    83.    -- as PIE
    84.    overriding
    85.    procedure PIG (the_deck    : in out MT.deck;
    86.                   Q_operand   : in KDF9.Q_register;
    87.                   set_offline : in Boolean);
    88.
    89.    -- as PIF
    90.    overriding
    91.    procedure PIH (the_deck    : in out MT.deck;
    92.                   Q_operand   : in KDF9.Q_register;
    93.                   set_offline : in Boolean);
    94.
    95.    -- MFSKQq, for odd parity on 7-track deck
    96.    overriding
    97.    procedure PMA (the_deck    : in out MT.deck;
    98.                   Q_operand   : in KDF9.Q_register;
    99.                   set_offline : in Boolean);
   100.
   101.    -- MBTQq
   102.    overriding
   103.    procedure PMB (the_deck    : in out MT.deck;
   104.                   Q_operand   : in KDF9.Q_register;
   105.                   set_offline : in Boolean);
   106.
   107.    -- MLBQq
   108.    overriding
   109.    procedure PMC (the_deck    : in out MT.deck;
   110.                   Q_operand   : in KDF9.Q_register;
   111.                   set_offline : in Boolean);
   112.    -- MRWDQq
   113.    overriding
   114.    procedure PMD (the_deck    : in out MT.deck;
   115.                   Q_operand   : in KDF9.Q_register;
   116.                   set_offline : in Boolean);
   117.
   118.    -- MBSKQqMFSKQq, for odd parity on 7-track deck
   119.    overriding
   120.    procedure PME (the_deck    : in out MT.deck;
   121.                   Q_operand   : in KDF9.Q_register;
   122.                   set_offline : in Boolean);
   123.
   124.    -- METQq
   125.    overriding
   126.    procedure PMF (the_deck    : in out MT.deck;
   127.                   Q_operand   : in KDF9.Q_register;
   128.                   set_offline : in Boolean);
   129.
   130.    -- PMKQq, forward skip, even parity, for 7-track deck only
   131.    overriding
   132.    procedure PMK (the_deck    : in out MT.deck;
   133.                   Q_operand   : in KDF9.Q_register;
   134.                   set_offline : in Boolean);
   135.
   136.    -- PMLQq, backward skip, even parity, for 7-track deck only
   137.    overriding
   138.    procedure PML (the_deck    : in out MT.deck;
   139.                   Q_operand   : in KDF9.Q_register;
   140.                   set_offline : in Boolean);
   141.
   142.    -- MWQq
   143.    overriding
   144.    procedure POA (the_deck    : in out MT.deck;
   145.                   Q_operand   : in KDF9.Q_register;
   146.                   set_offline : in Boolean);
   147.
   148.    -- MWEQq
   149.    overriding
   150.    procedure POB (the_deck    : in out MT.deck;
   151.                   Q_operand   : in KDF9.Q_register;
   152.                   set_offline : in Boolean);
   153.
   154.    -- MLWQq
   155.    overriding
   156.    procedure POC (the_deck    : in out MT.deck;
   157.                   Q_operand   : in KDF9.Q_register;
   158.                   set_offline : in Boolean);
   159.
   160.    -- MLWEQq
   161.    overriding
   162.    procedure POD (the_deck    : in out MT.deck;
   163.                   Q_operand   : in KDF9.Q_register;
   164.                   set_offline : in Boolean);
   165.
   166.    -- MGAPQq
   167.    overriding
   168.    procedure POE (the_deck    : in out MT.deck;
   169.                   Q_operand   : in KDF9.Q_register;
   170.                   set_offline : in Boolean);
   171.
   172.    -- MWIPEQq
   173.    overriding
   174.    procedure POF (the_deck    : in out MT.deck;
   175.                   Q_operand   : in KDF9.Q_register;
   176.                   set_offline : in Boolean);
   177.
   178.    procedure enable_MT_deck (b : in KDF9.buffer_number);
   179.
   180.    procedure enable_ST_deck (b : in KDF9.buffer_number);
   181.
   182. private
   183.
   184.    use magtape_data;
   185.
   186.    -- slice_size_limit must be set so that the slice size field fits into 1 byte,
   187.    --    thus avoiding endian-ness and portability issues.
   188.    pragma Compile_Time_Error (slice_size_limit > 255, "magtape_data.slice_size_limit > 255");
   189.
   190.    -- I think that both types of tape for the KDF9 had a maximum reel length of 2400 feet.
   191.    -- I assume that the recording density of the 7-track deck was no greater than that of the 1081.
   192.
   193.    max_bits_per_inch      : constant := 400;
   194.    max_reel_length        : constant := 12 * 2400;
   195.    type length_in_frames is range 0 .. max_reel_length * max_bits_per_inch;
   196.    type data_storage     is array (MT.length_in_frames range <>) of Character;
   197.
   198.    -- Attempts to write a block of more than max_block_size/8 words will be rejected.
   199.    -- The largest recommended size, as stated in the Manual, §22.1.3, is 3000 words.
   200.    -- The present value cannot logically be exceeded, and so allows all possible usages.
   201.
   202.    max_block_size         : constant := 32768 * 8;
   203.    subtype block_range   is MT.length_in_frames range 0 .. max_block_size;
   204.    subtype block_storage is data_storage (MT.block_range range 1 .. max_block_size);
   205.
   206.    -- A data block consists of one or more slices:
   207.    --
   208.    -- 1. a block of data length <= slice_size_limit has 1 slice, with (is_last and is_first) = True;
   209.    --
   210.    -- 2. a longer block has 1 or more prior slices, which all have data length = slice_size_limit,
   211.    --       all of them having is_last = False, and the first of them having is_first = True;
   212.    --    and 1 final slice of data length <= slice_size_limit, with is_last = True.
   213.    --
   214.    -- The total data length of all the slices in a block is <= max_block_size.
   215.    --
   216.    -- GAP and WIPE slices represent erased lengths of tape.
   217.    -- They are implemented, in effect, as data slices with non-significant data.
   218.    --
   219.    -- Parity mark slices represent tape marks on IBM-compatible Ampex TM4 decks.
   220.    -- See Manual, Appendix 7, p.317.
   221.
   222.    type basis_kind is (data_slice,
   223.                        GAP_slice,
   224.                        NULL_slice,
   225.                        WIPE_slice,
   226.                        even_parity_mark,
   227.                        odd_parity_mark);
   228.
   229.    -- These representations make for easy inspection of a MT file (e.g. using the UNIX od command).
   230.    for basis_kind use (data_slice       => Character'Pos('D'),
   231.                        GAP_slice        => Character'Pos('G'),
   232.                        NULL_slice       => Character'Pos('N'),
   233.                        WIPE_slice       => Character'Pos('W'),
   234.                        even_parity_mark => Character'Pos('e'),
   235.                        odd_parity_mark  => Character'Pos('o'));
   236.
   237.    subtype tape_gap_kind is MT.basis_kind
   238.       with Static_Predicate => tape_gap_kind in GAP_slice | WIPE_slice;
   239.
   240.    subtype tape_mark_kind is MT.basis_kind
   241.       with Static_Predicate => tape_mark_kind in odd_parity_mark | even_parity_mark;
   242.
   243.    subtype data_kind is MT.basis_kind
   244.       with Static_Predicate => data_kind = data_slice;
   245.
   246.    subtype slice_range   is MT.block_range range 0 .. magtape_data.slice_size_limit;
   247.    subtype slice_storage is data_storage (1 .. slice_range'Last);
   248.
   249.    tape_mark_data  : constant MT.slice_storage := (1 => tape_mark_sign, others => block_padding);
   250.    erased_gap_data : constant MT.slice_storage := (others => block_padding);
   251.
   252.    type slice is
   253.       record
   254.          kind              : MT.basis_kind;
   255.          is_first, is_last : Boolean;
   256.          is_LBM_flagged    : Boolean;
   257.          size              : MT.slice_range;
   258.          data              : MT.slice_storage; -- Only data(1 .. size) are valid.
   259.       end record
   260.    with Size => 8 * MT_record_length;
   261.
   262.    -- These two representation specifications put the kind and is_* fields at convenient positions
   263.    --    for easy inspection in a legible print of a MT file (e.g. using the UNIX od command).
   264.
   265.    -- The first byte contains the initial letter of the slice type (see basis_kind).
   266.
   267.    -- The second byte takes the following octal/ASCII values for non-tape mark slices:
   268.    --    000 = NUL  => no flags
   269.    --    001 = SOH  => first slice of block
   270.    --    010 = BEL  => last slice of block
   271.    --    011 = HT   => only slice of block (first and last)
   272.    --    100 = @    => LBM flag
   273.    --    101 = A    => first slice of block with LBM flag
   274.    --    110 = H    => last slice of block with LBM flag
   275.    --    111 = I    => only slice of block with LBM flag
   276.
   277.    for slice use
   278.       record
   279.          kind           at 0 range  0..7;
   280.          is_first       at 1 range  0..2;
   281.          is_last        at 1 range  3..5;
   282.          is_LBM_flagged at 1 range  6..7;
   283.          size           at 2 range  0..7;
   284.          data           at 3 range  0..8*slice_size_limit - 1;
   285.       end record;
   286.
   287.    even_parity_tape_mark : constant MT.slice := (even_parity_mark,
   288.                                                  is_first       => True,
   289.                                                  is_last        => True,
   290.                                                  is_LBM_flagged => True,
   291.                                                  size           => 1,
   292.                                                  data           => tape_mark_data);
   293.
   294.    odd_parity_tape_mark  : constant MT.slice := (odd_parity_mark,
   295.                                                  is_first       => True,
   296.                                                  is_last        => True,
   297.                                                  is_LBM_flagged => True,
   298.                                                  size           => 1,
   299.                                                  data           => tape_mark_data);
   300.
   301.    a_NULL_slice          : constant MT.slice := (NULL_slice,
   302.                                                  is_first       => False,
   303.                                                  is_last        => False,
   304.                                                  is_LBM_flagged => False,
   305.                                                  size           => 0,
   306.                                                  data           => erased_gap_data);
   307.
   308.    a_WIPE_slice          : constant MT.slice := (WIPE_slice,
   309.                                                  is_first       => True,
   310.                                                  is_last        => True,
   311.                                                  is_LBM_flagged => False,
   312.                                                  size           => 0,
   313.                                                  data           => erased_gap_data);
   314.
   315.    a_GAP_slice           : constant MT.slice := (GAP_slice,
   316.                                                  is_first       => True,
   317.                                                  is_last        => True,
   318.                                                  is_LBM_flagged => False,
   319.                                                  size           => 0,
   320.                                                  data           => erased_gap_data);
   321.
   322.    package MT_slice_IO is new Ada.Direct_IO(MT.slice);
   323.    use MT_slice_IO;
   324.
   325.    type file is tagged limited
   326.       record
   327.          has_a_WP_ring   : Boolean := True;
   328.          last_data_index : Count   := 0;
   329.          position        : Count   := 0;
   330.          reel            : File_Type;
   331.       end record;
   332.
   333.    -- The complete deck type with its primitive operations.
   334.
   335.    type deck is new IOC.fast.device with
   336.       record
   337.          -- unwound_frames tallies the amount of tape wound from its spool to the takeup spool;
   338.          --    i.e. how much has to be wound back before being able to unload the tape.
   339.          unwound_frames    : MT.length_in_frames := 0;
   340.          bytes_moved       : KDF9.word := 0;
   341.          is_LBM_flagged    : Boolean   := False;
   342.          terminator        : KDF9_char_sets.symbol;
   343.          recording_density : MT.length_in_frames;
   344.          max_reel_length   : MT.length_in_frames;
   345.          inter_block_gap   : MT.length_in_frames;
   346.          tape_capacity     : MT.length_in_frames;
   347.          PET_position      : MT.length_in_frames;
   348.          ETW_position      : MT.length_in_frames;
   349.          tape              : MT.file;
   350.       end record;
   351.
   352.    overriding
   353.    function IO_elapsed_time_total (the_deck : MT.deck)
   354.    return KDF9.us
   355.    is (the_deck.elapsed_time);
   356.
   357.    overriding
   358.    procedure Initialize (the_deck : in out MT.deck);
   359.
   360.    overriding
   361.    procedure Finalize (the_deck : in out MT.deck);
   362.
   363.    procedure open (the_deck : in out MT.deck;
   364.                    the_mode : in POSIX.access_mode)
   365.    is null;
   366.
   367.    overriding
   368.    function is_open (the_deck : MT.deck)
   369.    return Boolean;
   370.
   371.    overriding
   372.    function usage (the_deck : MT.deck)
   373.    return KDF9.word;
   374.
   375.    overriding
   376.    procedure close (the_deck : in out MT.deck);
   377.
   378.    overriding
   379.    procedure flush(the_deck : in out MT.deck) is null;
   380.
   381.    procedure find_tape (the_label  : in  MT.data_storage;
   382.                         its_number : out KDF9.buffer_number;
   383.                         its_serial : out KDF9.word;
   384.                         requestor  : in  String);
   385.
   386. end IOC.fast.MT;

 1271 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-slow-shift-fw.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:31

     1. -- ioc-slow-shift-fw.adb
     2. --
     3. -- Emulation of the FlexoWriter buffer: monitor typewriter functionality.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received the copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Exceptions;
    20. with Ada.Text_IO;
    21. --
    22. with HCI;
    23. with host_IO;
    24.
    25. use  Ada.Text_IO;
    26. --
    27. use  HCI;
    28. use  host_IO;
    29.
    30. package body IOC.slow.shift.FW is
    31.
    32.    use  KDF9_char_sets;
    33.    use  Ada.Characters.Latin_1;
    34.
    35.    function a_LF_was_just_read (the_FW : FW.device)
    36.    return Boolean
    37.    is (the_FW.mode = the_flexowriter_is_reading and then a_LF_was_just_read(the_FW.stream));
    38.
    39.    function a_LF_was_just_written (the_FW : FW.device)
    40.    return Boolean
    41.    is (the_FW.mode = the_flexowriter_is_writing and then a_LF_was_just_written(the_FW.stream));
    42.
    43.    max_text_length : constant Positive := 64;  -- This is arbitrary, but seems reasonable.
    44.    type interaction is
    45.       record
    46.          text           : String(1 .. max_text_length);
    47.          prompt_length,
    48.          total_length   : Positive range 1 .. max_text_length;
    49.       end record;
    50.
    51.    max_interactions : constant Positive := 16; -- This is arbitrary, but seems reasonable.
    52.    interactions     : array (1 .. max_interactions) of IOC.slow.shift.FW.interaction;
    53.    next_interaction : Positive := 1;
    54.    last_interaction : Natural  := 0;
    55.
    56.     -- A '®' denotes LF, and the '©' denotes FF in an interaction text input.
    57.    LF_surrogate     : constant Character := '®';
    58.    FF_surrogate     : constant Character := '©';
    59.
    60.    -- These are the ANSI SGR terminal escape codes for styling FW output.
    61.    red_font_code   : constant String := ESC & "[0m" & ESC & "[31m";
    62.    black_font_code : constant String := ESC & "[0m" & ESC & "[30m";
    63.    underline_code  : constant String := ESC & "[4m";
    64.    plain_font_code : constant String := ESC & "[0m";
    65.
    66.    procedure set_text_colour_to_red (the_flexowriter_output : in out host_IO.stream) is
    67.    begin
    68.       if the_terminal_is_ANSI_compatible and realistic_FW_output_is_wanted then
    69.          put_escape_code(red_font_code, the_flexowriter_output);
    70.       end if;
    71.    end set_text_colour_to_red;
    72.
    73.    procedure set_text_colour_to_black (the_flexowriter_output : in out host_IO.stream) is
    74.    begin
    75.       if the_terminal_is_ANSI_compatible then
    76.          put_escape_code(black_font_code, the_flexowriter_output);
    77.       end if;
    78.    end set_text_colour_to_black;
    79.
    80.    procedure set_text_style_to_underline (the_flexowriter_output : in out host_IO.stream) is
    81.    begin
    82.       if the_terminal_is_ANSI_compatible then
    83.          put_escape_code(underline_code, the_flexowriter_output);
    84.       end if;
    85.    end set_text_style_to_underline;
    86.
    87.    procedure set_text_style_to_plain (the_flexowriter_output : in out host_IO.stream) is
    88.    begin
    89.       if the_terminal_is_ANSI_compatible then
    90.          put_escape_code(plain_font_code, the_flexowriter_output);
    91.       end if;
    92.    end set_text_style_to_plain;
    93.
    94.    overriding
    95.    procedure Initialize (the_FW : in out FW.device) is
    96.       interaction_file : Ada.Text_IO.File_Type;
    97.    begin
    98.       ensure_UI_is_open;
    99.       the_FW.mode := the_flexowriter_is_writing;
   100.       the_FW.device_name := device_name_of(the_FW);
   101.       if the_FW.device_name = "FW0" then
   102.          -- Attempt to open the command file for the console the_FW.
   103.          begin
   104.             Open(interaction_file, In_File, "FW0");
   105.          response_list_loop:
   106.             while not End_of_file(interaction_file) loop
   107.                if last_interaction = max_interactions then
   108.                   log_line("The file FW0 contains too many interactions!");
   109.                   raise Ada.Text_IO.Data_Error;
   110.                end if;
   111.                last_interaction := last_interaction + 1;
   112.                declare
   113.                   interaction       : String  := Get_Line(interaction_file);
   114.                   the_prompt_length : Natural := 0;
   115.                begin
   116.                   if interaction'Length > max_text_length then
   117.                      log_line(
   118.                               "The file FW0 contains an overlong string: '"
   119.                             & interaction
   120.                             & "'!"
   121.                              );
   122.                      raise Ada.Text_IO.Data_Error;
   123.                   end if;
   124.
   125.                   exit response_list_loop when interaction'Length = 0;
   126.
   127.                   for p in 1 .. interaction'Length loop
   128.                      if interaction(p) = ';' then
   129.                         the_prompt_length := p;
   130.                      elsif interaction(p) = LF_surrogate then
   131.                         -- Convert '®' to LF to allow for multi-line prompts.
   132.                         interaction(p) := LF;
   133.                      elsif interaction(p) = FF_surrogate then
   134.                         -- Convert '©' to FF to allow for multi-line prompts.
   135.                         interaction(p) := FF;
   136.                      end if;
   137.                   end loop;
   138.
   139.                   if the_prompt_length = 0 then
   140.                      log_line(
   141.                               "The file FW0 contains the string: '"
   142.                             & interaction
   143.                             & "' without the semicolon!"
   144.                              );
   145.                      raise Ada.Text_IO.Data_Error;
   146.                   end if;
   147.
   148.                   interactions(last_interaction).text(1 .. interaction'Length) := interaction;
   149.                   interactions(last_interaction).prompt_length := the_prompt_length;
   150.                   interactions(last_interaction).total_length := interaction'Length;
   151.                end;
   152.             end loop response_list_loop;
   153.          exception
   154.             when Name_Error =>
   155.                null;
   156.             when Use_Error =>
   157.                log_line("The file FW0 exists, but cannot be read!");
   158.          end;
   159.       end if;
   160.       open(the_FW.stream, the_FW.device_name, read_mode, UI_in_FD);
   161.       open(the_FW.output, the_FW.device_name, write_mode, UI_out_FD);
   162.       IOC.device(the_FW).Initialize;
   163.       the_FW.current_case := KDF9_char_sets.Case_Normal;
   164.    end Initialize;
   165.
   166.    -- If authentic timing, the delay of length the_pause is inserted between characters output
   167.    --    to the Flexowriter, with the aim of approximating the actual speed of its typing.
   168.    the_pause  : KDF9.us := 0;
   169.
   170.    procedure set_the_duration_of_the_pause (the_FW : in FW.device) is
   171.    begin
   172.       if authentic_timing_is_enabled then
   173.          the_pause := the_FW.quantum;
   174.       else
   175.          the_pause := 0;
   176.       end if;
   177.    end set_the_duration_of_the_pause;
   178.
   179.    call_for_manual_input    : constant String (1..2) := (others => BEL);
   180.
   181.    procedure inject_a_response (the_FW     : in out FW.device;
   182.                                 the_prompt : in String;
   183.                                 the_size   : in out KDF9.word) is
   184.    begin
   185.       set_the_duration_of_the_pause(the_FW);
   186.       for t in next_interaction .. last_interaction loop
   187.          declare
   188.             the : interaction renames interactions(t);
   189.          begin
   190.             if the.prompt_length = the.total_length then
   191.                -- A null response, so terminate the program.
   192.                raise exceptions.quit_request with "at the prompt: '" & the_prompt & "'";
   193.             end if;
   194.             next_interaction := next_interaction + 1;
   195.             if the.text(1..the.prompt_length-1) = the_prompt and then
   196.                   the.text(the.prompt_length-0) = ';'            then
   197.                inject(the.text(the.prompt_length+1..the.total_length) & LF, the_FW.stream);
   198.                the_size := the_size + KDF9.word(the.total_length-the.prompt_length);
   199.                put_chars(the.text(the.prompt_length+1..the.total_length) & LF, the_FW.output);
   200.                -- Human operators type much more slowly than KDF9 buffers!
   201.                flush(the_FW.output, the_pause*10);
   202.                the_FW.mode := the_flexowriter_is_reading;
   203.                return;
   204.             end if;
   205.          end;
   206.       end loop;
   207.       -- No canned response is available, so control reverts to the terminal.
   208.       -- Output an audible signal to notify the operator.
   209.       if noninteractive_usage_is_enabled then
   210.          raise input_is_impossible;
   211.       end if;
   212.       put_bytes(call_for_manual_input, the_FW.output);
   213.       flush(the_FW.output, the_pause);
   214.       the_FW.mode := the_flexowriter_is_reading;
   215.    end inject_a_response;
   216.
   217.    -- TRQq
   218.    overriding
   219.    procedure PIA (the_FW      : in out FW.device;
   220.                   Q_operand   : in KDF9.Q_register;
   221.                   set_offline : in Boolean) is
   222.    begin
   223.       if noninteractive_usage_is_enabled then
   224.          raise input_is_impossible;
   225.       end if;
   226.       put_bytes(call_for_manual_input, the_FW.output);
   227.       flush(the_FW.output);
   228.       the_FW.mode := the_flexowriter_is_reading;
   229.       start_slow_transfer(the_FW, Q_operand, set_offline);
   230.       read(the_FW, Q_operand);
   231.       lock_out_relative_addresses(Q_operand);
   232.       reset(the_FW.stream);
   233.    end PIA;
   234.
   235.    -- TREQq
   236.    overriding
   237.    procedure PIB (the_FW      : in out FW.device;
   238.                   Q_operand   : in KDF9.Q_register;
   239.                   set_offline : in Boolean) is
   240.    begin
   241.       if noninteractive_usage_is_enabled then
   242.          raise input_is_impossible;
   243.       end if;
   244.       put_bytes(call_for_manual_input, the_FW.output);
   245.       flush(the_FW.output);
   246.       the_FW.mode := the_flexowriter_is_reading;
   247.       start_slow_transfer(the_FW, Q_operand, set_offline);
   248.       read_to_EM(the_FW, Q_operand);
   249.       lock_out_relative_addresses(Q_operand);
   250.       reset(the_FW.stream);
   251.    end PIB;
   252.
   253.    overriding
   254.    procedure PIC (the_FW      : in out FW.device;
   255.                   Q_operand   : in KDF9.Q_register;
   256.                   set_offline : in Boolean) is
   257.    begin
   258.       if noninteractive_usage_is_enabled then
   259.          raise input_is_impossible;
   260.       end if;
   261.       put_bytes(call_for_manual_input, the_FW.output);
   262.       flush(the_FW.output);
   263.       the_FW.mode := the_flexowriter_is_reading;
   264.       start_slow_transfer(the_FW, Q_operand, set_offline);
   265.       words_read(the_FW, Q_operand);
   266.       lock_out_relative_addresses(Q_operand);
   267.       reset(the_FW.stream);
   268.    end PIC;
   269.
   270.    overriding
   271.    procedure PID (the_FW      : in out FW.device;
   272.                   Q_operand   : in KDF9.Q_register;
   273.                   set_offline : in Boolean) is
   274.    begin
   275.       if noninteractive_usage_is_enabled then
   276.          raise input_is_impossible;
   277.       end if;
   278.       put_bytes(call_for_manual_input, the_FW.output);
   279.       flush(the_FW.output);
   280.       the_FW.mode := the_flexowriter_is_reading;
   281.       start_slow_transfer(the_FW, Q_operand, set_offline);
   282.       words_read_to_EM(the_FW, Q_operand);
   283.       lock_out_relative_addresses(Q_operand);
   284.       reset(the_FW.stream);
   285.    end PID;
   286.
   287.    overriding
   288.    procedure PIE (the_FW      : in out FW.device;
   289.                   Q_operand   : in KDF9.Q_register;
   290.                   set_offline : in Boolean) is
   291.    begin
   292.       PIA(the_FW, Q_operand, set_offline);
   293.    end PIE;
   294.
   295.    overriding
   296.    procedure PIF (the_FW      : in out FW.device;
   297.                   Q_operand   : in KDF9.Q_register;
   298.                   set_offline : in Boolean) is
   299.    begin
   300.       PIB(the_FW, Q_operand, set_offline);
   301.    end PIF;
   302.
   303.    overriding
   304.    procedure PIG (the_FW      : in out FW.device;
   305.                   Q_operand   : in KDF9.Q_register;
   306.                   set_offline : in Boolean) is
   307.    begin
   308.       PIC(the_FW, Q_operand, set_offline);
   309.    end PIG;
   310.
   311.    overriding
   312.    procedure PIH (the_FW      : in out FW.device;
   313.                   Q_operand   : in KDF9.Q_register;
   314.                   set_offline : in Boolean) is
   315.    begin
   316.       PID(the_FW, Q_operand, set_offline);
   317.    end PIH;
   318.
   319.    -- neat strips off any enclosing non-graphic characters from s.
   320.    function neat (s : String)
   321.    return String is
   322.       l : Positive := 1;
   323.       r : Natural  := 0;
   324.    begin
   325.       for i in s'Range loop
   326.          l := i;
   327.       exit when s(i) > ' ' and s(i) /= DEL;
   328.       end loop;
   329.       for i in reverse s'Range loop
   330.          r := i;
   331.       exit when s(i) > ' ' and s(i) /= DEL;
   332.       end loop;
   333.       return s(l..r);  -- s(1..0) yields the null string when s is the null string.
   334.    end neat;
   335.
   336.    overriding
   337.    procedure do_output_housekeeping (the_FW   : in out FW.device;
   338.                                      written,
   339.                                      fetched  : in KDF9.word) is
   340.    begin
   341.       flush(the_FW.stream);
   342.       add_in_the_IO_CPU_time(the_FW, fetched);
   343.       correct_transfer_time(the_FW, written);
   344.       the_FW.byte_count := the_FW.byte_count + fetched;
   345.    end do_output_housekeeping;
   346.
   347.    underlined : Boolean := False;
   348.
   349.    procedure put_symbols (the_FW         : in out FW.device;
   350.                           Q_operand      : in KDF9.Q_register;
   351.                           transfer_to_EM : in Boolean) is
   352.       start_address : constant KDF9.address := Q_operand.I;
   353.       end_address   : constant KDF9.address := Q_operand.M;
   354.       fill   : KDF9.word := 0;
   355.       size   : KDF9.word := 0;
   356.       symbol : KDF9_char_sets.symbol;
   357.       char   : Character;
   358.    begin
   359.       check_addresses_and_lockouts(start_address, end_address);
   360.       set_the_duration_of_the_pause(the_FW);
   361.       the_FW.mode := the_flexowriter_is_writing;
   362.       set_text_style_to_plain(the_FW.output);
   363.       set_text_colour_to_red(the_FW.output);
   364.
   365.       -- Ensure that any prompt occupies the buffer alone.
   366.       flush(the_FW.output);
   367.
   368.    word_loop:
   369.       for w in start_address .. end_address loop
   370.          for c in KDF9_char_sets.symbol_index'Range loop
   371.             case the_FW.mode is
   372.
   373.                when the_flexowriter_is_writing =>
   374.                   symbol := fetch_symbol(w, c);
   375.                   size := size + 1;
   376.
   377.                   if symbol = KDF9_char_sets.Word_Filler then
   378.                      fill := fill + 1;
   379.
   380.                   elsif symbol = KDF9_char_sets.Case_Shift then
   381.                      the_FW.current_case := KDF9_char_sets.Case_Shift;
   382.                      the_FW.shifts := the_FW.shifts + 1;
   383.
   384.                   elsif  symbol = KDF9_char_sets.Case_Normal then
   385.                      the_FW.current_case := KDF9_char_sets.Case_Normal;
   386.                      the_FW.shifts := the_FW.shifts + 1;
   387.
   388.                   else
   389.
   390.                      if the_FW.current_case = KDF9_char_sets.Case_Normal then
   391.                         char := TP_CN(symbol);
   392.                      else
   393.                         char := TP_CS(symbol);
   394.                      end if;
   395.
   396.                      if char = ';' then
   397.
   398.                         declare
   399.                            the_prompt : constant String := contents(the_FW.output);
   400.                         begin
   401.                            -- Must flush AFTER saving the prompt and BEFORE going black.
   402.                            flush(the_FW.output, the_pause);
   403.                            set_text_colour_to_black(the_FW.output);
   404.                            set_text_style_to_plain(the_FW.output);
   405.                            put_byte(';', the_FW.output);
   406.                            flush(the_FW.output, the_pause);
   407.
   408.                            inject_a_response(the_FW, neat(the_prompt), size);
   409.
   410.                            the_FW.mode := the_flexowriter_is_reading;
   411.                            set_text_style_to_plain(the_FW.output);
   412.                         end;
   413.
   414.                      elsif flexowriter_output_is_wanted then
   415.
   416.                         if char = '_' then
   417.                            underlined := True;
   418.                            do_not_put_byte(char, the_FW.output);
   419.                            flush(the_FW.output, the_pause);
   420.                         else
   421.                            if underlined then
   422.                               set_text_style_to_underline(the_FW.output);
   423.                            end if;
   424.                            put_char(char, the_FW.output);
   425.                            if underlined then
   426.                               flush(the_FW.output, the_pause);
   427.                               set_text_style_to_plain(the_FW.output);
   428.                               set_text_colour_to_red(the_FW.output);
   429.                               underlined := False;
   430.                            end if;
   431.                         end if;
   432.
   433.                      else
   434.                         do_not_put_byte(char, the_FW.output);
   435.                      end if;
   436.
   437.                      exit word_loop when transfer_to_EM and symbol = KDF9_char_sets.End_Message;
   438.                   end if;
   439.
   440.                when the_flexowriter_is_reading =>
   441.                   get_char(char, the_FW.stream);
   442.                   if case_of(char) /= both and case_of(char) /= the_FW.current_case then
   443.                      store_symbol(CN_TR(next_case(the_FW.current_case)), w, c);
   444.                      size := size + 1;
   445.                      the_FW.current_case := the_FW.current_case xor 1;
   446.                      back_off(the_FW.stream);
   447.                   else
   448.                      if the_FW.current_case = KDF9_char_sets.Case_Normal then
   449.                         symbol := CN_TR(char);
   450.                      else
   451.                         symbol := CS_TR(char);
   452.                      end if;
   453.                      store_symbol(symbol, w, c);
   454.                      size := size + 1;
   455.                      if transfer_to_EM and symbol = KDF9_char_sets.End_Message then
   456.                         for d in 1 .. 7-c loop
   457.                            store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
   458.                         end loop;
   459.                         exit word_loop;
   460.                      end if;
   461.                   end if;
   462.
   463.             end case;
   464.          end loop;
   465.       end loop word_loop;
   466.
   467.       flush(the_FW.output, the_pause);
   468.       set_text_style_to_plain(the_FW.output);
   469.       set_text_colour_to_black(the_FW.output);
   470.       do_output_housekeeping(the_FW, written => size-fill, fetched => size);
   471.       flush(the_FW.output);
   472.
   473.    exception
   474.
   475.       when end_of_stream =>
   476.          flush(the_FW.output);
   477.          set_text_colour_to_black(the_FW.output);
   478.          set_text_style_to_plain(the_FW.output);
   479.          do_output_housekeeping(the_FW, written => size-fill, fetched => size);
   480.    end put_symbols;
   481.
   482.    overriding
   483.    procedure write (the_FW    : in out FW.device;
   484.                     Q_operand : in KDF9.Q_register) is
   485.    begin
   486.       put_symbols(the_FW, Q_operand, transfer_to_EM => False);
   487.    end write;
   488.
   489.    overriding
   490.    procedure write_to_EM (the_FW    : in out FW.device;
   491.                           Q_operand : in KDF9.Q_register) is
   492.    begin
   493.       put_symbols(the_FW, Q_operand, transfer_to_EM => True);
   494.    end write_to_EM;
   495.
   496.    -- TWQq
   497.    overriding
   498.    procedure POA (the_FW      : in out FW.device;
   499.                   Q_operand   : in KDF9.Q_register;
   500.                   set_offline : in Boolean) is
   501.    begin
   502.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   503.       write(the_FW, Q_operand);
   504.       lock_out_relative_addresses(Q_operand);
   505.       reset(the_FW.stream);
   506.    end POA;
   507.
   508.    -- TWEQq
   509.    overriding
   510.    procedure POB (the_FW      : in out FW.device;
   511.                   Q_operand   : in KDF9.Q_register;
   512.                   set_offline : in Boolean) is
   513.    begin
   514.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   515.       write_to_EM(the_FW, Q_operand);
   516.       lock_out_relative_addresses(Q_operand);
   517.       -- reset(the_FW.stream);
   518.    end POB;
   519.
   520.    procedure put_words (the_FW         : in out FW.device;
   521.                         Q_operand      : in KDF9.Q_register;
   522.                         transfer_to_EM : in Boolean := False) is
   523.       start_address : constant KDF9.address := Q_operand.I;
   524.       end_address   : constant KDF9.address := Q_operand.M;
   525.       size : KDF9.word := 0;
   526.       word : KDF9.word;
   527.       char : Character;
   528.    begin
   529.       check_addresses_and_lockouts(start_address, end_address);
   530.       set_the_duration_of_the_pause(the_FW);
   531.       the_FW.mode := the_flexowriter_is_writing;
   532.       set_text_style_to_plain(the_FW.output);
   533.       set_text_colour_to_red(the_FW.output);
   534.    word_loop:
   535.       for w in start_address .. end_address loop
   536.          case the_FW.mode is
   537.
   538.             when the_flexowriter_is_writing =>
   539.                word := fetch_word(w) and 8#377#;
   540.                size := size + 1;
   541.                char := Character'Val(word);
   542.
   543.                if word = KDF9_char_sets.Semi_Colon_tape_bits then
   544.                   -- Hypothesis: POC and POD act like POA and POB with respect to prompting;
   545.                   --    and change from writing to reading after the output of any word that has
   546.                   --       the KDF9 FW tape code for a semicolon in its least significant 8 bits.
   547.                   declare
   548.                      the_prompt : constant String := contents(the_FW.output);
   549.                   begin
   550.                      -- Must flush AFTER saving the prompt and BEFORE going black.
   551.                      flush(the_FW.output, the_pause);
   552.                      set_text_colour_to_black(the_FW.output);
   553.                      set_text_style_to_plain(the_FW.output);
   554.                      put_byte(';', the_FW.output);
   555.                      flush(the_FW.output, the_pause);
   556.
   557.                      inject_a_response(the_FW, neat(the_prompt), size);
   558.
   559.                      the_FW.mode := the_flexowriter_is_reading;
   560.                      set_text_style_to_plain(the_FW.output);
   561.                   end;
   562.                elsif flexowriter_output_is_wanted then
   563.
   564.                         if char = '_' then
   565.                            underlined := True;
   566.                            do_not_put_byte(char, the_FW.output);
   567.                            flush(the_FW.output, the_pause);
   568.                         else
   569.                            if underlined then
   570.                               set_text_style_to_underline(the_FW.output);
   571.                            end if;
   572.                            put_char(char, the_FW.output);
   573.                            if underlined then
   574.                               flush(the_FW.output, the_pause);
   575.                               set_text_style_to_plain(the_FW.output);
   576.                               set_text_colour_to_red(the_FW.output);
   577.                               underlined := False;
   578.                            end if;
   579.                         end if;
   580.       exit word_loop when transfer_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   581.                end if;
   582.
   583.             when the_flexowriter_is_reading =>
   584.                get_char(char, the_FW.stream);
   585.                size := size + 1;
   586.                word := KDF9.word(Character'Pos(char));
   587.                store_word(word, w);
   588.       exit word_loop when transfer_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   589.
   590.          end case;
   591.       end loop word_loop;
   592.
   593.       flush(the_FW.output);
   594.       set_text_colour_to_black(the_FW.output);
   595.       set_text_style_to_plain(the_FW.output);
   596.       do_output_housekeeping(the_FW, written => size, fetched => size);
   597.
   598.    exception
   599.
   600.       when end_of_stream =>
   601.          flush(the_FW.output);
   602.          set_text_colour_to_black(the_FW.output);
   603.          set_text_style_to_plain(the_FW.output);
   604.          do_output_housekeeping(the_FW, written => size, fetched => size);
   605.    end put_words;
   606.
   607.    overriding
   608.    procedure words_write (the_FW    : in out FW.device;
   609.                           Q_operand : in KDF9.Q_register) is
   610.    begin
   611.       put_words(the_FW, Q_operand, transfer_to_EM => False);
   612.    end words_write;
   613.
   614.    overriding
   615.    procedure words_write_to_EM (the_FW    : in out FW.device;
   616.                                 Q_operand : in KDF9.Q_register) is
   617.    begin
   618.       put_words(the_FW, Q_operand, transfer_to_EM => True);
   619.    end words_write_to_EM;
   620.
   621.    -- TWCQq
   622.    overriding
   623.    procedure POC (the_FW      : in out FW.device;
   624.                   Q_operand   : in KDF9.Q_register;
   625.                   set_offline : in Boolean) is
   626.    begin
   627.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   628.       words_write(the_FW, Q_operand);
   629.       lock_out_relative_addresses(Q_operand);
   630.    end POC;
   631.
   632.    -- TWECQq
   633.    overriding
   634.    procedure POD (the_FW      : in out FW.device;
   635.                   Q_operand   : in KDF9.Q_register;
   636.                   set_offline : in Boolean) is
   637.    begin
   638.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   639.       words_write_to_EM(the_FW, Q_operand);
   640.       lock_out_relative_addresses(Q_operand);
   641.    end POD;
   642.
   643.    overriding
   644.    procedure Finalize (the_FW : in out FW.device) is
   645.       total : constant KDF9.word := the_FW.output.bytes_moved+the_FW.stream.bytes_moved + the_FW.shifts;
   646.    begin
   647.       close(
   648.            the_FW,
   649.            "transferred",
   650.            total,
   651.            "character" & plurality(total)
   652.           );
   653.    end Finalize;
   654.
   655.    -- This is the monitor console Flexowriter.
   656.
   657.    FW_quantum : constant := 1E6 / 10;  -- 10 characters per second.
   658.
   659.    type FW_access is access FW.device;
   660.
   661.    FW0 : FW_access with Warnings => Off;
   662.
   663.    already_enabled : Boolean := False;
   664.
   665.    procedure enable (b : in KDF9.buffer_number) is
   666.    begin
   667.       if already_enabled then trap_operator_error("FW:", "more than one unit specified"); end if;
   668.       if b /= 0 then trap_operator_error("FW0", "must be on buffer 0"); end if;
   669.       FW0 := new FW.device (number  => b,
   670.                             kind    => FW_kind,
   671.                             unit    => 0,
   672.                             quantum => FW_quantum);
   673.       already_enabled := True;
   674.    end enable;
   675.
   676. end IOC.slow.shift.FW;
   677.

Compiling: ../Source/ioc-slow-shift-fw.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:31

     1. -- ioc-slow-shift-fw.ads
     2. --
     3. -- Emulation of a FlexoWriter buffer: monitor typewriter functionality.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.slow.shift.FW is
    20.
    21.    type device is new IOC.slow.shift.device with private;
    22.
    23.    function a_LF_was_just_read (the_FW : FW.device)
    24.    return Boolean;
    25.
    26.    function a_LF_was_just_written (the_FW : FW.device)
    27.    return Boolean;
    28.
    29.    -- TRQq
    30.    overriding
    31.    procedure PIA (the_FW      : in out FW.device;
    32.                   Q_operand   : in KDF9.Q_register;
    33.                   set_offline : in Boolean);
    34.
    35.    -- TREQq
    36.    overriding
    37.    procedure PIB (the_FW      : in out FW.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    -- TRCQq character read
    42.    overriding
    43.    procedure PIC (the_FW      : in out FW.device;
    44.                   Q_operand   : in KDF9.Q_register;
    45.                   set_offline : in Boolean);
    46.
    47.    -- TRECQq character read to End_Message
    48.    overriding
    49.    procedure PID (the_FW      : in out FW.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    -- as PIA
    54.    overriding
    55.    procedure PIE (the_FW      : in out FW.device;
    56.                   Q_operand   : in KDF9.Q_register;
    57.                   set_offline : in Boolean);
    58.
    59.    -- as PIB
    60.    overriding
    61.    procedure PIF (the_FW      : in out FW.device;
    62.                   Q_operand   : in KDF9.Q_register;
    63.                   set_offline : in Boolean);
    64.
    65.    -- as PIC
    66.    overriding
    67.    procedure PIG (the_FW      : in out FW.device;
    68.                   Q_operand   : in KDF9.Q_register;
    69.                   set_offline : in Boolean);
    70.
    71.    -- as PID
    72.    overriding
    73.    procedure PIH (the_FW      : in out FW.device;
    74.                   Q_operand   : in KDF9.Q_register;
    75.                   set_offline : in Boolean);
    76.
    77.    -- TWQq
    78.    overriding
    79.    procedure POA (the_FW      : in out FW.device;
    80.                   Q_operand   : in KDF9.Q_register;
    81.                   set_offline : in Boolean);
    82.
    83.    -- TWEQq
    84.    overriding
    85.    procedure POB (the_FW      : in out FW.device;
    86.                   Q_operand   : in KDF9.Q_register;
    87.                   set_offline : in Boolean);
    88.
    89.    -- NB the following assumes that page 285 of the Manual is erroneous,
    90.    -- and that POC and POD for the Flexowriter are analogous to the tape punch,
    91.    -- as other sources, such as the "Usecode Digest", do in fact indicate.
    92.
    93.    -- TWCQq character write
    94.    overriding
    95.    procedure POC (the_FW      : in out FW.device;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean);
    98.
    99.    -- TWECQq character write to End_Message
   100.    overriding
   101.    procedure POD (the_FW      : in out FW.device;
   102.                   Q_operand   : in KDF9.Q_register;
   103.                   set_offline : in Boolean);
   104.
   105.    procedure enable (b : in KDF9.buffer_number);
   106.
   107. private
   108.
   109.    type flexowriter_mode is
   110.       (the_flexowriter_is_reading, the_flexowriter_is_writing);
   111.
   112.    -- The Flexowriter has separate input and output streams, to accommodate the console I/O API
   113.    --    of MS Windows, which requires separate pseudo-devices for input and output.
   114.    type device is new IOC.slow.shift.device with
   115.       record
   116.          output : host_IO.stream;
   117.          mode   : FW.flexowriter_mode;
   118.          shifts : KDF9.word := 0;
   119.       end record;
   120.
   121.    overriding
   122.    procedure Initialize (the_FW : in out FW.device);
   123.
   124.    overriding
   125.    procedure Finalize (the_FW : in out FW.device);
   126.
   127.    overriding
   128.    procedure write (the_FW    : in out FW.device;
   129.                     Q_operand : in KDF9.Q_register);
   130.
   131.    overriding
   132.    procedure write_to_EM (the_FW    : in out FW.device;
   133.                           Q_operand : in KDF9.Q_register);
   134.    overriding
   135.    procedure words_write (the_FW    : in out FW.device;
   136.                           Q_operand : in KDF9.Q_register);
   137.
   138.    overriding
   139.    procedure words_write_to_EM (the_FW    : in out FW.device;
   140.                                 Q_operand : in KDF9.Q_register);
   141.
   142.    overriding
   143.    procedure do_output_housekeeping (the_FW   : in out FW.device;
   144.                                      written,
   145.                                      fetched  : in KDF9.word);
   146.
   147. end IOC.slow.shift.FW;

 677 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-slow-shift-gp.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:31

     1. -- ioc-slow-shift-gp.ads
     2. --
     3. -- Emulation of a Calcomp 564 graph plotter, switched to a tape punch buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18. with formatting;
    19. with HCI;
    20. with IOC.equipment;
    21. with plotter;
    22. with postscript;
    23. with settings;
    24. with tracing;
    25.
    26. use  formatting;
    27. use  HCI;
    28. use  IOC.equipment;
    29. use  plotter;
    30. use  postscript;
    31. use  settings;
    32. use  tracing;
    33.
    34. package body IOC.slow.shift.GP is
    35.
    36.    overriding
    37.    procedure Initialize (the_GP : in out GP.device) is
    38.    begin
    39.       -- Ready the graph plotter driver and PostScript output file.
    40.       the_GP.device_name := device_name_of(the_GP);
    41.       open(the_GP.stream, the_GP.device_name, write_mode);
    42.       IOC.device(the_GP).Initialize;
    43.       if the_GP.is_open then
    44.          truncate(the_GP.stream, to_length => 0);
    45.          initialize_PS_output(the_GP.stream);
    46.          open_the_plot_file(the_GP.stream);
    47.       end if;
    48.    end Initialize;
    49.
    50.    overriding
    51.    procedure Finalize (the_GP : in out GP.device) is
    52.    begin
    53.       if the_graph_plotter_is_enabled then
    54.          if the_GP.is_open           and then
    55.                the_GP.byte_count /= 0    then
    56.             if the_final_state_is_wanted then
    57.                log_line(
    58.                         the_GP.device_name
    59.                       & " on buffer #"
    60.                       & oct_of(KDF9.Q_part(the_GP.number), 2)
    61.                       & " made"
    62.                       & the_GP.byte_count'Image
    63.                       & " plotting steps."
    64.                        );
    65.             end if;
    66.             the_GP.byte_count := 0;
    67.             close_the_plot_file(the_GP.stream);
    68.             finalize_PS_output(the_GP.stream);
    69.          end if;
    70.       end if;
    71.    end Finalize;
    72.
    73.    -- the_T_bit_is_set (the buffer has been switched from a tape punch to a graph plotter)
    74.    overriding
    75.    procedure PMB (the_GP      : in out GP.device;
    76.                   Q_operand   : in KDF9.Q_register;
    77.                   set_offline : in Boolean) is
    78.    begin
    79.       validate_device(the_GP, Q_operand);
    80.       validate_parity(the_GP);
    81.       deal_with_a_busy_device(the_GP, 13, set_offline);
    82.       the_T_bit_is_set := True;
    83.       take_note_of_test(the_GP.device_name, Q_operand, the_T_bit_is_set);
    84.    end PMB;
    85.
    86.    GP_quantum   : constant := 1E6 / 200;  -- 200 plotting movements per second.
    87.    GP_lift_time : constant := 1E6 /  10;  -- 10 pen up/down movements per second.
    88.    lift_ratio   : constant := GP_lift_time / GP_quantum;
    89.
    90.    overriding
    91.    procedure do_output_housekeeping (the_GP      : in out GP.device;
    92.                                      size, lifts : in     KDF9.word) is
    93.    begin
    94.       add_in_the_IO_CPU_time(the_GP, size);
    95.       correct_transfer_time(the_GP, size - lifts + lifts * lift_ratio);
    96.    end do_output_housekeeping;
    97.
    98.    procedure put_symbols (the_GP    : in out GP.device;
    99.                           Q_operand : in KDF9.Q_register) is
   100.       start_address : constant KDF9.address := Q_operand.I;
   101.       end_address   : constant KDF9.address := Q_operand.M;
   102.       size    : KDF9.word := 0;
   103.       lifts   : KDF9.word := 0;
   104.       command : plotter.command;
   105.    begin
   106.       check_addresses_and_lockouts(start_address, end_address);
   107.    word_loop:
   108.       for w in start_address .. end_address loop
   109.          for c in KDF9_char_sets.symbol_index'Range loop
   110.             command := plotter.command(fetch_symbol(w, c));
   111.             perform(command, the_GP.stream);
   112.             size := size + 1;
   113.             the_GP.byte_count := the_GP.byte_count + 1;
   114.             if command in pen_up | pen_down then
   115.                -- These actions are much slower than plotting movements.
   116.                lifts := lifts + 1;
   117.             end if;
   118.          end loop;
   119.       end loop word_loop;
   120.       do_output_housekeeping (the_GP, size, lifts);
   121.    end put_symbols;
   122.
   123.    overriding
   124.    procedure POA (the_GP      : in out GP.device;
   125.                   Q_operand   : in KDF9.Q_register;
   126.                   set_offline : in Boolean) is
   127.    begin
   128.       start_slow_transfer(the_GP, Q_operand, set_offline, output_operation);
   129.       put_symbols(the_GP, Q_operand);
   130.       lock_out_relative_addresses(Q_operand);
   131.    end POA;
   132.
   133.    overriding
   134.    procedure POB (the_GP      : in out GP.device;
   135.                   Q_operand   : in KDF9.Q_register;
   136.                   set_offline : in Boolean) is
   137.    begin
   138.       -- See the Manual Appendix 6, §5.2, p.303.
   139.       POA(the_GP, Q_operand, set_offline);
   140.    end POB;
   141.
   142.    procedure put_words (the_GP    : in out GP.device;
   143.                         Q_operand : in KDF9.Q_register) is
   144.       start_address : constant KDF9.address := Q_operand.I;
   145.       end_address   : constant KDF9.address := Q_operand.M;
   146.       size    : KDF9.word := 0;
   147.       lifts   : KDF9.word := 0;
   148.       command : plotter.command;
   149.    begin
   150.       check_addresses_and_lockouts(start_address, end_address);
   151.       for w in start_address .. end_address loop
   152.          -- Ony the last 6 bits (character 7) of each word are used.
   153.          command := plotter.command(fetch_symbol(w, 7));
   154.          perform(command, the_GP.stream);
   155.          size := size + 1;
   156.          the_GP.byte_count := the_GP.byte_count + 1;
   157.          if command in pen_up | pen_down then
   158.             -- These actions are much slower than plotting movements.
   159.             lifts := lifts + 1;
   160.          end if;
   161.       end loop;
   162.       do_output_housekeeping (the_GP, size, lifts);
   163.    end put_words;
   164.
   165.    overriding
   166.    procedure POC (the_GP      : in out GP.device;
   167.                   Q_operand   : in KDF9.Q_register;
   168.                   set_offline : in Boolean) is
   169.    begin
   170.       start_slow_transfer(the_GP, Q_operand, set_offline, output_operation);
   171.       put_words(the_GP, Q_operand);
   172.       lock_out_relative_addresses(Q_operand);
   173.    end POC;
   174.
   175.    overriding
   176.    procedure POD (the_GP      : in out GP.device;
   177.                   Q_operand   : in KDF9.Q_register;
   178.                   set_offline : in Boolean) is
   179.    begin
   180.       -- See the Manual Appendix 6, §5.2, p.303.
   181.       POC(the_GP, Q_operand, set_offline);
   182.    end POD;
   183.
   184.
   185.    type GP_access is access GP.device;
   186.
   187.    GP0 : GP_access with Warnings => Off;
   188.
   189.    procedure enable (b : in KDF9.buffer_number) is
   190.    begin
   191.       GP0 := new GP.device (number  => b,
   192.                             kind    => GP_kind,
   193.                             unit    => 0,
   194.                             quantum => GP_quantum);
   195.       GP0_number := b;
   196.       the_graph_plotter_is_enabled := True;
   197.    end enable;
   198.
   199.    procedure notify_invalid_movement (from_x, from_y, step_x, step_y : in Integer) is
   200.    begin
   201.       trap_failing_IO_operation(
   202.                                 GP0.all,
   203.                                 "cannot move from <"
   204.                               & trimmed(from_x'Image)
   205.                               & ", "
   206.                               & trimmed(from_y'Image)
   207.                               & "> by <"
   208.                               & trimmed(step_x'Image)
   209.                               & ", "
   210.                               & trimmed(step_y'Image)
   211.                               & ">"
   212.                                );
   213.    end notify_invalid_movement;
   214.
   215. end IOC.slow.shift.GP;

Compiling: ../Source/ioc-slow-shift-gp.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:31

     1. -- ioc-slow-shift-gp.ads
     2. --
     3. -- Emulation of a Calcomp 564 graph plotter, switched to a tape punch buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.slow.shift.GP is
    20.
    21.    type device is new IOC.slow.shift.device with private;
    22.
    23.    overriding
    24.    procedure POA (the_GP      : in out GP.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    overriding
    29.    procedure POB (the_GP      : in out GP.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    overriding
    34.    procedure POC (the_GP      : in out GP.device;
    35.                   Q_operand   : in KDF9.Q_register;
    36.                   set_offline : in Boolean);
    37.
    38.    overriding
    39.    procedure POD (the_GP      : in out GP.device;
    40.                   Q_operand   : in KDF9.Q_register;
    41.                   set_offline : in Boolean);
    42.
    43.    -- the_T_bit_is_set (buffer is switched to graph plotter)
    44.    overriding
    45.    procedure PMB (the_GP      : in out GP.device;
    46.                   Q_operand   : in KDF9.Q_register;
    47.                   set_offline : in Boolean);
    48.
    49.    procedure enable (b : in KDF9.buffer_number);
    50.
    51.    procedure notify_invalid_movement (from_x, from_y, step_x, step_y : in Integer)
    52.       with Inline => False;
    53.
    54. private
    55.
    56.    type device is new IOC.slow.shift.device with null record;
    57.
    58.    overriding
    59.    procedure Initialize (the_GP : in out GP.device);
    60.
    61.    overriding
    62.    procedure Finalize (the_GP : in out GP.device);
    63.
    64.    overriding
    65.    procedure do_output_housekeeping (the_GP      : in out GP.device;
    66.                                      size, lifts : in     KDF9.word);
    67.
    68. end IOC.slow.shift.GP;

 215 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-slow-shift-si.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:31

     1. -- ioc-slow-shift-si.adb
     2. --
     3. -- Emulation of a standard interface buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Exceptions;
    20. --
    21. with IOC.equipment;
    22. with tracing;
    23.
    24. use  IOC.equipment;
    25. use  tracing;
    26.
    27. package body IOC.slow.shift.SI is
    28.
    29.    use KDF9_char_sets;
    30.
    31.    overriding
    32.    procedure Initialize (the_SI : in out SI.device) is
    33.    begin
    34.       -- Open the associated file.
    35.       open(IOC.device(the_SI), rd_wr_mode);
    36.    end Initialize;
    37.
    38.    overriding
    39.    procedure PIA (the_SI      : in out SI.device;
    40.                   Q_operand   : in KDF9.Q_register;
    41.                   set_offline : in Boolean) is
    42.    begin
    43.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    44.       read(the_SI, Q_operand);
    45.       lock_out_relative_addresses(Q_operand);
    46.    end PIA;
    47.
    48.    overriding
    49.    procedure PIB (the_SI      : in out SI.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean) is
    52.    begin
    53.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    54.       read_to_EM(the_SI, Q_operand);
    55.       lock_out_relative_addresses(Q_operand);
    56.    end PIB;
    57.
    58.    overriding
    59.    procedure PIC (the_SI      : in out SI.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean) is
    62.    begin
    63.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    64.       words_read(the_SI, Q_operand);
    65.       lock_out_relative_addresses(Q_operand);
    66.    end PIC;
    67.
    68.    overriding
    69.    procedure PID (the_SI      : in out SI.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean) is
    72.    begin
    73.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    74.       words_read_to_EM(the_SI, Q_operand);
    75.       lock_out_relative_addresses(Q_operand);
    76.    end PID;
    77.
    78.    overriding
    79.    procedure PIE (the_SI      : in out SI.device;
    80.                   Q_operand   : in KDF9.Q_register;
    81.                   set_offline : in Boolean) is
    82.    begin
    83.       -- as PIA: "parity off" has no effect on the data read in
    84.       PIA(the_SI, Q_operand, set_offline);
    85.    end PIE;
    86.
    87.    overriding
    88.    procedure PIF (the_SI      : in out SI.device;
    89.                   Q_operand   : in KDF9.Q_register;
    90.                   set_offline : in Boolean) is
    91.    begin
    92.       -- as PIB: "parity off" has no effect on the data read in
    93.       PIB(the_SI, Q_operand, set_offline);
    94.    end PIF;
    95.
    96.    overriding
    97.    procedure PIG (the_SI      : in out SI.device;
    98.                   Q_operand   : in KDF9.Q_register;
    99.                   set_offline : in Boolean) is
   100.    begin
   101.       PIC(the_SI, Q_operand, set_offline);
   102.    end PIG;
   103.
   104.    overriding
   105.    procedure PIH (the_SI      : in out SI.device;
   106.                   Q_operand   : in KDF9.Q_register;
   107.                   set_offline : in Boolean) is
   108.    begin
   109.       PID(the_SI, Q_operand, set_offline);
   110.    end PIH;
   111.
   112.    overriding
   113.    procedure PMB (the_SI      : in out SI.device;
   114.                   Q_operand   : in KDF9.Q_register;
   115.                   set_offline : in Boolean) is
   116.    begin
   117.       -- ee9's SI0 always asserts 8 channel mode.
   118.       validate_device(the_SI, Q_operand);
   119.       validate_parity(the_SI);
   120.       deal_with_a_busy_device(the_SI, 13, set_offline);
   121.       the_T_bit_is_set := True;
   122.       take_note_of_test(the_SI.device_name, Q_operand, the_T_bit_is_set);
   123.    end PMB;
   124.
   125.    overriding
   126.    procedure PMC (the_SI      : in out SI.device;
   127.                   Q_operand   : in KDF9.Q_register;
   128.                   set_offline : in Boolean) is
   129.    begin
   130.       PMB(the_SI, Q_operand, set_offline);
   131.    end PMC;
   132.
   133.    overriding
   134.    procedure POA (the_SI      : in out SI.device;
   135.                   Q_operand   : in KDF9.Q_register;
   136.                   set_offline : in Boolean) is
   137.    begin
   138.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   139.       write(the_SI, Q_operand);
   140.       lock_out_relative_addresses(Q_operand);
   141.    end POA;
   142.
   143.    overriding
   144.    procedure POB (the_SI      : in out SI.device;
   145.                   Q_operand   : in KDF9.Q_register;
   146.                   set_offline : in Boolean) is
   147.    begin
   148.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   149.       write_to_EM(the_SI, Q_operand);
   150.       lock_out_relative_addresses(Q_operand);
   151.    end POB;
   152.
   153.    overriding
   154.    procedure POC (the_SI      : in out SI.device;
   155.                   Q_operand   : in KDF9.Q_register;
   156.                   set_offline : in Boolean) is
   157.    begin
   158.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   159.       words_write(the_SI, Q_operand);
   160.       lock_out_relative_addresses(Q_operand);
   161.    end POC;
   162.
   163.    overriding
   164.    procedure POD (the_SI      : in out SI.device;
   165.                   Q_operand   : in KDF9.Q_register;
   166.                   set_offline : in Boolean) is
   167.    begin
   168.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   169.       words_write_to_EM(the_SI, Q_operand);
   170.       lock_out_relative_addresses(Q_operand);
   171.    end POD;
   172.
   173.    overriding
   174.    procedure POE (the_SI      : in out SI.device;
   175.                   Q_operand   : in KDF9.Q_register;
   176.                   set_offline : in Boolean) is
   177.    begin
   178.       require_nonnegative_count(Q_operand.M);
   179.       output_a_gap(the_SI, Q_operand, set_offline, word_mode => False, text_mode => False);
   180.    end POE;
   181.
   182.    overriding
   183.    procedure POF (the_SI      : in out SI.device;
   184.                   Q_operand   : in KDF9.Q_register;
   185.                   set_offline : in Boolean) is
   186.    begin
   187.       require_nonnegative_count(Q_operand.M);
   188.       output_a_gap(the_SI, Q_operand, set_offline, word_mode => True, text_mode => False);
   189.    end POF;
   190.
   191.    overriding
   192.    procedure Finalize (the_SI : in out SI.device) is
   193.    begin
   194.       close(
   195.             the_SI,
   196.             "transferred",
   197.             the_SI.byte_count,
   198.             "character" & plurality(the_SI.byte_count)
   199.            );
   200.    end Finalize;
   201.
   202.    type SI_access is access SI.device;
   203.
   204.    SI0 : SI_access with Warnings => Off;
   205.    SI1 : SI_access with Warnings => Off;
   206.
   207.    unit : IOC.unit_number := 0;
   208.
   209.    SI_quantum : constant := 1E6 / 50E3;  -- for 50_000 characters per second (a guess) !!
   210.
   211.    procedure enable (b : in KDF9.buffer_number) is
   212.    begin
   213.       case unit is
   214.          when 0 =>
   215.             SI0 := new SI.device (number  => b,
   216.                                   kind    => SI_kind,
   217.                                   unit    => 0,
   218.                                   quantum => SI_quantum);
   219.             SI0_number := b;
   220.          when 1 =>
   221.             SI1 := new SI.device (number  => b,
   222.                                   kind    => SI_kind,
   223.                                   unit    => 1,
   224.                                   quantum => SI_quantum);
   225.             SI1_number := b;
   226.          when others =>
   227.             trap_operator_error("SI:", "more than two units specified" & unit'Image & b'Image);
   228.       end case;
   229.       unit := unit + 1;
   230.    end enable;
   231.
   232.    procedure re_enable (b : in KDF9.buffer_number) is
   233.    begin
   234.       if SI0 /= null   and then
   235.             SI0.number = b then
   236.          return;
   237.       end if;
   238.       if SI1 /= null   and then
   239.             SI1.number = b then
   240.          return;
   241.       end if;
   242.       buffer(b) := null;
   243.       enable(b);
   244.    end re_enable;
   245.
   246.    function SI0_is_enabled
   247.    return Boolean
   248.    is (SI0 /= null or SI1 /= null);
   249.
   250. end IOC.slow.shift.SI;

Compiling: ../Source/ioc-slow-shift-si.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:31

     1. -- ioc-slow-shift-si.ads
     2. --
     3. -- Emulation of a standard interface buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.slow.shift.SI is
    20.
    21.    -- The Standard Interface Buffer is the KDF9 device about which least is presently known.
    22.    -- Anecdotal evidence suggests it is an implementation of the British Standard Interface (BSIF).
    23.    -- ee9 implements a best guess as to its functionality, based on the following considerations.
    24.
    25.    -- According to the Manual, Appendix 6.1, p.296,
    26.    --    the Standard Interface Buffer has orders that look very like the union of a TR and a TP.
    27.
    28.    -- However:
    29.
    30.    -- (a) PIE and PIF do a read with "parity off".
    31.    --     I think this relates to a feature of the BSIF,
    32.    --        whereby a source device can omit parity if it de-asserts its "parity valid" signal.
    33.    --     With such a device the KDF9 would need a way of ignoring spurious parity errors.
    34.    -- PIE/PIF act in exactly the same way as PIA/PIB as there will be no such error under ee9.
    35.
    36.    -- (b) PMB and PMC set the Test Register "if 8 channel set".  The BSIF is 8 data bits wide.
    37.    --     I think this signals that the KDF9 should use "character" orders to access all 8 bits,
    38.    --        and I think that the other orders access only the low-order 6 bits of the interface.
    39.    -- ee9 always asserts "8 channel set", as it is always capable of providing 8-bit bytes.
    40.
    41.    -- In any case, 6-bit transfers work in the same way as for paper tape readers and punches.
    42.
    43.    type device is new IOC.slow.shift.device with private;
    44.
    45.    overriding
    46.    procedure PIA (the_SI      : in out SI.device;
    47.                   Q_operand   : in KDF9.Q_register;
    48.                   set_offline : in Boolean);
    49.
    50.    overriding
    51.    procedure PIB (the_SI      : in out SI.device;
    52.                   Q_operand   : in KDF9.Q_register;
    53.                   set_offline : in Boolean);
    54.
    55.    overriding
    56.    procedure PIC (the_SI      : in out SI.device;
    57.                   Q_operand   : in KDF9.Q_register;
    58.                   set_offline : in Boolean);
    59.
    60.    overriding
    61.    procedure PID (the_SI      : in out SI.device;
    62.                   Q_operand   : in KDF9.Q_register;
    63.                   set_offline : in Boolean);
    64.
    65.    overriding
    66.    procedure PIE (the_SI      : in out SI.device;
    67.                   Q_operand   : in KDF9.Q_register;
    68.                   set_offline : in Boolean);
    69.
    70.    overriding
    71.    procedure PIF (the_SI      : in out SI.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    overriding
    76.    procedure PIG (the_SI      : in out SI.device;
    77.                   Q_operand   : in KDF9.Q_register;
    78.                   set_offline : in Boolean);
    79.
    80.    overriding
    81.    procedure PIH (the_SI      : in out SI.device;
    82.                   Q_operand   : in KDF9.Q_register;
    83.                   set_offline : in Boolean);
    84.
    85.    overriding
    86.    procedure PMB (the_SI      : in out SI.device;
    87.                   Q_operand   : in KDF9.Q_register;
    88.                   set_offline : in Boolean);
    89.
    90.    overriding
    91.    procedure PMC (the_SI      : in out SI.device;
    92.                   Q_operand   : in KDF9.Q_register;
    93.                   set_offline : in Boolean);
    94.
    95.    overriding
    96.    procedure POA (the_SI      : in out SI.device;
    97.                   Q_operand   : in KDF9.Q_register;
    98.                   set_offline : in Boolean);
    99.
   100.    overriding
   101.    procedure POB (the_SI      : in out SI.device;
   102.                   Q_operand   : in KDF9.Q_register;
   103.                   set_offline : in Boolean);
   104.
   105.    overriding
   106.    procedure POC (the_SI      : in out SI.device;
   107.                   Q_operand   : in KDF9.Q_register;
   108.                   set_offline : in Boolean);
   109.
   110.    overriding
   111.    procedure POD (the_SI      : in out SI.device;
   112.                   Q_operand   : in KDF9.Q_register;
   113.                   set_offline : in Boolean);
   114.
   115.    overriding
   116.    procedure POE (the_SI      : in out SI.device;
   117.                   Q_operand   : in KDF9.Q_register;
   118.                   set_offline : in Boolean);
   119.
   120.    overriding
   121.    procedure POF (the_SI      : in out SI.device;
   122.                   Q_operand   : in KDF9.Q_register;
   123.                   set_offline : in Boolean);
   124.
   125.    procedure enable (b : in KDF9.buffer_number);
   126.
   127.    procedure re_enable (b : in KDF9.buffer_number);
   128.
   129.    function SI0_is_enabled
   130.    return Boolean;
   131.
   132. private
   133.
   134.    type device is new IOC.slow.shift.device with null record;
   135.
   136.    overriding
   137.    procedure Initialize (the_SI : in out SI.device);
   138.
   139.    overriding
   140.    procedure Finalize (the_SI : in out SI.device);
   141.
   142. end IOC.slow.shift.SI;

 250 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-slow-unit.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:32

     1. -- ioc-slow-unit.adb
     2. --
     3. -- Emulation of the common functionality of "unit record" (i.e. LP, CP or CR) devices.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package body IOC.slow.unit is
    20.
    21.    overriding
    22.    function IO_elapsed_time_total (the_buffer : unit.device)
    23.    return KDF9.us is
    24.    begin
    25.       return IO_elapsed_time(the_buffer, the_buffer.unit_count);
    26.    end IO_elapsed_time_total;
    27.
    28.    overriding
    29.    function atomic_item_count (the_buffer : unit.device;
    30.                                Q_operand  : KDF9.Q_register)
    31.    return KDF9.word is
    32.       pragma Unreferenced(the_buffer);
    33.       pragma Unreferenced(Q_operand);
    34.    begin
    35.       return 1;
    36.    end atomic_item_count;
    37.
    38. end IOC.slow.unit;

Compiling: ../Source/ioc-slow-unit.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:32

     1. -- ioc-slow-unit.ads
     2. --
     3. -- Emulation of the common functionality of "unit record" (i.e. LP, CP or CR) devices.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.slow.unit is
    20.
    21.    --
    22.    -- This is the root type for all unit-record I/O device types.
    23.    --
    24.
    25.    type device is abstract new IOC.slow.device with private;
    26.
    27. private
    28.
    29.    type device is abstract new IOC.slow.device with
    30.       record
    31.          unit_count : KDF9.word := 0;
    32.       end record;
    33.
    34.    overriding
    35.    function IO_elapsed_time_total (the_buffer : unit.device)
    36.    return KDF9.us;
    37.
    38.    overriding
    39.    function atomic_item_count (the_buffer : unit.device;
    40.                                Q_operand  : KDF9.Q_register)
    41.    return KDF9.word;
    42.
    43. end IOC.slow.unit;

 38 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-slow-unit-cp.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:32

     1. -- ioc-unit-cp.adb
     2. --
     3. -- Emulation of a card punch buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with IOC.equipment;
    20.
    21. use  IOC.equipment;
    22.
    23. package body IOC.slow.unit.CP is
    24.
    25.    use KDF9_char_sets;
    26.
    27.    overriding
    28.    procedure Initialize (the_CP : in out CP.device) is
    29.    begin
    30.       open(the_CP, write_mode);
    31.    end Initialize;
    32.
    33.    procedure do_output_housekeeping (the_CP     : in out CP.device;
    34.                                      fetched    : in KDF9.word) is
    35.    begin
    36.       flush(the_CP.stream);
    37.       correct_transfer_time(the_CP, actual_length => 1);
    38.       add_in_the_IO_CPU_time(the_CP, fetched);
    39.    end do_output_housekeeping;
    40.
    41.    procedure write_card (the_CP        : in out CP.device;
    42.                          Q_operand     : in KDF9.Q_register;
    43.                          max_words     : in KDF9.address;
    44.                          writing_to_EM : in Boolean := False) is
    45.       start_address : constant KDF9.address := Q_operand.I;
    46.       end_address   : constant KDF9.address := Q_operand.M;
    47.       size : KDF9.word := 0;
    48.       char : Character;
    49.       byte : KDF9_char_sets.symbol;
    50.    begin
    51.       check_addresses_and_lockouts(start_address, end_address);
    52.    word_loop:
    53.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    54.          for c in KDF9_char_sets.symbol_index'Range loop
    55.             byte := fetch_symbol(w, c);
    56.             size := size + 1;
    57.             char := to_CP(byte);
    58.             put_byte(char, the_CP.stream);
    59.             exit word_loop when writing_to_EM and char = KDF9_char_sets.E_M;
    60.          end loop;
    61.       end loop word_loop;
    62.       put_EOL(the_CP.stream);
    63.       the_CP.unit_count := the_CP.unit_count + 1;
    64.       do_output_housekeeping(the_CP, fetched => size);
    65.    end write_card;
    66.
    67.    procedure words_write_card (the_CP        : in out CP.device;
    68.                                Q_operand     : in KDF9.Q_register;
    69.                                max_words     : in KDF9.address;
    70.                                writing_to_EM : in Boolean := False) is
    71.
    72.       start_address : constant KDF9.address := Q_operand.I;
    73.       end_address   : constant KDF9.address := Q_operand.M;
    74.       size : KDF9.word := 0;
    75.       char : Character;
    76.       byte : KDF9_char_sets.symbol;
    77.    begin
    78.       check_addresses_and_lockouts(start_address, end_address);
    79.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    80.          byte := KDF9_char_sets.symbol(fetch_word(w) and 8#77#);
    81.          size := size + 1;
    82.          char := to_CP(byte);
    83.          put_byte(char, the_CP.stream);
    84.       exit when writing_to_EM and char = KDF9_char_sets.E_M;
    85.       end loop;
    86.       put_EOL(the_CP.stream);
    87.       the_CP.unit_count := the_CP.unit_count + 1;
    88.       do_output_housekeeping(the_CP, fetched => size);
    89.    end words_write_card;
    90.
    91.    overriding
    92.    procedure POA (the_CP      : in out CP.device;
    93.                   Q_operand   : in KDF9.Q_register;
    94.                   set_offline : in Boolean) is
    95.    begin
    96.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
    97.       write_card(the_CP, Q_operand, max_words => 20);
    98.       lock_out_relative_addresses(Q_operand);
    99.    end POA;
   100.
   101.    overriding
   102.    procedure POB (the_CP      : in out CP.device;
   103.                   Q_operand   : in KDF9.Q_register;
   104.                   set_offline : in Boolean) is
   105.    begin
   106.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   107.       write_card(the_CP, Q_operand, max_words => 20, writing_to_EM => True);
   108.       lock_out_relative_addresses(Q_operand);
   109.    end POB;
   110.
   111.    overriding
   112.    procedure POC (the_CP      : in out CP.device;
   113.                   Q_operand   : in KDF9.Q_register;
   114.                   set_offline : in Boolean) is
   115.    begin
   116.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   117.       words_write_card(the_CP, Q_operand, max_words => 160);
   118.       lock_out_relative_addresses(Q_operand);
   119.    end POC;
   120.
   121.    overriding
   122.    procedure POD (the_CP      : in out CP.device;
   123.                   Q_operand   : in KDF9.Q_register;
   124.                   set_offline : in Boolean) is
   125.    begin
   126.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   127.       words_write_card(the_CP, Q_operand, max_words => 160, writing_to_EM => True);
   128.       lock_out_relative_addresses(Q_operand);
   129.    end POD;
   130.
   131.    overriding
   132.    procedure POE (the_CP      : in out CP.device;
   133.                   Q_operand   : in KDF9.Q_register;
   134.                   set_offline : in Boolean) is
   135.    begin
   136.       POC(the_CP, Q_operand, set_offline);
   137.    end POE;
   138.
   139.    overriding
   140.    procedure POF (the_CP      : in out CP.device;
   141.                   Q_operand   : in KDF9.Q_register;
   142.                   set_offline : in Boolean) is
   143.    begin
   144.       POA(the_CP, Q_operand, set_offline);
   145.    end POF;
   146.
   147.    overriding
   148.    procedure POG (the_CP      : in out CP.device;
   149.                   Q_operand   : in KDF9.Q_register;
   150.                   set_offline : in Boolean) is
   151.    begin
   152.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   153.       write_card(the_CP, Q_operand, max_words => 10, writing_to_EM => False);
   154.       lock_out_relative_addresses(Q_operand);
   155.    end POG;
   156.
   157.    overriding
   158.    procedure POH (the_CP      : in out CP.device;
   159.                   Q_operand   : in KDF9.Q_register;
   160.                   set_offline : in Boolean) is
   161.    begin
   162.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   163.       write_card(the_CP, Q_operand, max_words => 10, writing_to_EM => True);
   164.       lock_out_relative_addresses(Q_operand);
   165.    end POH;
   166.
   167.    overriding
   168.    procedure POK (the_CP      : in out CP.device;
   169.                   Q_operand   : in KDF9.Q_register;
   170.                   set_offline : in Boolean) is
   171.    begin
   172.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   173.       -- See the Manual, p289.
   174.       words_write_card(the_CP, Q_operand, max_words => 80, writing_to_EM => True);
   175.       lock_out_relative_addresses(Q_operand);
   176.    end POK;
   177.
   178.    overriding
   179.    procedure POL (the_CP      : in out CP.device;
   180.                   Q_operand   : in KDF9.Q_register;
   181.                   set_offline : in Boolean) is
   182.    begin
   183.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   184.       -- See the Manual, p289.
   185.       words_write_card(the_CP, Q_operand, max_words => 80, writing_to_EM => False);
   186.       lock_out_relative_addresses(Q_operand);
   187.    end POL;
   188.
   189.    overriding
   190.    procedure Finalize (the_CP : in out CP.device) is
   191.    begin
   192.       close(
   193.             the_CP,
   194.             "punched",
   195.             the_CP.unit_count,
   196.             "card" & plurality(the_CP.unit_count)
   197.            );
   198.    end Finalize;
   199.
   200.    CP_quantum : constant := 1E6 / (300 / 60); -- 300 cards per minute.
   201.
   202.    type CP_access is access CP.device;
   203.
   204.    CP0 : CP_access with Warnings => Off;
   205.    CP1 : CP_access with Warnings => Off;
   206.
   207.    unit : IOC.unit_number := 0;
   208.
   209.    procedure enable (b : in KDF9.buffer_number) is
   210.    begin
   211.       case unit is
   212.          when 0 =>
   213.             CP0 := new CP.device (number  => b,
   214.                                   kind    => CP_kind,
   215.                                   unit    => 0,
   216.                                   quantum => CP_quantum);
   217.             CP0_number := b;
   218.          when 1 =>
   219.             CP1 := new CP.device (number  => b,
   220.                                   kind    => CP_kind,
   221.                                   unit    => 1,
   222.                                   quantum => CP_quantum);
   223.             CP1_number := b;
   224.          when others =>
   225.             trap_operator_error("CP:", "more than two units specified");
   226.       end case;
   227.       unit := unit + 1;
   228.    end enable;
   229.
   230. end IOC.slow.unit.CP;

Compiling: ../Source/ioc-slow-unit-cp.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:32

     1. -- ioc-unit-cp.ads
     2. --
     3. -- Emulation of a card punch buffer.
     4. -- Card punches are "unit record" devices: they cannot transfer less than a whole card.
     5. --
     6. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     7. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     8. --
     9. -- The ee9 program is free software; you can redistribute it and/or
    10. -- modify it under terms of the GNU General Public License as published
    11. -- by the Free Software Foundation; either version 3, or (at your option)
    12. -- any later version. This program is distributed in the hope that it
    13. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    14. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    15. -- See the GNU General Public License for more details. You should have
    16. -- received a copy of the GNU General Public License distributed with
    17. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    18. --
    19.
    20. package IOC.slow.unit.CP is
    21.
    22.    type device is new IOC.slow.unit.device with private;
    23.
    24.    -- Punch binary mode.
    25.    overriding
    26.    procedure POA (the_CP      : in out CP.device;
    27.                   Q_operand   : in KDF9.Q_register;
    28.                   set_offline : in Boolean);
    29.
    30.    -- Punch binary mode to End Message.
    31.    overriding
    32.    procedure POB (the_CP      : in out CP.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    -- Punch binary character mode.
    37.    overriding
    38.    procedure POC (the_CP      : in out CP.device;
    39.                   Q_operand   : in KDF9.Q_register;
    40.                   set_offline : in Boolean);
    41.
    42.    -- Punch binary character mode to End Message.
    43.    overriding
    44.    procedure POD (the_CP      : in out CP.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    -- As POC.
    49.    overriding
    50.    procedure POE (the_CP      : in out CP.device;
    51.                   Q_operand   : in KDF9.Q_register;
    52.                   set_offline : in Boolean);
    53.
    54.    -- As POA.
    55.    overriding
    56.    procedure POF (the_CP      : in out CP.device;
    57.                   Q_operand   : in KDF9.Q_register;
    58.                   set_offline : in Boolean);
    59.
    60.    -- Punch alphanumeric mode.
    61.    overriding
    62.    procedure POG (the_CP      : in out CP.device;
    63.                   Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean);
    65.
    66.    -- Punch alphanumeric mode to End Message.
    67.    overriding
    68.    procedure POH (the_CP      : in out CP.device;
    69.                   Q_operand   : in KDF9.Q_register;
    70.                   set_offline : in Boolean);
    71.
    72.    -- Punch alphanumeric character mode to End Message.
    73.    overriding
    74.    procedure POK (the_CP      : in out CP.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.
    78.    -- Punch alphanumeric character mode.
    79.    overriding
    80.    procedure POL (the_CP      : in out CP.device;
    81.                   Q_operand   : in KDF9.Q_register;
    82.                   set_offline : in Boolean);
    83.
    84.    procedure enable (b : in KDF9.buffer_number);
    85.
    86. private
    87.
    88.    type device is new IOC.slow.unit.device with null record;
    89.
    90.    overriding
    91.    procedure Initialize (the_CP : in out CP.device);
    92.
    93.    overriding
    94.    procedure Finalize (the_CP : in out CP.device);
    95.
    96. end IOC.slow.unit.CP;

 230 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-slow-unit-cr.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:32

     1. -- ioc-unit-cr.adb
     2. --
     3. -- Emulation of a card reader buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with IOC.equipment;
    20. with tracing;
    21.
    22. use  IOC.equipment;
    23. use  tracing;
    24.
    25. package body IOC.slow.unit.CR is
    26.
    27.    use KDF9_char_sets;
    28.
    29.    overriding
    30.    procedure Initialize (the_CR : in out CR.device) is
    31.    begin
    32.       open(the_CR, read_mode);
    33.    end Initialize;
    34.
    35.    blank_card : constant String(max_card_columns) := (others => SP);
    36.
    37.    procedure get_card_image (the_CR         : in out CR.device;
    38.                               size          : in out KDF9.word;
    39.                               max_columns   : in KDF9.address;
    40.                               reading_to_EM : in Boolean := False) is
    41.       max  : constant Positive := Positive(max_columns);
    42.       char : Character;
    43.    begin
    44.       -- Clear out the card image field.
    45.       the_CR.card_image(1..max) := blank_card(1..max);
    46.       -- Fill as much of the card image as possible with the next data line, padded out with
    47.       --    blanks, so that it is unnecessary to type all 80 or 160 characters.
    48.       -- For transfers to End Message, a line terminator must follow the E_M.
    49.       for i in 1 .. max loop
    50.          get_char_from_stream (char, the_CR);
    51.          size := size + 1;
    52.       exit when char = LF;
    53.          the_CR.card_image(i) := char;
    54.       exit when reading_to_EM and char = KDF9_char_sets.E_M;
    55.       end loop;
    56.       if char /= KDF9_char_sets.E_M then  -- The whole card was read.
    57.          size := KDF9.word(max);
    58.       end if;
    59.       the_CR.unit_count := the_CR.unit_count + 1;
    60.       -- Discard excess characters in the current data line.
    61.       while char /= LF loop
    62.          get_char_from_stream (char, the_CR);  -- N.B. do not update size for discards.
    63.       end loop;
    64.    exception
    65.       when end_of_stream =>
    66.          flush(the_CR.stream);
    67.          the_CR.is_abnormal := True;
    68.          raise;
    69.    end get_card_image;
    70.
    71.    procedure do_input_housekeeping (the_CR  : in out CR.device;
    72.                                     fetched : in KDF9.word) is
    73.    begin
    74.       add_in_the_IO_CPU_time(the_CR, fetched);
    75.       correct_transfer_time(the_CR, actual_length => 1);
    76.    end do_input_housekeeping;
    77.
    78.    procedure read_card (the_CR        : in out CR.device;
    79.                         Q_operand     : in KDF9.Q_register;
    80.                         max_words     : in KDF9.address;
    81.                         reading_to_EM : in Boolean := False) is
    82.       start_address : constant KDF9.address := Q_operand.I;
    83.       end_address   : constant KDF9.address := Q_operand.M;
    84.       size : KDF9.word := 0;
    85.       next : Natural := 0;
    86.       char : Character;
    87.       byte : KDF9_char_sets.symbol;
    88.    begin
    89.       check_addresses_and_lockouts(start_address, end_address);
    90.       get_card_image(the_CR, size, max_columns => max_words*8);
    91.    word_loop:
    92.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    93.          for c in KDF9_char_sets.symbol_index'Range loop
    94.             next := next + 1;
    95.             char := the_CR.card_image(next);
    96.             byte := CR_in(char);
    97.             store_symbol(byte, w, c);
    98.             if reading_to_EM and byte = KDF9_char_sets.End_Message then
    99.                for d in 1 .. 7-c loop
   100.                   store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
   101.                end loop;
   102.                exit word_loop;
   103.             end if;
   104.          end loop;
   105.       end loop word_loop;
   106.       do_input_housekeeping(the_CR, size);
   107.    exception
   108.       when end_of_stream =>
   109.          do_input_housekeeping(the_CR, size);
   110.    end read_card;
   111.
   112.    procedure words_read_card (the_CR        : in out CR.device;
   113.                               Q_operand     : in KDF9.Q_register;
   114.                               max_words     : in KDF9.address;
   115.                               reading_to_EM : in Boolean := False) is
   116.       start_address : constant KDF9.address := Q_operand.I;
   117.       end_address   : constant KDF9.address := Q_operand.M;
   118.       size : KDF9.word := 0;
   119.       next : Natural := 0;
   120.       char : Character;
   121.       word : KDF9.word;
   122.    begin
   123.       check_addresses_and_lockouts(start_address, end_address);
   124.       get_card_image(the_CR, size, max_columns => max_words);
   125.       if the_CR.is_abnormal then return; end if;
   126.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
   127.          next := next + 1;
   128.          char := the_CR.card_image(next);
   129.          word := KDF9.word(CR_in(char));
   130.          store_word(word, w);
   131.       exit when reading_to_EM and char = KDF9_char_sets.E_M;
   132.       end loop;
   133.       add_in_the_IO_CPU_time(the_CR, size);
   134.       correct_transfer_time(the_CR, actual_length => 1);
   135.    exception
   136.       when end_of_stream =>
   137.          flush(the_CR.stream);
   138.          add_in_the_IO_CPU_time(the_CR, size);
   139.          correct_transfer_time(the_CR, actual_length => 1);
   140.    end words_read_card;
   141.
   142.    overriding
   143.    procedure PIA (the_CR      : in out CR.device;
   144.                   Q_operand   : in KDF9.Q_register;
   145.                   set_offline : in Boolean) is
   146.    begin
   147.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   148.       read_card(the_CR, Q_operand, max_words => 20);
   149.       lock_out_relative_addresses(Q_operand);
   150.    end PIA;
   151.
   152.    overriding
   153.    procedure PIB (the_CR      : in out CR.device;
   154.                   Q_operand   : in KDF9.Q_register;
   155.                   set_offline : in Boolean) is
   156.    begin
   157.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   158.       read_card(the_CR, Q_operand, max_words => 20, reading_to_EM => True);
   159.       lock_out_relative_addresses(Q_operand);
   160.    end PIB;
   161.
   162.    overriding
   163.    procedure PIC (the_CR      : in out CR.device;
   164.                   Q_operand   : in KDF9.Q_register;
   165.                   set_offline : in Boolean) is
   166.    begin
   167.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   168.       words_read_card(the_CR, Q_operand, max_words => 160);
   169.       lock_out_relative_addresses(Q_operand);
   170.    end PIC;
   171.
   172.    overriding
   173.    procedure PID (the_CR      : in out CR.device;
   174.                   Q_operand   : in KDF9.Q_register;
   175.                   set_offline : in Boolean) is
   176.    begin
   177.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   178.       words_read_card(the_CR, Q_operand, max_words => 160, reading_to_EM => True);
   179.       lock_out_relative_addresses(Q_operand);
   180.    end PID;
   181.
   182.    overriding
   183.    procedure PIE (the_CR      : in out CR.device;
   184.                   Q_operand   : in KDF9.Q_register;
   185.                   set_offline : in Boolean) is
   186.    begin
   187.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   188.       read_card(the_CR, Q_operand, max_words => 10);
   189.       lock_out_relative_addresses(Q_operand);
   190.    end PIE;
   191.
   192.    overriding
   193.    procedure PIF (the_CR      : in out CR.device;
   194.                   Q_operand   : in KDF9.Q_register;
   195.                   set_offline : in Boolean) is
   196.    begin
   197.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   198.       read_card(the_CR, Q_operand, max_words => 10, reading_to_EM => True);
   199.       lock_out_relative_addresses(Q_operand);
   200.    end PIF;
   201.
   202.    overriding
   203.    procedure PIG (the_CR      : in out CR.device;
   204.                   Q_operand   : in KDF9.Q_register;
   205.                   set_offline : in Boolean) is
   206.    begin
   207.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   208.       words_read_card(the_CR, Q_operand, max_words => 80);
   209.       lock_out_relative_addresses(Q_operand);
   210.    end PIG;
   211.
   212.    overriding
   213.    procedure PIH (the_CR      : in out CR.device;
   214.                   Q_operand   : in KDF9.Q_register;
   215.                   set_offline : in Boolean) is
   216.    begin
   217.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   218.       words_read_card(the_CR, Q_operand, max_words => 80, reading_to_EM => True);
   219.       lock_out_relative_addresses(Q_operand);
   220.    end PIH;
   221.
   222.    -- the_T_bit_is_set := (RECHECK switch is OFF). {It always is nowadays!}
   223.    overriding
   224.    procedure PMB (the_CR      : in out CR.device;
   225.                   Q_operand   : in KDF9.Q_register;
   226.                   set_offline : in Boolean) is
   227.    begin
   228.       validate_device(the_CR, Q_operand);
   229.       validate_parity(the_CR);
   230.       deal_with_a_busy_device(the_CR, 13, set_offline);
   231.       the_T_bit_is_set := True;
   232.       take_note_of_test(the_CR.device_name, Q_operand, the_T_bit_is_set);
   233.    end PMB;
   234.
   235.    overriding
   236.    procedure Finalize (the_CR : in out CR.device) is
   237.    begin
   238.       close(
   239.             the_CR,
   240.             "read",
   241.             the_CR.unit_count,
   242.             "card" & plurality(the_CR.unit_count)
   243.            );
   244.    end Finalize;
   245.
   246.    CR_quantum : constant := 1E6 / (600 / 60); -- 600 cards per minute.
   247.
   248.    type CR_access is access CR.device;
   249.
   250.    CR0 : CR_access with Warnings => Off;
   251.    CR1 : CR_access with Warnings => Off;
   252.
   253.    unit : IOC.unit_number := 0;
   254.
   255.    procedure enable (b : in KDF9.buffer_number) is
   256.    begin
   257.       case unit is
   258.          when 0 =>
   259.             CR0 := new CR.device (number  => b,
   260.                                   kind    => CR_kind,
   261.                                   unit    => 0,
   262.                                   quantum => CR_quantum);
   263.             CR0_number := b;
   264.          when 1 =>
   265.             CR1 := new CR.device (number  => b,
   266.                                   kind    => CR_kind,
   267.                                   unit    => 1,
   268.                                   quantum => CR_quantum);
   269.             CR1_number := b;
   270.          when others =>
   271.             trap_operator_error("CR:", "more than two units specified");
   272.       end case;
   273.       unit := unit + 1;
   274.    end enable;
   275.
   276. end IOC.slow.unit.CR;

Compiling: ../Source/ioc-slow-unit-cr.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:32

     1. -- ioc-slow-unit-cr.ads
     2. --
     3. -- Emulation of a card reader buffer.
     4. -- Card readers are "unit record" devices: they cannot transfer less than a whole card.
     5. --
     6. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     7. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     8. --
     9. -- The ee9 program is free software; you can redistribute it and/or
    10. -- modify it under terms of the GNU General Public License as published
    11. -- by the Free Software Foundation; either version 3, or (at your option)
    12. -- any later version. This program is distributed in the hope that it
    13. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    14. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    15. -- See the GNU General Public License for more details. You should have
    16. -- received a copy of the GNU General Public License distributed with
    17. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    18. --
    19.
    20. package IOC.slow.unit.CR is
    21.
    22.    type device is new IOC.slow.unit.device with private;
    23.
    24.    -- Binary (undecoded) read
    25.    overriding
    26.    procedure PIA (the_CR      : in out CR.device;
    27.                   Q_operand   : in KDF9.Q_register;
    28.                   set_offline : in Boolean);
    29.
    30.    -- Binary (undecoded) read to End_Message
    31.    overriding
    32.    procedure PIB (the_CR      : in out CR.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    -- Binary (undecoded) character read
    37.    overriding
    38.    procedure PIC (the_CR      : in out CR.device;
    39.                   Q_operand   : in KDF9.Q_register;
    40.                   set_offline : in Boolean);
    41.
    42.    -- Binary (undecoded) character read to End_Message
    43.    overriding
    44.    procedure PID (the_CR      : in out CR.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    -- Alphanumeric (decoded) read
    49.    overriding
    50.    procedure PIE (the_CR      : in out CR.device;
    51.                   Q_operand   : in KDF9.Q_register;
    52.                   set_offline : in Boolean);
    53.
    54.    -- Alphanumeric (decoded) read to End_Message
    55.    overriding
    56.    procedure PIF (the_CR      : in out CR.device;
    57.                   Q_operand   : in KDF9.Q_register;
    58.                   set_offline : in Boolean);
    59.
    60.    -- Alphanumeric (decoded) character read
    61.    overriding
    62.    procedure PIG (the_CR      : in out CR.device;
    63.                   Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean);
    65.
    66.    -- Alphanumeric (decoded) character read to End_Message
    67.    overriding
    68.    procedure PIH (the_CR      : in out CR.device;
    69.                   Q_operand   : in KDF9.Q_register;
    70.                   set_offline : in Boolean);
    71.
    72.    -- the_T_bit_is_set := (RECHECK switch is OFF)
    73.    overriding
    74.    procedure PMB (the_CR      : in out CR.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.
    78.    procedure enable (b : in KDF9.buffer_number);
    79.
    80. private
    81.
    82.    subtype max_card_columns is Positive range 1 .. 160;
    83.
    84.    type device is new IOC.slow.unit.device with
    85.       record
    86.          card_image : String(max_card_columns);
    87.       end record;
    88.
    89.    overriding
    90.    procedure Initialize (the_CR : in out CR.device);
    91.
    92.    overriding
    93.    procedure Finalize (the_CR : in out CR.device);
    94.
    95. end IOC.slow.unit.CR;

 276 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-slow-unit-lp.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:32

     1. -- ioc-slow-unit-lp.adb
     2. --
     3. -- Emulation of a lineprinter buffer.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with IOC.equipment;
    20.
    21. use  IOC.equipment;
    22.
    23. package body IOC.slow.unit.LP is
    24.
    25.    use KDF9_char_sets;
    26.
    27.    overriding
    28.    procedure Initialize (the_LP : in out LP.device) is
    29.    begin
    30.       open(the_LP, write_mode);
    31.    end Initialize;
    32.
    33.    max_LP_line_length : constant := 160;  -- This is a hardware limit.
    34.    max_LP_page_length : constant :=  66;  -- This is the length of a page of standard stationery.
    35.
    36.    -- The number of lines traversed by paper motion with a standard control loop.
    37.    function skip_length (the_LP : LP.device; symbol : KDF9_char_sets.symbol)
    38.    return KDF9.word
    39.    is (
    40.        if symbol = KDF9_char_sets.Page_Change
    41.        then max_LP_page_length - the_LP.unit_count mod max_LP_page_length
    42.        else 1
    43.       );
    44.
    45.    procedure do_output_housekeeping (the_LP   : in out LP.device;
    46.                                      old_count,
    47.                                      fetched  : in KDF9.word) is
    48.    begin
    49.       flush(the_LP.stream);
    50.       correct_transfer_time(the_LP, IO_elapsed_time(the_LP, the_LP.unit_count-old_count));
    51.       add_in_the_IO_CPU_time(the_LP, fetched);
    52.    end do_output_housekeeping;
    53.
    54.    next_column : Natural := 0;
    55.
    56.    procedure print (symbol : in KDF9_char_sets.symbol; the_LP : in out LP.device) is
    57.       char : constant Character := to_LP(symbol);
    58.    begin
    59.       if char /= KDF9_char_sets.W_F then
    60.          if symbol in KDF9_char_sets.Line_Shift | KDF9_char_sets.Page_Change then
    61.             the_LP.unit_count := the_LP.unit_count + skip_length(the_LP, symbol);
    62.             put_char(char, the_LP.stream);
    63.             next_column := 0;
    64.          elsif next_column < max_LP_line_length then
    65.             next_column := next_column + 1;
    66.             put_char(char, the_LP.stream);
    67.          end if;
    68.       end if;
    69.    end print;
    70.
    71.    -- It is unclear what should happen if more than max_LP_line_length printable characters
    72.    --    are sent to the printer before a LS or PC character, which empties the print matrix.
    73.    -- ee9 simply ignores the excess.
    74.
    75.    procedure put_symbols (the_LP        : in out LP.device;
    76.                           Q_operand     : in KDF9.Q_register;
    77.                           writing_to_EM : in Boolean) is
    78.       start_address : constant KDF9.address := Q_operand.I;
    79.       end_address   : constant KDF9.address := Q_operand.M;
    80.       count         : constant KDF9.word := the_LP.unit_count;
    81.       size   : KDF9.word := 0;
    82.       symbol : KDF9_char_sets.symbol;
    83.    begin
    84.       check_addresses_and_lockouts(start_address, end_address);
    85.    word_loop:
    86.       for w in start_address .. end_address loop
    87.          for c in KDF9_char_sets.symbol_index'Range loop
    88.             symbol := fetch_symbol(w, c);
    89.             size := size + 1;
    90.       -- Is this what should happen transfers on EM, leaving the print matrix ready for more data ??
    91.       exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
    92.             print(symbol, the_LP);
    93.          end loop;
    94.       end loop word_loop;
    95.       do_output_housekeeping(the_LP, old_count => count, fetched => size);
    96.    end put_symbols;
    97.
    98.    -- LPQq
    99.    overriding
   100.    procedure POA (the_LP      : in out LP.device;
   101.                   Q_operand   : in KDF9.Q_register;
   102.                   set_offline : in Boolean) is
   103.    begin
   104.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   105.       put_symbols(the_LP, Q_operand, writing_to_EM => False);
   106.       lock_out_relative_addresses(Q_operand);
   107.    end POA;
   108.
   109.    -- LPEQq
   110.    overriding
   111.    procedure POB (the_LP      : in out LP.device;
   112.                   Q_operand   : in KDF9.Q_register;
   113.                   set_offline : in Boolean) is
   114.    begin
   115.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   116.       put_symbols(the_LP, Q_operand, writing_to_EM => True);
   117.       lock_out_relative_addresses(Q_operand);
   118.    end POB;
   119.
   120.    procedure put_words (the_LP        : in out LP.device;
   121.                         Q_operand     : in KDF9.Q_register;
   122.                         writing_to_EM : in Boolean) is
   123.       start_address : constant KDF9.address := Q_operand.I;
   124.       end_address   : constant KDF9.address := Q_operand.M;
   125.       count         : constant KDF9.word := the_LP.unit_count;
   126.       size   : KDF9.word := 0;
   127.       symbol : KDF9_char_sets.symbol;
   128.    begin
   129.       check_addresses_and_lockouts(start_address, end_address);
   130.       for w in start_address .. end_address loop
   131.          symbol := KDF9_char_sets.symbol(fetch_word(w) and 8#77#);
   132.          size := size + 1;
   133.       -- Is this what should happen transfers on EM, leaving the print matrix ready for more data ??
   134.       exit when writing_to_EM and symbol = KDF9_char_sets.End_Message;
   135.          print(symbol, the_LP);
   136.       end loop;
   137.       do_output_housekeeping(the_LP, old_count => count, fetched => size);
   138.    end put_words;
   139.
   140.    -- Character write ?? Usercode Digest and Manual conflict!
   141.    overriding
   142.    procedure POC (the_LP      : in out LP.device;
   143.                   Q_operand   : in KDF9.Q_register;
   144.                   set_offline : in Boolean) is
   145.    begin
   146.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   147.       put_words(the_LP, Q_operand, writing_to_EM => False);
   148.       lock_out_relative_addresses(Q_operand);
   149.    end POC;
   150.
   151.    -- Character write to End_Message ?? Usercode Digest and Manual conflict!
   152.    overriding
   153.    procedure POD (the_LP      : in out LP.device;
   154.                   Q_operand   : in KDF9.Q_register;
   155.                   set_offline : in Boolean) is
   156.    begin
   157.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   158.       put_words(the_LP, Q_operand, writing_to_EM => True);
   159.       lock_out_relative_addresses(Q_operand);
   160.    end POD;
   161.
   162.    overriding
   163.    procedure Finalize (the_LP : in out LP.device) is
   164.    begin
   165.       close(
   166.             the_LP,
   167.             "printed",
   168.             the_LP.unit_count,
   169.             "line" & plurality(the_LP.unit_count)
   170.            );
   171.    end Finalize;
   172.
   173.    LP_quantum : constant := 1E6 / (900 / 60);  -- 900 lines per minute.
   174.
   175.    type LP_access is access LP.device;
   176.
   177.    LP0 : LP_access with Warnings => Off;
   178.    LP1 : LP_access with Warnings => Off;
   179.
   180.    unit : IOC.unit_number := 0;
   181.
   182.    procedure enable (b : in KDF9.buffer_number) is
   183.    begin
   184.       case unit is
   185.          when 0 =>
   186.             LP0 := new LP.device (number  => b,
   187.                                   kind    => LP_kind,
   188.                                   unit    => 0,
   189.                                   quantum => LP_quantum);
   190.             LP0_number := b;
   191.          when 1 =>
   192.             LP1 := new LP.device (number  => b,
   193.                                   kind    => LP_kind,
   194.                                   unit    => 1,
   195.                                   quantum => LP_quantum);
   196.             LP1_number := b;
   197.          when others =>
   198.             trap_operator_error("LP:", "more than two units specified");
   199.       end case;
   200.       unit := unit + 1;
   201.    end enable;
   202.
   203. end IOC.slow.unit.LP;

Compiling: ../Source/ioc-slow-unit-lp.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:32

     1. -- ioc-slow-unit-lp.ads
     2. --
     3. -- Emulation of a lineprinter buffer.
     4. -- Lineprinters are "unit record" devices: they cannot transfer less than a whole line.
     5. --
     6. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     7. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     8. --
     9. -- The ee9 program is free software; you can redistribute it and/or
    10. -- modify it under terms of the GNU General Public License as published
    11. -- by the Free Software Foundation; either version 3, or (at your option)
    12. -- any later version. This program is distributed in the hope that it
    13. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    14. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    15. -- See the GNU General Public License for more details. You should have
    16. -- received a copy of the GNU General Public License distributed with
    17. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    18. --
    19.
    20. package IOC.slow.unit.LP is
    21.
    22.    type device is new IOC.slow.unit.device with private;
    23.
    24.    -- LPQq
    25.    overriding
    26.    procedure POA (the_LP      : in out LP.device;
    27.                   Q_operand   : in KDF9.Q_register;
    28.                   set_offline : in Boolean);
    29.
    30.    -- LPEQq
    31.    overriding
    32.    procedure POB (the_LP      : in out LP.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    -- Character write ??
    37.    overriding
    38.    procedure POC (the_LP      : in out LP.device;
    39.                   Q_operand   : in KDF9.Q_register;
    40.                   set_offline : in Boolean);
    41.
    42.    -- Character write to End_Message ??
    43.    overriding
    44.    procedure POD (the_LP      : in out LP.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    procedure enable (b : in KDF9.buffer_number);
    49.
    50. private
    51.
    52.    type device is new IOC.slow.unit.device with null record;
    53.
    54.    overriding
    55.    procedure Initialize (the_LP : in out LP.device);
    56.
    57.    overriding
    58.    procedure Finalize (the_LP : in out LP.device);
    59.
    60. end IOC.slow.unit.LP;

 203 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/environmental_value_of.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:33

     1. -- environmental_value_of.adb
     2. --
     3. -- Get the value of an environment variable.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Environment_Variables;
    20.
    21. function environmental_value_of (name, default : String)
    22. return String is
    23.    value : constant String := Ada.Environment_Variables.Value(name, "");
    24. begin
    25.    return (if value = "" then default else value);
    26. end environmental_value_of;

 26 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/os_specifics.adb
Source file time stamp: 2020-12-30 00:11:18
Compiled at: 2020-12-30 00:11:33

     1. -- OS_specifics.adb
     2. --
     3. -- Specific feature values and operation for the console terminal streams.
     4. -- This is the Linux, macOS and UNIX version.
     5. --
     6. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     7. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     8. --
     9. -- The ee9 program is free software; you can redistribute it and/or
    10. -- modify it under terms of the GNU General Public License as published
    11. -- by the Free Software Foundation; either version 3, or (at your option)
    12. -- any later version. This program is distributed in the hope that it
    13. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    14. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    15. -- See the GNU General Public License for more details. You should have
    16. -- received a copy of the GNU General Public License distributed with
    17. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    18. --
    19.
    20. package body OS_specifics is
    21.
    22.    procedure make_transparent (fd : in Integer) is null;
    23.
    24.    function EOL
    25.    return String
    26.    is (1 => Character'Val(16#0A#));
    27.
    28.    function UI_in_name
    29.    return String
    30.    is ("/dev/tty");
    31.
    32.    function UI_out_name
    33.    return String
    34.    is ("/dev/tty");
    35.
    36. end OS_specifics;

Compiling: ../Source/os_specifics.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:33

     1. -- OS_specifics.ads
     2. --
     3. -- Specific feature values and operation for the console terminal streams.
     4. -- This specification is the same for Windows, Linux, macOS and UNIX versions of ee9.
     5. --
     6. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     7. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     8. --
     9. -- The ee9 program is free software; you can redistribute it and/or
    10. -- modify it under terms of the GNU General Public License as published
    11. -- by the Free Software Foundation; either version 3, or (at your option)
    12. -- any later version. This program is distributed in the hope that it
    13. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    14. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    15. -- See the GNU General Public License for more details. You should have
    16. -- received a copy of the GNU General Public License distributed with
    17. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    18. --
    19.
    20. package OS_specifics is
    21.
    22.    -- make_transparent sets the "binary" mode of I/O on Windows/Cygwin.
    23.    -- It does nothing on UNIX-family systems, where no such precaution is necessary.
    24.    procedure make_transparent (fd : in Integer);
    25.
    26.    -- UI_in_name returns the interactive input device name appropriate to the host OS, e.g.:
    27.    -- "/dev/tty"  for macOS/UNIX/Linux,
    28.    -- "CONIN$" for Windows.
    29.    function UI_in_name
    30.    return String;
    31.
    32.    -- UI_out_name returns the interactive output device name appropriate to the host OS, e.g.:
    33.    -- "/dev/tty"  for macOS/UNIX/Linux,
    34.    -- "CONOUT$" for Windows.
    35.    function UI_out_name
    36.    return String;
    37.
    38.    -- EOL returns the appropriate line terminator for the selected host OS, e.g.:
    39.    -- LF for macOS/UNIX/Linux,
    40.    -- CRLF for Windows.
    41.    function EOL
    42.    return String;
    43.
    44. end OS_specifics;

 36 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/kdf9-directors.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:33

     1. -- kdf9.directors.adb
     2. --
     3. -- Implement the system call API (OUTs) of the supported KDF9 Directors.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with dumping;
    20. with exceptions;
    21. with formatting;
    22. with HCI;
    23. with host_IO;
    24. with IOC;
    25. with IOC.dispatcher;
    26. with IOC.equipment;
    27. with IOC.fast.DR.OUTs;
    28. with IOC.fast.FD.OUTs;
    29. with IOC.fast.MT.OUTs;
    30. with IOC.slow.shift.FW;
    31. with IOC.slow.shift.SI;
    32. with IOC.slow.shift.TR;
    33. with KDF9_char_sets;
    34. with KDF9.CPU;
    35. with KDF9.store;
    36. with logging.file;
    37. with settings;
    38. with state_display;
    39. with tracing;
    40.
    41. with environmental_value_of;
    42.
    43. use  dumping;
    44. use  exceptions;
    45. use  formatting;
    46. use  HCI;
    47. use  host_IO;
    48. use  IOC;
    49. use  IOC.dispatcher;
    50. use  IOC.equipment;
    51. use  IOC.fast.DR.OUTs;
    52. use  IOC.fast.FD.OUTs;
    53. use  IOC.fast.MT.OUTs;
    54. use  IOC.slow.shift.FW;
    55. use  IOC.slow.shift.SI;
    56. use  IOC.slow.shift.TR;
    57. use  KDF9_char_sets;
    58. use  KDF9.store;
    59. use  logging.file;
    60. use  settings;
    61. use  state_display;
    62. use  tracing;
    63.
    64. package body KDF9.Directors is
    65.
    66.    -- This is the actual wall clock time at which the program was loaded.
    67.    -- If signature hashing is enabled, it stays at zero to get a repeatable hash.
    68.    the_time_of_loading : KDF9.us := 0;
    69.
    70.    -- Set the base for virtual elapsed time reckoning.
    71.    procedure set_the_time_of_loading (the_time : in KDF9.us) is
    72.    begin
    73.       the_time_of_loading := the_time;
    74.    end set_the_time_of_loading;
    75.
    76.    function destination_device_for (the_stream : KDF9.word)
    77.    return IOC.device_number is
    78.    begin
    79.       case the_stream is
    80.          when 8#00# =>
    81.             return 0;
    82.          when 8#10# |8#12# |8#14# | 8#16# =>
    83.             return TP0_number;
    84.          when 8#11# |8#13# |8#15# | 8#17# =>
    85.             return TP1_number;
    86.          when 8#30#..8#37# =>
    87.             return LP0_number;
    88.          when 8#50#..8#57# =>
    89.             return TP1_number;
    90.          when 8#70#..8#77# =>
    91.             return LP0_number;
    92.          when others =>
    93.             fail_OUT(8, "invalid stream #" & oct_of(the_stream));
    94.       end case;
    95.    end destination_device_for;
    96.
    97.    -- Implement a subset of the Time Sharing Director's OUT 8 / OUT 16 spooling API.
    98.    procedure do_TSD_IO (this_OUT : in KDF9.word) is
    99.
   100.       the_stream : KDF9.word;
   101.       Q, G       : KDF9.Q_register;
   102.
   103.       procedure prepare_output_to_FW0 is
   104.          message_prefix  : constant KDF9.word := 8#02_06_21_55_22_00_07_77#; -- LS CS [ m ] SP CN Ø
   105.          prompt_prefix   : constant KDF9.word := 8#02_06_21_61_22_00_07_77#; -- LS CS [ q ] SP CN Ø
   106.          OUT_16_prefix   : constant KDF9.word := 8#02_07_56_33_00_77_77_77#; -- LS CN N º SP Ø  Ø Ø
   107.          filler_in_D0_D5 : constant KDF9.word := 8#77_00_00_00_00_00_00_00#; -- Ø
   108.          s               : KDF9_char_sets.symbol := KDF9_char_sets.Word_Filler;
   109.          the_prefix      : KDF9.word;
   110.       begin  -- prepare_output_to_FW0
   111.          -- The logic of FW streams is rather complex, to preserve the layout of the typescript.
   112.          -- There are three significant aspects.
   113.
   114.          -- 1. The message is truncated if longer than 8 words.
   115.          if Q.M - Q.I > 8 then
   116.             Q.M := Q.I + 8;
   117.          end if;
   118.
   119.          -- 2. It must not contain LS or HT;
   120.          --       nor ';' in the last word;
   121.          --          nor ';' other than in character 7;
   122.          --    but anything after an End Message can safely be ignored.
   123.          word_loop: for w in Q.I+1 .. Q.M loop
   124.              for c in KDF9_char_sets.symbol_index'Range loop
   125.                 s := fetch_symbol(w, c);
   126.                 if s = KDF9_char_sets.Line_Shift                                 or else
   127.                       s = KDF9_char_sets.Tabulation                              or else
   128.                          ((s = KDF9_char_sets.Semi_Colon) and (c /= 7 or  w = Q.M)) then
   129.                    fail_OUT(this_OUT, "invalid data for OUT 8 to FW");
   130.                 end if;
   131.          exit word_loop when s = KDF9_char_sets.Semi_Colon or s = KDF9_char_sets.End_Message;
   132.              end loop;
   133.          end loop word_loop;
   134.
   135.          the_prefix := (if s = KDF9_char_sets.Semi_Colon then prompt_prefix else message_prefix);
   136.          the_prefix := (if this_OUT = 16                 then OUT_16_prefix else the_prefix);
   137.
   138.          -- 3. The Director takes a new line for each OUT 8 message to the FW.
   139.          -- It sets up the format effector(s) in the first word of the OUT 8 area.
   140.          declare
   141.             package FW renames IOC.slow.shift.FW;
   142.             the_FW : FW.device renames FW.device(buffer(0).all);
   143.          begin
   144.             if a_LF_was_just_read(the_FW) then
   145.                -- Replace the redundant Line Shift with a Word Filler character.
   146.                store_word(the_prefix or filler_in_D0_D5, Q.I);
   147.             else
   148.                -- The initial Line Shift is needed.
   149.                store_word(the_prefix, Q.I);
   150.             end if;
   151.          end;
   152.       end prepare_output_to_FW0;
   153.
   154.       page_change : constant := 8#77_77_77_77_77_77_77_03#;  --  LP Page Change character
   155.
   156.    begin  -- do_TSD_IO
   157.       ensure_that_the_nest_holds_an_operand;
   158.       Q := as_Q(pop);  -- the N2 parameter
   159.       the_trace_operand := as_word(Q);
   160.
   161.       -- A FW query has D0 of the control word set.
   162.       if (Q.C and 8#1_00000#) /= 0 then
   163.          Q.C := 0;
   164.       end if;
   165.
   166.       --
   167.          -- OUT 8 'output spooling'.
   168.       --
   169.
   170.       if Q.C = Q.I and Q.I = Q.M then
   171.          -- The N2 parameter specifies stream closure.
   172.          flush(buffer(destination_device_for(KDF9.word(Q.C))).all);
   173.          return;
   174.       end if;
   175.
   176.       -- The Q = N2 parameter specifies a block starting with the stream number.
   177.       check_address_and_lockout(Q.I);
   178.       the_stream := fetch_word(Q.I);
   179.       Q.C := destination_device_for(the_stream);
   180.       set_state_of(buffer(Q.C), allocated => True);
   181.       check_address_and_lockout(Q.I+1);
   182.       G := as_Q(fetch_word(Q.I+1));
   183.
   184.       -- See the Manual, §12.6.1.
   185.       if G.C = 4095 and then G.I = 8#177777# then
   186.          -- The G parameter specifies output of a 'gap' suitable for the device.
   187.          the_trace_operand := as_word(G);
   188.          if G.M = 0 then
   189.             return;
   190.          end if;
   191.          G.M := (if G.M in 1 .. 511 then G.M else 120);
   192.          if destination_device_for(the_stream) = 0 then
   193.             null;  -- What else could be done; fail?
   194.          elsif destination_device_for(the_stream) in TP0_number | TP1_number then
   195.             POE((Q.C, 0, G.M), False);   -- Write gap.
   196.          elsif destination_device_for(the_stream) = LP0_number then
   197.             store_word(page_change, Q.I);
   198.             POA((Q.C, Q.I, Q.I), False); -- Write PC.
   199.          else
   200.             fail_OUT(8, "cannot gap on device #" & oct_of(destination_device_for(the_stream)));
   201.          end if;
   202.          return;
   203.       end if;
   204.
   205.       if Q.M <= Q.I then
   206.          fail_OUT(8, "invalid M-part #" & oct_of(Q.M));
   207.       end if;
   208.
   209.       if Q.C /= 0 then
   210.          -- For non-FW streams, the first word of the OUT 8 area is not transferred.
   211.          Q.I := Q.I + 1;
   212.       else
   213.          -- The logic for FW streams is more complex, to preserve the layout of the typescript.
   214.          prepare_output_to_FW0;
   215.       end if;
   216.       POB(Q, False);
   217.
   218.    exception
   219.       when host_IO.end_of_stream =>
   220.          fail_OUT(8, "unexpected end of file for stream #" & oct_of(KDF9.Q_part(the_stream)));
   221.    end do_TSD_IO;
   222.
   223.    -- is_free_for_explicit_allocation keepa a note of explicitly requested allocations by OUT 5.
   224.    -- Allocations by OUT 8 emulation prevent LIVs on the the pseudo-spooled devices.
   225.    -- These internal allocations by OUT 8 must not cause a reservation by OUT 5 to fail.
   226.
   227.    is_free_for_explicit_allocation : array(KDF9.buffer_number) of Boolean := (others => True);
   228.
   229.    procedure set_ancestor_to_rest (OUT_number : in KDF9.word) is
   230.    begin
   231.       if the_log_is_wanted and pre_overlay_state_is_enabled then
   232.          show_final_state("before overlay by OUT" & OUT_number'Image);
   233.       end if;
   234.
   235.       if the_log_is_wanted and nr_of_post_dumping_areas /= 0 then
   236.          log_new_line;
   237.          log_rule;
   238.          log_title("Post-run Dump:");
   239.          print_postrun_dump_areas;
   240.       end if;
   241.
   242.       remove_prerun_dump_areas;
   243.       remove_postrun_dump_areas;
   244.
   245.       clear_retro_FIFO;
   246.       clear_IOC_FIFO;
   247.       clear_the_histogram;
   248.       clear_the_profile;
   249.       the_profile_is_wanted := False;
   250.       the_INS_plot_is_wanted := False;
   251.    end set_ancestor_to_rest;
   252.
   253.    procedure prepare_successor is
   254.    begin
   255.       poke_all_amendments;
   256.       save_the_initial_jump;
   257.
   258.       the_program_has_been_analysed := False;
   259.       show_all_prerun_dump_areas;
   260.
   261.       -- Setting NIA must follow loading, as it fetches E0 into the IWBs.
   262.       set_NIA_to((0, 0));
   263.       the_V_bit_is_set := False;
   264.       the_T_bit_is_set := False;
   265.    end prepare_successor;
   266.
   267.    procedure complete_TSD_OUT_2 (time_limit : in KDF9.word) is
   268.    begin
   269.       set_ancestor_to_rest(OUT_number => 2);
   270.       log_API_message("OUT 2: ICR ="
   271.                     & ICR'Image
   272.                     & "; RAN/EL ="
   273.                     & the_CPU_time'Image
   274.                     & " /"
   275.                     & KDF9.us'Image(the_clock_time)
   276.                     & " KDF9 us"
   277.                     & "; new time limit = "
   278.                     & KDF9.word'Image(time_limit/2**24) &"s"
   279.                      );
   280.
   281.       get_settings_from_file("2");
   282.       install_GP0;
   283.       prepare_successor;
   284.       store_halfword(time_limit, 1, 0);
   285.       store_halfword((KDF9.word'(max_address)) * 2**24, 1, 1);
   286.
   287.       log_new_line;
   288.       display_execution_modes;
   289.       reset_the_program_state;
   290.    end complete_TSD_OUT_2;
   291.
   292.    procedure overlay_a_new_program (program_name : in String) is
   293.       overlay : constant String := environmental_value_of("KDF9_BINARY", default => "Binary")
   294.                                  & "/"
   295.                                  & program_name;
   296.       W : KDF9.word;
   297.    begin
   298.       if program_name = "" then
   299.          fail_OUT(1, "the given program name is an empty string");
   300.       end if;
   301.
   302.       if program_name = "KMW0201--UPU" then
   303.          -- The Whetstone Controller is trying to overlay itself with the Translator.
   304.          -- This is so inconvenient in practice that I simply prevent it.
   305.          notify_termination;
   306.          log_API_message("OUT 1: ee9 will not return to the Whetstone Translator",
   307.                          skip => 2
   308.                         );
   309.          raise program_exit;
   310.       end if;
   311.
   312.       complete_all_extant_transfers;  -- To get an accurate elapsed time.
   313.       is_free_for_explicit_allocation := (others => True);
   314.       set_ancestor_to_rest(OUT_number => 1);
   315.       log_API_message("OUT 1: ICR ="
   316.                     & ICR'Image
   317.                     & "; RAN/EL ="
   318.                     & the_CPU_time'Image
   319.                     & " /"
   320.                     & KDF9.us'Image(the_clock_time)
   321.                     & " KDF9 us"
   322.                      );
   323.
   324.       if the_external_trace_is_enabled then
   325.          log_new_line(the_external_trace_file);
   326.          log(the_external_trace_file, "ee9: Running overlay " & overlay);
   327.          log_new_line(the_external_trace_file);
   328.          log_an_external_trace_header;
   329.       end if;
   330.
   331.       get_settings_from_file("2");
   332.       install_GP0;
   333.
   334.       log_new_line;
   335.       display_execution_modes(overlay);
   336.
   337.       W := fetch_word(1);
   338.       load_a_program(program_file_name => overlay);
   339.       store_word(W, 1);
   340.
   341.       prepare_successor;
   342.       raise mode_change_request;
   343.    end overlay_a_new_program;
   344.
   345.
   346.    -- These are the device-type codes to be given when requesting
   347.    --    the allocation of a peripheral with TSD OUT 5,
   348.    --       according to the Manual and the document:
   349.    --          "Service Routine Library Manual" §22.13, p22-28-0.
   350.
   351.    FW_OUT5_code : constant := 0;
   352.    TP_OUT5_code : constant := 1;
   353.    TR_OUT5_code : constant := 2;
   354.    LP_OUT5_code : constant := 3;
   355.    CR_OUT5_code : constant := 4;
   356.    FP_OUT5_code : constant := 5;      -- Ferranti 5-channel Tape punch
   357.    CP_OUT5_code : constant := 7;
   358.    GP_OUT5_code : constant := 8#20#;
   359.    SI_OUT5_code : constant := 8#21#;  -- Standard Interface, "Data Link, N.P.L. Special Buffer"
   360.    FE_OUT5_code : constant := 8#65#;  -- Tape buffer link for PDP-8 on Eldon2, and perhaps COTAN
   361.    UT_OUT5_code : constant := 8#67#;  -- Unlabelled Tape
   362.
   363.    procedure select_the_next_device_from_among
   364.       (device_A, device_B : in  KDF9.buffer_number;
   365.        wanted_device_type : in  KDF9.word;
   366.        chosen_device      : out KDF9.buffer_number) is
   367.    begin
   368.       if device_A /= 0                            and then
   369.             is_free_for_explicit_allocation(device_A) then
   370.          chosen_device := device_A;
   371.          is_free_for_explicit_allocation(device_A) := False;
   372.       elsif device_B /= 0                         and then
   373.             is_free_for_explicit_allocation(device_B) then
   374.          chosen_device := device_B;
   375.          is_free_for_explicit_allocation(device_B) := False;
   376.       else
   377.          fail_OUT(5, "there is no available device of type #" & oct_of(wanted_device_type));
   378.       end if;
   379.    end select_the_next_device_from_among;
   380.
   381.    procedure allocate_a_device is
   382.       B : KDF9.buffer_number;
   383.       W : KDF9.word;
   384.    begin
   385.       ensure_that_the_nest_holds_an_operand;
   386.       W := read_top;
   387.
   388.       case W is
   389.          -- 8 was added to the code to pre-allocate a device.
   390.          -- I treat pre-allocating and allocating the same way here.
   391.          when FW_OUT5_code
   392.             | FW_OUT5_code+8 =>
   393.             B := 0;  -- Always allowed, no checking performed.
   394.          when TP_OUT5_code
   395.             | TP_OUT5_code+8
   396.             | FP_OUT5_code
   397.             | FP_OUT5_code+8 =>
   398.             select_the_next_device_from_among(TP0_number, TP1_number, W, B);
   399.          when TR_OUT5_code
   400.             | TR_OUT5_code+8 =>
   401.             -- N.B. the TR devices must appear in this order.
   402.             -- TR0 is used for reading the bootstrap/problem program in KDF9 code.
   403.             -- When there is Latin-1 data it therefore needs to go in via TR1.
   404.             select_the_next_device_from_among(TR1_number, TR0_number, W, B);
   405.             set_case(IOC.slow.shift.TR.device(buffer(B).all));
   406.          when LP_OUT5_code
   407.             | LP_OUT5_code+8 =>
   408.             select_the_next_device_from_among(LP0_number, LP1_number, W, B);
   409.          when CR_OUT5_code
   410.             | CR_OUT5_code+8 =>
   411.             select_the_next_device_from_among(CR0_number, CR1_number, W, B);
   412.          when CP_OUT5_code
   413.             | CP_OUT5_code+8 =>
   414.             select_the_next_device_from_among(CP0_number, CP1_number, W, B);
   415.          when GP_OUT5_code
   416.             | GP_OUT5_code+8 =>
   417.             -- There is only 1 graph plotter.
   418.             the_graph_plotter_is_enabled := True;
   419.             install_GP0;
   420.             select_the_next_device_from_among(GP0_number, GP0_number, W, B);
   421.          when SI_OUT5_code =>
   422.             if SI0_is_enabled then
   423.                select_the_next_device_from_among(SI0_number, SI1_number, W, B);
   424.             else
   425.                fail_OUT(5, "the SI buffer has not been enabled");
   426.             end if;
   427.          when FE_OUT5_code =>
   428.             trap_unimplemented_feature("PDP-8 Front End Tape buffers");
   429.          when UT_OUT5_code =>
   430.             trap_unimplemented_feature("Unlabelled Tape buffers");
   431.          when others =>
   432.             fail_OUT(5, "unknown device type" & W'Image);
   433.       end case;
   434.
   435.       pop;
   436.       push(KDF9.word(B));
   437.       the_trace_operand := KDF9.word(B);
   438.       set_state_of(buffer(B), allocated => True);
   439.
   440.       if buffer(B).all in IOC.slow.shift.device'Class and then
   441.             buffer(B).kind /= GP_kind                     then
   442.          log_API_message("OUT 5: requested a device of type #"
   443.                        & oct_of(KDF9.Q_part(W), 2)
   444.                        & " and got "
   445.                        & device_name_of(buffer(B).all)
   446.                        & " on buffer #"
   447.                        & oct_of(B, 2)
   448.                        & ", using "
   449.                        & (
   450.                           if IOC.slow.shift.device(buffer(B).all).uses_Latin_1 then
   451.                              "Latin-1"
   452.                           else
   453.                              "KDF9"
   454.                          )
   455.                        & " code"
   456.                         );
   457.       else
   458.          log_API_message("OUT 5: requested a device of type #"
   459.                        & oct_of(KDF9.Q_part(W), 2)
   460.                        & " and got "
   461.                        & device_name_of(buffer(B).all)
   462.                        & " on buffer #"
   463.                        & oct_of(B, 2)
   464.                         );
   465.       end if;
   466.    end allocate_a_device;
   467.
   468.    procedure deallocate_a_verified_device (OUT_number : in KDF9.word; B : in KDF9.buffer_number) is
   469.    begin
   470.       if buffer(B).kind in MT_kind | ST_kind then
   471.          if needs_rewinding(b) then
   472.             PMD(buffer(B).all, KDF9.Q_register'(B, 0, 0), set_offline => (OUT_number = 6));
   473.          end if;
   474.       elsif OUT_number = 7 then
   475.          fail_OUT(7, "device #" & oct_of(B, 2) & ", is not a tape deck");
   476.       end if;
   477.       set_state_of(buffer(B), allocated => False);
   478.       is_free_for_explicit_allocation(B) := True;
   479.       log_API_message("OUT" & OUT_number'Image & ": released " & device_name_of(buffer(B).all));
   480.    end deallocate_a_verified_device;
   481.
   482.    procedure deallocate_a_device (OUT_number : in KDF9.word) is
   483.       B : KDF9.Q_part;
   484.    begin
   485.       ensure_that_the_nest_holds_an_operand;
   486.       the_trace_operand := pop;
   487.       if the_trace_operand > 15 then
   488.          notify_termination;
   489.          fail_OUT(OUT_number, "#" & oct_of(the_trace_operand) & " is not a valid buffer number");
   490.       end if;
   491.       B := KDF9.buffer_number(the_trace_operand);
   492.       if is_unallocated(buffer(B)) then
   493.          fail_OUT(OUT_number, "device #" & oct_of(B, 2) & " is not allocated to this program");
   494.       end if;
   495.       deallocate_a_verified_device(OUT_number, B);
   496.    end deallocate_a_device;
   497.
   498.    procedure dispose_all_allocated_tapes (OUT_number : in KDF9.word) is
   499.    begin
   500.       for b in KDF9.buffer_number loop
   501.          if buffer(b) /= null                      and then
   502.                buffer(b).kind in MT_kind | ST_kind and then
   503.                   is_allocated(buffer(b))              then
   504.             deallocate_a_verified_device(OUT_number, b);
   505.          end if;
   506.       end loop;
   507.    end dispose_all_allocated_tapes;
   508.
   509.    -- Return a time in µs as 48-bit seconds to 23 integral places.
   510.    function OUT_time (microseconds : KDF9.us)
   511.    return KDF9.word is
   512.       -- The time was recorded by the hardware in units of 32 us, not 1 us.
   513.       truncated_time : constant KDF9.us := microseconds and not 31;
   514.    begin
   515.       if truncated_time < 2**23 * 1E6 then
   516.          -- 2**18 / 15625 = 2**24 / 1E6, with no risk of overflow in 64 bits.
   517.          return KDF9.word(truncated_time * 2**18 / 15625);
   518.       else
   519.          -- The virtual elapsed time overflows the 23-bit seconds field.
   520.          -- This would never have happened to a real KDF9, as 2**23 seconds is over three months.
   521.          -- No KDF9 could stay up that long!
   522.          -- However 2**23 KDF9 seconds pass in about 5 hours of ee9 real time,
   523.          --    so precautions have to be taken.
   524.          raise emulation_failure with "the KDF9 has been running too long, time > 2**23 seconds";
   525.       end if;
   526.    end OUT_time;
   527.
   528.    -- Emulate a subset of the Time Sharing Director's OUT API.
   529.    procedure do_a_TSD_OUT (OUT_number : in KDF9.word) is
   530.
   531.       P : KDF9.pair;
   532.       W : KDF9.word;
   533.
   534.    begin
   535.       -- Dismiss the OUT number in N1, allowing for an empty NEST, treated as OUT 0.
   536.       if the_nest_depth > 0 then
   537.          pop;
   538.       end if;
   539.
   540.       case OUT_number is
   541.
   542.          when 0 =>
   543.             -- Terminate program.
   544.             dispose_all_allocated_tapes(OUT_number => 0);
   545.             notify_termination;
   546.             log_API_message("OUT 0: end of run");
   547.             raise program_exit;
   548.
   549.          when 1 =>
   550.             -- Overlay a nominated program, retaining allocated I/O devices.
   551.             ensure_that_the_nest_holds_2_operands;
   552.             P := pop;
   553.             P := CPU.shift_logical(P, 24);
   554.             overlay_a_new_program(program_name => trimmed(to_string(P)));
   555.
   556.          when 2 =>
   557.             -- Resume a program with a new time limit.
   558.             ensure_that_the_nest_holds_an_operand;
   559.             W := pop;
   560.             the_trace_operand := W;
   561.             dispose_all_allocated_tapes(OUT_number => 2);
   562.             notify_termination;
   563.             raise program_restart;
   564.             -- complete_TSD_OUT_2 is called by KDF9.microcode
   565.             --    after it has finalized the execution of the OUT instruction.
   566.
   567.          when 3 =>
   568.             -- Get the virtual CPU time used, allowing for previous overlays.
   569.             W := OUT_time(the_CPU_time);
   570.             push(W);
   571.             the_trace_operand := W;
   572.
   573.          when 4 =>
   574.             do_TSD_OUT_4;
   575.
   576.          when 5 =>
   577.             allocate_a_device;
   578.
   579.          when 6
   580.             | 7 =>
   581.             deallocate_a_device(OUT_number);
   582.
   583.          when 8 =>
   584.             do_TSD_IO(this_OUT => 8);
   585.
   586.          when 9 =>
   587.             -- Get the time of day, in seconds since midnight to 23 integral places.
   588.             -- A TOD clock is simulated using the real TOD at which the program was
   589.             --    loaded, and the virtual time that has elapsed since.
   590.             W := OUT_time(the_time_of_loading + the_clock_time);
   591.             push(W);
   592.             the_trace_operand := W;
   593.
   594.          when 10 =>
   595.             do_TSD_OUT_10;
   596.
   597.          when 11 =>
   598.             do_TSD_OUT_11;
   599.
   600.          when 12 =>
   601.             do_TSD_OUT_12;
   602.
   603.          when 13 =>
   604.             do_TSD_OUT_13;
   605.
   606.          when 14 =>
   607.             do_TSD_OUT_14;
   608.
   609.          when 16 =>
   610.             do_TSD_IO(this_OUT => 16);
   611.
   612.          when 17 =>
   613.             -- In program mode, the Notional Elapsed Time is the same thing as the_clock_time.
   614.             ensure_that_the_nest_has_room_for_2_results;
   615.             W := OUT_time(the_CPU_time);
   616.             push(OUT_time(the_clock_time));
   617.             push(W);
   618.             the_trace_operand := W;
   619.
   620.          when 41 =>
   621.             do_TSD_OUT_41;
   622.
   623.          when 42 =>
   624.             do_TSD_OUT_42;
   625.
   626.          when 43 =>
   627.             do_TSD_OUT_43;
   628.
   629.          when 44 =>
   630.             do_TSD_OUT_44;
   631.
   632.          when 45 =>
   633.             do_TSD_OUT_45;
   634.
   635.          when 70 =>
   636.             -- This is not a genuine TSD OUT, it is an expedient for debugging KAlgol,
   637.             --   so ee9 simply erases its parameters from N1 and N2.
   638.             ensure_that_the_nest_holds_2_operands;
   639.             W := pop;
   640.             the_trace_operand := W;
   641.             W := pop;
   642.
   643.          when 98 =>
   644.             -- This is not a genuine TSD OUT, it is an ee9 'OUT' for setting FW output format.
   645.             ensure_that_the_nest_holds_an_operand;
   646.             W := pop;
   647.             the_trace_operand := W;
   648.             realistic_FW_output_is_wanted := the_trace_operand /= 0;
   649.
   650.          when 99 =>
   651.             -- This is not a genuine TSD OUT, it is an ee9 'OUT' for program instrumentation.
   652.             -- Get present value of the Instruction Count Register (ICR) from within ee9.
   653.             W := KDF9.word(ICR);
   654.             push(W);
   655.             the_trace_operand := W;
   656.
   657.          when others =>
   658.             trap_unimplemented_feature("OUT" & OUT_number'Image);
   659.
   660.       end case;
   661.
   662.    end do_a_TSD_OUT;
   663.
   664.    -- Emulate a subset of the EGDON Director's OUT API.
   665.    procedure do_an_EGDON_OUT (OUT_number : in KDF9.word) is
   666.    begin
   667.       trap_unimplemented_feature("EGDON OUTs are not yet supported");
   668.    end do_an_EGDON_OUT;
   669.
   670.    -- Emulate a subset of some other Director's OUT API.
   671.    procedure do_some_other_OUT (OUT_number : in KDF9.word) is
   672.    begin
   673.       trap_unimplemented_feature("this OUT is not yet supported");
   674.    end do_some_other_OUT;
   675.
   676. end KDF9.Directors;

Compiling: ../Source/kdf9-directors.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:33

     1. -- kdf9.directors.ads
     2. --
     3. -- Implement the APIs (OUTs) of KDF9 Directors.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package KDF9.Directors is
    20.
    21.    -- Emulate a subset of the EGDON Director's OUT API.
    22.    procedure do_an_EGDON_OUT (OUT_number : in KDF9.word);
    23.
    24.    -- Emulate a subset of the Time Sharing Director's OUT API.
    25.    procedure do_a_TSD_OUT (OUT_number : in KDF9.word);
    26.
    27.    -- Effect a Time Sharing Director OUT 2 restart.
    28.    procedure complete_TSD_OUT_2 (time_limit : in KDF9.word);
    29.
    30.    -- Emulate a subset of some other Director's OUT API.
    31.    procedure do_some_other_OUT (OUT_number : in KDF9.word);
    32.
    33.    -- Set the base for virtual elapsed time reckoning.
    34.    procedure set_the_time_of_loading (the_time : in KDF9.us);
    35.
    36. end KDF9.Directors;

 676 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/kdf9-tod_clock.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:33

     1. -- kdf9-tod_clock.adb
     2. --
     3. -- functions that implement timing for Director emulation.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Calendar;
    20. with Ada.Calendar.Time_Zones;
    21. with Ada.Calendar.Formatting;
    22.
    23. use  Ada.Calendar;
    24. use  Ada.Calendar.Time_Zones;
    25. use  Ada.Calendar.Formatting;
    26.
    27. package body KDF9.TOD_clock is
    28.
    29.    function todays_date_28n_years_ago
    30.    return KDF9.word is
    31.
    32.       zero  : constant KDF9.word := 8#20#;
    33.       slash : constant KDF9.word := 8#17#;
    34.       today : constant Ada.Calendar.Time := Ada.Calendar.Clock;
    35.
    36.       year, month, day, hour, minute, second, sub_second : KDF9.word;
    37.
    38.       -- For values of i in 0..99, return two 6-bit KDF9 decimal digits.
    39.       function as_2_digits (i : KDF9.word)
    40.       return KDF9.word
    41.       is ((i/10 + zero)*64 or (i mod 10 + zero));
    42.
    43.    begin  -- todays_date_28n_years_ago
    44.       Split(today,
    45.             Year_Number(year),
    46.             Month_Number(month),
    47.             Day_Number(day),
    48.             Hour_Number(hour),
    49.             Minute_Number(minute),
    50.             Second_Number(second),
    51.             Second_Duration(sub_second),
    52.             Time_Zone => UTC_Time_Offset(today)
    53.            );
    54.       loop  -- Repeat n > 0 times, assuming no time travel into the past!
    55.          year := year - 28;
    56.       exit when year < 2000;
    57.       end loop;
    58.       return (as_2_digits(day)*64   or slash) * 64**5  -- DD/.....
    59.           or (as_2_digits(month)*64 or slash) * 64**2  --    MM/..
    60.           or (as_2_digits((year) mod 100));            --       YY
    61.    end todays_date_28n_years_ago;
    62.
    63.    function the_time_of_day
    64.    return KDF9.us is
    65.       today : constant Ada.Calendar.Time := Ada.Calendar.Clock;
    66.       year, month, day, hour, minute, second, sub_second : KDF9.word;
    67.    begin
    68.       Split(today,
    69.             Year_Number(year),
    70.             Month_Number(month),
    71.             Day_Number(day),
    72.             Hour_Number(hour),
    73.             Minute_Number(minute),
    74.             Second_Number(second),
    75.             Second_Duration(sub_second),
    76.             Time_Zone => UTC_Time_Offset(today)
    77.            );
    78.       return KDF9.us(hour*3600 + minute*60 + second) * 1_000_000;
    79.    end the_time_of_day;
    80.
    81. end KDF9.TOD_clock;

Compiling: ../Source/kdf9-tod_clock.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:33

     1. -- kdf9-tod_clock.ads
     2. --
     3. -- functions that implement timing for Director emulation.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package KDF9.TOD_clock is
    20.
    21.    -- The date a multiple of 28 years ago has the same day/date correspondence as today.
    22.    -- To avoid exposing KDF9's lack of Y2K compliance, ee9 uses such a date before 2000.
    23.    -- 8-)
    24.    -- todays_date_28n_years_ago returns a word of 8 KDF9 characters in the format DD/MM/YY.
    25.
    26.    function todays_date_28n_years_ago
    27.    return KDF9.word;
    28.
    29.    -- The time in microseconds since midnight.
    30.    function the_time_of_day
    31.    return KDF9.us;
    32.
    33. end KDF9.TOD_clock;

 81 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/finalize_ee9.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:33

     1. -- finalize_ee9.adb
     2. --
     3. -- Shut down processing in preparation for a dignified exit.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Exceptions;
    20. --
    21. with HCI;
    22. with IOC;
    23. with state_display;
    24.
    25. use  HCI;
    26. use  IOC;
    27. use  state_display;
    28.
    29. procedure finalize_ee9 (because : in String) is
    30. begin
    31.    show_final_state(because);
    32.    finalize_all_KDF9_buffers;
    33. exception
    34.    when error : others =>
    35.       log_line("Failure: " & Ada.Exceptions.Exception_Information(error));
    36. end finalize_ee9;

 36 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/postscript.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:34

     1. -- postscript.adb
     2. --
     3. -- Elementary Encapsulated PostScript (EPS) line drawing.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Exceptions;
    20. --
    21. with exceptions;
    22.
    23. use  Ada.Exceptions;
    24. --
    25. use  exceptions;
    26.
    27. package body postscript is
    28.
    29.    use host_IO;
    30.
    31.    -- A path is a series of vectors v1, v2, ..., vn such that the last point
    32.    --    of vi is the same as the first point of v(i+1),
    33.    --       and v1, ..., vn are all drawn in the same colour.
    34.    -- A new path is started by a jump to a non-contiguous point or by a change of pen colour.
    35.
    36.    there_is_an_open_path      : Boolean := False;
    37.    the_last_point_in_the_path : postscript.point := (0, 0);
    38.
    39.    -- The bounding box limits are set from the value of maximum_offset at the end of the plot.
    40.    maximum_offset             : postscript.point := (0, 0);
    41.
    42.    procedure ensure_separation (stream : in out host_IO.stream) is
    43.    begin
    44.       if column(stream) > 0 then
    45.          put_byte(' ', stream);
    46.       end if;
    47.    end ensure_separation;
    48.
    49.    procedure put (stream : in out host_IO.stream; PS_text : String) is
    50.    begin
    51.       put_bytes(PS_text, stream);
    52.    end put;
    53.
    54.    procedure put_unit (stream : in out host_IO.stream; PS_text : String) is
    55.    begin
    56.       ensure_separation(stream);
    57.       put(stream, PS_text);
    58.    end put_unit;
    59.
    60.    procedure put_line (stream : in out host_IO.stream; PS_text : String) is
    61.    begin
    62.       put(stream, PS_text);
    63.       put_EOL(stream);
    64.    end put_line;
    65.
    66.    procedure put_unit_line (stream : in out host_IO.stream; PS_text : String) is
    67.    begin
    68.       put_unit(stream, PS_text);
    69.       put_EOL(stream);
    70.    end put_unit_line;
    71.
    72.    procedure put_integer (stream : in out host_IO.stream; i : Integer) is
    73.       integer_image  : constant String := i'Image;
    74.    begin
    75.       ensure_separation(stream);
    76.       if integer_image(integer_image'First) /= ' ' then
    77.          put(stream, integer_image);
    78.       else  -- Suppress the nuisance blank character.
    79.          put(stream, integer_image(integer_image'First+1..integer_image'Last));
    80.       end if;
    81.    end put_integer;
    82.
    83.    procedure terminate_any_open_path (stream : in out host_IO.stream) is
    84.    begin
    85.       if there_is_an_open_path then
    86.          -- Draw the accumulated strokes.
    87.          put_unit_line(stream, "s");
    88.       end if;
    89.       there_is_an_open_path := False;
    90.    end terminate_any_open_path;
    91.
    92.    procedure draw_a_PS_vector (stream : in out host_IO.stream;
    93.                                initial,
    94.                                final  : in postscript.point) is
    95.
    96.       function largest_of (a, b, c : Natural)
    97.       return Natural
    98.       is (Natural'Max(a, Natural'Max(b, c)));
    99.
   100.    begin -- draw_a_PS_vector
   101.       if initial /= the_last_point_in_the_path then
   102.          -- This vector is not contiguous with the previous one.
   103.          terminate_any_open_path(stream);
   104.       end if;
   105.       if initial = final then
   106.          -- This vector is of length 0.
   107.          return;
   108.       end if;
   109.       maximum_offset.x := largest_of(maximum_offset.x, initial.x, final.x);
   110.       maximum_offset.y := largest_of(maximum_offset.y, initial.y, final.y);
   111.       if there_is_an_open_path then
   112.          -- Draw a line to the final point, extending the current path.
   113.          put_integer(stream, final.x);
   114.          put_integer(stream, final.y);
   115.          put_unit_line(stream, "l");
   116.       else
   117.          -- Move to the initial point, opening a fresh path, and draw a line to the final point.
   118.          put_integer(stream, final.x);
   119.          put_integer(stream, final.y);
   120.          put_integer(stream, initial.x);
   121.          put_integer(stream, initial.y);
   122.          put_unit_line(stream, "n");
   123.          there_is_an_open_path := True;
   124.       end if;
   125.       the_last_point_in_the_path := final;
   126.    exception
   127.       when error : others =>
   128.          close(stream);
   129.          raise emulation_failure with "drawing a PostScript vector: " & Exception_Information(error);
   130.    end draw_a_PS_vector;
   131.
   132.    subtype RGB is String(1..11);
   133.    gamut : constant array (pen_colour) of RGB
   134.          := (
   135.                Black          => ".00 .00 .00",
   136.                Blue           => ".00 .00 1.0",
   137.                Brown          => ".60 .20 .00",
   138.                Cyan           => ".00 1.0 1.0",
   139.                Dark_Blue      => ".10 .10 .80",
   140.                Dark_Cyan      => ".20 .80 1.0",
   141.                Dark_Green     => ".00 .60 .40",
   142.                Dark_Grey      => ".50 .50 .50",
   143.                Dark_Magenta   => ".75 .25 .75",
   144.                Dark_Red       => ".75 .00 .00",
   145.                Green          => ".00 1.0 .00",
   146.                Grey           => ".80 .80 .80",
   147.                Magenta        => "1.0 .00 1.0",
   148.                Red            => "1.0 .00 .00",
   149.                White          => "1.0 1.0 1.0",
   150.                Yellow         => "1.0 1.0 .00"
   151.             );
   152.
   153.    subtype tip_breadth is String(1..4);
   154.    breadth : constant array (pen_tip_size) of tip_breadth
   155.            := (
   156.                Extra_Extra_Fine => "1.00",
   157.                Extra_Fine       => "2.00",
   158.                Fine             => "4.00",
   159.                Medium           => "6.00",
   160.                Medium_Broad     => "8.00",
   161.                Broad            => "10.0",
   162.                Extra_Broad      => "12.0"
   163.               );
   164.
   165.    the_colour   : pen_colour   := the_default_colour;
   166.    the_pen_size : pen_tip_size := the_default_tip_size;
   167.
   168.    procedure put_the_pen_settings (stream : in out host_IO.Stream) is
   169.    begin -- put_the_pen_settings
   170.       terminate_any_open_path(stream);
   171.       put_unit(stream, gamut(the_colour));
   172.       put_unit_line(stream, "setrgbcolor");
   173.       put_unit(stream, breadth(the_pen_size));
   174.       put_unit_line(stream, "setlinewidth");
   175.    end put_the_pen_settings;
   176.
   177.    procedure set_the_pen_properties (this_colour   : in pen_colour   := the_default_colour;
   178.                                      this_pen_size : in pen_tip_size := the_default_tip_size) is
   179.    begin -- set_the_pen_properties
   180.       the_colour := this_colour;
   181.       the_pen_size := this_pen_size;
   182.    end set_the_pen_properties;
   183.
   184.    -- We eventually seek back to the bounding box parametsrs using this, their file offset.
   185.    the_position_of_the_placeholders : Natural;
   186.
   187.    procedure initialize_PS_output (stream : in out host_IO.Stream) is
   188.
   189.    begin -- initialize_PS_output
   190.       put_line(stream, "%!PS-Adobe-3.0 EPSF-1.0");
   191.       put_unit(stream, "%%BoundingBox: ");
   192.
   193.       -- Note the file offset of the bounding box placeholders.
   194.       get_position(the_position_of_the_placeholders, stream);
   195.
   196.       -- Write the 10-column placeholders.
   197.       put_line(stream, "xxxxxxxxxx|yyyyyyyyyy");
   198.
   199.       put_line(stream, "% This graph was plotted by ee9, the GNU Ada KDF9 emulator.");
   200.       put_line(stream, "% For more information, see <http://www.findlayw.plus.com/KDF9>.");
   201.       put_line(stream, "save");
   202.
   203.       put_line(stream, "1 setlinecap");
   204.       put_line(stream, "1 setlinejoin");
   205.
   206.       put_the_pen_settings(stream);
   207.
   208.       put_line(stream, "0 792 translate");  -- Assumes a page of length 11"!
   209.
   210.       -- The plotter step was 0.005", which is the same as 0.36 PostScript points.
   211.       -- The scaling factor is set here to make the wabbit example fit an A4 page.
   212.       put_line(stream, "0.12 -0.12 scale");
   213.
   214.       put_line(stream, "/l { lineto } bind def");
   215.       put_line(stream, "/n { newpath moveto lineto } bind def");
   216.       put_line(stream, "/s { stroke } bind def");
   217.
   218.       put_line(stream, "save");
   219.    exception
   220.       when error : others =>
   221.          close(stream);
   222.          raise emulation_failure with "initializing PostScript: " & Exception_Information(error);
   223.    end initialize_PS_output;
   224.
   225.    procedure finalize_PS_output (stream : in out host_IO.Stream) is
   226.
   227.       subtype bound_string is String(1..10);
   228.
   229.       function bound_image (n : in Natural)
   230.       return bound_string is
   231.          n_image : constant String := n'Image;
   232.          b : bound_string := (others => ' ');
   233.       begin
   234.          if n_image'Length > bound_string'Length then
   235.             raise emulation_failure with "infeasible PostScript bounding box size: " & n_image;
   236.          else
   237.             b(b'Last-n_image'Length+b'First .. b'Last) := n_image;
   238.             return b;
   239.          end if;
   240.       end bound_image;
   241.
   242.    begin -- finalize_PS_output
   243.       terminate_any_open_path(stream);
   244.       put_line(stream, "showpage");
   245.       put_line(stream, "restore");
   246.       put_line(stream, "restore");
   247.       put_line(stream, "% End of plot");
   248.
   249.       -- Go back to the bounding box placeholders in the output file.
   250.       set_position(the_position_of_the_placeholders, stream);
   251.
   252.       -- Overwrite them with the actual x and y co-ordinate bounds.
   253.       put(stream, bound_image(maximum_offset.x));
   254.       put(stream, " ");
   255.       put(stream, bound_image(maximum_offset.y));
   256.
   257.       close(stream);
   258.    exception
   259.       when error : others =>
   260.          close(stream);
   261.          raise emulation_failure with "closing PostScript output: " & Exception_Information(error);
   262.    end finalize_PS_output;
   263.
   264. end postscript;
   265.

Compiling: ../Source/postscript.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:34

     1. -- postscript.ads
     2. --
     3. -- Elementary Encapsulated PostScript (EPS) line drawing.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with host_IO;
    20.
    21. package postscript is
    22.
    23.    type pen_colour is (
    24.                        Black,
    25.                        Blue,
    26.                        Brown,
    27.                        Cyan,
    28.                        Dark_Blue,
    29.                        Dark_Cyan,
    30.                        Dark_Green,
    31.                        Dark_Grey,
    32.                        Dark_Magenta,
    33.                        Dark_Red,
    34.                        Green,
    35.                        Grey,
    36.                        Magenta,
    37.                        Red,
    38.                        White,
    39.                        Yellow
    40.                       );
    41.
    42.    the_default_colour : constant pen_colour := Black;
    43.
    44.    type pen_tip_size is (
    45.                          Extra_Extra_Fine,
    46.                          Extra_Fine,
    47.                          Fine,
    48.                          Medium,
    49.                          Medium_Broad,
    50.                          Broad,
    51.                          Extra_Broad
    52.                         );
    53.
    54.    the_default_tip_size : constant pen_tip_size := Extra_Extra_Fine;
    55.
    56.    -- Choose the pen's colour and tip size.
    57.
    58.    procedure set_the_pen_properties (this_colour   : in pen_colour   := the_default_colour;
    59.                                      this_pen_size : in pen_tip_size := the_default_tip_size);
    60.
    61.    -- Drawing is done in terms of the plotter's co-ordinate system.
    62.    -- (0, 0) is the top left point of the drawing,
    63.    -- The x axis increases down the plot (long axis, direction of paper movement),
    64.    --    and the y axis increases across the plot (short axis, direction of pen movement).
    65.
    66.    type point is
    67.      record
    68.         x, y : Natural;  -- All physically possible co-ordinates are non-negative.
    69.      end record;
    70.
    71.    -- Draw a straight line from initial to final.
    72.    procedure draw_a_PS_vector (stream : in out host_IO.stream;
    73.                                initial,
    74.                                final  : in postscript.point);
    75.
    76.    -- Open the PostScript file and write the prelude, with a placeholder for the bounds.
    77.    procedure initialize_PS_output (stream : in out host_IO.Stream);
    78.
    79.    -- Close the PostScript file, having gone back to overwrite the bounding box placeholders.
    80.    procedure finalize_PS_output (stream : in out host_IO.Stream);
    81.
    82. end postscript;

 265 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/settings-io.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:34

     1. -- settings-IO.ads
     2. --
     3. -- Settings-reader I/O support.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Characters.Latin_1;
    20. --
    21. with file_interfacing;
    22. with KDF9;
    23.
    24. use  Ada.Characters.Latin_1;
    25.
    26. package body settings.IO is
    27.
    28.    procedure open_options_file (file : in out File_Type; name : in String) is
    29.    begin
    30.       file_interfacing.initialize(file, in_file, name);
    31.       line_number := 1;
    32.    exception
    33.       when others =>
    34.          raise Status_Error with name;
    35.    end open_options_file;
    36.
    37.    procedure close_options_file (file : in out File_Type; name : in String) is
    38.    begin
    39.       file_interfacing.finalize(file, name);
    40.    end close_options_file;
    41.
    42.    comment_flag_character : constant Character := '|';
    43.
    44.    procedure skip_to_next_non_blank (file : File_Type) is
    45.       next_char : Character := ' ';
    46.       end_line  : Boolean;
    47.    begin
    48.       loop
    49.         look_ahead(file, next_char, end_line);
    50.       exit when end_line or else
    51.                   (next_char /= ' ' and next_char /= HT);
    52.          get(file, next_char);
    53.       end loop;
    54.       if next_char = comment_flag_character then
    55.          while not end_of_line(file) loop
    56.             get(file, next_char);
    57.          end loop;
    58.       end if;
    59.    end skip_to_next_non_blank;
    60.
    61.    procedure ensure_not_at_end_of_line (file : File_Type) is
    62.    begin
    63.       skip_to_next_non_blank (file);
    64.       if end_of_line(file) then
    65.          raise Data_Error;
    66.       end if;
    67.    end ensure_not_at_end_of_line;
    68.
    69.    procedure skip_to_next_nonempty_line (file : in File_Type) is
    70.       flag     : Character;
    71.       end_line : Boolean;
    72.    begin
    73.       loop
    74.          look_ahead(file, flag, end_line);
    75.          if end_line                      or else
    76.                flag = comment_flag_character then
    77.             Skip_Line(file);
    78.             line_number := line_number + 1;
    79.          else
    80.             exit;
    81.          end if;
    82.       end loop;
    83.       if flag = comment_flag_character then
    84.          raise Data_Error;
    85.       end if;
    86.    end skip_to_next_nonempty_line;
    87.
    88.    digit_offset : constant := Character'Pos('0');
    89.
    90.    procedure get_octal (file : in File_Type; value : out KDF9.word) is
    91.       next_char : Character;
    92.       last_char : Character := '_';
    93.       place     : Natural   := 0;
    94.       end_line  : Boolean   := False;
    95.    begin
    96.       value := 0;
    97.       ensure_not_at_end_of_line(file);
    98.       get(file, next_char);
    99.       if next_char = '#' then
   100.          get(file, next_char);
   101.       else
   102.          raise Data_Error;
   103.       end if;
   104.       loop
   105.          if next_char in '0' .. '7' then
   106.             value := value*8 + KDF9.word(Character'Pos(next_char)-digit_offset);
   107.             place := place + 1;
   108.             if place > 16 then
   109.                raise Data_Error;
   110.             end if;
   111.          elsif next_char = '_' then
   112.             if place = 0 then
   113.                raise Data_Error;
   114.             end if;
   115.          else
   116.             if last_char = '_' or place = 0 then
   117.                raise Data_Error;
   118.             end if;
   119.             exit;
   120.          end if;
   121.          last_char := next_char;
   122.          look_ahead(file, next_char, end_line);
   123.       exit when end_line;
   124.          if next_char in '0' .. '7' or next_char = '_' then
   125.             get(file, next_char);
   126.          else
   127.             if last_char = '_' or place = 0 then
   128.                raise Data_Error;
   129.             end if;
   130.             exit;
   131.          end if;
   132.       end loop;
   133.    end get_octal;
   134.
   135.    procedure get_decimal (file : in File_Type; value : out KDF9.word) is
   136.       next_char : Character;
   137.       last_char : Character := '_';
   138.       place     : Natural   := 0;
   139.       end_line  : Boolean   := False;
   140.    begin
   141.       value := 0;
   142.       ensure_not_at_end_of_line(file);
   143.       get(file, next_char);
   144.       if next_char not in '0' .. '9' then
   145.          raise Program_Error with "get_decimal " & next_char;
   146.       end if;
   147.       loop
   148.          if next_char in '0' .. '9' then
   149.             value := value*10 + KDF9.word(Character'Pos(next_char)-digit_offset);
   150.             place := place + 1;
   151.             if place > 15 then
   152.                raise Data_Error;
   153.             end if;
   154.          elsif next_char = '_' then
   155.             if place = 0 then
   156.                raise Data_Error;
   157.             end if;
   158.          else
   159.             if last_char = '_' or place = 0 then
   160.                raise Data_Error;
   161.             end if;
   162.       exit;
   163.          end if;
   164.          last_char := next_char;
   165.          look_ahead(file, next_char, end_line);
   166.       exit when end_line;
   167.          if next_char in '0' .. '9' or next_char = '_' then
   168.             get(file, next_char);
   169.          else
   170.             if last_char = '_' or place = 0 then
   171.                raise Data_Error;
   172.             end if;
   173.       exit;
   174.          end if;
   175.       end loop;
   176.    end get_decimal;
   177.
   178.    procedure get_word (file : in File_Type; value : out KDF9.word) is
   179.       next_char : Character;
   180.       end_line  : Boolean;
   181.    begin
   182.       ensure_not_at_end_of_line(file);
   183.       look_ahead(file, next_char, end_line);
   184.       pragma Unreferenced(end_line);
   185.       if next_char = '#' then
   186.          get_octal(file, value);
   187.       else
   188.          get_decimal(file, value);
   189.       end if;
   190.    end get_word;
   191.
   192.    procedure get_char (file : in File_Type; value : out Character) is
   193.       end_line : Boolean;
   194.       char     : Character;
   195.    begin
   196.       ensure_not_at_end_of_line(file);
   197.       look_ahead(file, char, end_line);
   198.       if end_line then
   199.          raise Data_Error;
   200.       end if;
   201.       if char /= ' ' then
   202.          get(file, value);
   203.       end if;
   204.    end get_char;
   205.
   206. end settings.IO;
   207.

Compiling: ../Source/settings-io.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:34

     1. -- settings.IO.ads
     2. --
     3. -- Settings-reader I/O support.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Text_IO;
    20. --
    21. with postscript;
    22.
    23. use  Ada.Text_IO;
    24.
    25. package settings.IO is
    26.
    27.    line_number : Natural := 0;
    28.
    29.    procedure open_options_file (file : in out File_Type; name : in String);
    30.
    31.    procedure close_options_file (file : in out File_Type; name : in String);
    32.
    33.    -- Check that the end of the line has not yet been reached, else raise Data_Error.
    34.    procedure ensure_not_at_end_of_line (file : in File_Type);
    35.
    36.    -- Move the reading position to the next non-blank or EOL, skipping comment.
    37.    procedure skip_to_next_non_blank (file : in File_Type);
    38.
    39.    -- Discard input until a non-empty line is reached,
    40.    --    leaving the reading position at the start of that line,
    41.    --    and incrementing line_number for each line terminator passed.
    42.    procedure skip_to_next_nonempty_line (file : in File_Type);
    43.
    44.    -- Read octal digits string as KDF9.word,
    45.    --    raising Data_Error on overflow or bad syntax.
    46.    procedure get_octal (file : in File_Type; value : out KDF9.word);
    47.
    48.    -- Read decimal digits string as KDF9.word,
    49.    --    raising Data_Error on overflow or bad syntax.
    50.    procedure get_decimal (file  : in File_Type; value : out KDF9.word);
    51.
    52.    -- Read an address as a KDF9.word in either octal or decimal,
    53.    --    using get_octal or get_decimal as indicated by the syntax.
    54.    procedure get_word (file : in File_Type; value : out KDF9.word);
    55.
    56.    -- Read the character value immediately following an octal or decimal number,
    57.    --    if it is not a space character; if it is a space, leave value unchanged.
    58.    procedure get_char (file : in File_Type; value : out Character);
    59.
    60.    package colour_IO is new Ada.Text_IO.Enumeration_IO(postscript.pen_colour);
    61.    package  width_IO is new Ada.Text_IO.Enumeration_IO(postscript.pen_tip_size);
    62.
    63. end settings.IO;

 207 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/generic_sets.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:34

     1. -- generic_sets.adb
     2. --
     3. -- Powersets of a discrete member type.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. -- generic
    20. --    type member is (<>);
    21. package body generic_sets is
    22.
    23.    function "abs" (set : generic_sets.set)
    24.    return Natural is
    25.       result : Natural := 0;
    26.    begin
    27.       for member in generic_sets.member loop
    28.          if set/member then
    29.             result := result + 1;
    30.          end if;
    31.       end loop;
    32.       return result;
    33.    end "abs";
    34.
    35.    function "/" (member : generic_sets.member; set : generic_sets.set)
    36.    return Boolean
    37.    is (set(member));
    38.
    39.    function "/" (set : generic_sets.set; member : generic_sets.member)
    40.    return Boolean
    41.    is (set(member));
    42.
    43.    function "or" (member : generic_sets.member; set : generic_sets.set)
    44.    return generic_sets.set is
    45.    begin
    46.       return result : generic_sets.set := set do
    47.          result(member) := True;
    48.       end return;
    49.    end "or";
    50.
    51.    function "or" (set : generic_sets.set; member : generic_sets.member)
    52.    return generic_sets.set is
    53.    begin
    54.       return result : generic_sets.set := set do
    55.          result(member) := True;
    56.       end return;
    57.    end "or";
    58.
    59.    function "-" (set : generic_sets.set; member : generic_sets.member)
    60.    return generic_sets.set is
    61.    begin
    62.       return result : generic_sets.set := set do
    63.          result(member) := False;
    64.       end return;
    65.    end "-";
    66.
    67.    function "-" (set1, set2 : generic_sets.set)
    68.    return generic_sets.set is
    69.    begin -- (set1 and not set2), avoiding need for large statically allocated workspace
    70.       return result : generic_sets.set := set1 do
    71.          for m in generic_sets.member loop
    72.             if set2(m) then
    73.                result(m) := False;
    74.             end if;
    75.          end loop;
    76.       end return;
    77.    end "-";
    78.
    79. end generic_sets;

Compiling: ../Source/generic_sets.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:34

     1. -- generic_sets.ads
     2. --
     3. -- Powersets of a discrete member type.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. generic
    20.    type member is (<>);
    21. package generic_sets is
    22.
    23.    pragma Preelaborate;
    24.
    25. --
    26. -- This package implements only those set operations that are needed by ee9.
    27. --
    28.
    29.    type set is array (generic_sets.member) of Boolean
    30.       with Component_Size => 1, Convention => C;
    31.
    32.    universe  : constant generic_sets.set := (others => True);
    33.
    34.    empty_set : constant generic_sets.set := (others => False);
    35.
    36.    function "abs" (set : generic_sets.set)
    37.    return Natural;
    38.
    39.    -- Test for membership of the set.
    40.    function "/" (set : generic_sets.set; member : generic_sets.member)
    41.    return Boolean;
    42.
    43.    function "/" (member : generic_sets.member; set : generic_sets.set)
    44.    return Boolean;
    45.
    46.     function "or"  (member : generic_sets.member; set : generic_sets.set)
    47.     return generic_sets.set;
    48.
    49.     function "or"  (set : generic_sets.set; member : generic_sets.member)
    50.     return generic_sets.set;
    51.
    52. -- "or"  (set1, set2 : generic_sets.set) is predefined
    53.
    54.    function "-" (set : generic_sets.set; member : generic_sets.member)
    55.    return generic_sets.set;
    56.
    57.    function "-" (set1, set2 : generic_sets.set)
    58.    return generic_sets.set;
    59.
    60. end generic_sets;

 79 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/kdf9-decoding.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:34

     1. -- kdf9-decoding.ads
     2. --
     3. -- The "compressed_opcode" values are effective opcodes, partially decoded from the first syllable,
     4. --   and combined with opcode bits of the second syllable, where appropriate (e.g. in jumps).
     5. --
     6. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     7. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     8. --
     9. -- The ee9 program is free software; you can redistribute it and/or
    10. -- modify it under terms of the GNU General Public License as published
    11. -- by the Free Software Foundation; either version 3, or (at your option)
    12. -- any later version. This program is distributed in the hope that it
    13. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    14. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    15. -- See the GNU General Public License for more details. You should have
    16. -- received a copy of the GNU General Public License distributed with
    17. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    18. --
    19.
    20. package KDF9.decoding is
    21.
    22.    -- The compressed_opcode values for 1-syllable orders are equal to their full codes.
    23.
    24.    ALL_0    : constant KDF9.compressed_opcode := 2#000_000#;
    25.    VR       : constant KDF9.compressed_opcode := 2#000_001#;
    26.    TO_TR    : constant KDF9.compressed_opcode := 2#000_010#;
    27.    BITS     : constant KDF9.compressed_opcode := 2#000_011#;
    28.    XF       : constant KDF9.compressed_opcode := 2#000_100#;
    29.    XDF      : constant KDF9.compressed_opcode := 2#000_101#;
    30.    INV006   : constant KDF9.compressed_opcode := 2#000_110#;
    31.    XPLUSF   : constant KDF9.compressed_opcode := 2#000_111#;
    32.    NEGD     : constant KDF9.compressed_opcode := 2#001_000#;
    33.    OR_9     : constant KDF9.compressed_opcode := 2#001_001#;
    34.    PERM     : constant KDF9.compressed_opcode := 2#001_010#;
    35.    TOB      : constant KDF9.compressed_opcode := 2#001_011#;
    36.    ROUNDH   : constant KDF9.compressed_opcode := 2#001_100#;
    37.    NEV      : constant KDF9.compressed_opcode := 2#001_101#;
    38.    ROUND    : constant KDF9.compressed_opcode := 2#001_110#;
    39.    DUMMY    : constant KDF9.compressed_opcode := 2#001_111#;
    40.    ROUNDF   : constant KDF9.compressed_opcode := 2#010_000#;
    41.    ROUNDHF  : constant KDF9.compressed_opcode := 2#010_001#;
    42.    MINUSDF  : constant KDF9.compressed_opcode := 2#010_010#;
    43.    PLUSDF   : constant KDF9.compressed_opcode := 2#010_011#;
    44.    FLOAT_9  : constant KDF9.compressed_opcode := 2#010_100#;
    45.    FLOATD   : constant KDF9.compressed_opcode := 2#010_101#;
    46.    ABS_9    : constant KDF9.compressed_opcode := 2#010_110#;
    47.    NEG      : constant KDF9.compressed_opcode := 2#010_111#;
    48.    ABSF     : constant KDF9.compressed_opcode := 2#011_000#;
    49.    NEGF     : constant KDF9.compressed_opcode := 2#011_001#;
    50.    MAX      : constant KDF9.compressed_opcode := 2#011_010#;
    51.    NOT_9    : constant KDF9.compressed_opcode := 2#011_011#;
    52.    XD       : constant KDF9.compressed_opcode := 2#011_100#;
    53.    X_frac   : constant KDF9.compressed_opcode := 2#011_101#;
    54.    MINUS    : constant KDF9.compressed_opcode := 2#011_110#;
    55.    SIGN     : constant KDF9.compressed_opcode := 2#011_111#;
    56.    INV040   : constant KDF9.compressed_opcode := 2#100_000#;
    57.    ZERO     : constant KDF9.compressed_opcode := 2#100_001#;
    58.    DUP      : constant KDF9.compressed_opcode := 2#100_010#;
    59.    DUPD     : constant KDF9.compressed_opcode := 2#100_011#;
    60.    DIVI     : constant KDF9.compressed_opcode := 2#100_100#;
    61.    FIX      : constant KDF9.compressed_opcode := 2#100_101#;
    62.    INV046   : constant KDF9.compressed_opcode := 2#100_110#;
    63.    STR      : constant KDF9.compressed_opcode := 2#100_111#;
    64.    CONT     : constant KDF9.compressed_opcode := 2#101_000#;
    65.    REVD     : constant KDF9.compressed_opcode := 2#101_001#;
    66.    ERASE    : constant KDF9.compressed_opcode := 2#101_010#;
    67.    MINUSD   : constant KDF9.compressed_opcode := 2#101_011#;
    68.    AND_9    : constant KDF9.compressed_opcode := 2#101_100#;
    69.    INV055   : constant KDF9.compressed_opcode := 2#101_101#;
    70.    PLUS     : constant KDF9.compressed_opcode := 2#101_110#;
    71.    PLUSD    : constant KDF9.compressed_opcode := 2#101_111#;
    72.    DIV      : constant KDF9.compressed_opcode := 2#110_000#;
    73.    DIVD     : constant KDF9.compressed_opcode := 2#110_001#;
    74.    DIVF     : constant KDF9.compressed_opcode := 2#110_010#;
    75.    DIVDF    : constant KDF9.compressed_opcode := 2#110_011#;
    76.    DIVR     : constant KDF9.compressed_opcode := 2#110_100#;
    77.    REV      : constant KDF9.compressed_opcode := 2#110_101#;
    78.    CAB      : constant KDF9.compressed_opcode := 2#110_110#;
    79.    FRB      : constant KDF9.compressed_opcode := 2#110_111#;
    80.    STAND    : constant KDF9.compressed_opcode := 2#111_000#;
    81.    NEGDF    : constant KDF9.compressed_opcode := 2#111_001#;
    82.    MAXF     : constant KDF9.compressed_opcode := 2#111_010#;
    83.    INV073   : constant KDF9.compressed_opcode := 2#111_011#;
    84.    PLUSF    : constant KDF9.compressed_opcode := 2#111_100#;
    85.    MINUSF   : constant KDF9.compressed_opcode := 2#111_101#;
    86.    INV076   : constant KDF9.compressed_opcode := 2#111_110#;
    87.    SIGNF    : constant KDF9.compressed_opcode := 2#111_111#;
    88.
    89.
    90.    -- compressed_opcode values for 2-syllable indirect fetch and store orders
    91.
    92.    MkMq       : constant KDF9.compressed_opcode := 2#000_000#;
    93.    MkMqQ      : constant KDF9.compressed_opcode := 2#000_010#;
    94.    MkMqH      : constant KDF9.compressed_opcode := 2#000_100#;
    95.    MkMqQH     : constant KDF9.compressed_opcode := 2#000_110#;
    96.    MkMqN      : constant KDF9.compressed_opcode := 2#001_000#;
    97.    MkMqQN     : constant KDF9.compressed_opcode := 2#001_010#;
    98.    MkMqHN     : constant KDF9.compressed_opcode := 2#001_100#;
    99.    MkMqQHN    : constant KDF9.compressed_opcode := 2#001_110#;
   100.
   101.    TO_MkMq    : constant KDF9.compressed_opcode := 2#000_001#;
   102.    TO_MkMqQ   : constant KDF9.compressed_opcode := 2#000_011#;
   103.    TO_MkMqH   : constant KDF9.compressed_opcode := 2#000_101#;
   104.    TO_MkMqQH  : constant KDF9.compressed_opcode := 2#000_111#;
   105.    TO_MkMqN   : constant KDF9.compressed_opcode := 2#001_001#;
   106.    TO_MkMqQN  : constant KDF9.compressed_opcode := 2#001_011#;
   107.    TO_MkMqHN  : constant KDF9.compressed_opcode := 2#001_101#;
   108.    TO_MkMqQHN : constant KDF9.compressed_opcode := 2#001_111#;
   109.
   110.
   111.    -- compressed_opcode values for 2-syllable Q store orders
   112.
   113.    M_PLUS_Iq    : constant KDF9.compressed_opcode := 2#100_000#;
   114.    M_MINUS_Iq   : constant KDF9.compressed_opcode := 2#100_001#;
   115.    NCq          : constant KDF9.compressed_opcode := 2#100_010#;
   116.    DCq          : constant KDF9.compressed_opcode := 2#100_011#;
   117.    POS1_TO_Iq   : constant KDF9.compressed_opcode := 2#100_100#;
   118.    NEG1_TO_Iq   : constant KDF9.compressed_opcode := 2#100_101#;
   119.    POS2_TO_Iq   : constant KDF9.compressed_opcode := 2#100_110#;
   120.    NEG2_TO_Iq   : constant KDF9.compressed_opcode := 2#100_111#;
   121.
   122.    MqTOQk       : constant KDF9.compressed_opcode := 2#101_001#;
   123.    IqTOQk       : constant KDF9.compressed_opcode := 2#101_010#;
   124.    IMqTOQk      : constant KDF9.compressed_opcode := 2#101_011#;
   125.    CqTOQk       : constant KDF9.compressed_opcode := 2#101_100#;
   126.    CMqTOQk      : constant KDF9.compressed_opcode := 2#101_101#;
   127.    CIqTOQk      : constant KDF9.compressed_opcode := 2#101_110#;
   128.    QqTOQk       : constant KDF9.compressed_opcode := 2#101_111#;
   129.
   130.    SHA          : constant KDF9.compressed_opcode := 2#110_001#;
   131.    SHAD         : constant KDF9.compressed_opcode := 2#110_010#;
   132.    MACC         : constant KDF9.compressed_opcode := 2#110_011#;
   133.    SHL          : constant KDF9.compressed_opcode := 2#110_100#;
   134.    SHLD         : constant KDF9.compressed_opcode := 2#110_110#;
   135.    SHC          : constant KDF9.compressed_opcode := 2#110_111#;
   136.    constant_bit : constant := 1;
   137.
   138.    TO_RCIMq     : constant KDF9.compressed_opcode := 2#111_000#;
   139.    QCIMq        : constant KDF9.compressed_opcode := 2#111_001#;
   140.    ADD_TO_QCIMq : constant KDF9.compressed_opcode := 2#111_010#;
   141.
   142.    -- masks for Q store Qk bits
   143.
   144.    reset_choice  : constant := 2#0001#;
   145.    C_part_choice : constant := 2#1000#;
   146.    I_part_choice : constant := 2#0100#;
   147.    M_part_choice : constant := 2#0010#;
   148.    all_Q_choice  : constant := C_part_choice + I_part_choice + M_part_choice;
   149.
   150.
   151.    -- compressed_opcode values for 2-syllable SJNS orders
   152.
   153.    LINK    : constant KDF9.compressed_opcode := 2#111_011#;
   154.    TO_LINK : constant KDF9.compressed_opcode := 2#111_100#;
   155.
   156.
   157.    -- compressed_opcode values for 2-syllable Director-only orders
   158.
   159.    TO_Kq : constant KDF9.compressed_opcode := 2#111_101#;
   160.    K0    : constant := 2#1000#;
   161.    K1    : constant := 2#0100#;
   162.    K2    : constant := 2#0010#;
   163.    K3    : constant := 2#0001#;
   164.    Kk    : constant KDF9.compressed_opcode := 2#111_110#;
   165.    K4    : constant := 2#1000#;
   166.    K5    : constant := 2#0100#;
   167.    K7    : constant := 2#0001#;
   168.
   169.
   170.    -- compressed_opcode value for 2-syllable short-loop jump order
   171.
   172.    JCqNZS : constant KDF9.compressed_opcode := 2#111_111#;
   173.
   174.
   175.    -- compressed_opcode values for 2-syllable I/O orders
   176.
   177.    CT_PMB_PMC_BUSY_Qq     : constant KDF9.compressed_opcode := 2#010_000#;
   178.    PAR_Qq                 : constant KDF9.compressed_opcode := 2#010_001#;
   179.    PMF_PMG_Qq             : constant KDF9.compressed_opcode := 2#010_010#;
   180.    PIA_PIC_CLO_TLO_Qq     : constant KDF9.compressed_opcode := 2#010_100#;
   181.    PIB_PID_Qq             : constant KDF9.compressed_opcode := 2#010_101#;
   182.    PIE_PIG_Qq             : constant KDF9.compressed_opcode := 2#010_110#;
   183.    PIF_PIH_Qq             : constant KDF9.compressed_opcode := 2#010_111#;
   184.
   185.    POA_POC_POE_POF_PMH_Qq : constant KDF9.compressed_opcode := 2#011_000#;
   186.    POB_POD_Qq             : constant KDF9.compressed_opcode := 2#011_001#;
   187.    POG_POL_Qq             : constant KDF9.compressed_opcode := 2#011_010#;
   188.    POH_POK_Qq             : constant KDF9.compressed_opcode := 2#011_011#;
   189.    PMA_PMK_INT_Qq         : constant KDF9.compressed_opcode := 2#011_100#;
   190.    PMD_PME_PML_Qq         : constant KDF9.compressed_opcode := 2#011_110#;
   191.
   192.    -- masks for I/O opcode extension bits (Qk field)
   193.
   194.    PAR_bits  : constant := 2#0000#;
   195.
   196.    -- PIA_PIC_CLO_TLO_Qq:
   197.    PIA_bits  : constant := 2#0000#;
   198.    PIC_bits  : constant := 2#1000#;
   199.    CLO_bits  : constant := 2#0010#;
   200.    TLO_bits  : constant := 2#0100#;
   201.
   202.    -- PIB_PID_Qq:
   203.    PIB_bits  : constant := 2#0000#;
   204.    PID_bits  : constant := 2#1000#;
   205.
   206.    -- PIE_PIG_Qq:
   207.    PIE_bits  : constant := 2#0000#;
   208.    PIG_bits  : constant := 2#1000#;
   209.
   210.    -- PIF_PIH_Qq:
   211.    PIF_bits  : constant := 2#0000#;
   212.    PIH_bits  : constant := 2#1000#;
   213.
   214.    -- PMA_PMK_INT_Qq:
   215.    PMA_bits  : constant := 2#0000#;
   216.    PMK_bits  : constant := 2#0100#;
   217.    INT_bits  : constant := 2#0010#;
   218.
   219.    -- CT_PMB_PMC_BUSY_Qq:
   220.    CTQ_bits   : constant := 2#0000#;
   221.    PMB_bits   : constant := 2#1000#;
   222.    PMC_bits   : constant := 2#0100#;
   223.    BUSY_bits  : constant := 2#0010#;
   224.    manual_bit : constant := 2#0001#;
   225.
   226.    -- PMD_PME_PML_Qq:
   227.    PME_bits  : constant := 2#0000#;
   228.    PMD_bits  : constant := 2#1000#;
   229.    PML_bits  : constant := 2#0100#;
   230.
   231.    -- PMF_PMG_Qq:
   232.    PMF_bits  : constant := 2#0000#;
   233.    PMG_bits  : constant := 2#0100#;
   234.
   235.    -- POA_POC_POE_POF_PMH_Qq:
   236.    POA_bits  : constant := 2#0000#;
   237.    POC_bits  : constant := 2#1000#;
   238.    POE_bits  : constant := 2#1100#;
   239.    POF_bits  : constant := 2#0100#;
   240.    PMH_bits  : constant := 2#0010#;
   241.
   242.    -- POB_POD_Qq:
   243.    POB_bits  : constant := 2#0000#;
   244.    POD_bits  : constant := 2#1000#;
   245.
   246.    -- POG_POL_Qq:
   247.    POG_bits  : constant := 2#0000#;
   248.    POL_bits  : constant := 2#1000#;
   249.
   250.    -- POH_POK_Qq:
   251.    POH_bits  : constant := 2#0000#;
   252.    POK_bits  : constant := 2#1000#;
   253.
   254.
   255.    -- compressed_opcode values for normal jump orders
   256.
   257.    JrNE   : constant KDF9.compressed_opcode := 2#000_001#;
   258.    JrGEZ  : constant KDF9.compressed_opcode := 2#000_010#;
   259.    JrLEZ  : constant KDF9.compressed_opcode := 2#000_100#;
   260.    JrNEZ  : constant KDF9.compressed_opcode := 2#000_110#;
   261.    JrNV   : constant KDF9.compressed_opcode := 2#001_000#;
   262.    OS_OUT : constant KDF9.compressed_opcode := 2#001_001#;
   263.    JrNEN  : constant KDF9.compressed_opcode := 2#001_010#;
   264.    Jr     : constant KDF9.compressed_opcode := 2#001_011#;
   265.    JrNEJ  : constant KDF9.compressed_opcode := 2#001_100#;
   266.    JSr    : constant KDF9.compressed_opcode := 2#001_101#;
   267.    JrNTR  : constant KDF9.compressed_opcode := 2#001_110#;
   268.    EXIT_n : constant KDF9.compressed_opcode := 2#001_111#;  -- 0h0 in bits 5-7
   269.    JrEQ   : constant KDF9.compressed_opcode := 2#010_001#;
   270.    JrLTZ  : constant KDF9.compressed_opcode := 2#010_010#;
   271.    JrGTZ  : constant KDF9.compressed_opcode := 2#010_100#;
   272.    JrEQZ  : constant KDF9.compressed_opcode := 2#010_110#;
   273.    JrV    : constant KDF9.compressed_opcode := 2#011_000#;
   274.    JrEN   : constant KDF9.compressed_opcode := 2#011_010#;
   275.    JrEJ   : constant KDF9.compressed_opcode := 2#011_100#;
   276.    JrTR   : constant KDF9.compressed_opcode := 2#011_110#;
   277.    EXITD  : constant KDF9.compressed_opcode := 2#011_111#;  -- 010 in bits 5-7
   278.    JrCqZ  : constant KDF9.compressed_opcode := 2#100_000#;
   279.    JrCqNZ : constant KDF9.compressed_opcode := 2#110_000#;
   280.
   281.    EXIT_1_bit : constant := 2#010#;  -- 0h0 in bits 5-7 of EXIT syllable_0
   282.
   283.
   284.    -- compressed_opcode values for directly-addressed data access orders
   285.
   286.    EaMq     : constant KDF9.compressed_opcode := 2#000_000#;
   287.    TO_EaMq  : constant KDF9.compressed_opcode := 2#000_001#;
   288.    EaMqQ    : constant KDF9.compressed_opcode := 2#000_010#;
   289.    TO_EaMqQ : constant KDF9.compressed_opcode := 2#000_011#;
   290.    SET      : constant KDF9.compressed_opcode := 2#000_100#;
   291.
   292.
   293. end KDF9.decoding;

 293 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-dispatcher.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:34

     1. -- ioc-dispatcher.adb
     2. --
     3. -- CPU I/O orders are dispatched here to device-specific handlers within the IOC type hierarchy.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with KDF9.PHU_store;
    20. with tracing;
    21.
    22. use  tracing;
    23.
    24. package body IOC.dispatcher is
    25.
    26.    --
    27.    --
    28.    -- CLO, SLO and TLO do not operate on a buffer, and so can be fully implemented here.
    29.    --
    30.    --
    31.
    32.    procedure CLO (Q_operand   : in KDF9.Q_register;
    33.                   set_offline : in Boolean) is
    34.       pragma Unreferenced(set_offline);
    35.       use  KDF9.PHU_store;
    36.    begin
    37.       -- This is a Director-only instruction.
    38.       take_note_of_test("   ", Q_operand, False);
    39.       unlock_absolute_addresses(Q_operand);
    40.       -- CLO also clears PHU[CPL].
    41.       PHU(CPL) := idle_PHU;
    42.       add_in_the_IO_lockout_CPU_time(Q_operand);
    43.    end CLO;
    44.
    45.    procedure SLO (Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean) is
    47.       pragma Unreferenced(set_offline);
    48.    begin
    49.       -- This is a Director-only instruction.
    50.       take_note_of_test("   ", Q_operand, False);
    51.       lock_out_absolute_addresses(Q_operand);
    52.       add_in_the_IO_lockout_CPU_time(Q_operand);
    53.    end SLO;
    54.
    55.    procedure TLO (Q_operand   : in KDF9.Q_register;
    56.                   result      : out Boolean) is
    57.    begin
    58.       -- This is NOT Director-only.
    59.       result := there_are_locks_in_relative_addresses(Q_operand);
    60.       take_note_of_test("   ", Q_operand, result);
    61.       add_in_the_IO_lockout_CPU_time(Q_operand);
    62.    end TLO;
    63.
    64.    --
    65.    --
    66.    -- All other I/O orders do access a buffer, and so dispatch to the relevant device driver.
    67.    --
    68.    --
    69.
    70.    procedure BUSY (Q_operand   : in KDF9.Q_register;
    71.                    set_offline : in Boolean;
    72.                    result      : out Boolean) is
    73.    begin
    74.       buffer(Q_operand.C and buffer_number_mask).BUSY(Q_operand, set_offline, result);
    75.    end BUSY;
    76.
    77.    procedure PAR (Q_operand   : in KDF9.Q_register;
    78.                   set_offline : in Boolean;
    79.                   result      : out Boolean) is
    80.    begin
    81.       buffer(Q_operand.C and buffer_number_mask).PAR(Q_operand, set_offline, result);
    82.    end PAR;
    83.
    84.    procedure MANUAL_CT (Q_operand   : in KDF9.Q_register;
    85.                         set_offline : in Boolean) is
    86.    begin
    87.       buffer(Q_operand.C and buffer_number_mask).MANUAL_CT(Q_operand, set_offline);
    88.    end MANUAL_CT;
    89.
    90.    procedure INT (Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean) is
    92.    begin
    93.       buffer(Q_operand.C and buffer_number_mask).INT(Q_operand, set_offline);
    94.    end INT;
    95.
    96.    procedure PIA (Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean) is
    98.    begin
    99.       buffer(Q_operand.C and buffer_number_mask).PIA(Q_operand, set_offline);
   100.       add_in_the_IO_lockout_CPU_time(Q_operand);
   101.    end PIA;
   102.
   103.    procedure PIB (Q_operand   : in KDF9.Q_register;
   104.                   set_offline : in Boolean) is
   105.    begin
   106.       buffer(Q_operand.C and buffer_number_mask).PIB(Q_operand, set_offline);
   107.       add_in_the_IO_lockout_CPU_time(Q_operand);
   108.    end PIB;
   109.
   110.    procedure PIC (Q_operand   : in KDF9.Q_register;
   111.                   set_offline : in Boolean) is
   112.    begin
   113.       buffer(Q_operand.C and buffer_number_mask).PIC(Q_operand, set_offline);
   114.       add_in_the_IO_lockout_CPU_time(Q_operand);
   115.    end PIC;
   116.
   117.    procedure PID (Q_operand   : in KDF9.Q_register;
   118.                   set_offline : in Boolean) is
   119.    begin
   120.       buffer(Q_operand.C and buffer_number_mask).PID(Q_operand, set_offline);
   121.       add_in_the_IO_lockout_CPU_time(Q_operand);
   122.    end PID;
   123.
   124.    procedure PIE (Q_operand   : in KDF9.Q_register;
   125.                   set_offline : in Boolean) is
   126.    begin
   127.       buffer(Q_operand.C and buffer_number_mask).PIE(Q_operand, set_offline);
   128.       add_in_the_IO_lockout_CPU_time(Q_operand);
   129.    end PIE;
   130.
   131.    procedure PIF (Q_operand   : in KDF9.Q_register;
   132.                   set_offline : in Boolean) is
   133.    begin
   134.       buffer(Q_operand.C and buffer_number_mask).PIF(Q_operand, set_offline);
   135.       add_in_the_IO_lockout_CPU_time(Q_operand);
   136.    end PIF;
   137.
   138.    procedure PIG (Q_operand   : in KDF9.Q_register;
   139.                   set_offline : in Boolean) is
   140.    begin
   141.       buffer(Q_operand.C and buffer_number_mask).PIG(Q_operand, set_offline);
   142.       add_in_the_IO_lockout_CPU_time(Q_operand);
   143.    end PIG;
   144.
   145.    procedure PIH (Q_operand   : in KDF9.Q_register;
   146.                   set_offline : in Boolean) is
   147.    begin
   148.       buffer(Q_operand.C and buffer_number_mask).PIH(Q_operand, set_offline);
   149.       add_in_the_IO_lockout_CPU_time(Q_operand);
   150.    end PIH;
   151.
   152.    procedure PMA (Q_operand   : in KDF9.Q_register;
   153.                   set_offline : in Boolean) is
   154.    begin
   155.       buffer(Q_operand.C and buffer_number_mask).PMA(Q_operand, set_offline);
   156.    end PMA;
   157.
   158.    procedure PMB (Q_operand   : in KDF9.Q_register;
   159.                   set_offline : in Boolean) is
   160.    begin
   161.       buffer(Q_operand.C and buffer_number_mask).PMB(Q_operand, set_offline);
   162.    end PMB;
   163.
   164.    procedure PMC (Q_operand   : in KDF9.Q_register;
   165.                   set_offline : in Boolean) is
   166.    begin
   167.       buffer(Q_operand.C and buffer_number_mask).PMC(Q_operand, set_offline);
   168.    end PMC;
   169.
   170.    procedure PMD (Q_operand   : in KDF9.Q_register;
   171.                   set_offline : in Boolean) is
   172.    begin
   173.       buffer(Q_operand.C and buffer_number_mask).PMD(Q_operand, set_offline);
   174.    end PMD;
   175.
   176.    procedure PME (Q_operand   : in KDF9.Q_register;
   177.                   set_offline : in Boolean) is
   178.    begin
   179.       buffer(Q_operand.C and buffer_number_mask).PME(Q_operand, set_offline);
   180.    end PME;
   181.
   182.    procedure PMF (Q_operand   : in KDF9.Q_register;
   183.                   set_offline : in Boolean) is
   184.    begin
   185.       buffer(Q_operand.C and buffer_number_mask).PMF(Q_operand, set_offline);
   186.    end PMF;
   187.
   188.    procedure PMG (Q_operand   : in KDF9.Q_register;
   189.                   set_offline : in Boolean) is
   190.    begin
   191.       buffer(Q_operand.C and buffer_number_mask).PMG(Q_operand, set_offline);
   192.    end PMG;
   193.
   194.    procedure PMK (Q_operand   : in KDF9.Q_register;
   195.                   set_offline : in Boolean) is
   196.    begin
   197.       buffer(Q_operand.C and buffer_number_mask).PMK(Q_operand, set_offline);
   198.    end PMK;
   199.
   200.    procedure PML (Q_operand   : in KDF9.Q_register;
   201.                   set_offline : in Boolean) is
   202.    begin
   203.       buffer(Q_operand.C and buffer_number_mask).PML(Q_operand, set_offline);
   204.    end PML;
   205.
   206.    procedure POA (Q_operand   : in KDF9.Q_register;
   207.                   set_offline : in Boolean) is
   208.    begin
   209.       buffer(Q_operand.C and buffer_number_mask).POA(Q_operand, set_offline);
   210.       add_in_the_IO_lockout_CPU_time(Q_operand);
   211.    end POA;
   212.
   213.    procedure POB (Q_operand   : in KDF9.Q_register;
   214.                   set_offline : in Boolean) is
   215.    begin
   216.       buffer(Q_operand.C and buffer_number_mask).POB(Q_operand, set_offline);
   217.       add_in_the_IO_lockout_CPU_time(Q_operand);
   218.    end POB;
   219.
   220.    procedure POC (Q_operand   : in KDF9.Q_register;
   221.                   set_offline : in Boolean) is
   222.    begin
   223.       buffer(Q_operand.C and buffer_number_mask).POC(Q_operand, set_offline);
   224.       add_in_the_IO_lockout_CPU_time(Q_operand);
   225.    end POC;
   226.
   227.    procedure POD (Q_operand   : in KDF9.Q_register;
   228.                   set_offline : in Boolean) is
   229.    begin
   230.       buffer(Q_operand.C and buffer_number_mask).POD(Q_operand, set_offline);
   231.       add_in_the_IO_lockout_CPU_time(Q_operand);
   232.    end POD;
   233.
   234.    procedure POE (Q_operand   : in KDF9.Q_register;
   235.                   set_offline : in Boolean) is
   236.    begin
   237.       buffer(Q_operand.C and buffer_number_mask).POE(Q_operand, set_offline);
   238.    end POE;
   239.
   240.    procedure POF (Q_operand   : in KDF9.Q_register;
   241.                   set_offline : in Boolean) is
   242.    begin
   243.       buffer(Q_operand.C and buffer_number_mask).POF(Q_operand, set_offline);
   244.    end POF;
   245.
   246.    procedure POG (Q_operand   : in KDF9.Q_register;
   247.                   set_offline : in Boolean) is
   248.    begin
   249.       buffer(Q_operand.C and buffer_number_mask).POG(Q_operand, set_offline);
   250.    end POG;
   251.
   252.    procedure POH (Q_operand   : in KDF9.Q_register;
   253.                   set_offline : in Boolean) is
   254.    begin
   255.       buffer(Q_operand.C and buffer_number_mask).POH(Q_operand, set_offline);
   256.    end POH;
   257.
   258.    procedure POK (Q_operand   : in KDF9.Q_register;
   259.                   set_offline : in Boolean) is
   260.    begin
   261.       buffer(Q_operand.C and buffer_number_mask).POK(Q_operand, set_offline);
   262.    end POK;
   263.
   264.    procedure POL (Q_operand   : in KDF9.Q_register;
   265.                   set_offline : in Boolean) is
   266.    begin
   267.       buffer(Q_operand.C and buffer_number_mask).POL(Q_operand, set_offline);
   268.    end POL;
   269.
   270. end IOC.dispatcher;

Compiling: ../Source/ioc-dispatcher.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:34

     1. -- ioc-dispatcher.ads
     2. --
     3. -- CPU I/O orders are dispatched here to device-specific handlers within the IOC type hierarchy.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.dispatcher is
    20.
    21.    procedure MANUAL_CT (Q_operand   : in KDF9.Q_register;
    22.                         set_offline : in Boolean);
    23.
    24.    procedure BUSY (Q_operand   : in KDF9.Q_register;
    25.                    set_offline : in Boolean;
    26.                    result      : out Boolean);
    27.
    28.    procedure PAR (Q_operand   : in KDF9.Q_register;
    29.                   set_offline : in Boolean;
    30.                   result      : out Boolean);
    31.
    32.    procedure TLO (Q_operand   : in KDF9.Q_register;
    33.                   result      : out Boolean);
    34.
    35.    procedure CLO (Q_operand   : in KDF9.Q_register;
    36.                   set_offline : in Boolean);
    37.
    38.    procedure SLO (Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    procedure INT (Q_operand   : in KDF9.Q_register;
    42.                   set_offline : in Boolean);
    43.
    44.    procedure PIA (Q_operand   : in KDF9.Q_register;
    45.                   set_offline : in Boolean);
    46.
    47.    procedure PIB (Q_operand   : in KDF9.Q_register;
    48.                   set_offline : in Boolean);
    49.
    50.    procedure PIC (Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    procedure PID (Q_operand   : in KDF9.Q_register;
    54.                   set_offline : in Boolean);
    55.
    56.    procedure PIE (Q_operand   : in KDF9.Q_register;
    57.                   set_offline : in Boolean);
    58.
    59.    procedure PIF (Q_operand   : in KDF9.Q_register;
    60.                   set_offline : in Boolean);
    61.
    62.    procedure PIG (Q_operand   : in KDF9.Q_register;
    63.                   set_offline : in Boolean);
    64.
    65.    procedure PIH (Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    procedure PMA (Q_operand   : in KDF9.Q_register;
    69.                   set_offline : in Boolean);
    70.
    71.    procedure PMB (Q_operand   : in KDF9.Q_register;
    72.                   set_offline : in Boolean);
    73.
    74.    procedure PMC (Q_operand   : in KDF9.Q_register;
    75.                   set_offline : in Boolean);
    76.
    77.    procedure PMD (Q_operand   : in KDF9.Q_register;
    78.                   set_offline : in Boolean);
    79.
    80.    procedure PME (Q_operand   : in KDF9.Q_register;
    81.                   set_offline : in Boolean);
    82.
    83.    procedure PMF (Q_operand   : in KDF9.Q_register;
    84.                   set_offline : in Boolean);
    85.
    86.    procedure PMG (Q_operand   : in KDF9.Q_register;
    87.                   set_offline : in Boolean);
    88.
    89.    procedure PMK (Q_operand   : in KDF9.Q_register;
    90.                   set_offline : in Boolean);
    91.
    92.    procedure PML (Q_operand   : in KDF9.Q_register;
    93.                   set_offline : in Boolean);
    94.
    95.    procedure POA (Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean);
    97.
    98.    procedure POB (Q_operand   : in KDF9.Q_register;
    99.                   set_offline : in Boolean);
   100.
   101.    procedure POC (Q_operand   : in KDF9.Q_register;
   102.                   set_offline : in Boolean);
   103.
   104.    procedure POD (Q_operand   : in KDF9.Q_register;
   105.                   set_offline : in Boolean);
   106.
   107.    procedure POE (Q_operand   : in KDF9.Q_register;
   108.                   set_offline : in Boolean);
   109.
   110.    procedure POF (Q_operand   : in KDF9.Q_register;
   111.                   set_offline : in Boolean);
   112.
   113.    procedure POG (Q_operand   : in KDF9.Q_register;
   114.                   set_offline : in Boolean);
   115.
   116.    procedure POH (Q_operand   : in KDF9.Q_register;
   117.                   set_offline : in Boolean);
   118.
   119.    procedure POK (Q_operand   : in KDF9.Q_register;
   120.                   set_offline : in Boolean);
   121.
   122.    procedure POL (Q_operand   : in KDF9.Q_register;
   123.                   set_offline : in Boolean);
   124.
   125. end IOC.dispatcher;
   126.

 270 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/disassembly.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:34

     1. -- disassembly.adb
     2. --
     3. -- Produce dis-assembled instructions in an approximation to KDF9 Usercode.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with formatting;
    20. with KDF9.CPU;
    21. with KDF9.decoding;
    22.
    23. use  formatting;
    24. use  KDF9.CPU;
    25. use  KDF9.decoding;
    26.
    27. package body disassembly is
    28.
    29.    function flagged (flag : String; s : KDF9.syllable)
    30.    return String
    31.    is (flag & oct_of(s));
    32.
    33.    function machine_code (decoded : KDF9.decoded_order)
    34.    return String
    35.    is (
    36.        case decoded.kind is
    37.           when one_syllable_order => flagged("#", decoded.order.syllable_0),
    38.
    39.           when two_syllable_order => flagged("#", decoded.order.syllable_0)
    40.                                    & flagged(":", decoded.order.syllable_1),
    41.           when normal_jump_order
    42.              | data_access_order  => flagged("#", decoded.order.syllable_0)
    43.                                    & flagged(":", decoded.order.syllable_1)
    44.                                    & flagged(":", decoded.order.syllable_2)
    45.       );
    46.
    47.    function one_syllable_order_name (decoded : KDF9.decoded_order)
    48.    return String
    49.    is (
    50.        case decoded.compressed_opcode is
    51.           when ABS_9   => "ABS",
    52.           when ABSF    => "ABSF",
    53.           when AND_9   => "AND",
    54.           when BITS    => "BITS",
    55.           when CAB     => "CAB",
    56.           when CONT    => "CONT",
    57.           when DIV     => "/",
    58.           when DIVD    => "/D",
    59.           when DIVDF   => "/DF",
    60.           when DIVF    => "/F",
    61.           when DIVI    => "/I",
    62.           when DIVR    => "/R",
    63.           when DUMMY   => "DUMMY",
    64.           when DUP     => "DUP",
    65.           when DUPD    => "DUPD",
    66.           when ERASE   => "ERASE",
    67.           when FIX     => "FIX",
    68.           when FLOAT_9 => "FLOAT",
    69.           when FLOATD  => "FLOATD",
    70.           when FRB     => "FRB",
    71.           when MAX     => "MAX",
    72.           when MAXF    => "MAXF",
    73.           when MINUS   => "-",
    74.           when MINUSD  => "-D",
    75.           when MINUSDF => "-DF",
    76.           when MINUSF  => "-F",
    77.           when NEG     => "NEG",
    78.           when NEGD    => "NEGD",
    79.           when NEGDF   => "NEGDF",
    80.           when NEGF    => "NEGF",
    81.           when NEV     => "NEV",
    82.           when NOT_9   => "NOT",
    83.           when OR_9    => "OR",
    84.           when PERM    => "PERM",
    85.           when PLUS    => "+",
    86.           when PLUSD   => "+D",
    87.           when PLUSDF  => "+DF",
    88.           when PLUSF   => "+F",
    89.           when REV     => "REV",
    90.           when REVD    => "REVD",
    91.           when ROUND   => "ROUND",
    92.           when ROUNDF  => "ROUNDF",
    93.           when ROUNDH  => "ROUNDH",
    94.           when ROUNDHF => "ROUNDHF",
    95.           when SIGN    => "SIGN",
    96.           when SIGNF   => "SIGNF",
    97.           when STAND   => "STAND",
    98.           when STR     => "STR",
    99.           when TO_TR   => "=TR",
   100.           when TOB     => "TOB",
   101.           when VR      => "VR",
   102.           when X_frac  => "×",
   103.           when XD      => "×D",
   104.           when XDF     => "×DF",
   105.           when XF      => "×F",
   106.           when XPLUSF  => "×+F",
   107.           when ZERO    => "ZERO",
   108.           when 0       => "DUMMY0",
   109.           when others  =>  machine_code(decoded)
   110.        );
   111.
   112.    function two_syllable_order_name (decoded : KDF9.decoded_order)
   113.    return String is
   114.
   115.       default : constant String := machine_code(decoded);
   116.       invalid : constant String := "";
   117.       k       : constant String := trimmed(decoded.Qk'Image);
   118.       q       : constant String := trimmed(decoded.Qq'Image);
   119.       opcode  : constant KDF9.compressed_opcode := (decoded.Qk and not manual_bit);
   120.       CT      : constant Boolean := (decoded.Qk and manual_bit) = 0;
   121.
   122.       function IO_order (stem : String)
   123.       return String
   124.       is (if stem = invalid then default else stem & "Q" & q);
   125.
   126.       function IO_order_name
   127.       return String
   128.       is (
   129.           case decoded.compressed_opcode is
   130.                when PIA_PIC_CLO_TLO_Qq =>
   131.                                    IO_order(case opcode is
   132.                                                when PIA_bits => "PIA",
   133.                                                when PIC_bits => "PIC",
   134.                                                when CLO_bits => "CLO",
   135.                                                when TLO_bits => "TLO",
   136.                                                when others   => invalid),
   137.                when PIB_PID_Qq =>
   138.                                    IO_order(case opcode is
   139.                                                when PIB_bits => "PIB",
   140.                                                when PID_bits => "PID",
   141.                                                when others   => invalid),
   142.                when PIE_PIG_Qq =>
   143.                                    IO_order(case opcode is
   144.                                                when PIE_bits => "PIE",
   145.                                                when PIG_bits => "PIG",
   146.                                                when others   => invalid),
   147.                when PIF_PIH_Qq =>
   148.                                    IO_order(case opcode is
   149.                                                when PIF_bits => "PIF",
   150.                                                when PIH_bits => "PIH",
   151.                                                when others   => invalid),
   152.                when PMA_PMK_INT_Qq =>
   153.                                    IO_order(case opcode is
   154.                                                when PMA_bits => "PMA",
   155.                                                when PMK_bits => "PMK",
   156.                                                when INT_bits => "INT",
   157.                                                when others   => invalid),
   158.                when CT_PMB_PMC_BUSY_Qq =>
   159.                                    IO_order(case opcode is
   160.                                                when PMB_bits  => "PMB",
   161.                                                when PMC_bits  => "PMC",
   162.                                                when BUSY_bits => "BUSY",
   163.                                                when CTQ_bits => (if CT then "CT" else "MANUAL"),
   164.                                                when others    => invalid),
   165.                when PMD_PME_PML_Qq =>
   166.                                    IO_order(case opcode is
   167.                                                when PMD_bits => "PMD",
   168.                                                when PME_bits => "PME",
   169.                                                when PML_bits => "PML",
   170.                                                when others   => invalid),
   171.                when PMF_PMG_Qq =>
   172.                                    IO_order(case opcode is
   173.                                                when PMF_bits => "PMF",
   174.                                                when PMG_bits => "PMG",
   175.                                                when others   => invalid),
   176.                when POA_POC_POE_POF_PMH_Qq =>
   177.                                    IO_order(case opcode is
   178.                                                when POA_bits => "POA",
   179.                                                when POC_bits => "POC",
   180.                                                when POE_bits => "POE",
   181.                                                when POF_bits => "POF",
   182.                                                when PMH_bits => "PMH",
   183.                                                when others   => invalid),
   184.                when POB_POD_Qq =>
   185.                                    IO_order(case opcode is
   186.                                                when POB_bits => "POB",
   187.                                                when POD_bits => "POD",
   188.                                                when others   => invalid),
   189.                when POG_POL_Qq =>
   190.                                    IO_order(case opcode is
   191.                                                when POG_bits => "POG",
   192.                                                when POL_bits => "POL",
   193.                                                when others   => invalid),
   194.                when POH_POK_Qq =>
   195.                                    IO_order(case opcode is
   196.                                                when POH_bits => "POH",
   197.                                                when POL_bits => "POK",
   198.                                                when others   => invalid),
   199.                when PAR_Qq =>      IO_order("PAR"),
   200.                when others =>      IO_order(invalid)
   201.          );
   202.
   203.       function indirect_store_order_name (suffix : String := "")
   204.       return String
   205.       is ("=M" & k & "M" & q & suffix);
   206.
   207.       function indirect_fetch_order_name (suffix : String := "")
   208.       return String
   209.       is ("M" & k & "M" & q & suffix);
   210.
   211.       function Qq_to_Qk_name (part : String)
   212.       return String
   213.       is (part & q & " TO Q" & k);
   214.
   215.       function Qq_order_name (action : String; suffix : String := "")
   216.       return String
   217.       is (action & q & suffix);
   218.
   219.       function shift_count
   220.       return String is
   221.          constant_flag : constant := 1;
   222.          fixed_shift   : CPU.signed_Q_part;
   223.       begin
   224.          if (decoded.order.syllable_1 and constant_flag) /= 0  then
   225.             fixed_shift := resign(KDF9.Q_part(decoded.order.syllable_1/2));
   226.             if fixed_shift > 63 then
   227.                fixed_shift := fixed_shift - 128;
   228.             end if;
   229.             return (if fixed_shift < 0 then "" else "+") & trimmed(fixed_shift'Image);
   230.          else
   231.             return "C" & q;
   232.          end if;
   233.       end shift_count;
   234.
   235.       function shift_order_name (action : String)
   236.       return String
   237.       is (action & shift_count);
   238.
   239.    begin -- two_syllable_order_name
   240.       return
   241.          (
   242.           case decoded.compressed_opcode is
   243.              when MkMq       => indirect_fetch_order_name,
   244.              when MkMqQ      => indirect_fetch_order_name(suffix => "Q"),
   245.              when MkMqH      => indirect_fetch_order_name(suffix => "H"),
   246.              when MkMqQH     => indirect_fetch_order_name(suffix => "QH"),
   247.              when MkMqN      => indirect_fetch_order_name(suffix => "N"),
   248.              when MkMqQN     => indirect_fetch_order_name(suffix => "QN"),
   249.              when MkMqHN     => indirect_fetch_order_name(suffix => "HN"),
   250.              when MkMqQHN    => indirect_fetch_order_name(suffix => "QHN"),
   251.
   252.              when TO_MkMq    => indirect_store_order_name,
   253.              when TO_MkMqQ   => indirect_store_order_name(suffix => "Q"),
   254.              when TO_MkMqH   => indirect_store_order_name(suffix => "H"),
   255.              when TO_MkMqQH  => indirect_store_order_name(suffix => "QH"),
   256.              when TO_MkMqN   => indirect_store_order_name(suffix => "N"),
   257.              when TO_MkMqQN  => indirect_store_order_name(suffix => "QN"),
   258.              when TO_MkMqHN  => indirect_store_order_name(suffix => "HN"),
   259.              when TO_MkMqQHN => indirect_store_order_name(suffix => "QHN"),
   260.
   261.              when M_PLUS_Iq  => Qq_order_name("M+I"),
   262.              when M_MINUS_Iq => Qq_order_name("M-I"),
   263.              when NCq        => Qq_order_name("NC"),
   264.              when DCq        => Qq_order_name("DC"),
   265.              when POS1_TO_Iq => Qq_order_name("I",  suffix => "=+1"),
   266.              when NEG1_TO_Iq => Qq_order_name("I",  suffix => "=-1"),
   267.              when POS2_TO_Iq => Qq_order_name("I",  suffix => "=+2"),
   268.              when NEG2_TO_Iq => Qq_order_name("I",  suffix => "=+2"),
   269.              when JCqNZS     => Qq_order_name("JC", suffix => "NZS"),
   270.
   271.              when MqTOQk     => Qq_to_Qk_name("M"),
   272.              when IqTOQk     => Qq_to_Qk_name("I"),
   273.              when IMqTOQk    => Qq_to_Qk_name("IM"),
   274.              when CqTOQk     => Qq_to_Qk_name("C"),
   275.              when CMqTOQk    => Qq_to_Qk_name("CM"),
   276.              when CIqTOQk    => Qq_to_Qk_name("CI"),
   277.              when QqTOQk     => Qq_to_Qk_name("Q"),
   278.              when QCIMq =>
   279.                 (
   280.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then  Qq_order_name("Q")
   281.                  elsif (decoded.Qk and M_part_choice) /= 0       then  Qq_order_name("M")
   282.                  elsif (decoded.Qk and C_part_choice) /= 0       then  Qq_order_name("C")
   283.                  elsif (decoded.Qk and I_part_choice) /= 0       then  Qq_order_name("I")
   284.                  else  default
   285.                 ),
   286.              when TO_RCIMq =>
   287.                 (
   288.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then Qq_order_name("=Q")
   289.                  elsif (decoded.Qk and M_part_choice) /= 0 then
   290.                     Qq_order_name(if (decoded.Qk and reset_choice) /= 0 then "=RM" else "=M")
   291.                  elsif (decoded.Qk and C_part_choice) /= 0 then
   292.                     Qq_order_name(if (decoded.Qk and reset_choice) /= 0 then "=RC" else "=C")
   293.                  elsif (decoded.Qk and I_part_choice) /= 0 then
   294.                     Qq_order_name(if (decoded.Qk and reset_choice) /= 0 then "=RI" else "=I")
   295.                  else default
   296.                 ),
   297.              when ADD_TO_QCIMq =>
   298.                 (
   299.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then Qq_order_name("=+Q")
   300.                  elsif (decoded.Qk and M_part_choice) /= 0       then Qq_order_name("=+M")
   301.                  elsif (decoded.Qk and C_part_choice) /= 0       then Qq_order_name("=+C")
   302.                  elsif (decoded.Qk and I_part_choice) /= 0       then Qq_order_name("=+I")
   303.                  else  default
   304.                 ),
   305.
   306.              when SHA   => shift_order_name("SHA"),
   307.              when SHAD  => shift_order_name("SHAD"),
   308.              when MACC  => shift_order_name("×+"),
   309.              when SHL   => shift_order_name("SHL"),
   310.              when SHLD  => shift_order_name("SHLD"),
   311.              when SHC   => shift_order_name("SHC"),
   312.
   313.              when TO_Kq =>
   314.                 (
   315.                  case decoded.Qq is
   316.                     when K0 => "=K0",
   317.                     when K1 => "=K1",
   318.                     when K2 => "=K2",
   319.                     when K3 => "=K3",
   320.                     when others => default
   321.                 ),
   322.              when Kk =>
   323.                 (
   324.                  case decoded.Qk is
   325.                    when K4 => "K4",
   326.                    when K5 => "K5",
   327.                    when K7 => "K7",
   328.                    when others => default
   329.                 ),
   330.
   331.              when LINK    => "LINK",
   332.              when TO_LINK => "=LINK",
   333.
   334.              when others  => IO_order_name
   335.           );
   336.    end two_syllable_order_name;
   337.
   338.    function normal_jump_order_name (decoded      : KDF9.decoded_order;
   339.                                     octal_option : Boolean := True;
   340.                                     both_bases   : Boolean := True)
   341.    return String is
   342.
   343.       the_target  : syllable_address renames decoded.target;
   344.       the_address : constant String := oct_or_dec_of(the_target, octal_option);
   345.       remark      : constant String
   346.                   := ";("
   347.                    & (if   octal_option
   348.                       then dec_of(KDF9.Q_part(the_target.order_word_number))
   349.                       else "#" & oct_of(the_target.order_word_number))
   350.                    & ")";
   351.
   352.       function jump (on_condition : String)
   353.       return String
   354.       is ("JE" & the_address & on_condition & (if both_bases then remark else ""));
   355.
   356.       function leave (and_how : String)
   357.       return String
   358.       is ("EXIT" & and_how & remark);
   359.
   360.    begin  -- normal_jump_order_name
   361.       return (
   362.               case decoded.compressed_opcode is
   363.                  when JrEQ   => jump("EQ"),
   364.                  when JrGTZ  => jump("GTZ"),
   365.                  when JrLTZ  => jump("LTZ"),
   366.                  when JrEQZ  => jump("EQZ"),
   367.                  when JrV    => jump("V"),
   368.                  when JrEN   => jump("EN"),
   369.                  when Jr     => jump(""),
   370.                  when JrEJ   => jump("EJ"),
   371.                  when JrTR   => jump("TR"),
   372.                  when JrNE   => jump("NE"),
   373.                  when JrLEZ  => jump("LEZ"),
   374.                  when JrGEZ  => jump("GEZ"),
   375.                  when JrNEZ  => jump("NEZ"),
   376.                  when JrNV   => jump("NV"),
   377.                  when JrNEN  => jump("NEN"),
   378.                  when JrNEJ  => jump("NEJ"),
   379.                  when JrNTR  => jump("NTR"),
   380.
   381.                  when JrCqZ  => jump("C" & trimmed(decoded.Qq'Image) & "Z"),
   382.                  when JrCqNZ => jump("C" & trimmed(decoded.Qq'Image) & "NZ"),
   383.
   384.                  when JSr    => "JSE" & the_address,
   385.                  when OS_OUT => "OUT",
   386.
   387.                  when EXITD  => leave("D"),
   388.                  when EXIT_n =>
   389.                     -- Try to give the most helpful interpretation of the operand.
   390.                     (
   391.                      if the_target.syllable_index = 0 then  -- c.f. decode_a_jump_order.
   392.                         -- No halfword offset applies.
   393.                         (
   394.                          if the_target.order_word_number < 4 then
   395.                            leave(
   396.                                  if the_target.order_word_number = 0
   397.                                  then ""
   398.                                  else oct_of(KDF9.Q_part(2*the_target.order_word_number), 1)
   399.                                 )
   400.                          else
   401.                            leave("AE" & oct_or_dec_of((the_target.order_word_number, 0), octal_option))
   402.                         )
   403.                      elsif the_target.order_word_number < 4 then
   404.                         leave(oct_of(KDF9.Q_part(2*the_target.order_word_number + 1), 1))
   405.                      else
   406.                         leave("AE" & oct_or_dec_of((the_target.order_word_number, 3), octal_option))
   407.                     ),
   408.
   409.                  when others =>  machine_code(decoded)
   410.              );
   411.    end normal_jump_order_name;
   412.
   413.    function data_access_order_name (decoded      : KDF9.decoded_order;
   414.                                     octal_option : Boolean;
   415.                                     both_bases   : Boolean := True)
   416.    return String is
   417.
   418.       operand      : KDF9.Q_part   renames decoded.operand;
   419.       Qq           : KDF9.Q_number renames decoded.Qq;
   420.       the_address  : constant String
   421.                    := (if octal_option then "#" & oct_of(operand, 1) else dec_of(operand));
   422.       remark       : constant String
   423.                    := ";(" & (if octal_option then dec_of(operand) else "#" & oct_of(operand, 1)) & ")";
   424.       any_modifier : constant String
   425.                    := (if Qq /= 0 then "M" & trimmed(Qq'Image) else "");
   426.    begin
   427.       return (
   428.               case decoded.compressed_opcode is
   429.                  when EaMq     => "E"   & the_address & any_modifier & remark,
   430.                  when TO_EaMq  => "=E"  & the_address & any_modifier & remark,
   431.                  when EaMqQ    => "E"   & the_address & any_modifier & "Q" & remark,
   432.                  when TO_EaMqQ => "=E"  & the_address & any_modifier & "Q" & remark,
   433.                  when SET      => "SET" & (
   434.                                            if octal_option
   435.                                            then "B" & oct_of(operand, 2)
   436.                                               & (
   437.                                                  if operand > 7 and both_bases
   438.                                                  then ";(" & signed_dec_of(operand) & ")"
   439.                                                  else ""
   440.                                                 )
   441.                                            else signed_dec_of(operand)
   442.                                               & (
   443.                                                  if operand > 9 and both_bases
   444.                                                  then ";(B" & oct_of(operand, 2) & ")"
   445.                                                  else ""
   446.                                                 )
   447.                                           ),
   448.                  when others   => "?"
   449.              );
   450.    end data_access_order_name;
   451.
   452.    function the_full_name_of (order        : KDF9.decoded_order;
   453.                               octal_option : Boolean := True;
   454.                               both_bases   : Boolean := True)
   455.    return String is
   456.       result : constant String
   457.          := (
   458.              case order.kind is
   459.                 when one_syllable_order => one_syllable_order_name(order),
   460.                 when two_syllable_order => two_syllable_order_name(order),
   461.                 when normal_jump_order  => normal_jump_order_name(order, octal_option, both_bases),
   462.                 when data_access_order  => data_access_order_name(order, octal_option, both_bases)
   463.             );
   464.    begin
   465.       return (if result(1) /= '?' then result else "an INVALID order");
   466.    end the_full_name_of;
   467.
   468.    function the_code_and_name_of_INS
   469.    return String
   470.    is (machine_code(INS) & ", i.e. " & the_full_name_of(INS));
   471.
   472.    function two_syllable_skeleton (encoding : KDF9.syllable)
   473.    return String is
   474.
   475.       function IO_skeleton
   476.       return String
   477.       is (
   478.           case encoding and 8#77# is
   479.              when POA_POC_POE_POF_PMH_Qq => "{POA|POC|POE|POF|PMH}Qq",
   480.              when PIA_PIC_CLO_TLO_Qq     => "{PIA|PIC|CLO|TLO}Qq",
   481.              when CT_PMB_PMC_BUSY_Qq     => "{BUSY|CT|MANUAL|PMB|PMC}Qq",
   482.              when PAR_Qq                 => "PARQq",
   483.              when PIB_PID_Qq             => "{PIB|PID}Qq",
   484.              when PIE_PIG_Qq             => "{PIE|PIG}Qq",
   485.              when PIF_PIH_Qq             => "{PIF|PIH}Qq",
   486.              when PMA_PMK_INT_Qq         => "{INT|PMA|PMK}Qq",
   487.              when PMD_PME_PML_Qq         => "{PMD|PME}Qq",
   488.              when PMF_PMG_Qq             => "{PMF|PMG}Qq",
   489.              when POB_POD_Qq             => "{POB|POD}Qq",
   490.              when POG_POL_Qq             => "{POG|POL}Qq",
   491.              when POH_POK_Qq             => "{POH|POK}Qq",
   492.              when others                 => "invalid IO group syllable #" & oct_of(encoding)
   493.          );
   494.
   495.    begin  -- two_syllable_skeleton
   496.       return
   497.          (
   498.           case encoding and 8#77# is
   499.              when MkMq         => "MkMq",
   500.              when MkMqQ        => "MkMqQ",
   501.              when MkMqH        => "MkMqH",
   502.              when MkMqQH       => "MkMqQH",
   503.              when MkMqN        => "MkMqN",
   504.              when MkMqQN       => "MkMqQN",
   505.              when MkMqHN       => "MkMqHN",
   506.              when MkMqQHN      => "MkMqQHN",
   507.
   508.              when TO_MkMq      => "=MkMq",
   509.              when TO_MkMqQ     => "=MkMqQ",
   510.              when TO_MkMqH     => "=MkMqH",
   511.              when TO_MkMqQH    => "=MkMqQH",
   512.              when TO_MkMqN     => "=MkMqN",
   513.              when TO_MkMqQN    => "=MkMqQN",
   514.              when TO_MkMqHN    => "=MkMqHN",
   515.              when TO_MkMqQHN   => "=MkMqQHN",
   516.
   517.              when JCqNZS       => "JCqNZS",
   518.              when M_PLUS_Iq    => "M+Iq",
   519.              when M_MINUS_Iq   => "M-Iq",
   520.              when NCq          => "NCq",
   521.              when DCq          => "DCq",
   522.              when POS1_TO_Iq   => "Iq=+1",
   523.              when NEG1_TO_Iq   => "Iq=-1",
   524.              when POS2_TO_Iq   => "Iq=+2",
   525.              when NEG2_TO_Iq   => "Iq=-2",
   526.
   527.              when MqTOQk       => "MqTOQk",
   528.              when IqTOQk       => "IqTOQk",
   529.              when IMqTOQk      => "IMqTOQk",
   530.              when CqTOQk       => "CqTOQk",
   531.              when CMqTOQk      => "CMqTOQk",
   532.              when CIqTOQk      => "CIqTOQk",
   533.              when QqTOQk       => "QqTOQk",
   534.
   535.              when QCIMq        => "{Q|C|I|M}q",
   536.              when TO_RCIMq     => "=[R]{Q|C|I|M}q",
   537.              when ADD_TO_QCIMq => "=+{Q|C|I|M}q",
   538.
   539.              when SHA          => "SHA",
   540.              when SHAD         => "SHAD",
   541.              when MACC         => "×+",
   542.              when SHL          => "SHL",
   543.              when SHLD         => "SHLD",
   544.              when SHC          => "SHC",
   545.
   546.              when TO_Kq =>
   547.                 (
   548.                  case encoding / 16 mod 16 is
   549.                     when K0 => "=K0",
   550.                     when K1 => "=K1",
   551.                     when K2 => "=K2",
   552.                     when K3 => "=K3",
   553.                     when others => "=K?"
   554.                 ),
   555.              when Kk =>
   556.                 (
   557.                  case encoding mod 16 is
   558.                     when K4 => "K4",
   559.                     when K5 => "K5",
   560.                     when K7 => "K7",
   561.                     when others => "K?"
   562.                 ),
   563.
   564.              when LINK =>    "LINK",
   565.              when TO_LINK => "=LINK",
   566.
   567.              when others =>  IO_skeleton
   568.          );
   569.    end two_syllable_skeleton;
   570.
   571.    function normal_jump_skeleton (encoding : KDF9.syllable)
   572.    return String
   573.    is (
   574.        case encoding and 8#77# is
   575.           when JrCqZ  .. JrCqZ+2#1111#  => "JrCqZ",
   576.           when JrCqNZ .. JrCqNZ+2#1111# => "JrCqNZ",
   577.           when JrEQ   => "JrEQ",
   578.           when JrGTZ  => "JrGTZ",
   579.           when JrLTZ  => "JrLTZ",
   580.           when JrEQZ  => "JrEQZ",
   581.           when JrV    => "JrV",
   582.           when JrEN   => "JrEN",
   583.           when Jr     => "Jr",
   584.           when JrEJ   => "JrEJ",
   585.           when JSr    => "JSr",
   586.           when JrTR   => "JrTR",
   587.           when EXIT_n => "EXIT",
   588.           when JrNE   => "JrNE",
   589.           when JrLEZ  => "JrLEZ",
   590.           when JrGEZ  => "JrGEZ",
   591.           when JrNEZ  => "JrNEZ",
   592.           when JrNV   => "JrNV",
   593.           when JrNEN  => "JrNEN",
   594.           when JrNEJ  => "JrNEJ",
   595.           when JrNTR  => "JrNTR",
   596.           when OS_OUT => "OUT",
   597.           when EXITD  => "EXITD",
   598.           when others => "invalid jump group syllable #" & oct_of(encoding)
   599.       );
   600.
   601.    function data_access_skeleton (compressed_opcode : KDF9.compressed_opcode)
   602.    return String
   603.    is (
   604.        case compressed_opcode is
   605.           when EaMq     => "EeMq",
   606.           when TO_EaMq  => "=EeMq",
   607.           when EaMqQ    => "EeMqQ",
   608.           when TO_EaMqQ => "=EeMqQ",
   609.           when SET      => "SET",
   610.           when others   => "invalid data access compressed opcode #" & oct_of(compressed_opcode)
   611.       );
   612.
   613.    function the_short_name_of (syllable_0 : KDF9.syllable)
   614.    return String is
   615.       its_INS : KDF9.decoded_order := (order => (syllable_0, 0, 0), others => <>);
   616.    begin
   617.       decode(its_INS);
   618.       return
   619.          (
   620.           case KDF9.INS_kind(syllable_0 / 2**6) is
   621.              when one_syllable_order   => one_syllable_order_name(its_INS),
   622.              when two_syllable_order   => two_syllable_skeleton(syllable_0),
   623.              when normal_jump_order    => normal_jump_skeleton(syllable_0),
   624.              when data_access_order    => data_access_skeleton(its_INS.compressed_opcode)
   625.          );
   626.    end the_short_name_of;
   627.
   628. end disassembly;

Compiling: ../Source/disassembly.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:34

     1. -- disassembly.ads
     2. --
     3. -- Produce dis-assembled instructions in an approximation to KDF9 Usercode.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with KDF9;
    20.
    21. use  KDF9;
    22.
    23. package disassembly is
    24.
    25.    function the_code_and_name_of_INS
    26.    return String;
    27.
    28.    function the_full_name_of (order        : KDF9.decoded_order;
    29.                               octal_option : Boolean := True;
    30.                               both_bases   : Boolean := True)
    31.    return String;
    32.
    33.    function the_short_name_of (syllable_0 : KDF9.syllable)
    34.    return String;
    35.
    36. end disassembly;

 628 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-diagnostics.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:36

     1. -- ioc-diagnostics.adb
     2. --
     3. -- Provide diagnostic output of the state of all the buffers.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with disassembly;
    20.
    21. with IOC.the_locker_of;
    22.
    23. procedure IOC.diagnostics is
    24.    Q : KDF9.Q_register;
    25.    B : KDF9.Q_part;
    26. begin
    27.    if not debugging_is_enabled then return; end if;
    28.    for g in Q_part'(0) .. 100 loop
    29.       if there_are_locks_in_physical_addresses(KDF9.Q_register'(0, 32*g, 32*g + 31)) then
    30.          output("there are locks in group" & g'Image & " PHY" & Q_part'(32*g)'Image);
    31.          B := the_locker_of(32*g);
    32.          output(", locked by" & B'Image & ":");
    33.          if B /= 16 then output_line(buffer(B).device_name); else output_line(""); end if;
    34.       end if;
    35.    end loop;
    36.    for the_buffer of buffer loop
    37.       if the_buffer /= null                        and then
    38.          the_buffer.initiation_time /= KDF9.us'Last    then
    39.          output_line;
    40.          output_line("Current state of buffer #" & oct_of(the_buffer.number, 2));
    41.          output_line(
    42.                      "   device: " & the_buffer.device_name
    43.                    & "     kind: " & the_buffer.kind'Image
    44.                    & "     unit:"  & the_buffer.unit'Image
    45.                     );
    46.          output_line("  is_busy: " & the_buffer.is_busy'Image);
    47.          output_line("operation: " & the_buffer.operation'Image);
    48.          output_line(" off_line: " & the_buffer.is_offline'Image);
    49.          output_line(" abnormal: " & the_buffer.is_abnormal'Image);
    50.          output_line(" Director: " & the_buffer.is_for_Director'Image);
    51.          output_line(" priority:"  & the_buffer.priority_level'Image);
    52.          output_line("initiated:"  & the_buffer.initiation_time'Image);
    53.          output_line("xfer_time:"  & the_buffer.transfer_time'Image);
    54.          output_line("completes:"  & the_buffer.completion_time'Image);
    55.          Q := the_buffer.control_word;
    56.          output_line(
    57.                      "  control: "
    58.                    & "Q"
    59.                    & Q.C'Image
    60.                    &"/"
    61.                    & Q.I'Image
    62.                    & "/"
    63.                    & Q.M'Image
    64.                     );
    65.          if Q.I <= max_address               and then
    66.              Q.M <= max_address              and then
    67.                 Q.I <= the_buffer.control_word.M then
    68.             output_line(
    69.                         "locked in:"
    70.                       & group(Q.I)'Image
    71.                       & ".."
    72.                       & group(Q.M)'Image
    73.                       & " is "
    74.                       & there_are_locks_in_physical_addresses(Q)'Image
    75.                        );
    76.          end if;
    77.          output_line("order ICR:"  & the_buffer.order_count'Image);
    78.          output_line("    order: " & disassembly.the_full_name_of(the_buffer.decoded_order));
    79.          output_line("@ address: " & oct_of(the_buffer.order_address));
    80.       end if;
    81.    end loop;
    82. end IOC.diagnostics;

 82 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/file_interfacing.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:36

     1. -- file_IO_interface.adb
     2. --
     3. -- Provide an Ada.Text_IO interface to the file system of the real OS.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package body file_interfacing is
    20.
    21.    procedure initialize (some_file : in out File_Type;
    22.                          mode      : in File_Mode;
    23.                          file_name : in String) is
    24.    begin
    25.       Open(some_file, mode, file_name);
    26.    exception
    27.       when others =>
    28.          if mode = Out_File then
    29.             Create(some_file, Out_File, file_name);
    30.          else
    31.             raise;
    32.          end if;
    33.    end initialize;
    34.
    35.    procedure finalize (some_file : in out File_Type;
    36.                        file_name : in String) is
    37.       pragma Unreferenced(file_name);
    38.    begin
    39.       Close(some_file);
    40.    end finalize;
    41.
    42. end file_interfacing;

Compiling: ../Source/file_interfacing.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:36

     1. -- file_interfacing.ads
     2. --
     3. -- Provide an Ada.Text_IO interface to the file system of the real OS.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Text_IO;
    20.
    21. use  Ada.Text_IO;
    22.
    23. package file_interfacing is
    24.
    25.    procedure initialize (some_file : in out File_Type;
    26.                          mode      : in File_Mode;
    27.                          file_name : in String);
    28.
    29.    procedure finalize (some_file : in out File_Type;
    30.                        file_name : in String);
    31.
    32. end file_interfacing;

 42 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/plotter.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:36

     1. -- plotter.adb
     2. --
     3. -- Emulation of the plotting commands of the Calcomp 564 graph plotter.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with IOC.slow.shift.GP;
    20. with postscript;
    21.
    22. use  IOC.slow.shift.GP;
    23. use  postscript;
    24.
    25. package body plotter is
    26.
    27.    -- The plotter made equal movements in the x and y directions, in steps of 0.005 inches.
    28.    -- Each command moves the plotting position by at most 1 step,
    29.    --   in either the positive or negative direction of each axis.
    30.
    31.    type step is
    32.      record
    33.         dx, dy : Integer range -1 .. +1;
    34.      end record;
    35.
    36.    null_step : constant plotter.step := (0, 0);
    37.
    38.    function "+" (p : postscript.point; s : plotter.step)
    39.    return postscript.point
    40.    is ((p.x + s.dx, p.y + s.dy));
    41.
    42.    function "-" (p, q : postscript.point)
    43.    return plotter.step
    44.    is ((p.x - q.x, p.y - q.y));
    45.
    46.    -- The plotter drew on a roll of paper 29.5 inches wide and 120 feet long.
    47.    -- 29.5" is   5900 steps at 200 steps per inch = 59 * 100
    48.    -- 120'  is 288000 steps  = 200 per inch * 12 inches per foot * 120 feet.
    49.    -- This sets the boundaries of the plot.
    50.    -- It was physically impossible to move to a point beyond these limits.
    51.
    52.    plot_limit : constant postscript.point := (120*12*200, 59*100);
    53.
    54.    -- A vector is represented by a series of consecutive colinear plotter movements.
    55.    -- For better efficiency, the steps of a vector are accumulated until there is
    56.    --    a change of direction, a pen lift, or the need to close the plotter file.
    57.    -- On these events, any vector thus defined is drawn via a single PostScript command.
    58.
    59.    the_origin      : constant postscript.point := (0, 0);
    60.
    61.    plot_position,
    62.    start_position  : postscript.point := the_origin;
    63.
    64.    -- last_step retains the direction of the previous plotter step.
    65.    last_step       : plotter.step := null_step;
    66.
    67.    the_pen_is_down : Boolean := False;
    68.
    69.    procedure ensure_the_validity_of (from  : in postscript.point;
    70.                                      step  : in plotter.step) is
    71.    begin
    72.      if from.x + step.dx < 0                     or else
    73.            from.y + step.dy < 0                  or else
    74.               from.x + step.dx > plot_limit.x    or else
    75.                  from.y + step.dy > plot_limit.y    then
    76.         notify_invalid_movement(from.x, from.y, step.dx, step.dy);
    77.      end if;
    78.    end ensure_the_validity_of;
    79.
    80.    procedure jump_to (p : in postscript.point)
    81.      with Inline;
    82.
    83.    procedure jump_to (p : in postscript.point) is
    84.    begin
    85.      -- Posit a new vector starting at p.
    86.      last_step := null_step;
    87.      plot_position := p;
    88.      start_position := p;
    89.    end;
    90.
    91.    procedure jump_by (this_step : in plotter.step)
    92.      with Inline;
    93.
    94.    procedure jump_by (this_step : in plotter.step) is
    95.    begin
    96.      ensure_the_validity_of(from => plot_position, step => this_step);
    97.      jump_to(plot_position + this_step);
    98.    end jump_by;
    99.
   100.    procedure close_any_open_vector (stream : in out host_IO.stream) is
   101.    begin
   102.      if the_pen_is_down                and then
   103.            start_position /= plot_position then
   104.         draw_a_PS_vector(stream, start_position, plot_position);
   105.         start_position := plot_position;
   106.      end if;
   107.    end close_any_open_vector;
   108.
   109.    procedure perform (action : in plotter.command; stream : in out host_IO.stream) is
   110.
   111.      procedure draw_to (p : in postscript.point)
   112.         with Inline;
   113.
   114.      procedure draw_to (p : in postscript.point) is
   115.      begin
   116.         if (plot_position - p) = last_step then
   117.            -- p is colinear with the previous step, so merely extend the vector to p.
   118.            plot_position := p;
   119.         else
   120.            -- Draw the whole vector and start a new one.
   121.            draw_a_PS_vector(stream, start_position, plot_position);
   122.            last_step := plot_position - p;
   123.            start_position := plot_position;
   124.            plot_position := p;
   125.         end if;
   126.      end draw_to;
   127.
   128.      procedure draw_by (this_step : in plotter.step)
   129.         with Inline;
   130.
   131.      procedure draw_by (this_step : in plotter.step) is
   132.      begin
   133.         ensure_the_validity_of(from => plot_position, step => this_step);
   134.         draw_to(plot_position + this_step);
   135.      end draw_by;
   136.
   137.      procedure move_by (this_step : in plotter.step)
   138.         with Inline;
   139.
   140.      procedure move_by (this_step : in plotter.step) is
   141.      begin
   142.         -- Convert from natural orientation of X axis to PostScript direction.
   143.         if the_pen_is_down then
   144.            draw_by((-this_step.dx, +this_step.dy));
   145.         else
   146.            jump_by((-this_step.dx, +this_step.dy));
   147.         end if;
   148.      end move_by;
   149.
   150.    begin -- perform
   151.      case action is
   152.         when dummy =>
   153.            null;
   154.         when pen_up =>
   155.            close_any_open_vector(stream);
   156.            the_pen_is_down := False;
   157.         when pen_down =>
   158.            the_pen_is_down := True;
   159.         when go_pY =>
   160.            move_by((+0, +1));
   161.         when go_nY =>
   162.            move_by((+0, -1));
   163.         when go_pX =>
   164.            move_by((+1, +0));
   165.         when go_nX =>
   166.            move_by((-1, +0));
   167.         when go_pXpY =>
   168.            move_by((+1, +1));
   169.         when go_nXnY =>
   170.            move_by((-1, -1));
   171.         when go_pXnY =>
   172.            move_by((+1, -1));
   173.         when go_nXpY =>
   174.            move_by((-1, +1));
   175.         when others =>
   176.            -- EM causes a 'peculiar' motion, according to the Manual, Appendix 5.2, p.303,
   177.            --    and other codes cause 'unpredictable' effects.
   178.            -- ee9 therefore performs an arbitrary, but safe, operation: moving to the origin.
   179.            close_any_open_vector(stream);
   180.            plot_position := the_origin;
   181.      end case;
   182.    end perform;
   183.
   184.    a_plot_is_open : Boolean := False;
   185.
   186.    procedure open_the_plot_file (stream : in out host_IO.stream) is
   187.    begin
   188.      if a_plot_is_open then
   189.         close_the_plot_file(stream);
   190.      end if;
   191.      plot_position := (0,0);
   192.      a_plot_is_open := True;
   193.    end open_the_plot_file;
   194.
   195.    procedure close_the_plot_file (stream : in out host_IO.stream) is
   196.    begin
   197.      if not a_plot_is_open then
   198.         return;
   199.      end if;
   200.      close_any_open_vector(stream);
   201.      a_plot_is_open := False;
   202.    end close_the_plot_file;
   203.
   204. end plotter;

Compiling: ../Source/plotter.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:36

     1. -- plotter.ads
     2. --
     3. -- Emulation of the plotting commands of the Calcomp 564 graph plotter.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with host_IO;
    20. with KDF9_char_sets;
    21.
    22. use  host_IO;
    23.
    24. package plotter is
    25.
    26.    procedure open_the_plot_file (stream : in out host_IO.stream);
    27.
    28.    procedure close_the_plot_file (stream : in out host_IO.stream);
    29.
    30.    type command is new KDF9_char_sets.symbol;
    31.
    32.    -- The KDF9 plotting commands are defined in the Manual, Appendix 6, §5.3, pp. 303-304.
    33.
    34.    -- BUT there is obviously an error in the Manual, as only 9 of the claimed 11 command
    35.    --    codes are listed, and the last, go_nXnY, is coded inconsistently with the others.
    36.
    37.    -- Hypothesis: the table should read as follows:
    38.
    39.    dummy    : constant plotter.command := 2#000_000#;
    40.
    41.    pen_up   : constant plotter.command := 2#100_000#;
    42.    pen_down : constant plotter.command := 2#010_000#;
    43.
    44.    go_pY    : constant plotter.command := 2#001_000#;
    45.    go_nY    : constant plotter.command := 2#000_100#;
    46.    go_pX    : constant plotter.command := 2#000_010#;
    47.    go_nX    : constant plotter.command := 2#000_001#;
    48.
    49.    go_nXnY  : constant plotter.command := go_nX + go_nY;
    50.    go_pXnY  : constant plotter.command := go_pX + go_nY;
    51.    go_nXpY  : constant plotter.command := go_nX + go_pY;
    52.    go_pXpY  : constant plotter.command := go_pX + go_pY;
    53.
    54.    -- These encodings are consistent with the Calcomp plotter command codes used here:
    55.    --     ub.fnwi.uva.nl/computermuseum//calcomp565.html
    56.    -- which defines a full set of 11 commands, two of which are missing from the KDF9 list.
    57.
    58.    is_valid : constant array (plotter.command) of Boolean
    59.             := (dummy    |
    60.                 pen_up   |
    61.                 pen_down |
    62.                 go_pY    |
    63.                 go_nY    |
    64.                 go_pX    |
    65.                 go_nX    |
    66.                 go_pXnY  |
    67.                 go_nXpY  |
    68.                 go_pXpY  |
    69.                 go_nXnY  => True,
    70.                 others   => False
    71.                );
    72.
    73.    procedure perform (action : in plotter.command; stream : in out host_IO.stream);
    74.
    75. end plotter;

 204 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-fast-dr-outs.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:36

     1. -- ioc-fast-dr-outs.adb
     2. --
     3. -- Implement the drum API (OUTs) of the EE Time Sharing Director.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with HCI;
    20. with IOC.dispatcher;
    21. with tracing;
    22.
    23. use  HCI;
    24. use  IOC.dispatcher;
    25. use  tracing;
    26.
    27. package body IOC.fast.DR.OUTs is
    28.
    29.    OUT13_was_done          : Boolean   := False;
    30.    last_reserved_DR_sector : KDF9.word := -1;
    31.
    32.    Q : KDF9.Q_register;
    33.    W : KDF9.word;
    34.
    35.    procedure check_DR_OUT (
    36.                            OUT_number      : in KDF9.word;
    37.                            it_is_erroneous : in Boolean;
    38.                            error_message   : in String
    39.                           ) is
    40.    begin
    41.       if not is_enabled then
    42.          fail_OUT(OUT_number, "there is no drum in this configuration");
    43.       end if;
    44.       if OUT_number /= 14 then
    45.          ensure_that_the_nest_holds_an_operand;
    46.          the_trace_operand := pop;
    47.       end if;
    48.       if it_is_erroneous then
    49.          fail_OUT(OUT_number, error_message);
    50.       end if;
    51.    end check_DR_OUT;
    52.
    53.    procedure prepare_drum_transfer (OUT_number : in KDF9.word) is
    54.    begin
    55.       check_DR_OUT(OUT_number, not OUT13_was_done, "obeyed before drum store reservation");
    56.       Q := as_Q(the_trace_operand);
    57.       W := KDF9.word(Q.C + (Q.M - Q.I + bytes_per_sector/2) / bytes_per_sector);
    58.       if W > last_reserved_DR_sector then
    59.          fail_OUT(OUT_number, "obeyed with wrong parameters that exceed the reservation");
    60.       end if;
    61.       Q := (Q.C*16 + DR0_number, Q.I, Q.M);
    62.    end prepare_drum_transfer;
    63.
    64.    procedure do_TSD_OUT_11 is
    65.    begin
    66.       prepare_drum_transfer(11);
    67.       POA(Q, False);
    68.    end do_TSD_OUT_11;
    69.
    70.    procedure do_TSD_OUT_12 is
    71.    begin
    72.       prepare_drum_transfer(12);
    73.       PIA(Q, False);
    74.    end do_TSD_OUT_12;
    75.
    76.    procedure do_TSD_OUT_13 is
    77.    begin
    78.       check_DR_OUT(13, OUT13_was_done, "obeyed a second time");
    79.       W := the_trace_operand;
    80.       if W > sectors_per_system or else
    81.             W = 0                       then
    82.          fail_OUT(13, "asks for an impossible number of sectors");
    83.       end if;
    84.       last_reserved_DR_sector := W - 1;
    85.       OUT13_was_done := True;
    86.       set_state_of(buffer(DR0_number), allocated => True);
    87.       log_API_message("OUT 13: allocated" & W'Image & " drum sectors");
    88.    end do_TSD_OUT_13;
    89.
    90.    procedure do_TSD_OUT_14 is
    91.    begin
    92.       check_DR_OUT(14, False, "");
    93.       if OUT13_was_done then
    94.          push((sectors_per_system - last_reserved_DR_sector - 1) or 2**47);
    95.       else
    96.          push(sectors_per_system);
    97.       end if;
    98.       -- I assume that the drum never experiences a parity error in ee9.
    99.    end do_TSD_OUT_14;
   100.
   101. end IOC.fast.DR.OUTs;

Compiling: ../Source/ioc-fast-dr-outs.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:36

     1. -- ioc-fast-dr-outs.ads
     2. --
     3. -- Implement the drum API (OUTs) of the EE Time Sharing Director.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.fast.DR.OUTs is
    20.
    21.    procedure do_TSD_OUT_11;
    22.
    23.    procedure do_TSD_OUT_12;
    24.
    25.    procedure do_TSD_OUT_13;
    26.
    27.    procedure do_TSD_OUT_14;
    28.
    29. end IOC.fast.DR.OUTs;

 101 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-fast-fd-outs.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:37

     1. -- ioc.fast-fd-outs.adb
     2. --
     3. -- Implement the fixed disc API (OUTs) of the EE Time Sharing Director.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with HCI;
    20. with IOC.dispatcher;
    21. with tracing;
    22.
    23. use  HCI;
    24. use  IOC.dispatcher;
    25. use  tracing;
    26.
    27. package body IOC.fast.FD.OUTs is
    28.
    29.    -- See the Manual, Appendix 6, §2 for the TSD FD OUTs.
    30.
    31.    claimable_discs              : constant := 8;
    32.    sectors_per_logical_block    : constant := 16;
    33.    logical_blocks_per_seek_area : constant := sectors_per_seek_area / sectors_per_logical_block;
    34.    logical_blocks_per_platter   : constant := seek_areas_per_platter * logical_blocks_per_seek_area;
    35.    sectors_per_platter          : constant := sectors_per_logical_block * logical_blocks_per_platter;
    36.
    37.    type reserved_disc_set is
    38.       record
    39.          claimed : Boolean := False;
    40.          size    : KDF9.Q_part range 0 .. claimable_discs;
    41.          sectors : KDF9.Q_part range 0 .. claimable_discs * sectors_per_platter;
    42.          start   : KDF9.Q_part range 0 .. claimable_discs;
    43.       end record;
    44.
    45.    disc_set             : array (KDF9.Q_part range 1 .. 2) of reserved_disc_set;
    46.    disc_sets_claimed    : KDF9.Q_part range 0 .. 2 := 0;
    47.    current_disc_set     : KDF9.Q_part range 1 .. 2;
    48.    discs_claimed_so_far : KDF9.Q_part := 0;
    49.
    50.    function FD_seek_parameter (OUT_number: KDF9.word; Q : KDF9.Q_register)
    51.    return KDF9.Q_register is
    52.       current_set : reserved_disc_set renames disc_set(current_disc_set);
    53.       block       : constant KDF9.Q_part := Q.C / sectors_per_logical_block;
    54.       seek_area   : constant KDF9.Q_part := block  /  (6 * current_set.size);
    55.       residue     : constant KDF9.Q_part := block mod (6 * current_set.size);
    56.       disc        : constant KDF9.Q_part := residue / 6 + current_set.start;
    57.       drive       : constant KDF9.Q_part := 0;  -- ee9 will reserve discs on drive 0 only.
    58.       parameter   : constant KDF9.Q_part
    59.                   := drive * seek_areas_per_platter * main_discs_per_drive
    60.                    + disc  * seek_areas_per_platter
    61.                    + seek_area;
    62.    begin
    63.       if Q.C >= disc_set(current_disc_set).sectors then
    64.          fail_OUT(OUT_number, Q.C'Image & " exceeds the sector capacity of the selected set");
    65.       end if;
    66.       return (parameter * 16 + FD0_number,  Q.I, Q.M);
    67.    end FD_seek_parameter;
    68.
    69.    function FD_xfer_parameter (Q : KDF9.Q_register)
    70.    return KDF9.Q_register is
    71.       sector : constant KDF9.Q_part := Q.C mod 96;
    72.    begin
    73.       return (sector * 16 + FD0_number, Q.I, Q.M);
    74.    end FD_xfer_parameter;
    75.
    76.    F : KDF9.Q_part;
    77.    Q : KDF9.Q_register;
    78.    W : KDF9.word;
    79.
    80.    procedure check_FD_OUT (
    81.                            OUT_number       : in KDF9.word;
    82.                            operand_message  : in String;
    83.                            it_is_erroneous  : in Boolean;
    84.                            second_message   : in String;
    85.                            second_test_only : in Boolean := False
    86.                           ) is
    87.    begin
    88.       if not is_enabled then
    89.          fail_OUT(OUT_number, "FD0 is not included in this configuration");
    90.       end if;
    91.       ensure_that_the_nest_holds_an_operand;
    92.       the_trace_operand := pop;
    93.       if the_trace_operand not in 0 | -1 and not second_test_only then
    94.          fail_OUT(OUT_number, operand_message);
    95.       end if;
    96.       if it_is_erroneous then
    97.          fail_OUT(OUT_number, second_message);
    98.       end if;
    99.       W := the_trace_operand;
   100.       Q := as_Q(W);
   101.    end check_FD_OUT;
   102.
   103.    procedure do_TSD_OUT_41 is
   104.    begin
   105.       check_FD_OUT(
   106.                    41,
   107.                    "",
   108.                    disc_sets_claimed = 0,
   109.                    "tries to write to unreserved FD0 discs",
   110.                    second_test_only => True
   111.                   );
   112.       W := KDF9.word(Q.C) / 16;
   113.       F := Q.C mod 16 + (Q.M - Q.I + words_per_sector - 1)/words_per_sector;
   114.       if F >= sectors_per_logical_block then
   115.          fail_OUT(41, "tries to write past the end of a logical block on FD0");
   116.       end if;
   117.       PMA(FD_seek_parameter(41, Q), False);
   118.       POA(FD_xfer_parameter(Q), False);
   119.    end do_TSD_OUT_41;
   120.
   121.    procedure do_TSD_OUT_42 is
   122.    begin
   123.       check_FD_OUT(
   124.                    42,
   125.                    "",
   126.                    disc_sets_claimed = 0,
   127.                    "tries to read from unreserved FD0 discs",
   128.                    second_test_only => True
   129.                   );
   130.       W := KDF9.word(Q.C) / 16;
   131.       F := Q.C mod 16 + (Q.M - Q.I + words_per_sector - 1)/words_per_sector;
   132.       if F >= sectors_per_logical_block then
   133.          fail_OUT(42, "tries to read past the end of a logical block on FD0");
   134.       end if;
   135.       PMA(FD_seek_parameter(42, Q), False);
   136.       PIA(FD_xfer_parameter(Q), False);
   137.    end do_TSD_OUT_42;
   138.
   139.    procedure do_TSD_OUT_43 is
   140.    begin
   141.       check_FD_OUT(
   142.                    43,
   143.                    "tries to select an impossible set of discs",
   144.                    disc_sets_claimed = 0,
   145.                    "no FD0 discs have been reserved yet"
   146.                   );
   147.       W := -the_trace_operand;
   148.       F := as_Q(W).M + 1;
   149.       if F > disc_sets_claimed then
   150.          fail_OUT(45, "tries to select an unreserved FD0 disc set");
   151.       end if;
   152.       current_disc_set := as_Q(-the_trace_operand).M + 1;
   153.    end do_TSD_OUT_43;
   154.
   155.    procedure do_TSD_OUT_44 is
   156.    begin
   157.       check_FD_OUT(
   158.                    44,
   159.                    "",
   160.                    disc_sets_claimed = 2,
   161.                    "tries to reserve more than two sets of FD0 discs",
   162.                    second_test_only => True
   163.                   );
   164.       F := as_Q(W).M;
   165.       if W not in 1..claimable_discs                           or else
   166.             discs_claimed_so_far + F not in 1..claimable_discs then
   167.          fail_OUT(44, "tries to reserve more than 8 FD0 discs");
   168.       end if;
   169.       current_disc_set := disc_sets_claimed + 1;
   170.       disc_set(current_disc_set).claimed := True;
   171.       disc_set(current_disc_set).size := F;
   172.       disc_set(current_disc_set).sectors := F * sectors_per_platter;
   173.       disc_set(current_disc_set).start := discs_claimed_so_far;
   174.       discs_claimed_so_far := discs_claimed_so_far + F;
   175.       disc_sets_claimed := disc_sets_claimed + 1;
   176.       log_API_message(
   177.                       "OUT 44: reserved"
   178.                     & F'Image
   179.                     & " FD0 disc"
   180.                     & plurality(KDF9.word(F))
   181.                     & " in set"
   182.                     & current_disc_set'Image
   183.                      );
   184.       set_state_of(buffer(FD0_number), allocated => True);
   185.    end do_TSD_OUT_44;
   186.
   187.    procedure do_TSD_OUT_45 is
   188.    begin
   189.       check_FD_OUT(
   190.                    45,
   191.                    "tries to release an unknown set of FD0 discs",
   192.                    disc_sets_claimed = 0,
   193.                    "tries to release an unreserved set of FD0 discs"
   194.                   );
   195.       W := -W;
   196.       F := as_Q(W).M + 1;
   197.       if F > disc_sets_claimed then
   198.          fail_OUT(45, "tries to release more FD0 disc sets than are reserved");
   199.       end if;
   200.       log_API_message(
   201.                       "OUT 45: released"
   202.                     & disc_set(F).size'Image
   203.                     & " FD0 disc"
   204.                     & plurality(KDF9.word(disc_set(F).size))
   205.                     & " from set"
   206.                     & F'Image
   207.                      );
   208.       discs_claimed_so_far := discs_claimed_so_far - disc_set(F).size;
   209.       current_disc_set := 1;
   210.       disc_sets_claimed := disc_sets_claimed - 1;
   211.       if F = 1 then
   212.          disc_set(1) := disc_set(2);
   213.          disc_set(2).claimed := False;
   214.       end if;
   215.    end do_TSD_OUT_45;
   216.
   217. end IOC.fast.FD.OUTs;

Compiling: ../Source/ioc-fast-fd-outs.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:37

     1. -- ioc.fast-fd-outs.ads
     2. --
     3. -- Implement the fixed disc API (OUTs) of the EE Time Sharing Director.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.fast.FD.OUTs is
    20.
    21.    -- See the Manual, Appendix 6, §2 for the TSD FD OUTs.
    22.
    23.    procedure do_TSD_OUT_41;
    24.
    25.    procedure do_TSD_OUT_42;
    26.
    27.    procedure do_TSD_OUT_43;
    28.
    29.    procedure do_TSD_OUT_44;
    30.
    31.    procedure do_TSD_OUT_45;
    32.
    33. end IOC.fast.FD.OUTs;

 217 lines: No errors

GNAT Community 2020 (20200429-84)
Copyright 1992-2020, Free Software Foundation, Inc.


Compiling: /Users/wf/KDF9/emulation/Source/ioc-fast-mt-outs.adb
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:37

     1. -- ioc-fast-mt-outs.adb
     2. --
     3. -- Emulation of magnetic tape decks and buffers.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with HCI;
    20. with tracing;
    21.
    22. use  HCI;
    23. use  tracing;
    24.
    25. package body IOC.fast.MT.OUTs is
    26.
    27.    type short_label is new String(1 .. 8);
    28.    type long_label  is new String(1 .. 16);
    29.
    30.    function needs_rewinding (b : KDF9.buffer_number)
    31.    return Boolean is
    32.       the_deck : MT.deck renames MT.deck(buffer(b).all);
    33.    begin
    34.       return the_deck.is_open and then the_deck.tape.position > 0;
    35.    end needs_rewinding;
    36.
    37.    procedure do_TSD_OUT_4 is
    38.       B : KDF9.Q_part;
    39.       W : KDF9.word;
    40.    begin
    41.       ensure_that_the_nest_holds_an_operand;
    42.       W := pop;
    43.       declare
    44.          label : constant short_label := short_label(to_string(W));
    45.       begin
    46.          find_tape(MT.data_storage(label), B, W, "OUT 4");  -- W is not actually used in OUT 4
    47.          push(KDF9.word(B));
    48.          the_trace_operand := KDF9.word(B);
    49.          if W = 0 then
    50.             log_API_message("OUT 4: requested a scratch tape and got '"
    51.                           & device_name_of(buffer(B).all)
    52.                           & "' with TSN '"
    53.                           & to_string(W)
    54.                           & "'"
    55.                            );
    56.          else
    57.             log_API_message("OUT 4: requested a tape labelled '"
    58.                           & String(label)
    59.                           & "' and got "
    60.                           & device_name_of(buffer(B).all)
    61.                           & " with TSN '"
    62.                           & to_string(W)
    63.                           & "'"
    64.                            );
    65.          end if;
    66.       end;
    67.       set_state_of(buffer(B), allocated => True);
    68.    end do_TSD_OUT_4;
    69.
    70.    procedure do_TSD_OUT_10 is
    71.       B : KDF9.Q_part;
    72.       P : KDF9.pair;
    73.       W : KDF9.word;
    74.    begin
    75.       ensure_that_the_nest_holds_2_operands;
    76.       P := pop;
    77.       declare
    78.          label : constant long_label := long_label(to_string(P));
    79.       begin
    80.          find_tape(MT.data_storage(label), B, w, "OUT 10");
    81.          push(W);
    82.          push(KDF9.word(B));
    83.          the_trace_operand := KDF9.word(B);
    84.          log_API_message("OUT 10: requested a tape labelled '"
    85.                        & String(label)
    86.                        & "' and got "
    87.                        & device_name_of(buffer(B).all)
    88.                        & " with TSN '"
    89.                        & to_string(W)
    90.                        & "'"
    91.                         );
    92.       end;
    93.       set_state_of(buffer(B), allocated => True);
    94.    end do_TSD_OUT_10;
    95.
    96. end IOC.fast.MT.OUTs;

Compiling: ../Source/ioc-fast-mt-outs.ads
Source file time stamp: 2020-12-29 23:49:43
Compiled at: 2020-12-30 00:11:37

     1. -- ioc-fast-mt-outs.ads
     2. --
     3. -- Implement the magnetic tape API (OUTs) of the EE Time Sharing Director.
     4. --
     5. -- This file is part of ee9 (V5.2b), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2021, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. package IOC.fast.MT.OUTs is
    20.
    21.    procedure do_TSD_OUT_4;
    22.
    23.    procedure do_TSD_OUT_10;
    24.
    25.    function needs_rewinding (b : KDF9.buffer_number)
    26.    return Boolean;
    27.
    28. end IOC.fast.MT.OUTs;

 96 lines: No errors
