Version V9p0p of ee9 for Linux, built on Thu 15 Sep 2022 03:07:59 PM BST.
mk9 'ee9' build: optimised and with full language checks, using configuration options:

pragma Restrictions(No_Abort_Statements);
pragma Restrictions(No_Implementation_Attributes);
pragma Restrictions(No_Implementation_Restrictions);
pragma Restrictions(No_Obsolescent_Features);
pragma Assertion_Policy(Ignore);
pragma Check_Policy(Debug, Off);
pragma Optimize_Alignment(Time);
pragma Unsuppress(All_Checks);
pragma Validity_Checks(Off);

Using the build command:
gnatmake -aI../Source -aO../Build -funwind-tables -gnatl12j96 -gnatw.e -gnatwD -gnatwH -gnatwP -gnatwT -gnatw.W -gnatw.B -gnatwC -gnatw.u -gnatyO -gnatw.Y -gnatw.N -fdata-sections -ffunction-sections -gnatfn -mtune=native -O3 -flto -j0 ee9 -bargs -static -largs -Wl,--gc-sections -Wl,--as-needed -flto

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ee9.adb
Source file time stamp: 2022-09-06 15:35:28
Compiled at: 2022-09-15 15:07:59

     1. -- This is the "main program" for the entire emulator.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with GNAT.Source_Info;
    18. --
    19. with Ada.Text_IO;
    20. with Ada.Command_Line;
    21. with Ada.Exceptions;
    22. --
    23. with exceptions;
    24. with HCI;
    25. with IOC.equipment;
    26. with IOC.slow.shift.TP;
    27. with IOC.slow.shift.TR;
    28. with settings;
    29. with string_editing;
    30.
    31. with execute;
    32. with say_goodbye;
    33.
    34. use  Ada.Text_IO;
    35. use  Ada.Exceptions;
    36. --
    37. use  exceptions;
    38. use  HCI;
    39. use  IOC.equipment;
    40. use  settings;
    41. use  string_editing;
    42.
    43. procedure ee9 is
    44.
    45.    package CLI renames Ada.Command_Line;
    46.
    47.    the_log_file_name : constant String := "KDF9_log.txt";
    48.
    49.    a_command_line_error_is_detected : exception;
    50.
    51.    procedure show_proper_usage (message : in String := "") is
    52.    begin
    53.       if message /= "" then
    54.          log_line(message);
    55.       end if;
    56.       log_line(
    57.                "usage: ee9 { [ -s{b|p|t} ] | [ -d{f|p|t|x|-} ] | [ -m"
    58.              & miscellany_prompt
    59.              & " ] [ -TP{k|l}{k|l} ] [ -TR{k|l}{k|l} ] } +program_file_name"
    60.               );
    61.       CLI.Set_Exit_Status(CLI.Failure);
    62.       raise a_command_line_error_is_detected;
    63.    end show_proper_usage;
    64.
    65.    procedure complain (about : in String; because : in String := "") is
    66.    begin
    67.       show_proper_usage(
    68.                         "Parameter" + abs about & "is not valid"
    69.                       & (if because = "" then "." else " because " & because & ".")
    70.                        );
    71.    end complain;
    72.
    73.    the_program_name_position : Natural := 0;
    74.
    75.    procedure check_all_flag_settings is
    76.
    77.       procedure check_flag_setting (i : in Positive) is
    78.
    79.          subtype tape_code_flags is Character
    80.             with Predicate => tape_code_flags in 'K' | 'L' | 'k' | 'l';
    81.
    82.          subtype tape_device_flags is Character
    83.             with Predicate => tape_device_flags in 'P' | 'R' |'p' | 'r';
    84.
    85.          argument : constant String   := CLI.Argument(i);
    86.          index    : constant Positive := argument'First;
    87.
    88.       begin
    89.          -- Ignore an empty parameter.
    90.          if argument'Length = 0 then
    91.             return;
    92.          end if;
    93.
    94.          -- Take note of a program name parameter.
    95.          if argument(index) = '+' then
    96.             if the_program_name_position /= 0 then
    97.                complain(about   => argument,
    98.                         because => "more than one program has been specified");
    99.             end if;
   100.             if argument'Length < 3 then
   101.                complain(about   => argument,
   102.                         because => "it is too short for a program file name");
   103.             end if;
   104.             the_program_name_position := i;
   105.             return;
   106.          end if;
   107.
   108.          -- Fail any non-flag parameter.
   109.          if argument(index) /= '-'  then
   110.             complain(about => argument);
   111.          end if;
   112.
   113.          -- Fail a too-short flag parameter.
   114.          if argument'Length < 2 then
   115.             complain(about   => argument,
   116.                      because => "it is too short");
   117.          end if;
   118.
   119.          -- Check for a miscellany parameter.
   120.          if argument'Length in 2 .. miscellany_flags'Length+2 and then
   121.                argument(index..index+1) = "-m"                    then
   122.             for i in index+2 .. argument'Last loop
   123.                if is_invalid_miscellany_flag(argument(i)) then
   124.                   complain(about => argument);
   125.                end if;
   126.             end loop;
   127.             return;
   128.          end if;
   129.
   130.          -- Check for a state or diagnostic parameter.
   131.          if argument in "-sb" | "-sp" | "-st" | "-df" | "-dt" | "-dp" | "-dx" | "-d-" then
   132.             return;
   133.          end if;
   134.
   135.          -- Check for a Tape Punch/Reader parameter.
   136.          if argument'Length in 4 .. 5                    and then
   137.                argument(index+1) in 'T' | 't'            and then
   138.                   argument(index+2) in tape_device_flags and then
   139.                      argument(index+3) in tape_code_flags    then
   140.             if argument'Length = 4                  or else
   141.                   argument(index+4) in tape_code_flags then
   142.                return;
   143.             end if;
   144.          end if;
   145.
   146.          complain(about => argument);
   147.
   148.       end check_flag_setting;
   149.
   150.    begin -- check_all_flag_settings
   151.       for i in 1..CLI.Argument_Count loop
   152.          check_flag_setting(i);
   153.       end loop;
   154.       if the_program_name_position = 0 then
   155.          show_proper_usage("No program name parameter was given.");
   156.       end if;
   157.    end check_all_flag_settings;
   158.
   159.    procedure impose_all_flag_settings is
   160.
   161.       procedure impose_flag_setting (i : in Positive) is
   162.
   163.          subtype Latin_1_code_flags is Character
   164.             with Predicate => Latin_1_code_flags in 'L' | 'l';
   165.
   166.          subtype punch_device_flags is Character
   167.             with Predicate => punch_device_flags in 'P' |'p';
   168.
   169.          argument : constant String   := CLI.Argument(i);
   170.          index    : constant Positive := argument'First;
   171.
   172.       begin -- impose_flag_setting
   173.          -- Ignore an empty parameter.
   174.          if argument'Length = 0 then
   175.             return;
   176.          end if;
   177.
   178.          -- Ignore a program_file_name parameter.
   179.          if argument(index) = '+'  then
   180.             return;
   181.          end if;
   182.
   183.          -- Impose a miscellany parameter.
   184.          if argument'Length in 2 .. miscellany_flags'Length+2 and then
   185.                argument(index..index+1) = "-m"  then
   186.             for i in index+2 .. argument'Last loop
   187.                set_this_miscellany_flag(argument(i));
   188.             end loop;
   189.             return;
   190.          end if;
   191.
   192.          -- Impose  a Tape Punch/Reader parameter.
   193.          if argument'Length in 4 .. 5 then
   194.             -- Set the code for the first device.
   195.             if argument(index+2) in punch_device_flags then
   196.                IOC.slow.shift.TP.set_unit_code(0, argument(index+3) in Latin_1_code_flags);
   197.             else
   198.                IOC.slow.shift.TR.set_unit_code(0, argument(index+3) in Latin_1_code_flags);
   199.             end if;
   200.          end if;
   201.          if argument'Length = 5 then
   202.             -- Set the code for the second device.
   203.             if argument(index+2) in punch_device_flags then
   204.                IOC.slow.shift.TP.set_unit_code(1, argument(index+4) in Latin_1_code_flags);
   205.             else
   206.                IOC.slow.shift.TR.set_unit_code(1, argument(index+4) in Latin_1_code_flags);
   207.             end if;
   208.          end if;
   209.
   210.          -- Impose a state or diagnostic parameter; argument is known to be 3 characters long.
   211.          if    argument = "-sb" then
   212.             set_execution_mode(boot_mode);
   213.          elsif argument = "-sp" then
   214.             set_execution_mode(program_mode);
   215.          elsif argument = "-st" then
   216.             set_execution_mode(privileged_mode);
   217.          elsif argument = "-d-" then
   218.             set_diagnostic_mode(fast_mode);
   219.          elsif argument = "-df" then
   220.             set_diagnostic_mode(fast_mode);
   221.          elsif argument = "-dt" then
   222.             set_diagnostic_mode(trace_mode);
   223.          elsif argument = "-dp" then
   224.             set_diagnostic_mode(pause_mode);
   225.          elsif argument = "-dx" then
   226.             set_diagnostic_mode(external_mode);
   227.          end if;
   228.       end impose_flag_setting;
   229.
   230.    begin -- impose_all_flag_settings
   231.       if CLI.Argument_Count = 0 then
   232.          return;
   233.       end if;
   234.       for i in 1..CLI.Argument_Count loop
   235.          impose_flag_setting(i);
   236.       end loop;
   237.    end impose_all_flag_settings;
   238.
   239.    function name_part_of (f : String)
   240.    return String
   241.    is (f(f'First+1 .. f'Last));
   242.
   243.    function the_program_name
   244.    return String
   245.    is (name_part_of(CLI.Argument(the_program_name_position)));
   246.
   247. begin -- ee9
   248.
   249.    check_all_flag_settings;
   250.    open(the_log_file_name);
   251.    get_settings_from_file("1");
   252.    configure_the_IOC;
   253.    impose_all_flag_settings;
   254.    revise_the_IOC_configuration;
   255.    log_line(
   256.             "This is ee9 9.0p, compiled by "
   257.           & Standard'Compiler_Version
   258.           & " on "
   259.           & GNAT.Source_Info.Compilation_ISO_Date
   260.           & ".",
   261.             iff => the_log_is_wanted
   262.            );
   263.
   264.    display_execution_modes(the_program_name);
   265.    execute(the_program_name);
   266.
   267.    close; -- the log file
   268.
   269. exception
   270.
   271.    when a_command_line_error_is_detected =>
   272.       close; -- the log file
   273.
   274.    when diagnostic : operator_error =>
   275.       say_goodbye("The KDF9 operator has made a mistake", Exception_Message(diagnostic));
   276.
   277.    when error : others =>
   278.       Put_Line(Standard_Error, "Failure in ee9: " & Exception_Information(error) & ".");
   279.       close; -- the log file
   280.       CLI.Set_Exit_Status(CLI.Failure);
   281.
   282. end ee9;

 282 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/hci.adb
Source file time stamp: 2022-09-06 15:33:49
Compiled at: 2022-09-15 15:07:59

     1. -- Provide operations supporting replicated human-readable output:
     2. --    1: to an interactive user interface for transient display, and
     3. --    2: to a file for persistent storage.
     4. -- If no file has been opened, or if it has been explicitly closed,
     5. --    output is to the interactive interface only.
     6. --
     7. -- Also provide operations allowing synchronization with the user.
     8. --
     9. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
    10. -- Copyright (C) 2022, W. Findlay; all rights reserved.
    11. --
    12. -- The ee9 program is free software; you can redistribute it and/or
    13. -- modify it under terms of the GNU General Public License as published
    14. -- by the Free Software Foundation; either version 3, or (at your option)
    15. -- any later version. This program is distributed in the hope that it
    16. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    17. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    18. -- See the GNU General Public License for more details. You should have
    19. -- received a copy of the GNU General Public License distributed with
    20. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    21. --
    22.
    23. with generic_logger;
    24. with settings;
    25.
    26. use  settings;
    27.
    28. package body HCI is
    29.
    30.    package log_manager is new generic_logger(max_logger_list_size => 2);
    31.
    32.    cc_list : log_manager.replicator;
    33.
    34.    procedure tab_log (at_least : in Natural;
    35.                       spacing  : in Positive := 6;
    36.                       iff      : in Boolean := True) is
    37.    begin
    38.       cc_list.tab_log(at_least, spacing, iff);
    39.    end tab_log;
    40.
    41.    procedure tab_log_to (column : in Positive;
    42.                          iff    : in Boolean := True) is
    43.    begin
    44.       cc_list.tab_log_to(column, iff);
    45.    end tab_log_to;
    46.
    47.    procedure log (char : in Character;
    48.                   iff  : in Boolean := True) is
    49.    begin
    50.       cc_list.log(char, iff);
    51.    end log;
    52.
    53.    procedure log (text : in String;
    54.                   iff  : in Boolean := True) is
    55.    begin
    56.       cc_list.log(text, iff);
    57.    end log;
    58.
    59.    procedure log_line (text : in String;
    60.                        iff  : in Boolean := True) is
    61.    begin
    62.       if text /= "" then
    63.          cc_list.log(text, iff);
    64.       end if;
    65.       log_new_line(iff);
    66.    end log_line;
    67.
    68.    procedure log_new_line (iff : in Boolean := True) is
    69.    begin
    70.       cc_list.log_new_line(iff);
    71.    end log_new_line;
    72.
    73.    procedure log_rule (start_a_new_line : in Boolean := False;
    74.                        iff              : in Boolean := True) is
    75.    begin
    76.        if start_a_new_line then
    77.           cc_list.log_new_line(iff);
    78.        end if;
    79.        log_line(String'(1..80 => '_'), iff);
    80.    end log_rule;
    81.
    82.    procedure log_message (message : in String) is
    83.    begin
    84.       cc_list.log(message);
    85.       cc_list.log_new_line;
    86.    end log_message;
    87.
    88.    procedure log_title (message : in String) is
    89.    begin
    90.       cc_list.log_new_line;
    91.       cc_list.log(message);
    92.       cc_list.log_new_line;
    93.    end log_title;
    94.
    95.    procedure log_ee9_status (message  : in String;
    96.                              skip     : in Natural := 0;
    97.                              complete : in Boolean := True;
    98.                              iff      : in Boolean := True) is
    99.    begin
   100.       if not iff then return; end if;
   101.       panel_logger.tab_log_to(1);
   102.       for i in 1 .. skip loop
   103.          log_new_line;
   104.       end loop;
   105.       if complete then
   106.          log_line("ee9: " & message & ".");
   107.       else
   108.          log("ee9: " & message);
   109.       end if;
   110.    end log_ee9_status;
   111.
   112.    procedure log_API_message (message  : in String;
   113.                               skip     : in Natural := 1) is
   114.    begin
   115.       if API_logging_is_wanted then
   116.          log_ee9_status(message, skip, True);
   117.       end if;
   118.    end log_API_message;
   119.
   120.    procedure show_line (message : in String) is
   121.    begin
   122.       if debugging_is_enabled then
   123.          panel_logger.show_line(message);
   124.          flush;
   125.       end if;
   126.    end show_line;
   127.
   128.    procedure interact (reason : in String := "Mode") is
   129.    begin
   130.       panel_logger.interact(reason);
   131.    end interact;
   132.
   133.    procedure open (logfile_name : in String) is
   134.    begin
   135.       cc_list.open(logfile_name);
   136.    end open;
   137.
   138.    procedure close is
   139.    begin
   140.       cc_list.close;
   141.    end close;
   142.
   143.    procedure flush (iff : in Boolean := True) is
   144.    begin
   145.       cc_list.flush(iff);
   146.    end flush;
   147.
   148.    procedure log_to_file (message : in String) is
   149.    begin
   150.       file_logger.log(message);
   151.       file_logger.log_new_line;
   152.    end log_to_file;
   153.
   154. begin
   155.    cc_list.set_logger_list((file_logger'Access, panel_logger'Access));
   156. end HCI;

Compiling: ../Source/hci.ads
Source file time stamp: 2022-09-06 15:33:36
Compiled at: 2022-09-15 15:07:59

     1. -- Provide operations supporting replicated human-readable output:
     2. --    1: to an interactive user interface for transient display, and
     3. --    2: to a file for persistent storage.
     4. -- If no file has been opened, or if it has been explicitly closed,
     5. --    output is to the interactive interface only.
     6. --
     7. -- Also provide operations allowing synchronization with the user.
     8. --
     9. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
    10. -- Copyright (C) 2022, W. Findlay; all rights reserved.
    11. --
    12. -- The ee9 program is free software; you can redistribute it and/or
    13. -- modify it under terms of the GNU General Public License as published
    14. -- by the Free Software Foundation; either version 3, or (at your option)
    15. -- any later version. This program is distributed in the hope that it
    16. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    17. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    18. -- See the GNU General Public License for more details. You should have
    19. -- received a copy of the GNU General Public License distributed with
    20. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    21. --
    22.
    23. with logging.file;
    24. with logging.panel;
    25.
    26. use  logging.file;
    27. use  logging.panel;
    28.
    29. package HCI is
    30.
    31.    file_logger  : aliased logging.file.output;
    32.    panel_logger : aliased logging.panel.display;
    33.
    34.    procedure tab_log (at_least : in Natural;
    35.                       spacing  : in Positive := 6;
    36.                       iff      : in Boolean := True);
    37.
    38.    procedure tab_log_to (column : in Positive;
    39.                          iff    : in Boolean := True);
    40.
    41.    procedure log (char : in Character;
    42.                   iff  : in Boolean := True);
    43.
    44.    procedure log (text : in String;
    45.                   iff  : in Boolean := True);
    46.
    47.    procedure log_line (text : in String;
    48.                        iff  : in Boolean := True);
    49.
    50.    procedure log_new_line (iff : in Boolean := True);
    51.
    52.    procedure log_rule (start_a_new_line : in Boolean := False;
    53.                        iff              : in Boolean := True);
    54.
    55.    procedure log_message (message : in String);
    56.
    57.    procedure log_title (message : in String);
    58.
    59.    procedure log_ee9_status (message  : in String;
    60.                              skip     : in Natural := 0;
    61.                              complete : in Boolean := True;
    62.                              iff      : in Boolean := True);
    63.
    64.    procedure log_API_message (message  : in String;
    65.                               skip     : in Natural := 1);
    66.
    67.    procedure show_line (message : in String);
    68.
    69.    procedure interact (reason : in String := "Mode");
    70.
    71.    procedure open  (logfile_name : in String);
    72.
    73.    procedure close;
    74.
    75.    procedure flush (iff : in Boolean := True);
    76.
    77.    procedure log_to_file (message : in String);
    78.
    79. end HCI;

 156 lines: No errors


Compiling: /home/parallels/emulation/Source/execute.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:07:59

     1. -- This is the emulation-mode coordinate module.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with GNAT.Ctrl_C;
    18. --
    19. with Ada.Command_Line;
    20. with Ada.Exceptions;
    21. --
    22. with break_in;
    23. with dumping;
    24. with exceptions;
    25. with HCI;
    26. with IOC.slow.shift.TR;
    27. with KDF9;
    28. with KDF9.microcode;
    29. with settings;
    30. with state_display;
    31.
    32. with say_goodbye;
    33.
    34. use  Ada.Command_Line;
    35. use  Ada.Exceptions;
    36. --
    37. use  dumping;
    38. use  exceptions;
    39. use  HCI;
    40. use  IOC.slow.shift.TR;
    41. use  KDF9;
    42. use  KDF9.microcode;
    43. use  settings;
    44. use  state_display;
    45.
    46. procedure execute (program_name : in String) is
    47.
    48.    procedure check_times_and_modes
    49.       with Inline;
    50.
    51.    pause_count : KDF9.order_counter := 0;
    52.
    53.    procedure check_times_and_modes is
    54.    begin
    55.       if ICR > pause_count then
    56.          if ICR >= time_limit then
    57.             raise time_expired;
    58.          end if;
    59.          pause_count := pause_count + time_slice;
    60.          change_diagnostic_mode_if_requested;
    61.       end if;
    62.    end check_times_and_modes;
    63.
    64. begin  -- execute
    65.    GNAT.Ctrl_C.Install_Handler(break_in.note_user_interrupt'Access);
    66.
    67.    if the_external_trace_is_enabled then
    68.       log_an_external_trace_header;
    69.    end if;
    70.
    71.    case the_execution_mode is
    72.       when boot_mode =>
    73.          reset_the_internal_registers(Director_state);
    74.       when privileged_mode=>
    75.          reset_the_internal_registers(Director_state);
    76.       when program_mode =>
    77.          reset_the_internal_registers(program_state);
    78.    end case;
    79.
    80.    case the_execution_mode is
    81.       when boot_mode =>
    82.          if this_is_a_bare_Director then
    83.             load_a_bare_Director(program_name);
    84.          else
    85.             boot_the_KDF9(program_name);
    86.          end if;
    87.       when privileged_mode=>
    88.          load_a_program(program_name);
    89.       when program_mode =>
    90.          load_a_program(program_name);
    91.    end case;
    92.
    93.    case the_execution_mode is
    94.       when boot_mode =>
    95.          if this_is_a_bare_Director then
    96.             reset_the_CPU_state((4, 0));
    97.          else
    98.             reset_the_CPU_state((0, 0));
    99.          end if;
   100.       when others =>
   101.          reset_the_CPU_state((0, 0));
   102.    end case;
   103.
   104.    if not loading_was_successful then
   105.       say_goodbye("Could not load the specified program.");
   106.       return;
   107.    end if;
   108.
   109.    poke_all_amendments;
   110.    show_all_prerun_dump_areas;
   111.
   112.    if do_not_execute then
   113.       log_new_line;
   114.       log_line("Run abandoned as requested.");
   115.       return;
   116.    end if;
   117.
   118. execution_loop:
   119.    loop
   120.
   121.       begin
   122.
   123.          check_times_and_modes;
   124.          if the_diagnostic_mode /= fast_mode then
   125.             -- Do a single, traced instruction, breaking-in conditionally.
   126.             do_a_traced_instruction_cycle;
   127.          else
   128.             -- Fast mode is designed for minimal overhead;
   129.             --    it interacts with the user only at the end of a time slice.
   130.             loop
   131.                do_a_fast_time_slice;
   132.                check_times_and_modes;
   133.             end loop;
   134.          end if;
   135.
   136.       exception  -- handler for execution_loop
   137.
   138.          when mode_change_request =>
   139.             quit_if_requested;
   140.             if do_not_execute then
   141.                log_new_line;
   142.                log_line("Run abandoned as requested.");
   143.                return;
   144.             end if;
   145.
   146.          when abandon_this_order =>
   147.             null;  -- Just get on with it after an interrupt or nullified order.
   148.
   149.          when LOV_exception =>
   150.             IOC.handle_a_main_store_lockout;
   151.
   152.          when program_exit =>
   153.             say_goodbye("", status => Success);
   154.             exit execution_loop;
   155.
   156.          when time_expired =>
   157.             say_goodbye("Infinite loop? Run failed by exceeding the time limit");
   158.             exit execution_loop;
   159.
   160.          when diagnostic : NOUV_exception =>
   161.             say_goodbye("NOUV interrupt", Exception_Message(diagnostic));
   162.             exit execution_loop;
   163.
   164.          when input_is_impossible =>
   165.             say_goodbye("Noninteractive mode; cannot respond to a prompt");
   166.             exit execution_loop;
   167.
   168.          when diagnostic : not_yet_implemented =>
   169.             say_goodbye("Not yet implemented", Exception_Message(diagnostic));
   170.             exit execution_loop;
   171.
   172.          when diagnostic : RESET_exception =>
   173.             say_goodbye("RESET interrupt", Exception_Message(diagnostic));
   174.             exit execution_loop;
   175.
   176.          when diagnostic : LIV_exception =>
   177.             say_goodbye( "LIV interrupt", Exception_Message(diagnostic));
   178.             exit execution_loop;
   179.
   180.          when diagnostic : Director_failure =>
   181.             say_goodbye("LIV interrupt in Director", Exception_Message(diagnostic));
   182.             exit execution_loop;
   183.
   184.          when diagnostic : OUT_error =>
   185.             say_goodbye("Failure in OUT", Exception_Message(diagnostic));
   186.             exit execution_loop;
   187.
   188.          when diagnostic : IO_error =>
   189.             say_goodbye("Impossible I/O operation", Exception_Message(diagnostic));
   190.             exit execution_loop;
   191.
   192.          when diagnostic : Director_IO_error =>
   193.             say_goodbye("Impossible I/O operation in Director", Exception_Message(diagnostic));
   194.             exit execution_loop;
   195.
   196.       end;
   197.
   198.    end loop execution_loop;
   199.
   200. exception  -- handler for execute
   201.
   202.    when diagnostic : debugging_stop =>
   203.       say_goodbye("Debugging stop requested", Exception_Message(diagnostic));
   204.
   205.    when diagnostic : invalid_paper_tape_file =>
   206.       say_goodbye("Invalid paper tape file supplied", Exception_Message(diagnostic));
   207.
   208.    when diagnostic : operator_error =>
   209.       say_goodbye("The KDF9 operator has made a mistake", Exception_Message(diagnostic));
   210.
   211.    when diagnostic : quit_request =>
   212.       say_goodbye("Run stopped by the user", Exception_Message(diagnostic), status => Success);
   213.
   214.    when diagnostic : others =>
   215.       say_goodbye("Apologies for this dismal failure", Exception_Message(diagnostic));
   216.
   217. end execute;

 217 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:07:59

     1. -- Emulation of the common functionality of a KDF9 IOC "buffer" (DMA channel),
     2. --    with fail-stop stubs for operations having device-specific behaviour.
     3. --
     4. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with KDF9.CPU;
    19. with KDF9.PHU_store;
    20. with tracing;
    21.
    22. with IOC.the_locker_of;
    23.
    24. use  KDF9.CPU;
    25. use  KDF9.PHU_store;
    26. use  tracing;
    27.
    28. package body IOC is
    29.
    30.    procedure set_state_of (the_buffer : in device_class_access;
    31.                            allocated  : in Boolean) is
    32.    begin
    33.       if the_buffer /= null then
    34.          if the_buffer.is_allocated = allocated then
    35.             -- Allocating an already allocated device, or deallocating an unallocated device.
    36.             -- Both are benign, so ignore.
    37.             return;
    38.          else
    39.             the_buffer.is_allocated := allocated;
    40.             the_CPDAR(the_buffer.number) := allocated;
    41.          end if;
    42.       end if;
    43.     end set_state_of;
    44.
    45.    function is_allocated (the_buffer : device_class_access)
    46.    return Boolean
    47.    is (the_buffer.is_allocated);
    48.
    49.    function is_unallocated (the_buffer : device_class_access)
    50.    return Boolean
    51.    is (not the_buffer.is_allocated);
    52.
    53.    hex : constant String := "0123456789ABCDEF";
    54.
    55.    function device_name_of (the_buffer : IOC.device)
    56.    return IOC.device_name is
    57.       its : IOC.device'Class renames IOC.device'Class(the_buffer);
    58.    begin
    59.       return IOC.device_kind'Image(its.kind)(1..2) & hex(Natural(its.unit)+1);
    60.    end device_name_of;
    61.
    62.    function device_name_of (the_number : IOC.device_number)
    63.    return IOC.device_name
    64.    is (device_name_of(buffer(the_number).all));
    65.
    66.    function device_kind_of (the_number : IOC.device_number)
    67.    return IOC.device_kind
    68.    is (buffer(the_number).kind);
    69.
    70.    procedure install (the_device : in out IOC.device'Class) is
    71.    begin
    72.       buffer(the_device.number) := the_device'Unchecked_Access;
    73.    end install;
    74.
    75.    overriding
    76.    procedure Initialize (the_buffer : in out IOC.device) is
    77.    begin
    78.       if not IOC.device'Class(the_buffer).is_open then
    79.          the_buffer.is_abnormal := True;
    80.          the_buffer.is_offline  := True;
    81.       end if;
    82.       install(the_buffer);
    83.    end Initialize;
    84.
    85.    procedure open (the_buffer : in out IOC.device'Class;
    86.                    the_mode   : in POSIX.access_mode) is
    87.    begin
    88.       the_buffer.device_name := device_name_of(the_buffer);
    89.       host_IO.open(the_buffer.stream, the_buffer.device_name, the_mode);
    90.       if the_buffer.is_open then
    91.          if the_mode = write_mode then
    92.             truncate(the_buffer.stream);
    93.          end if;
    94.       else
    95.          trap_operator_error(the_buffer.device_name + "cannot be found");
    96.       end if;
    97.       IOC.device(the_buffer).Initialize;
    98.    end open;
    99.
   100.    overriding
   101.    procedure Finalize (the_buffer : in out IOC.device) is
   102.    begin
   103.       if IOC.device'Class(the_buffer).is_open   and then
   104.             IOC.device'Class(the_buffer).usage /= 0 then
   105.          IOC.device'Class(the_buffer).close;
   106.       end if;
   107.    end Finalize;
   108.
   109.    function usage (the_buffer : IOC.device)
   110.    return KDF9.word is
   111.    begin
   112.       return KDF9.word(the_buffer.stream.bytes_moved);
   113.    end usage;
   114.
   115.    procedure flush (the_buffer : in out IOC.device) is
   116.    begin
   117.       flush(the_buffer.stream);
   118.    end flush;
   119.
   120.    procedure close (the_buffer : in out IOC.device) is
   121.    begin
   122.       close(the_buffer.stream);
   123.       IOC.buffer(the_buffer.number) := null;
   124.    end close;
   125.
   126.    procedure finalize_all_KDF9_buffers is
   127.    begin
   128.       for b in IOC.buffer'Range loop
   129.          if IOC.buffer(b) /= null then
   130.             Finalize(IOC.buffer(b).all);
   131.          end if;
   132.       end loop;
   133.    end finalize_all_KDF9_buffers;
   134.
   135.    procedure add_in_the_IO_lockout_CPU_time (Q_operand : in KDF9.Q_register) is
   136.       IO_size : constant KDF9.Q_part := Q_operand.M - Q_operand.I;
   137.    begin
   138.       the_CPU_delta := the_CPU_delta + KDF9.us(IO_size + group_size - 1) / group_size;
   139.    end add_in_the_IO_lockout_CPU_time;
   140.
   141.    function IO_elapsed_time (the_buffer   : IOC.device;
   142.                              atomic_items : KDF9.word)
   143.    return KDF9.us
   144.    is (
   145.        if IOC.device'Class(the_buffer).is_open then
   146.           KDF9.us(atomic_items) * IOC.device'Class(the_buffer).quantum
   147.        else
   148.           0
   149.       );
   150.
   151.    function IO_elapsed_time_total (the_buffer : IOC.device)
   152.    return KDF9.us
   153.    is (IO_elapsed_time(IOC.device'Class(the_buffer), IOC.device'Class(the_buffer).usage));
   154.
   155.    procedure validate_device (the_buffer : in IOC.device'Class) is
   156.    begin
   157.       if not the_CPDAR(the_buffer.number) and then
   158.             the_CPU_state /= Director_state   then
   159.          trap_illegal_instruction("unallocated I/O device" + the_buffer.device_name);
   160.       end if;
   161.    end validate_device;
   162.
   163.    procedure validate_bounds (Q_operand : in KDF9.Q_register) is
   164.    begin
   165.       if Q_operand.I > Q_operand.M then
   166.          trap_illegal_instruction("invalid I/O Q operand: I > M");
   167.       end if;
   168.       validate_address_range(Q_operand.I, Q_operand.M);
   169.    end validate_bounds;
   170.
   171.    procedure validate_transfer (the_buffer : in IOC.device'Class;
   172.                                 Q_operand  : in KDF9.Q_register) is
   173.    begin
   174.       validate_device(the_buffer);
   175.       validate_bounds(Q_operand);
   176.    end validate_transfer;
   177.
   178.    procedure validate_parity (the_buffer : in IOC.device'Class) is
   179.    begin
   180.       if the_buffer.is_abnormal then
   181.          trap_illegal_instruction(the_buffer.device_name + "is abnormal (parity error or EOF)");
   182.       end if;
   183.    end validate_parity;
   184.
   185.    procedure require_positive_count (count : in KDF9.Q_part) is
   186.    begin
   187.       if resign(count) <= 0 then
   188.          trap_illegal_instruction("I/O repetition count <= 0");
   189.       end if;
   190.    end require_positive_count;
   191.
   192.    procedure require_nonnegative_count (count : in KDF9.Q_part) is
   193.    begin
   194.       if resign(count) < 0 then
   195.          trap_illegal_instruction("I/O repetition count < 0");
   196.       end if;
   197.    end require_nonnegative_count;
   198.
   199.    function control_word_image (the_buffer : in IOC.device'Class)
   200.    return String
   201.    is (
   202.        the_buffer.device_name
   203.      & " Q"  & the_buffer.control_word.C'Image
   204.      & "/#"  & oct_of(the_buffer.control_word.I)
   205.      & "/#"  & oct_of(the_buffer.control_word.M)
   206.       );
   207.
   208.    -- In boot mode, punt the LOV interrupt to Director.
   209.    -- In other modes, advance the elapsed time to the next-interrupt time,
   210.    --    and suppress the LOV by simulating an earlier end of transfer.
   211.    procedure handle_a_buffer_lockout (the_buffer : in IOC.device'Class) is
   212.    begin
   213.       PHU(CPL) := (
   214.                    is_held_up => True,
   215.                    blockage   => (buffer_busy, the_buffer.number, by_INTQq => False)
   216.                   );
   217.       take_note_of_buffer_lockout(the_buffer.device_name, the_buffer.operation);
   218.       if the_execution_mode = boot_mode then
   219.          LOV_if_user_mode(the_buffer.device_name + "is busy");
   220.       else
   221.          advance_the_clock(the_buffer.completion_time);
   222.          act_on_pending_interrupts;
   223.       end if;
   224.    end handle_a_buffer_lockout;
   225.
   226.    procedure deal_with_a_busy_device (the_buffer  : in out IOC.device'Class;
   227.                                       order_time  : in KDF9.us;
   228.                                       set_offline : in Boolean) is
   229.    begin
   230.       advance_the_clock(the_clock_time+order_time);
   231.       if the_buffer.is_busy then
   232.          handle_a_buffer_lockout(the_buffer);
   233.       end if;
   234.       the_buffer.is_offline := set_offline;
   235.    end deal_with_a_busy_device;
   236.
   237.    procedure finalize_transfer (the_buffer : in out IOC.device'Class;
   238.                                 need_EDT,
   239.                                 need_PR    : out Boolean);
   240.
   241.    procedure start_data_transfer (the_buffer   : in out IOC.device'Class;
   242.                                   Q_operand    : in KDF9.Q_register;
   243.                                   set_offline  : in Boolean;
   244.                                   busy_time    : in KDF9.us;
   245.                                   operation    : in IOC.transfer_kind := some_other_operation) is
   246.       pragma Unreferenced(set_offline);
   247.       transferring_data : constant Boolean := operation in input_operation | output_operation;
   248.       time_now          : constant KDF9.us := the_clock_time;
   249.       real_Q            : KDF9.Q_register := Q_operand;
   250.       EDT_needed,
   251.       PR_needed         : Boolean;
   252.    begin
   253.       -- Check the IO parameters and the buffer state, and handle any lockout set by another device.
   254.       validate_device(the_buffer);
   255.
   256.       if transferring_data then
   257.          validate_bounds(real_Q);
   258.          real_Q := (real_Q.C, real_Q.I+BA, real_Q.M+BA);
   259.       else
   260.          require_nonnegative_count(real_Q.M);
   261.       end if;
   262.
   263.       validate_parity(the_buffer);
   264.
   265.       if the_buffer.is_busy then
   266.          handle_a_buffer_lockout(the_buffer);
   267.          if the_execution_mode = boot_mode then
   268.             finalize_transfer (the_buffer, EDT_needed, PR_needed);
   269.             if the_next_interrupt_time > time_now + 1_024_000 then
   270.                the_next_interrupt_time := time_now + 1_024_000;
   271.             end if;
   272.             if EDT_needed then
   273.                effect_interrupt(caused_by_EDT, the_buffer.control_word_image);
   274.             elsif PR_needed then
   275.                effect_interrupt(caused_by_PR, the_buffer.control_word_image);
   276.             end if;
   277.          end if;
   278.       end if;
   279.
   280.       if transferring_data                            and then
   281.             there_are_locks_in_physical_addresses(real_Q) then
   282.          LOV_if_user_mode(
   283.                           "in "
   284.                        &  "#"   & oct_of(the_buffer.control_word.I)
   285.                        &  "/#"  & oct_of(the_buffer.control_word.M)
   286.                        +  "for"
   287.                        +  the_buffer.device_name
   288.                          );
   289.       end if;
   290.
   291.       -- Set up the transfer parameters.
   292.       the_buffer.is_for_Director := (the_CPU_state = Director_state);
   293.       the_buffer.priority_level  := CPL;
   294.       the_buffer.control_word    := real_Q;
   295.       the_buffer.operation       := operation;
   296.       the_buffer.order_count     := ICR+1;
   297.       the_buffer.order_address   := CIA;
   298.       the_buffer.decoded_order   := INS;
   299.       the_buffer.initiation_time := time_now;
   300.       the_buffer.transfer_time   := busy_time;
   301.       the_buffer.completion_time := the_buffer.initiation_time + busy_time;
   302.
   303.       if busy_time > 0 or transferring_data then
   304.          if the_buffer.completion_time < the_next_interrupt_time then
   305.             the_next_interrupt_time := the_buffer.completion_time;
   306.          end if;
   307.          the_buffer.is_busy := True;
   308.          take_note_of_IO_start(
   309.                                the_buffer.device_name,
   310.                                the_buffer.completion_time,
   311.                                the_buffer.control_word,
   312.                                the_buffer.operation
   313.                               );
   314.       else
   315.          the_buffer.is_busy := False;
   316.          take_note_of_IO_finis (
   317.                                 the_buffer.order_count,
   318.                                 the_buffer.order_address,
   319.                                 the_buffer.decoded_order,
   320.                                 the_buffer.initiation_time,
   321.                                 the_buffer.device_name,
   322.                                 the_buffer.is_for_Director,
   323.                                 the_buffer.priority_level,
   324.                                 the_buffer.completion_time,
   325.                                 the_buffer.control_word,
   326.                                 the_buffer.operation
   327.                                );
   328.       end if;
   329.       PHU(CPL) := idle_PHU;
   330.    end start_data_transfer;
   331.
   332.    -- start_slow_transfer takes a pessimistic view of transfers-to-End_Message.
   333.    -- When the actual transfer length is known, the end-of-transfer time can be
   334.    --    made more realistic by specifying its real length to correct_transfer_time.
   335.    -- correct_transfer_time must be called before finalize_transfer is called.
   336.
   337.    procedure correct_transfer_time (the_buffer  : in out IOC.device'Class;
   338.                                     actual_time : in KDF9.us) is
   339.    begin
   340.       the_buffer.transfer_time :=  actual_time;
   341.       the_buffer.completion_time := the_buffer.initiation_time + the_buffer.transfer_time;
   342.       if the_buffer.completion_time < the_next_interrupt_time then
   343.          the_next_interrupt_time := the_buffer.completion_time;
   344.       end if;
   345.    end correct_transfer_time;
   346.
   347.    procedure correct_transfer_time (the_buffer    : in out IOC.device'Class;
   348.                                     actual_length : in KDF9.word) is
   349.    begin
   350.       the_buffer.transfer_time := IO_elapsed_time(the_buffer, actual_length);
   351.       the_buffer.completion_time := the_buffer.initiation_time + the_buffer.transfer_time;
   352.       if the_buffer.completion_time < the_next_interrupt_time then
   353.          the_next_interrupt_time := the_buffer.completion_time;
   354.       end if;
   355.    end correct_transfer_time;
   356.
   357.    -- If the buffer has a terminated transfer, clear its lockouts, reset its state,
   358.    --    update the PHUs, and demand an EDT or PR interrupt as needed.
   359.    procedure finalize_transfer (the_buffer : in out IOC.device'Class;
   360.                                 need_EDT,
   361.                                 need_PR    : out Boolean) is
   362.       the_PHU : KDF9.PHU_store.PHU_register renames KDF9.PHU_store.PHU(the_buffer.priority_level);
   363.       blocked : PHU_reason;
   364.    begin
   365.       if the_buffer.transfer_time /= 0 then
   366.          take_note_of_IO_finis (
   367.                                 the_buffer.order_count,
   368.                                 the_buffer.order_address,
   369.                                 the_buffer.decoded_order,
   370.                                 the_buffer.initiation_time,
   371.                                 the_buffer.device_name,
   372.                                 the_buffer.is_for_Director,
   373.                                 the_buffer.priority_level,
   374.                                 the_buffer.completion_time,
   375.                                 the_buffer.control_word,
   376.                                 the_buffer.operation
   377.                                );
   378.       end if;
   379.
   380.       need_EDT := the_buffer.is_for_Director;
   381.
   382.       -- Clear down the transfer and idle the buffer.
   383.       if the_buffer.operation in input_operation | output_operation then
   384.          unlock_absolute_addresses(the_buffer.control_word);
   385.       end if;
   386.       the_buffer.is_busy := False;
   387.       the_buffer.is_for_Director := False;
   388.
   389.       -- The following code is somewhat redundant, but written like this to exactly mirror the
   390.       -- logic stated in the KDF9 TIME-SHARING DIRECTOR SUPPORT DOCUMENTATION of 1-May-1965.
   391.       need_PR := False;
   392.       if the_PHU.is_held_up then
   393.          blocked := the_PHU.blockage;
   394.          if (blocked.reason = buffer_busy and then blocked.by_INTQq)                      or else
   395.             (blocked.reason = buffer_busy and then not buffer(blocked.buffer_nr).is_busy) or else
   396.             (blocked.reason = locked_core and then is_unlocked(blocked.group_nr))            then
   397.             the_PHU := idle_PHU;
   398.             need_PR := the_buffer.priority_level < CPL;
   399.          end if;
   400.       end if;
   401.
   402.       -- A PR interrupt may be wanted, BUT not if an EDT interrupt is wanted.
   403.       -- EDT is wanted if the transfer was for Director OR another program awaits the same buffer.
   404.
   405.       -- Check the rest of the PHU stores for an EDT interrupt.
   406.       -- This is needed only when running a Director.
   407.       if the_execution_mode = boot_mode then
   408.          -- Test for possible priority inversion, i.e. other program(s) blocked on this buffer.
   409.          for p of PHU loop
   410.             if p.is_held_up                               and then
   411.                   p.blockage.reason = buffer_busy         and then
   412.                      p.blockage.buffer_nr = the_buffer.number then
   413.                -- The KDF9 TIME-SHARING DIRECTOR SUPPORT DOCUMENTATION of 1-May-1965
   414.                --   says such a PHU is NOT cleared, but EDT is requested INSTEAD of PR,
   415.                --   so Director can take action according to what it finds there.
   416.                need_EDT := True;
   417.             end if;
   418.          end loop;
   419.       end if;
   420.       if need_EDT then
   421.          need_PR := False;
   422.       end if;
   423.    end finalize_transfer;
   424.
   425.    procedure act_on_pending_interrupts is
   426.       time_now   : constant KDF9.us := the_clock_time;
   427.       EDT_needed,
   428.       PR_needed  : Boolean := False;
   429.       number     : IOC.device_number;
   430.    begin
   431.       advance_the_clock(the_next_interrupt_time);
   432.       -- Predict another interrupt (at most 2**20 seconds in the future in boot mode).
   433.       the_next_interrupt_time := KDF9.us'Last;
   434.       for b of buffer loop
   435.          if b /= null and then
   436.                b.is_busy  then
   437.             if time_now >= b.completion_time then
   438.                finalize_transfer(b.all, EDT_needed, PR_needed);
   439.                if EDT_needed or PR_needed then
   440.                   number := b.number;
   441.                end if;
   442.             elsif the_next_interrupt_time > b.completion_time then
   443.                the_next_interrupt_time := b.completion_time;
   444.             end if;
   445.          end if;
   446.       end loop;
   447.       -- Prevent an inadvertant double clock interrupt.
   448.       if the_execution_mode = boot_mode                and then
   449.             the_next_interrupt_time > time_now + 2**24 - 1 then
   450.          the_next_interrupt_time := time_now + 2**24 - 1;
   451.       end if;
   452.       if EDT_needed then
   453.          effect_interrupt(caused_by_EDT, buffer(number).control_word_image);
   454.       elsif PR_needed then
   455.          effect_interrupt(caused_by_PR, buffer(number).control_word_image);
   456.       end if;
   457.    end act_on_pending_interrupts;
   458.
   459.    -- Advance the time to a point after all extant transfer have terminated,
   460.    --    finalizing all extant transfer in temporal order in the process.
   461.    procedure complete_all_extant_transfers is
   462.       EDT_needed,
   463.       PR_needed      : Boolean := False;
   464.       last_time      : KDF9.us := 0;
   465.       next_time      : KDF9.us;
   466.    begin
   467.       -- At least one transfer should be terminated each time around outer_loop,
   468.       --    if not, outer_loop is exited.
   469.    outer_loop:
   470.       for c in buffer'Range loop
   471.          -- Find the earliest transfer termination time.
   472.          next_time := KDF9.us'Last;
   473.          for b of buffer loop
   474.             if b /= null                       and then
   475.                   b.is_busy                    and then
   476.                      b.completion_time < next_time then
   477.                next_time := b.completion_time;
   478.             end if;
   479.          end loop;
   480.
   481.          if next_time = KDF9.us'Last then
   482.             -- All the buffers are quiescent.
   483.             exit outer_loop;
   484.          else
   485.             -- At least one transfer remains to be finalized.
   486.             advance_the_clock(next_time);
   487.             last_time := KDF9.us'Max(last_time, next_time);
   488.          end if;
   489.
   490.          -- Finalize all transfers with completion time <= next_time.
   491.          for b of buffer loop
   492.             if b /= null                        and then
   493.                   b.is_busy                     and then
   494.                      b.completion_time <= next_time then
   495.                finalize_transfer(b.all, EDT_needed, PR_needed);
   496.             end if;
   497.          end loop;
   498.
   499.       end loop outer_loop;
   500.    end complete_all_extant_transfers;
   501.
   502.    procedure handle_a_main_store_lockout is
   503.       the_locker : KDF9.buffer_number;
   504.       found      : Boolean;
   505.    begin
   506.       PHU(CPL) := (
   507.                    is_held_up => True,
   508.                    blockage   => (locked_core, group_address(group(the_locked_out_address)))
   509.                   );
   510.       -- Store access LOV interrupts invoke instruction restart outside Director.
   511.       the_locker := the_locker_of(the_locked_out_address, found);
   512.       if not found then
   513.          raise emulation_failure with "cannot find a buffer responsible for this store lockout";
   514.       end if;
   515.       take_note_of_store_lockout(device_name_of(buffer(the_locker).all));
   516.       if the_execution_mode = boot_mode then
   517.          if_user_mode_then_LOV(the_locked_out_address);
   518.       else
   519.          set_NIA_to(CIA);
   520.          advance_the_clock(buffer(the_locker).completion_time);
   521.          act_on_pending_interrupts;
   522.       end if;
   523.       ICR := ICR + 1;
   524.    end handle_a_main_store_lockout;
   525.
   526.    procedure MANUAL_CT (the_buffer  : in out IOC.device'Class;
   527.                         Q_operand   : in KDF9.Q_register;
   528.                         set_offline : in Boolean) is
   529.       EDT_needed, PR_needed : Boolean := False;
   530.    begin
   531.       validate_device(the_buffer);
   532.       take_note_of_test(the_buffer.device_name, Q_operand, the_buffer.is_busy);
   533.       -- ee9 allows the transfer to terminate normally, as if MANUALQ with set_offline = True;
   534.       --    even when set_offline = False, i.e. CTQ, which aborted any residual I/O on the KDF9.
   535.       if the_buffer.is_busy then
   536.          the_buffer.completion_time := KDF9.us'Min(the_buffer.completion_time, the_clock_time);
   537.          finalize_transfer(the_buffer, EDT_needed, PR_needed);
   538.       end if;
   539.       the_buffer.is_busy     := False;
   540.       the_buffer.operation   := some_other_operation;
   541.       the_buffer.is_abnormal := False;
   542.       the_buffer.is_offline  := set_offline;
   543.    end MANUAL_CT;
   544.
   545.    procedure INT (the_buffer  : in out IOC.device'Class;
   546.                   Q_operand   : in KDF9.Q_register;
   547.                   set_offline : in Boolean) is
   548.       now  : constant KDF9.us := the_clock_time;
   549.       step : KDF9.us;
   550.    begin
   551.       validate_device(the_buffer);
   552.       if the_buffer.is_busy then
   553.          PHU(CPL) := (
   554.                       is_held_up => True,
   555.                       blockage   => (buffer_busy, the_buffer.number, by_INTQq => True)
   556.                      );
   557.          take_note_of_buffer_lockout(the_buffer.device_name, the_buffer.operation);
   558.          if the_execution_mode = boot_mode then
   559.             step := KDF9.us'Max((the_buffer.completion_time - now) / 16, 1);
   560.             advance_the_clock(KDF9.us'Min(the_buffer.completion_time, now + step));
   561.             effect_interrupt(caused_by_PR, control_word_image(the_buffer));
   562.          else
   563.             advance_the_clock(the_buffer.completion_time);
   564.             act_on_pending_interrupts;
   565.          end if;
   566.       else
   567.          take_note_of_test(the_buffer.device_name, Q_operand, False);
   568.       end if;
   569.       the_buffer.is_offline := set_offline;
   570.    end INT;
   571.
   572.    procedure BUSY (the_buffer  : in out IOC.device'Class;
   573.                    Q_operand   : in KDF9.Q_register;
   574.                    set_offline : in Boolean;
   575.                    result      : out Boolean) is
   576.    begin
   577.       validate_device(the_buffer);
   578.       result := the_buffer.is_busy;
   579.       take_note_of_test(the_buffer.device_name, Q_operand, result);
   580.       if the_buffer.is_busy and then
   581.             (the_execution_mode /= boot_mode or the_CPU_state = Director_state) then
   582.          act_on_pending_interrupts;
   583.       end if;
   584.       the_buffer.is_offline := set_offline;
   585.    end BUSY;
   586.
   587.    procedure PAR (the_buffer  : in out IOC.device'Class;
   588.                   Q_operand   : in KDF9.Q_register;
   589.                   set_offline : in Boolean;
   590.                   result      : out Boolean) is
   591.    begin
   592.       validate_device(the_buffer);
   593.       deal_with_a_busy_device(the_buffer, 13, set_offline);
   594.       result := the_buffer.is_abnormal;
   595.       take_note_of_test(the_buffer.device_name, Q_operand, result);
   596.       the_buffer.is_abnormal := False;
   597.       the_buffer.is_offline := set_offline;
   598.    end PAR;
   599.
   600.    subtype IO_mnemonic is String(1 .. 5);
   601.    type synonyms       is array (1 .. 2) of IO_mnemonic;
   602.    type synonym_list   is array (Positive range <>) of synonyms;
   603.
   604.    FW_synonyms  : constant synonym_list
   605.                 := (
   606.                     ("POA  ", "TW   "), ("POB  ", "TWE  "),
   607.                     ("PIA  ", "TR   "), ("PIB  ", "TRE  ")
   608.                    );
   609.
   610.    TR_synonyms  : constant synonym_list
   611.                 := (
   612.                     ("PIA  ", "PR   "), ("PIB  ", "PRE  "),
   613.                     ("PIC  ", "PRC  "), ("PID  ", "PRCE ")
   614.                    );
   615.
   616.    TP_synonyms  : constant synonym_list
   617.                 := (
   618.                     ("POA  ", "PW   "), ("POB  ", "PWE  "),
   619.                     ("POC  ", "PWC  "), ("POD  ", "PWCE "),
   620.                     ("POE  ", "PGAP ")
   621.                    );
   622.
   623.    LP_synonyms  : constant synonym_list
   624.                 := (
   625.                     ("POA  ", "LP   "), ("POB  ", "LPE  ")
   626.                    );
   627.
   628.    MT_synonyms  : constant synonym_list
   629.                 := (
   630.                     ("PIA  ", "MFR  "), ("PIB  ", "MFRE "),
   631.                     ("PIE  ", "MBR  "), ("PIF  ", "MBRE "),
   632.                     ("POA  ", "MW   "), ("POB  ", "MWE  "),
   633.                     ("POC  ", "MLW  "), ("POD  ", "MLWE "),
   634.                     ("POE  ", "MGAP "), ("POF  ", "MWIPE"),
   635.                     ("PMA  ", "MFSK "), ("PMB  ", "MBT  "),
   636.                     ("PMC  ", "MLB  "), ("PMD  ", "MRWD "),
   637.                     ("PME  ", "MBSK "), ("PMF  ", "MET  ")
   638.                    );
   639.
   640.    function mnemonic (order : in String; class : in IOC.device_name)
   641.    return String is
   642.
   643.       key : constant IO_mnemonic := just_left(order(order'First..order'First+2), 5);
   644.       Qij : constant String      := order(order'First+3..order'Last);
   645.
   646.       function choose (synonyms : synonym_list)
   647.       return String is
   648.       begin
   649.          for s of synonyms loop
   650.             if s(1) = key then return trimmed(s(2)) & Qij; end if;
   651.          end loop;
   652.          return order;
   653.       end choose;
   654.
   655.       XY : constant String(1..2) := class(class'First..class'First+1);
   656.
   657.    begin
   658.       if key(1..3) in "TLO" | "CLO" | "PMH" | "SLO" then
   659.          -- These orders do not necessarily involve a device.
   660.          return order;
   661.       end if;
   662.       if XY in "AD" | "CP" | "CR" | "DR" | "FD" | "GP" | "ST" | "SI" then
   663.          return order;
   664.       elsif XY = "FW" then -- FlexoWriter
   665.          return choose(FW_synonyms);
   666.       elsif XY = "LP" then -- Line Printer
   667.          return choose(LP_synonyms);
   668.       elsif XY = "MT" then -- Magnetic Tape
   669.          return choose(MT_synonyms);
   670.       elsif XY = "TP" then -- Tape Punch
   671.          return choose(TP_synonyms);
   672.       elsif XY = "TR" then -- Tape Reader
   673.          return choose(TR_synonyms);
   674.       else
   675.          return "??";
   676.       end if;
   677.    end mnemonic;
   678.
   679.    procedure trap_failing_IO_operation (the_culprit : in String; the_message : in String) is
   680.       the_diagnostic : constant String := "%" & the_message + "on" + the_culprit;
   681.    begin
   682.       if the_execution_mode in program_mode | privileged_mode then
   683.          raise IO_error with the_diagnostic;
   684.       elsif the_CPU_state = program_state then
   685.          raise abandon_this_order with the_diagnostic;
   686.       else
   687.          raise Director_IO_error with the_diagnostic;
   688.       end if;
   689.    end trap_failing_IO_operation;
   690.
   691.    procedure trap_failing_IO_operation (the_buffer : in out IOC.device; the_message : in String) is
   692.    begin
   693.       if the_CPU_state = program_state then
   694.          the_buffer.is_abnormal := True;
   695.       end if;
   696.       trap_failing_IO_operation(the_buffer.device_name, the_message);
   697.    end trap_failing_IO_operation;
   698.
   699.    procedure trap_illegal_IO_operation (order       : in String;
   700.                                         buffer      : in IOC.device;
   701.                                         Q_operand   : in KDF9.Q_register;
   702.                                         set_offline : in Boolean) is
   703.       pragma Unreferenced(Q_operand);
   704.       pragma Unreferenced(set_offline);
   705.    begin
   706.       trap_illegal_instruction(order + "cannot be used on" + buffer.device_name);
   707.    end trap_illegal_IO_operation;
   708.
   709.    --
   710.    -- The following bodies provide inheritable default actions for
   711.    -- operations that are not implemented by specific device types.
   712.    --
   713.
   714.    procedure PIA (the_buffer  : in out IOC.device;
   715.                   Q_operand   : in KDF9.Q_register;
   716.                   set_offline : in Boolean) is
   717.    begin
   718.       trap_illegal_IO_operation("PIA", the_buffer, Q_operand, set_offline);
   719.    end PIA;
   720.
   721.    procedure PIB (the_buffer  : in out IOC.device;
   722.                   Q_operand   : in KDF9.Q_register;
   723.                   set_offline : in Boolean) is
   724.    begin
   725.       trap_illegal_IO_operation("PIB", the_buffer, Q_operand, set_offline);
   726.    end PIB;
   727.
   728.    procedure PIC (the_buffer  : in out IOC.device;
   729.                   Q_operand   : in KDF9.Q_register;
   730.                   set_offline : in Boolean) is
   731.    begin
   732.       trap_illegal_IO_operation("PIC", the_buffer, Q_operand, set_offline);
   733.    end PIC;
   734.
   735.    procedure PID (the_buffer  : in out IOC.device;
   736.                   Q_operand   : in KDF9.Q_register;
   737.                   set_offline : in Boolean) is
   738.    begin
   739.       trap_illegal_IO_operation("PID", the_buffer, Q_operand, set_offline);
   740.    end PID;
   741.
   742.    procedure PIE (the_buffer  : in out IOC.device;
   743.                   Q_operand   : in KDF9.Q_register;
   744.                   set_offline : in Boolean) is
   745.    begin
   746.       trap_illegal_IO_operation("PIE", the_buffer, Q_operand, set_offline);
   747.    end PIE;
   748.
   749.    procedure PIF (the_buffer  : in out IOC.device;
   750.                   Q_operand   : in KDF9.Q_register;
   751.                   set_offline : in Boolean) is
   752.    begin
   753.       trap_illegal_IO_operation("PIF", the_buffer, Q_operand, set_offline);
   754.    end PIF;
   755.
   756.    procedure PIG (the_buffer  : in out IOC.device;
   757.                   Q_operand   : in KDF9.Q_register;
   758.                   set_offline : in Boolean) is
   759.    begin
   760.       trap_illegal_IO_operation("PIG", the_buffer, Q_operand, set_offline);
   761.    end PIG;
   762.
   763.    procedure PIH (the_buffer  : in out IOC.device;
   764.                   Q_operand   : in KDF9.Q_register;
   765.                   set_offline : in Boolean) is
   766.    begin
   767.       trap_illegal_IO_operation("PIH", the_buffer, Q_operand, set_offline);
   768.    end PIH;
   769.
   770.    procedure PMA (the_buffer  : in out IOC.device;
   771.                   Q_operand   : in KDF9.Q_register;
   772.                   set_offline : in Boolean) is
   773.    begin
   774.       trap_illegal_IO_operation("PMA", the_buffer, Q_operand, set_offline);
   775.    end PMA;
   776.
   777.    procedure PMB (the_buffer  : in out IOC.device;
   778.                   Q_operand   : in KDF9.Q_register;
   779.                   set_offline : in Boolean)
   780.    is null;
   781.
   782.    procedure PMC (the_buffer  : in out IOC.device;
   783.                   Q_operand   : in KDF9.Q_register;
   784.                   set_offline : in Boolean)
   785.    is null;
   786.
   787.    procedure PMD (the_buffer  : in out IOC.device;
   788.                   Q_operand   : in KDF9.Q_register;
   789.                   set_offline : in Boolean) is
   790.    begin
   791.       trap_illegal_IO_operation("PMD", the_buffer, Q_operand, set_offline);
   792.    end PMD;
   793.
   794.    procedure PME (the_buffer  : in out IOC.device;
   795.                   Q_operand   : in KDF9.Q_register;
   796.                   set_offline : in Boolean) is
   797.    begin
   798.       trap_illegal_IO_operation("PME", the_buffer, Q_operand, set_offline);
   799.    end PME;
   800.
   801.    procedure PMF (the_buffer  : in out IOC.device;
   802.                   Q_operand   : in KDF9.Q_register;
   803.                   set_offline : in Boolean)
   804.    is null;
   805.
   806.    procedure PMG (the_buffer  : in out IOC.device;
   807.                   Q_operand   : in KDF9.Q_register;
   808.                   set_offline : in Boolean) is
   809.    begin
   810.       trap_illegal_IO_operation("PMG", the_buffer, Q_operand, set_offline);
   811.    end PMG;
   812.
   813. -- procedure PMH is subsumed by SLOC.
   814.
   815.    procedure PMK (the_buffer  : in out IOC.device;
   816.                   Q_operand   : in KDF9.Q_register;
   817.                   set_offline : in Boolean) is
   818.    begin
   819.       trap_illegal_IO_operation("PMK", the_buffer, Q_operand, set_offline);
   820.    end PMK;
   821.
   822.    procedure PML (the_buffer  : in out IOC.device;
   823.                   Q_operand   : in KDF9.Q_register;
   824.                   set_offline : in Boolean) is
   825.    begin
   826.       trap_illegal_IO_operation("PML", the_buffer, Q_operand, set_offline);
   827.    end PML;
   828.
   829.    procedure POA (the_buffer  : in out IOC.device;
   830.                   Q_operand   : in KDF9.Q_register;
   831.                   set_offline : in Boolean) is
   832.    begin
   833.       trap_illegal_IO_operation("POA", the_buffer, Q_operand, set_offline);
   834.    end POA;
   835.
   836.    procedure POB (the_buffer  : in out IOC.device;
   837.                   Q_operand   : in KDF9.Q_register;
   838.                   set_offline : in Boolean) is
   839.    begin
   840.       trap_illegal_IO_operation("POB", the_buffer, Q_operand, set_offline);
   841.    end POB;
   842.
   843.    procedure POC (the_buffer  : in out IOC.device;
   844.                   Q_operand   : in KDF9.Q_register;
   845.                   set_offline : in Boolean) is
   846.    begin
   847.       trap_illegal_IO_operation("POC", the_buffer, Q_operand, set_offline);
   848.    end POC;
   849.
   850.    procedure POD (the_buffer  : in out IOC.device;
   851.                   Q_operand   : in KDF9.Q_register;
   852.                   set_offline : in Boolean) is
   853.    begin
   854.       trap_illegal_IO_operation("POD", the_buffer, Q_operand, set_offline);
   855.    end POD;
   856.
   857.    procedure POE (the_buffer  : in out IOC.device;
   858.                   Q_operand   : in KDF9.Q_register;
   859.                   set_offline : in Boolean) is
   860.    begin
   861.       trap_illegal_IO_operation("POE", the_buffer, Q_operand, set_offline);
   862.    end POE;
   863.
   864.    procedure POF (the_buffer  : in out IOC.device;
   865.                   Q_operand   : in KDF9.Q_register;
   866.                   set_offline : in Boolean) is
   867.    begin
   868.       trap_illegal_IO_operation("POF", the_buffer, Q_operand, set_offline);
   869.    end POF;
   870.
   871.    procedure POG (the_buffer  : in out IOC.device;
   872.                   Q_operand   : in KDF9.Q_register;
   873.                   set_offline : in Boolean) is
   874.    begin
   875.       trap_illegal_IO_operation("POG", the_buffer, Q_operand, set_offline);
   876.    end POG;
   877.
   878.    procedure POH (the_buffer  : in out IOC.device;
   879.                   Q_operand   : in KDF9.Q_register;
   880.                   set_offline : in Boolean) is
   881.    begin
   882.       trap_illegal_IO_operation("POH", the_buffer, Q_operand, set_offline);
   883.    end POH;
   884.
   885.    procedure POK (the_buffer  : in out IOC.device;
   886.                   Q_operand   : in KDF9.Q_register;
   887.                   set_offline : in Boolean) is
   888.    begin
   889.       trap_illegal_IO_operation("POK", the_buffer, Q_operand, set_offline);
   890.    end POK;
   891.
   892.    procedure POL (the_buffer  : in out IOC.device;
   893.                   Q_operand   : in KDF9.Q_register;
   894.                   set_offline : in Boolean) is
   895.    begin
   896.       trap_illegal_IO_operation("POL", the_buffer, Q_operand, set_offline);
   897.    end POL;
   898.
   899. end IOC;

Compiling: ../Source/ioc.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:07:59

     1. -- Emulation of the common functionality of a KDF9 IOC "buffer" (DMA channel),
     2. --    with fail-stop stubs for operations having device-specific behaviour.
     3. --
     4. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with Ada.Finalization;
    19. --
    20. with KDF9;
    21.
    22. private with Ada.Exceptions;
    23. --
    24. private with KDF9.imaging;
    25. private with exceptions;
    26. private with HCI;
    27. private with host_IO;
    28. private with KDF9_char_sets;
    29. private with KDF9.store;
    30. private with POSIX;
    31. private with settings;
    32. private with string_editing;
    33.
    34. use  Ada.Finalization;
    35. --
    36. use  KDF9;
    37.
    38. package IOC is
    39.
    40.    -- N.B. the KDF9 'buffer' is a DMA controller in more modern terminology.
    41.
    42.    -- Each KDF9 buffer is externally characterized by:
    43.    --    its (absolute) number,
    44.    --    its (attached-device) kind, and
    45.    --    its unit (the number of that device within its kind).
    46.
    47.    -- A device of AD_kind is attached to a buffer with No Device connected.
    48.    -- If commanded, it performs a basic default action,
    49.    --    which is to cause a LIV interrupt in the case of transfers,
    50.    --       but is both benign and appropriate for all other operations.
    51.
    52.    type device_kind is
    53.       (CP_kind,  -- Card Punch
    54.        CR_kind,  -- Card Reader
    55.        DR_kind,  -- Drum
    56.        FD_kind,  -- Fixed Disc
    57.        FW_kind,  -- FlexoWriter (monitor typewriter)
    58.        GP_kind,  -- Graph Plotter (Calcomp 120' by 29.5" model)
    59.        LP_kind,  -- Line Printer
    60.        MT_kind,  -- Magnetic Tape
    61.        SI_kind,  -- Standard Interface buffer
    62.        ST_kind,  -- Seven Track (IBM) magnetic Tape
    63.        TP_kind,  -- Tape Punch
    64.        TR_kind,  -- Tape Reader
    65.        AD_kind   -- Absent Device
    66.       );
    67.
    68.    -- This is the number of the buffer a device is connected to.
    69.    subtype device_number is KDF9.Q_part range 0 .. 15;
    70.
    71.    -- This is the index of a device within devices of the type in the configuration.
    72.    subtype unit_number   is KDF9.Q_part range 0 .. 15;
    73.
    74.    -- An IOC.device_name is of the form XYu, where XY is a two-letter device-type code
    75.    --    and u is the logical unit number, in the range 0..F, of the device within its type.
    76.
    77.    subtype device_name is String(1..3);
    78.
    79. --
    80. --
    81.    -- This is the root for all I/O device types.
    82. --
    83. --
    84.
    85.    type device (number : IOC.device_number; unit : IOC.unit_number)
    86.    is abstract new Limited_Controlled with private;
    87.
    88.    -- The quantum is the time, in s, taken to transfer a basic datum.
    89.    -- For unit-record devices (CR, CP, LP) this is the card/line.
    90.    -- For other devices it is the KDF9 character.
    91.    function quantum (the_buffer : IOC.device)
    92.    return KDF9.us
    93.    is abstract;
    94.
    95.    function kind (the_buffer : IOC.device)
    96.    return IOC.device_kind
    97.    is abstract;
    98.
    99.    -- This is overridden separately for fast and slow devices.
   100.    procedure add_in_the_IO_CPU_time (the_buffer  : in IOC.device;
   101.                                      bytes_moved : in KDF9.word)
   102.    is abstract;
   103.
   104.    -- True iff the_buffer has been opened but not yet closed.
   105.    -- It is overridden separately for magnetic tapes and all other devices.
   106.    function is_open (the_buffer : IOC.device)
   107.    return Boolean
   108.    is abstract;
   109.
   110.    -- A measure of the I/O volume transferred by the_buffer, so far.
   111.    function usage (the_buffer : IOC.device)
   112.    return KDF9.word;
   113.
   114.    -- Ensure that all output to the_buffer has been transmitted.
   115.    procedure flush (the_buffer : in out IOC.device);
   116.
   117.    -- Make the_buffer unavailable for further I/O use, after flushing if necessary.
   118.    procedure close (the_buffer : in out IOC.device);
   119.
   120.    -- A IOC.device_name is of the form XYn, where XY is a two-letter device-type
   121.    --    code (e.g., "LP" or "CR"); and n is the one-digit logical unit number
   122.    --       of a device within its category (n may be in hexadecimal).
   123.
   124.    function device_name_of (the_buffer : IOC.device)
   125.    return IOC.device_name;
   126.
   127.    function device_name_of (the_number : IOC.device_number)
   128.    return IOC.device_name;
   129.
   130.    function device_kind_of (the_number : IOC.device_number)
   131.    return IOC.device_kind;
   132.
   133.    -- Get the device-specific name of the I/O order, or the generic name if there isn't one.
   134.    function mnemonic (order : in String; class : in IOC.device_name)
   135.    return String;
   136.
   137.    -- An I/O operation may fail for two distict reasons:
   138.    -- 1. the order is illegal per se
   139.    -- 2. the order is legal, but is attempting an impossible effect.
   140.
   141.    -- trap_illegal_IO_operation fails the run because of an attempt to use an I/O order
   142.    --   that is illegal or undefined for the device concerned.
   143.    procedure trap_illegal_IO_operation (order       : in String;
   144.                                         buffer      : in IOC.device;
   145.                                         Q_operand   : in KDF9.Q_register;
   146.                                         set_offline : in Boolean)
   147.       with Inline => False;
   148.
   149.    -- trap_failing_IO_operation fails the run iff either:
   150.    -- 1. ee9 is running in a non-boot mode, because nothing more can usefully be done
   151.    -- OR
   152.    -- 2. Director is running, because an impossible operation implies a serious failure in Director.
   153.    --
   154.    -- In boot mode, when Director is not running, it sets the buffer abnormal and abandons the order.
   155.    -- It is then up to the problem program to act accordingly.  Failure to do so may LIV.
   156.
   157.    procedure trap_failing_IO_operation (the_buffer : in out IOC.device; the_message : in String)
   158.       with Inline => False;
   159.
   160.    procedure trap_failing_IO_operation (the_culprit : in String; the_message : in String)
   161.       with Inline => False;
   162.
   163.    -- The elapsed time for the I/O of the given number of atomic_items
   164.    --    which may be, e.g., bytes, or card images, or printer lines.
   165.    function IO_elapsed_time (the_buffer   : IOC.device;
   166.                              atomic_items : KDF9.word)
   167.    return KDF9.us;
   168.
   169.    -- The total elapsed time taken, so far, by transfers on the attached device.
   170.    function IO_elapsed_time_total (the_buffer : IOC.device)
   171.    return KDF9.us;
   172.
   173.
   174.    --
   175.    -- The CLOQq, SLOQq and TLOQq operations do NOT address a buffer,
   176.    --    and so are fully implemented elsewhere.
   177.    --
   178.
   179.    --
   180.    -- The INTQq, BUSYQq, PARQq and MANUALQq/CTQq operations DO address a buffer,
   181.    --    but do NOT initiate an I/O transfer, and are common to all devices,
   182.    --       so they operate on a class-wide parameter.
   183.    --
   184.
   185.    procedure INT (the_buffer  : in out IOC.device'Class;
   186.                   Q_operand   : in KDF9.Q_register;
   187.                   set_offline : in Boolean);
   188.
   189.    procedure BUSY (the_buffer  : in out IOC.device'Class;
   190.                    Q_operand   : in KDF9.Q_register;
   191.                    set_offline : in Boolean;
   192.                    result      : out Boolean);
   193.
   194.    procedure PAR (the_buffer   : in out IOC.device'Class;
   195.                    Q_operand   : in KDF9.Q_register;
   196.                    set_offline : in Boolean;
   197.                    result      : out Boolean);
   198.
   199.    procedure MANUAL_CT (the_buffer  : in out IOC.device'Class;
   200.                         Q_operand   : in KDF9.Q_register;
   201.                         set_offline : in Boolean);
   202.
   203.    -- These KDF9 data-transfer operations must be overridden for non-trivial functionality.
   204.    -- Invoking any of them raises a LIV exception. This exactly mirrors the action of the
   205.    --    KDF9 in causing a LIV interrupt when an invalid operation was applied to a device.
   206.    -- A device without some of these operations inherits them from this list and so
   207.    --    implements correctly the original semantics of the KDF9.
   208.
   209.    --
   210.    -- The PI* are input operations.
   211.    --
   212.
   213.    procedure PIA (the_buffer  : in out IOC.device;
   214.                   Q_operand   : in KDF9.Q_register;
   215.                   set_offline : in Boolean);
   216.
   217.    procedure PIB (the_buffer  : in out IOC.device;
   218.                   Q_operand   : in KDF9.Q_register;
   219.                   set_offline : in Boolean);
   220.
   221.    procedure PIC (the_buffer  : in out IOC.device;
   222.                   Q_operand   : in KDF9.Q_register;
   223.                   set_offline : in Boolean);
   224.
   225.    procedure PID (the_buffer  : in out IOC.device;
   226.                   Q_operand   : in KDF9.Q_register;
   227.                   set_offline : in Boolean);
   228.
   229.    procedure PIE (the_buffer  : in out IOC.device;
   230.                   Q_operand   : in KDF9.Q_register;
   231.                   set_offline : in Boolean);
   232.
   233.    procedure PIF (the_buffer  : in out IOC.device;
   234.                   Q_operand   : in KDF9.Q_register;
   235.                   set_offline : in Boolean);
   236.
   237.    procedure PIG (the_buffer  : in out IOC.device;
   238.                   Q_operand   : in KDF9.Q_register;
   239.                   set_offline : in Boolean);
   240.
   241.    procedure PIH (the_buffer  : in out IOC.device;
   242.                   Q_operand   : in KDF9.Q_register;
   243.                   set_offline : in Boolean);
   244.
   245.    --
   246.    -- The PM* are device-status operations.
   247.    --
   248.
   249.    procedure PMA (the_buffer  : in out IOC.device;
   250.                   Q_operand   : in KDF9.Q_register;
   251.                   set_offline : in Boolean);
   252.
   253.    procedure PMB (the_buffer  : in out IOC.device;
   254.                   Q_operand   : in KDF9.Q_register;
   255.                   set_offline : in Boolean);
   256.
   257.    procedure PMC (the_buffer  : in out IOC.device;
   258.                   Q_operand   : in KDF9.Q_register;
   259.                   set_offline : in Boolean);
   260.
   261.    procedure PMD (the_buffer  : in out IOC.device;
   262.                   Q_operand   : in KDF9.Q_register;
   263.                   set_offline : in Boolean);
   264.
   265.    procedure PME (the_buffer  : in out IOC.device;
   266.                   Q_operand   : in KDF9.Q_register;
   267.                   set_offline : in Boolean);
   268.
   269.    procedure PMF (the_buffer  : in out IOC.device;
   270.                   Q_operand   : in KDF9.Q_register;
   271.                   set_offline : in Boolean);
   272.
   273.    -- This is the mysterious "read C store" order.
   274.    procedure PMG (the_buffer  : in out IOC.device;
   275.                   Q_operand   : in KDF9.Q_register;
   276.                   set_offline : in Boolean);
   277.
   278. -- procedure PMH is implemented by SLO
   279.
   280.    procedure PMK (the_buffer  : in out IOC.device;
   281.                   Q_operand   : in KDF9.Q_register;
   282.                   set_offline : in Boolean);
   283.
   284.    procedure PML (the_buffer  : in out IOC.device;
   285.                   Q_operand   : in KDF9.Q_register;
   286.                   set_offline : in Boolean);
   287.
   288.    --
   289.    -- The PO* are output operations.
   290.    --
   291.
   292.    procedure POA (the_buffer  : in out IOC.device;
   293.                   Q_operand   : in KDF9.Q_register;
   294.                   set_offline : in Boolean);
   295.
   296.    procedure POB (the_buffer  : in out IOC.device;
   297.                   Q_operand   : in KDF9.Q_register;
   298.                   set_offline : in Boolean);
   299.
   300.    procedure POC (the_buffer  : in out IOC.device;
   301.                   Q_operand   : in KDF9.Q_register;
   302.                   set_offline : in Boolean);
   303.
   304.    procedure POD (the_buffer  : in out IOC.device;
   305.                   Q_operand   : in KDF9.Q_register;
   306.                   set_offline : in Boolean);
   307.
   308.    procedure POE (the_buffer  : in out IOC.device;
   309.                   Q_operand   : in KDF9.Q_register;
   310.                   set_offline : in Boolean);
   311.
   312.    procedure POF (the_buffer  : in out IOC.device;
   313.                   Q_operand   : in KDF9.Q_register;
   314.                   set_offline : in Boolean);
   315.
   316.    procedure POG (the_buffer  : in out IOC.device;
   317.                   Q_operand   : in KDF9.Q_register;
   318.                   set_offline : in Boolean);
   319.
   320.    procedure POH (the_buffer  : in out IOC.device;
   321.                   Q_operand   : in KDF9.Q_register;
   322.                   set_offline : in Boolean);
   323.
   324.    procedure POK (the_buffer  : in out IOC.device;
   325.                   Q_operand   : in KDF9.Q_register;
   326.                   set_offline : in Boolean);
   327.
   328.    procedure POL (the_buffer  : in out IOC.device;
   329.                   Q_operand   : in KDF9.Q_register;
   330.                   set_offline : in Boolean);
   331.
   332.
   333. --
   334. --
   335.    -- The buffer_configuration type enables the dynamic setting-up of a complement of I/O devices.
   336. --
   337. --
   338.
   339.    type device_class_access  is access all IOC.device'Class;
   340.
   341.    type buffer_configuration is array (KDF9.buffer_number) of IOC.device_class_access;
   342.
   343.    -- These are the I/O devices installed in this configuration.
   344.    -- Each device installs itself into the configuration when the device is initialized.
   345.
   346.    buffer : buffer_configuration;
   347.
   348. --
   349.    -- These operations are used by Directors to manage device allocation to problem programs.
   350. --
   351.
   352.    procedure set_state_of (the_buffer : in device_class_access;
   353.                            allocated  : in Boolean);
   354.
   355.    function is_allocated (the_buffer : device_class_access)  -- N.B. IS_allocated.
   356.    return Boolean;
   357.
   358.    function is_unallocated (the_buffer : device_class_access)  -- N.B. is_UNallocated.
   359.    return Boolean;
   360.
   361. --
   362.    -- These buffer-implementation operations are used outside IOC and apply to all device types.
   363. --
   364.
   365.    -- Complete all extant transfers, then Finalize each buffer.
   366.    procedure finalize_all_KDF9_buffers;
   367.
   368.    -- Advance the elapsed time to a point after all extant transfer have terminated.
   369.    procedure complete_all_extant_transfers;
   370.
   371.    -- Complete any terminated transfer operations and take any needed interrupts.
   372.    procedure act_on_pending_interrupts;
   373.
   374.    -- Handle non-data transfer operations on busy device.
   375.    procedure deal_with_a_busy_device (the_buffer  : in out IOC.device'Class;
   376.                                       order_time  : in KDF9.us;
   377.                                       set_offline : in Boolean);
   378.
   379.    -- A LOV interupt caused by an attempted store access must arrange
   380.    --    for the interrupted instruction to be resumed.
   381.    -- In boot mode, effect the LOV interrupt to Director.
   382.    -- In other modes, advance the elapsed time to the end-of-transfer time
   383.    --    for the_locked_out_address, then act on pending interrupts.
   384.    procedure handle_a_main_store_lockout;
   385.
   386.    type transfer_kind  is (input_operation,
   387.                            output_operation,
   388.                            control_operation,
   389.                            some_other_operation);
   390.
   391.    -- Take note of the start of a transfer.
   392.    -- For I/O operations that do not entail an actual data transfer,
   393.    --    such as testing a buffer for a graph plotter,
   394.    --    set the busy time to the order's MC execution time.
   395.    -- This keeps elapsed time in sync with CPU time,
   396.    --    and ensures that the operation waits for any preceding transfer
   397.    --    on the same buffer to complete before the test is actioned.
   398.    procedure start_data_transfer (the_buffer  : in out IOC.device'Class;
   399.                                   Q_operand   : in KDF9.Q_register;
   400.                                   set_offline : in Boolean;
   401.                                   busy_time   : in KDF9.us;
   402.                                   operation   : in IOC.transfer_kind := IOC.some_other_operation);
   403.
   404. private
   405.
   406.    use Ada.Exceptions; pragma Warnings(Off, Ada.Exceptions);
   407.    --
   408.    use KDF9.imaging;   pragma Warnings(Off, KDF9.imaging);
   409.    use exceptions;     pragma Warnings(Off, exceptions);
   410.    use HCI;            pragma Warnings(Off, HCI);
   411.    use host_IO;        pragma Warnings(Off, host_IO);
   412.    use KDF9_char_sets; pragma Warnings(Off, KDF9_char_sets);
   413.    use KDF9.store;     pragma Warnings(Off, KDF9.store);
   414.    use settings;       pragma Warnings(Off, settings);
   415.    use string_editing; pragma Warnings(Off, string_editing);
   416.
   417.    use POSIX;          -- Used here, so no need to suppress warnings.
   418.
   419.    type device (number : IOC.device_number; unit : IOC.unit_number)
   420.    is abstract new Limited_Controlled with
   421.       record
   422.          is_abnormal,
   423.          is_busy,
   424.          is_offline,
   425.          is_allocated,
   426.          is_for_Director : Boolean := False;
   427.          operation       : IOC.transfer_kind := IOC.some_other_operation;
   428.          initiation_time : KDF9.us := KDF9.us'Last;
   429.          transfer_time   : KDF9.us := KDF9.us'Last;
   430.          completion_time : KDF9.us := KDF9.us'Last;
   431.          priority_level  : KDF9.priority;
   432.          control_word    : KDF9.Q_register;
   433.          decoded_order   : KDF9.decoded_order;
   434.          device_name     : IOC.device_name;
   435.          order_address   : KDF9.syllable_address;
   436.          order_count     : KDF9.order_counter;
   437.          stream          : host_IO.stream;
   438.       end record;
   439.
   440.    overriding
   441.    procedure Initialize (the_buffer : in out IOC.device);
   442.
   443.    procedure open (the_buffer : in out IOC.device'Class;
   444.                    the_mode   : in POSIX.access_mode);
   445.
   446.    overriding
   447.    procedure Finalize (the_buffer : in out IOC.device)
   448.       with Inline => False;
   449.
   450.    -- Operations, used only within the IOC hierarchy, that apply to all device types.
   451.
   452.    -- Check that the buffer for the_device is unused, then set it to the_device.
   453.    procedure install (the_device : in out IOC.device'Class);
   454.
   455.    -- LIV if the_buffer is in the abnormal state.
   456.    procedure validate_parity (the_buffer : in IOC.device'Class)
   457.       with Inline => False;
   458.
   459.    -- Check that the_buffer is online, and that access to it is permitted; LIV if not.
   460.    procedure validate_device (the_buffer : in IOC.device'Class)
   461.       with Inline => False;
   462.
   463.    -- Check that the device and the transfer address bounds are valid;
   464.    --    LIV if not.
   465.    procedure validate_transfer (the_buffer : in IOC.device'Class;
   466.                                 Q_operand  : in KDF9.Q_register);
   467.
   468.    -- When the real duration of a variable-length transfer is known,
   469.    --    its completion time can be made accurate by giving its actual_time.
   470.    -- correct_transfer_time must be called before finalize_transfer is called.
   471.    procedure correct_transfer_time (the_buffer  : in out IOC.device'Class;
   472.                                     actual_time : in KDF9.us);
   473.
   474.    procedure correct_transfer_time (the_buffer    : in out IOC.device'Class;
   475.                                     actual_length : in KDF9.word);
   476.
   477.    -- LIV if the repetition count is negative.
   478.    procedure require_nonnegative_count (count : in KDF9.Q_part);
   479.
   480.    -- LIV if the repetition count is negative or zero.
   481.    procedure require_positive_count (count : in KDF9.Q_part);
   482.
   483.    -- Account for the CPU time taken by the buffer in setting store lockouts.
   484.    procedure add_in_the_IO_lockout_CPU_time (Q_operand : in KDF9.Q_register);
   485.
   486.    -- These are handy to have in the child packages.
   487.    NUL : constant Character := Character'Val(0);
   488.    BEL : constant Character := Character'Val(7);
   489.    HT  : constant Character := Character'Val(9);
   490.    LF  : constant Character := Character'Val (10);
   491.    FF  : constant Character := Character'Val (12);
   492.    ESC : constant Character := Character'Val (27);
   493.    SP  : constant Character := ' ';
   494.    DEL : constant Character := Character'Val (127);
   495.
   496. end IOC;

 899 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-equipment.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:07:59

     1. -- Data supporting the definition of a KDF9 I/O equipment configuration.
     2. --
     3. --
     4. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with IOC.absent;
    19. with IOC.fast.DR;
    20. with IOC.fast.FD;
    21. with IOC.fast.tape;
    22. with IOC.slow.shift.FW;
    23. with IOC.slow.shift.GP;
    24. with IOC.slow.shift.SI;
    25. with IOC.slow.shift.TP;
    26. with IOC.slow.shift.TR;
    27. with IOC.slow.unit.CP;
    28. with IOC.slow.unit.CR;
    29. with IOC.slow.unit.LP;
    30. with settings;
    31.
    32. package body IOC.equipment is
    33.
    34.    procedure configure_the_IOC is
    35.    begin
    36.       for b in KDF9.buffer_number loop
    37.          case equipment.choice(b) is
    38.             when AD => IOC.absent.enable(b);
    39.             when CP => IOC.slow.unit.CP.enable(b);
    40.             when CR => IOC.slow.unit.CR.enable(b);
    41.             when DR => IOC.fast.DR.enable(b);
    42.             when FD => IOC.fast.FD.enable(b);
    43.             when FW => IOC.slow.shift.FW.enable(b);
    44.             when GP => IOC.slow.shift.TP.remove_from_buffer(b);
    45.                        IOC.slow.shift.GP.enable(b);
    46.             when LP => IOC.slow.unit.LP.enable(b);
    47.             when MT => IOC.fast.tape.enable_MT_deck(b);
    48.             when SI => IOC.slow.shift.SI.enable(b);
    49.             when ST => IOC.fast.tape.enable_ST_deck(b);
    50.             when TP => IOC.slow.shift.TP.enable(b);
    51.             when TR => IOC.slow.shift.TR.enable(b);
    52.          end case;
    53.          if buffer(b) = null then
    54.             IOC.absent.enable(b);
    55.          end if;
    56.       end loop;
    57.       -- By this point every buffer must have an attached device.
    58.       if IOC.buffer(0).kind /= IOC.FW_kind then
    59.          trap_operator_error("buffer #00 must be a FW");
    60.       end if;
    61.       if IOC.buffer(1).kind /= IOC.TR_kind then
    62.          trap_operator_error("buffer #01 must be a TR");
    63.       end if;
    64.    end configure_the_IOC;
    65.
    66.    procedure revise_the_IOC_configuration is
    67.    begin
    68.       -- By this point every buffer has a device which should be removed before it is replaced.
    69.       for b in equipment.choice'Range loop
    70.          case equipment.choice(b) is
    71.             when DR => IOC.fast.FD.remove_from_buffer(b);
    72.                        IOC.fast.DR.replace_on_buffer(b);
    73.             when FD => IOC.fast.DR.remove_from_buffer(b);
    74.                        IOC.fast.FD.replace_on_buffer(b);
    75.             when GP => if buffer(b).device_name = "TP1" then
    76.                           IOC.slow.shift.TP.remove_from_buffer(b);
    77.                           IOC.slow.shift.GP.replace_on_buffer(b);
    78.                        end if;
    79.             when SI => IOC.slow.shift.SI.replace_on_buffer(b);
    80.             when others => null;
    81.          end case;
    82.       end loop;
    83.    end revise_the_IOC_configuration;
    84.
    85. end IOC.equipment;

Compiling: ../Source/ioc-equipment.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:07:59

     1. -- Enable the devices included in the chosen KDF9 I/O configuration.
     2. --
     3. --
     4. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with KDF9;
    19.
    20. package IOC.equipment is
    21.
    22.    -- These variables are used in the emulation of OUT 5.
    23.    -- They are set to the device buffer number at the start of each run by configure_the_IOC.
    24.    -- A value of 0 indicates that the device is not included in the configuration for the run.
    25.    -- Fast devices are not allocated by this mechanism and so do not appear here.
    26.
    27.    CP0_number  : KDF9.buffer_number := 0;
    28.    CP1_number  : KDF9.buffer_number := 0;
    29.    CR0_number  : KDF9.buffer_number := 0;
    30.    CR1_number  : KDF9.buffer_number := 0;
    31.    GP0_number  : KDF9.buffer_number := 0;
    32.    LP0_number  : KDF9.buffer_number := 0;
    33.    LP1_number  : KDF9.buffer_number := 0;
    34.    SI0_number  : KDF9.buffer_number := 0;
    35.    SI1_number  : KDF9.buffer_number := 0;
    36.    TP0_number  : KDF9.buffer_number := 0;
    37.    TP1_number  : KDF9.buffer_number := 0;
    38.    TR0_number  : KDF9.buffer_number := 0;
    39.    TR1_number  : KDF9.buffer_number := 0;
    40.
    41.    type kind   is (AD, CP, CR, DR, FD, FW, GP, LP, MT, SI, ST, TP, TR);
    42.
    43.    type setup  is array (KDF9.buffer_number) of equipment.kind;
    44.
    45.    -- These are the buffer numbers for the devices in the default configuration.
    46.    -- The Fixed Disc drive was on buffer 14 (#16) of Eldon 2 KDF9s, so I adopt that here.
    47.
    48.    FW0_default : constant KDF9.buffer_number := 0;
    49.    TR0_default : constant KDF9.buffer_number := 1;
    50.    TR1_default : constant KDF9.buffer_number := 2;
    51.    TP0_default : constant KDF9.buffer_number := 3;
    52.    TP1_default : constant KDF9.buffer_number := 4;
    53.    LP0_default : constant KDF9.buffer_number := 5;
    54.    CR0_default : constant KDF9.buffer_number := 6;
    55.    CP0_default : constant KDF9.buffer_number := 7;
    56.    MT0_default : constant KDF9.buffer_number := 8;
    57.    MT1_default : constant KDF9.buffer_number := 9;
    58.    MT2_default : constant KDF9.buffer_number := 10;
    59.    MT3_default : constant KDF9.buffer_number := 11;
    60.    MT4_default : constant KDF9.buffer_number := 12;
    61.    MT5_default : constant KDF9.buffer_number := 13;
    62.    DR0_default : constant KDF9.buffer_number := 14;
    63.    FD0_default : constant KDF9.buffer_number := 14;
    64.    ST0_default : constant KDF9.buffer_number := 15;
    65.
    66.    default : constant equipment.setup
    67.            := (
    68.                CP0_default => CP,
    69.                CR0_default => CR,
    70.                FD0_default => FD,
    71.                FW0_default => FW,
    72.                LP0_default => LP,
    73.                MT0_default => MT,
    74.                MT1_default => MT,
    75.                MT2_default => MT,
    76.                MT3_default => MT,
    77.                MT4_default => MT,
    78.                MT5_default => MT,
    79.                ST0_default => ST,
    80.                TP0_default => TP,
    81.                TP1_default => TP,
    82.                TR0_default => TR,
    83.                TR1_default => TR
    84.               );
    85.
    86.    choice  : equipment.setup := default;
    87.
    88.    -- Attach the chosen devices to their buffers.
    89.    procedure configure_the_IOC;
    90.
    91.    -- If a drum, disc or BSI has been enabled on the command line, make sure it is installed.
    92.    procedure revise_the_IOC_configuration;
    93.
    94. end IOC.equipment;

 85 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:07:59

     1. -- Emulation of the common functionality of a KDF9 "slow", byte-by-byte, devices.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with HCI;
    18. with OS_specifics;
    19. with imported_value_of;
    20.
    21. use HCI;
    22.
    23. package body IOC.slow is
    24.
    25.    overriding
    26.    function is_open (the_buffer : slow.device)
    27.    return Boolean
    28.    is (the_buffer.stream.is_open);
    29.
    30.    overriding
    31.    procedure add_in_the_IO_CPU_time (the_buffer  : in slow.device;
    32.                                      bytes_moved : in KDF9.word) is
    33.       pragma Unreferenced(the_buffer);
    34.    begin
    35.       the_CPU_delta := the_CPU_delta + KDF9.us(bytes_moved) * 6; -- 6s/char
    36.    end add_in_the_IO_CPU_time;
    37.
    38.    procedure display_device_usage (the_buffer  : in slow.device;
    39.                                    the_action  : in String;
    40.                                    the_amount  : in KDF9.word;
    41.                                    the_quantum : in String) is
    42.    begin
    43.          if the_final_state_is_wanted and then
    44.                the_log_is_wanted      and then
    45.                   the_buffer.is_open  and then
    46.                the_amount /= 0            then
    47.          if (the_buffer.number = 0) and not (API_logging_is_wanted or the_log_is_wanted) then
    48.             -- Take a new line at the head of the list, for low-visibility modes.
    49.             log_new_line;
    50.          end if;
    51.          log_line(
    52.                   the_buffer.device_name
    53.                 + "on buffer #"
    54.                 & oct_of(KDF9.Q_part(the_buffer.number), 2)
    55.                 + the_action
    56.                 & the_amount'Image
    57.                 + the_quantum
    58.                 & "."
    59.                  );
    60.       end if;
    61.    end display_device_usage;
    62.
    63.    procedure close (the_buffer  : in out slow.device;
    64.                     the_action  : in String;
    65.                     the_amount  : in KDF9.word;
    66.                     the_quantum : in String) is
    67.    begin
    68.       display_device_usage (the_buffer, the_action, the_amount, the_quantum);
    69.       IOC.device(the_buffer).close;
    70.    end close;
    71.
    72.    function atomic_item_count (the_buffer : slow.device;
    73.                                Q_operand  : KDF9.Q_register)
    74.    return KDF9.word is
    75.       words : constant KDF9.Q_part := Q_operand.M - Q_operand.I + 1;
    76.    begin
    77.       if the_buffer.is_open then
    78.          return KDF9.word(words) * 8;
    79.       else
    80.          return 0;
    81.       end if;
    82.    end atomic_item_count;
    83.
    84.    procedure reattach (the_buffer   : in out slow.device;
    85.                        the_file     : in String) is
    86.    begin
    87.       reattach(the_buffer.stream, the_file, read_mode);
    88.    end reattach;
    89.
    90.    procedure deal_with_end_of_data (the_buffer : in out slow.device) is
    91.
    92.       procedure reattach_the_text_file (name : in String) is
    93.       begin
    94.          if name = "" then
    95.             the_buffer.is_abnormal := True;
    96.             raise end_of_stream;
    97.          elsif exists(name) then
    98.             reattach(the_buffer, name);
    99.             return;
   100.          elsif exists(name & ".txt") then
   101.             reattach(the_buffer, name & ".txt");
   102.             return;
   103.          else
   104.             raise operator_error;
   105.          end if;
   106.       end reattach_the_text_file;
   107.
   108.       response : response_kind;
   109.       inline   : Boolean;
   110.
   111.    begin
   112.       output_line(BEL & "");
   113.       output_line("ee9: End of given data for" + the_buffer.device_name & ".");
   114.       loop
   115.          POSIX.data_prompt
   116.             (
   117.              noninteractive_usage_is_enabled,
   118.              "Type @ or / to name a file, = to type the data, ENTER key for EOF, Q or q to quit",
   119.              response,
   120.              inline
   121.             );
   122.          case response is
   123.             when wrong_response
   124.                | debug_response =>
   125.                null;  -- repeat the prompt
   126.             when LF_response
   127.                | EOF_response =>
   128.                if response = EOF_response then
   129.                   -- Need to take a new line after ^D to preserve the format.
   130.                   output_line;
   131.                end if;
   132.                the_buffer.is_abnormal := True;
   133.                raise end_of_stream;
   134.             when quit_response =>
   135.                raise quit_request with "quit requested";
   136.             when here_response =>
   137.                reattach(the_buffer, OS_specifics.UI_in_name);
   138.                the_buffer.is_reading_a_file := False;
   139.                return;
   140.             when at_response =>
   141.                declare
   142.                   here : constant String := imported_value_of("KDF9_DATA", default => "Data") & "/";
   143.                   next : constant String
   144.                      := next_file_name(BEL & "Give the name of a file in" + here, inline);
   145.                   this : constant String := here & next;
   146.                begin
   147.                   if next = "" then
   148.                      raise operator_error;
   149.                   end if;
   150.                   reattach_the_text_file(this);
   151.                   return;
   152.                exception
   153.                   when operator_error =>
   154.                      output_line(BEL & "ee9: The file" + abs this + "could not be found.");
   155.                end;
   156.             when path_response =>
   157.                declare
   158.                   next : constant String
   159.                        := next_file_name(BEL & "Give the pathname of the file", inline);
   160.                begin
   161.                   if next = "" then
   162.                      raise operator_error;
   163.                   end if;
   164.                   reattach_the_text_file(next);
   165.                   return;
   166.                exception
   167.                   when operator_error =>
   168.                      output_line(BEL & "ee9: The file" + abs next + "could not be found.");
   169.                end;
   170.          end case;
   171.       end loop;
   172.    end deal_with_end_of_data;
   173.
   174.    procedure start_slow_transfer (the_buffer   : in out slow.device;
   175.                                   Q_operand    : in KDF9.Q_register;
   176.                                   set_offline  : in Boolean;
   177.                                   operation    : in IOC.transfer_kind := some_other_operation) is
   178.       atomic_items : constant KDF9.word := atomic_item_count(the_buffer, Q_operand);
   179.       time_needed  : constant KDF9.us := IO_elapsed_time(the_buffer, atomic_items);
   180.    begin
   181.       start_data_transfer(the_buffer, Q_operand, set_offline,
   182.                           busy_time => time_needed,
   183.                           operation => start_slow_transfer.operation);
   184.    end start_slow_transfer;
   185.
   186.    procedure get_char_from_stream (char       : out Character;
   187.                                    the_buffer : in out slow.device) is
   188.    begin
   189.       loop
   190.          begin
   191.             get_char(char, the_buffer.stream);
   192.             return;
   193.          exception
   194.             when end_of_stream =>
   195.                deal_with_end_of_data(the_buffer);
   196.          end;
   197.       end loop;
   198.    end get_char_from_stream;
   199.
   200. end IOC.slow;

Compiling: ../Source/ioc-slow.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:07:59

     1. -- Emulation of the common functionality of a KDF9 "slow", i.e. byte-by-byte, devices.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. private with IOC.equipment;
    18. private with tracing;
    19.
    20. package IOC.slow is
    21.
    22.    --
    23.    -- This is the root type for all slow I/O device types.
    24.    --
    25.
    26.    type device is abstract new IOC.device with private;
    27.
    28.    -- Log the usage statistics for the device on the buffer.
    29.    procedure display_device_usage (the_buffer  : in slow.device;
    30.                                    the_action  : in String;
    31.                                    the_amount  : in KDF9.word;
    32.                                    the_quantum : in String);
    33.
    34.    -- Change the file associated with a device.
    35.    procedure reattach (the_buffer : in out slow.device;
    36.                        the_file   : in String);
    37.
    38. private
    39.
    40.    use IOC.equipment; pragma Warnings(Off, IOC.equipment);
    41.    use tracing;       pragma Warnings(Off, tracing);
    42.
    43.    type device is abstract new IOC.device with
    44.       record
    45.          is_transcribing   : Boolean := True;
    46.          is_reading_a_file : Boolean := True;
    47.          byte_count        : KDF9.word := 0;
    48.       end record;
    49.
    50.    overriding
    51.    function is_open (the_buffer : slow.device)
    52.    return Boolean;
    53.
    54.    overriding
    55.    procedure add_in_the_IO_CPU_time (the_buffer  : in slow.device;
    56.                                      bytes_moved : in KDF9.word);
    57.
    58.    -- Optionally log an activity message for the device; close its I/O stream.
    59.    procedure close (the_buffer  : in out slow.device;
    60.                     the_action  : in String;
    61.                     the_amount  : in KDF9.word;
    62.                     the_quantum : in String);
    63.
    64.    -- The number of timed transfer units in the designated core-store area.
    65.    -- In the case of unit-record devices, such as card readers and line printers,
    66.    --    this is the number of unit records (cards, or lines, respectively).
    67.    -- In all other cases it is the number of characters in the designated core-store area.
    68.    function atomic_item_count (the_buffer : slow.device;
    69.                                Q_operand  : KDF9.Q_register)
    70.    return KDF9.word;
    71.
    72.    -- Check the IO parameters and the buffer state, and handle any old lockout.
    73.    -- Set the new buffer state, and project the next interrupt time.
    74.    procedure start_slow_transfer (the_buffer   : in out slow.device;
    75.                                   Q_operand    : in KDF9.Q_register;
    76.                                   set_offline  : in Boolean;
    77.                                   operation    : in IOC.transfer_kind := some_other_operation);
    78.
    79.    procedure deal_with_end_of_data (the_buffer : in out slow.device);
    80.
    81.    -- Read a raw byte from the stream and deal with any input file concatenation.
    82.    procedure get_char_from_stream (char       : out Character;
    83.                                    the_buffer : in out slow.device);
    84.
    85. end IOC.slow;

 200 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:07:59

     1. -- Emulation of the common functionality of a 2-case (Normal/Shift) buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets.framed;
    18.
    19. package body IOC.slow.shift is
    20.
    21.    use KDF9_char_sets;
    22.
    23.    overriding
    24.    procedure Initialize (the_device : in out shift.device) is
    25.    begin
    26.       -- Open the associated file.
    27.       open(the_device, read_mode);
    28.    end Initialize;
    29.
    30.    procedure do_input_housekeeping (the_device : in out shift.device;
    31.                                     read_in,
    32.                                     stored     : in KDF9.word) is
    33.    begin
    34.       add_in_the_IO_CPU_time(the_device, stored);
    35.       correct_transfer_time(the_device, read_in);
    36.       the_device.byte_count := the_device.byte_count + read_in;
    37.    end do_input_housekeeping;
    38.
    39.    procedure get_symbols (the_device    : in out shift.device;
    40.                           Q_operand     : in KDF9.Q_register;
    41.                           reading_to_EM : in Boolean) is
    42.       start_address : constant KDF9.address := Q_operand.I;
    43.       end_address   : constant KDF9.address := Q_operand.M;
    44.       fill   : KDF9.word := 0;
    45.       size   : KDF9.word := 0;
    46.       symbol : KDF9_char_sets.symbol;
    47.       char   : Character;
    48.    begin
    49.       check_addresses_and_lockouts(start_address, end_address);
    50.    word_loop:
    51.       for w in start_address .. end_address loop
    52.          store_word(0, w);
    53.          for c in KDF9_char_sets.symbol_index'Range loop
    54.             get_char_from_stream(char, the_device);
    55.             size := size + 1;
    56.             if char = KDF9_char_sets.W_F then
    57.                -- Filler was suppressed on normal input from the slow devices.
    58.                fill := fill + 1;
    59.             elsif case_of(char) /= both                   and then
    60.                      case_of(char) /= the_device.current_case then
    61.                store_symbol(CN_TR(next_case(the_device.current_case)), w, c);
    62.                the_device.current_case := the_device.current_case xor 1;
    63.                back_off(the_device.stream);
    64.             else
    65.                symbol := CN_TR(char) or CS_TR(char);
    66.                store_symbol(symbol, w, c);
    67.                if reading_to_EM and symbol = KDF9_char_sets.End_Message then
    68.                   for d in 1 .. 7-c loop
    69.                      store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
    70.                   end loop;
    71.                   exit word_loop;
    72.                end if;
    73.             end if;
    74.          end loop;
    75.       end loop word_loop;
    76.       do_input_housekeeping(the_device, read_in => size, stored => size-fill);
    77.    exception
    78.       when end_of_stream =>
    79.          flush(the_device.stream);
    80.          do_input_housekeeping(the_device, read_in => size, stored => size-fill);
    81.    end get_symbols;
    82.
    83.    procedure read (the_device : in out shift.device;
    84.                    Q_operand  : in KDF9.Q_register) is
    85.    begin
    86.       get_symbols(the_device, Q_operand, reading_to_EM => False);
    87.    end read;
    88.
    89.    procedure read_to_EM (the_device : in out shift.device;
    90.                          Q_operand  : in KDF9.Q_register) is
    91.    begin
    92.       get_symbols(the_device, Q_operand, reading_to_EM => True);
    93.    end read_to_EM;
    94.
    95.    procedure get_frame_from_stream (frame      : out Character;
    96.                                     the_device : in out shift.device) is
    97.    begin
    98.       loop
    99.          begin
   100.             get_byte(frame, the_device.stream);
   101.             if the_device.is_reading_a_file then
   102.                -- Assume file, in KDF9 paper tape code, contains all needed shift characters.
   103.                return;
   104.             end if;
   105.             -- Reading from the terminal, the frame is in Latin-1 and must be converted.
   106.             -- This may entail interpolating a shift character.
   107.             if case_of(frame) not in both | the_device.current_case then
   108.                frame := framed(CN_TR(next_case(the_device.current_case)));
   109.                the_device.current_case := the_device.current_case xor 1;
   110.                back_off(the_device.stream);
   111.             elsif the_device.current_case = KDF9_char_sets.Case_Normal then
   112.                frame := framed(CN_TR(frame));
   113.             else
   114.                frame := framed(CS_TR(frame));
   115.             end if;
   116.             return;
   117.          exception
   118.             when end_of_stream =>
   119.                deal_with_end_of_data(the_device);
   120.          end;
   121.       end loop;
   122.    end get_frame_from_stream;
   123.
   124.    procedure get_words (the_device    : in out shift.device;
   125.                         Q_operand     : in KDF9.Q_register;
   126.                         reading_to_EM : in Boolean) is
   127.
   128.       function reframed (byte : Character)
   129.       return KDF9.word is
   130.          data : KDF9.word;
   131.       begin -- reframed
   132.          -- Permute the paper tape frame bits to make a data byte, see the Manual,  17.7, pp. 137-138.
   133.          -- This is the converse of put_words.reframed.
   134.          data := KDF9.word(Character'Pos(byte));
   135.          return  (data and 2#0000_1111#)    -- D44-D47 -> D44-D47
   136.               or (data and 2#0110_0000#)/2  -- D41-D42 -> D42-D43
   137.               or (data and 2#0001_0000#)*4  -- D43     -> D41
   138.               or (data and 2#1000_0000#);   -- D40     -> D40
   139.       end reframed;
   140.
   141.       start_address : constant KDF9.address := Q_operand.I;
   142.       end_address : constant KDF9.address := Q_operand.M;
   143.       size        : KDF9.word := 0;
   144.       word        : KDF9.word;
   145.       done        : Boolean;
   146.       char        : Character;
   147.
   148.    begin -- get_words
   149.       check_addresses_and_lockouts(start_address, end_address);
   150.       for w in start_address .. end_address loop
   151.          if the_device.is_transcribing then
   152.             -- "transcribing" actually means "transparent" for character mode input.
   153.             get_char_from_stream(char, the_device);
   154.             word := KDF9.word(Character'Pos(char));
   155.             done := char = E_M;
   156.          else
   157.             -- KDF9 mode.
   158.             get_frame_from_stream(char, the_device);
   159.             word := reframed(char);
   160.             done := KDF9_char_sets.symbol(word and 8#77#) = End_Message;
   161.          end if;
   162.          store_word(word, w);
   163.          size := size + 1;
   164.       exit when reading_to_EM and done;
   165.       end loop;
   166.       do_input_housekeeping(the_device, read_in => size, stored => size);
   167.    exception
   168.       when end_of_stream =>
   169.          flush(the_device.stream);
   170.          do_input_housekeeping(the_device, read_in => size, stored => size);
   171.    end get_words;
   172.
   173.    procedure words_read (the_device : in out shift.device;
   174.                          Q_operand  : in KDF9.Q_register) is
   175.    begin
   176.       get_words(the_device, Q_operand, reading_to_EM => False);
   177.    end words_read;
   178.
   179.    procedure words_read_to_EM (the_device : in out shift.device;
   180.                                Q_operand  : in KDF9.Q_register) is
   181.    begin
   182.       get_words(the_device, Q_operand, reading_to_EM => True);
   183.    end words_read_to_EM;
   184.
   185.    procedure put_symbols (the_device    : in out shift.device;
   186.                           Q_operand     : in KDF9.Q_register;
   187.                           writing_to_EM : in Boolean) is
   188.       start_address : constant KDF9.address := Q_operand.I;
   189.       end_address   : constant KDF9.address := Q_operand.M;
   190.       fill   : KDF9.word := 0;
   191.       size   : KDF9.word := 0;
   192.       symbol : KDF9_char_sets.symbol;
   193.       char   : Character;
   194.    begin
   195.       check_addresses_and_lockouts(start_address, end_address);
   196.    word_loop:
   197.       for w in start_address .. end_address loop
   198.          for c in KDF9_char_sets.symbol_index'Range loop
   199.             symbol := fetch_symbol(w, c);
   200.             size := size + 1;
   201.             if symbol = KDF9_char_sets.Word_Filler then
   202.                -- Filler was suppressed on normal output to the slow devices.
   203.                fill := fill + 1;
   204.             elsif symbol = KDF9_char_sets.Case_Shift then
   205.                the_device.current_case := KDF9_char_sets.Case_Shift;
   206.             elsif  symbol = KDF9_char_sets.Case_Normal then
   207.                the_device.current_case := KDF9_char_sets.Case_Normal;
   208.             else
   209.                if the_device.current_case = KDF9_char_sets.Case_Normal then
   210.                   char := TP_CN(symbol);
   211.                else
   212.                   char := TP_CS(symbol);
   213.                end if;
   214.                put_char(char, the_device.stream);
   215.                exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
   216.             end if;
   217.          end loop;
   218.       end loop word_loop;
   219.       do_output_housekeeping(the_device, written => size-fill, fetched => size);
   220.    exception
   221.       when end_of_stream =>
   222.          do_output_housekeeping(the_device, written => size-fill, fetched => size);
   223.    end put_symbols;
   224.
   225.    procedure write (the_device : in out shift.device;
   226.                     Q_operand  : in KDF9.Q_register) is
   227.    begin
   228.       put_symbols(the_device, Q_operand, writing_to_EM => False);
   229.    end write;
   230.
   231.    procedure write_to_EM (the_device : in out shift.device;
   232.                           Q_operand  : in KDF9.Q_register) is
   233.    begin
   234.       put_symbols(the_device, Q_operand, writing_to_EM => True);
   235.    end write_to_EM;
   236.
   237.    procedure put_words (the_device    : in out shift.device;
   238.                         Q_operand     : in KDF9.Q_register;
   239.                         writing_to_EM : in Boolean) is
   240.
   241.       function reframed (byte : Character)
   242.       return Character is
   243.          data : KDF9.word:= KDF9.word(Character'Pos(byte));
   244.       begin -- reframed
   245.          -- Permute the data bits to make a paper tape frame, see the Manual,  17.7, pp. 137-138.
   246.          -- This is the converse of get_words.reframed.
   247.          data := (data and 2#0000_1111#)    -- D44-D47 -> D44-D47
   248.               or (data and 2#0011_0000#)*2  -- D42-D43 -> D41-D42
   249.               or (data and 2#0100_0000#)/4  -- D41     -> D43
   250.               or (data and 2#1000_0000#);   -- D40     -> D40
   251.          return Character'Val(Natural(data));
   252.       end reframed;
   253.
   254.       start_address : constant KDF9.address := Q_operand.I;
   255.       end_address   : constant KDF9.address := Q_operand.M;
   256.       size : KDF9.word := 0;
   257.       done : Boolean;
   258.       char : Character;
   259.
   260.    begin -- put_words
   261.       check_addresses_and_lockouts(start_address, end_address);
   262.       for w in start_address .. end_address loop
   263.          char := Character'Val(fetch_word(w) and 8#377#);
   264.          if the_device.is_transcribing then
   265.             -- "transcribing" actually means "transparent Latin-1" for character mode transfers.
   266.             done := char = E_M;
   267.          else
   268.             -- KDF9 mode.
   269.             char := reframed(char);
   270.             done := KDF9_char_sets.symbol(Character'Pos(char) mod 64) = End_Message;
   271.          end if;
   272.          put_byte(char, the_device.stream);
   273.          size := size + 1;
   274.       exit when writing_to_EM and done;
   275.       end loop;
   276.       do_output_housekeeping(the_device, written => size, fetched => size);
   277.    end put_words;
   278.
   279.    procedure words_write (the_device : in out shift.device;
   280.                           Q_operand  : in KDF9.Q_register) is
   281.    begin
   282.       put_words(the_device, Q_operand, writing_to_EM => False);
   283.    end words_write;
   284.
   285.    procedure words_write_to_EM (the_device : in out shift.device;
   286.                                 Q_operand  : in KDF9.Q_register) is
   287.    begin
   288.       put_words(the_device, Q_operand, writing_to_EM => True);
   289.    end words_write_to_EM;
   290.
   291.    procedure output_a_gap (the_device   : in out shift.device;
   292.                            Q_operand    : in KDF9.Q_register;
   293.                            set_offline  : in Boolean;
   294.                            word_mode    : in Boolean := False;
   295.                            text_mode    : in Boolean := False) is
   296.       length : constant KDF9.word :=  KDF9.word(Q_operand.M) * (if word_mode then 8 else 1);
   297.       char   : constant Character := Character'Val(0);
   298.       size   : KDF9.word := 0;
   299.    begin
   300.       require_positive_count(Q_operand.M);
   301.       for i in 1 .. length loop
   302.          size := size + 1;
   303.          if text_mode then
   304.             do_not_put_byte(char, the_device.stream);
   305.          else
   306.             put_byte(char, the_device.stream);
   307.          end if;
   308.       end loop;
   309.       start_data_transfer(
   310.                           the_device,
   311.                           (Q_operand.C, 0, Q_operand.M),
   312.                           set_offline,
   313.                           busy_time => IO_elapsed_time(the_device, length)
   314.                          );
   315.       do_output_housekeeping(the_device, written => length, fetched => 0);
   316.    exception
   317.       when end_of_stream =>
   318.          do_output_housekeeping(the_device, written => size, fetched => 0);
   319.    end output_a_gap;
   320.
   321.    procedure do_output_housekeeping (the_device : in out shift.device;
   322.                                      written,
   323.                                      fetched    : in KDF9.word) is
   324.    begin
   325.       flush(the_device.stream);
   326.       add_in_the_IO_CPU_time(the_device, fetched);
   327.       correct_transfer_time(the_device, written);
   328.       the_device.byte_count := the_device.byte_count + fetched;
   329.    end do_output_housekeeping;
   330.
   331.    procedure set_case (the_device  : in out shift.device;
   332.                        the_setting : in KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal) is
   333.    begin
   334.       the_device.current_case := the_setting;
   335.    end set_case;
   336.
   337.    function uses_Latin_1 (the_device : in shift.device)
   338.    return Boolean
   339.    is (the_device.is_transcribing);
   340.
   341.    overriding
   342.    procedure Finalize (the_device : in out shift.device) is
   343.    begin
   344.       close(
   345.             the_device,
   346.             "transferred",
   347.             the_device.byte_count,
   348.             "character" & plurality(the_device.byte_count)
   349.            );
   350.    end Finalize;
   351.
   352. end IOC.slow.shift;

Compiling: ../Source/ioc-slow-shift.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:07:59

     1. -- Emulation of the common functionality of a 2-case (Normal/Shift) buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18.
    19. use  KDF9_char_sets;
    20.
    21. package IOC.slow.shift is
    22.
    23.    --
    24.    -- Abstract common functionality of Case Normal / Case Shift devices, i.e.,
    25.    --    the BSI interface (SI) paper tape reader (TR), punch (TP) and console Flexowriter (FW).
    26.    --
    27.
    28.    type device is abstract new IOC.slow.device with private;
    29.
    30.    procedure set_case (the_device  : in out shift.device;
    31.                        the_setting : in KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal);
    32.
    33.    function uses_Latin_1 (the_device : in shift.device)
    34.    return Boolean;
    35.
    36.    -- Read a character from the stream and deal with any input file concatenation.
    37.    -- If the buffer is reading from a file, deliver the character found; otherwise:
    38.    --    convert the character from Latin-1 to the corresponding paper tape 8-bit code frame.
    39.    procedure get_frame_from_stream (frame      : out Character;
    40.                                     the_device : in out shift.device);
    41.
    42. private
    43.
    44.    type device is abstract new IOC.slow.device with
    45.       record
    46.          current_case : KDF9_char_sets.letter_case := KDF9_char_sets.Case_Normal;
    47.       end record;
    48.
    49.    overriding
    50.    procedure Finalize (the_device : in out shift.device);
    51.
    52.    overriding
    53.    procedure Initialize (the_device : in out shift.device);
    54.
    55.    procedure do_input_housekeeping (the_device : in out shift.device;
    56.                                     read_in,
    57.                                     stored     : in KDF9.word);
    58.
    59.    procedure do_output_housekeeping (the_device : in out shift.device;
    60.                                      written,
    61.                                      fetched    : in KDF9.word);
    62.
    63.    procedure write (the_device : in out shift.device;
    64.                     Q_operand  : in KDF9.Q_register);
    65.
    66.    procedure read (the_device : in out shift.device;
    67.                    Q_operand  : in KDF9.Q_register);
    68.
    69.    procedure write_to_EM (the_device : in out shift.device;
    70.                           Q_operand  : in KDF9.Q_register);
    71.
    72.    procedure read_to_EM (the_device : in out shift.device;
    73.                          Q_operand  : in KDF9.Q_register);
    74.
    75.    procedure words_write (the_device : in out shift.device;
    76.                           Q_operand  : in KDF9.Q_register);
    77.
    78.    procedure words_read (the_device : in out shift.device;
    79.                          Q_operand  : in KDF9.Q_register);
    80.
    81.    procedure words_write_to_EM (the_device : in out shift.device;
    82.                                 Q_operand  : in KDF9.Q_register);
    83.
    84.    procedure words_read_to_EM (the_device : in out shift.device;
    85.                                Q_operand  : in KDF9.Q_register);
    86.
    87.    procedure output_a_gap (the_device   : in out shift.device;
    88.                            Q_operand    : in KDF9.Q_register;
    89.                            set_offline  : in Boolean;
    90.                            word_mode    : in Boolean := False;
    91.                            text_mode    : in Boolean := False);
    92.
    93. end IOC.slow.shift;

 352 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-tp.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:07:59

     1. -- Emulation of a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets.framed;
    18.
    19. package body IOC.slow.shift.TP is
    20.
    21.    use KDF9_char_sets;
    22.
    23.    overriding
    24.    procedure Initialize (the_TP : in out TP.device) is
    25.    begin
    26.       open(the_TP, write_mode);
    27.    end Initialize;
    28.
    29.    -- the_T_bit_is_set := (the buffer has been switched from a tape punch to a graph plotter)
    30.    overriding
    31.    procedure PMB (the_TP      : in out TP.device;
    32.                   Q_operand   : in KDF9.Q_register;
    33.                   set_offline : in Boolean) is
    34.    begin
    35.       validate_device(the_TP);
    36.       validate_parity(the_TP);
    37.       deal_with_a_busy_device(the_TP, 13, set_offline);
    38.       the_T_bit_is_set := False;  -- We never get here if GP0 is enabled.
    39.       take_note_of_test(the_TP.device_name, Q_operand, the_T_bit_is_set);
    40.    end PMB;
    41.
    42. --
    43. --
    44.    --
    45.    -- See Manual, 17.4 for paper tape 8-bit frame format.
    46.    --
    47. --
    48. --
    49.
    50.    procedure write_KDF9_tape_code (the_TP        : in out TP.device;
    51.                                    Q_operand     : in KDF9.Q_register;
    52.                                    writing_to_EM : in Boolean := False) is
    53.       start_address : constant KDF9.address := Q_operand.I;
    54.       end_address   : constant KDF9.address := Q_operand.M;
    55.       size   : KDF9.word := 0;
    56.       symbol : KDF9_char_sets.symbol;
    57.       char   : Character;
    58.
    59.    begin -- write_KDF9_tape_code
    60.       check_addresses_and_lockouts(start_address, end_address);
    61.    word_loop:
    62.       for w in start_address .. end_address loop
    63.          for c in KDF9_char_sets.symbol_index'Range loop
    64.             symbol := fetch_symbol(w, c);
    65.             size := size + 1;
    66.             char := framed(symbol);
    67.             put_byte(char, the_TP.stream);
    68.          exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
    69.          end loop;
    70.       end loop word_loop;
    71.       do_output_housekeeping(the_TP, written => size, fetched => size);
    72.    exception
    73.       when end_of_stream =>
    74.          do_output_housekeeping(the_TP, written => size, fetched => size);
    75.    end write_KDF9_tape_code;
    76.
    77.    -- PWQq
    78.    overriding
    79.    procedure POA (the_TP      : in out TP.device;
    80.                   Q_operand   : in KDF9.Q_register;
    81.                   set_offline : in Boolean) is
    82.    begin
    83.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
    84.       if the_TP.is_transcribing then
    85.          write(the_TP, Q_operand);
    86.       else
    87.          write_KDF9_tape_code(the_TP, Q_operand);
    88.       end if;
    89.       lock_out_relative_addresses(Q_operand);
    90.    end POA;
    91.
    92.    -- PWEQq
    93.    overriding
    94.    procedure POB (the_TP      : in out TP.device;
    95.                   Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean) is
    97.    begin
    98.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
    99.       if the_TP.is_transcribing then
   100.          write_to_EM(the_TP, Q_operand);
   101.       else
   102.          write_KDF9_tape_code(the_TP, Q_operand, writing_to_EM => True);
   103.       end if;
   104.       lock_out_relative_addresses(Q_operand);
   105.    end POB;
   106.
   107.    -- PWCQq
   108.    overriding
   109.    procedure POC (the_TP      : in out TP.device;
   110.                   Q_operand   : in KDF9.Q_register;
   111.                   set_offline : in Boolean) is
   112.    begin
   113.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   114.       words_write(the_TP, Q_operand);
   115.       lock_out_relative_addresses(Q_operand);
   116.    end POC;
   117.
   118.    -- PWCEQq
   119.    overriding
   120.    procedure POD (the_TP      : in out TP.device;
   121.                   Q_operand   : in KDF9.Q_register;
   122.                   set_offline : in Boolean) is
   123.    begin
   124.       start_slow_transfer(the_TP, Q_operand, set_offline, output_operation);
   125.       words_write_to_EM(the_TP, Q_operand);
   126.       lock_out_relative_addresses(Q_operand);
   127.    end POD;
   128.
   129.    -- PGAPQq
   130.    overriding
   131.    procedure POE (the_TP      : in out TP.device;
   132.                   Q_operand   : in KDF9.Q_register;
   133.                   set_offline : in Boolean) is
   134.    begin
   135.       require_nonnegative_count(Q_operand.M);
   136.       output_a_gap(
   137.                    the_TP,
   138.                    Q_operand,
   139.                    set_offline,
   140.                    word_mode => False,
   141.                    text_mode => the_TP.is_transcribing
   142.                   );
   143.    end POE;
   144.
   145.    -- "word gap"
   146.    overriding
   147.    procedure POF (the_TP      : in out TP.device;
   148.                   Q_operand   : in KDF9.Q_register;
   149.                   set_offline : in Boolean) is
   150.    begin
   151.       require_nonnegative_count(Q_operand.M);
   152.       output_a_gap(
   153.                    the_TP,
   154.                    Q_operand,
   155.                    set_offline,
   156.                    word_mode => True,
   157.                    text_mode => the_TP.is_transcribing
   158.                   );
   159.    end POF;
   160.
   161.    overriding
   162.    procedure Finalize (the_TP : in out TP.device) is
   163.    begin
   164.       close(
   165.             the_TP,
   166.             "punched",
   167.             the_TP.byte_count,
   168.             "character" & plurality(the_TP.byte_count)
   169.           + "in"
   170.           + (if the_TP.is_transcribing then "Latin-1" else "KDF9")
   171.           + "code"
   172.            );
   173.    end Finalize;
   174.
   175.    type TP_access is access TP.device;
   176.
   177.    TP0  : TP_access with Warnings => Off;
   178.    TP1  : TP_access with Warnings => Off;
   179.
   180.    unit : IOC.unit_number := 0;
   181.
   182.    procedure enable (b : in KDF9.buffer_number) is
   183.    begin
   184.       case unit is
   185.          when 0 =>
   186.             TP0 := new TP.device (number => b, unit => 0);
   187.             TP0_number := b;
   188.          when 1 =>
   189.             TP1 := new TP.device (number => b, unit => 1);
   190.             TP1_number := b;
   191.          when others =>
   192.             trap_operator_error("more than two TP units have been configured");
   193.       end case;
   194.       unit := unit + 1;
   195.    end enable;
   196.
   197.    procedure remove_from_buffer (b : in KDF9.buffer_number) is
   198.    begin
   199.       if TP1 /= null   and then
   200.             TP1.number = b then
   201.          Finalize(TP1.all);
   202.          TP1 := null;
   203.       else
   204.          trap_operator_error("GP0 cannot be configured. TP1 is not on buffer #" & oct_of(b, 2));
   205.       end if;
   206.    end remove_from_buffer;
   207.
   208.    -- Set the character code to be used by the designated TP.
   209.    procedure set_unit_code (unit : in Natural; is_transcribing : in Boolean) is
   210.    begin
   211.       if unit = 0 and then TP0 /= null then
   212.          TP0.is_transcribing := set_unit_code.is_transcribing;
   213.       elsif unit = 1 and then TP1 /= null then
   214.          TP1.is_transcribing := set_unit_code.is_transcribing;
   215.       end if;
   216.    end set_unit_code;
   217.
   218. end IOC.slow.shift.TP;

Compiling: ../Source/ioc-slow-shift-tp.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:07:59

     1. -- Emulation of a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.TP is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    -- PWQq
    22.    overriding
    23.    procedure POA (the_TP      : in out TP.device;
    24.                   Q_operand   : in KDF9.Q_register;
    25.                   set_offline : in Boolean);
    26.
    27.    -- PWEQq
    28.    overriding
    29.    procedure POB (the_TP      : in out TP.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    -- PWCQq
    34.    overriding
    35.    procedure POC (the_TP      : in out TP.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    -- PWCEQq
    40.    overriding
    41.    procedure POD (the_TP      : in out TP.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    -- PGAPQq
    46.    overriding
    47.    procedure POE (the_TP      : in out TP.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- This is called "word gap" in the Manual, but never defined.
    52.    overriding
    53.    procedure POF (the_TP      : in out TP.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- the_T_bit_is_set (the buffer has been switched from a tape punch to a graph plotter)
    58.    overriding
    59.    procedure PMB (the_TP      : in out TP.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    procedure enable (b : in KDF9.buffer_number);
    64.
    65.    -- Finalize TP1 if necessary and remove it from the configuration, to allow GP0 to be attached.
    66.    procedure remove_from_buffer (b : in KDF9.buffer_number);
    67.
    68.    -- Set the character code to be used by the TP unit.
    69.    procedure set_unit_code(unit : in Natural; is_transcribing : in Boolean);
    70.
    71. private
    72.
    73.    type device is new IOC.slow.shift.device with null record;
    74.
    75.    overriding
    76.    procedure Initialize (the_TP : in out TP.device);
    77.
    78.    overriding
    79.    procedure Finalize (the_TP : in out TP.device);
    80.
    81.    overriding
    82.    function kind (the_TP : TP.device)
    83.    return IOC.device_kind
    84.    is (TP_kind);
    85.
    86.    overriding
    87.    function quantum (the_TP : TP.device)
    88.    return KDF9.us
    89.    is (1E6 / 110);
    90.
    91. end IOC.slow.shift.TP;

 218 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/say_goodbye.adb
Source file time stamp: 2022-09-06 16:46:31
Compiled at: 2022-09-15 15:08:00

     1. -- Finalize emulation with a helpful message derived from exception information.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Command_Line;
    18. --
    19. with finalize_ee9;
    20. with HCI;
    21. with settings;
    22. with string_editing;
    23.
    24. use  Ada.Command_Line;
    25. --
    26. use  HCI;
    27. use  settings;
    28. use  string_editing;
    29.
    30. procedure say_goodbye (
    31.                        reason : in String;
    32.                        cause  : in String := "";
    33.                        status : in Exit_Status := Failure
    34.                       ) is
    35.
    36.    function explanation
    37.    return String is
    38.       CR   : constant Character := Character'Val(16#D#);
    39.       LF   : constant Character := Character'Val(16#A#);
    40.       L, R : Natural;
    41.    begin  -- explanation
    42.       if cause'Length < 3 then
    43.          return cause;
    44.       end if;
    45.       L := index_forward(cause, "%", start => cause'First) + 1;
    46.       if cause(cause'Last-1) = CR then
    47.          R := cause'Last - 2;
    48.       elsif cause(cause'Last) in LF | CR then
    49.          R := cause'Last - 1;
    50.       else
    51.          R := cause'Last;
    52.       end if;
    53.       return cause(L .. R);
    54.    end explanation;
    55.
    56. begin  -- say_goodbye
    57.    if the_log_is_wanted then
    58.       log_new_line;
    59.    end if;
    60.    if reason = "" then
    61.       finalize_ee9;
    62.    elsif reason'Length > 2 and then
    63.          reason(reason'Last-2..reason'Last) = "OUT" then
    64.       finalize_ee9(reason + explanation);
    65.    elsif reason'Length = 0 then
    66.       finalize_ee9(explanation);
    67.    elsif explanation'Length = 0 then
    68.       finalize_ee9(reason);
    69.    else
    70.       finalize_ee9(reason & ": " & explanation);
    71.    end if;
    72.    if the_log_is_wanted then
    73.       log_new_line;
    74.    end if;
    75.    Set_Exit_Status(status);
    76. end say_goodbye;

 76 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-tr.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:07:59

     1. -- Emulation of a paper tape reader buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with disassembly.symbols;
    18. with KDF9.TSD.timing;
    19.
    20. use  disassembly.symbols;
    21.
    22. package body IOC.slow.shift.TR is
    23.
    24.    use KDF9_char_sets;
    25.
    26.    overriding
    27.    procedure Initialize (the_TR : in out TR.device) is
    28.    begin
    29.       -- Open the associated file.
    30.       open(IOC.device(the_TR), read_mode);
    31.    end Initialize;
    32.
    33.    --
    34.    -- See Manual, 17.4 for paper tape 8-bit frame format.
    35.    --
    36.
    37.    function has_even_parity (octet : KDF9.syllable)
    38.    return Boolean is
    39.       frame  : KDF9.syllable := octet;
    40.       parity : KDF9.syllable := 0;
    41.    begin
    42.       while frame /= 0 loop
    43.          parity := parity xor (frame and 1);
    44.          frame  := frame / 2;
    45.       end loop;
    46.       return parity = 0;
    47.    end has_even_parity;
    48.
    49.    function symbol_from (octet : KDF9.syllable)
    50.    return KDF9_char_sets.symbol
    51.    is (KDF9_char_sets.symbol((octet and 2#01_100_000#)/2 or (octet and 2#00_001_111#)));
    52.
    53.    DEL_frame : constant := 8#377#;
    54.    NUL_frame : constant := 8#000#;
    55.
    56.    -- Read 8-bit paper tape frames, compress to 6-bit byteacters, and pack into words.
    57.    procedure read_KDF9_tape_code (the_TR        : in out TR.device;
    58.                                   Q_operand     : in KDF9.Q_register;
    59.                                   reading_to_EM,
    60.                                   loading_code  : in Boolean := False) is
    61.       c      : KDF9_char_sets.symbol_index := 0;
    62.       w      : KDF9.Q_part := Q_operand.I;
    63.       size   : KDF9.word := 0;
    64.       octet  : KDF9.syllable;
    65.       symbol : KDF9_char_sets.symbol;
    66.       byte   : Character;
    67.    begin
    68.       check_addresses_and_lockouts(Q_operand.I, Q_operand.M);
    69.    word_loop:
    70.       loop
    71.          loop
    72.             get_frame_from_stream(byte, the_TR);
    73.             octet := KDF9.syllable(Character'Pos(byte));
    74.          exit when octet not in NUL_frame | DEL_frame;
    75.          end loop;
    76.          if has_even_parity(octet) then
    77.             symbol := symbol_from(octet);
    78.          else
    79.             trap_invalid_paper_tape("probably not in KDF9 code (parity error detected)");
    80.          end if;
    81.          store_symbol(symbol, w, c);
    82.          size := size + 1;
    83.          c := c + 1;
    84.          if c = 0 then
    85.       exit word_loop when reading_to_EM and symbol = KDF9_char_sets.End_Message;
    86.             w := w + 1;
    87.       exit word_loop when w > Q_operand.M;
    88.          end if;
    89.          if reading_to_EM and then symbol = KDF9_char_sets.End_Message then
    90.             for d in c .. 7 loop
    91.                store_symbol(KDF9_char_sets.Blank_Space, w, d);
    92.             end loop;
    93.       exit word_loop;
    94.          end if;
    95.       exit word_loop when w > Q_operand.M;
    96.       end loop word_loop;
    97.       if not loading_code then
    98.          do_input_housekeeping(the_TR, read_in => size, stored => size);
    99.       end if;
   100.    exception
   101.       when end_of_stream =>
   102.          if size = 0 then
   103.             trap_invalid_paper_tape("there was no data on the tape");
   104.          end if;
   105.          if not loading_code then
   106.             do_input_housekeeping(the_TR, read_in => size, stored => size);
   107.          end if;
   108.          the_TR.is_abnormal := True;
   109.          if not reading_to_EM and c /= 0 then
   110.             trap_invalid_paper_tape("the last word on the tape was incomplete");
   111.          end if;
   112.    end read_KDF9_tape_code;
   113.
   114.    -- PRQq
   115.    overriding
   116.    procedure PIA (the_TR      : in out TR.device;
   117.                   Q_operand   : in KDF9.Q_register;
   118.                   set_offline : in Boolean) is
   119.    begin
   120.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   121.       if the_TR.is_transcribing then
   122.          read(the_TR, Q_operand);
   123.       else
   124.          read_KDF9_tape_code(the_TR, Q_operand);
   125.       end if;
   126.       lock_out_relative_addresses(Q_operand);
   127.    end PIA;
   128.
   129.    -- PREQq
   130.    overriding
   131.    procedure PIB (the_TR      : in out TR.device;
   132.                   Q_operand   : in KDF9.Q_register;
   133.                   set_offline : in Boolean) is
   134.    begin
   135.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   136.       if the_TR.is_transcribing then
   137.          read_to_EM(the_TR, Q_operand);
   138.       else
   139.          read_KDF9_tape_code(the_TR, Q_operand, reading_to_EM => True);
   140.       end if;
   141.       lock_out_relative_addresses(Q_operand);
   142.    end PIB;
   143.
   144.    -- PRCQq
   145.    overriding
   146.    procedure PIC (the_TR      : in out TR.device;
   147.                   Q_operand   : in KDF9.Q_register;
   148.                   set_offline : in Boolean) is
   149.    begin
   150.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   151.       words_read(the_TR, Q_operand);
   152.       lock_out_relative_addresses(Q_operand);
   153.    end PIC;
   154.
   155.    -- PRCEQq
   156.    overriding
   157.    procedure PID (the_TR      : in out TR.device;
   158.                   Q_operand   : in KDF9.Q_register;
   159.                   set_offline : in Boolean) is
   160.    begin
   161.       start_slow_transfer(the_TR, Q_operand, set_offline, input_operation);
   162.       words_read_to_EM(the_TR, Q_operand);
   163.       lock_out_relative_addresses(Q_operand);
   164.    end PID;
   165.
   166.    -- as PIA
   167.    overriding
   168.    procedure PIE (the_TR      : in out TR.device;
   169.                   Q_operand   : in KDF9.Q_register;
   170.                   set_offline : in Boolean) is
   171.    begin
   172.       PIA(the_TR, Q_operand, set_offline);
   173.    end PIE;
   174.
   175.    -- as PIB
   176.    overriding
   177.    procedure PIF (the_TR      : in out TR.device;
   178.                   Q_operand   : in KDF9.Q_register;
   179.                   set_offline : in Boolean) is
   180.    begin
   181.       PIB(the_TR, Q_operand, set_offline);
   182.    end PIF;
   183.
   184.    -- as PIC
   185.    overriding
   186.    procedure PIG (the_TR      : in out TR.device;
   187.                   Q_operand   : in KDF9.Q_register;
   188.                   set_offline : in Boolean) is
   189.    begin
   190.       PIC(the_TR, Q_operand, set_offline);
   191.    end PIG;
   192.
   193.    -- as PID
   194.    overriding
   195.    procedure PIH (the_TR      : in out TR.device;
   196.                   Q_operand   : in KDF9.Q_register;
   197.                   set_offline : in Boolean) is
   198.    begin
   199.       PID(the_TR, Q_operand, set_offline);
   200.    end PIH;
   201.
   202.    -- the_T_bit_is_set := (the reader is set to 8-track mode);
   203.    --    it is always in 8-track mode, as 5-track input is not supported by ee9.
   204.    overriding
   205.    procedure PMB (the_TR      : in out TR.device;
   206.                   Q_operand   : in KDF9.Q_register;
   207.                   set_offline : in Boolean) is
   208.    begin
   209.       validate_device(the_TR);
   210.       validate_parity(the_TR);
   211.       deal_with_a_busy_device(the_TR, 13, set_offline);
   212.       the_T_bit_is_set := True;
   213.       take_note_of_test(the_TR.device_name, Q_operand, the_T_bit_is_set);
   214.    end PMB;
   215.
   216.    overriding
   217.    procedure Finalize (the_TR : in out TR.device) is
   218.    begin
   219.       close(
   220.             the_TR,
   221.             "read",
   222.             the_TR.byte_count,
   223.             "character" & plurality(the_TR.byte_count)
   224.           + "in"
   225.           + (if the_TR.is_transcribing then "Latin-1" else "KDF9")
   226.           + "code"
   227.            );
   228.    end Finalize;
   229.
   230.    type TR_access is access TR.device;
   231.
   232.    TR0  : TR_access with Warnings => Off;
   233.    TR1  : TR_access with Warnings => Off;
   234.
   235.    unit : IOC.unit_number := 0;
   236.
   237.    procedure enable (b : in KDF9.buffer_number) is
   238.    begin
   239.       case unit is
   240.          when 0 =>
   241.             TR0 := new TR.device (number => b, unit => 0);
   242.             TR0_number := b;
   243.          when 1 =>
   244.             TR1 := new TR.device (number => b, unit => 1);
   245.             TR1_number := b;
   246.          when others =>
   247.             trap_operator_error("more than two TR units have been configured");
   248.       end case;
   249.       unit := unit + 1;
   250.    end enable;
   251.
   252.    -- Set the character code to be used by the designated TR.
   253.    procedure set_unit_code (unit : in Natural; is_transcribing : in Boolean) is
   254.    begin
   255.       if unit = 0 then
   256.          TR0.is_transcribing := set_unit_code.is_transcribing;
   257.       elsif TR1 /= null then
   258.          TR1.is_transcribing := set_unit_code.is_transcribing;
   259.       end if;
   260.    end set_unit_code;
   261.
   262.    --
   263.    -- Support for loading programs and for bootstrapping the KDF9.
   264.    --
   265.
   266.    procedure reattach (unit : in Natural; next_file_name : in String) is
   267.       the_reader  : constant TR_access := (if unit = 0 then TR0 else TR1);
   268.    begin
   269.       reattach(the_reader.all, next_file_name);
   270.       if the_reader.is_open then
   271.          the_reader.current_case := KDF9_char_sets.Case_Normal;
   272.       else
   273.          trap_operator_error(abs next_file_name + "cannot be found");
   274.       end if;
   275.    end reattach;
   276.
   277.    procedure reset_loader_usage (unit : in Natural) is
   278.       the_reader  : constant TR_access := (if unit = 0 then TR0 else TR1);
   279.    begin
   280.       correct_transfer_time(the_reader.all, KDF9.us(0));
   281.       the_reader.byte_count := 0;
   282.       unlock_absolute_addresses((0, 0, 32767));
   283.    end reset_loader_usage;
   284.
   285.    -- This emulates the Director's program load from a designated  paper tape reader.
   286.    -- Once the loading is done, the tape reader is reattached to TR0.
   287.    procedure load_a_program (program_file_name : in String) is
   288.
   289.       -- This is the call sign for a program on Disc or Drum.
   290.       CN_LS_D_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   291.                                       or (KDF9.word(Line_Shift)   * 2**12)
   292.                                       or (KDF9.word(Upper_Case_D) * 2** 6)
   293.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   294.
   295.       -- This is the call sign for a program on Magnetic Tape.
   296.       CN_LS_M_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   297.                                       or (KDF9.word(Line_Shift)   * 2**12)
   298.                                       or (KDF9.word(Upper_Case_M) * 2** 6)
   299.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   300.
   301.       -- This is the call sign for a program on Paper Tape.
   302.       CN_LS_P_LS : constant KDF9.word := (KDF9.word(Case_Normal)  * 2**18)
   303.                                       or (KDF9.word(Line_Shift)   * 2**12)
   304.                                       or (KDF9.word(Upper_Case_P) * 2** 6)
   305.                                       or (KDF9.word(Line_Shift)   * 2** 0);
   306.
   307.       threshold  : constant KDF9.word := 32767 * 2**24;
   308.       substitute : constant KDF9.word := 32736 * 2**24;
   309.       get_a_word : constant KDF9.Q_register := (TR0.number, 0, 0);
   310.
   311.       descriptor : KDF9.Q_register := (TR0.number, 1, 7);
   312.       word_count : Positive := 2;
   313.
   314.    begin -- load_a_program
   315.
   316.       loading_was_successful := False;
   317.
   318.       -- Access the program file as TR0.
   319.       reattach(0, program_file_name);
   320.
   321.       --
   322.       -- For the structure of a compiled program, see Manual 26.3.
   323.       --
   324.
   325.       -- Get the first word of the file into E0: it may start an A block or a B block.
   326.       read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True);
   327.
   328.       -- Check for an A block.  If one is found, check its validity, but otherwise ignore it.
   329.       if fetch_halfword(0, 0)/2**24 in CN_LS_D_LS | CN_LS_M_LS | CN_LS_P_LS then
   330.          -- We have an A block.
   331.          -- The next word completes the program name used by Director.  Ignore it.
   332.          read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True);
   333.
   334.       block_loop:
   335.          -- An A block is at most 8 words long but can end sooner with a word containing EM.
   336.          loop
   337.             word_count := word_count + 1;
   338.          exit block_loop when word_count > 8;
   339.             read_KDF9_tape_code(TR0.all, get_a_word, loading_code => True, reading_to_EM => True);
   340.             for c in KDF9_char_sets.symbol_index loop
   341.          exit block_loop when fetch_symbol(0, c) = End_Message;
   342.             end loop;
   343.          end loop block_loop;
   344.
   345.          if word_count > 8 then
   346.             -- The file is not a valid program tape.
   347.             trap_invalid_paper_tape("excessively long A block");
   348.          end if;
   349.
   350.          -- Read the first word of the following B block.
   351.          read_KDF9_tape_code(TR0.all, (TR0.number, 0, 0), loading_code => True);
   352.       end if;
   353.
   354.       -- Check for an unconditional jump at the start of the B block.
   355.       if (fetch_word(0)/ 2**32 and 2#1111_0000_1111_0000#) /= 2#1000_0000_1011_0000# then
   356.          -- The file is not a valid program tape.
   357.          trap_invalid_paper_tape("no jump was found in E0U: " & oct_of(fetch_word(0)));
   358.       else
   359.          -- Preserve the initial jump in case of corruption by a buggy program.
   360.          save_the_initial_jump;
   361.       end if;
   362.
   363.       -- At this point, E0 contains the first word of the B block, so get the rest of it in E1-E7.
   364.       read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   365.
   366.       descriptor := as_Q(fetch_word(descriptor.M));
   367.       -- Read the non-final C blocks; the validity of the designated descriptors cannot be assumed.
   368.       while descriptor.C /= 0 loop
   369.          validate_address_range(descriptor.I, descriptor.M);
   370.          read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   371.          descriptor := as_Q(fetch_word(descriptor.M));
   372.       end loop;
   373.
   374.       -- Read the final C block.
   375.       validate_address_range(descriptor.I, descriptor.M);
   376.       read_KDF9_tape_code(TR0.all, descriptor, loading_code => True);
   377.
   378.       -- Set up the rest of the stored image.
   379.
   380.       -- Set the (virtual) date in E7.
   381.       store_word(todays_date_28n_years_ago, 7);
   382.
   383.       -- Ensure valid parameters in E1 (some binaries may have invalid entries).
   384.       if fetch_halfword(1, 0) > threshold or else fetch_halfword(1, 0) = 0 then
   385.          store_halfword(substitute, 1, 0);
   386.       end if;
   387.       if fetch_halfword(1, 1) > threshold or else fetch_halfword(1, 1) = 0 then
   388.          store_halfword(substitute, 1, 1);
   389.       end if;
   390.
   391.       -- Save the available data for later diagnostic purposes.
   392.       set_whole_program_data(fetch_word(1), (fetch_word(0)/2**24));
   393.
   394.       -- Do not set the time if we are computing a signature, so as to get a repeatable hash.
   395.       if not the_signature_is_enabled then
   396.          KDF9.TSD.timing.set_the_time_of_loading(the_time_of_day);
   397.       end if;
   398.
   399.       loading_was_successful := True;
   400.
   401.       -- Clear up the I/O system.
   402.       reattach(0, "TR0");
   403.       clear_IOC_FIFO;
   404.       reset_loader_usage(0);
   405.    end load_a_program;
   406.
   407.    -- This emulates action of a Director call program, including:
   408.    --    1. Moving the JP0 order from E0U to E2U.
   409.    --    2. Inserting the interrupt handling code into E0 and E1, and
   410.    --    3. setting NIA to (4, 0) instead of (0, 0).
   411.    procedure load_a_bare_Director (program_file_name : in String) is
   412.
   413.    begin -- load_a_bare_Director
   414.       load_a_program(program_file_name);
   415.       store_halfword(fetch_halfword(0, index => 0), 2, index => 0);
   416.       store_word(8#3620716437675016#, 0); -- #171 #016 #164 #177 #172 #016: Q0; SHL+63; =+Q0;
   417.       store_word(8#6114000037240052#, 1); -- #304 #300 #000 #175 #100 #052: SETB140000;; =K1; ERASE
   418.       set_NIA_to((4, 0));
   419.    end load_a_bare_Director;
   420.
   421.    -- TR0 is the hardware bootstrap device for reading initial orders.
   422.    procedure boot_the_KDF9 (program_file_name : in String) is
   423.       boot_descriptor : constant KDF9.Q_register := (C => TR0.number, I => 0, M => 8);
   424.    begin
   425.       loading_was_successful := False;
   426.       reattach(0, program_file_name);
   427.
   428.       -- The bootstrap is 9 words of instruction code, which reads in the rest of its file.
   429.       -- The validity of the bootstrap descriptor is hardware defined.
   430.       read_KDF9_tape_code(TR0.all, boot_descriptor, loading_code => True);
   431.
   432.       -- Reset the I/O system for execution of the Director.
   433.       clear_IOC_FIFO;
   434.       reset_loader_usage(0);
   435.       loading_was_successful := True;
   436.    end boot_the_KDF9;
   437.
   438. end IOC.slow.shift.TR;

Compiling: ../Source/ioc-slow-shift-tr.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:07:59

     1. -- Emulation of a paper tape reader buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.TR is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    -- PRQq
    22.    overriding
    23.    procedure PIA (the_TR      : in out TR.device;
    24.                   Q_operand   : in KDF9.Q_register;
    25.                   set_offline : in Boolean);
    26.
    27.    -- PREQq
    28.    overriding
    29.    procedure PIB (the_TR      : in out TR.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    --PRCQq
    34.    overriding
    35.    procedure PIC (the_TR      : in out TR.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    -- PRCEQq
    40.    overriding
    41.    procedure PID (the_TR      : in out TR.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    -- as PIA
    46.    overriding
    47.    procedure PIE (the_TR      : in out TR.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- as PIB
    52.    overriding
    53.    procedure PIF (the_TR      : in out TR.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- as PIC
    58.    overriding
    59.    procedure PIG (the_TR      : in out TR.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    -- as PID
    64.    overriding
    65.    procedure PIH (the_TR      : in out TR.device;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    -- the_T_bit_is_set (the reader is set to 8-track mode)
    70.    overriding
    71.    procedure PMB (the_TR      : in out TR.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    procedure enable (b : in KDF9.buffer_number);
    76.
    77.    -- Reattach the designated TR to the specified file and set CASE NORMAL (may be irrelevant).
    78.    -- This is done after loading a binary program, to allow access any TR data file(s);
    79.    --    also to access a binary program for loading as an overlay.
    80.    procedure reattach (unit : in Natural; next_file_name : in String);
    81.
    82.    -- Read the 9-word bootstrap.
    83.    procedure boot_the_KDF9 (program_file_name : in String);
    84.
    85.    -- Read a binary program.
    86.    procedure load_a_program (program_file_name : in String);
    87.
    88.    -- This emulates action of a Director call program, including:
    89.    --    1. Moving the JP0 order from E0U to E2U.
    90.    --    2. Inserting the interrupt handling code into E0 and E1, and
    91.    --    3. setting NIA to (4, 0) instead of (0, 0).
    92.    procedure load_a_bare_Director (program_file_name : in String);
    93.
    94.    -- Set the character code to be used by the TR unit.
    95.    procedure set_unit_code(unit : in Natural; is_transcribing : in Boolean);
    96.
    97. private
    98.
    99.    type device is new IOC.slow.shift.device with null record;
   100.
   101.    overriding
   102.    procedure Initialize (the_TR : in out TR.device);
   103.
   104.    overriding
   105.    procedure Finalize (the_TR : in out TR.device);
   106.
   107.    overriding
   108.    function kind (the_TR : TR.device)
   109.    return IOC.device_kind
   110.    is (TR_kind);
   111.
   112.    overriding
   113.    function quantum (the_TR : TR.device)
   114.    return KDF9.us
   115.    is (1_000);
   116.
   117. end IOC.slow.shift.TR;

 438 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/generic_logger.adb
Source file time stamp: 2022-09-06 00:09:39
Compiled at: 2022-09-15 15:08:00

     1. -- Provide operations supporting replicated output to a list of logging interfaces.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. -- generic
    18. --    max_logger_list_size : in Positive;
    19. package body generic_logger is
    20.
    21.    not overriding
    22.    procedure set_logger_list (logger : in out replicator; list : in distribution_list) is
    23.    begin
    24.       logger.data := (list'Length, list);
    25.    end set_logger_list;
    26.
    27.    overriding
    28.    procedure tab_log (logger   : in out replicator;
    29.                       at_least : in Natural;
    30.                       spacing  : in Positive;
    31.                       iff      : in Boolean := True) is
    32.    begin
    33.       for l in logger.data.list'Range loop
    34.          logger.data.list(l).tab_log(at_least, spacing, iff);
    35.       end loop;
    36.    end tab_log;
    37.
    38.    overriding
    39.    procedure tab_log_to (logger : in out replicator;
    40.                          column : in Positive;
    41.                          iff    : in Boolean := True) is
    42.    begin
    43.       for l in logger.data.list'Range loop
    44.          logger.data.list(l).tab_log_to(column, iff);
    45.       end loop;
    46.    end tab_log_to;
    47.
    48.    overriding
    49.    procedure log (logger : in out replicator;
    50.                   char   : in Character;
    51.                   iff    : in Boolean := True) is
    52.    begin
    53.       for l in logger.data.list'Range loop
    54.          logger.data.list(l).log(char, iff);
    55.       end loop;
    56.    end log;
    57.
    58.    overriding
    59.    procedure log (logger : in out replicator;
    60.                   text   : in String;
    61.                   iff    : in Boolean := True) is
    62.    begin
    63.       for l in logger.data.list'Range loop
    64.          logger.data.list(l).log(text, iff);
    65.       end loop;
    66.    end log;
    67.
    68.    overriding
    69.    procedure log_new_line (logger : in out replicator;
    70.                            iff    : in Boolean := True) is
    71.    begin
    72.       for l in logger.data.list'Range loop
    73.          logger.data.list(l).log_new_line(iff);
    74.       end loop;
    75.    end log_new_line;
    76.
    77.    overriding
    78.    procedure open (logger : in out replicator; log_name : in String) is
    79.    begin
    80.       for l in logger.data.list'Range loop
    81.          logger.data.list(l).open(log_name);
    82.       end loop;
    83.    end open;
    84.
    85.    overriding
    86.    procedure close (logger : in out replicator) is
    87.    begin
    88.       for l in logger.data.list'Range loop
    89.          logger.data.list(l).close;
    90.       end loop;
    91.    end close;
    92.
    93.    overriding
    94.    procedure flush (logger : in out replicator; iff : in Boolean := True) is
    95.    begin
    96.       for l in logger.data.list'Range loop
    97.          logger.data.list(l).flush(iff);
    98.       end loop;
    99.    end flush;
   100.
   101. end generic_logger;

Compiling: ../Source/generic_logger.ads
Source file time stamp: 2022-09-06 00:09:20
Compiled at: 2022-09-15 15:08:00

     1. -- Provide operations supporting replicated output to a list of logging interfaces.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with logging;
    18.
    19. generic
    20.    max_logger_list_size : in Positive;
    21. package generic_logger is
    22.
    23.    type distribution_list is array (Positive range <>) of access logging.output'Class;
    24.
    25.    type replicator is new logging.output with private;
    26.
    27.    not overriding
    28.    procedure set_logger_list (logger : in out replicator; list : in distribution_list);
    29.
    30.    overriding
    31.    procedure tab_log (logger   : in out replicator;
    32.                       at_least : in Natural;
    33.                       spacing  : in Positive;
    34.                       iff      : in Boolean := True);
    35.
    36.    overriding
    37.    procedure tab_log_to (logger : in out replicator;
    38.                          column : in Positive;
    39.                          iff    : in Boolean := True);
    40.
    41.    overriding
    42.    procedure log (logger : in out replicator;
    43.                   char   : in Character;
    44.                   iff    : in Boolean := True);
    45.
    46.    overriding
    47.    procedure log (logger : in out replicator;
    48.                   text   : in String;
    49.                   iff    : in Boolean := True);
    50.
    51.    overriding
    52.    procedure log_new_line (logger : in out replicator;
    53.                            iff    : in Boolean := True);
    54.
    55.    overriding
    56.    procedure open  (logger : in out replicator; log_name : in String);
    57.
    58.    overriding
    59.    procedure close (logger : in out replicator);
    60.
    61.    overriding
    62.    procedure flush (logger : in out replicator; iff : in Boolean := True);
    63.
    64. private
    65.
    66.    subtype logger_list_size is Natural range 0 .. max_logger_list_size;
    67.
    68.    -- This type is needed because tagged types cannot have discriminants.
    69.    type replica_list (length : logger_list_size := 0) is
    70.       record
    71.          list : distribution_list(1 .. length);
    72.       end record;
    73.
    74.    type replicator is new logging.output with
    75.       record
    76.          data : replica_list;
    77.       end record;
    78.
    79. end generic_logger;

 101 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/logging.ads
Source file time stamp: 2022-09-06 00:06:44
Compiled at: 2022-09-15 15:08:00

     1. -- Define an abstract log output device.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package logging is
    18.
    19.    type output is interface;
    20.
    21.    procedure tab_log (logger   : in out logging.output;
    22.                       at_least : in Natural;
    23.                       spacing  : in Positive;
    24.                       iff      : in Boolean := True) is abstract;
    25.
    26.    procedure tab_log_to (logger : in out logging.output;
    27.                          column : in Positive;
    28.                          iff    : in Boolean := True) is abstract;
    29.
    30.    procedure log (logger : in out logging.output;
    31.                   char   : in Character;
    32.                   iff    : in Boolean := True) is abstract;
    33.
    34.    procedure log (logger : in out logging.output;
    35.                   text   : in String;
    36.                   iff    : in Boolean := True) is abstract;
    37.
    38.    procedure log_new_line (logger : in out logging.output;
    39.                            iff    : in Boolean := True) is abstract;
    40.
    41.    procedure open  (logger : in out logging.output; log_name : in String) is abstract;
    42.
    43.    procedure close (logger : in out logging.output) is abstract;
    44.
    45.    procedure flush (logger : in out logging.output; iff : in Boolean := True) is abstract;
    46.
    47. end logging;

 47 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/logging-file.adb
Source file time stamp: 2022-09-06 00:08:19
Compiled at: 2022-09-15 15:08:00

     1. -- Provide logging output to a named text file.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18. with Ada.Unchecked_Deallocation;
    19. --
    20. with file_interfacing;
    21.
    22. use  Ada.Text_IO;
    23. --
    24. use  file_interfacing;
    25.
    26. package body logging.file is
    27.
    28.    overriding
    29.    procedure tab_log (logger   : in out file.output;
    30.                       at_least : in Natural;
    31.                       spacing  : in Positive;
    32.                       iff      : in Boolean := True) is
    33.       column_nr : constant Positive_Count := Col(logger.the_log.all) + Count(at_least);
    34.       excess    : constant Count          := column_nr mod Count(spacing);
    35.    begin
    36.       if not iff or logger.log_file_is_shut then return; end if;
    37.       Set_Col(logger.the_log.all, column_nr);
    38.       if excess /= 0 then
    39.          Set_Col(logger.the_log.all, column_nr + Count(spacing) - excess);
    40.       end if;
    41.    end tab_log;
    42.
    43.    overriding
    44.    procedure tab_log_to (logger : in out file.output;
    45.                          column : in Positive;
    46.                          iff    : in Boolean := True) is
    47.    begin
    48.       if not iff or logger.log_file_is_shut then return; end if;
    49.       Set_Col(logger.the_log.all, Positive_Count(column));
    50.    end tab_log_to;
    51.
    52.    overriding
    53.    procedure log_new_line (logger : in out file.output;
    54.                            iff    : in Boolean := True) is
    55.    begin
    56.       if not iff or logger.log_file_is_shut then return; end if;
    57.       New_Line(logger.the_log.all);
    58.    end log_new_line;
    59.
    60.    overriding
    61.    procedure log (logger : in out file.output;
    62.                   char   : in Character;
    63.                   iff    : in Boolean := True) is
    64.    begin
    65.       if not iff or logger.log_file_is_shut then return; end if;
    66.       Put(logger.the_log.all, char);
    67.    end log;
    68.
    69.    overriding
    70.    procedure log (logger : in out file.output;
    71.                   text   : in String;
    72.                   iff    : in Boolean := True) is
    73.    begin
    74.       if not iff or logger.log_file_is_shut then return; end if;
    75.       Put(logger.the_log.all, text);
    76.    end log;
    77.
    78.    overriding
    79.    procedure open (logger : in out file.output; logfile_name : in String) is
    80.    begin
    81.       if logger.log_file_is_shut then
    82.          logger.the_log := new Ada.Text_IO.File_Type;
    83.          file_interfacing.initialize(logger.the_log.all, out_file, logfile_name);
    84.          logger.log_file_is_shut := False;
    85.       end if;
    86.    end open;
    87.
    88.    overriding
    89.    procedure close (logger : in out file.output) is
    90.
    91.       procedure free_log_file is
    92.          new Ada.Unchecked_Deallocation(Ada.Text_IO.File_Type, File_Type_access);
    93.
    94.    begin
    95.       if logger.log_file_is_shut then return; end if;
    96.       flush(logger);
    97.       -- file_interfacing.finalize(logger.the_log.all, logfile_name);
    98.       free_log_file(logger.the_log);
    99.       logger.log_file_is_shut := True;
   100.    end close;
   101.
   102.    overriding
   103.    procedure flush (logger : in out file.output; iff : in Boolean := True) is
   104.    begin
   105.       if not iff or logger.log_file_is_shut then return; end if;
   106.       Flush(logger.the_log.all);
   107.    end flush;
   108.
   109. end logging.file;

Compiling: ../Source/logging-file.ads
Source file time stamp: 2022-09-06 00:07:32
Compiled at: 2022-09-15 15:08:00

     1. -- Provide logging output to a named text file.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. private with Ada.Text_IO;
    18.
    19. package logging.file is
    20.
    21.    type output is new logging.output with private;
    22.
    23.    overriding
    24.    procedure tab_log (logger   : in out file.output;
    25.                       at_least : in Natural;
    26.                       spacing  : in Positive;
    27.                       iff      : in Boolean := True);
    28.
    29.    overriding
    30.    procedure tab_log_to (logger : in out file.output;
    31.                          column : in Positive;
    32.                          iff    : in Boolean := True);
    33.
    34.    overriding
    35.    procedure log (logger : in out file.output;
    36.                   char   : in Character;
    37.                   iff    : in Boolean := True);
    38.
    39.    overriding
    40.    procedure log (logger : in out file.output;
    41.                   text   : in String;
    42.                   iff    : in Boolean := True);
    43.
    44.    overriding
    45.    procedure log_new_line (logger : in out file.output;
    46.                            iff    : in Boolean := True);
    47.
    48.    overriding
    49.    procedure open  (logger : in out file.output; logfile_name : in String);
    50.
    51.    overriding
    52.    procedure close (logger : in out file.output);
    53.
    54.    overriding
    55.    procedure flush (logger : in out file.output; iff : in Boolean := True);
    56.
    57. private
    58.
    59.    type File_Type_access is access Ada.Text_IO.File_Type;
    60.
    61.    type output is new logging.output with
    62.       record
    63.          log_file_is_shut : Boolean := True;
    64.          the_log          : file.File_Type_access;
    65.       end record;
    66.
    67. end logging.file;

 109 lines: No errors


Compiling: /home/parallels/emulation/Source/settings.adb
Source file time stamp: 2022-09-06 16:55:53
Compiled at: 2022-09-15 15:08:00

     1. -- Read and register execution mode, diagnostic mode, and other emulation-control settings.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. with Ada.Long_Float_Text_IO;
    19. with Ada.Text_IO;
    20. --
    21. with KDF9.imaging;
    22. with disassembly.symbols;
    23. with dumping;
    24. with exceptions;
    25. with HCI;
    26. with IOC.equipment;
    27. with KDF9.store;
    28. with postscript;
    29. with settings.IO;
    30. with string_editing;
    31. with tracing;
    32.
    33. use  Ada.Exceptions;
    34. use  Ada.Long_Float_Text_IO;
    35. use  Ada.Text_IO;
    36. --
    37. use  KDF9.imaging;
    38. use  disassembly.symbols;
    39. use  dumping;
    40. use  exceptions;
    41. use  HCI;
    42. use  KDF9.store;
    43. use  settings.IO;
    44. use  string_editing;
    45. use  tracing;
    46.
    47. package body settings is
    48.
    49.    error_count : Natural := 0;
    50.
    51.    procedure reset_default_visibility_options is
    52.    begin
    53.       API_logging_is_wanted            := True;
    54.       flexowriter_output_is_wanted     := True;
    55.       histogramming_is_wanted          := True;
    56.       interrupt_tracing_is_wanted      := True;
    57.       peripheral_tracing_is_wanted     := True;
    58.       realistic_FW_output_is_wanted    := True;
    59.       retrospective_tracing_is_wanted  := True;
    60.       the_final_state_is_wanted        := True;
    61.       the_log_is_wanted                := True;
    62.       the_signature_is_wanted          := True;
    63.       authentic_timing_is_enabled      := False;
    64.       core_file_is_enabled             := False;
    65.       debugging_is_enabled             := False;
    66.       histogramming_is_enabled         := False;
    67.       interrupt_tracing_is_enabled     := False;
    68.       peripheral_tracing_is_enabled    := False;
    69.       retrospective_tracing_is_enabled := False;
    70.       the_signature_is_enabled         := False;
    71.    end reset_default_visibility_options;
    72.
    73.    function is_invalid_miscellany_flag (option : in Character)
    74.    return Boolean is
    75.    begin
    76.       for f of miscellany_flags loop
    77.          if f = option then
    78.             return False;
    79.          end if;
    80.       end loop;
    81.       if option = '-' then  -- Ignore hyphens to make the calling scripts easier.
    82.          return False;
    83.       end if;
    84.       return True;
    85.    end is_invalid_miscellany_flag;
    86.
    87.    procedure set_this_miscellany_flag (option : in Character) is
    88.       use IOC.equipment;
    89.    begin
    90.       if is_invalid_miscellany_flag(option) then
    91.          log_line(
    92.                   "**** Error in a miscellany specification:"
    93.                 + abs option
    94.                 & "."
    95.                  );
    96.          return;
    97.       end if;
    98.       case option is
    99.          when '-'        =>
   100.             null;  -- Ignore hyphens, to make the calling scripts easier.
   101.          when '.'        =>
   102.             time_limit := 1_000_000;
   103.          when '0' .. '9' =>
   104.             time_limit := (Character'Pos(option) - Character'Pos('0') + 1) * 100_000_000;
   105.          when 'a' | 'A' =>
   106.             API_logging_is_wanted := False;
   107.          when 'b' | 'B' =>
   108.             choice(KDF9.buffer_number'(15)) := SI;
   109.          when 'c' | 'C' =>
   110.             core_file_is_enabled := True;
   111.          when 'd' | 'D' =>
   112.             debugging_is_enabled := True;
   113.          when 'e' | 'E' =>
   114.             the_log_is_wanted := False;
   115.          when 'f' | 'F' =>
   116.             the_final_state_is_wanted := False;
   117.          when 'g' | 'G' =>
   118.             choice(if TP1_number = 0 then TP1_default else TP1_number) := GP;
   119.          when 'h' | 'H' =>
   120.             histogramming_is_wanted := False;
   121.          when 'i' | 'I' =>
   122.             interrupt_tracing_is_wanted := False;
   123.          when 'k' | 'K' =>
   124.             choice(DR0_default) := DR;
   125.          when 'n' | 'N' =>
   126.             noninteractive_usage_is_enabled := True;
   127.             time_limit := offline_time_limit;
   128.           when 'o' |'O' =>
   129.             pre_overlay_state_is_enabled := True;
   130.          when 'p' |'P' =>
   131.             peripheral_tracing_is_wanted := False;
   132.          when 'q' | 'Q' =>
   133.             do_not_execute := True;
   134.          when 'r' | 'R' =>
   135.             retrospective_tracing_is_wanted := False;
   136.          when 's' | 'S' =>
   137.             the_signature_is_wanted := False;
   138.          when 't' | 'T' =>
   139.             authentic_timing_is_enabled := True;
   140.          when 'w' | 'W' =>
   141.             flexowriter_output_is_wanted := False;
   142.          when 'x' | 'X' =>
   143.             only_signature_tracing := True;
   144.          when 'y' | 'Y' =>
   145.             this_is_a_bare_Director := True;
   146.          when 'z' | 'Z' =>
   147.             API_logging_is_wanted           := False;
   148.             debugging_is_enabled            := False;
   149.             histogramming_is_wanted         := False;
   150.             interrupt_tracing_is_wanted     := False;
   151.             peripheral_tracing_is_wanted    := False;
   152.             retrospective_tracing_is_wanted := False;
   153.             the_final_state_is_wanted       := False;
   154.             the_log_is_wanted               := False;
   155.             the_signature_is_wanted         := False;
   156.          when others =>
   157.             null;
   158.       end case;
   159.       set_diagnostic_mode(the_diagnostic_mode);
   160.    end set_this_miscellany_flag;
   161.
   162.    procedure display_execution_modes (for_this : in String := "") is
   163.       needs_comma : Boolean := False;
   164.
   165.       procedure append_option (flag : in Boolean; name : in String) is
   166.       begin
   167.          if flag then
   168.             if needs_comma then
   169.                log(", ");
   170.             end if;
   171.             log(name);
   172.             needs_comma := True;
   173.          end if;
   174.       end append_option;
   175.
   176.       function run_type (type_of_run : String)
   177.       return String
   178.       is (if for_this = "" then type_of_run else type_of_run + for_this);
   179.
   180.    begin -- display_execution_modes
   181.       if not the_log_is_wanted then return; end if;
   182.       log_new_line;
   183.       if for_this = "" then
   184.          log("Resuming the run");
   185.       else
   186.          log(
   187.              case the_execution_mode is
   188.                when boot_mode        => (
   189.                                          if this_is_a_bare_Director then
   190.                                             "Running the bare " & run_type("Director")
   191.                                          else
   192.                                             "Booting the KDF9 " & run_type("Director")
   193.                                         ),
   194.                when program_mode     => "Running the KDF9 " & run_type("problem program"),
   195.                when privileged_mode  => "Running the KDF9 " & run_type("privileged program")
   196.             );
   197.       end if;
   198.       log(" in ");
   199.       log(
   200.           case the_diagnostic_mode is
   201.              when trace_mode    =>
   202.                 (if the_external_trace_is_enabled then "external trace mode" else "trace mode"),
   203.              when fast_mode     => "fast mode",
   204.              when pause_mode    => "pause mode",
   205.              when external_mode => "external trace mode"
   206.          );
   207.
   208.       if authentic_timing_is_enabled      or else
   209.          core_file_is_enabled             or else
   210.          debugging_is_enabled             or else
   211.          histogramming_is_enabled         or else
   212.          interrupt_tracing_is_enabled     or else
   213.          noninteractive_usage_is_enabled  or else
   214.          peripheral_tracing_is_enabled    or else
   215.          retrospective_tracing_is_enabled or else
   216.          the_external_trace_is_enabled    or else
   217.          the_signature_is_enabled            then
   218.
   219.          log_line(", with option(s):");
   220.          log("   ");
   221.          append_option(authentic_timing_is_enabled,      "authentic timing");
   222.          append_option(core_file_is_enabled,             "core file output");
   223.          append_option(debugging_is_enabled,             "debugging output");
   224.          append_option(histogramming_is_enabled,         "histogram(s)");
   225.          append_option(interrupt_tracing_is_enabled,     "interrupt trace");
   226.          append_option(noninteractive_usage_is_enabled,  "noninteractive");
   227.          append_option(peripheral_tracing_is_enabled,    "peripheral trace");
   228.          append_option(retrospective_tracing_is_enabled, "retro trace");
   229.          append_option(the_external_trace_is_enabled,    "external trace");
   230.          append_option(the_signature_is_enabled,         "signature hash");
   231.       end if;
   232.       log_line(".");
   233.       log_rule;
   234.    end display_execution_modes;
   235.
   236.    procedure quit_if_requested is
   237.    begin
   238.       if quit_was_requested then
   239.          raise quit_request with ""; -- "" suppresses the default message.
   240.       end if;
   241.    end quit_if_requested;
   242.
   243.    procedure change_diagnostic_mode_if_requested is
   244.    begin
   245.       if the_diagnostic_mode_changed then
   246.          the_diagnostic_mode_changed := False;
   247.          raise mode_change_request;
   248.       end if;
   249.    end change_diagnostic_mode_if_requested;
   250.
   251.    procedure set_diagnostic_mode (a_diagnostic_mode : in settings.diagnostic_mode) is
   252.       tracing_is_allowed    : constant Boolean := a_diagnostic_mode /= fast_mode;
   253.       interrupts_can_happen : constant Boolean := the_execution_mode = boot_mode and tracing_is_allowed;
   254.    begin
   255.       if a_diagnostic_mode = external_mode then
   256.          if (the_diagnostic_mode /= external_mode) and (not the_external_trace_is_enabled) then
   257.             open(the_external_trace_file, the_external_trace_file_name);
   258.          end if;
   259.          the_diagnostic_mode := trace_mode;
   260.          the_external_trace_is_enabled := True;
   261.       else
   262.          the_diagnostic_mode := a_diagnostic_mode;
   263.       end if;
   264.       histogramming_is_enabled         := histogramming_is_wanted         and tracing_is_allowed;
   265.       interrupt_tracing_is_enabled     := interrupt_tracing_is_wanted     and interrupts_can_happen;
   266.       peripheral_tracing_is_enabled    := peripheral_tracing_is_wanted    and tracing_is_allowed;
   267.       retrospective_tracing_is_enabled := retrospective_tracing_is_wanted and tracing_is_allowed;
   268.       the_signature_is_enabled         := the_signature_is_wanted         and tracing_is_allowed;
   269.    end set_diagnostic_mode;
   270.
   271.    procedure set_execution_mode (an_execution_mode : in settings.execution_mode) is
   272.    begin
   273.       the_execution_mode := an_execution_mode;
   274.    end set_execution_mode;
   275.
   276.    package diagnostic_mode_IO   is new Ada.Text_IO.Enumeration_IO(settings.diagnostic_mode);
   277.
   278.    package execution_mode_IO    is new Ada.Text_IO.Enumeration_IO(settings.execution_mode);
   279.
   280.    package authenticity_mode_IO is new Ada.Text_IO.Enumeration_IO(KDF9.authenticity_mode);
   281.
   282.    package equipment_IO         is new Ada.Text_IO.Enumeration_IO(IOC.equipment.kind);
   283.
   284.    procedure get_settings_from_file (version : in String) is
   285.
   286.       the_settings_file_name : constant String := "settings_" & version & ".txt";
   287.       HT                     : constant Character := Character'Val(9);
   288.       counts_are_set : Boolean := False;
   289.       settings_file  : File_Type;
   290.       flag           : Character;
   291.
   292.       procedure set_the_miscellany_flags is
   293.          c  : Character := ' ';
   294.       begin
   295.          skip_to_next_non_blank(settings_file);
   296.          if End_Of_Line(settings_file) then
   297.             reset_default_visibility_options;
   298.             return;
   299.          end if;
   300.          loop
   301.             get(settings_file, c);
   302.             if is_invalid_miscellany_flag(c) then
   303.                if c not in  ' ' | HT  then
   304.                   raise Data_Error;
   305.                end if;
   306.             else
   307.                set_this_miscellany_flag(c);
   308.             end if;
   309.          exit when End_Of_Line(settings_file);
   310.          end loop;
   311.       exception
   312.          when Data_Error =>
   313.             error_count := error_count + 1;
   314.             if not End_Of_Line(settings_file) then
   315.                Skip_Line(settings_file);
   316.             end if;
   317.             log_new_line;
   318.             log_line(
   319.                      "**** Error in a miscellany specification:"
   320.                    + (if c = ' ' then "no option was given." else "invalid data" + abs c & ".")
   321.                     );
   322.       end set_the_miscellany_flags;
   323.
   324.       procedure set_breakpoints is
   325.          start, end_point : KDF9.code_address;
   326.       begin
   327.          begin
   328.             get_word(settings_file, KDF9.word(start));
   329.          exception
   330.             when others =>
   331.                error_count := error_count + 1;
   332.                log_new_line;
   333.                log_line("**** Error in lower address; no breakpoint set.");
   334.                return;
   335.          end;
   336.
   337.          log_new_line;
   338.          log_line(
   339.                   "Lower breakpoint: #"
   340.                 & oct_of(KDF9.syllable_address'(start, 0))
   341.                 + "("
   342.                 & dec_of(KDF9.syllable_address'(start, 0))
   343.                 & ")",
   344.                   iff => the_log_is_wanted
   345.                  );
   346.          breakpoints(start) := True;
   347.
   348.          begin
   349.             get_word(settings_file, KDF9.word(end_point));
   350.          exception
   351.             when Data_Error =>
   352.                error_count := error_count + 1;
   353.                log_line("      No upper address: one breakpoint set.", iff => the_log_is_wanted);
   354.                set_breakpoints(start, start);
   355.                return;
   356.          end;
   357.          log_line(
   358.                   "Upper breakpoint: #"
   359.                 & oct_of(KDF9.syllable_address'(end_point, 5))
   360.                 + "(" & dec_of(KDF9.syllable_address'(end_point, 5))
   361.                 & ")",
   362.                   iff => the_log_is_wanted
   363.                  );
   364.          set_breakpoints(start, end_point);
   365.       exception
   366.          when others =>
   367.             error_count := error_count + 1;
   368.             log_line("**** Error setting breakpoints; none set.");
   369.       end set_breakpoints;
   370.
   371.       procedure set_store_points is
   372.          start, end_point : KDF9.address;
   373.       begin
   374.          begin
   375.             get_word(settings_file, KDF9.word(start));
   376.          exception
   377.             when others =>
   378.                error_count := error_count + 1;
   379.                log_new_line;
   380.                log_line("**** Error in lower address; no storepoint set.");
   381.                return;
   382.          end;
   383.          log_new_line;
   384.          log_line(
   385.                   "Lower storepoint: #"
   386.                 & oct_of(start)
   387.                 + "("
   388.                 & dec_of(start)
   389.                 & ")",
   390.                   iff => the_log_is_wanted
   391.                  );
   392.          begin
   393.             get_word(settings_file, KDF9.word(end_point));
   394.          exception
   395.             when Data_Error =>
   396.                error_count := error_count + 1;
   397.                log_line("      No upper address: one storepoint set.", iff => the_log_is_wanted);
   398.                set_store_points(start, start);
   399.                return;
   400.          end;
   401.          log_line(
   402.                   "Upper storepoint: #"
   403.                 & oct_of(end_point)
   404.                 + "("
   405.                 & dec_of(end_point)
   406.                 & ")",
   407.                   iff => the_log_is_wanted
   408.                  );
   409.          set_store_points(start, end_point);
   410.       exception
   411.          when others =>
   412.             error_count := error_count + 1;
   413.             log_line("**** Error setting storepoints; none set.");
   414.       end set_store_points;
   415.
   416.       procedure set_watchpoints is
   417.          start, end_point : KDF9.address;
   418.       begin
   419.          begin
   420.             get_word(settings_file, KDF9.word(start));
   421.          exception
   422.             when others =>
   423.                error_count := error_count + 1;
   424.                log_new_line;
   425.                log_line("**** Error in lower address; no watchpoint set.");
   426.                return;
   427.          end;
   428.          log_new_line;
   429.          log_line(
   430.                   "Lower watchpoint: #"
   431.                 & oct_of(start)
   432.                 + "("
   433.                 & dec_of(start)
   434.                 & ")",
   435.                   iff => the_log_is_wanted
   436.                  );
   437.          begin
   438.             get_word(settings_file, KDF9.word(end_point));
   439.          exception
   440.             when Data_Error =>
   441.                error_count := error_count + 1;
   442.                log_line("      No upper address: one watchpoint set.", iff => the_log_is_wanted);
   443.                set_store_points(start, start);
   444.                set_fetch_points(start, start);
   445.                return;
   446.          end;
   447.          log_line(
   448.                   "Upper watchpoint: #"
   449.                 & oct_of(end_point)
   450.                 + "("
   451.                 & dec_of(end_point)
   452.                 & ")",
   453.                   iff => the_log_is_wanted);
   454.          set_fetch_points(start, end_point);
   455.          set_store_points(start, end_point);
   456.       exception
   457.          when others =>
   458.             error_count := error_count + 1;
   459.             log_line("**** Error setting watchpoints; none set.");
   460.       end set_watchpoints;
   461.
   462.       procedure set_specified_dumping_ranges (epoch : in dumping.flag) is
   463.          use dumping.flag_support;
   464.          epoch_flag   : constant Character := (if epoch = initial_flag then 'I' else 'F');
   465.          format       : dumping.format_set := no_dumping_flags or epoch;
   466.          first_address,
   467.          last_address : KDF9.address := 0;
   468.          bad_range    : Boolean := False;
   469.          max_address,
   470.          data         : KDF9.word;
   471.          c            : Character;
   472.          OK           : Boolean;
   473.       begin
   474.          log("Dump: format" + epoch_flag, iff => the_log_is_wanted);
   475.          while not End_Of_Line(settings_file) loop
   476.             get(settings_file, c);
   477.             log(c, iff => the_log_is_wanted);
   478.          exit when c = ' ';
   479.             if is_parameter_flag/dumping_flag(upper(c)) then
   480.                format := format or dumping_flag(upper(c));
   481.             else
   482.                if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   483.                log_new_line;
   484.                log_line("**** Error:" + abs c + "is not a valid dump type.");
   485.                return;
   486.             end if;
   487.          end loop;
   488.          log_new_line;
   489.
   490.          max_address := (if (format and is_order_flag) /= no_dumping_flags then 8191 else 32767);
   491.          if (format and is_parameter_flag) /= no_dumping_flags then
   492.             get_word(settings_file, data);
   493.             if data > max_address then
   494.                log_line(
   495.                         "**** Error: Lower dump address = #"
   496.                       & oct_of(data)
   497.                       + "="
   498.                       & data'Image
   499.                       + "is too large for this option."
   500.                        );
   501.                bad_range := True;
   502.             else
   503.                first_address := KDF9.address(data);
   504.                last_address  := KDF9.address(data);
   505.                log_line(
   506.                         "      Lower dump address: #"
   507.                       & oct_of(first_address)
   508.                       + "("
   509.                       & dec_of(first_address)
   510.                       & ")",
   511.                         iff => the_log_is_wanted
   512.                        );
   513.             end if;
   514.
   515.            skip_to_next_non_blank (settings_file);
   516.
   517.             if not end_of_line(settings_file) then
   518.                get_word(settings_file, data);
   519.                if data > max_address then
   520.                   log_line(
   521.                            "**** Error: Upper dump address = #"
   522.                          & oct_of(data)
   523.                          + "="
   524.                          & data'Image
   525.                          + "is too large for this option."
   526.                           );
   527.                   bad_range := True;
   528.                else
   529.                   last_address := KDF9.address(data);
   530.                   log_line(
   531.                            "      Upper dump address: #"
   532.                          & oct_of(last_address)
   533.                          + "("
   534.                          & dec_of(last_address)
   535.                          & ")",
   536.                            iff => the_log_is_wanted
   537.                           );
   538.                end if;
   539.             end if;
   540.
   541.             if first_address > last_address then
   542.                log_line(
   543.                         "**** Error: Upper dump address: #"
   544.                       & oct_of(last_address)
   545.                       + "="
   546.                       & last_address'Image
   547.                       + "is less than lower dump address: #"
   548.                       & oct_of(first_address)
   549.                       + "="
   550.                       & first_address'Image
   551.                       & "."
   552.                        );
   553.                bad_range := True;
   554.             end if;
   555.          end if;
   556.
   557.          if not bad_range then
   558.             request_a_dumping_area(format, first_address, last_address, OK);
   559.             if not OK then
   560.                log_line("**** Error: Too many dump specifications (ignored).");
   561.             end if;
   562.          end if;
   563.
   564.          if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   565.       exception
   566.          when others =>
   567.             error_count := error_count + 1;
   568.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   569.             log_new_line;
   570.             log_line("**** Error in a dump area specification (ignored)." );
   571.       end set_specified_dumping_ranges;
   572.
   573.       procedure set_initial_dumping_ranges is
   574.       begin
   575.          set_specified_dumping_ranges(initial_flag);
   576.       end set_initial_dumping_ranges;
   577.
   578.       procedure set_final_dumping_ranges is
   579.       begin
   580.          set_specified_dumping_ranges(final_flag);
   581.       end set_final_dumping_ranges;
   582.
   583.       procedure set_histogram_options is
   584.          c : Character;
   585.       begin
   586.          while not End_Of_Line(settings_file) loop
   587.             get(settings_file, c);
   588.          exit when c = ' ';
   589.             case c is
   590.                when 'P' | 'p' =>
   591.                   the_profile_is_wanted  := True;
   592.                   clear_the_profile;
   593.                when 'T' | 't' =>
   594.                   the_INS_plot_is_wanted := True;
   595.                   clear_the_histogram;
   596.                when others =>
   597.                   raise Data_Error;
   598.             end case;
   599.          end loop;
   600.          ensure_not_at_end_of_line(settings_file);
   601.          get(settings_file, histogram_cutoff);
   602.          if histogram_cutoff >= 100.0 or histogram_cutoff < 0.0 then
   603.             raise Data_Error;
   604.          end if;
   605.          get(settings_file, c);
   606.          if c /= '%' then
   607.             raise Data_Error;
   608.          end if;
   609.       exception
   610.          when others =>
   611.             error_count := error_count + 1;
   612.             histogram_cutoff := cutoff_default;
   613.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   614.             log_new_line;
   615.             log_line("**** Error in the histogram option; default used.");
   616.       end set_histogram_options;
   617.
   618.       procedure set_time_limit is
   619.          begin
   620.             begin
   621.             get_decimal(settings_file, KDF9.word(time_limit));
   622.          exception
   623.             when others =>
   624.                error_count := error_count + 1;
   625.                if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   626.                time_limit := offline_time_limit;
   627.          end;
   628.
   629.          if not counts_are_set then
   630.             high_count := time_limit;
   631.          end if;
   632.
   633.          log_new_line;
   634.          log_line("Time limit (in instructions) =" & time_limit'Image,
   635.                   iff => the_log_is_wanted);
   636.       end set_time_limit;
   637.
   638.       procedure set_tracing_counts is
   639.
   640.          procedure show_counts is
   641.          begin
   642.             if not the_log_is_wanted then return; end if;
   643.             log_new_line;
   644.             log_line("Lower tracing count:" & low_count'Image);
   645.             log_line("Upper tracing count:" & high_count'Image);
   646.          end show_counts;
   647.
   648.       begin
   649.          get_decimal(settings_file, KDF9.word(low_count));
   650.          get_decimal(settings_file, KDF9.word(high_count));
   651.          show_counts;
   652.          if low_count > high_count then
   653.             log_new_line;
   654.             log_line("**** Error: Low count > high count.");
   655.             raise Data_Error;
   656.          end if;
   657.          counts_are_set := True;
   658.       exception
   659.          when others =>
   660.             error_count := error_count + 1;
   661.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   662.             low_count  := low_count_default;
   663.             high_count := high_count_default;
   664.             log_new_line;
   665.             log_line("**** Error in a tracing count; defaults used.");
   666.             show_counts;
   667.       end set_tracing_counts;
   668.
   669.       procedure set_tracing_range is
   670.
   671.          procedure show_range is
   672.          begin
   673.             if not the_log_is_wanted then return; end if;
   674.             log_new_line;
   675.             log_line(
   676.                      "Lower trace address: #"
   677.                    & oct_of(KDF9.syllable_address'(low_bound, 0))
   678.                    + "("
   679.                    & dec_of(KDF9.syllable_address'(low_bound, 0))
   680.                    & ")"
   681.                     );
   682.             log_line(
   683.                      "Upper trace address: #"
   684.                    & oct_of(KDF9.syllable_address'(high_bound, 5))
   685.                    + "("
   686.                    & dec_of(KDF9.syllable_address'(high_bound, 5))
   687.                    & ")"
   688.                     );
   689.          end show_range;
   690.
   691.       begin
   692.          get_word(settings_file, KDF9.word(low_bound));
   693.          get_word(settings_file, KDF9.word(high_bound));
   694.          if low_bound > high_bound then
   695.             log_new_line;
   696.             log_line("**** Error: Low bound > high bound.");
   697.             raise Data_Error;
   698.          end if;
   699.          show_range;
   700.       exception
   701.          when others =>
   702.             error_count := error_count + 1;
   703.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   704.             low_bound  := low_bound_default;
   705.             high_bound := high_bound_default;
   706.             log_new_line;
   707.             log_line("**** Error in a tracing address; defaults used.");
   708.             show_range;
   709.       end set_tracing_range;
   710.
   711.       procedure set_diagnostic_mode is
   712.          use diagnostic_mode_IO;
   713.          the_diagnostic_mode : settings.diagnostic_mode;
   714.       begin
   715.          ensure_not_at_end_of_line(settings_file);
   716.          get(settings_file, the_diagnostic_mode);
   717.          set_diagnostic_mode(the_diagnostic_mode);
   718.       exception
   719.          when others =>
   720.             error_count := error_count + 1;
   721.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   722.             set_diagnostic_mode(the_diagnostics_default);
   723.             log_new_line;
   724.             log_line("**** Error in the diagnostic mode; default used.");
   725.       end set_diagnostic_mode;
   726.
   727.       procedure set_execution_mode is
   728.          use execution_mode_IO;
   729.       begin
   730.          ensure_not_at_end_of_line(settings_file);
   731.          get(settings_file, the_execution_mode);
   732.       exception
   733.          when others =>
   734.             error_count := error_count + 1;
   735.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   736.             the_execution_mode := the_execution_default;
   737.             log_new_line;
   738.             log_line("**** Error in the testing mode; default used.");
   739.       end set_execution_mode;
   740.
   741.       procedure set_authenticity is
   742.          use authenticity_mode_IO;
   743.       begin
   744.          ensure_not_at_end_of_line(settings_file);
   745.          get(settings_file, the_authenticity_mode);
   746.          if the_authenticity_mode = authentic_time_mode then
   747.             authentic_timing_is_enabled := True;
   748.          end if;
   749.       exception
   750.          when others =>
   751.             error_count := error_count + 1;
   752.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   753.             the_authenticity_mode := the_authenticity_default;
   754.             log_new_line;
   755.             log_line("**** Error in the authenticity mode; default used.");
   756.       end set_authenticity;
   757.
   758.       procedure set_graph_plotting_pen is
   759.          use postscript;
   760.          use colour_IO;
   761.          use  width_IO;
   762.          the_colour   : pen_colour   := the_default_colour;
   763.          the_pen_size : pen_tip_size := the_default_tip_size;
   764.
   765.          procedure show_pen_options is
   766.          begin
   767.             if not the_log_is_wanted then return; end if;
   768.             log_new_line;
   769.             if the_colour /= the_default_colour then
   770.                log_line("The graph plotter pen colour is" + the_colour'Image & ".");
   771.             end if;
   772.             if the_pen_size /= the_default_tip_size then
   773.                log_line("The graph plotter pen tip is" + the_pen_size'Image & ".");
   774.             end if;
   775.          end show_pen_options;
   776.
   777.          procedure configure_the_plotter is
   778.          begin
   779.             if the_colour /= the_default_colour or the_pen_size /= the_default_tip_size then
   780.                set_the_pen_properties(the_colour, the_pen_size);
   781.                show_pen_options;
   782.             end if;
   783.          end configure_the_plotter;
   784.
   785.       begin  -- set_graph_plotting_pen
   786.          ensure_not_at_end_of_line(settings_file);
   787.          begin
   788.             Get(settings_file, the_colour);
   789.          exception
   790.             when others =>
   791.                error_count := error_count + 1;
   792.                log_new_line;
   793.                log_line("**** Error in the plotter pen the_colour; default used.");
   794.          end;
   795.          ensure_not_at_end_of_line(settings_file);
   796.          begin
   797.             Get(settings_file, the_pen_size);
   798.          exception
   799.             when others =>
   800.                error_count := error_count + 1;
   801.                log_new_line;
   802.                log_line("**** Error in the plotter pen tip; default used.");
   803.          end;
   804.          configure_the_plotter;
   805.       exception
   806.          when Data_Error =>
   807.             error_count := error_count + 1;
   808.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   809.             configure_the_plotter;
   810.       end set_graph_plotting_pen;
   811.
   812.       procedure set_non_interactivity is
   813.       begin
   814.          noninteractive_usage_is_enabled := True;
   815.          set_time_limit;
   816.       end set_non_interactivity;
   817.
   818.       procedure save_poke_value is
   819.          -- W: full Word, U: Upper halfword, L: Lower halfword, S: Syllable, C: Character
   820.          address  : KDF9.address;
   821.          sub_word : Character;
   822.          position : KDF9.address;
   823.          value    : KDF9.word;
   824.          OK       : Boolean;
   825.       begin
   826.          begin
   827.             get_word(settings_file, KDF9.word(address));
   828.          exception
   829.             when others =>
   830.                error_count := error_count + 1;
   831.                log_line("**** Error in poke word address.");
   832.                Skip_Line(settings_file);
   833.                return;
   834.          end;
   835.
   836.          get_char(settings_file, sub_word);
   837.          if sub_word not in 'S' | 's' | 'C' | 'c' | 'L' | 'l' | 'U' | 'u' | 'W' | 'w' then
   838.             error_count := error_count + 1;
   839.             log_line(
   840.                      "**** Error in (sub)word indicator;"
   841.                    + sub_word
   842.                    + "should be W, L, U, S, or C."
   843.                     );
   844.             Skip_Line(settings_file);
   845.             return;
   846.          end if;
   847.
   848.          if sub_word in 'S' | 's' | 'C' | 'c' then
   849.             begin
   850.                get_word(settings_file, KDF9.word(position));
   851.                if (sub_word in 'S' | 's' and position > 5) or else
   852.                   (sub_word in 'C' | 'c' and position > 7)    then
   853.                   error_count := error_count + 1;
   854.                   log_line(
   855.                            "**** Error in position given for a"
   856.                          + (if sub_word in 'S' | 's' then "syllable:" else "character:")
   857.                          & position'Image
   858.                          + "is too large, poke request ignored."
   859.                           );
   860.                   Skip_Line(settings_file);
   861.                   return;
   862.                end if;
   863.             exception
   864.                when others =>
   865.                   error_count := error_count + 1;
   866.                   log_line(
   867.                            "**** Error in position given for a"
   868.                          + (if sub_word in 'S' | 's' then "syllable" else "character")
   869.                          & ", poke request ignored."
   870.                           );
   871.                   Skip_Line(settings_file);
   872.                   return;
   873.             end;
   874.          else
   875.             position := 0;
   876.          end if;
   877.
   878.          begin
   879.             get_word(settings_file, value);
   880.          exception
   881.             when others =>
   882.                error_count := error_count + 1;
   883.                log_line("**** Error in poked value.");
   884.                Skip_Line(settings_file);
   885.                return;
   886.          end;
   887.
   888.          if (sub_word in 'L' | 'l' | 'U' | 'u' and value > 2**24-1) or else
   889.                (sub_word in 'S' | 's'          and value > 255)     or else
   890.                   (sub_word in 'C' | 'c'       and value > 63)      then
   891.             error_count := error_count + 1;
   892.             log_line(
   893.                      "**** Error in poked value #"
   894.                    & oct_of(value)
   895.                    & ": out of range for a"
   896.                    + (case sub_word is
   897.                          when 'L' | 'l' | 'U' | 'u' => "halfword",
   898.                          when 'S' | 's'             => "syllable",
   899.                          when 'C' | 'c'             => "character",
   900.                          when others                => "word")
   901.                    & ", poke request ignored."
   902.                     );
   903.             Skip_Line(settings_file);
   904.             return;
   905.          end if;
   906.
   907.          add_to_poke_list(address, sub_word, position, value, OK);
   908.
   909.          if not OK then
   910.             log_line("**** Error setting up a poke: poke list full; request ignored.");
   911.          end if;
   912.
   913.       exception
   914.
   915.          when others =>
   916.             null;  -- to skip line at end of input loop
   917.
   918.       end save_poke_value;
   919.
   920.       procedure set_KDF9_configuration is
   921.          use equipment_IO;
   922.          use IOC.equipment;
   923.          d : IOC.equipment.kind := AD;
   924.          b : KDF9.buffer_number;
   925.       begin
   926.          if version = "1" then
   927.             for i in IOC.equipment.setup'Range loop
   928.             exit when end_of_line(settings_file);
   929.                get_word(settings_file, KDF9.word(b));
   930.                ensure_not_at_end_of_line(settings_file);
   931.                get(settings_file, d);
   932.                IOC.equipment.choice(b) := d;
   933.             end loop;
   934.          else
   935.             log_new_line;
   936.             log_line("The previous KDF9 configuration is still being used.");
   937.          end if;
   938.          if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   939.       exception
   940.          when others =>
   941.             error_count := error_count + 1;
   942.             if not End_Of_Line(settings_file) then Skip_Line(settings_file); end if;
   943.             IOC.equipment.choice := IOC.equipment.default;
   944.             log_new_line;
   945.             log_line("**** Error in the device configuration; defaults used.");
   946.       end set_KDF9_configuration;
   947.
   948.       procedure set_symbols is
   949.          c : Character := ' ';
   950.          a : KDF9.address;
   951.          v : Natural;
   952.          p : Natural;
   953.       begin
   954.          if End_Of_Line(settings_file) then
   955.             clear_all_symbol_definitions;
   956.             return;
   957.          end if;
   958.          get(settings_file, c);
   959.          case c is
   960.             when '#' =>
   961.                get(settings_file, c);
   962.                get_word(settings_file, KDF9.word(a));
   963.                if c = 'V' then
   964.                   set_main_program_V_size(Natural(a));
   965.                elsif c = 'Y' then
   966.                   set_Y_size(if a = KDF9.address'Last then 0 else a);
   967.                else
   968.                   raise Data_Error;
   969.                end if;
   970.             when 'W' =>
   971.                get_word(settings_file, KDF9.word(a));
   972.                set_W0(a);
   973.             when 'Y' =>
   974.                get_word(settings_file, KDF9.word(a));
   975.                set_Y0(a);
   976.             when 'Z' =>
   977.                get_word(settings_file, KDF9.word(a));
   978.                set_Z0(a);
   979.             when 'P' =>
   980.                skip_to_next_non_blank(settings_file);
   981.                get_word(settings_file, KDF9.word(p));
   982.                skip_to_next_non_blank(settings_file);
   983.                get(settings_file, c);
   984.                if c = 'V' then
   985.                   get_decimal(settings_file, KDF9.word(v));
   986.                   skip_to_next_non_blank(settings_file);
   987.                   get(settings_file, c);
   988.                   if c /= '@' then raise Data_Error; end if;
   989.                   skip_to_next_non_blank(settings_file);
   990.                   get_word(settings_file, KDF9.word(a));
   991.                   site_Pp(p, a, v);
   992.                else
   993.                   if c /= '@' then raise Data_Error; end if;
   994.                   skip_to_next_non_blank(settings_file);
   995.                   get_word(settings_file, KDF9.word(a));
   996.                   site_Pp(p, a);
   997.                end if;
   998.             when ' ' =>
   999.                skip_to_next_non_blank(settings_file);
  1000.                get(settings_file, c);
  1001.                if c not in 'A' .. 'Z'  then
  1002.                   raise Data_Error;
  1003.                end if;
  1004.                get_word(settings_file, KDF9.word(a));
  1005.                set_Yy0(c, a);
  1006.             when others =>
  1007.                raise Data_Error;
  1008.          end case;
  1009.       exception
  1010.          when Data_Error =>
  1011.             error_count := error_count + 1;
  1012.             if not End_Of_Line(settings_file) then
  1013.                Skip_Line(settings_file);
  1014.             end if;
  1015.             log_new_line;
  1016.             log_line(
  1017.                      "**** Error in a Y flag specification: "
  1018.                    & "invalid data after"
  1019.                    + abs c
  1020.                    & "."
  1021.                     );
  1022.       end set_symbols;
  1023.
  1024.    begin -- get_settings_from_file
  1025.
  1026.       do_not_execute := False;
  1027.       high_count := time_limit;
  1028.       open_options_file(settings_file, the_settings_file_name);
  1029.       if End_of_File(settings_file) then
  1030.          raise End_Error;
  1031.       end if;
  1032.
  1033.       loop
  1034.          skip_to_next_nonempty_line(settings_file);
  1035.          get(settings_file, flag);
  1036.          case flag is
  1037.             when 'A' | 'a' =>
  1038.                set_authenticity;
  1039.             when 'B' | 'b' =>
  1040.                set_breakpoints;
  1041.             when 'C' | 'c' =>
  1042.                set_tracing_counts;
  1043.             when 'D' | 'd' =>
  1044.                set_diagnostic_mode;
  1045.             when 'F' | 'f' =>
  1046.                set_final_dumping_ranges;
  1047.             when 'G' | 'g' =>
  1048.                set_graph_plotting_pen;
  1049.             when 'H' | 'h' =>
  1050.                set_histogram_options;
  1051.             when 'I' | 'i' =>
  1052.                set_initial_dumping_ranges;
  1053.             when 'K' | 'k' =>
  1054.                set_KDF9_configuration;
  1055.             when 'L' | 'l' =>
  1056.                set_time_limit;
  1057.             when 'N' | 'n' =>
  1058.                set_non_interactivity;
  1059.                time_limit := offline_time_limit;
  1060.             when 'O' |'o' =>
  1061.                set_this_miscellany_flag(flag);
  1062.             when 'P' | 'p' =>
  1063.                save_poke_value;
  1064.             when 'Q' | 'q' =>
  1065.                do_not_execute := True;
  1066.             when 'R' | 'r' =>
  1067.                set_tracing_range;
  1068.             when 'S' | 's' =>
  1069.                set_store_points;
  1070.             when 'T' | 't' =>
  1071.                set_execution_mode;
  1072.             when 'V' | 'v' =>
  1073.                set_the_miscellany_flags;
  1074.             when 'W' | 'w' =>
  1075.                set_watchpoints;
  1076.             when 'X' | 'x' =>
  1077.                only_signature_tracing := True;
  1078.             when 'Y' | 'y' =>
  1079.                set_symbols;
  1080.             when '-' | '/' =>
  1081.                Skip_Line(settings_file);
  1082.             when others =>
  1083.                error_count := error_count + 1;
  1084.                log_line(
  1085.                         "**** Invalid flag:"
  1086.                       + abs flag
  1087.                       + "at line"
  1088.                       & line_number'Image
  1089.                       + "of the settings file!"
  1090.                        );
  1091.                log_line("     The valid flags are A,B,C,D,F,G,H,I,K,L,N,O,P,Q,R,S,T,V,W,X,Y -, and /");
  1092.                Skip_Line(settings_file);
  1093.                line_number := line_number + 1;
  1094.          end case;
  1095.
  1096.          if error_count > 10 then
  1097.             log_new_line;
  1098.             log_line("**** There are too many invalid flags in" + the_settings_file_name & ".");
  1099.             raise operator_error;
  1100.          end if;
  1101.       end loop;
  1102.
  1103.    exception
  1104.
  1105.       when Status_Error =>
  1106.          log_line("**** Error:" + the_settings_file_name + "was not found; defaults used.");
  1107.          log_new_line;
  1108.
  1109.       when End_Error =>
  1110.          close_options_file(settings_file, the_settings_file_name);
  1111.
  1112.       when operator_error  =>
  1113.          trap_operator_error("Abandoning the run");
  1114.
  1115.       when Data_Error =>
  1116.          close_options_file(settings_file, the_settings_file_name);
  1117.          if error_count < 10 then
  1118.             log_new_line;
  1119.             log_line("**** Error: invalid data in the settings file.");
  1120.             log_line(
  1121.                      "Reading of settings abandoned at line"
  1122.                    & line_number'Image
  1123.                    + "of"
  1124.                    + the_settings_file_name
  1125.                    & "."
  1126.                     );
  1127.          else
  1128.             raise;
  1129.          end if;
  1130.
  1131.       when error : others =>
  1132.          close_options_file(settings_file, the_settings_file_name);
  1133.          log_new_line;
  1134.          log_line(
  1135.                   "Failure in ee9; unexpected exception:"
  1136.                 + Exception_Information(error)
  1137.                 + "in get_settings_from_file!"
  1138.                  );
  1139.          log_line(
  1140.                   "Reading of settings abandoned at line"
  1141.                 & line_number'Image
  1142.                 + "of"
  1143.                 + the_settings_file_name
  1144.                 & "!"
  1145.                  );
  1146.          log_rule;
  1147.          raise;
  1148.
  1149.    end get_settings_from_file;
  1150.
  1151. end settings;

Compiling: ../Source/settings.ads
Source file time stamp: 2022-09-06 16:53:21
Compiled at: 2022-09-15 15:08:00

     1. -- execution mode, diagnostic mode, and other emulation-control settings
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18. with logging.file;
    19.
    20. use  KDF9;
    21. use  logging.file;
    22.
    23. package settings is
    24.
    25. --
    26.    -- In fast mode: code runs as efficiently as possible, without diagnostics.
    27.
    28.    -- In trace mode: breakpoints, watchpoints, tracing address bounds and
    29.    --    tracing instruction count bounds are all honoured;
    30.    --       entries may be made in all the retrospective trace logs;
    31.    --          a digital execution signature may be computed,
    32.    --             and an instruction-frequency histogram may be generated.
    33.
    34.    -- In pause mode: execution proceeds as in trace mode;
    35.    --    additionally, breakpoints occur on every order executed within trace bounds.
    36.
    37.    -- The external mode is a user-interface value only. It requests the trace mode,
    38.    --    combined with the logging of a running trace to an external file.
    39. --
    40.
    41.    type diagnostic_mode is (fast_mode,
    42.                             trace_mode,
    43.                             pause_mode,
    44.                             external_mode);
    45.
    46.    procedure set_diagnostic_mode (a_diagnostic_mode : in settings.diagnostic_mode);
    47.
    48.    procedure change_diagnostic_mode_if_requested;
    49.
    50.    the_diagnostics_default  : constant settings.diagnostic_mode := fast_mode;
    51.    the_diagnostic_mode      : settings.diagnostic_mode := the_diagnostics_default;
    52.
    53.    the_external_trace_file_name : constant String := "trace.txt";
    54.    only_signature_tracing       : Boolean := False;
    55.    the_external_trace_file      : logging.file.output;
    56.
    57.    -- The diagnostic generation and display controls, inter alia.
    58.    -- The *_trace_is_wanted flags are set to True iff
    59.    --    they are both requested, and offered by the_diagnostic_mode.
    60.    -- These requests may be set by the miscellany and visibilty options.
    61.
    62.    miscellany_flags  : constant String := "abcdefghiknopqrstwxyz.0123456789ABCDEFGHIKMNOPQRSTWXYZ";
    63.    miscellany_prompt : constant String := "{a|b|c|d|e|f|g|h|i|k|n|o|p|q|r|s|t|w|x|z|.|0..9}";
    64.
    65.    -- *_is_wanted  iff the facility is provided by default.
    66.    -- *_is_enabled iff the facility is wanted and not suppressed by other considerations,
    67.    --    such as the diagnostic mode (e.g. fast mode suppresses all tracing).
    68.
    69.    API_logging_is_wanted,
    70.    flexowriter_output_is_wanted,
    71.    histogramming_is_wanted,
    72.    interrupt_tracing_is_wanted,
    73.    peripheral_tracing_is_wanted,
    74.    realistic_FW_output_is_wanted,
    75.    retrospective_tracing_is_wanted,
    76.    the_final_state_is_wanted,
    77.    the_log_is_wanted,
    78.    the_signature_is_wanted         : Boolean := True;
    79.
    80.    authentic_timing_is_enabled,
    81.    core_file_is_enabled,
    82.    debugging_is_enabled,
    83.    do_not_execute,
    84.    histogramming_is_enabled,
    85.    interrupt_tracing_is_enabled,
    86.    noninteractive_usage_is_enabled,
    87.    peripheral_tracing_is_enabled,
    88.    pre_overlay_state_is_enabled,
    89.    retrospective_tracing_is_enabled,
    90.    the_external_trace_is_enabled,
    91.    the_signature_is_enabled        : Boolean := False;
    92.
    93.    procedure reset_default_visibility_options;
    94.
    95.    -- In boot_mode: a Director program is read from TR0 and executed
    96.    --    in Director state, with full use of the emulated hardware.
    97.    -- In program_mode: a user program is read from TR0 and executed
    98.    --    in program state, with basic OUTs implemented by the emulator.
    99.    -- In privileged_mode: a user program is read from TR0 and executed
   100.    --    as in program state, but allowing orders that should LIV to succeed,
   101.    --    this being useful for executing "hardware test" programs.
   102.
   103.    type execution_mode is (boot_mode, program_mode, privileged_mode);
   104.
   105.    procedure set_execution_mode (an_execution_mode : in settings.execution_mode);
   106.
   107.    the_execution_default   : constant settings.execution_mode := program_mode;
   108.    the_execution_mode      :          settings.execution_mode := the_execution_default;
   109.
   110.    this_is_a_bare_Director : Boolean := False;
   111.
   112.    --
   113.    -- Tracing bound settings.
   114.    --
   115.
   116.    -- time_limit bounds the number of KDF9 instructions executed.
   117.
   118.    time_limit_default : constant KDF9.order_counter := KDF9.order_counter'Last;
   119.    time_slice         : constant KDF9.order_counter := 10_000;
   120.    offline_time_limit : constant KDF9.order_counter := 10_000 * time_slice;
   121.    time_limit         :          KDF9.order_counter := time_limit_default;
   122.
   123.
   124.    -- low_bound and high_bound bound the static scope of tracing.
   125.
   126.    low_bound_default  : constant KDF9.code_address := 0;
   127.    high_bound_default : constant KDF9.code_address := KDF9.code_address'Last;
   128.    low_bound          :          KDF9.code_address := low_bound_default;
   129.    high_bound         :          KDF9.code_address := high_bound_default;
   130.
   131.    -- low_count and high_count bound the dynamic scope of tracing.
   132.
   133.    low_count_default  : constant KDF9.order_counter := 0;
   134.    high_count_default : constant KDF9.order_counter := time_limit_default;
   135.    low_count          :          KDF9.order_counter := low_count_default;
   136.    high_count         :          KDF9.order_counter := high_count_default;
   137.
   138.    -- Histogram bin frequencies less than histogram_cutoff are not logged.
   139.    the_profile_is_wanted  :          Boolean := False;
   140.    the_INS_plot_is_wanted :          Boolean := False;
   141.    cutoff_default         : constant Long_Float := 0.0;
   142.    histogram_cutoff       :          Long_Float := cutoff_default;
   143.
   144.    function is_invalid_miscellany_flag (option : in Character)
   145.    return Boolean;
   146.
   147.    procedure set_this_miscellany_flag (option : in Character);
   148.
   149.    procedure get_settings_from_file (version : in String);
   150.
   151.    procedure display_execution_modes (for_this : in String := "");
   152.
   153.    procedure quit_if_requested;
   154.
   155.    quit_was_requested          : Boolean := False;
   156.
   157.    the_diagnostic_mode_changed : Boolean := False;
   158.
   159.    loading_was_successful      : Boolean := False;
   160.
   161.    mode_change_request         : exception;
   162.
   163. end settings;

 1151 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/logging-panel.adb
Source file time stamp: 2022-09-06 00:07:21
Compiled at: 2022-09-15 15:08:00

     1. -- Provide logging output to an interactive terminal/control panel.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with POSIX;
    18. with settings;
    19.
    20. use  POSIX;
    21. use  settings;
    22.
    23. package body logging.panel is
    24.
    25.    not overriding
    26.    function column (logger : panel.display)
    27.    return Positive
    28.    is (logger.column_number);
    29.
    30.    overriding
    31.    procedure tab_log (logger   : in out panel.display;
    32.                       at_least : in Natural;
    33.                       spacing  : in Positive;
    34.                       iff      : in Boolean := True) is
    35.       new_col : constant Natural := logger.column_number + at_least;
    36.       deficit : constant Natural := (spacing - new_col mod spacing) mod spacing;
    37.    begin
    38.       if logger.panel_is_shut then return; end if;
    39.       if not iff then return; end if;
    40.       for i in logger.column_number .. (new_col + deficit) loop
    41.          POSIX.output(' ');
    42.       end loop;
    43.       logger.column_number := new_col + deficit;
    44.    end tab_log;
    45.
    46.    overriding
    47.    procedure tab_log_to (logger : in out panel.display;
    48.                          column : in Positive;
    49.                          iff    : in Boolean := True) is
    50.    begin
    51.       if logger.panel_is_shut then return; end if;
    52.       if not iff then return; end if;
    53.       if column < logger.column_number then
    54.          logger.log_new_line;
    55.       end if;
    56.       for i in logger.column_number .. column-1 loop
    57.          POSIX.output(' ');
    58.       end loop;
    59.       logger.column_number := column;
    60.    end tab_log_to;
    61.
    62.    overriding
    63.    procedure log (logger : in out panel.display;
    64.                   char   : in Character;
    65.                   iff    : in Boolean := True) is
    66.    begin
    67.       if logger.panel_is_shut then return; end if;
    68.       if not iff then return; end if;
    69.       POSIX.output(char);
    70.       logger.column_number := logger.column_number + 1;
    71.    end log;
    72.
    73.    overriding
    74.    procedure log (logger : in out panel.display;
    75.                   text   : in String;
    76.                   iff    : in Boolean := True) is
    77.    begin
    78.       if logger.panel_is_shut then return; end if;
    79.       if not iff then return; end if;
    80.       if text /= "" then
    81.          POSIX.output(text);
    82.       end if;
    83.       logger.column_number := logger.column_number + text'Length;
    84.    end log;
    85.
    86.    overriding
    87.    procedure log_new_line (logger : in out panel.display;
    88.                            iff    : in Boolean := True) is
    89.    begin
    90.       if logger.panel_is_shut then return; end if;
    91.       if not iff then return; end if;
    92.       POSIX.output_line;
    93.       logger.column_number := 1;
    94.    end log_new_line;
    95.
    96.    not overriding
    97.    procedure show_line (logger : in out panel.display; message : in String := "") is
    98.    begin
    99.       if logger.panel_is_shut then return; end if;
   100.       if message /= "" then
   101.          logger.log(message);
   102.       end if;
   103.       logger.log_new_line;
   104.    end show_line;
   105.
   106.    not overriding
   107.    procedure interact (logger : in out panel.display; reason : in String := "Mode") is
   108.       old_mode : constant settings.diagnostic_mode := the_diagnostic_mode;
   109.       response : response_kind;
   110.       choice   : Character;
   111.    begin
   112.    if logger.panel_is_shut then return; end if;
   113.    interaction_loop:
   114.       loop
   115.          logger.column_number := 1;
   116.          POSIX.debug_prompt(noninteractive_usage_is_enabled, reason, response, choice);
   117.          if response = debug_response then
   118.             case choice is
   119.                when 'q' | 'Q' =>
   120.                   quit_was_requested := True;
   121.                   exit interaction_loop;
   122.                when 'd' | 'D' =>
   123.                   debugging_is_enabled := not debugging_is_enabled;
   124.                   exit interaction_loop;
   125.                when 'f' | 'F' =>
   126.                   set_diagnostic_mode(fast_mode);
   127.                   exit interaction_loop;
   128.                when 'p' | 'P' =>
   129.                   set_diagnostic_mode(pause_mode);
   130.                   exit interaction_loop;
   131.                when 't' | 'T' =>
   132.                   set_diagnostic_mode(trace_mode);
   133.                   exit interaction_loop;
   134.                when others =>
   135.                   null; -- An invalid choice, try again.
   136.             end case;
   137.          elsif response = EOF_response then
   138.             exit;
   139.          end if;
   140.       end loop interaction_loop;
   141.       the_diagnostic_mode_changed := (the_diagnostic_mode /= old_mode) or quit_was_requested;
   142.    end interact;
   143.
   144.    overriding
   145.    procedure open (logger : in out panel.display; logfile_name : in String) is
                                                          |
        >>> warning: formal parameter "logfile_name" is not referenced

   146.    begin
   147.       if not logger.panel_is_shut then return; end if;
   148.       logger.panel_is_shut := False;
   149.    end open;
   150.
   151.    overriding
   152.    procedure close  (logger : in out panel.display) is
   153.    begin
   154.       if logger.panel_is_shut then return; end if;
   155.       logger.panel_is_shut := True;
   156.    end close;
   157.
   158. end logging.panel;

Compiling: ../Source/logging-panel.ads
Source file time stamp: 2022-09-06 00:07:08
Compiled at: 2022-09-15 15:08:00

     1. -- Provide logging output to an interactive terminal/control panel.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package logging.panel is
    18.
    19.    type display is new logging.output with private;
    20.
    21.    not overriding
    22.    function column (logger : panel.display)
    23.    return Positive;
    24.
    25.    overriding
    26.    procedure tab_log (logger   : in out panel.display;
    27.                       at_least : in Natural;
    28.                       spacing  : in Positive;
    29.                       iff      : in Boolean := True);
    30.
    31.    overriding
    32.    procedure tab_log_to (logger : in out panel.display;
    33.                          column : in Positive;
    34.                          iff    : in Boolean := True);
    35.
    36.    overriding
    37.    procedure log (logger : in out panel.display;
    38.                   char   : in Character;
    39.                   iff    : in Boolean := True);
    40.
    41.    overriding
    42.    procedure log (logger : in out panel.display;
    43.                   text   : in String;
    44.                   iff    : in Boolean := True);
    45.
    46.    overriding
    47.    procedure log_new_line (logger : in out panel.display;
    48.                            iff    : in Boolean := True);
    49.
    50.    not overriding
    51.    procedure show_line (logger : in out panel.display; message : in String := "");
    52.
    53.    not overriding
    54.    procedure interact (logger : in out panel.display; reason : in String := "Mode");
    55.
    56.    overriding
    57.    procedure open (logger : in out panel.display; logfile_name : in String);
    58.
    59.    overriding
    60.    procedure close (logger : in out panel.display);
    61.
    62.    overriding
    63.    procedure flush (logger : in out panel.display; iff : in Boolean := True) is null;
    64.
    65. private
    66.
    67.    type display is new logging.output with
    68.       record
    69.          column_number : Positive := 1;
    70.          panel_is_shut : Boolean := True;
    71.       end record;
    72.
    73. end logging.panel;


GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/break_in.adb
Source file time stamp: 2022-09-06 15:41:13
Compiled at: 2022-09-15 15:08:00

     1. -- This communicates a break-in to the microcode.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with exceptions;
    18. with HCI;
    19. with KDF9;
    20. with POSIX;
    21. with finalize_ee9;
    22. with settings;
    23. with state_display;
    24.
    25. use  exceptions;
    26. use  HCI;
    27. use  KDF9;
    28. use  settings;
    29. use  state_display;
    30.
    31. package body break_in is
    32.
    33.    requested : Natural := 0
    34.       with Atomic, Volatile;
    35.
    36.    procedure note_user_interrupt is
    37.    begin
    38.       requested := requested + 1;
    39.       if requested > 1 then
    40.          -- A previous interrupt has not been serviced and the user is getting antsy.
    41.          -- Perhaps ee9 itself has gone into an infinite loop, so abandon the run.
    42.          finalize_ee9("Run abandoned by the user");
    43.          POSIX.exit_program(0);
    44.       end if;
    45.    end note_user_interrupt;
    46.
    47.    function has_been_requested
    48.    return Boolean is
    49.    begin
    50.       return requested /= 0;
    51.    end has_been_requested;
    52.
    53.    procedure handler is
    54.    begin
    55.       requested := 0;
    56.       interact("Break-in");
    57.       quit_if_requested;
    58.       if the_execution_mode = boot_mode then
    59.          effect_interrupt(caused_by_FLEX, "the operator interrupts");
    60.       else
    61.          show_current_state;
    62.       end if;
    63.       flush;
    64.    exception
    65.       when quit_request =>
    66.          finalize_ee9("Quit requested by the user");
    67.          POSIX.exit_program(0);
    68.    end handler;
    69.
    70. end break_in;

Compiling: ../Source/break_in.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:00

     1. -- This conveys a break-in to the microcode.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package break_in is
    18.
    19.    function has_been_requested
    20.    return Boolean
    21.       with Inline;
    22.
    23.    procedure note_user_interrupt;
    24.
    25.    procedure handler;
    26.
    27. end break_in;

 70 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/dumping.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:00

     1. -- Provide support for diagnostic core-dumping area descriptions.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with state_display;
    18. with string_editing;
    19.
    20. use  state_display;
    21. use  string_editing;
    22.
    23. package body dumping is
    24.
    25.    type poke_list_entry is
    26.       record
    27.          address  : KDF9.address;
    28.          sub_word : sub_word_flag;
    29.          position : KDF9.address;
    30.          value    : KDF9.word;
    31.       end record;
    32.
    33.    length_of_poke_list : constant := 100;
    34.    poke_list_count     : Natural range 0 .. length_of_poke_list := 0;
    35.    poke_list           : array (Positive range 1 .. length_of_poke_list) of poke_list_entry;
    36.
    37.    use dumping.flag_support;
    38.
    39.    function dumping_flag (c : Character)
    40.    return dumping.flag
    41.    is (dumping.flag(upper(c)));
    42.
    43.    type area is
    44.       record
    45.          format_set  : dumping.format_set := no_dumping_flags;
    46.          first, last : KDF9.address;
    47.       end record;
    48.
    49.    no_dumping_area : constant dumping.area := (no_dumping_flags, 0, 0);
    50.
    51.    dumping_areas : array (dumping.area_number) of dumping.area := (others => no_dumping_area);
    52.
    53.    pre_dumping_area_count  : area_count := 0;
    54.    post_dumping_area_count : area_count := 0;
    55.
    56.    function nr_of_pre_dumping_areas
    57.    return dumping.area_count
    58.    is (pre_dumping_area_count);
    59.
    60.    function nr_of_post_dumping_areas
    61.    return dumping.area_count
    62.    is (post_dumping_area_count);
    63.
    64.    procedure request_a_dumping_area (
    65.                                      format_set  : in dumping.format_set;
    66.                                      first, last : in KDF9.address;
    67.                                      was_stored  : out Boolean
    68.                                     ) is
    69.    begin
    70.       was_stored := False;
    71.       if pre_dumping_area_count+post_dumping_area_count = nr_of_dumping_areas then
    72.          return;
    73.       end if;
    74.       for d of dumping_areas loop
    75.          if d = (format_set, first, last) then
    76.             was_stored := True;
    77.             return;
    78.          end if;
    79.       end loop;
    80.       for d of dumping_areas loop
    81.          if d.format_set = no_dumping_flags then
    82.             d := (format_set, first, last);
    83.             was_stored := True;
    84.             if format_set/initial_flag then
    85.                pre_dumping_area_count := pre_dumping_area_count + 1;
    86.             end if;
    87.             if format_set/final_flag then
    88.                post_dumping_area_count := post_dumping_area_count + 1;
    89.             end if;
    90.             return;
    91.          end if;
    92.       end loop;
    93.    end request_a_dumping_area;
    94.
    95.    procedure print_formatted_area (d : in dumping.area) is
    96.       format_set  : constant dumping.format_set := d.format_set;
    97.       first       : constant KDF9.address := d.first;
    98.       last        : constant KDF9.address := d.last;
    99.    begin
   100.       if format_set/tape_code_flag then
   101.          show_core_in_tape_code(first, last);
   102.       end if;
   103.       if format_set/normal_flag then
   104.          show_core_in_case_normal(first, last);
   105.       end if;
   106.       if format_set/shift_flag then
   107.          show_core_in_case_shift(first, last);
   108.       end if;
   109.       if format_set/ card_code_flag then
   110.          show_core_in_card_code(first, last);
   111.       end if;
   112.       if format_set/printer_flag then
   113.          show_core_in_print_code(first, last);
   114.       end if;
   115.       if format_set/ASCII_flag then
   116.          show_core_in_Latin_1(first, last);
   117.       end if;
   118.       if format_set/word_flag then
   119.          show_core_as_word_forms(
   120.                                  first, last,
   121.                                  octal_option => not format_set/decimal_flag
   122.                                 );
   123.       end if;
   124.       if format_set/Usercode_flag then
   125.          show_core_as_Usercode(
   126.                                (KDF9.code_address(first), 0),
   127.                                (KDF9.code_address(last),  0),
   128.                                 octal_option => not format_set/decimal_flag
   129.                               );
   130.       end if;
   131.       if format_set/orders_flag then
   132.          show_core_as_syllables(
   133.                                 (KDF9.code_address(first), 0),
   134.                                 (KDF9.code_address(last),  0)
   135.                                );
   136.       end if;
   137.    end print_formatted_area;
   138.
   139.    procedure print_dump_areas (flag : in dumping.flag; count : in dumping.area_count) is
   140.       Usercode_wanted : Boolean := False;
   141.    begin
   142.       if count = 0 then
   143.          return;
   144.       end if;
   145.       for d of dumping_areas loop
   146.          Usercode_wanted := Usercode_wanted or d.format_set/Usercode_flag;
   147.       end loop;
   148.       if Usercode_wanted then
   149.          mark_all_code_blocks_and_data_blocks(pre_run => flag = initial_flag);
   150.       end if;
   151.       for d of dumping_areas loop
   152.          if d.format_set/flag then
   153.             print_formatted_area(d);
   154.          end if;
   155.       end loop;
   156.    end print_dump_areas;
   157.
   158.    procedure print_prerun_dump_areas is
   159.    begin
   160.       print_dump_areas(initial_flag, pre_dumping_area_count);
   161.    end print_prerun_dump_areas;
   162.
   163.    procedure print_postrun_dump_areas is
   164.    begin
   165.       print_dump_areas(final_flag, post_dumping_area_count);
   166.    end print_postrun_dump_areas;
   167.
   168.    procedure remove_dump_areas (flag : in dumping.flag; count : in out dumping.area_count) is
   169.    begin
   170.       if count = 0 then
   171.          return;
   172.       end if;
   173.       for d of dumping_areas loop
   174.          if d.format_set/flag then
   175.             d := no_dumping_area;
   176.          end if;
   177.       end loop;
   178.       count := 0;
   179.    end remove_dump_areas;
   180.
   181.    procedure remove_prerun_dump_areas is
   182.    begin
   183.       remove_dump_areas(initial_flag, pre_dumping_area_count);
   184.    end remove_prerun_dump_areas;
   185.
   186.    procedure remove_postrun_dump_areas is
   187.    begin
   188.       remove_dump_areas(final_flag, post_dumping_area_count);
   189.    end remove_postrun_dump_areas;
   190.
   191.    procedure add_to_poke_list (address    : in KDF9.address;
   192.                                sub_word   : in sub_word_flag;
   193.                                position   : in KDF9.address;
   194.                                value      : in KDF9.word;
   195.                                was_stored : out Boolean) is
   196.    begin
   197.       if poke_list_count < length_of_poke_list then
   198.          poke_list_count := poke_list_count + 1;
   199.          poke_list(poke_list_count) := (address, sub_word, position, value);
   200.          was_stored := True;
   201.       else
   202.          was_stored := False;
   203.       end if;
   204.    end add_to_poke_list;
   205.
   206.    procedure poke_all_amendments is
   207.    begin
   208.       for p in 1..poke_list_count loop
   209.          poke(poke_list(p).address, poke_list(p).sub_word, poke_list(p).position, poke_list(p).value);
   210.       end loop;
   211.       poke_list_count := 0;
   212.    end poke_all_amendments;
   213.
   214. end dumping;

Compiling: ../Source/dumping.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:00

     1. -- Provide support for diagnostic core-dumping area descriptions.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with generic_sets;
    18. with KDF9;
    19.
    20. use  KDF9;
    21.
    22. package dumping is
    23.
    24.    type flag is new Character range '@' .. 'Z';
    25.
    26.    no_flag        : constant dumping.flag := '@';
    27.    ASCII_flag     : constant dumping.flag := 'A';
    28.    card_code_flag : constant dumping.flag := 'C';
    29.    decimal_flag   : constant dumping.flag := 'D';
    30.    single_flag    : constant dumping.flag := 'E';
    31.    final_flag     : constant dumping.flag := 'F';
    32.    half_flag      : constant dumping.flag := 'H';
    33.    initial_flag   : constant dumping.flag := 'I';
    34.    normal_flag    : constant dumping.flag := 'N';
    35.    orders_flag    : constant dumping.flag := 'O';
    36.    printer_flag   : constant dumping.flag := 'L';
    37.    shift_flag     : constant dumping.flag := 'S';
    38.    tape_code_flag : constant dumping.flag := 'T';
    39.    Usercode_flag  : constant dumping.flag := 'U';
    40.    word_flag      : constant dumping.flag := 'W';
    41.
    42.    function dumping_flag (c : Character)
    43.    return dumping.flag;
    44.
    45.    package flag_support is new generic_sets(member => dumping.flag);
    46.
    47.    subtype format_set is flag_support.set;
    48.    use type format_set;
    49.
    50.    is_parameter_flag : constant dumping.format_set
    51.                      := (  decimal_flag
    52.                          | single_flag
    53.                          | half_flag
    54.                          | ASCII_flag
    55.                          | orders_flag
    56.                          | printer_flag
    57.                          | tape_code_flag
    58.                          | Usercode_flag
    59.                          | card_code_flag
    60.                          | normal_flag
    61.                          | shift_flag
    62.                          | word_flag     => True,
    63.                            others        => False
    64.                         );
    65.
    66.
    67.    is_order_flag : constant dumping.format_set
    68.                  := (  orders_flag
    69.                      | Usercode_flag => True,
    70.                        others        => False
    71.                     );
    72.
    73.    is_epoch_flag : constant dumping.format_set
    74.                  := (  initial_flag
    75.                      | final_flag => True,
    76.                        others     => False
    77.                     );
    78.
    79.    is_dumping_flag  : constant dumping.format_set
    80.                     := is_parameter_flag or is_epoch_flag;
    81.
    82.    no_dumping_flags : constant dumping.format_set
    83.                     := flag_support.empty_set;
    84.
    85.    nr_of_dumping_areas : constant := 100;
    86.    subtype area_count  is Natural  range 0 .. nr_of_dumping_areas;
    87.    subtype area_number is Positive range 1 .. nr_of_dumping_areas;
    88.
    89.    procedure request_a_dumping_area (
    90.                                      format_set  : in dumping.format_set;
    91.                                      first, last : in KDF9.address;
    92.                                      was_stored  : out Boolean
    93.                                     );
    94.
    95.    procedure print_prerun_dump_areas;
    96.
    97.    procedure remove_prerun_dump_areas;
    98.
    99.    procedure print_postrun_dump_areas;
   100.
   101.    procedure remove_postrun_dump_areas;
   102.
   103.    function nr_of_pre_dumping_areas
   104.    return dumping.area_count;
   105.
   106.    function nr_of_post_dumping_areas
   107.    return dumping.area_count;
   108.
   109.    no_specification : constant String := "";
   110.
   111.    subtype sub_word_flag is Character
   112.       with Static_Predicate =>
   113.          sub_word_flag in 'S' | 's' | 'C' | 'c' | 'L' | 'l' | 'U' | 'u' | 'W' | 'w';
   114.
   115.    -- poke support is in dumping because it is needed at the same time during initialization.
   116.    procedure add_to_poke_list (
   117.                                address    : in KDF9.address;
   118.                                sub_word   : in sub_word_flag;
   119.                                position   : in KDF9.address;
   120.                                value      : in KDF9.word;
   121.                                was_stored : out Boolean
   122.                               );
   123.
   124.    -- poke_all_amendments effects all stored pokes and then clears the poke list for reuse.
   125.    procedure poke_all_amendments;
   126.
   127. end dumping;

 214 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9.adb
Source file time stamp: 2022-09-05 22:36:46
Compiled at: 2022-09-15 15:08:00

     1. -- The machine-state manipulations used by the CPU microcode.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Calendar;
    18. with Ada.Calendar.Time_Zones;
    19. with Ada.Calendar.Formatting;
    20. with Ada.Unchecked_Conversion;
    21. --
    22. with exceptions;
    23. with KDF9.CPU;
    24. with KDF9.decoding;
    25. with KDF9.PHU_store;
    26. with KDF9.store;
    27. with settings;
    28. with tracing;
    29.
    30. use  Ada.Calendar;
    31. use  Ada.Calendar.Time_Zones;
    32. use  Ada.Calendar.Formatting;
    33. --
    34. use  exceptions;
    35. use  KDF9.CPU;
    36. use  KDF9.decoding;
    37. use  KDF9.PHU_store;
    38. use  KDF9.store;
    39. use  settings;
    40. use  tracing;
    41.
    42. package body KDF9 is
    43.
    44.    C_part_scale : constant := 2**32;
    45.    I_part_scale : constant := 2**16;
    46.    Q_part_scale : constant := 2**16;
    47.
    48.    function as_Q (the_word : KDF9.word)
    49.    return KDF9.Q_register
    50.    is (
    51.        (C => KDF9.Q_part(KDF9.word'(the_word / C_part_scale) mod Q_part_scale),
    52.         I => KDF9.Q_part(KDF9.word'(the_word / I_part_scale) mod Q_part_scale),
    53.         M => KDF9.Q_part(the_word mod Q_part_scale)
    54.        )
    55.       );
    56.
    57.    function as_word (the_Q : KDF9.Q_register)
    58.    return KDF9.word
    59.    is (KDF9.word(the_Q.C)*C_part_scale or KDF9.word(the_Q.I)*I_part_scale or KDF9.word(the_Q.M));
    60.
    61.    function sign_extended (Q : KDF9.Q_part)
    62.    return KDF9.word
    63.    is (unsign(CPU.signed(resign(Q))));
    64.
    65.    function as_word (the_link : KDF9.SJNS_link)
    66.    return KDF9.word is
    67.       function link_Q_part is new Ada.Unchecked_Conversion(KDF9.SJNS_link, KDF9.Q_part);
    68.    begin
    69.       return KDF9.word(link_Q_part(the_link));
    70.    end as_word;
    71.
    72.    function as_link (the_word : KDF9.word)
    73.    return KDF9.SJNS_link is
    74.       function Q_part_link is new Ada.Unchecked_Conversion(KDF9.Q_part, KDF9.SJNS_link);
    75.    begin
    76.       return Q_part_link(KDF9.Q_part(the_word and Q_part_mask));
    77.    end as_link;
    78.
    79.    procedure ensure_that_the_SJNS_is_not_empty is
    80.    begin
    81.       if the_SJNS_depth > 0             or else
    82.             the_CPU_state = Director_state then
    83.          return;
    84.       end if;
    85.       effect_interrupt(caused_by_NOUV, "empty SJNS");
    86.    end ensure_that_the_SJNS_is_not_empty;
    87.
    88.    procedure ensure_that_the_SJNS_is_not_full is
    89.    begin
    90.       if the_SJNS_depth < 16             or else
    91.             the_CPU_state = Director_state  then
    92.          return;
    93.       end if;
    94.       effect_interrupt(caused_by_NOUV, "full SJNS");
    95.    end ensure_that_the_SJNS_is_not_full;
    96.
    97.    procedure push (the_link : in KDF9.syllable_address) is
    98.    begin
    99.       the_SJNS(the_SJNS_depth) := KDF9.SJNS_link(the_link);
   100.       the_SJNS_depth := the_SJNS_depth + 1;
   101.    end push;
   102.
   103.    function pop
   104.    return KDF9.syllable_address is
   105.    begin
   106.       the_SJNS_depth := the_SJNS_depth - 1;
   107.       return KDF9.syllable_address(the_SJNS(the_SJNS_depth));
   108.    end pop;
   109.
   110.    function SJNS_top
   111.    return KDF9.SJNS_link
   112.    is (the_SJNS(the_SJNS_depth-1));
   113.
   114.    function operand_words_needed (need : KDF9.NEST_depth)
   115.    return String
   116.    is ("NEST lacks" & need'Image + "operand" & (if need > 1 then "s" else ""));
   117.
   118.    procedure ensure_that_the_NEST_holds (at_least : in KDF9.NEST_depth) is
   119.    begin
   120.       if the_NEST_depth >= at_least          or else
   121.             the_CPU_state = Director_state      then
   122.          return;
   123.       end if;
   124.       effect_interrupt(caused_by_NOUV, operand_words_needed(need => at_least-the_NEST_depth));
   125.    end ensure_that_the_NEST_holds;
   126.
   127.    procedure ensure_that_the_NEST_holds_an_operand is
   128.    begin
   129.       ensure_that_the_NEST_holds (at_least => 1);
   130.    end ensure_that_the_NEST_holds_an_operand;
   131.
   132.    procedure ensure_that_the_NEST_holds_2_operands is
   133.    begin
   134.       ensure_that_the_NEST_holds (at_least => 2);
   135.    end ensure_that_the_NEST_holds_2_operands;
   136.
   137.    function result_space_needed (need : KDF9.NEST_depth)
   138.    return String
   139.       with Inline => False;
   140.
   141.    function result_space_needed (need : KDF9.NEST_depth)
   142.    return String
   143.    is (if need = 1 then "full NEST" else "NEST too full for" & need'Image + "operands");
   144.
   145.    procedure ensure_that_the_NEST_has_room_for (at_least : in KDF9.NEST_depth) is
   146.    begin
   147.       if the_NEST_depth <= 16-at_least     or else
   148.             the_CPU_state = Director_state    then
   149.          return;
   150.       end if;
   151.       effect_interrupt(caused_by_NOUV, result_space_needed(need => at_least - (16-the_NEST_depth)));
   152.    end ensure_that_the_NEST_has_room_for;
   153.
   154.    procedure ensure_that_the_NEST_has_room_for_a_result is
   155.    begin
   156.       ensure_that_the_NEST_has_room_for (at_least => 1);
   157.    end ensure_that_the_NEST_has_room_for_a_result;
   158.
   159.    procedure ensure_that_the_NEST_has_room_for_2_results is
   160.    begin
   161.       ensure_that_the_NEST_has_room_for (at_least => 2);
   162.    end ensure_that_the_NEST_has_room_for_2_results;
   163.
   164.    procedure push (the_word : in KDF9.word) is
   165.    begin
   166.       the_NEST(the_NEST_depth) := the_word;
   167.       the_NEST_depth := the_NEST_depth + 1;
   168.    end push;
   169.
   170.    function pop
   171.    return KDF9.word is
   172.    begin
   173.       return result : constant KDF9.word := the_NEST(the_NEST_depth - 1) do
   174.          the_NEST(the_NEST_depth - 1) := 0;
   175.          the_NEST_depth := the_NEST_depth - 1;
   176.       end return;
   177.    end pop;
   178.
   179.    procedure pop is
   180.    begin
   181.       the_NEST(the_NEST_depth - 1) := 0;
   182.       the_NEST_depth := the_NEST_depth - 1;
   183.    end pop;
   184.
   185.    function read_top
   186.    return KDF9.word
   187.    is (the_NEST(the_NEST_depth-1));
   188.
   189.    procedure write_top (the_word : in KDF9.word) is
   190.    begin
   191.       the_NEST(the_NEST_depth-1) := the_word;
   192.    end write_top;
   193.
   194.    procedure push (the_pair : in KDF9.pair) is
   195.    begin
   196.       the_NEST(the_NEST_depth+0) := the_pair.lsw;
   197.       the_NEST(the_NEST_depth+1) := the_pair.msw;
   198.       the_NEST_depth := the_NEST_depth + 2;
   199.    end push;
   200.
   201.    function pop
   202.    return KDF9.pair is
   203.    begin
   204.       return result : constant KDF9.pair := (msw => the_NEST(the_NEST_depth-1),
   205.                                              lsw => the_NEST(the_NEST_depth-2)) do
   206.          the_NEST(the_NEST_depth-1) := 0;
   207.          the_NEST(the_NEST_depth-2) := 0;
   208.          the_NEST_depth := the_NEST_depth - 2;
   209.       end return;
   210.    end pop;
   211.
   212.    procedure pop_pair is
   213.    begin
   214.       the_NEST(the_NEST_depth-1) := 0;
   215.       the_NEST(the_NEST_depth-2) := 0;
   216.       the_NEST_depth := the_NEST_depth - 2;
   217.    end pop_pair;
   218.
   219.    function read_top
   220.    return KDF9.pair
   221.    is ((msw => the_NEST(the_NEST_depth-1), lsw => the_NEST(the_NEST_depth-2)));
   222.
   223.    procedure write_top (the_pair : in KDF9.pair) is
   224.    begin
   225.       the_NEST(the_NEST_depth-1) := the_pair.msw;
   226.       the_NEST(the_NEST_depth-2) := the_pair.lsw;
   227.    end write_top;
   228.
   229.
   230. --
   231.    -- Support for Director-only operations.
   232. --
   233.
   234.    -- Set BA (bits D38:47), CPL (D34:35) and NOL (D24:33).
   235.
   236.    procedure set_K1_register (setting : in KDF9.word) is
   237.    begin
   238.       BA  := KDF9.address(setting mod 2**10) * 2**5;
   239.       CPL := KDF9.priority((setting / 2**12) and 2#11#);
   240.       NOL := KDF9.address((setting / 2**14) mod 2**10) * 2**5 + 31;
   241.    end set_K1_register;
   242.
   243.    -- Set CPDAR (bits D32:47).
   244.
   245.    procedure set_K2_register (setting : in KDF9.word) is
   246.       CPDAR_Q : KDF9.Q_part := as_Q(setting).M;
   247.    begin
   248.       for i in KDF9.buffer_number loop
   249.          the_CPDAR(i) := (CPDAR_Q mod 2) = 1;
   250.          CPDAR_Q := CPDAR_Q / 2;
   251.       end loop;
   252.    end set_K2_register;
   253.
   254.    -- Set context (bits D0:1), NEST_depth (D2:6) and SJNS_depth (D7:11).
   255.
   256.    procedure set_K3_register (setting : in KDF9.word) is
   257.    begin
   258.       -- Save the current register values in the register bank.
   259.       register_bank(the_context).NEST := the_NEST;
   260.       register_bank(the_context).SJNS := the_SJNS;
   261.       register_bank(the_context).Q_store := the_Q_store;
   262.       -- Set the new context.
   263.       the_context := KDF9.context(KDF9.word'(setting / 2**46));
   264.       the_NEST_depth := KDF9.NEST_depth(setting / 2**41 mod 2**5);
   265.       the_SJNS_depth := KDF9.SJNS_depth(setting / 2**36 mod 2**5);
   266.       -- Restore the register values for the new context.
   267.       the_NEST := register_bank(the_context).NEST;
   268.       the_SJNS := register_bank(the_context).SJNS;
   269.       the_Q_store := register_bank(the_context).Q_store;
   270.    end set_K3_register;
   271.
   272.    function todays_date_28n_years_ago
   273.    return KDF9.word is
   274.
   275.       zero  : constant KDF9.word := 8#20#;  -- in KDF9 internal code
   276.       slash : constant KDF9.word := 8#17#;  -- in KDF9 internal code
   277.       today : constant Ada.Calendar.Time := Ada.Calendar.Clock;
   278.
   279.       year, month, day, hour, minute, second : KDF9.word;
   280.       sub_second : Second_Duration;
   281.
   282.       -- For values of i in 0..99, return two 6-bit decimal digits in KDF9 internal code.
   283.       function as_2_digits (i : KDF9.word)
   284.       return KDF9.word
   285.       is ((i/10 + zero)*64 or (i mod 10 + zero));
   286.
   287.    begin  -- todays_date_28n_years_ago
   288.       Split(today,
   289.             Year_Number(year),
   290.             Month_Number(month),
   291.             Day_Number(day),
   292.             Hour_Number(hour),
   293.             Minute_Number(minute),
   294.             Second_Number(second),
   295.             sub_second,
   296.             Time_Zone => UTC_Time_Offset(today)
   297.            );
   298.       loop  -- Repeat n > 0 times, assuming no time travel into the past!
   299.          year := year - 28;
   300.       exit when year < 2000;
   301.       end loop;
   302.       return (as_2_digits(day)*64   or slash) * 64**5  -- DD/.....
   303.           or (as_2_digits(month)*64 or slash) * 64**2  --    MM/..
   304.           or (as_2_digits((year) mod 100));            --       YY
   305.    end todays_date_28n_years_ago;
   306.
   307.    function the_time_of_day
   308.    return KDF9.us is
   309.       today : constant Ada.Calendar.Time := Ada.Calendar.Clock;
   310.       year, month, day, hour, minute, second : KDF9.word;
   311.       sub_second : Second_Duration;
   312.    begin
   313.       Split(today,
   314.             Year_Number(year),
   315.             Month_Number(month),
   316.             Day_Number(day),
   317.             Hour_Number(hour),
   318.             Minute_Number(minute),
   319.             Second_Number(second),
   320.             Second_Duration(sub_second),
   321.             Time_Zone => UTC_Time_Offset(today)
   322.            );
   323.       return KDF9.us(hour*3600 + minute*60 + second) * 1_000_000
   324.            + KDF9.us(sub_second * 1_000_000);
   325.    end the_time_of_day;
   326.
   327.    the_time_at_loading : constant KDF9.us := the_time_of_day;
   328.
   329.    in_microseconds     : constant := 1.0 / 2.0**20;
   330.
   331.    type seconds is delta in_microseconds range 0.0 .. 1000.0*365.2425*24.0*3600.0;  -- 1000 years!
   332.
   333.    procedure update_the_elapsed_time;
   334.
   335.    -- Let the real elapsed time catch up with the_real_time virtual seconds.
   336.    -- This works well if the resolution of Ada.Calendar.Clock is significantly less than 100ms.
   337.    procedure delay_until (the_real_time : in KDF9.us) is
   338.       the_virtual_time : constant KDF9.us := the_time_of_day - the_time_at_loading;
   339.       the_time_lag     : seconds;
   340.    begin
   341.       if the_virtual_time = 0 then
   342.          return;
   343.       end if;
   344.       if the_real_time > the_virtual_time then
   345.          -- Make the physical elapsed time catch up with the virtual elapsed time.
   346.          the_time_lag := seconds(the_real_time - the_virtual_time) * in_microseconds;
   347.          delay Duration(the_time_lag);
   348.       end if;
   349.       the_elapsed_time := the_real_time;
   350.       update_the_elapsed_time;
   351.    end delay_until;
   352.
   353.    -- Advance to the larger of the_CPU_time, the_elapsed_time, and the_last_delay_time.
   354.    -- Cap the increase to prevent a spurious double-clock (RESET) interrupt in Director.
   355.
   356.    procedure update_the_elapsed_time is
   357.       max_elapsed_time : constant KDF9.us := the_last_K4_time + 2**20 - 1;
   358.    begin
   359.       the_elapsed_time := KDF9.us'Max(the_elapsed_time, the_CPU_time);
   360.       if the_execution_mode = boot_mode and the_CPU_state = Director_state then
   361.          the_elapsed_time := KDF9.us'Min(the_elapsed_time, max_elapsed_time);
   362.       end if;
   363.    end update_the_elapsed_time;
   364.
   365.    -- The virtual elapsed time.
   366.
   367.    function the_clock_time
   368.    return KDF9.us is
   369.    begin
   370.       update_the_elapsed_time;
   371.       return the_elapsed_time;
   372.    end the_clock_time;
   373.
   374.    procedure advance_the_clock (past : in KDF9.us) is
   375.    begin
   376.       if authentic_timing_is_enabled then
   377.          delay_until(past);
   378.       else
   379.          the_elapsed_time := KDF9.us'Max(the_elapsed_time, past);
   380.          update_the_elapsed_time;
   381.       end if;
   382.    end advance_the_clock;
   383.
   384.    procedure synchronize_the_real_and_virtual_times is
   385.    begin
   386.       update_the_elapsed_time;
   387.       if authentic_timing_is_enabled then
   388.          delay_until(the_elapsed_time);
   389.       end if;
   390.    end synchronize_the_real_and_virtual_times;
   391.
   392.    -- Get clock (bits D0:15) and RFIR (D16:31).
   393.
   394.    function get_K4_operand
   395.    return KDF9.word is
   396.
   397.       function RFIR_in_a_word
   398.       return KDF9.word is
   399.          result : KDF9.word := 0;
   400.       begin
   401.          for r of the_RFIR loop
   402.             result := result*2;
   403.             if r then
   404.                result := result or 1;
   405.             end if;
   406.          end loop;
   407.          return result;
   408.       end RFIR_in_a_word;
   409.
   410.       -- The KDF9's interval timing clock ticks once per 32 s;
   411.       --    the emulator virtual time has a resolution of 1 s.
   412.
   413.       time_now : constant KDF9.us := the_clock_time;
   414.       interval : constant KDF9.us := (time_now - the_last_K4_time);
   415.
   416.    begin
   417.       the_last_K4_time := time_now;
   418.       if interval / 32 >= 2**16 then
   419.          effect_interrupt(caused_by_RESET, "double clock");
   420.          the_RFIR(caused_by_RESET ) := True;
   421.       elsif interval / 32 >= 2**15 then
   422.          effect_interrupt(caused_by_CLOCK, "time since a K4" & interval'Image & "us");
   423.          the_RFIR(caused_by_CLOCK ) := True;  --?? why is this needed?
   424.       end if;
   425.       return (KDF9.word(interval / 32) * 2**32) or (RFIR_in_a_word * 2**16);
   426.    end get_K4_operand;
   427.
   428.    -- Get PHUi (bits D6i:6i+5, i = 0 .. 3).
   429.
   430.    function get_K5_operand
   431.    return KDF9.word
   432.    is (K5_operand);
   433.
   434.    -- Get context (bits D0:1), NEST_depth (D2:6) and SJNS_depth (D7:11).
   435.
   436.    function get_K7_operand
   437.    return KDF9.word
   438.    is (
   439.        (KDF9.word(the_context)    * 2**46) or
   440.        (KDF9.word(the_NEST_depth) * 2**41) or
   441.        (KDF9.word(the_SJNS_depth) * 2**36)
   442.       );
   443.
   444.    procedure reset_V_and_T is
   445.    begin
   446.       the_V_bit_is_set := False;
   447.       the_T_bit_is_set := False;
   448.    end reset_V_and_T;
   449.
   450.    procedure reset_the_internal_registers (the_new_state : in CPU_state) is
   451.    begin
   452.       -- Set the state of a newly bootstrapped CPU.
   453.       reset_V_and_T;
   454.       CIA := (0, 0);
   455.       CPL := 0;
   456.       BA  := 0;
   457.       NOL := KDF9.address'Last;
   458.       the_RFIR := (others => False);
   459.       ICR := 0;
   460.       the_CPU_time := 0;
   461.       the_elapsed_time := 0;
   462.       the_last_K4_time := 0;
   463.       the_CPU_state := the_new_state;
   464.       the_CPDAR := (0 => True, others => False);  -- FW0 is always allocated.
   465.    end reset_the_internal_registers;
   466.
   467.    empty_NEST : constant NEST := (others => 0);
   468.    empty_SJNS : constant SJNS := (others => (0, 0));
   469.    empty_Q_s  : constant Q_store := (others => (0, 0, 0));
   470.
   471.    procedure reset_the_CPU_state (initial_entry : KDF9.syllable_address) is
   472.    begin
   473.       the_context := 0;
   474.       for bank of register_bank loop
   475.          bank := (NEST => empty_NEST, SJNS => empty_SJNS, Q_store => empty_Q_s);
   476.       end loop;
   477.       the_NEST_depth := 0;
   478.       the_NEST       := empty_NEST;
   479.       the_SJNS_depth := 0;
   480.       the_SJNS       := empty_SJNS;
   481.       the_Q_store    := empty_Q_s;
   482.       if the_execution_mode = program_mode then
   483.          reset_the_internal_registers(program_state);
   484.       else
   485.          reset_the_internal_registers(Director_state);
   486.       end if;
   487.       -- Setting NIA must follow program loading, as it fetches E0 into the IWBs.
   488.       set_NIA_to(initial_entry);
   489.    end reset_the_CPU_state;
   490.
   491.    procedure reset_the_program_state is
   492.    begin
   493.       the_NEST_depth := 0;
   494.       the_NEST       := empty_NEST;
   495.       the_SJNS_depth := 0;
   496.       the_SJNS       := empty_SJNS;
   497.       reset_V_and_T;
   498.       the_CPDAR := (0 => True, others => False);  -- FW0 is always allocated.
   499.       -- Setting NIA must follow program loading, as it fetches E0 into the IWBs.
   500.       set_NIA_to((0, 0));
   501.    end reset_the_program_state;
   502.
   503.    procedure effect_interrupt (caused_by_this : in KDF9.interrupt_number; message : in String) is
   504.       return_address : KDF9.syllable_address;
   505.    begin
   506.       take_note_of_interrupt(caused_by_this, message);
   507.       the_RFIR(caused_by_this) := True;
   508.       case the_execution_mode is
   509.          when boot_mode =>
   510.             -- Interrupts are either actioned or deferred to Director.
   511.             if the_CPU_state = program_state or else caused_by_this = caused_by_RESET  then
   512.                -- Action an actual interrupt into Director.
   513.                if caused_by_this in caused_by_LOV  | caused_by_OUT then
   514.                   return_address := CIA;  -- Restart the interrupted instruction.
   515.                else
   516.                   return_address := NIA;  -- Proceed after the interrupted instruction.
   517.                end if;
   518.                if the_SJNS_depth < 16 then
   519.                   push(return_address);                  -- The program link fits into the SJNS.
   520.                else
   521.                   JB := KDF9.SJNS_link(return_address);  -- The program link overwrites JB.
   522.                end if;
   523.                BA := 0;
   524.                fetching_normally := True;
   525.                set_NIA_to((0, 0));
   526.                the_CPU_state := Director_state;
   527.                raise abandon_this_order;
   528.             else
   529.                -- Defer: Director will eventually find any request left in the_RFIR.
   530.                -- NOUV is completely suppressed in Director state.
   531.                the_RFIR(caused_by_NOUV) := False;
   532.             end if;
   533.
   534.          when privileged_mode =>
   535.             -- Interrupts other than LOV and RESET are ignored.
   536.             -- There is no need to accurately emulate the address placed by the hardware in JB.
   537.             case caused_by_this is
   538.                when caused_by_LOV  =>
   539.                   raise LOV_exception with message;
   540.                when caused_by_RESET  =>
   541.                   raise RESET_exception with message;
   542.                when others =>
   543.                   null;
   544.             end case;
   545.
   546.          when program_mode =>
   547.             -- Interrupts other than LOV are treated as failures.
   548.             -- There is no need to accurately emulate the address placed by the hardware in JB.
   549.             case caused_by_this is
   550.                when caused_by_PR =>
   551.                   raise PR_exception with message;
   552.                when caused_by_FLEX =>
   553.                   raise FLEX_exception with message;
   554.                when caused_by_LIV =>
   555.                   raise LIV_exception with message;
   556.                when caused_by_NOUV =>
   557.                   raise NOUV_exception with message;
   558.                when caused_by_EDT =>
   559.                   raise EDT_exception with message;
   560.                when caused_by_OUT =>
   561.                   raise OUT_exception with message;
   562.                when caused_by_LOV  =>
   563.                   raise LOV_exception with message;
   564.                when caused_by_RESET  =>
   565.                   raise RESET_exception with message;
   566.                when EXITD_flag =>
   567.                   raise emulation_failure with "invalid EXITD RFI in effect_interrupt";
   568.                when caused_by_CLOCK =>
   569.                   raise emulation_failure with "invalid CLOCK RFI in effect_interrupt";
   570.             end case;
   571.       end case;
   572.    end effect_interrupt;
   573.
   574.    procedure effect_clock_interrupt (interval : in KDF9.us)
   575.       with Inline => False;
   576.
   577.    procedure effect_clock_interrupt (interval : in KDF9.us) is
   578.    begin
   579.       effect_interrupt(caused_by_CLOCK, interval'Image + "KDF9 us");
   580.    end effect_clock_interrupt;
   581.
   582.    procedure check_for_a_clock_interrupt is
   583.       interval : KDF9.us;
   584.    begin
   585.       -- Clock ticks are ignored in program_mode and privileged_mode.
   586.       -- In boot_mode:
   587.       --    they are actioned in program_state;
   588.       --    they are deferred in Director_state: Director will eventually find the time for itself.
   589.       if the_execution_mode = boot_mode and then
   590.             the_CPU_state = program_state   then
   591.          interval := (the_clock_time - the_last_K4_time);
   592.          if interval >= 2**20 then
   593.             effect_clock_interrupt(interval);
   594.          end if;
   595.       end if;
   596.    end check_for_a_clock_interrupt;
   597.
   598.    procedure fail_in_problem_program_state is
   599.    begin
   600.       case the_execution_mode is
   601.          when program_mode =>
   602.             -- The unprivileged program has attempted a privileged operation.
   603.             raise LIV_exception with "%Director-only instruction";
   604.          when privileged_mode =>
   605.             -- The privileged program is allowed to use privileged instructions.
   606.             return;
   607.          when boot_mode =>
   608.             if the_CPU_state = program_state then
   609.                -- Punt the error to Director.
   610.                effect_interrupt(caused_by_LIV, "Director-only instruction");
   611.             else
   612.                -- All privileged operations are permitted to Director.
   613.                return;
   614.             end if;
   615.       end case;
   616.    end fail_in_problem_program_state;
   617.
   618.    procedure LOV_if_user_mode (cause : in String) is
   619.    begin
   620.       -- LOV was TOTALLY suppressed in Director state.
   621.       if the_CPU_state /= Director_state then
   622.          set_NIA_to(CIA);
   623.          effect_interrupt(caused_by_LOV, cause);
   624.       end if;
   625.    end LOV_if_user_mode;
   626.
   627.    -- The %  prepended to the_message aids parsing of exception error messages in failure shutdown.
   628.
   629.    procedure trap_illegal_instruction (the_message : in String := "invalid opcode") is
   630.    begin
   631.       -- The program has failed in a manner that could cause a LIV interrupt.
   632.       case the_execution_mode is
   633.          when program_mode
   634.             | privileged_mode =>
   635.             raise LIV_exception with "%" & the_message;
   636.          when boot_mode =>
   637.             if the_CPU_state = program_state then
   638.                -- Punt the problem to Director.
   639.                effect_interrupt(caused_by_LIV, the_message);
   640.             else
   641.                -- The Director itself has gone seriously wrong.
   642.                -- LIV is impossible in Director, so ee9 takes responsibility for stopping the run
   643.                --    to avert consequential emulation failure.
   644.                raise Director_failure with "%" & the_message;
   645.             end if;
   646.       end case;
   647.    end trap_illegal_instruction;
   648.
   649.    procedure trap_operator_error (the_message : in String) is
   650.    begin
   651.       -- The program has failed for a reason, such as a misconfigured environment,
   652.       --    that is beyond its control and prevents further execution.
   653.       raise operator_error with "%" & the_message;
   654.    end trap_operator_error;
   655.
   656.    procedure trap_unimplemented_feature (the_message : in String) is
   657.    begin
   658.       -- The program has attempted to use something that ee9 does not (yet) support.
   659.       raise not_yet_implemented with "%" & the_message;
   660.    end trap_unimplemented_feature;
   661.
   662.    procedure trap_failing_OUT (OUT_number : in KDF9.word; the_message : in String) is
   663.       OUT_name : constant String := OUT_number'Image;
   664.    begin
   665.       -- The program has issued an invalid OUT.
   666.       raise OUT_error with "%" & OUT_name(2..OUT_name'Last) & ":" + the_message;
   667.    end trap_failing_OUT;
   668.
   669.    procedure trap_invalid_paper_tape (the_message : in String) is
   670.    begin
   671.       -- The paper tape file given to load or boot has defects.
   672.       raise invalid_paper_tape_file with "%" & the_message;
   673.    end trap_invalid_paper_tape;
   674.
   675.    procedure return_from_Director_to (new_IAR : in KDF9.syllable_address) is
   676.    begin
   677.       the_CPU_state := program_state;
   678.       set_NIA_to(new_IAR);
   679.    end return_from_Director_to;
   680.
   681.    procedure increment_by_1 (the_link : in out KDF9.syllable_address) is
   682.    begin
   683.       if the_link.syllable_index < 5 then
   684.          the_link.syllable_index := the_link.syllable_index + 1;
   685.       else
   686.          the_link.syllable_index := 0;
   687.          the_link.code_address     := the_link.code_address + 1;
   688.       end if;
   689.    end increment_by_1;
   690.
   691.    procedure increment_by_2 (the_link : in out KDF9.syllable_address) is
   692.    begin
   693.       if the_link.syllable_index < 4 then
   694.          the_link.syllable_index := the_link.syllable_index + 2;
   695.       else
   696.          the_link.syllable_index := the_link.syllable_index - 4;
   697.          the_link.code_address     := the_link.code_address + 1;
   698.       end if;
   699.    end increment_by_2;
   700.
   701.    procedure increment_by_3 (the_link : in out KDF9.syllable_address) is
   702.    begin
   703.       if the_link.syllable_index < 3 then
   704.          the_link.syllable_index := the_link.syllable_index + 3;
   705.       else
   706.          the_link.syllable_index := the_link.syllable_index - 3;
   707.          the_link.code_address     := the_link.code_address + 1;
   708.       end if;
   709.    end increment_by_3;
   710.
   711.    -- the_syllable_cache holds two instruction words, pre-split into syllables.
   712.    -- They would have been held in IWB0 and IWB1 by Main Control in the KDF9.
   713.
   714.    subtype syllable_cache_range is Natural range 0 .. 11;
   715.
   716.    the_syllable_cache  : array (syllable_cache_range) of KDF9.syllable;
   717.    the_cache_index     : syllable_cache_range   := 0;
   718.    the_cached_location : KDF9.code_address := 0;
   719.
   720.    function NIA
   721.    return KDF9.syllable_address
   722.    is (
   723.        if the_cache_index > 5 then
   724.           (the_cached_location, KDF9.syllable_index(the_cache_index-6))
   725.        else
   726.           (the_cached_location-1, KDF9.syllable_index(the_cache_index))
   727.       );
   728.
   729.    function NIA_word_number
   730.    return KDF9.code_address
   731.    is (the_cached_location - (if the_cache_index > 5 then 0 else 1));
   732.
   733.    procedure trap_an_invalid_order_address (new_NIA : in KDF9.syllable_address)
   734.       with Inline => False;
   735.
   736.    procedure trap_an_invalid_order_address (new_NIA : in KDF9.syllable_address) is
   737.    begin
   738.       if new_NIA.syllable_index = 6 then
   739.          effect_interrupt(caused_by_RESET, "syllable number = 6");
   740.       elsif new_NIA.syllable_index = 7 then
   741.          effect_interrupt(caused_by_RESET, "syllable number = 7");
   742.       else
   743.          effect_interrupt(caused_by_LIV, "jump to 8191");  -- See EE Report K/GD y 82.
   744.       end if;
   745.    end trap_an_invalid_order_address;
   746.
   747.    procedure set_NIA_to (new_NIA : in KDF9.syllable_address) is
   748.       mask        : constant := 8#377#;
   749.       shift       : constant := 2**8;
   750.       IWB0, IWB1  : KDF9.word;
   751.    begin
   752.       if new_NIA.code_address = 8191 or else
   753.             new_NIA.syllable_index > 5  then
   754.          trap_an_invalid_order_address(new_NIA);
   755.       end if;
   756.
   757.       IWB0 := fetch_word(KDF9.address(new_NIA.code_address) + 0);
   758.       IWB1 := fetch_word(KDF9.address(new_NIA.code_address) + 1);
   759.
   760.       the_cache_index := syllable_cache_range(new_NIA.syllable_index);
   761.       the_cached_location := new_NIA.code_address + 1;
   762.
   763.       the_syllable_cache(5+0) := KDF9.syllable(IWB0 and mask);
   764.       IWB0 := IWB0 / shift;
   765.       the_syllable_cache(4+0) := KDF9.syllable(IWB0 and mask);
   766.       IWB0 := IWB0 / shift;
   767.       the_syllable_cache(3+0) := KDF9.syllable(IWB0 and mask);
   768.       IWB0 := IWB0 / shift;
   769.       the_syllable_cache(2+0) := KDF9.syllable(IWB0 and mask);
   770.       IWB0 := IWB0 / shift;
   771.       the_syllable_cache(1+0) := KDF9.syllable(IWB0 and mask);
   772.       IWB0 := IWB0 / shift;
   773.       the_syllable_cache(0+0) := KDF9.syllable(IWB0);
   774.
   775.       the_syllable_cache(5+6) := KDF9.syllable(IWB1 and mask);
   776.       IWB1 := IWB1 / shift;
   777.       the_syllable_cache(4+6) := KDF9.syllable(IWB1 and mask);
   778.       IWB1 := IWB1 / shift;
   779.       the_syllable_cache(3+6) := KDF9.syllable(IWB1 and mask);
   780.       IWB1 := IWB1 / shift;
   781.       the_syllable_cache(2+6) := KDF9.syllable(IWB1 and mask);
   782.       IWB1 := IWB1 / shift;
   783.       the_syllable_cache(1+6) := KDF9.syllable(IWB1 and mask);
   784.       IWB1 := IWB1 / shift;
   785.       the_syllable_cache(0+6) := KDF9.syllable(IWB1);
   786.    end set_NIA_to;
   787.
   788.    procedure set_NIA_to_the_INS_target_address is
   789.    begin
   790.       set_NIA_to(INS.target);
   791.    end set_NIA_to_the_INS_target_address;
   792.
   793.    procedure set_IWB0_and_IWB1_for_a_JCqNZS_loop is
   794.    begin
   795.       set_NIA_to((code_address => CIA.code_address-1, syllable_index => 0));
   796.       fetching_normally := False;
   797.    end set_IWB0_and_IWB1_for_a_JCqNZS_loop;
   798.
   799.    procedure go_back_to_the_start_of_IWB0 is
   800.    begin
   801.       the_cache_index := 0;
   802.    end go_back_to_the_start_of_IWB0;
   803.
   804.    procedure continue_after_JCqNZS is
   805.    begin
   806.       if CIA.syllable_index = 4 and the_cached_location = CIA.code_address then
   807.          set_NIA_to((code_address => CIA.code_address+1, syllable_index => 0));
   808.       end if;
   809.       fetching_normally := True;
   810.    end continue_after_JCqNZS;
   811.
   812.    function next_order_syllable
   813.    return KDF9.syllable
   814.       with Inline;
   815.
   816.    -- The amount by which the_CPU_time is increased, for a refill of both Instruction Word Buffers.
   817.
   818.    the_IWB01_reload_time : constant KDF9.us := 7;  -- microseconds
   819.
   820.    function next_order_syllable
   821.    return KDF9.syllable is
   822.       the_next_syllable : KDF9.syllable;
   823.    begin
   824.       the_next_syllable := the_syllable_cache(the_cache_index);
   825.       if the_cache_index < 11 then
   826.          the_cache_index := the_cache_index + 1;
   827.       elsif fetching_normally then
   828.          set_NIA_to((code_address => CIA.code_address+1, syllable_index => 0));
   829.          -- Part-overlapped order-word fetch: can happen only once per instruction,
   830.          --    and only before the instruction is executed, so no need to ADD to the_CPU_delta.
   831.          if (CIA.code_address and 15) < 10 then
   832.             -- The fudge factor applied here gives the Whetstone Benchmark its historical run time.
   833.             the_CPU_delta := the_IWB01_reload_time + 1;
   834.          else
   835.             the_CPU_delta := the_IWB01_reload_time;
   836.          end if;
   837.       else
   838.          go_back_to_the_start_of_IWB0;
   839.       end if;
   840.       return the_next_syllable;
   841.    end next_order_syllable;
   842.
   843.    procedure decode_syllable_0 (decoded : in out KDF9.decoded_order)
   844.       with Inline;
   845.
   846.    procedure decode_syllable_1 (decoded : in out KDF9.decoded_order)
   847.       with Inline;
   848.
   849.    procedure decode_a_jump_order (decoded : in out KDF9.decoded_order)
   850.       with Inline;
   851.
   852.    procedure decode_a_store_access_order (decoded : in out KDF9.decoded_order)
   853.       with Inline;
   854.
   855.    procedure decode_a_set_literal_order (decoded : in out KDF9.decoded_order)
   856.       with Inline;
   857.
   858.    procedure decode_syllable_0 (decoded : in out KDF9.decoded_order) is
   859.    begin
   860.       decoded.compressed_opcode := decoded.order.syllable_0 and 8#77#;
   861.       decoded.kind := KDF9.INS_kind(decoded.order.syllable_0 / 2**6);
   862.    end decode_syllable_0;
   863.
   864.    procedure process_syllable_0_of_INS is
   865.    begin
   866.       if the_cache_index > 5 then
   867.          CIA.code_address := the_cached_location;
   868.          CIA.syllable_index   := KDF9.syllable_index(the_cache_index-6);
   869.       else
   870.          CIA.code_address := the_cached_location - 1;
   871.          CIA.syllable_index   := KDF9.syllable_index(the_cache_index);
   872.       end if;
   873.       INS.order.syllable_0 := next_order_syllable;
   874.       INS.compressed_opcode := INS.order.syllable_0 and 8#77#;
   875.       INS.kind := KDF9.INS_kind(INS.order.syllable_0 / 2**6);
   876.    end process_syllable_0_of_INS;
   877.
   878.    procedure decode_syllable_1 (decoded : in out KDF9.decoded_order) is
   879.    begin
   880.       decoded.Qq := KDF9.Q_number(decoded.order.syllable_1 / 2**4);
   881.       decoded.Qk := KDF9.Q_number(decoded.order.syllable_1 and 8#17#);
   882.    end decode_syllable_1;
   883.
   884.    procedure process_syllable_1_of_INS is
   885.    begin
   886.       INS.order.syllable_1 := next_order_syllable;
   887.       INS.Qq := KDF9.Q_number(INS.order.syllable_1 / 2**4);
   888.       INS.Qk := KDF9.Q_number(INS.order.syllable_1 and 8#17#);
   889.    end process_syllable_1_of_INS;
   890.
   891.    syllable_nr_mask : constant := 2#111#;
   892.    D4_mask          : constant := 2#1000#;
   893.    D2_mask          : constant := 2#00_100_000#;
   894.    D0_thru_3_mask   : constant := 2#11_110_000#;
   895.
   896.    procedure decode_a_jump_order (decoded : in out KDF9.decoded_order) is
   897.    begin
   898.       decoded.target.syllable_index
   899.          := KDF9.syllable_index(decoded.order.syllable_0 and syllable_nr_mask);
   900.       decoded.target.code_address
   901.          := KDF9.code_address(decoded.order.syllable_2)
   902.           + KDF9.code_address(decoded.Qk) * 2**8
   903.           + KDF9.code_address(decoded.order.syllable_0 and D4_mask) * 2**9;
   904.       if (decoded.compressed_opcode and D2_mask) /= 0 then -- not JrCq ...
   905.          decoded.compressed_opcode := decoded.compressed_opcode and D0_thru_3_mask;
   906.       else
   907.          decoded.compressed_opcode := (decoded.compressed_opcode and D0_thru_3_mask) or KDF9.syllable(decoded.Qq);
   908.       end if;
   909.       if decoded.compressed_opcode = EXIT_n then
   910.          -- The syllable part of EXIT is actually a halfword offset,
   911.          --    so convert it to an actual syllable number.
   912.          if decoded.target.syllable_index = 2 then
   913.             decoded.target.syllable_index := 0;
   914.          else
   915.             decoded.target.syllable_index := 3;
   916.          end if;
   917.       end if;
   918.    end decode_a_jump_order;
   919.
   920.    procedure process_syllables_1_and_2_of_a_jump_order is
   921.    begin
   922.       process_syllable_1_of_INS;
   923.       INS.order.syllable_2 := next_order_syllable;
   924.       decode_a_jump_order(INS);
   925.    end process_syllables_1_and_2_of_a_jump_order;
   926.
   927.    D5_thru_7_mask : constant := 2#111#;
   928.    D5_and_7_mask  : constant := 2#101#;
   929.    D2_thru_4_mask : constant := 2#111000#;
   930.
   931.    procedure decode_a_store_access_order (decoded : in out KDF9.decoded_order) is
   932.    begin
   933.       decoded.operand := KDF9.Q_part(decoded.order.syllable_2) + KDF9.Q_part(decoded.Qk)*2**8
   934.                        + KDF9.Q_part((decoded.order.syllable_0 and D2_thru_4_mask)) * 2**9;
   935.       decoded.compressed_opcode := decoded.compressed_opcode and D5_thru_7_mask;
   936.    end decode_a_store_access_order;
   937.
   938.    procedure decode_a_set_literal_order (decoded : in out KDF9.decoded_order) is
   939.    begin
   940.       decoded.operand := KDF9.Q_part(decoded.order.syllable_2)
   941.                        + KDF9.Q_part(decoded.order.syllable_1)*2**8;
   942.       decoded.compressed_opcode := 2#100#;
   943.    end decode_a_set_literal_order;
   944.
   945.    procedure process_syllables_1_and_2_of_a_data_access_order is
   946.    begin
   947.       if (INS.compressed_opcode and D5_thru_7_mask) < SET then
   948.          process_syllable_1_of_INS;
   949.          INS.order.syllable_2 := next_order_syllable;
   950.          decode_a_store_access_order(INS);
   951.       elsif (INS.compressed_opcode and D5_and_7_mask) = SET then
   952.          -- SET n
   953.          INS.order.syllable_1 := next_order_syllable;
   954.          INS.order.syllable_2 := next_order_syllable;
   955.          decode_a_set_literal_order(INS);
   956.       else
   957.          INS.order.syllable_1 := next_order_syllable;
   958.          INS.order.syllable_2 := next_order_syllable;
   959.          decode_a_set_literal_order(INS);
   960.          INS.compressed_opcode := 7;  -- an invalid compression.
   961.       end if;
   962.    end process_syllables_1_and_2_of_a_data_access_order;
   963.
   964.    procedure decode_the_next_order is
   965.    begin
   966.       -- The CPU time is adjusted by a fudge factor to account for
   967.       --    the instruction-fetch time being partly overlapped.
   968.       process_syllable_0_of_INS;
   969.       case INS.kind is
   970.          when one_syllable_order =>
   971.             return;
   972.          when two_syllable_order =>
   973.             process_syllable_1_of_INS;
   974.          when normal_jump_order =>
   975.             process_syllables_1_and_2_of_a_jump_order;
   976.          when data_access_order =>
   977.             process_syllables_1_and_2_of_a_data_access_order;
   978.       end case;
   979.    end decode_the_next_order;
   980.
   981.    procedure decode (the_order : in out KDF9.decoded_order) is
   982.    begin
   983.       decode_syllable_0(the_order);
   984.       case the_order.kind is
   985.          when one_syllable_order =>
   986.             null;
   987.          when two_syllable_order =>
   988.             decode_syllable_1(the_order);
   989.          when normal_jump_order =>
   990.             decode_syllable_1(the_order);
   991.             decode_a_jump_order(the_order);
   992.          when data_access_order =>
   993.             if (the_order.compressed_opcode and D5_thru_7_mask) < SET then
   994.                decode_syllable_1(the_order);
   995.                decode_a_store_access_order(the_order);
   996.             elsif (INS.compressed_opcode and D5_and_7_mask) = SET then
   997.                -- SET n
   998.                decode_a_set_literal_order(the_order);
   999.             else
  1000.                decode_a_set_literal_order(the_order);
  1001.                INS.compressed_opcode := 7;  -- an invalid compression.
  1002.             end if;
  1003.       end case;
  1004.    end decode;
  1005.
  1006.    -- the_order_at_NIA gets three syllables starting at [NIA].  It is FOR DIAGNOSTIC USE ONLY!
  1007.    -- It does NOT update the CPU time properly and MUST NOT be used inside an instruction cycle.
  1008.
  1009.    function the_order_at_NIA
  1010.    return KDF9.syllable_group is
  1011.       saved_NIA : constant KDF9.syllable_address := NIA;
  1012.       result    : KDF9.syllable_group;
  1013.    begin
  1014.       result.syllable_0 := next_order_syllable;
  1015.       result.syllable_1 := next_order_syllable;
  1016.       result.syllable_2 := next_order_syllable;
  1017.       set_NIA_to(saved_NIA);
  1018.       return result;
  1019.    end the_order_at_NIA;
  1020.
  1021.    -- This is the initial jump from the top halfword of E0 just after loading.
  1022.
  1023.    E0U : KDF9.word := 0;  -- N.B. the lower halfword is used for option flags.
  1024.
  1025.    procedure save_the_initial_jump is
  1026.    begin
  1027.       E0U := fetch_halfword(0, 0);
  1028.    end save_the_initial_jump;
  1029.
  1030.    procedure restore_the_initial_jump is
  1031.    begin
  1032.        store_halfword(E0U, 0, 0);
  1033.    end restore_the_initial_jump;
  1034.
  1035.    function the_initial_jump_was_corrupted
  1036.    return Boolean
  1037.    is (E0U /= fetch_halfword(0, 0));
  1038.
  1039.    function is_an_invalid_order (decoded : KDF9.decoded_order)
  1040.    return Boolean is
  1041.       syllable_0 : constant KDF9.syllable := decoded.order.syllable_0;
  1042.    begin
  1043.       return
  1044.          (decoded.kind = data_access_order and then (syllable_0 and 2#101#) > 2#100#)     or else
  1045.             (decoded.kind = normal_jump_order and then decoded.target.syllable_index > 5) or else
  1046.                syllable_0 in 8#006# | 8#040# | 8#046# | 8#055# | 8#073# | 8#076# | 8#150#;
  1047.    end is_an_invalid_order;
  1048.
  1049.    function is_an_unconditional_jump (decoded : KDF9.decoded_order)
  1050.    return Boolean
  1051.    is (
  1052.        decoded.kind = normal_jump_order                   and then
  1053.           decoded.order.syllable_0 in Jr | EXIT_n | EXITD and then
  1054.              decoded.target.syllable_index < 6
  1055.       );
  1056.
  1057.    the_signature_hash : KDF9.word := 0;
  1058.
  1059.    function the_digital_signature
  1060.    return KDF9.word
  1061.    is (the_signature_hash);
  1062.
  1063.    function visible_state_hash
  1064.    return KDF9.word
  1065.       with Inline;
  1066.
  1067.    function visible_state_hash
  1068.    return KDF9.word is
  1069.       hash : KDF9.word;
  1070.    begin
  1071.       hash := rotate_word_right(the_signature_hash, 1) xor KDF9.word(ICR);
  1072.       hash := rotate_word_right(hash, 1) xor as_word(the_Q_store(INS.Qq));
  1073.       hash := rotate_word_right(hash, 1) xor as_word(the_Q_store(INS.Qk));
  1074.       if the_SJNS_depth > 0 then
  1075.          for s in reverse KDF9.SJNS_depth range 0 .. the_SJNS_depth-1 loop
  1076.                hash := rotate_word_right(hash, 1) xor as_word(the_SJNS(s));
  1077.          end loop;
  1078.       end if;
  1079.       if the_NEST_depth > 0 then
  1080.          for n in reverse KDF9.NEST_depth range 0 .. the_NEST_depth-1 loop
  1081.                hash := rotate_word_right(hash, 1) xor the_NEST(n);
  1082.          end loop;
  1083.       end if;
  1084.       return hash;
  1085.    end visible_state_hash;
  1086.
  1087.    procedure update_the_digital_signature is
  1088.    begin
  1089.       the_signature_hash := visible_state_hash;
  1090.    end update_the_digital_signature;
  1091.
  1092. end KDF9;

Compiling: ../Source/kdf9.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:00

     1. -- The architecturally-defined data and register formats of the KDF9 computer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with System;
    18. --
    19. private with KDF9_char_sets;
    20. private with string_editing;
    21.
    22. package KDF9 is
    23.
    24.    --
    25.    --
    26.    -- The fundamental storage unit is the 48-bit word.
    27.    --
    28.    --
    29.
    30.    --
    31.    -- The 48-bit word, considered as an unsigned integer.
    32.    --
    33.
    34.    type word is mod 2**48;
    35.
    36.    word_mask     : constant := 8#7777777777777777#;
    37.    min_word      : constant := 8#4000000000000000#;
    38.    max_word      : constant := 8#3777777777777777#;
    39.    all_zero_bits : constant := 0;
    40.    sign_bit      : constant := KDF9.min_word;
    41.    not_sign_bit  : constant := KDF9.max_word;
    42.    all_one_bits  : constant := KDF9.word_mask;
    43.
    44.
    45.    --
    46.    -- The 96-bit double word, considered as a pair of words.
    47.    --
    48.
    49.    type pair is
    50.       record
    51.          msw, lsw : KDF9.word;
    52.       end record;
    53.
    54.
    55.    --
    56.    -- The basic 16-bit operand.
    57.    --
    58.
    59.    type field_of_16_bits is mod 2**16;
    60.
    61.    --
    62.    -- The 16-bit word, considered as a field of a Q register.
    63.    --
    64.
    65.    type Q_part is new KDF9.field_of_16_bits;
    66.
    67.    Q_part_mask : constant := KDF9.Q_part'Last;
    68.
    69.    function sign_extended (Q : KDF9.Q_part)
    70.    return KDF9.word
    71.       with Inline;
    72.
    73.    --
    74.    -- The 16-bit word, considered as a buffer (DMA channel) number.
    75.    --
    76.
    77.    subtype buffer_number is KDF9.Q_part range 0 .. 15;
    78.
    79.    buffer_number_mask : constant := buffer_number'Last;
    80.
    81.    --
    82.    -- The 16-bit word, considered as a core-store address.
    83.    --
    84.
    85.    subtype address is KDF9.Q_part range 0 .. 8#77777#;
    86.
    87.    address_mask : constant := KDF9.address'Last;
    88.
    89.    --
    90.    -- The Q-store element.
    91.    --
    92.
    93.    type Q_register is
    94.       record
    95.          C, I, M : KDF9.Q_part;
    96.       end record;
    97.
    98.    function as_Q (the_word : KDF9.word)
    99.    return KDF9.Q_register
   100.       with Inline;
   101.
   102.    function as_word (the_Q : KDF9.Q_register)
   103.    return KDF9.word
   104.       with Inline;
   105.
   106.
   107.    --
   108.    -- The 8-bit instruction syllable and its components.
   109.    --
   110.
   111.    type syllable is mod 2**8;
   112.
   113.    subtype compressed_opcode is KDF9.syllable range 0 .. 63;
   114.    subtype Q_number          is KDF9.syllable range 0 .. 15;
   115.
   116.    type syllable_group is
   117.       record
   118.          syllable_0, syllable_1, syllable_2 : KDF9.syllable := 0;
   119.       end record;
   120.
   121.
   122.    --
   123.    -- An instruction address.
   124.    --
   125.    -- N.B. 5 is the hardware's largest valid syllable address.
   126.    -- The values 6 and 7 are used as diagnostic flags by ee9.
   127.    -- They cause a RESET trap if encountered during execution.
   128.    --
   129.
   130.    type code_address   is mod 2**13;
   131.    type syllable_index is mod 2**3;
   132.
   133.    type syllable_address is
   134.       record
   135.          code_address   : KDF9.code_address;
   136.          syllable_index : KDF9.syllable_index;
   137.       end record;
   138.
   139.    --
   140.    -- An instruction address, in the packed format of a hardware (SJNS) link.
   141.    --
   142.
   143.    type SJNS_link is new KDF9.syllable_address
   144.       with Size => 16;
   145.    for SJNS_link'Bit_Order use System.Low_Order_First;
   146.    for SJNS_link use
   147.       record
   148.          code_address   at 0 range  0 .. 12;
   149.          syllable_index at 0 range 13 .. 15;
   150.       end record;
   151.
   152.    function as_word (the_link : KDF9.SJNS_link)
   153.    return KDF9.word;
   154.
   155.    function as_link (the_word : KDF9.word)
   156.    return KDF9.SJNS_link;
   157.
   158.    procedure increment_by_1 (the_link : in out KDF9.syllable_address)
   159.       with Inline;
   160.
   161.    procedure increment_by_2 (the_link : in out KDF9.syllable_address)
   162.       with Inline;
   163.
   164.    procedure increment_by_3 (the_link : in out KDF9.syllable_address)
   165.       with Inline;
   166.
   167.
   168.    --
   169.    -- The KDF9 halfword. Each occupies 24 bits, packed 2 per word.
   170.    --
   171.
   172.    type halfword is mod 2**24;
   173.    halfword_mask : constant := 8#77_77_77_77#;
   174.
   175.    subtype halfword_number is KDF9.address range 0 .. 1;
   176.
   177.
   178.    --
   179.    -- The KDF9 character occupies six bits, and they are packed 8 per word.
   180.    -- The various character sets, and the symbol type, are defined in the package KDF9_char_sets.
   181.    --
   182.
   183.
   184.    --
   185.    --
   186.    --
   187.    -- The following types define the structure of the KDF9's programmable registers.
   188.    --
   189.    --
   190.    --
   191.
   192.
   193.    --
   194.    -- authenticity_mode is declared here instead of in settings, to avoid a cyclic dependency.
   195.    --
   196.
   197.    type authenticity_mode is (modern_times_mode, authentic_time_mode);
   198.
   199.    the_authenticity_default : constant KDF9.authenticity_mode := modern_times_mode;
   200.    the_authenticity_mode    :          KDF9.authenticity_mode := the_authenticity_default;
   201.
   202.
   203.    --
   204.    --
   205.    --
   206.    -- The following variables (the_NEST, the_SJNS and the_Q_store) constitute
   207.    --    the emulation microcode's fixed working set of registers.
   208.    -- ee9 (unlike the real KDF9) swaps them with register_bank(the_context)
   209.    --    when a context switch is made by the =K3 instruction.
   210.    -- The real KDF9 used register_bank(the_context) directly for operands.
   211.    -- ee9's approach improves host cache locality and avoids indexing overheads,
   212.    --    the trade off being microscopically increased context-switching time.
   213.    --
   214.    --
   215.    --
   216.
   217.    --
   218.    -- The NEST.
   219.    --
   220.
   221.    type NEST_depth is mod 19;
   222.
   223.    type NEST is array (KDF9.NEST_depth) of KDF9.word;
   224.
   225.    the_NEST       : KDF9.NEST;
   226.    the_NEST_depth : KDF9.NEST_depth  := 0;
   227.
   228.    -- The ensure_that_the_NEST_holds* procedures trap NOUV.
   229.    -- They are used to validate operations that reduce the NEST depth.
   230.
   231.    procedure ensure_that_the_NEST_holds (at_least : in KDF9.NEST_depth)
   232.       with Inline;
   233.
   234.    procedure ensure_that_the_NEST_holds_an_operand
   235.       with Inline;
   236.
   237.    procedure ensure_that_the_NEST_holds_2_operands
   238.       with Inline;
   239.
   240.    function operand_words_needed (need : KDF9.NEST_depth)
   241.    return String
   242.       with Inline => False;
   243.
   244.    function pop
   245.    return KDF9.word
   246.       with Inline;
   247.
   248.    procedure pop
   249.       with Inline;
   250.
   251.    procedure write_top (the_word : in KDF9.word)
   252.       with Inline;
   253.
   254.    function read_top
   255.    return KDF9.word
   256.       with Inline;
   257.
   258.    function pop
   259.    return KDF9.pair
   260.       with Inline;
   261.
   262.    procedure pop_pair
   263.       with Inline;
   264.
   265.    procedure write_top (the_pair : in KDF9.pair)
   266.       with Inline;
   267.
   268.    function read_top
   269.    return KDF9.pair
   270.       with Inline;
   271.
   272.    -- The ensure_that_the_NEST_has_room_for* procedures trap NOUV.
   273.    -- They are used to validate operations that increase the NEST depth.
   274.
   275.    procedure ensure_that_the_NEST_has_room_for (at_least : in KDF9.NEST_depth)
   276.       with Inline;
   277.
   278.    procedure ensure_that_the_NEST_has_room_for_a_result
   279.       with Inline;
   280.
   281.    procedure push (the_word : in KDF9.word)
   282.       with Inline;
   283.
   284.    procedure ensure_that_the_NEST_has_room_for_2_results
   285.       with Inline;
   286.
   287.    procedure push (the_pair : in KDF9.pair)
   288.       with Inline;
   289.
   290.
   291.    --
   292.    -- The SJNS.
   293.    --
   294.
   295.    type SJNS_depth is mod 17;
   296.
   297.    type SJNS is array (KDF9.SJNS_depth) of KDF9.SJNS_link;
   298.
   299.    the_SJNS       : KDF9.SJNS;
   300.    JB             : KDF9.SJNS_link renames the_SJNS(16);
   301.    the_SJNS_depth : KDF9.SJNS_depth := 0;
   302.
   303.    procedure ensure_that_the_SJNS_is_not_empty
   304.       with Inline;
   305.
   306.    function pop
   307.    return KDF9.syllable_address
   308.       with Inline;
   309.
   310.    function SJNS_top
   311.    return KDF9.SJNS_link
   312.       with Inline;
   313.
   314.    procedure ensure_that_the_SJNS_is_not_full
   315.       with Inline;
   316.
   317.    procedure push (the_link : in KDF9.syllable_address)
   318.       with Inline;
   319.
   320.
   321.    --
   322.    -- The Q Store.
   323.    -- Q0 is kept permanently zeroised.
   324.    --
   325.
   326.    type Q_store is array (KDF9.Q_number) of KDF9.Q_register;
   327.
   328.    the_Q_store : KDF9.Q_store;
   329.
   330.
   331.    --
   332.    -- The Boolean registers.
   333.    --
   334.
   335.    the_V_bit_is_set : Boolean := False;
   336.    the_T_bit_is_set : Boolean := False;
   337.
   338.
   339.    --
   340.    --
   341.    -- The following are to do with maintaining the virtual time.
   342.    --
   343.    --
   344.
   345.    -- The date a multiple of 28 years ago has the same day/date correspondence as today.
   346.    -- To avoid exposing KDF9's lack of Y2K compliance, ee9 uses such a date before 2000.
   347.    -- 8-)
   348.    -- todays_date_28n_years_ago returns a word of 8 KDF9 characters in the format DD/MM/YY.
   349.
   350.    type us is mod 2**64;  -- The emulation clocks tick in microseconds (unlike KDF9's clock).
   351.
   352.    -- The virtual processor time.
   353.    the_CPU_time  : KDF9.us := 0;
   354.
   355.    -- The amount by which the_CPU_time is increased by an instruction execution.
   356.    the_CPU_delta : KDF9.us := 0;
   357.
   358.    -- The virtual elapsed time at which the next IO interrupt is expected.
   359.    the_next_interrupt_time : KDF9.us := KDF9.us'Last;
   360.
   361.    -- The virtual elapsed time, capped to prevent a spurious double-clock (RESET) interrupt.
   362.    function the_clock_time
   363.    return KDF9.us
   364.       with Inline;
   365.
   366.    -- Advance to the largest of the_CPU_time, the_elapsed_time, the_last_delay_time, and past.
   367.    -- Cap the increase to prevent a spurious double-clock (RESET) interrupt in Director.
   368.    -- If necessary, pause execution until the real time equals the virtual elapsed time.
   369.    procedure advance_the_clock (past : in KDF9.us);
   370.
   371.    -- If necessary, pause execution until the real time equals the virtual elapsed time.
   372.    procedure synchronize_the_real_and_virtual_times;
   373.
   374.    -- Getthe date as a word of 8 characters, thus: dd/mm/yy, where 19yy = this year-28n.
   375.    function todays_date_28n_years_ago
   376.    return KDF9.word;
   377.
   378.    -- The real time in microseconds since midnight.
   379.    function the_time_of_day
   380.    return KDF9.us;
   381.
   382. ------------------------------------------------------------------------------------------------
   383.
   384.    --
   385.    --
   386.    -- The following registers are used only in Director state.
   387.    --
   388.    --
   389.
   390.
   391.    --
   392.    -- The following are to do with the K1 order.
   393.    --
   394.
   395.    type priority is mod 2**2;
   396.
   397.    -- CPL = priority level of the currently-executing problem program.
   398.
   399.    CPL : KDF9.priority;
   400.
   401.    -- BA = word address of first allocated word (NOT group number as in the KDF9).
   402.
   403.    BA  : KDF9.address;
   404.
   405.    -- NOL = word address of last allocated word (NOT group number as in the KDF9).
   406.
   407.    NOL : KDF9.address;
   408.
   409.    -- Set BA (setting bits D38:47), CPL (D34:35) and NOL (D24:33).
   410.
   411.    procedure set_K1_register (setting : in KDF9.word);
   412.
   413.
   414.    --
   415.    -- The following are to do with the =K2 order.
   416.    --
   417.
   418.    -- The Current Peripheral Device Allocation Register.
   419.
   420.    type CPDAR is array (KDF9.buffer_number) of Boolean
   421.       with Component_Size => 8, Convention => C;
   422.
   423.    the_CPDAR : KDF9.CPDAR;
   424.
   425.    -- Set CPDAR (setting bits D32 .. D47).
   426.
   427.    procedure set_K2_register (setting : in KDF9.word);
   428.
   429.
   430.    --
   431.    -- The following are to do with the =K3 and K7 orders.
   432.    --
   433.
   434.    type user_register_set is
   435.       record
   436.          NEST     : KDF9.NEST;
   437.          SJNS     : KDF9.SJNS;
   438.          Q_store  : KDF9.Q_store;
   439.       end record;
   440.
   441.
   442.    -- There are 4 sets of user registers.
   443.    -- The execution context is the number of the register set in active use.
   444.
   445.    type context is mod 2**2;
   446.
   447.    -- register_bank holds the currently inactive register sets.
   448.
   449.    register_bank : array(KDF9.context) of KDF9.user_register_set;
   450.
   451.    -- KDF9 actually indexed the register bank with the value of the_context,
   452.    --   but the emulator swaps register sets between register_bank and
   453.    --      the_NEST, the_SJNS, and the_Q_store (q.v.).
   454.
   455.    the_context : KDF9.context := 0;
   456.
   457.    -- Set context (bits D46:47), NEST_depth (D41:45) and SJNS_depth (D36:41).
   458.
   459.    procedure set_K3_register (setting : in KDF9.word);
   460.
   461.    -- Get BA (bits D0 .. D9), CPL (D12 .. D13) and NOL (D14 .. D23).
   462.
   463.    function get_K7_operand
   464.    return KDF9.word;
   465.
   466.
   467.    --
   468.    -- The following are to do with the K4 order.
   469.    --
   470.
   471.    type interrupt_number is range 22 .. 31;
   472.
   473.    -- higher PRiority PRogram unblocked by end of I/O, or INTQq on busy device
   474.    caused_by_PR    : constant KDF9.interrupt_number := 22;
   475.    PR_exception    : exception;
   476.
   477.    -- FLEXowriter interrupt from operator
   478.    caused_by_FLEX  : constant KDF9.interrupt_number := 23;
   479.    FLEX_exception  : exception;
   480.
   481.    -- Lock-In Violation (attempt at a disallowed operation)
   482.    caused_by_LIV   : constant KDF9.interrupt_number := 24;
   483.    LIV_exception   : exception;
   484.
   485.    -- Nest (or SJNS) Over/Underflow Violation
   486.    caused_by_NOUV  : constant KDF9.interrupt_number := 25;
   487.    NOUV_exception  : exception;
   488.
   489.    -- End of Director Transfer, or I/O priority inversion
   490.    caused_by_EDT   : constant KDF9.interrupt_number := 26;
   491.    EDT_exception   : exception;
   492.
   493.    -- OUT system call
   494.    caused_by_OUT   : constant KDF9.interrupt_number := 27;
   495.    OUT_exception   : exception;
   496.
   497.    -- Lock-Out Violation
   498.    caused_by_LOV   : constant KDF9.interrupt_number := 28;
   499.    LOV_exception   : exception;
   500.
   501.    -- invalid syllable number or 'double-clock'
   502.    caused_by_RESET : constant KDF9.interrupt_number := 29;
   503.    RESET_exception : exception;
   504.
   505.    type RFIR is array (KDF9.interrupt_number) of Boolean;
   506.
   507.    the_RFIR : KDF9.RFIR := (others => False);
   508.
   509.    -- The time at which the last K4 order was executed.
   510.    the_last_K4_time : KDF9.us := 0;
   511.
   512.    -- Get clock (bits D0:15) and RFIR (D16:31), clearing both.
   513.    function get_K4_operand
   514.    return KDF9.word
   515.       with Inline => False;
   516.
   517.    -- An interrupt is raised when 1 second expires outside Director;
   518.    --    the flag does not correspond to any RFIR bit.
   519.    caused_by_CLOCK : constant KDF9.interrupt_number := 31;
   520.    CLOCK_exception : exception;
   521.
   522.    -- This is for tracing a return from Director;
   523.    --    the flag does not correspond to any RFIR bit.
   524.    EXITD_flag : constant KDF9.interrupt_number := 30;
   525.
   526.    -- abandon_this_order is raised
   527.    -- 1. when an interrupt is punted to Director
   528.    -- OR
   529.    -- 2. when an operation is attempted, in a program running under Director,
   530.    --    that is invalid but is not defined to cause a LIV interrupt.
   531.    abandon_this_order : exception;
   532.
   533.    --
   534.    -- The following are to do with the K5 order.
   535.    --
   536.
   537.    -- The Program Hold-Up register is internal to I/O Control.
   538.    -- Get PHUi (bits D6i .. 6i+5), i = 0 .. 3.
   539.
   540.    function get_K5_operand
   541.    return KDF9.word;
   542.
   543.
   544.    --
   545.    -- The following are to do with management of the CPU's internal state.
   546.    --
   547.
   548.    type CPU_state is (Director_state, program_state);
   549.
   550.    the_CPU_state : KDF9.CPU_state;
   551.
   552.    procedure reset_V_and_T;
   553.
   554.    procedure reset_the_CPU_state (initial_entry : KDF9.syllable_address);
   555.
   556.    procedure reset_the_internal_registers (the_new_state : in CPU_state);
   557.
   558.    procedure fail_in_problem_program_state;
   559.
   560.    procedure LOV_if_user_mode (cause : in String);
   561.
   562.    procedure return_from_Director_to (new_IAR : in KDF9.syllable_address);
   563.
   564.    procedure effect_interrupt (caused_by_this : in KDF9.interrupt_number; message : in String)
   565.       with Inline => False;
   566.
   567.    procedure check_for_a_clock_interrupt
   568.       with Inline;
   569.
   570.    procedure trap_illegal_instruction (the_message : in String := "invalid opcode")
   571.       with Inline => False;
   572.
   573.    procedure trap_operator_error (the_message : in String)
   574.       with Inline => False, No_Return;
   575.
   576.    procedure trap_unimplemented_feature (the_message : in String)
   577.       with Inline => False, No_Return;
   578.
   579.    procedure trap_failing_OUT (OUT_number : in KDF9.word; the_message : in String)
   580.       with Inline => False, No_Return;
   581.
   582.    procedure trap_invalid_paper_tape (the_message : in String)
   583.       with Inline => False, No_Return;
   584.
   585.    procedure reset_the_program_state;
   586.
   587.
   588.    --
   589.    --
   590.    -- Instruction fetch and decode.
   591.    --
   592.    --
   593.
   594.    -- These Instruction Address Registers are the nearest KDF9 has
   595.    --    to a conventional 'Program Counter' register.
   596.    -- NIA is significant only after an instruction has been decoded.
   597.
   598.    function NIA
   599.    return KDF9.syllable_address  -- the Next Instruction Address
   600.       with Inline;
   601.
   602.    function NIA_word_number
   603.    return KDF9.code_address
   604.       with Inline;
   605.
   606.    CIA : KDF9.syllable_address := (0, 0);  -- the Current Instruction Address
   607.
   608.    -- IWB0 and IWB1 in KDF9 contained the current 2 instruction words.
   609.    -- A 'short' loop, initiated by the JCqNZS instruction, ran entirely
   610.    --    inside the IWBs, obviating repeated instruction-fetch overhead.
   611.    -- Director exploits this in a loop that zeroizes the whole of core,
   612.    --    including that loop, which runs, immune to overwriting, in the IWBs.
   613.
   614.    procedure set_NIA_to (new_NIA : in KDF9.syllable_address)
   615.       with Inline;
   616.
   617.    procedure set_NIA_to_the_INS_target_address
   618.       with Inline;
   619.
   620.    procedure set_IWB0_and_IWB1_for_a_JCqNZS_loop
   621.       with Inline;
   622.
   623.    procedure go_back_to_the_start_of_IWB0
   624.       with Inline;
   625.
   626.    procedure continue_after_JCqNZS
   627.       with Inline;
   628.
   629.    -- Bits 0-1 of every order indicate its type as follows.
   630.
   631.    type INS_kind is mod 2**2;
   632.
   633.    one_syllable_order : constant := 0;
   634.    two_syllable_order : constant := 1;
   635.    normal_jump_order  : constant := 2;
   636.    data_access_order  : constant := 3;
   637.
   638.    type decoded_order is
   639.       record
   640.          order : KDF9.syllable_group := (0, 0, 0);
   641.          kind  : KDF9.INS_kind := 0;
   642.
   643.          -- The compressed_opcode is:
   644.          --    bits 2-7 of 1- and 2-syllable orders
   645.          --    bits 2-3|8-11 of normal jumps
   646.          --    bits 5-7 of SET and directly-addressed store access orders.
   647.          -- See the KDF9.decoding package.
   648.          compressed_opcode : KDF9.compressed_opcode := 0;
   649.
   650.           -- Qq is bits 8-11, Qk is bits 12-15.
   651.          Qq, Qk : KDF9.Q_number := 0;
   652.
   653.          -- For an jump instruction, syllable_index is bits 5-7.
   654.          target : KDF9.syllable_address;
   655.
   656.          -- For a data address or value (SET), operand is bits 2-4|12-23.
   657.          operand : KDF9.Q_part := 0;
   658.       end record;
   659.
   660.    INS : KDF9.decoded_order;  -- analogous to the INS register in Main Control
   661.
   662.    -- After decode_the_next_order:
   663.    --    INS contains the whole instruction at the address given by CIA,
   664.    --       with its components unpacked (not all are significant in every case).
   665.
   666.    procedure decode_the_next_order
   667.       with Inline;
   668.
   669.    procedure decode (the_order : in out KDF9.decoded_order)
   670.       with Inline;
   671.
   672.    procedure process_syllable_0_of_INS
   673.       with Inline;
   674.
   675.    procedure process_syllable_1_of_INS
   676.       with Inline;
   677.
   678.    procedure process_syllables_1_and_2_of_a_jump_order
   679.       with Inline;
   680.
   681.    procedure process_syllables_1_and_2_of_a_data_access_order
   682.       with Inline;
   683.
   684.    -- the_order_at_NIA gets three syllables starting at [NIA].
   685.    -- It is FOR DIAGNOSTIC USE ONLY!
   686.    -- It does NOT update the CPU time properly and must not be used inside an instruction cycle!
   687.
   688.    function the_order_at_NIA
   689.    return KDF9.syllable_group
   690.       with Inline;
   691.
   692.    -- Save E0U, lest the initial jump in E0 be corrupted during the run.
   693.    procedure save_the_initial_jump;
   694.
   695.    -- Restore E0U to its saved value.
   696.    procedure restore_the_initial_jump;
   697.
   698.    -- Check whether E0U has changed.
   699.    function the_initial_jump_was_corrupted
   700.    return Boolean;
   701.
   702.    -- True if the parameter is not a valid KDF9 instruction.
   703.    function is_an_invalid_order (decoded : KDF9.decoded_order)
   704.    return Boolean;
   705.
   706.    -- True if the parameter is a well-formed unconditional jump.
   707.    function is_an_unconditional_jump (decoded : KDF9.decoded_order)
   708.    return Boolean;
   709.
   710.    --
   711.    -- The Instruction Counter Register, ICR, (N.B. NOT a 'PROGRAM counter')
   712.    --   indicates the number of instructions executed by the KDF9.
   713.    --
   714.
   715.    type order_counter is mod 2**64;
   716.
   717.    ICR : KDF9.order_counter := 0;
   718.
   719.
   720.    --
   721.    -- The following support hashed execution-signature checking,
   722.    --    mainly for self-checking of new versions and ports.
   723.    --
   724.
   725.    function the_digital_signature
   726.    return KDF9.word;
   727.
   728.    procedure update_the_digital_signature
   729.       with Inline;
   730.
   731. private
   732.
   733.    use KDF9_char_sets; pragma Warnings(Off, KDF9_char_sets);
   734.    use string_editing; pragma Warnings(Off, string_editing);
   735.
   736.    the_elapsed_time    : KDF9.us := 0;
   737.
   738.    fetching_normally   : Boolean := True;
   739.
   740. end KDF9;

 1092 lines: No errors


Compiling: /home/parallels/emulation/Source/kdf9-microcode.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:00

     1. -- KDF9 ISP emulation - CPU microcode routines.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with break_in;
    18. with exceptions;
    19. with IOC;
    20. with IOC.dispatcher;
    21. with KDF9.CPU;
    22. with KDF9.decoding;
    23. with KDF9.EGDON;
    24. with KDF9.store;
    25. with KDF9.TSD;
    26. with KDF9.TSD.processes;
    27. with POSIX;
    28. with settings;
    29. with state_display;
    30. with tracing;
    31.
    32. use  exceptions;
    33. use  IOC;
    34. use  IOC.dispatcher;
    35. use  KDF9.CPU;
    36. use  KDF9.decoding;
    37. use  KDF9.EGDON;
    38. use  KDF9.store;
    39. use  KDF9.TSD;
    40. use  KDF9.TSD.processes;
    41. use  settings;
    42. use  state_display;
    43. use  tracing;
    44.
    45. package body KDF9.microcode is
    46.
    47.    procedure do_a_one_syllable_order is
    48.       A, B, C, E : KDF9.word;
    49.       bit_count  : KDF9.word;
    50.       AB, CD     : KDF9.pair;
    51.       X, Y       : CPU.f48;
    52.       XY, ZT     : CPU.f96;
    53.    begin
    54.       case INS.compressed_opcode is
    55.
    56.          when 0 =>
    57.             -- The DUMMY order originally had code 0, before being changed to #17.
    58.             -- The Kidsgrove compiler continued to use code 0, so we must assume that,
    59.             --    despite the Manual, 0 continued to be a valid no-op order.
    60.             the_CPU_delta := the_CPU_delta + 1;
    61.
    62.          when VR =>
    63.             the_V_bit_is_set := False;
    64.             the_CPU_delta := the_CPU_delta + 1;
    65.
    66.          when TO_TR =>
    67.             ensure_that_the_NEST_holds_an_operand;
    68.             if resign(pop) < 0 then
    69.                the_T_bit_is_set := True;
    70.             end if;
    71.             the_CPU_delta := the_CPU_delta + 2;
    72.
    73.          when BITS =>
    74.             write_top(number_of_1_bits_in(read_top));
    75.             the_CPU_delta := the_CPU_delta + 27;
    76.
    77.          when XF =>
    78.             ensure_that_the_NEST_holds_2_operands;
    79.             X := pop;
    80.             Y := read_top;
    81.             write_top(CPU.f48'(Y * X));
    82.             the_CPU_delta := the_CPU_delta + 15;
    83.
    84.          when XDF =>
    85.             ensure_that_the_NEST_holds_2_operands;
    86.             XY := read_top;
    87.             ZT := XY.lsw * XY.msw;
    88.             write_top(ZT);
    89.             the_CPU_delta := the_CPU_delta + 16;
    90.
    91.          when XPLUSF =>
    92.             ensure_that_the_NEST_holds(at_least => 4);
    93.             XY := pop;
    94.             ZT := XY.lsw * XY.msw;
    95.             XY := read_top;
    96.             write_top(XY + ZT);
    97.             the_CPU_delta := the_CPU_delta + 18;
    98.
    99.          when NEGD =>
   100.             AB := read_top;
   101.             write_top( - AB);
   102.             the_CPU_delta := the_CPU_delta + 2;
   103.
   104.          when OR_9 =>
   105.             ensure_that_the_NEST_holds_2_operands;
   106.             A := pop;
   107.             write_top(read_top or A);
   108.             the_CPU_delta := the_CPU_delta + 1;
   109.
   110.          when PERM =>
   111.             A := pop;
   112.             CD := pop;
   113.             push(A);
   114.             push(CD);
   115.             the_CPU_delta := the_CPU_delta + 2;
   116.
   117.          when TOB =>
   118.             ensure_that_the_NEST_holds_2_operands;
   119.             A := pop;      -- the value
   120.             bit_count := number_of_1_bits_in(A);
   121.             B := read_top; -- the radixes
   122.             C := 0;
   123.
   124.             for i in 1 .. 8 loop
   125.                A := rotate_word_left(A, 6);
   126.                B := rotate_word_left(B, 6);
   127.                E := B and 8#77#; -- this radix
   128.                C := C*E + (A and 8#77#);
   129.             end loop;
   130.
   131.             write_top(C);
   132.             the_CPU_delta := the_CPU_delta + 2 + 4*KDF9.us(bit_count);
   133.
   134.          when ROUNDH =>
   135.             A := read_top;
   136.             write_top(resign(A) + 2**23);
   137.             the_CPU_delta := the_CPU_delta + 22;
   138.
   139.          when NEV =>
   140.             ensure_that_the_NEST_holds_2_operands;
   141.             A := pop;
   142.             write_top(read_top xor A);
   143.             the_CPU_delta := the_CPU_delta + 2;
   144.
   145.          when ROUND =>
   146.             ensure_that_the_NEST_holds_2_operands;
   147.             A := pop;
   148.             write_top(resign(A) + resign(shift_word_right(read_top, 46) and 1));
   149.             the_CPU_delta := the_CPU_delta + 1;
   150.
   151.          when DUMMY =>
   152.             the_CPU_delta := the_CPU_delta + 1;
   153.
   154.          when ROUNDF =>
   155.             ensure_that_the_NEST_holds_2_operands;
   156.             XY := pop;
   157.             ZT := XY;
   158.             push(narrowed(XY));
   159.             the_CPU_delta := the_CPU_delta + 3;
   160.
   161.          when ROUNDHF =>
   162.             X := pop;
   163.             push(narrowed(X));
   164.             the_CPU_delta := the_CPU_delta + 3;
   165.
   166.          when MINUSDF =>
   167.             ensure_that_the_NEST_holds(at_least => 4);
   168.             XY := pop;
   169.             ZT := read_top;
   170.             write_top(ZT - XY);
   171.             the_CPU_delta := the_CPU_delta + 12;
   172.
   173.          when PLUSDF =>
   174.             ensure_that_the_NEST_holds(at_least => 4);
   175.             XY := pop;
   176.             ZT := read_top;
   177.             write_top(ZT + XY);
   178.             the_CPU_delta := the_CPU_delta + 12;
   179.
   180.          when FLOAT_9 =>
   181.             ensure_that_the_NEST_holds_2_operands;
   182.             -- There is great uncertainty as to how the FLOAT/FLOATD orders handled scale factors
   183.             --   in N1 that lie outside the range allowed by the Manual, namely -128 <= N1 <= +127.
   184.             -- ee9 here takes a safety-first approach which is consistent with the
   185.             --    behaviour of the Kidsgrove sqrt function with arguments < 0.50.
   186.             A := shift_arithmetic(shift_logical(pop, +40), -40);
   187.             B := read_top;
   188.             write_top(KDF9.word(normalized(full_fraction => B, scaler => A)));
   189.
   190.          when FLOATD =>
   191.             ensure_that_the_NEST_holds(at_least => 3);
   192.             A := shift_arithmetic(shift_logical(pop, +40), -40);
   193.             CD := read_top;
   194.             -- See 3.4 of Report K/GD.y.83, dated 6/12/1962.  It would seem to require this:
   195.             -- CD.lsw := CD.lsw and not 8#77#;  -- The 6 l.s.b. are lost.
   196.             -- The above is commented out because it gives the wrong answer with KAA01.
   197.             -- A post-document hardware modification is suspected.
   198.             reconstruct(CD, scaler => A);
   199.             write_top(CD);
   200.             the_CPU_delta := the_CPU_delta + 8;
   201.
   202.          when ABS_9 =>
   203.             write_top( abs resign(read_top));
   204.             the_CPU_delta := the_CPU_delta + 1;
   205.
   206.          when NEG =>
   207.             write_top( - resign(read_top));
   208.             the_CPU_delta := the_CPU_delta + 1;
   209.
   210.          when ABSF =>
   211.             X := read_top;
   212.             if resign(KDF9.word(X)) < 0 then
   213.                write_top( - X);
   214.                the_CPU_delta := the_CPU_delta + 4;
   215.             else
   216.                the_CPU_delta := the_CPU_delta + 1;
   217.             end if;
   218.
   219.          when NEGF =>
   220.             X := read_top;
   221.             write_top( - X);
   222.             the_CPU_delta := the_CPU_delta + 3;
   223.
   224.          when MAX =>
   225.             AB := read_top;
   226.             if resign(AB.lsw) >= resign(AB.msw) then
   227.                write_top(KDF9.pair'(msw => AB.lsw, lsw =>AB.msw));
   228.                the_V_bit_is_set := True;
   229.             end if;
   230.             the_CPU_delta := the_CPU_delta + 4;
   231.
   232.          when NOT_9 =>
   233.             A := read_top;
   234.             write_top(not A);
   235.             the_CPU_delta := the_CPU_delta + 1;
   236.
   237.          when XD =>
   238.             AB := read_top;
   239.             CD := AB.msw * AB.lsw;
   240.             write_top(CD);
   241.             the_CPU_delta := the_CPU_delta + 14;
   242.
   243.          when X_frac =>
   244.             ensure_that_the_NEST_holds_2_operands;
   245.             A := pop;
   246.             write_top(as_word(CPU.fraction'(read_top * A)));
   247.             the_CPU_delta := the_CPU_delta + 15;
   248.
   249.          when MINUS =>
   250.             ensure_that_the_NEST_holds_2_operands;
   251.             A := pop;
   252.             B := read_top;
   253.             write_top(resign(B) - resign(A));
   254.             the_CPU_delta := the_CPU_delta + 1;
   255.
   256.          when SIGN =>
   257.             ensure_that_the_NEST_holds_2_operands;
   258.             A := pop;
   259.             B := read_top;
   260.             if B = A then
   261.                write_top(KDF9.word'(0));
   262.             elsif resign(B) > resign(A) then
   263.                write_top(KDF9.word'(1));
   264.             else
   265.                write_top(KDF9.word'(all_one_bits));
   266.             end if;
   267.             the_CPU_delta := the_CPU_delta + 3;
   268.
   269.          when ZERO =>
   270.             ensure_that_the_NEST_has_room_for_a_result;
   271.             push(KDF9.word'(all_zero_bits));
   272.             the_CPU_delta := the_CPU_delta + 2;
   273.
   274.          when DUP =>
   275.             ensure_that_the_NEST_has_room_for_a_result;
   276.             A := read_top;
   277.             push(A);
   278.             the_CPU_delta := the_CPU_delta + 2;
   279.
   280.          when DUPD =>
   281.             ensure_that_the_NEST_has_room_for_2_results;
   282.             AB := read_top;
   283.             push(AB);
   284.             the_CPU_delta := the_CPU_delta + 4;
   285.
   286.          when DIVI =>
   287.             AB := read_top;
   288.             do_DIVI(L => AB.lsw,
   289.                     R => AB.msw,
   290.                     Quotient  => CD.lsw,
   291.                     Remainder => CD.msw);
   292.             write_top(CD);
   293.             the_CPU_delta := the_CPU_delta + 36;
   294.
   295.          when FIX =>
   296.             ensure_that_the_NEST_holds_an_operand;
   297.             ensure_that_the_NEST_has_room_for_a_result;
   298.             X := read_top;
   299.             write_top(fraction_word(X));
   300.             push(scaler(X));
   301.             the_CPU_delta := the_CPU_delta + 6;
   302.
   303.          when STR =>
   304.             ensure_that_the_NEST_has_room_for_a_result;
   305.             A := read_top;
   306.             if resign(A) < 0 then
   307.                write_top(A and not_sign_bit);
   308.                push(KDF9.word'(all_one_bits));
   309.             else
   310.                push(KDF9.word'(all_zero_bits));
   311.             end if;
   312.             the_CPU_delta := the_CPU_delta + 3;
   313.
   314.          when CONT =>
   315.             ensure_that_the_NEST_holds_2_operands;
   316.             A := pop;
   317.             B := read_top;
   318.             write_top(contracted(KDF9.pair'(msw => A, lsw => B)));
   319.             the_CPU_delta := the_CPU_delta + 2;
   320.
   321.          when REVD =>
   322.             AB := pop;
   323.             CD := pop;
   324.             push(AB);
   325.             push(CD);
   326.             the_CPU_delta := the_CPU_delta + 4;
   327.
   328.          when ERASE =>
   329.             ensure_that_the_NEST_holds_an_operand;
   330.             pop;
   331.             the_CPU_delta := the_CPU_delta + 1;
   332.
   333.          when MINUSD =>
   334.             ensure_that_the_NEST_holds(at_least => 4);
   335.             AB := pop;
   336.             CD := read_top;
   337.             write_top(CD - AB);
   338.             the_CPU_delta := the_CPU_delta + 3;
   339.
   340.          when AND_9 =>
   341.             ensure_that_the_NEST_holds_2_operands;
   342.             A := pop;
   343.             write_top(read_top and A);
   344.             the_CPU_delta := the_CPU_delta + 1;
   345.
   346.          when PLUS =>
   347.             ensure_that_the_NEST_holds_2_operands;
   348.             A := pop;
   349.             B := read_top;
   350.             write_top(resign(B) + resign(A));
   351.             the_CPU_delta := the_CPU_delta + 1;
   352.
   353.          when PLUSD =>
   354.             ensure_that_the_NEST_holds(at_least => 4);
   355.             AB := pop;
   356.             CD := read_top;
   357.             write_top(CD + AB);
   358.             the_CPU_delta := the_CPU_delta + 3;
   359.
   360.          when DIV =>
   361.             ensure_that_the_NEST_holds_2_operands;
   362.             AB := pop;
   363.             push(as_word(CPU.fraction'(AB.lsw / AB.msw)));
   364.             the_CPU_delta := the_CPU_delta + 36;
   365.
   366.          when DIVD =>
   367.             ensure_that_the_NEST_holds(at_least => 3);
   368.             A := pop;
   369.             CD := pop;
   370.             do_DIVD(L => CD,
   371.                     R => A,
   372.                     Q => E);
   373.             push(E);
   374.             the_CPU_delta := the_CPU_delta + 36;
   375.
   376.          when DIVF =>
   377.             X := pop;
   378.             Y := read_top;
   379.             write_top(Y / X);
   380.             the_CPU_delta := the_CPU_delta + 36;
   381.
   382.          when DIVDF =>
   383.             ensure_that_the_NEST_holds(at_least => 3);
   384.             Y := pop;
   385.             XY := pop;
   386.             push(XY / Y);
   387.             the_CPU_delta := the_CPU_delta + 35;
   388.
   389.          when DIVR =>
   390.             ensure_that_the_NEST_holds(at_least => 3);
   391.             A := pop;
   392.             CD := read_top;
   393.             do_DIVR(L => CD,
   394.                     R => A,
   395.                     Quotient  => AB.msw,
   396.                     Remainder => AB.lsw);
   397.             write_top(AB);
   398.             the_CPU_delta := the_CPU_delta + 36;
   399.
   400.          when REV =>
   401.             AB := read_top;
   402.             write_top(KDF9.pair'(msw => AB.lsw, lsw =>AB.msw));
   403.             the_CPU_delta := the_CPU_delta + 1;
   404.
   405.          when CAB =>
   406.             AB := pop;
   407.             C := pop;
   408.             push(AB);
   409.             push(C);
   410.             the_CPU_delta := the_CPU_delta + 2;
   411.
   412.          when FRB =>
   413.             ensure_that_the_NEST_holds_2_operands;
   414.             A := pop;      -- the value
   415.             bit_count := number_of_1_bits_in(A);
   416.             B := read_top; -- the radixes
   417.             C := 0;
   418.
   419.             for i in 1 .. 8 loop
   420.                E := B and 8#77#;
   421.                if E /= 0 then
   422.                   C := C or (A mod E);
   423.                   A := A / E;
   424.                else
   425.                   if A /= 0 then the_V_bit_is_set := True; end if;
   426.                end if;
   427.                B := shift_word_right(B, 6);
   428.                C := rotate_word_right(C, 6);
   429.             end loop;
   430.
   431.             if A /= 0 then
   432.                -- The value was too big for the representation; see Manual.
   433.                the_V_bit_is_set := True;
   434.             end if;
   435.             write_top(C);
   436.             the_CPU_delta := the_CPU_delta + 8 + 3*KDF9.us(bit_count);
   437.
   438.          when STAND =>
   439.             X := read_top;
   440.             write_top(normalized(X));
   441.             the_CPU_delta := the_CPU_delta + 5;
   442.
   443.          when NEGDF =>
   444.             XY := read_top;
   445.             write_top( - XY);
   446.             the_CPU_delta := the_CPU_delta + 9;
   447.
   448.          when MAXF =>
   449.             XY := read_top;
   450.             if XY.lsw >= XY.msw then
   451.                write_top(CPU.f96'(msw => XY.lsw, lsw =>XY.msw));
   452.                the_V_bit_is_set := True;
   453.             end if;
   454.             the_CPU_delta := the_CPU_delta + 6;
   455.
   456.          when PLUSF =>
   457.             ensure_that_the_NEST_holds_2_operands;
   458.             X := pop;
   459.             Y := read_top;
   460.             write_top(Y + X);
   461.             the_CPU_delta := the_CPU_delta + 7;
   462.
   463.          when MINUSF =>
   464.             ensure_that_the_NEST_holds_2_operands;
   465.             X := pop;
   466.             Y := read_top;
   467.             write_top(Y - X);
   468.             the_CPU_delta := the_CPU_delta + 7;
   469.
   470.          when SIGNF =>
   471.             ensure_that_the_NEST_holds_2_operands;
   472.             XY := pop;
   473.             if KDF9.word(XY.lsw) = KDF9.word(XY.msw) then
   474.                push(KDF9.word'(all_zero_bits));
   475.             elsif XY.lsw < XY.msw then
   476.                push(KDF9.word'(all_one_bits));
   477.             else
   478.                push(KDF9.word(1));
   479.             end if;
   480.             the_CPU_delta := the_CPU_delta + 5;
   481.
   482.          when others =>
   483.             trap_illegal_instruction;
   484.
   485.       end case;
   486.    end do_a_one_syllable_order;
   487.
   488.
   489.    procedure do_an_IO_order is
   490.       IO_opcode   : constant KDF9.compressed_opcode := (INS.Qk and not manual_bit);
   491.       IO_operand  : constant KDF9.Q_register := the_Q_store(INS.Qq);
   492.       set_offline : constant Boolean         := (INS.Qk and manual_bit) /= 0;
   493.    begin
   494.       case INS.compressed_opcode is
   495.
   496.          when PAR_Qq =>
   497.             the_CPU_delta := the_CPU_delta + 11;
   498.             PAR(IO_operand, set_offline, the_T_bit_is_set);
   499.             the_CPU_delta := the_CPU_delta + 3;
   500.
   501.          when PIA_PIC_CLO_TLO_Qq =>
   502.             the_CPU_delta := the_CPU_delta + 15;
   503.             case IO_opcode is
   504.                when PIA_bits =>
   505.                   PIA(IO_operand, set_offline);
   506.                   the_CPU_delta := the_CPU_delta + 7;
   507.                when PIC_bits =>
   508.                   PIC(IO_operand, set_offline);
   509.                   the_CPU_delta := the_CPU_delta + 7;
   510.                when CLO_bits =>
   511.                   fail_in_problem_program_state;
   512.                   CLO(IO_operand, set_offline);
   513.                   the_CPU_delta := the_CPU_delta + 1;
   514.                when TLO_bits =>
   515.                   TLO(IO_operand, the_T_bit_is_set);
   516.                when others =>
   517.                   trap_illegal_instruction;
   518.             end case;
   519.
   520.          when PIB_PID_Qq =>
   521.             the_CPU_delta := the_CPU_delta + 15;
   522.             case IO_opcode is
   523.                when PIB_bits =>
   524.                   PIB(IO_operand, set_offline);
   525.                   the_CPU_delta := the_CPU_delta + 7;
   526.                when PID_bits =>
   527.                   PID(IO_operand, set_offline);
   528.                   the_CPU_delta := the_CPU_delta + 7;
   529.                when others =>
   530.                   trap_illegal_instruction;
   531.             end case;
   532.
   533.          when PIE_PIG_Qq =>
   534.             the_CPU_delta := the_CPU_delta + 15;
   535.             case IO_opcode is
   536.                when PIE_bits =>
   537.                   PIE(IO_operand, set_offline);
   538.                   the_CPU_delta := the_CPU_delta + 7;
   539.                when PIG_bits =>
   540.                   PIG(IO_operand, set_offline);
   541.                   the_CPU_delta := the_CPU_delta + 7;
   542.                when others =>
   543.                   trap_illegal_instruction;
   544.             end case;
   545.
   546.          when PIF_PIH_Qq =>
   547.             the_CPU_delta := the_CPU_delta + 15;
   548.             case IO_opcode is
   549.                when PIF_bits =>
   550.                   PIF(IO_operand, set_offline);
   551.                   the_CPU_delta := the_CPU_delta + 7;
   552.                when PIH_bits =>
   553.                   PIH(IO_operand, set_offline);
   554.                   the_CPU_delta := the_CPU_delta + 7;
   555.                when others =>
   556.                   trap_illegal_instruction;
   557.             end case;
   558.
   559.          when PMA_PMK_INT_Qq =>
   560.             the_CPU_delta := the_CPU_delta + 11;
   561.             case IO_opcode is
   562.                when PMA_bits =>
   563.                   PMA(IO_operand, set_offline);
   564.                when PMK_bits =>
   565.                   PMK(IO_operand, set_offline);
   566.                when INT_bits =>
   567.                   INT(IO_operand, set_offline);
   568.                when others =>
   569.                   trap_illegal_instruction;
   570.             end case;
   571.
   572.          when CT_PMB_PMC_BUSY_Qq =>
   573.             the_CPU_delta := the_CPU_delta + 11;
   574.             case IO_opcode is
   575.                when CTQ_bits =>
   576.                   -- if set_offline then MANUALQq else CTQq
   577.                   if set_offline                      or else
   578.                         the_CPU_state = Director_state   then
   579.                      MANUAL_CT(IO_operand, set_offline);
   580.                      the_CPU_delta := the_CPU_delta + 2;
   581.                   else
   582.                      trap_illegal_instruction; -- This will always LIV, as we are not in Director.
   583.                   end if;
   584.                when PMB_bits =>
   585.                   PMB(IO_operand, set_offline);
   586.                   the_CPU_delta := the_CPU_delta + 3;
   587.                when PMC_bits =>
   588.                   PMC(IO_operand, set_offline);
   589.                   the_CPU_delta := the_CPU_delta + 3;
   590.                when BUSY_bits =>
   591.                   BUSY(IO_operand, set_offline, the_T_bit_is_set);
   592.                   the_CPU_delta := the_CPU_delta + 2;
   593.                when others =>
   594.                   trap_illegal_instruction;
   595.             end case;
   596.
   597.          when PMD_PME_PML_Qq =>
   598.             the_CPU_delta := the_CPU_delta + 14;
   599.             case IO_opcode is
   600.                when PMD_bits =>
   601.                   PMD(IO_operand, set_offline);
   602.                   the_CPU_delta := the_CPU_delta + 5;
   603.                when PME_bits =>
   604.                   PME(IO_operand, set_offline);
   605.                   the_CPU_delta := the_CPU_delta + 5;
   606.                when PML_bits =>
   607.                   PML(IO_operand, set_offline);
   608.                   the_CPU_delta := the_CPU_delta + 5;
   609.                when others =>
   610.                   trap_illegal_instruction;
   611.             end case;
   612.
   613.          when PMF_PMG_Qq =>
   614.             the_CPU_delta := the_CPU_delta + 11;
   615.             case IO_opcode is
   616.                when PMF_bits =>
   617.                   PMF(IO_operand, set_offline);
   618.                   the_CPU_delta := the_CPU_delta + 3;
   619.                when PMG_bits =>
   620.                   fail_in_problem_program_state;
   621.                   the_CPU_delta := the_CPU_delta + 14;  -- ??
   622.                   PMG(IO_operand, set_offline);
   623.                 when others =>
   624.                   trap_illegal_instruction;
   625.             end case;
   626.
   627.          when POA_POC_POE_POF_PMH_Qq =>
   628.             the_CPU_delta := the_CPU_delta + 15;
   629.             case IO_opcode is
   630.                when POA_bits =>
   631.                   POA(IO_operand, set_offline);
   632.                   the_CPU_delta := the_CPU_delta + 7;
   633.                when POC_bits =>
   634.                   POC(IO_operand, set_offline);
   635.                   the_CPU_delta := the_CPU_delta + 7;
   636.                when POE_bits =>
   637.                   POE(IO_operand, set_offline);
   638.                   the_CPU_delta := the_CPU_delta + 4;
   639.                when POF_bits =>
   640.                   POF(IO_operand, set_offline);
   641.                   the_CPU_delta := the_CPU_delta + 4;
   642.                when PMH_bits =>
   643.                   fail_in_problem_program_state;
   644.                   SLO(IO_operand, set_offline);
   645.                   the_CPU_delta := the_CPU_delta + 1;
   646.                when others =>
   647.                   trap_illegal_instruction;
   648.             end case;
   649.
   650.          when POB_POD_Qq =>
   651.             the_CPU_delta := the_CPU_delta + 15;
   652.             case IO_opcode is
   653.                when POB_bits =>
   654.                   POB(IO_operand, set_offline);
   655.                   the_CPU_delta := the_CPU_delta + 7;
   656.                when POD_bits =>
   657.                   POD(IO_operand, set_offline);
   658.                   the_CPU_delta := the_CPU_delta + 7;
   659.                when others =>
   660.                   trap_illegal_instruction;
   661.             end case;
   662.
   663.          when POG_POL_Qq =>
   664.             the_CPU_delta := the_CPU_delta + 15;
   665.             case IO_opcode is
   666.                when POG_bits =>
   667.                   POG(IO_operand, set_offline);
   668.                   the_CPU_delta := the_CPU_delta + 7;
   669.                when POL_bits =>
   670.                   POL(IO_operand, set_offline);
   671.                   the_CPU_delta := the_CPU_delta + 7;
   672.                when others =>
   673.                   trap_illegal_instruction;
   674.             end case;
   675.
   676.          when POH_POK_Qq =>
   677.             the_CPU_delta := the_CPU_delta + 15;
   678.             case IO_opcode is
   679.                when POH_bits =>
   680.                   POH(IO_operand, set_offline);
   681.                   the_CPU_delta := the_CPU_delta + 7;
   682.                when POK_bits =>
   683.                   POK(IO_operand, set_offline);
   684.                   the_CPU_delta := the_CPU_delta + 7;
   685.                when others =>
   686.                   trap_illegal_instruction;
   687.             end case;
   688.
   689.          when others =>
   690.             trap_illegal_instruction;
   691.
   692.       end case;
   693.    end do_an_IO_order;
   694.
   695.
   696.    all_zero_Q_store : constant KDF9.Q_register := (C | I | M => 0);
   697.
   698.    procedure ensure_that_Q0_contains_zero (suspect : KDF9.Q_number)
   699.       with Inline;
   700.
   701.    procedure ensure_that_Q0_contains_zero (suspect : KDF9.Q_number) is
   702.    begin
   703.       if suspect = 0 then
   704.          the_Q_store(0) := all_zero_Q_store;  -- Override any assignment to Q0.
   705.       end if;
   706.    end ensure_that_Q0_contains_zero;
   707.
   708.    procedure auto_increment
   709.       with Inline;
   710.
   711.    procedure auto_increment is
   712.    begin
   713.       if INS.Qq /= 0 then
   714.          the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M + the_Q_store(INS.Qq).I;
   715.          the_Q_store(INS.Qq).C := the_Q_store(INS.Qq).C - 1;
   716.       end if;
   717.    end auto_increment;
   718.
   719.    function shift_count
   720.    return CPU.signed_Q_part
   721.       with Inline;
   722.
   723.    function shift_count
   724.    return CPU.signed_Q_part
   725.    is (
   726.        if (INS.order.syllable_1 and constant_bit) /= 0  then
   727.           resign(KDF9.Q_part(INS.order.syllable_1/2 xor 64)) - 64
   728.        else
   729.           resign((the_Q_store(INS.Qq).C and 255) xor 128) - 128
   730.       );
   731.
   732.
   733.    procedure do_a_two_syllable_order is
   734.       A  : KDF9.word;
   735.       AB : KDF9.pair;
   736.       CD : KDF9.pair;
   737.    begin
   738.       case INS.compressed_opcode is
   739.
   740.          when JCqNZS =>
   741.             if CIA.syllable_index = 5 then
   742.                -- KDF9 did not actually detect this error, and the JCqNZS instruction would work
   743.                --    until broken-into by an interrupt, which returned to the word following that
   744.                --       containing the first syllable of the JCqNZS instruction.
   745.                -- I see no case for reproducing this behaviour.
   746.                trap_illegal_instruction ("JCqNZS instruction at syllable 5");
   747.             end if;
   748.             if the_Q_store(INS.Qq).C /= 0 then
   749.                if fetching_normally then
   750.                   set_IWB0_and_IWB1_for_a_JCqNZS_loop;
   751.                   the_CPU_delta := the_CPU_delta + 7;  -- Takes 11s the first time it jumps.
   752.                end if;
   753.                -- The IWBs now contain the loop, so go to syllable 0 of IWB0.
   754.                go_back_to_the_start_of_IWB0;
   755.             else
   756.                continue_after_JCqNZS;
   757.             end if;
   758.             the_CPU_delta := the_CPU_delta + 4;
   759.
   760.          when MkMq =>
   761.             the_trace_address := virtual_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   762.             check_address_and_lockout(the_trace_address);
   763.             ensure_that_the_NEST_has_room_for_a_result;
   764.             the_trace_operand := fetch_word(the_trace_address);
   765.             push(the_trace_operand);
   766.             the_CPU_delta := the_CPU_delta + 7;
   767.
   768.          when MkMqQ =>
   769.             the_trace_address := virtual_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   770.             check_address_and_lockout(the_trace_address);
   771.             ensure_that_the_NEST_has_room_for_a_result;
   772.             the_trace_operand := fetch_word(the_trace_address);
   773.             push(the_trace_operand);
   774.             auto_increment;
   775.             the_CPU_delta := the_CPU_delta + 8;
   776.
   777.          when MkMqH =>
   778.             the_trace_address := virtual_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   779.             check_address_and_lockout(the_trace_address);
   780.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   781.             ensure_that_the_NEST_has_room_for_a_result;
   782.             push(the_trace_operand);
   783.             the_CPU_delta := the_CPU_delta + 7;
   784.
   785.          when MkMqQH =>
   786.             the_trace_address := virtual_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   787.             check_address_and_lockout(the_trace_address);
   788.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   789.             ensure_that_the_NEST_has_room_for_a_result;
   790.             push(the_trace_operand);
   791.             auto_increment;
   792.             the_CPU_delta := the_CPU_delta + 8;
   793.
   794.          when MkMqN =>
   795.             the_trace_address := virtual_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   796.             check_address_and_lockout(the_trace_address);
   797.             ensure_that_the_NEST_has_room_for_a_result;
   798.             the_trace_operand := fetch_word(the_trace_address);
   799.             push(the_trace_operand);
   800.             the_CPU_delta := the_CPU_delta + 7;
   801.
   802.          when MkMqQN =>
   803.             the_trace_address := virtual_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   804.             check_address_and_lockout(the_trace_address);
   805.             ensure_that_the_NEST_has_room_for_a_result;
   806.             the_trace_operand := fetch_word(the_trace_address);
   807.             push(the_trace_operand);
   808.             auto_increment;
   809.             the_CPU_delta := the_CPU_delta + 8;
   810.
   811.          when MkMqHN =>
   812.             the_trace_address := virtual_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   813.             check_address_and_lockout(the_trace_address);
   814.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   815.             ensure_that_the_NEST_has_room_for_a_result;
   816.             push(the_trace_operand);
   817.             the_CPU_delta := the_CPU_delta + 7;
   818.
   819.          when MkMqQHN =>
   820.             the_trace_address := virtual_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   821.             check_address_and_lockout(the_trace_address);
   822.             the_trace_operand := fetch_halfword(the_trace_address, the_Q_store(INS.Qq).M mod 2);
   823.             ensure_that_the_NEST_has_room_for_a_result;
   824.             push(the_trace_operand);
   825.             auto_increment;
   826.             the_CPU_delta := the_CPU_delta + 8;
   827.
   828.          when TO_MkMq =>
   829.             the_trace_address := virtual_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   830.             check_address_and_lockout(the_trace_address);
   831.             ensure_that_the_NEST_holds_an_operand;
   832.             the_trace_operand := pop;
   833.             store_word(the_trace_operand, the_trace_address);
   834.             the_CPU_delta := the_CPU_delta + 7;
   835.
   836.          when TO_MkMqQ =>
   837.             the_trace_address := virtual_word_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   838.             check_address_and_lockout(the_trace_address);
   839.             ensure_that_the_NEST_holds_an_operand;
   840.             the_trace_operand := pop;
   841.             store_word(the_trace_operand, the_trace_address);
   842.             auto_increment;
   843.             the_CPU_delta := the_CPU_delta + 8;
   844.
   845.          when TO_MkMqH =>
   846.             the_trace_address := virtual_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   847.             check_address_and_lockout(the_trace_address);
   848.             ensure_that_the_NEST_holds_an_operand;
   849.             the_trace_operand := pop;
   850.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   851.             the_CPU_delta := the_CPU_delta + 7;
   852.
   853.          when TO_MkMqQH =>
   854.             the_trace_address := virtual_halfword_address(the_Q_store(INS.Qk).M, the_Q_store(INS.Qq).M);
   855.             check_address_and_lockout(the_trace_address);
   856.             ensure_that_the_NEST_holds_an_operand;
   857.             the_trace_operand := pop;
   858.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   859.             auto_increment;
   860.             the_CPU_delta := the_CPU_delta + 8;
   861.
   862.          when TO_MkMqN =>
   863.             the_trace_address := virtual_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   864.             check_address_and_lockout(the_trace_address);
   865.             ensure_that_the_NEST_holds_an_operand;
   866.             the_trace_operand := pop;
   867.             store_word(the_trace_operand, the_trace_address);
   868.             the_CPU_delta := the_CPU_delta + 7;
   869.
   870.          when TO_MkMqQN =>
   871.             the_trace_address := virtual_word_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   872.             check_address_and_lockout(the_trace_address);
   873.             ensure_that_the_NEST_holds_an_operand;
   874.             the_trace_operand := pop;
   875.             store_word(the_trace_operand, the_trace_address);
   876.             auto_increment;
   877.             the_CPU_delta := the_CPU_delta + 8;
   878.
   879.          when TO_MkMqHN =>
   880.             the_trace_address := virtual_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   881.             check_address_and_lockout(the_trace_address);
   882.             ensure_that_the_NEST_holds_an_operand;
   883.             the_trace_operand := pop;
   884.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   885.             the_CPU_delta := the_CPU_delta + 7;
   886.
   887.          when TO_MkMqQHN =>
   888.             the_trace_address := virtual_halfword_address(the_Q_store(INS.Qk).M+1, the_Q_store(INS.Qq).M);
   889.             check_address_and_lockout(the_trace_address);
   890.             ensure_that_the_NEST_holds_an_operand;
   891.             the_trace_operand := pop;
   892.             store_halfword(the_trace_operand, the_trace_address, the_Q_store(INS.Qq).M mod 2);
   893.             auto_increment;
   894.             the_CPU_delta := the_CPU_delta + 8;
   895.
   896.          when M_PLUS_Iq =>
   897.             the_CPU_delta := the_CPU_delta + 4;
   898.             the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M + the_Q_store(INS.Qq).I;
   899.
   900.          when M_MINUS_Iq =>
   901.             the_CPU_delta := the_CPU_delta + 5;
   902.             the_Q_store(INS.Qq).M := the_Q_store(INS.Qq).M - the_Q_store(INS.Qq).I;
   903.
   904.          when NCq =>
   905.             the_CPU_delta := the_CPU_delta + 5;
   906.             the_Q_store(INS.Qq).C := - the_Q_store(INS.Qq).C;
   907.
   908.          when DCq =>
   909.             the_CPU_delta := the_CPU_delta + 3;
   910.             if INS.Qq /= 0 then
   911.                the_Q_store(INS.Qq).C := the_Q_store(INS.Qq).C - 1;
   912.             end if;
   913.
   914.          when POS1_TO_Iq =>
   915.             the_CPU_delta := the_CPU_delta + 3;
   916.             if INS.Qq /= 0 then
   917.                the_Q_store(INS.Qq).I := + 1;
   918.             end if;
   919.
   920.          when NEG1_TO_Iq =>
   921.             the_CPU_delta := the_CPU_delta + 3;
   922.             if INS.Qq /= 0 then
   923.                the_Q_store(INS.Qq).I := 8#177777#;  -- i.e. -1
   924.             end if;
   925.
   926.          when POS2_TO_Iq =>
   927.             the_CPU_delta := the_CPU_delta + 3;
   928.             if INS.Qq /= 0 then
   929.                the_Q_store(INS.Qq).I := + 2;
   930.             end if;
   931.
   932.          when NEG2_TO_Iq =>
   933.             the_CPU_delta := the_CPU_delta + 3;
   934.             if INS.Qq /= 0 then
   935.                the_Q_store(INS.Qq).I := 8#177776#;  -- i.e. -2
   936.             end if;
   937.
   938.          when CqTOQk =>
   939.             the_CPU_delta := the_CPU_delta + 4;
   940.             if INS.Qk /= 0 then
   941.                the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   942.             end if;
   943.
   944.          when IqTOQk =>
   945.             the_CPU_delta := the_CPU_delta + 4;
   946.             if INS.Qk /= 0 then
   947.                the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   948.             end if;
   949.
   950.          when MqTOQk =>
   951.             the_CPU_delta := the_CPU_delta + 4;
   952.             if INS.Qk /= 0 then
   953.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   954.             end if;
   955.
   956.          when QqTOQk =>
   957.             the_CPU_delta := the_CPU_delta + 4;
   958.             if INS.Qk /= 0 then
   959.                the_Q_store(INS.Qk) := the_Q_store(INS.Qq);
   960.             end if;
   961.
   962.          when CIqTOQk =>
   963.            the_CPU_delta := the_CPU_delta + 4;
   964.            if INS.Qk /= 0 then
   965.               the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   966.               the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   967.            end if;
   968.
   969.          when IMqTOQk =>
   970.             the_CPU_delta := the_CPU_delta + 4;
   971.             if INS.Qk /= 0 then
   972.                the_Q_store(INS.Qk).I := the_Q_store(INS.Qq).I;
   973.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   974.             end if;
   975.
   976.          when CMqTOQk =>
   977.             the_CPU_delta := the_CPU_delta + 4;
   978.             if INS.Qk /= 0 then
   979.                the_Q_store(INS.Qk).C := the_Q_store(INS.Qq).C;
   980.                the_Q_store(INS.Qk).M := the_Q_store(INS.Qq).M;
   981.             end if;
   982.
   983.          when QCIMq =>
   984.             ensure_that_the_NEST_has_room_for_a_result;
   985.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- Qq
   986.                push(as_word(the_Q_store(INS.Qq)));
   987.                the_CPU_delta := the_CPU_delta + 4;
   988.             elsif (INS.Qk and M_part_choice) /= 0 then       -- Mq
   989.                push(sign_extended(the_Q_store(INS.Qq).M));
   990.                the_CPU_delta := the_CPU_delta + 4;
   991.             elsif (INS.Qk and C_part_choice) /= 0 then       -- Cq
   992.                push(sign_extended(the_Q_store(INS.Qq).C));
   993.                the_CPU_delta := the_CPU_delta + 5;
   994.             elsif (INS.Qk and I_part_choice) /= 0 then       -- Iq
   995.                push(sign_extended(the_Q_store(INS.Qq).I));
   996.                the_CPU_delta := the_CPU_delta + 6;
   997.             else
   998.                trap_illegal_instruction;
   999.             end if;
  1000.
  1001.          when TO_RCIMq =>
  1002.             ensure_that_the_NEST_holds_an_operand;
  1003.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- =Qq
  1004.                the_Q_store(INS.Qq) := as_Q(pop);
  1005.                the_CPU_delta := the_CPU_delta + 2;
  1006.             elsif (INS.Qk and M_part_choice) /= 0 then       -- =[R]Mq
  1007.                the_Q_store(INS.Qq).M := KDF9.Q_part(pop and Q_part_mask);
  1008.                if (INS.Qk and reset_choice) /= 0 then
  1009.                   the_Q_store(INS.Qq).C := 0;
  1010.                   the_Q_store(INS.Qq).I := 1;
  1011.                   the_CPU_delta := the_CPU_delta + 3;
  1012.                else
  1013.                   the_CPU_delta := the_CPU_delta + 2;
  1014.                end if;
  1015.             elsif (INS.Qk and C_part_choice) /= 0 then       -- =[R]Cq
  1016.                the_Q_store(INS.Qq).C := KDF9.Q_part(pop and Q_part_mask);
  1017.                if (INS.Qk and reset_choice) /= 0 then
  1018.                   the_Q_store(INS.Qq).I := 1;
  1019.                   the_Q_store(INS.Qq).M := 0;
  1020.                   the_CPU_delta := the_CPU_delta + 3;
  1021.                else
  1022.                   the_CPU_delta := the_CPU_delta + 2;
  1023.                end if;
  1024.             elsif (INS.Qk and I_part_choice) /= 0 then       -- =[R]Iq
  1025.                the_Q_store(INS.Qq).I := KDF9.Q_part(pop and Q_part_mask);
  1026.                if (INS.Qk and reset_choice) /= 0 then
  1027.                   the_Q_store(INS.Qq).C := 0;
  1028.                   the_Q_store(INS.Qq).M := 0;
  1029.                   the_CPU_delta := the_CPU_delta + 3;
  1030.                else
  1031.                   the_CPU_delta := the_CPU_delta + 2;
  1032.                end if;
  1033.             else
  1034.                trap_illegal_instruction;
  1035.             end if;
  1036.             ensure_that_Q0_contains_zero(suspect => INS.Qq);
  1037.
  1038.          when ADD_TO_QCIMq =>
  1039.             ensure_that_the_NEST_has_room_for_a_result;
  1040.             ensure_that_the_NEST_holds_an_operand;
  1041.
  1042.             -- Because the following does not push the Q operand on to the NEST,
  1043.             --   it will not leave an authentic bit pattern in the NEST core stack,
  1044.             --      in the event of a subsequent NOUV.
  1045.             -- I take this to be of no importance.
  1046.
  1047.             if (INS.Qk and all_Q_choice) = all_Q_choice then -- =+Qq
  1048.                the_Q_store(INS.Qq) := as_Q(as_word(the_Q_store(INS.Qq)) + pop);
  1049.                the_CPU_delta := the_CPU_delta + 5;
  1050.             elsif (INS.Qk and M_part_choice) /= 0 then       -- =+Mq
  1051.                the_Q_store(INS.Qq).M := KDF9.Q_part(Q_part_mask and
  1052.                                              (sign_extended(the_Q_store(INS.Qq).M) + pop));
  1053.                the_CPU_delta := the_CPU_delta + 5;
  1054.             elsif (INS.Qk and C_part_choice) /= 0 then       -- =+Cq
  1055.                the_Q_store(INS.Qq).C := KDF9.Q_part(Q_part_mask and
  1056.                                              (sign_extended(the_Q_store(INS.Qq).C) + pop));
  1057.                the_CPU_delta := the_CPU_delta + 6;
  1058.             elsif (INS.Qk and I_part_choice) /= 0 then       -- =+Iq
  1059.                the_Q_store(INS.Qq).I := KDF9.Q_part(Q_part_mask and
  1060.                                              (sign_extended(the_Q_store(INS.Qq).I) + pop));
  1061.                the_CPU_delta := the_CPU_delta + 7;
  1062.             else
  1063.                trap_illegal_instruction;
  1064.             end if;
  1065.             ensure_that_Q0_contains_zero(suspect => INS.Qq);
  1066.
  1067.          when SHA =>
  1068.             A := read_top;
  1069.             write_top(KDF9.word'(shift_arithmetic(A, shift_count)));
  1070.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1071.
  1072.          when SHAD =>
  1073.             AB := read_top;
  1074.             write_top(KDF9.pair'(shift_arithmetic(AB, shift_count)));
  1075.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1076.
  1077.          when MACC =>
  1078.             ensure_that_the_NEST_holds(at_least => 4);
  1079.             AB := pop;
  1080.             AB := AB.msw * AB.lsw;
  1081.             CD := read_top;
  1082.             write_top(CD + shift_arithmetic(AB, shift_count));
  1083.             the_CPU_delta := the_CPU_delta + 15 + shift_time(Natural(abs shift_count));
  1084.
  1085.          when SHL =>
  1086.             write_top(KDF9.word'(shift_logical(read_top, shift_count)));
  1087.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1088.
  1089.          when SHLD =>
  1090.             write_top(KDF9.pair'(shift_logical(read_top, shift_count)));
  1091.             the_CPU_delta := the_CPU_delta + 2 + shift_time(Natural(abs shift_count));
  1092.
  1093.          when SHC =>
  1094.             write_top(shift_circular(read_top, shift_count));
  1095.             the_CPU_delta := the_CPU_delta + 3 + shift_time(Natural(abs shift_count));
  1096.
  1097.          when TO_Kq =>
  1098.             fail_in_problem_program_state;
  1099.             case INS.Qq is
  1100.                when K0 =>
  1101.                   if read_top /= KDF9.word'(all_zero_bits) then
  1102.                      for w in all_zero_bits .. read_top mod 8 loop
  1103.                         POSIX.output_line("BLEEP!");
  1104.                      end loop;
  1105.                      delay 10.0;
  1106.                   end if;
  1107.                when K1 =>
  1108.                   set_K1_register(read_top);
  1109.                when K2 =>
  1110.                   set_K2_register(read_top);
  1111.                when K3 =>
  1112.                   set_K3_register(read_top);
  1113.                when others =>
  1114.                   trap_illegal_instruction;
  1115.             end case;
  1116.             the_CPU_delta := the_CPU_delta + 3;
  1117.
  1118.          when Kk =>
  1119.             fail_in_problem_program_state;
  1120.             ensure_that_the_NEST_has_room_for_a_result;
  1121.             case INS.Qk is
  1122.                when K4 =>
  1123.                   push(get_K4_operand);
  1124.                   the_RFIR := (others => False);
  1125.                when K5 =>
  1126.                   push(get_K5_operand);
  1127.                when K7 =>
  1128.                   push(get_K7_operand);
  1129.                when others =>
  1130.                   trap_illegal_instruction;
  1131.             end case;
  1132.             the_CPU_delta := the_CPU_delta + 3;
  1133.
  1134.          when LINK =>
  1135.             if the_CPU_state = Director_state and the_SJNS_depth = 0 then -- clear out JB
  1136.                push(KDF9.word'(all_zero_bits));
  1137.                the_SJNS_depth := 0 - 1;
  1138.             else
  1139.                ensure_that_the_NEST_has_room_for_a_result;
  1140.                ensure_that_the_SJNS_is_not_empty;
  1141.                push(as_word(KDF9.SJNS_link(KDF9.syllable_address'(pop))));
  1142.             end if;
  1143.             the_CPU_delta := the_CPU_delta + 4;
  1144.
  1145.          when TO_LINK =>
  1146.             ensure_that_the_SJNS_is_not_full;
  1147.             ensure_that_the_NEST_holds_an_operand;
  1148.             push(KDF9.syllable_address(as_link(pop)));
  1149.             the_CPU_delta := the_CPU_delta + 3;
  1150.
  1151.          when others =>
  1152.             do_an_IO_order;
  1153.
  1154.       end case;
  1155.    end do_a_two_syllable_order;
  1156.
  1157.    procedure do_a_jump_order is
  1158.       RA        : KDF9.syllable_address;
  1159.       A         : KDF9.word;
  1160.    begin
  1161.       fetching_normally := True;
  1162.
  1163.       case INS.compressed_opcode is
  1164.
  1165.          when Jr =>
  1166.             set_NIA_to_the_INS_target_address;
  1167.             the_CPU_delta := the_CPU_delta + 8;
  1168.
  1169.          when JSr =>
  1170.             ensure_that_the_SJNS_is_not_full;
  1171.             push(CIA);
  1172.             set_NIA_to_the_INS_target_address;
  1173.             the_CPU_delta := the_CPU_delta + 11;
  1174.
  1175.          when JrEQ =>
  1176.             ensure_that_the_NEST_holds_2_operands;
  1177.             A := pop;
  1178.             if A = read_top then
  1179.                set_NIA_to_the_INS_target_address;
  1180.                the_CPU_delta := the_CPU_delta + 12;
  1181.             else
  1182.                the_CPU_delta := the_CPU_delta + 5;
  1183.             end if;
  1184.
  1185.          when JrNE =>
  1186.             ensure_that_the_NEST_holds_2_operands;
  1187.             A := pop;
  1188.             if A /= read_top then
  1189.                set_NIA_to_the_INS_target_address;
  1190.                the_CPU_delta := the_CPU_delta + 12;
  1191.             else
  1192.                the_CPU_delta := the_CPU_delta + 5;
  1193.             end if;
  1194.
  1195.          when JrGTZ =>
  1196.             ensure_that_the_NEST_holds_an_operand;
  1197.             if resign(pop) > 0 then
  1198.                set_NIA_to_the_INS_target_address;
  1199.                the_CPU_delta := the_CPU_delta + 11;
  1200.             else
  1201.                the_CPU_delta := the_CPU_delta + 4;
  1202.             end if;
  1203.
  1204.          when JrLTZ =>
  1205.             ensure_that_the_NEST_holds_an_operand;
  1206.             A := pop;
  1207.             if resign(A) < 0 then
  1208.                set_NIA_to_the_INS_target_address;
  1209.                the_CPU_delta := the_CPU_delta + 11;
  1210.             else
  1211.                the_CPU_delta := the_CPU_delta + 4;
  1212.             end if;
  1213.
  1214.          when JrEQZ =>
  1215.             ensure_that_the_NEST_holds_an_operand;
  1216.              if pop = KDF9.word'(all_zero_bits) then
  1217.                set_NIA_to_the_INS_target_address;
  1218.                the_CPU_delta := the_CPU_delta + 11;
  1219.             else
  1220.                the_CPU_delta := the_CPU_delta + 4;
  1221.             end if;
  1222.
  1223.          when JrLEZ =>
  1224.             ensure_that_the_NEST_holds_an_operand;
  1225.             if resign(pop) <= 0 then
  1226.                set_NIA_to_the_INS_target_address;
  1227.                the_CPU_delta := the_CPU_delta + 11;
  1228.             else
  1229.                the_CPU_delta := the_CPU_delta + 4;
  1230.             end if;
  1231.
  1232.          when JrGEZ =>
  1233.             ensure_that_the_NEST_holds_an_operand;
  1234.             if resign(pop) >= 0 then
  1235.                set_NIA_to_the_INS_target_address;
  1236.                the_CPU_delta := the_CPU_delta + 11;
  1237.             else
  1238.                the_CPU_delta := the_CPU_delta + 4;
  1239.             end if;
  1240.
  1241.          when JrNEZ =>
  1242.             ensure_that_the_NEST_holds_an_operand;
  1243.             if pop /= KDF9.word'(all_zero_bits) then
  1244.                set_NIA_to_the_INS_target_address;
  1245.                the_CPU_delta := the_CPU_delta + 11;
  1246.             else
  1247.                the_CPU_delta := the_CPU_delta + 4;
  1248.             end if;
  1249.
  1250.          when JrV =>
  1251.             if the_V_bit_is_set then
  1252.                the_V_bit_is_set := False;
  1253.                set_NIA_to_the_INS_target_address;
  1254.                the_CPU_delta := the_CPU_delta + 10;
  1255.             else
  1256.                the_CPU_delta := the_CPU_delta + 3;
  1257.             end if;
  1258.
  1259.          when JrNV =>
  1260.             if the_V_bit_is_set then
  1261.                the_V_bit_is_set := False;
  1262.                the_CPU_delta := the_CPU_delta + 3;
  1263.             else
  1264.                set_NIA_to_the_INS_target_address;
  1265.                the_CPU_delta := the_CPU_delta + 10;
  1266.             end if;
  1267.
  1268.          when JrEN =>
  1269.             the_trace_operand := KDF9.word(the_NEST_depth);
  1270.             if the_NEST_depth = 0 then
  1271.                set_NIA_to_the_INS_target_address;
  1272.                the_CPU_delta := the_CPU_delta + 10;
  1273.             else
  1274.                the_CPU_delta := the_CPU_delta + 3;
  1275.             end if;
  1276.
  1277.          when JrNEN =>
  1278.             the_trace_operand := KDF9.word(the_NEST_depth);
  1279.             if the_NEST_depth /= 0 then
  1280.                set_NIA_to_the_INS_target_address;
  1281.                the_CPU_delta := the_CPU_delta + 10;
  1282.             else
  1283.                the_CPU_delta := the_CPU_delta + 3;
  1284.             end if;
  1285.
  1286.          when JrEJ =>
  1287.             the_trace_operand := KDF9.word(the_SJNS_depth);
  1288.             if the_SJNS_depth = 0 then
  1289.                set_NIA_to_the_INS_target_address;
  1290.                the_CPU_delta := the_CPU_delta + 10;
  1291.             end if;
  1292.             the_CPU_delta := the_CPU_delta + 3;
  1293.
  1294.          when JrNEJ =>
  1295.             the_trace_operand := KDF9.word(the_SJNS_depth);
  1296.             if the_SJNS_depth /= 0 then
  1297.                set_NIA_to_the_INS_target_address;
  1298.                the_CPU_delta := the_CPU_delta + 10;
  1299.             end if;
  1300.             the_CPU_delta := the_CPU_delta + 3;
  1301.
  1302.          when JrTR =>
  1303.             if the_T_bit_is_set then
  1304.                the_T_bit_is_set := False;
  1305.                set_NIA_to_the_INS_target_address;
  1306.                the_CPU_delta := the_CPU_delta + 10;
  1307.             else
  1308.                the_CPU_delta := the_CPU_delta + 3;
  1309.             end if;
  1310.
  1311.          when JrNTR =>
  1312.             if the_T_bit_is_set then
  1313.                the_T_bit_is_set := False;
  1314.                the_CPU_delta := the_CPU_delta + 3;
  1315.             else
  1316.                set_NIA_to_the_INS_target_address;
  1317.                the_CPU_delta := the_CPU_delta + 10;
  1318.             end if;
  1319.
  1320.          when EXIT_n =>
  1321.             ensure_that_the_SJNS_is_not_empty;
  1322.             RA := pop;
  1323.             if INS.target.syllable_index = 3 then  -- c.f. decode_a_jump_order.
  1324.                increment_by_3(RA);
  1325.             end if;
  1326.             RA.code_address := RA.code_address+INS.target.code_address;
  1327.             set_NIA_to(RA);
  1328.             the_CPU_delta := the_CPU_delta + 12 + KDF9.us(INS.target.syllable_index mod 2);
  1329.
  1330.          when EXITD =>
  1331.             fail_in_problem_program_state;
  1332.             if the_SJNS_depth = 0 then
  1333.                -- This indicates a serious failure in Director; best to abandon it at once.
  1334.                trap_illegal_instruction("empty SJNS in Director");
  1335.             end if;
  1336.             RA := pop;
  1337.             the_CPU_delta := the_CPU_delta + 11;
  1338.             return_from_Director_to(RA);
  1339.
  1340.          when JrCqZ =>
  1341.             if the_Q_store(INS.Qq).C = 0 then
  1342.                set_NIA_to_the_INS_target_address;
  1343.                the_CPU_delta := the_CPU_delta + 11;
  1344.             else
  1345.                the_CPU_delta := the_CPU_delta + 4;
  1346.             end if;
  1347.
  1348.          when JrCqNZ =>
  1349.             if the_Q_store(INS.Qq).C /= 0 then
  1350.                set_NIA_to_the_INS_target_address;
  1351.                the_CPU_delta := the_CPU_delta + 11;
  1352.             else
  1353.                the_CPU_delta := the_CPU_delta + 4;
  1354.             end if;
  1355.
  1356.          when OS_OUT =>
  1357.             the_CPU_delta := the_CPU_delta + 13;
  1358.             ensure_that_the_SJNS_is_not_full;
  1359.             A := (if the_NEST_depth = 0 then 0 else read_top);
  1360.             if the_execution_mode = boot_mode then
  1361.                effect_interrupt(caused_by_OUT, A'Image);
  1362.                -- We get here only in Director state, when the OUT does not interrupt.
  1363.                -- Arguably, this should be notified as an error.
  1364.                return; -- OUT has the effect of a no-op in Director state.
  1365.             end if;
  1366.             -- Emulate a subset of the appropriate Director's API.
  1367.             if A < 100 then
  1368.                do_a_TSD_OUT(OUT_number => A);
  1369.             elsif A < 200 then
  1370.                do_an_EGDON_OUT(OUT_number => A);
  1371.             else
  1372.                trap_failing_OUT(A, "is unknown, or not yet implemented");
  1373.             end if;
  1374.
  1375.          when others =>
  1376.             trap_illegal_instruction;
  1377.
  1378.       end case;
  1379.    end do_a_jump_order;
  1380.
  1381.    procedure do_a_data_access_order is
  1382.    begin
  1383.       case INS.compressed_opcode is
  1384.
  1385.          when EaMq =>
  1386.             the_trace_address := virtual_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1387.             check_address_and_lockout(the_trace_address);
  1388.             ensure_that_the_NEST_has_room_for_a_result;
  1389.             the_trace_operand := fetch_word(the_trace_address);
  1390.             push(the_trace_operand);
  1391.             the_CPU_delta := the_CPU_delta + 6;
  1392.
  1393.          when TO_EaMq =>
  1394.             the_trace_address := virtual_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1395.             check_address_and_lockout(the_trace_address);
  1396.             ensure_that_the_NEST_holds_an_operand;
  1397.             the_trace_operand := pop;
  1398.             store_word(the_trace_operand, the_trace_address);
  1399.             the_CPU_delta := the_CPU_delta + 6;
  1400.
  1401.          when EaMqQ =>
  1402.             the_trace_address := virtual_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1403.             check_address_and_lockout(the_trace_address);
  1404.             ensure_that_the_NEST_has_room_for_a_result;
  1405.             the_trace_operand := fetch_word(the_trace_address);
  1406.             push(the_trace_operand);
  1407.             auto_increment;
  1408.             the_CPU_delta := the_CPU_delta + 7;
  1409.
  1410.          when TO_EaMqQ =>
  1411.             the_trace_address := virtual_word_address(the_Q_store(INS.Qq).M, INS.operand);
  1412.             check_address_and_lockout(the_trace_address);
  1413.             ensure_that_the_NEST_holds_an_operand;
  1414.             the_trace_operand := pop;
  1415.             store_word(the_trace_operand, the_trace_address);
  1416.             auto_increment;
  1417.             the_CPU_delta := the_CPU_delta + 7;
  1418.
  1419.          when SET =>
  1420.             ensure_that_the_NEST_has_room_for_a_result;
  1421.             the_trace_operand := sign_extended(INS.operand);
  1422.             push(the_trace_operand);
  1423.             the_CPU_delta := the_CPU_delta + 4;
  1424.
  1425.          when others =>
  1426.             trap_illegal_instruction;
  1427.
  1428.       end case;
  1429.    end do_a_data_access_order;
  1430.
  1431.    procedure update_the_virtual_clocks
  1432.       with Inline;
  1433.
  1434.    procedure update_the_virtual_clocks is
  1435.    begin
  1436.       the_CPU_time := the_CPU_time + the_CPU_delta;
  1437.       the_elapsed_time := the_elapsed_time + the_CPU_delta;
  1438.       if the_CPU_time > the_elapsed_time then
  1439.          the_elapsed_time := the_CPU_time;
  1440.       end if;
  1441.       ICR := ICR + 1;
  1442.    end update_the_virtual_clocks;
  1443.
  1444.    procedure do_a_fast_time_slice is
  1445.    begin
  1446.
  1447.          if break_in.has_been_requested then
  1448.             break_in.handler;
  1449.          end if;
  1450.
  1451.       for i in 1 .. time_slice loop
  1452.
  1453.          the_CPU_delta := 0;
  1454.
  1455.          process_syllable_0_of_INS;
  1456.          case INS.kind is
  1457.             when one_syllable_order =>
  1458.                do_a_one_syllable_order;
  1459.             when two_syllable_order =>
  1460.                process_syllable_1_of_INS;
  1461.                do_a_two_syllable_order;
  1462.             when normal_jump_order =>
  1463.                process_syllables_1_and_2_of_a_jump_order;
  1464.                do_a_jump_order;
  1465.             when data_access_order =>
  1466.                process_syllables_1_and_2_of_a_data_access_order;
  1467.                do_a_data_access_order;
  1468.          end case;
  1469.
  1470.          update_the_virtual_clocks;
  1471.          check_for_a_clock_interrupt;
  1472.          if the_elapsed_time > the_next_interrupt_time then
  1473.             act_on_pending_interrupts;
  1474.          end if;
  1475.
  1476.       end loop;
  1477.
  1478.    exception
  1479.
  1480.       when program_exit =>
  1481.          complete_all_extant_transfers;
  1482.          update_the_virtual_clocks;
  1483.          synchronize_the_real_and_virtual_times;
  1484.          raise;
  1485.
  1486.       when OUT_2_restart =>
  1487.          complete_all_extant_transfers;
  1488.          update_the_virtual_clocks;
  1489.          synchronize_the_real_and_virtual_times;
  1490.          complete_TSD_OUT_2;
  1491.
  1492.    end do_a_fast_time_slice;
  1493.
  1494.    procedure do_a_traced_instruction_cycle is
  1495.       use tracing.order_flags;
  1496.
  1497.       procedure finalize_the_traced_instruction_execution is
  1498.       begin
  1499.          update_the_virtual_clocks;
  1500.          synchronize_the_real_and_virtual_times;
  1501.
  1502.          if ICR in low_count .. high_count            and then
  1503.                NIA_word_number in low_bound .. high_bound then
  1504.             take_note_of(the_trace_operand);
  1505.             if the_signature_is_enabled then
  1506.                update_the_digital_signature;
  1507.             end if;
  1508.             if histogramming_is_enabled then
  1509.                add_INS_to_the_histogram;
  1510.                add_CIA_to_the_profile;
  1511.             end if;
  1512.             if the_external_trace_is_enabled then
  1513.                log_to_external_trace;
  1514.             end if;
  1515.             case INS.kind is
  1516.                when two_syllable_order =>
  1517.                   act_on_any_two_syllable_order_watchpoints;
  1518.                when data_access_order =>
  1519.                   act_on_any_data_access_order_watchpoints;
  1520.                when others =>
  1521.                   null;
  1522.             end case;
  1523.          end if;
  1524.       end finalize_the_traced_instruction_execution;
  1525.
  1526.    begin  -- do_a_traced_instruction_cycle
  1527.
  1528.       if break_in.has_been_requested then
  1529.          break_in.handler;
  1530.       end if;
  1531.
  1532.       the_trace_operand := 0;
  1533.       the_trace_address := 0;
  1534.       the_CPU_delta := 0;
  1535.
  1536.       process_syllable_0_of_INS;
  1537.
  1538.       case INS.kind is
  1539.          when one_syllable_order =>
  1540.             preview_a_one_syllable_order;
  1541.                do_a_one_syllable_order;
  1542.             look_back_at_a_one_syllable_order;
  1543.          when two_syllable_order =>
  1544.             process_syllable_1_of_INS;
  1545.             preview_a_two_syllable_order;
  1546.                do_a_two_syllable_order;
  1547.             look_back_at_a_two_syllable_order;
  1548.          when normal_jump_order =>
  1549.             process_syllables_1_and_2_of_a_jump_order;
  1550.             preview_a_jump_order;
  1551.                do_a_jump_order;
  1552.             look_back_at_a_jump_order;
  1553.          when data_access_order =>
  1554.             process_syllables_1_and_2_of_a_data_access_order;
  1555.             preview_a_data_access_order;
  1556.                do_a_data_access_order;
  1557.             look_back_at_a_data_access_order;
  1558.       end case;
  1559.
  1560.       finalize_the_traced_instruction_execution;
  1561.
  1562.       if ICR >= time_limit then
  1563.          raise time_expired;
  1564.       end if;
  1565.
  1566.       if (breakpoints/NIA_word_number        and then
  1567.              ICR in low_count .. high_count)  or else
  1568.                 the_diagnostic_mode = pause_mode then
  1569.          handle_breakpoint;
  1570.       end if;
  1571.
  1572.       check_for_a_clock_interrupt;
  1573.       if the_elapsed_time > the_next_interrupt_time then
  1574.          act_on_pending_interrupts;
  1575.       end if;
  1576.
  1577.    exception
  1578.
  1579.       when program_exit =>
  1580.          case INS.kind is
  1581.             when one_syllable_order =>
  1582.                look_back_at_a_one_syllable_order;
  1583.             when two_syllable_order =>
  1584.                look_back_at_a_two_syllable_order;
  1585.             when normal_jump_order =>
  1586.                look_back_at_a_jump_order;
  1587.             when data_access_order =>
  1588.                look_back_at_a_data_access_order;
  1589.          end case;
  1590.          complete_all_extant_transfers;
  1591.          finalize_the_traced_instruction_execution;
  1592.          raise;
  1593.
  1594.       when OUT_2_restart =>
  1595.          complete_all_extant_transfers;
  1596.          finalize_the_traced_instruction_execution;
  1597.          complete_TSD_OUT_2;
  1598.
  1599.    end do_a_traced_instruction_cycle;
  1600.
  1601. end KDF9.microcode;

Compiling: ../Source/kdf9-microcode.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:00

     1. -- KDF9 ISP emulation - CPU microcode routines.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.microcode is
    18.
    19.    procedure do_a_fast_time_slice;
    20.
    21.    procedure do_a_traced_instruction_cycle;
    22.
    23. end KDF9.microcode;

 1601 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-absent.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:01

     1. -- Handle attempted usage of a buffer with No Device attached.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.absent is
    18.
    19.    procedure disavow (the_device  : in out absent.device;
    20.                       Q_operand   : in KDF9.Q_register;
    21.                       set_offline : in Boolean) is
    22.       pragma Unreferenced(Q_operand);
    23.       pragma Unreferenced(set_offline);
    24.    begin
    25.       trap_operator_error("there is no device on buffer #" & oct_of(the_device.number, 2));
    26.    end disavow;
    27.
    28.    overriding
    29.    procedure PIA (the_device  : in out absent.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean) is
    32.    begin disavow(the_device, Q_operand, set_offline); end PIA;
    33.
    34.    overriding
    35.    procedure PIB (the_device  : in out absent.device;
    36.                   Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean) is
    38.    begin disavow(the_device, Q_operand, set_offline); end PIB;
    39.
    40.    overriding
    41.    procedure PIC (the_device  : in out absent.device;
    42.                   Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean) is
    44.    begin disavow(the_device, Q_operand, set_offline); end PIC;
    45.
    46.    overriding
    47.    procedure PID (the_device  : in out absent.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean) is
    50.    begin disavow(the_device, Q_operand, set_offline); end PID;
    51.
    52.    overriding
    53.    procedure PIE (the_device  : in out absent.device;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean) is
    56.    begin disavow(the_device, Q_operand, set_offline); end PIE;
    57.
    58.    overriding
    59.    procedure PIF (the_device  : in out absent.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean) is
    62.    begin disavow(the_device, Q_operand, set_offline); end PIF;
    63.
    64.    overriding
    65.    procedure PIG (the_device  : in out absent.device;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean) is
    68.    begin disavow(the_device, Q_operand, set_offline); end PIG;
    69.
    70.    overriding
    71.    procedure PIH (the_device  : in out absent.device;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean) is
    74.    begin disavow(the_device, Q_operand, set_offline); end PIH;
    75.
    76.    overriding
    77.    procedure PMA (the_device  : in out absent.device;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean) is
    80.    begin disavow(the_device, Q_operand, set_offline); end PMA;
    81.
    82.    overriding
    83.    procedure PMB (the_device  : in out absent.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean) is
    86.    begin disavow(the_device, Q_operand, set_offline); end PMB;
    87.
    88.    overriding
    89.    procedure PMC (the_device  : in out absent.device;
    90.                   Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean) is
    92.    begin disavow(the_device, Q_operand, set_offline); end PMC;
    93.    overriding
    94.    procedure PMD (the_device  : in out absent.device;
    95.                   Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean) is
    97.    begin disavow(the_device, Q_operand, set_offline); end PMD;
    98.
    99.    overriding
   100.    procedure PME (the_device  : in out absent.device;
   101.                   Q_operand   : in KDF9.Q_register;
   102.                   set_offline : in Boolean) is
   103.    begin disavow(the_device, Q_operand, set_offline); end PME;
   104.
   105.    overriding
   106.    procedure PMF (the_device  : in out absent.device;
   107.                   Q_operand   : in KDF9.Q_register;
   108.                   set_offline : in Boolean) is
   109.    begin disavow(the_device, Q_operand, set_offline); end PMF;
   110.
   111.
   112.    overriding
   113.    procedure PMG (the_device  : in out absent.device;
   114.                   Q_operand   : in KDF9.Q_register;
   115.                   set_offline : in Boolean) is
   116.    begin disavow(the_device, Q_operand, set_offline); end PMG;
   117.
   118.    overriding
   119.    procedure PMK (the_device  : in out absent.device;
   120.                   Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean) is
   122.    begin disavow(the_device, Q_operand, set_offline); end PMK;
   123.
   124.    overriding
   125.    procedure PML (the_device  : in out absent.device;
   126.                   Q_operand   : in KDF9.Q_register;
   127.                   set_offline : in Boolean) is
   128.    begin disavow(the_device, Q_operand, set_offline); end PML;
   129.
   130.    overriding
   131.    procedure POA (the_device  : in out absent.device;
   132.                   Q_operand   : in KDF9.Q_register;
   133.                   set_offline : in Boolean) is
   134.    begin disavow(the_device, Q_operand, set_offline); end POA;
   135.
   136.    overriding
   137.    procedure POB (the_device  : in out absent.device;
   138.                   Q_operand   : in KDF9.Q_register;
   139.                   set_offline : in Boolean) is
   140.    begin disavow(the_device, Q_operand, set_offline); end POB;
   141.
   142.    overriding
   143.    procedure POC (the_device  : in out absent.device;
   144.                   Q_operand   : in KDF9.Q_register;
   145.                   set_offline : in Boolean) is
   146.    begin disavow(the_device, Q_operand, set_offline); end POC;
   147.
   148.    overriding
   149.    procedure POD (the_device  : in out absent.device;
   150.                   Q_operand   : in KDF9.Q_register;
   151.                   set_offline : in Boolean) is
   152.    begin disavow(the_device, Q_operand, set_offline); end POD;
   153.
   154.    overriding
   155.    procedure POE (the_device  : in out absent.device;
   156.                   Q_operand   : in KDF9.Q_register;
   157.                   set_offline : in Boolean) is
   158.    begin disavow(the_device, Q_operand, set_offline); end POE;
   159.
   160.    overriding
   161.    procedure POF (the_device  : in out absent.device;
   162.                   Q_operand   : in KDF9.Q_register;
   163.                   set_offline : in Boolean) is
   164.    begin disavow(the_device, Q_operand, set_offline); end POF;
   165.
   166.    overriding
   167.    procedure POG (the_device  : in out absent.device;
   168.                   Q_operand   : in KDF9.Q_register;
   169.                   set_offline : in Boolean) is
   170.    begin disavow(the_device, Q_operand, set_offline); end POG;
   171.
   172.    overriding
   173.    procedure POH (the_device  : in out absent.device;
   174.                   Q_operand   : in KDF9.Q_register;
   175.                   set_offline : in Boolean) is
   176.    begin disavow(the_device, Q_operand, set_offline); end POH;
   177.
   178.    overriding
   179.    procedure POK (the_device  : in out absent.device;
   180.                   Q_operand   : in KDF9.Q_register;
   181.                   set_offline : in Boolean) is
   182.    begin disavow(the_device, Q_operand, set_offline); end POK;
   183.
   184.    overriding
   185.    procedure POL (the_device  : in out absent.device;
   186.                   Q_operand   : in KDF9.Q_register;
   187.                   set_offline : in Boolean) is
   188.    begin disavow(the_device, Q_operand, set_offline); end POL;
   189.
   190.    overriding
   191.    procedure Initialize (the_device : in out absent.device) is
   192.    begin
   193.       install(the_device);
   194.    end Initialize;
   195.
   196.    type AD_access is access absent.device;
   197.    AD_list : array (IOC.unit_number range 0..14) of AD_access with Warnings => Off;
   198.
   199.     -- This cannot overflow, because there must be at least 2 non-AD buffers: FW0 and TR0.
   200.    unit : IOC.unit_number := 0;
   201.
   202.    procedure enable (b : in KDF9.buffer_number) is
   203.    begin
   204.       AD_list(unit) := new absent.device(number => b, unit => unit);
   205.        unit := unit + 1;
   206.    end enable;
   207.
   208. end IOC.absent;
   209.

Compiling: ../Source/ioc-absent.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:01

     1. -- Handle attempted usage of a buffer with No Device attached.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.absent is
    18.
    19.    type device is new IOC.device with null record;
    20.
    21.    -- All the operations of an absent device terminate the run.
    22.
    23.    overriding
    24.    procedure PIA (the_device  : in out absent.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    overriding
    29.    procedure PIB (the_device  : in out absent.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean);
    32.
    33.    overriding
    34.    procedure PIC (the_device  : in out absent.device;
    35.                   Q_operand   : in KDF9.Q_register;
    36.                   set_offline : in Boolean);
    37.
    38.    overriding
    39.    procedure PID (the_device  : in out absent.device;
    40.                   Q_operand   : in KDF9.Q_register;
    41.                   set_offline : in Boolean);
    42.
    43.    overriding
    44.    procedure PIE (the_device  : in out absent.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    overriding
    49.    procedure PIF (the_device  : in out absent.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    overriding
    54.    procedure PIG (the_device  : in out absent.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    overriding
    59.    procedure PIH (the_device  : in out absent.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    overriding
    64.    procedure PMA (the_device  : in out absent.device;
    65.                   Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    overriding
    69.    procedure PMB (the_device  : in out absent.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean);
    72.
    73.    overriding
    74.    procedure PMC (the_device  : in out absent.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.    overriding
    78.    procedure PMD (the_device  : in out absent.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean);
    81.
    82.    overriding
    83.    procedure PME (the_device  : in out absent.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    overriding
    88.    procedure PMF (the_device  : in out absent.device;
    89.                   Q_operand   : in KDF9.Q_register;
    90.                   set_offline : in Boolean);
    91.
    92.    overriding
    93.    procedure PMG (the_device  : in out absent.device;
    94.                   Q_operand   : in KDF9.Q_register;
    95.                   set_offline : in Boolean);
    96.
    97.    overriding
    98.    procedure PMK (the_device  : in out absent.device;
    99.                   Q_operand   : in KDF9.Q_register;
   100.                   set_offline : in Boolean);
   101.
   102.    overriding
   103.    procedure PML (the_device  : in out absent.device;
   104.                   Q_operand   : in KDF9.Q_register;
   105.                   set_offline : in Boolean);
   106.
   107.    overriding
   108.    procedure POA (the_device  : in out absent.device;
   109.                   Q_operand   : in KDF9.Q_register;
   110.                   set_offline : in Boolean);
   111.
   112.    overriding
   113.    procedure POB (the_device  : in out absent.device;
   114.                   Q_operand   : in KDF9.Q_register;
   115.                   set_offline : in Boolean);
   116.
   117.    overriding
   118.    procedure POC (the_device  : in out absent.device;
   119.                   Q_operand   : in KDF9.Q_register;
   120.                   set_offline : in Boolean);
   121.
   122.    overriding
   123.    procedure POD (the_device  : in out absent.device;
   124.                   Q_operand   : in KDF9.Q_register;
   125.                   set_offline : in Boolean);
   126.
   127.    overriding
   128.    procedure POE (the_device  : in out absent.device;
   129.                   Q_operand   : in KDF9.Q_register;
   130.                   set_offline : in Boolean);
   131.
   132.    overriding
   133.    procedure POF (the_device  : in out absent.device;
   134.                   Q_operand   : in KDF9.Q_register;
   135.                   set_offline : in Boolean);
   136.
   137.    overriding
   138.    procedure POG (the_device  : in out absent.device;
   139.                   Q_operand   : in KDF9.Q_register;
   140.                   set_offline : in Boolean);
   141.
   142.    overriding
   143.    procedure POH (the_device  : in out absent.device;
   144.                   Q_operand   : in KDF9.Q_register;
   145.                   set_offline : in Boolean);
   146.
   147.    overriding
   148.    procedure POK (the_device  : in out absent.device;
   149.                   Q_operand   : in KDF9.Q_register;
   150.                   set_offline : in Boolean);
   151.
   152.    overriding
   153.    procedure POL (the_device  : in out absent.device;
   154.                   Q_operand   : in KDF9.Q_register;
   155.                   set_offline : in Boolean);
   156.
   157.    -- Register the absence of a device in case of future attempted access to buffer b.
   158.    procedure enable (b : in KDF9.buffer_number);
   159.
   160. private
   161.
   162.    overriding
   163.    procedure Initialize (the_device : in out absent.device);
   164.
   165.    overriding
   166.    function is_open (the_device : absent.device)
   167.    return Boolean
   168.    is (False);
   169.
   170.    overriding
   171.    function kind (the_device : absent.device)
   172.    return IOC.device_kind
   173.    is (AD_kind);
   174.
   175.    overriding
   176.    function quantum (the_device : absent.device)
   177.    return KDF9.us
   178.    is (0);
   179.
   180.    overriding
   181.    procedure add_in_the_IO_CPU_time (the_device  : in absent.device;
   182.                                      bytes_moved : in KDF9.word)
   183.    is null;
   184.
   185. end IOC.absent;

 209 lines: No errors


Compiling: /home/parallels/emulation/Source/state_display.adb
Source file time stamp: 2022-09-06 21:59:32
Compiled at: 2022-09-15 15:08:00

     1. -- Provide the comprehensive machine-state display panel KDF9 never had.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Latin_1;
    18. with Ada.Exceptions;
    19. with Ada.Long_Float_Text_IO;
    20. --
    21. with KDF9.imaging;
    22. with disassembly;
    23. with disassembly.symbols;
    24. with exceptions;
    25. with generic_sets;
    26. with HCI;
    27. with IOC;
    28. with IOC.fast.DR;
    29. with IOC.fast.FD;
    30. with KDF9_char_sets;
    31. with KDF9.CPU;
    32. with KDF9.decoding;
    33. with KDF9.PHU_store;
    34. with KDF9.store;
    35. with logging.file;
    36. with settings;
    37. with string_editing;
    38. with tracing;
    39.
    40. with IOC.diagnostics;
    41.
    42. use  Ada.Characters.Latin_1;
    43. use  Ada.Exceptions;
    44. use  Ada.Long_Float_Text_IO;
    45. --
    46. use  KDF9.imaging;
    47. use  disassembly;
    48. use  disassembly.symbols;
    49. use  exceptions;
    50. use  HCI;
    51. use  IOC;
    52. use  IOC.fast.DR;
    53. use  IOC.fast.FD;
    54. use  KDF9_char_sets;
    55. use  KDF9.CPU;
    56. use  KDF9.decoding;
    57. use  KDF9.PHU_store;
    58. use  KDF9.store;
    59. use  logging.file;
    60. use  settings;
    61. use  tracing;
    62. use  string_editing;
    63.
    64. package body state_display is
    65.
    66.    procedure show_IM_parts (the_Q_register : in KDF9.Q_register;
    67.                             width          : in Positive := 8) is
    68.    begin
    69.       log(
    70.           "/"
    71.         & just_right("#" & oct_of(the_Q_register.I, width-2), width)
    72.         & "/"
    73.         & just_right("#" & oct_of(the_Q_register.M, width-2), width)
    74.          );
    75.    end show_IM_parts;
    76.
    77.    procedure show_IO_register (the_Q_register : in KDF9.Q_register;
    78.                                width          : in Positive := 8;
    79.                                for_DR,
    80.                                for_FD,
    81.                                for_FH,
    82.                                for_seek,
    83.                                for_OUT         : in Boolean  := False) is
    84.    begin
    85.       log('Q');
    86.       if for_FD then
    87.          log(just_right(as_FD_command(the_Q_register, for_FD and for_seek, for_FD and for_FH), width));
    88.       elsif for_DR then
    89.          log(just_right(as_DR_command(the_Q_register, for_OUT), width));
    90.       else
    91.          log(just_right("#" & oct_of(the_Q_register.C, width-2), width));
    92.       end if;
    93.       show_IM_parts(the_Q_register, width);
    94.    end show_IO_register;
    95.
    96.    procedure show_Q_register (the_Q_register : in KDF9.Q_register;
    97.                               width          : in Positive := 8) is
    98.    begin
    99.       log('Q' & just_right("#" & oct_of(the_Q_register.C, width-2), width));
   100.       show_IM_parts(the_Q_register, width);
   101.    end show_Q_register;
   102.
   103.    procedure show_Q_in_decimal (the_Q_register : in KDF9.Q_register;
   104.                                 width          : in Positive := 7) is
   105.    begin
   106.       log(
   107.           'Q'
   108.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.C)), width)
   109.         & "/"
   110.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.I)), width)
   111.         & "/"
   112.         & just_right(CPU.signed_Q_part'Image(resign(the_Q_register.M)), width)
   113.          );
   114.    end show_Q_in_decimal;
   115.
   116.    procedure show_in_syllables_form (the_word : in KDF9.word) is
   117.       word : KDF9.word := the_word;
   118.       syllable : KDF9.syllable;
   119.    begin
   120.       for b in 0 .. 5 loop
   121.          word := rotate_word_left(word, 8);
   122.          syllable := KDF9.syllable(word and 8#377#);
   123.          log("#" & just_right(oct_of(syllable), 3) & " ");
   124.       end loop;
   125.    end show_in_syllables_form;
   126.
   127.    procedure show_as_glyphs (the_word : in KDF9.word) is
   128.    begin
   129.       log('"' & glyphs_for(the_word) & '"');
   130.    end show_as_glyphs;
   131.
   132.    procedure log_padded_string (text  : in String;
   133.                                 width : in Positive := 1) is
   134.       pad_width   : constant Natural := Integer'Max (0, width - text'Length);
   135.       padding     : constant String (1 .. pad_width) := (others => ' ');
   136.       padded_text : constant String := padding & text;
   137.    begin
   138.       log(padded_text);
   139.    end log_padded_string;
   140.
   141.    procedure log_octal (number : in KDF9.field_of_16_bits;
   142.                         width  : in Positive := 1) is
   143.    begin
   144.       log_padded_string("#" & oct_of(number), width);
   145.    end log_octal;
   146.
   147.    procedure log_octal (number : in KDF9.word;
   148.                         width  : in Positive := 1) is
   149.    begin
   150.       log_padded_string("#" & oct_of(number), width);
   151.    end log_octal;
   152.
   153.   procedure show_in_various_formats (the_word : in KDF9.word) is
   154.       image : String(1 .. 21);
   155.    begin
   156.       log("  ");
   157.       log_octal(the_word);
   158.       log(" = ");
   159.       show_in_syllables_form(the_word);
   160.       log("= ");
   161.       show_as_glyphs(the_word);
   162.       tab_log_to(66);
   163.       log("= ");
   164.       show_Q_register(as_Q(the_word));
   165.       log_new_line;
   166.       log(" = " & just_right(trimmed(CPU.signed'Image(resign(the_word))), 16) & " = ");
   167.       Put(image, host_float(CPU.f48(the_word)), Aft => 12, Exp => 2);
   168.       log(trimmed(image) & " = ");
   169.       log(as_fraction(the_word)'Image);
   170.       tab_log_to(66);
   171.       log("= ");
   172.       show_Q_in_decimal(as_Q(the_word));
   173.    end show_in_various_formats;
   174.
   175.    procedure show_progress is
   176.
   177.       function readable (t : KDF9.us)
   178.       return String is
   179.          t_in_ms  : constant KDF9.us := (t + 5E2)/ 1E3;
   180.          t_in_sec : constant KDF9.us := (t + 5E5)/ 1E6;
   181.       begin
   182.          return (
   183.                  if    t < 1E3 then ""
   184.                  elsif t < 1E6 then " about" & t_in_ms'Image  & " ms"
   185.                  else               " about" & t_in_sec'Image & " sec"
   186.                 );
   187.       end readable;
   188.
   189.       CPU : constant String := " KDF9 us  (RAN)" & readable(the_CPU_time);
   190.       EL  : constant String := " KDF9 us  (EL) " & readable(the_clock_time);
   191.
   192.    begin
   193.       log_line("ORDERS:     " & just_right(ICR'Image, 10) & " executed (ICR)");
   194.       log_line("CPU TIME:   " & just_right(the_CPU_time'Image, 10) & CPU);
   195.       log_line("CLOCK TIME: " & just_right(KDF9.us'Image(the_clock_time), 10) & EL);
   196.    end show_progress;
   197.
   198.    slot_name : constant array (KDF9.context) of String(1..1)  := ("P", "Q", "R", "S");
   199.
   200.    procedure show_Director_registers is
   201.       interval : constant KDF9.us := the_clock_time - the_last_K4_time;
   202.    begin
   203.       log_line("The CPU is in " & the_CPU_state'Image);
   204.       log_line("CONTEXT:  " & slot_name(the_context));
   205.       log_line("PRIORITY: " & just_right(CPL'Image, 1));
   206.       log_line("BA:       " & just_right("#" & oct_of(BA), 6));
   207.       log_line("NOL:      " & just_right("#" & oct_of(NOL), 6));
   208.       log("CPDAR:    ");
   209.       for i in KDF9.buffer_number loop
   210.          log(if the_CPDAR(i) then device_name_of(buffer(i).all) & " " else "");
   211.       end loop;
   212.       log_new_line;
   213.       log_new_line;
   214.       log_line("PHU stores:");
   215.       for p in KDF9.priority loop
   216.          log("PHU" & p'Image & " is ");
   217.          if PHU(p).is_held_up then
   218.             if PHU(p).blockage.reason = buffer_busy then
   219.                log("waiting for " & device_name_of(IOC.device_number(PHU(p).blockage.buffer_nr)));
   220.                log(" on buffer #" & oct_of(PHU(p).blockage.buffer_nr, 2));
   221.                if PHU(p).blockage.by_INTQq then
   222.                   log(", because of INTQq");
   223.                end if;
   224.             else
   225.                log("locked out of group" & KDF9.store.group_address'Image(PHU(p).blockage.group_nr));
   226.             end if;
   227.          else
   228.             log("idle");
   229.          end if;
   230.          log_new_line;
   231.       end loop;
   232.       log_new_line;
   233.       log("RFIR: ");
   234.       if the_RFIR(caused_by_PR)     then log("PR, ");    end if;
   235.       if the_RFIR(caused_by_FLEX)   then log("FLEX, ");  end if;
   236.       if the_RFIR(caused_by_LIV)    then log("LIV, ");   end if;
   237.       if the_RFIR(caused_by_NOUV)   then log("NOUV, ");  end if;
   238.       if the_RFIR(caused_by_EDT)    then log("EDT, ");   end if;
   239.       if the_RFIR(caused_by_OUT)    then log("OUT, ");   end if;
   240.       if the_RFIR(caused_by_LOV)    then log("LOV, ");   end if;
   241.       if the_RFIR(caused_by_RESET)  then log("RESET, "); end if;
   242.       if interval >= 2**20          then log("CLOCK, "); end if;
   243.       log_line(trimmed(KDF9.us'Image(interval/32*32)) & " KDF9 us since last CLOCK");
   244.       log_new_line;
   245.    end show_Director_registers;
   246.
   247.    procedure show_V_and_T is
   248.    begin
   249.       if the_V_bit_is_set or the_T_bit_is_set then
   250.          log_new_line;
   251.          if the_V_bit_is_set then
   252.             log("V is set. ");
   253.          else
   254.             log("V is clear. ");
   255.          end if;
   256.          if the_T_bit_is_set then
   257.             log("T is set. ");
   258.          else
   259.             log("T is clear. ");
   260.          end if;
   261.          log_new_line;
   262.       end if;
   263.    end show_V_and_T;
   264.
   265.    procedure show_NEST is
   266.    begin
   267.       if the_NEST_depth = 0 then
   268.          log_line("The NEST is empty.");
   269.          return;
   270.       else
   271.          log_line("NEST:");
   272.          for i in reverse KDF9.NEST_depth loop
   273.             if i < the_NEST_depth then
   274.                log(just_right("N" & trimmed(KDF9.NEST_depth'Image(the_NEST_depth-i)), 3) & ": ");
   275.                log_new_line;
   276.                show_in_various_formats(the_NEST(i));
   277.                log_new_line;
   278.             end if;
   279.          end loop;
   280.       end if;
   281.    end show_NEST;
   282.
   283.    procedure show_SJNS is
   284.    begin
   285.       if the_SJNS_depth = 0 then
   286.          log_line("The SJNS is empty.");
   287.          return;
   288.       else
   289.          log_line("SJNS:");
   290.       end if;
   291.       for i in reverse KDF9.SJNS_depth loop
   292.          if i < the_SJNS_depth then
   293.             log(just_right("S" & trimmed(KDF9.SJNS_depth'Image(the_SJNS_depth-i)), 3) & ": ");
   294.             log_line(oct_of(the_SJNS(i)) & " (" & dec_of(KDF9.syllable_address(the_SJNS(i))) & ")");
   295.          end if;
   296.       end loop;
   297.    end show_SJNS;
   298.
   299.    procedure show_Q_store is
   300.       Q_bits  : KDF9.word := 0;
   301.    begin
   302.       for Qq of the_Q_store loop
   303.          Q_bits := Q_bits or as_word(Qq);
   304.       end loop;
   305.       if Q_bits = 0 then
   306.          log_line("Q store: all zero.");
   307.          return;
   308.       else
   309.          log_line("Q store:");
   310.       end if;
   311.       for q in KDF9.Q_store'Range loop
   312.          if as_word(the_Q_store(q)) /= KDF9.word'(0) then
   313.             log(just_right("Q" & trimmed(q'Image), 3) & ": ");
   314.             show_Q_register(the_Q_store(q));
   315.             log("  = ");
   316.             show_Q_in_decimal(the_Q_store(q));
   317.             log_new_line;
   318.          end if;
   319.       end loop;
   320.    end show_Q_store;
   321.
   322.    procedure show_registers is
   323.    begin
   324.       show_progress;
   325.       log_new_line;
   326.       if the_execution_mode = boot_mode then
   327.          show_Director_registers;
   328.       end if;
   329.       show_SJNS;
   330.       log_new_line;
   331.       show_Q_store;
   332.       show_V_and_T;
   333.       log_new_line;
   334.       show_NEST;
   335.    end show_registers;
   336.
   337.    procedure show_order is
   338.    begin
   339.       log(the_code_and_name_of_INS);
   340.    end show_order;
   341.
   342.    procedure show_execution_context is
   343.    begin
   344.       log("At "
   345.         & oct_of(CIA)
   346.         & " ("
   347.         & dec_of(CIA)
   348.         & ")"
   349.         & "; ICR ="
   350.         & ICR'Image
   351.         & "; EL ="
   352.         & the_clock_time'Image
   353.         & "; the instruction was ");
   354.       show_order;
   355.       log_new_line;
   356.    end show_execution_context;
   357.
   358.    function for_FH_disc (compressed_opcode : KDF9.compressed_opcode; Pxy_bits : KDF9.Q_number)
   359.    return Boolean
   360.    is (case compressed_opcode is
   361.           when PIA_PIC_CLO_TLO_Qq     => Pxy_bits = PIC_bits,
   362.           when PIB_PID_Qq             => Pxy_bits = PID_bits,
   363.           when PIE_PIG_Qq             => Pxy_bits = PIG_bits,
   364.           when PIF_PIH_Qq             => Pxy_bits = PIH_bits,
   365.           when POA_POC_POE_POF_PMH_Qq => Pxy_bits = POC_bits,
   366.           when POB_POD_Qq             => Pxy_bits = POD_bits,
   367.           when POG_POL_Qq             => Pxy_bits = POL_bits,
   368.           when POH_POK_Qq             => Pxy_bits = POK_bits,
   369.           when others                 => False
   370.       );
   371.
   372.    type register_usage is array (KDF9.compressed_opcode) of Boolean
   373.       with Size => 64, Component_Size => 1;
   374.
   375.    it_uses_JB : constant register_usage
   376.               := (
   377.                    LINK
   378.                  | TO_LINK
   379.                  | OS_OUT
   380.                  | JrNEJ
   381.                  | JSr
   382.                  | EXIT_n
   383.                  | JrEJ
   384.                  | EXITD     => True,
   385.                    others    => False
   386.                  );
   387.
   388.    it_uses_Qq : constant register_usage
   389.               := (
   390.                    MkMq
   391.                  | MkMqQ
   392.                  | MkMqH
   393.                  | MkMqQH
   394.                  | MkMqN
   395.                  | MkMqQN
   396.                  | MkMqHN
   397.                  | MkMqQHN
   398.                  | TO_MkMq
   399.                  | TO_MkMqQ
   400.                  | TO_MkMqH
   401.                  | TO_MkMqQH
   402.                  | TO_MkMqN
   403.                  | TO_MkMqQN
   404.                  | TO_MkMqHN
   405.                  | TO_MkMqQHN
   406.                  | MqTOQk
   407.                  | IqTOQk
   408.                  | IMqTOQk
   409.                  | CqTOQk
   410.                  | CMqTOQk
   411.                  | CIqTOQk
   412.                  | QqTOQk
   413.                  | M_PLUS_Iq
   414.                  | M_MINUS_Iq
   415.                  | NCq
   416.                  | DCq
   417.                  | POS1_TO_Iq
   418.                  | NEG1_TO_Iq
   419.                  | POS2_TO_Iq
   420.                  | NEG2_TO_Iq
   421.                  | SHA
   422.                  | SHAD
   423.                  | MACC
   424.                  | SHL
   425.                  | SHLD
   426.                  | SHC
   427.                  | TO_RCIMq
   428.                  | QCIMq
   429.                  | ADD_TO_QCIMq
   430.                  | JCqNZS
   431.                  | PAR_Qq
   432.                  | PIA_PIC_CLO_TLO_Qq
   433.                  | PIB_PID_Qq
   434.                  | PIE_PIG_Qq
   435.                  | PIF_PIH_Qq
   436.                  | PMA_PMK_INT_Qq
   437.                  | CT_PMB_PMC_BUSY_Qq
   438.                  | PMD_PME_PML_Qq
   439.                  | PMF_PMG_Qq
   440.                  | POA_POC_POE_POF_PMH_Qq
   441.                  | POB_POD_Qq
   442.                  | POG_POL_Qq
   443.                  | POH_POK_Qq
   444.                  | JrCqNZ    => True,
   445.                    others    => False
   446.                  );
   447.
   448.    is_modified : constant register_usage
   449.                := (
   450.                     EaMq
   451.                   | TO_EaMq
   452.                   | EaMqQ
   453.                   | TO_EaMqQ  => True,
   454.                     others    => False
   455.                   );
   456.    is_MqMk_class : constant register_usage
   457.                := (
   458.
   459.                    MkMq
   460.                  | MkMqQ
   461.                  | MkMqH
   462.                  | MkMqQH
   463.                  | MkMqN
   464.                  | MkMqQN
   465.                  | MkMqHN
   466.                  | MkMqQHN
   467.                  | TO_MkMq
   468.                  | TO_MkMqQ
   469.                  | TO_MkMqH
   470.                  | TO_MkMqQH
   471.                  | TO_MkMqN
   472.                  | TO_MkMqQN
   473.                  | TO_MkMqHN
   474.                  | TO_MkMqQHN  => True,
   475.                    others      => False
   476.                   );
   477.
   478.    it_uses_Qk : constant register_usage
   479.               := (
   480.                    MkMq
   481.                  | MkMqQ
   482.                  | MkMqH
   483.                  | MkMqQH
   484.                  | MkMqN
   485.                  | MkMqQN
   486.                  | MkMqHN
   487.                  | MkMqQHN
   488.                  | TO_MkMq
   489.                  | TO_MkMqQ
   490.                  | TO_MkMqH
   491.                  | TO_MkMqQH
   492.                  | TO_MkMqN
   493.                  | TO_MkMqQN
   494.                  | TO_MkMqHN
   495.                  | TO_MkMqQHN
   496.                  | MqTOQk
   497.                  | IqTOQk
   498.                  | IMqTOQk
   499.                  | CqTOQk
   500.                  | CMqTOQk
   501.                  | CIqTOQk
   502.                  | QqTOQk    => True,
   503.                    others    => False
   504.                  );
   505.
   506.    function INS_uses_Qq
   507.    return Boolean is
   508.       (
   509.        -- A compressed_opcode may be ambiguous: to know which opcode it represents,
   510.        --   further attributes of the order may need to be considered.
   511.        case INS.kind is
   512.           when two_syllable_order =>
   513.              it_uses_Qq(INS.compressed_opcode)
   514.                and
   515.              -- If a shift, exclude fixed-amount shifts.
   516.              ((INS.order.syllable_1 and 1) = 0 or else INS.compressed_opcode not in SHA..SHC),
   517.           when normal_jump_order =>
   518.              INS.compressed_opcode in JrCqZ | JrCqNZ,
   519.           when data_access_order =>
   520.              is_modified(INS.compressed_opcode),
   521.           when others =>
   522.              False
   523.       );
   524.
   525.    procedure log_to_external_trace is
   526.
   527.       procedure log_Q_operand is
   528.          I : constant KDF9.compressed_opcode := INS.compressed_opcode;
   529.          Q : KDF9.Q_register;
   530.       begin
   531.          case INS.kind is
   532.             when two_syllable_order =>
   533.                if it_uses_Qq(I) and then not is_MqMk_class(I) then
   534.                   Q := the_Q_store(INS.Qq);
   535.                   tab_log_to(the_external_trace_file, 104);
   536.                   log(the_external_trace_file, "Q" & Q.C'Image & "/" & Q.I'Image & "/" & Q.M'Image);
   537.                end if;
   538.             when others =>
   539.                null;
   540.          end case;
   541.       end log_Q_operand;
   542.
   543.    begin -- log_to_external_trace
   544.       log(the_external_trace_file, oct_of(CIA));
   545.       tab_log_to(the_external_trace_file, 10);
   546.       log(the_external_trace_file, ICR'Image);
   547.       tab_log_to(the_external_trace_file, 20);
   548.       if only_signature_tracing then
   549.          log(
   550.              the_external_trace_file,
   551.              "#"
   552.            & oct_of(the_digital_signature)
   553.            & (if the_V_bit_is_set then "V" else " ")
   554.            & (if the_T_bit_is_set then "T" else " ")
   555.             );
   556.          tab_log_to(the_external_trace_file, 40);
   557.          if the_NEST_depth > 0 then
   558.             log(the_external_trace_file, "#" & oct_of(read_top));
   559.          end if;
   560.          tab_log_to(the_external_trace_file, 58);
   561.       else
   562.          log(the_external_trace_file, the_CPU_time'Image);
   563.          tab_log_to(the_external_trace_file, 40);
   564.          log(the_external_trace_file, the_NEST_depth'Image);
   565.          tab_log_to(the_external_trace_file, 43);
   566.          log(the_external_trace_file, the_SJNS_depth'Image);
   567.          tab_log_to(the_external_trace_file, 46);
   568.          log(the_external_trace_file, (if the_V_bit_is_set then "V" else " "));
   569.          log(the_external_trace_file, (if the_T_bit_is_set then "T" else " "));
   570.          tab_log_to(the_external_trace_file, 50);
   571.          if the_NEST_depth > 0 then
   572.             log(the_external_trace_file, "#" & oct_of(read_top));
   573.          end if;
   574.          tab_log_to(the_external_trace_file, 68);
   575.       end if;
   576.       log(the_external_trace_file, " |" & the_full_name_of(INS, True));
   577.       tab_log_to(the_external_trace_file, 92);
   578.       log(the_external_trace_file, KDF9.us'Image(the_clock_time));
   579.       log_Q_operand;
   580.       log_new_line(the_external_trace_file);
   581.    end log_to_external_trace;
   582.
   583.    procedure log_an_external_trace_header (caption : in String := "") is
   584.    begin
   585.       if caption /= "" then
   586.          log_new_line(the_external_trace_file);
   587.          log(the_external_trace_file, caption);
   588.          log_new_line(the_external_trace_file);
   589.       end if;
   590.       log(the_external_trace_file, "LOCATION");
   591.       tab_log_to(the_external_trace_file, 11);
   592.       log(the_external_trace_file, "ICR");
   593.       tab_log_to(the_external_trace_file, 20);
   594.       if only_signature_tracing then
   595.          log(the_external_trace_file, "DIGITAL SIGNATURE");
   596.          tab_log_to(the_external_trace_file, 40);
   597.          log(the_external_trace_file, "[N1]");
   598.          tab_log_to(the_external_trace_file, 58);
   599.       else
   600.          log(the_external_trace_file, " CPU");
   601.          tab_log_to(the_external_trace_file, 40);
   602.          log(the_external_trace_file, "ND");
   603.          tab_log_to(the_external_trace_file, 43);
   604.          log(the_external_trace_file, "SD");
   605.          tab_log_to(the_external_trace_file, 46);
   606.          log(the_external_trace_file, "VT");
   607.          tab_log_to(the_external_trace_file, 50);
   608.          log(the_external_trace_file, "[N1]");
   609.          tab_log_to(the_external_trace_file, 68);
   610.       end if;
   611.       log(the_external_trace_file, " |INSTRUCTION");
   612.       log_new_line(the_external_trace_file);
   613.    end log_an_external_trace_header;
   614.
   615.    procedure show_CIA_and_NIA is
   616.    begin
   617.       log_line("CIA:        " & just_right(oct_of(CIA), 10) & " (" & just_right(dec_of(CIA) & ")"));
   618.       log_line(" :        " & just_right(oct_of(NIA), 10) & " (" & just_right(dec_of(NIA) & ")"));
   619.    end show_CIA_and_NIA;
   620.
   621.    procedure long_witness is
   622.    begin
   623.       log_new_line;
   624.       log("At " & oct_of(CIA) & " (" & dec_of(CIA) & ") the instruction was ");
   625.       show_order;
   626.       log_new_line;
   627.       show_registers;
   628.    end long_witness;
   629.
   630.    procedure short_witness is
   631.
   632.       need_new_line : Boolean := False;
   633.
   634.    begin  -- short_witness
   635.       log_new_line;
   636.       show_execution_context;
   637.       if the_CPU_state = Director_state then
   638.          show_Director_registers;
   639.       end if;
   640.
   641.       if it_uses_JB(INS.compressed_opcode)                     and then
   642.             INS.kind in two_syllable_order | normal_jump_order and then
   643.                the_SJNS_depth > 0                                  then
   644.          log_line(
   645.                   " JB: "
   646.                 & oct_of(the_SJNS(the_SJNS_depth-1))
   647.                 & "; SJNS depth: " & just_right(the_SJNS_depth'Image, 3)
   648.                  );
   649.       end if;
   650.
   651.       if INS.Qq /= 0 and then
   652.             INS_uses_Qq  then
   653.          log(just_right("Q" & trimmed(INS.Qq'Image), 3) & ": ");
   654.          show_Q_register(the_Q_store(INS.Qq));
   655.          log("  = ");
   656.          show_Q_in_decimal(the_Q_store(INS.Qq));
   657.          log_new_line;
   658.          need_new_line := True;
   659.       end if;
   660.       if INS.Qk /= 0                       and then
   661.             INS.kind in two_syllable_order and then
   662.                it_uses_Qk(INS.compressed_opcode)    and then
   663.                   INS.Qq /= INS.Qk             then
   664.          log(just_right("Q" & trimmed(INS.Qk'Image), 3) & ": ");
   665.          show_Q_register(the_Q_store(INS.Qk));
   666.          log("  = ");
   667.          show_Q_in_decimal(the_Q_store(INS.Qk));
   668.          log_new_line;
   669.          need_new_line := True;
   670.       end if;
   671.       if need_new_line then
   672.          log_new_line;
   673.       end if;
   674.
   675.       show_V_and_T;
   676.       show_NEST;
   677.       log_rule;
   678.    end short_witness;
   679.
   680.    procedure show_frequency_plots is
   681.
   682.       function summed_counts (from, to : KDF9.syllable)
   683.       return KDF9.order_counter is
   684.          sum : KDF9.order_counter := 0;
   685.       begin
   686.          for i in from .. to loop
   687.             sum := sum + the_histogram(i);
   688.          end loop;
   689.          return sum;
   690.       end summed_counts;
   691.
   692.       procedure log_opcode_bin (bin    : in KDF9.syllable;
   693.                                 sum    : in KDF9.order_counter;
   694.                                 bound  : in Long_Float) is
   695.          percent : Long_Float;
   696.          image   : String(1 .. 6);
   697.       begin
   698.          if sum /= 0 then
   699.             percent := Long_Float(sum)/Long_Float(ICR)*100.0;
   700.             if percent < bound then
   701.                return;
   702.             end if;
   703.             log(oct_of(bin) & ": " & the_short_name_of(bin));
   704.             tab_log_to(32);
   705.             log(sum'Image);
   706.             tab_log_to(42);
   707.             Put(image, percent, Aft => 2, Exp => 0);
   708.             log(image & "% :");
   709.             for i in 1 .. Integer(percent) loop
   710.                log("|");
   711.             end loop;
   712.             log_new_line;
   713.          end if;
   714.       end log_opcode_bin;
   715.
   716.       procedure log_opcode_usage (bound : in Long_Float) is
   717.       begin
   718.          for i in KDF9.syllable'(0) .. 8#167# loop
   719.             log_opcode_bin(i, the_histogram(i), bound);
   720.          end loop;
   721.          for i in KDF9.syllable'(8#170#) .. 8#237# loop
   722.             log_opcode_bin(i, the_histogram(i), bound);
   723.          end loop;
   724.          log_opcode_bin(8#240#, summed_counts(from => 8#240#, to => 8#257#), bound);
   725.          log_opcode_bin(8#260#, summed_counts(from => 8#240#, to => 8#277#), bound);
   726.          for i in KDF9.syllable'(8#300#) .. 8#377# loop
   727.             log_opcode_bin(i, the_histogram(i), bound);
   728.          end loop;
   729.       end log_opcode_usage;
   730.
   731.       accounted_for : Long_Float;
   732.       cutoff_image  : String(1 .. 7) := "      %";
   733.       percent_image : String(1 .. 7) := "      %";
   734.
   735.       procedure log_order_word_bin (bin    : in KDF9.code_address;
   736.                                     sum    : in KDF9.order_counter;
   737.                                     bound  : in Long_Float) is
   738.          percent : Long_Float;
   739.       begin
   740.          if sum /= 0 then
   741.             percent := Long_Float(sum)/Long_Float(ICR)*100.0;
   742.             if percent < bound then
   743.                return;
   744.             end if;
   745.             accounted_for := accounted_for + percent;
   746.             log("#" & oct_of(bin) & ": ");
   747.             tab_log_to(32);
   748.             log(sum'Image);
   749.             tab_log_to(42);
   750.             Put(percent_image, percent, Aft => 2, Exp => 0);
   751.             percent_image(7) := '%';
   752.             log(percent_image);
   753.             log(" :");
   754.             for i in 1 .. Integer(percent) loop
   755.                log("|");
   756.             end loop;
   757.             log_new_line;
   758.          end if;
   759.       end log_order_word_bin;
   760.
   761.       procedure log_profile (bound : in Long_Float) is
   762.       begin
   763.          accounted_for := 0.0;
   764.          for w in KDF9.code_address loop
   765.             if the_profile(w) /= 0 then
   766.                log_order_word_bin(w, the_profile(w), bound);
   767.             end if;
   768.          end loop;
   769.       end log_profile;
   770.
   771.       procedure sum_logged_frequencies (bound  : in Long_Float) is
   772.          percent : Long_Float;
   773.       begin
   774.          accounted_for := 0.0;
   775.          for w in KDF9.code_address loop
   776.             percent := Long_Float(the_profile(w))/Long_Float(ICR)*100.0;
   777.             if percent >= bound then
   778.                accounted_for := accounted_for + percent;
   779.             end if;
   780.          end loop;
   781.       end sum_logged_frequencies;
   782.
   783.    begin -- show_frequency_plots
   784.       Put(cutoff_image(1..6), histogram_cutoff, Aft => 2, Exp => 0);
   785.       cutoff_image(7) := '%';
   786.       if the_INS_plot_is_wanted and ICR /= 0 and the_diagnostic_mode /= fast_mode then
   787.          -- Print the instruction execution-frequency histogram.
   788.          log_title(
   789.                    "Histogram of the opcodes of"
   790.                  & ICR'Image
   791.                  & " executed instructions with frequency >="
   792.                  & cutoff_image
   793.                   );
   794.          log_opcode_usage(bound => histogram_cutoff);
   795.          log_new_line;
   796.       end if;
   797.       if the_profile_is_wanted and ICR /= 0 and the_diagnostic_mode /= fast_mode then
   798.          log_title(
   799.                    "Histogram of the loci of"
   800.                  & ICR'Image
   801.                  & " executed instructions with frequency >="
   802.                  & cutoff_image
   803.                   );
   804.          log_profile(bound => histogram_cutoff);
   805.          log_new_line;
   806.       end if;
   807.       sum_logged_frequencies(bound => histogram_cutoff);
   808.       Put(percent_image(1..6), accounted_for, Aft =>1, Exp => 0);
   809.       log_line("Executions accounted for in the profile:" & percent_image);
   810.       log_rule;
   811.    end show_frequency_plots;
   812.
   813.    function as_RFIR (K4_word : KDF9.word)
   814.    return KDF9.RFIR is
   815.       mask : KDF9.word := 2**16;
   816.       RFIR : KDF9.RFIR := (others => False);
   817.    begin
   818.       for r in reverse KDF9.interrupt_number loop
   819.          if (K4_word and mask) /= 0 then
   820.             RFIR(r) := True;
   821.          end if;
   822.          mask := 2 * mask;
   823.       end loop;
   824.       return RFIR;
   825.    end as_RFIR;
   826.
   827.    first_col   : constant := 17;
   828.    device_col  : constant := first_col + 23;
   829.    operand_col : constant := device_col;
   830.    event_col   : constant := operand_col + 4;
   831.    is_D_col    : constant := event_col + 29;
   832.    depth_col   : constant := 77;
   833.    time_col    : constant := depth_col + 11;
   834.    ICR_col     : constant := time_col + 13;
   835.
   836.    procedure show_retro_FIFO is
   837.
   838.       RFIR_id : constant array (KDF9.interrupt_number) of Character
   839.               := ('P', 'F', 'I', 'N', 'E', 'S', 'O', 'R', 'Y', 'Z');
   840.       image   : String(1 .. 21);
   841.       RFIR    : KDF9.RFIR;
   842.    begin
   843.       if retro_FIFO_count = 0 then
   844.          return;
   845.       end if;
   846.       log_title("Retrospective trace of all instructions.");
   847.       tab_log_to(depth_col);
   848.       log_line("ND SD VTD   CPU TIME     ICR");
   849.       for i in 1 .. retro_FIFO_count loop
   850.          if i = 1 then
   851.             log("Ended ");
   852.          else
   853.             log("After ");
   854.          end if;
   855.          declare
   856.             this      : tracing.retro_FIFO_entry renames retro_FIFO(retro_FIFO_index);
   857.             Q         : constant KDF9.Q_register := as_Q(this.parameter);
   858.             decoded   : KDF9.decoded_order;
   859.          begin
   860.             log(oct_of(this.location) & ":");
   861.             tab_log_to(first_col);
   862.             decoded.order := this.order;
   863.             decode(decoded);
   864.             log(the_full_name_of(decoded, in_octal => decoded.kind = normal_jump_order));
   865.             tab_log_to(operand_col);
   866.             case decoded.kind is
   867.                when one_syllable_order =>
   868.                   if this.nested > 0 then
   869.                      case decoded.compressed_opcode is
   870.                         when DIV
   871.                            | DIVD
   872.                            | X_frac =>
   873.                            log(CPU.fraction'Image(as_fraction(this.parameter)));
   874.                         when DIVI =>
   875.                            log(CPU.signed'Image(resign(this.parameter)));
   876.                         when STAND
   877.                            | ABSF
   878.                            | DIVDF
   879.                            | DIVF
   880.                            | FLOAT_9
   881.                            | FLOATD
   882.                            | MINUSDF
   883.                            | MINUSF
   884.                            | NEGDF
   885.                            | NEGF
   886.                            | PLUSDF
   887.                            | PLUSF
   888.                            | ROUNDF
   889.                            | ROUNDHF
   890.                            | XDF
   891.                            | XF
   892.                            | XPLUSF
   893.                            | MAXF =>
   894.                            Put(image, host_float(CPU.f48(this.parameter)), Aft => 12, Exp => 2);
   895.                            log(trimmed(image));
   896.                         when others =>
   897.                            log_octal(this.parameter);
   898.                            log(" = ");
   899.                            log(CPU.signed'Image(resign(this.parameter)));
   900.                      end case;
   901.                   end if;
   902.                when two_syllable_order =>
   903.                   case decoded.compressed_opcode is
   904.                      when PAR_Qq =>
   905.                         show_IO_register(Q, for_DR => False, for_FD => False);
   906.                      when CT_PMB_PMC_BUSY_Qq
   907.                         | PMA_PMK_INT_Qq
   908.                         | PMD_PME_PML_Qq
   909.                         | PMF_PMG_Qq =>
   910.                         show_IO_register(
   911.                                          Q,
   912.                                          for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
   913.                                          for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
   914.                                          for_seek => decoded.Qk = PMA_bits
   915.                                         );
   916.                      when PIA_PIC_CLO_TLO_Qq
   917.                         | PIB_PID_Qq
   918.                         | PIE_PIG_Qq
   919.                         | PIF_PIH_Qq
   920.                         | POA_POC_POE_POF_PMH_Qq
   921.                         | POB_POD_Qq
   922.                         | POG_POL_Qq
   923.                         | POH_POK_Qq =>
   924.                         show_IO_register(
   925.                                          Q,
   926.                                          for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
   927.                                          for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
   928.                                          for_FH   => for_FH_disc(decoded.compressed_opcode, decoded.Qk)
   929.                                         );
   930.                      when M_PLUS_Iq
   931.                         | M_MINUS_Iq
   932.                         | NCq
   933.                         | DCq
   934.                         | POS1_TO_Iq
   935.                         | NEG1_TO_Iq
   936.                         | POS2_TO_Iq
   937.                         | NEG2_TO_Iq
   938.                         | CqTOQk
   939.                         | IqTOQk
   940.                         | MqTOQk
   941.                         | QqTOQk
   942.                         | CIqTOQk
   943.                         | IMqTOQk
   944.                         | CMqTOQk
   945.                         | TO_RCIMq
   946.                         | ADD_TO_QCIMq
   947.                         | QCIMq
   948.                         | JCqNZS =>
   949.                         show_Q_register(Q);
   950.                      when Kk =>
   951.                         case decoded.Qk is
   952.                            when K4 =>
   953.                               log(KDF9.word'Image(32*KDF9.word(Q.C)));
   954.                               log("us");
   955.                               if Q.I /= 0 then
   956.                                  log("; RFIR: ");
   957.                                  RFIR := as_RFIR(this.parameter);
   958.                                  for r in KDF9.interrupt_number loop
   959.                                     if RFIR(r) then
   960.                                        log(RFIR_id(r)&"");
   961.                                     end if;
   962.                                  end loop;
   963.                               end if;
   964.                               if resign(this.parameter) < 0 then
   965.                                  log("C");
   966.                               end if;
   967.                            when K5 | K7 =>
   968.                               log_octal(this.parameter);
   969.                            when others =>
   970.                               log("invalid K order: #" & oct_of(decoded.compressed_opcode));
   971.                         end case;
   972.                      when TO_LINK =>
   973.                         log(oct_of(as_link(this.parameter)));
   974.                      when LINK =>
   975.                         log(oct_of(as_link(this.parameter)));
   976.                      when TO_MkMq
   977.                         | TO_MkMqQ
   978.                         | TO_MkMqH
   979.                         | TO_MkMqQH
   980.                         | TO_MkMqN
   981.                         | TO_MkMqQN
   982.                         | TO_MkMqHN
   983.                         | TO_MkMqQHN =>
   984.                         log_octal(this.parameter);
   985.                         log(" = ");
   986.                         log(CPU.signed'Image(resign(this.parameter)));
   987.                      when others =>
   988.                         if this.nested > 0 then
   989.                            log_octal(this.parameter);
   990.                            log(" = ");
   991.                            log(CPU.signed'Image(resign(this.parameter)));
   992.                         end if;
   993.                   end case;
   994.                when normal_jump_order =>
   995.                   case decoded.compressed_opcode is
   996.                      when Jr
   997.                         | JSr =>
   998.                         log(oct_of(as_link(this.parameter)));
   999.                      when EXIT_n =>
  1000.                         if this.parameter < 8 then
  1001.                            log(this.parameter'Image);
  1002.                         else
  1003.                            log(oct_of(as_link(this.parameter)));
  1004.                         end if;
  1005.                      when EXITD =>
  1006.                         log(oct_of(as_link(this.parameter)));
  1007.                      when JrCqZ
  1008.                         | JrCqNZ =>
  1009.                         show_Q_register(Q);
  1010.                      when OS_OUT =>
  1011.                         if this.parameter < 16 then
  1012.                            log_octal(this.parameter);
  1013.                         elsif this.parameter < 64 then
  1014.                            log(this.parameter'Image);
  1015.                         elsif this.parameter > 2**47 then
  1016.                            log_octal(this.parameter);
  1017.                         else
  1018.                            show_Q_register(Q);
  1019.                         end if;
  1020.                      when JrEJ
  1021.                         | JrNEJ
  1022.                         | JrEN
  1023.                         | JrNEN =>
  1024.                            log(this.parameter'Image);
  1025.                      when JrTR
  1026.                         | JrV =>
  1027.                            log(Boolean'Image(Boolean'Val(this.parameter)));
  1028.                      when JrNTR
  1029.                         | JrNV =>
  1030.                            log(Boolean'Image(not Boolean'Val(this.parameter)));
  1031.                      when others =>
  1032.                         if this.nested > 0 then
  1033.                            log_octal(this.parameter);
  1034.                         end if;
  1035.                      end case;
  1036.                when others =>
  1037.                   if this.nested > 0 then
  1038.                      log_octal(this.parameter);
  1039.                      log(" = ");
  1040.                      log(CPU.signed'Image(resign(this.parameter)));
  1041.                   end if;
  1042.             end case;
  1043.             tab_log_to(depth_col);
  1044.             log(just_right(this.nested'Image,2));
  1045.             log(" ");
  1046.             log(just_right(this.called'Image,2));
  1047.             log(" ");
  1048.             log(if this.V then "V" else " ");
  1049.             log(if this.T then "T" else " ");
  1050.             log(if this.D then "D" else " ");
  1051.             tab_log_to(time_col);
  1052.             log(this.CPU_time'Image);
  1053.             tab_log_to(ICR_col);
  1054.             log(this.ICR_value'Image);
  1055.             log_new_line;
  1056.          end;
  1057.          retro_FIFO_index := retro_FIFO_index - 1;
  1058.       end loop;
  1059.       if retro_FIFO_count = FIFO_size then
  1060.          log("After earlier instructions, whose tracing is now lost.");
  1061.       else
  1062.          log("After the start of traced execution.");
  1063.       end if;
  1064.       log_new_line;
  1065.       log_rule;
  1066.    end show_retro_FIFO;
  1067.
  1068.    the_final_ICR : KDF9.order_counter := 0;
  1069.
  1070.    procedure notify_state_display_of_final_ICR is
  1071.    begin
  1072.       the_final_ICR := ICR;
  1073.    end notify_state_display_of_final_ICR;
  1074.
  1075.    procedure show_IOC_FIFO is
  1076.    begin
  1077.       if IOC_FIFO_count = 0 then return; end if;
  1078.       log_title("Retrospective trace of peripheral I/O events.");
  1079.       tab_log_to(is_D_col);
  1080.       log_line("CPL T           EL. TIME       ICR");
  1081.       for i in 1 .. IOC_FIFO_count loop
  1082.          if i = 1 then
  1083.             log("Ended ");
  1084.          else
  1085.             log("After ");
  1086.          end if;
  1087.
  1088.          declare
  1089.             this    : tracing.IOC_FIFO_entry renames IOC_FIFO(IOC_FIFO_index);
  1090.             decoded : constant KDF9.decoded_order := this.decoded_order;
  1091.
  1092.             procedure show_transfer (
  1093.                                      Q                 : in KDF9.Q_register;
  1094.                                      for_OUT, for_seek : in Boolean := False
  1095.                                     ) is
  1096.             begin
  1097.                case decoded.compressed_opcode is
  1098.                   when PAR_Qq =>
  1099.                      show_IO_register(Q, for_DR => False, for_FD => False);
  1100.                   when CT_PMB_PMC_BUSY_Qq
  1101.                      | PMA_PMK_INT_Qq
  1102.                      | PMD_PME_PML_Qq
  1103.                      | PMF_PMG_Qq =>
  1104.                      show_IO_register(
  1105.                                       Q,
  1106.                                       for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
  1107.                                       for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
  1108.                                       for_seek => (decoded.Qk in PMA_bits) or show_transfer.for_seek,
  1109.                                       for_OUT  => show_transfer.for_OUT
  1110.                                      );
  1111.                   when PIA_PIC_CLO_TLO_Qq
  1112.                      | PIB_PID_Qq
  1113.                      | PIE_PIG_Qq
  1114.                      | PIF_PIH_Qq
  1115.                      | POA_POC_POE_POF_PMH_Qq
  1116.                      | POB_POD_Qq
  1117.                      | POG_POL_Qq
  1118.                      | POH_POK_Qq
  1119.                      | OS_OUT =>
  1120.                      show_IO_register(
  1121.                                       Q,
  1122.                                       for_DR   => device_kind_of(Q.C mod 16) = DR_kind,
  1123.                                       for_FD   => device_kind_of(Q.C mod 16) = FD_kind,
  1124.                                       for_FH   => for_FH_disc(decoded.compressed_opcode, decoded.Qk),
  1125.                                       for_OUT  => show_transfer.for_OUT
  1126.                                      );
  1127.                   when others =>
  1128.                      log("invalid IO order: #" & oct_of(decoded.compressed_opcode));
  1129.                end case;
  1130.             end show_transfer;
  1131.
  1132.             shown_ICR : KDF9.order_counter := this.ICR_value;
  1133.             FD_seek   : Boolean := False;
  1134.             FD_xfer   : Boolean := False;
  1135.
  1136.          begin -- show_IOC_FIFO
  1137.             log(oct_of(this.order_address) & ":");
  1138.             tab_log_to(first_col);
  1139.             if the_full_name_of(this.decoded_order, True) = "OUT"  then
  1140.                 if this.device_name(1..2) in "MT" | "ST" and then
  1141.                       this.ICR_value >= the_final_ICR        then
  1142.                   log("OUT 0/2 rewind");
  1143.                   shown_ICR := the_final_ICR + 1;
  1144.                elsif this.device_name(1..2) in "MT" | "ST" then
  1145.                   log("OUT 6/7 rewind");
  1146.                elsif this.device_name(1..2) in "LP" | "TP" then
  1147.                   log("OUT 8");
  1148.                elsif this.device_name(1..2) = "DR" then
  1149.                   if this.kind in start_transfer | finis_transfer | buffer_lockout | store_lockout then
  1150.                      log(if this.operation = output_operation then "OUT 11" else "OUT 12");
  1151.                   else
  1152.                      log("OUT 11/12");
  1153.                   end if;
  1154.                elsif this.device_name(1..2) = "FD" then
  1155.                   if this.kind in start_transfer | finis_transfer | buffer_lockout | store_lockout then
  1156.                      log(if this.operation = output_operation then "OUT 41" else "OUT 42");
  1157.                   else
  1158.                      log("OUT 41/42 seek"); FD_seek := True;
  1159.                   end if;
  1160.                elsif this.device_name(1..2) = "FW" then
  1161.                   log("OUT 8/16");
  1162.                else
  1163.                   log("OUT ?");
  1164.                end if;
  1165.             else
  1166.                log(mnemonic(the_full_name_of(this.decoded_order, True), this.device_name));
  1167.             end if;
  1168.             tab_log_to(device_col);
  1169.             log(this.device_name);
  1170.             case this.kind is
  1171.                when store_lockout =>
  1172.                   tab_log_to(event_col);
  1173.                   log("locks out #");
  1174.                   log(oct_of(this.data_address));
  1175.                   log(" = E");
  1176.                   log(dec_of(this.data_address));
  1177.                   tab_log_to(is_D_col);
  1178.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1179.                   log(this.priority_level'Image);
  1180.                   tab_log_to(time_col);
  1181.                   log(this.initiation_time'Image);
  1182.                   tab_log_to(ICR_col);
  1183.                   log(shown_ICR'Image);
  1184.                 when buffer_lockout =>
  1185.                   tab_log_to(event_col);
  1186.                   log("buffer lockout");
  1187.                   tab_log_to(is_D_col);
  1188.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1189.                   log(this.priority_level'Image);
  1190.                   tab_log_to(time_col);
  1191.                   log(this.initiation_time'Image);
  1192.                   tab_log_to(ICR_col);
  1193.                   log(shown_ICR'Image);
  1194.                when start_transfer =>
  1195.                   tab_log_to(event_col);
  1196.                   show_transfer(this.control_word);
  1197.                   tab_log_to(is_D_col);
  1198.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1199.                   log(this.priority_level'Image);
  1200.                   tab_log_to(time_col-2);
  1201.                   log(" S" & this.initiation_time'Image);
  1202.                   tab_log_to(ICR_col);
  1203.                   log(shown_ICR'Image);
  1204.                when finis_transfer =>
  1205.                   tab_log_to(event_col);
  1206.                   show_transfer(this.control_word);
  1207.                   tab_log_to(is_D_col);
  1208.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1209.                   log(this.priority_level'Image);
  1210.                   tab_log_to(time_col-2);
  1211.                   log(" E" & this.completion_time'Image);
  1212.                   tab_log_to(ICR_col);
  1213.                   log(shown_ICR'Image);
  1214.                when buffer_status =>
  1215.                   tab_log_to(event_col);
  1216.                   FD_xfer := this.device_name(1..2) = "FD";
  1217.                   -- PMFQq entails no data transfer or seek, but has a sector address parameter.
  1218.                   FD_seek := (FD_seek or (decoded.Qk in PMA_bits)) and FD_xfer;
  1219.                   FD_seek := FD_seek and decoded.compressed_opcode /= PMF_PMG_Qq;
  1220.                   show_IO_register(this.Q_register, for_FD => FD_xfer, for_seek => FD_seek);
  1221.                   tab_log_to(is_D_col);
  1222.                   log(if this.is_for_Director then "D" else slot_name(this.context));
  1223.                   log(this.priority_level'Image);
  1224.                   log(if this.status then " Y" else " N");
  1225.                   tab_log_to(time_col);
  1226.                   log(this.initiation_time'Image);
  1227.                   tab_log_to(ICR_col);
  1228.                   log(shown_ICR'Image);
  1229.             end case;
  1230.             log_new_line;
  1231.          end;
  1232.          IOC_FIFO_index := IOC_FIFO_index - 1;
  1233.       end loop;
  1234.       if IOC_FIFO_count = FIFO_size then
  1235.          log_line("After earlier instructions, whose tracing is now lost.");
  1236.       else
  1237.          log_line("After the start of traced execution.");
  1238.       end if;
  1239.       log_line("Total time waiting for unoverlapped I/O to finish ="
  1240.              & KDF9.us'Image((the_clock_time-the_CPU_time+500) / 1000)
  1241.              & " ms.");
  1242.       log_rule;
  1243.    end show_IOC_FIFO;
  1244.
  1245.    procedure show_interrupt_FIFO is
  1246.    begin
  1247.       if interrupt_FIFO_count = 0 then return; end if;
  1248.       log_title("Retrospective trace of interrupt requests.");
  1249.       tab_log_to(is_D_col);
  1250.       log_line("CPL             EL. TIME     ICR");
  1251.       for i in 1 .. interrupt_FIFO_count loop
  1252.          log(if i = 1 then "Ended " else "After ");
  1253.          declare
  1254.             this : tracing.interrupt_FIFO_entry renames interrupt_FIFO(interrupt_FIFO_index);
  1255.          begin
  1256.             log(oct_of(this.order_address) & ": ");
  1257.             tab_log_to(first_col);
  1258.             log(case this.interrupt_code is
  1259.                    when caused_by_PR     => "PR   ",
  1260.                    when caused_by_FLEX   => "FLEX ",
  1261.                    when caused_by_LIV    => "LIV  ",
  1262.                    when caused_by_NOUV   => "NOUV ",
  1263.                    when caused_by_EDT    => "EDT  ",
  1264.                    when caused_by_OUT    => "OUT  ",
  1265.                    when caused_by_LOV     => "LOV  ",
  1266.                    when caused_by_RESET   => "RESET",
  1267.                    when caused_by_CLOCK   => "CLOCK",
  1268.                    when EXITD_flag       => "EXITD"
  1269.                );
  1270.             tab_log_to(event_col-4);
  1271.             log(trimmed(this.message));
  1272.             tab_log_to(is_D_col);
  1273.             log(slot_name(this.context));
  1274.             log(this.priority_level'Image);
  1275.             tab_log_to(time_col);
  1276.             log(this.busy_time'Image);
  1277.             tab_log_to(ICR_col);
  1278.             log(this.ICR_value'Image);
  1279.             log_new_line;
  1280.          end;
  1281.          interrupt_FIFO_index := interrupt_FIFO_index - 1;
  1282.       end loop;
  1283.       log(
  1284.           if interrupt_FIFO_count = FIFO_size then
  1285.              "After earlier interrupts, whose tracing is now lost."
  1286.           else
  1287.             "After the start of traced execution."
  1288.          );
  1289.       log_new_line;
  1290.       log_new_line;
  1291.    end show_interrupt_FIFO;
  1292.
  1293.    procedure show_retrospective_traces is
  1294.    begin
  1295.       if peripheral_tracing_is_enabled then
  1296.          pragma Debug(IOC.diagnostics);
  1297.       end if;
  1298.       if interrupt_tracing_is_enabled then
  1299.          show_interrupt_FIFO;
  1300.       end if;
  1301.       if peripheral_tracing_is_enabled then
  1302.          show_IOC_FIFO;
  1303.       end if;
  1304.       if retrospective_tracing_is_enabled then
  1305.          show_retro_FIFO;
  1306.       end if;
  1307.    end show_retrospective_traces;
  1308.
  1309.    procedure show_current_state is
  1310.    begin
  1311.       show_execution_context;
  1312.       log_rule;
  1313.       show_registers;
  1314.       log_rule;
  1315.    end show_current_state;
  1316.
  1317.    procedure show_final_state (because : in String) is
  1318.    begin
  1319.       if the_final_state_is_wanted then
  1320.          if loading_was_successful then
  1321.
  1322.             -- make sure there is at least one NL after any FW output.
  1323.             if the_log_is_wanted then
  1324.                log_new_line;
  1325.                log_rule;
  1326.             else
  1327.                log_new_line;
  1328.             end if;
  1329.             log_line("Final State: " & because & ".");
  1330.             if not the_log_is_wanted then return; end if;
  1331.             long_witness;
  1332.             log_rule;
  1333.
  1334.             if nr_of_post_dumping_areas /= 0 then
  1335.                log_title("Post-run Dump:");
  1336.                print_postrun_dump_areas;
  1337.             end if;
  1338.
  1339.             if the_INS_plot_is_wanted or the_profile_is_wanted then
  1340.                if histogramming_is_enabled then
  1341.                   show_frequency_plots;
  1342.                end if;
  1343.             end if;
  1344.
  1345.             show_retrospective_traces;
  1346.             if the_signature_is_enabled then
  1347.                log_title("Digital signature of traced orders = #"
  1348.                        & oct_of(the_digital_signature)
  1349.                        & ".");
  1350.             end if;
  1351.
  1352.          else
  1353.
  1354.             log_line("ee9: " & because & ".");
  1355.             show_all_prerun_dump_areas;
  1356.          end if;
  1357.       end if;
  1358.    end show_final_state;
  1359.
  1360.    procedure show_all_prerun_dump_areas is
  1361.    begin
  1362.       if the_log_is_wanted and nr_of_pre_dumping_areas /= 0 then
  1363.          log_title("Pre-run Dump:");
  1364.          print_prerun_dump_areas;
  1365.          remove_prerun_dump_areas;
  1366.       end if;
  1367.    end show_all_prerun_dump_areas;
  1368.
  1369.    increment   : constant := 3;
  1370.    jump_tab    : constant := 4;
  1371.    first_tab   : constant := 7;
  1372.    last_column : constant := 96;
  1373.
  1374.    function is_non_blank (first : in KDF9.address)
  1375.    return Boolean is
  1376.       result : Boolean := False;
  1377.    begin
  1378.       for address in first .. first+increment-1 loop
  1379.          result := result or (fetch_word(address) /= 0);
  1380.       end loop;
  1381.       return result;
  1382.    end is_non_blank;
  1383.
  1384.    subtype converted_word is String(1..8);
  1385.
  1386.    type convertor is
  1387.       not null access function (address : KDF9.address) return converted_word;
  1388.
  1389.    procedure show_core (start, finish : in KDF9.address;
  1390.                         head, side    : in String;
  1391.                         converted     : in convertor) is
  1392.
  1393.       first : constant KDF9.address := bounded_data_address(start);
  1394.       last  : constant KDF9.address := bounded_data_address(finish);
  1395.
  1396.       procedure show_group (first : in KDF9.address) is
  1397.          address : KDF9.address := first;
  1398.       begin
  1399.          while address <= first+increment-1 loop
  1400.             log(converted(address));
  1401.             address := address + 1;
  1402.             exit when address < first;
  1403.          end loop;
  1404.       end show_group;
  1405.
  1406.       address : KDF9.address := bounded_data_address(first);
  1407.
  1408.    begin
  1409.       if last < start then
  1410.          log_title(
  1411.                    "Address range #"
  1412.                  & oct_of(start)
  1413.                  & " .. #"
  1414.                  & oct_of(finish)
  1415.                  & ", to be given as "
  1416.                  & head
  1417.                  & ", is outside the allocated core."
  1418.                   );
  1419.          log_rule;
  1420.          return;
  1421.       end if;
  1422.       BA := 0; -- Ensure that physical store is examined when running in boot mode.
  1423.       log_title("Core store [#" & oct_of(first) & " .. #" & oct_of(last) & "] interpreted as " & head & ":");
  1424.       while address <= last loop
  1425.          if is_non_blank(address) then
  1426.             log_octal(KDF9.field_of_16_bits(address));
  1427.             log(":");
  1428.             tab_log_to(jump_tab);
  1429.             log(side);
  1430.             log(" """);
  1431.             show_group(address);
  1432.             log("""");
  1433.             log_new_line;
  1434.          else
  1435.             log_line("========  blank  ========");
  1436.          end if;
  1437.       exit when address >= KDF9.address'Last - increment;
  1438.          address := address + increment;
  1439.       end loop;
  1440.       log_rule;
  1441.    end show_core;
  1442.
  1443.    function encoding_of (address : KDF9.address; code_table : output_code_table)
  1444.    return converted_word is
  1445.       result : converted_word;
  1446.    begin
  1447.       for b in KDF9_char_sets.symbol_index loop
  1448.          result(Natural(b)+1) := glyph_for(code_table(fetch_symbol(address, b)));
  1449.       end loop;
  1450.       return result;
  1451.    end encoding_of;
  1452.
  1453.    current_case : KDF9_char_sets.symbol := KDF9_char_sets.Case_Normal;
  1454.
  1455.    function interpretation_of (address : KDF9.address)
  1456.    return converted_word is
  1457.       result : converted_word;
  1458.       symbol : KDF9_char_sets.symbol;
  1459.       char   : Character;
  1460.    begin
  1461.       for b in KDF9_char_sets.symbol_index loop
  1462.          symbol := fetch_symbol(address, b);
  1463.          if current_case = KDF9_char_sets.Case_Normal then
  1464.             char := TP_CN(symbol);
  1465.          else
  1466.             char := TP_CS(symbol);
  1467.          end if;
  1468.          if symbol = KDF9_char_sets.Case_Normal then
  1469.             current_case := KDF9_char_sets.Case_Normal;
  1470.          elsif symbol = KDF9_char_sets.Case_Shift then
  1471.             current_case := KDF9_char_sets.Case_Shift;
  1472.          end if;
  1473.          result(Natural(b)+1) := glyph_for(char);
  1474.       end loop;
  1475.       return result;
  1476.    end interpretation_of;
  1477.
  1478.    function case_visible (address : KDF9.address)
  1479.    return converted_word
  1480.    is (interpretation_of(address));
  1481.
  1482.    function case_normal (address : KDF9.address)
  1483.    return converted_word
  1484.    is (encoding_of(address, code_table => TP_CN));
  1485.
  1486.    function case_shift (address : KDF9.address)
  1487.    return converted_word
  1488.    is (encoding_of(address, code_table => TP_CS));
  1489.
  1490.    function printer_code (address : KDF9.address)
  1491.    return converted_word
  1492.    is (encoding_of(address, code_table => to_LP));
  1493.
  1494.    function card_code (address : KDF9.address)
  1495.    return converted_word
  1496.    is (encoding_of(address, code_table => to_CP));
  1497.
  1498.    function Latin_1_code (address : KDF9.address)
  1499.    return converted_word
  1500.    is (converted_word'(1..7 => Space,
  1501.                        8    => glyph_for(Character'Val(fetch_word(address) and 8#377#))));
  1502.
  1503.    procedure show_core_in_case_visible (first, last : in KDF9.address) is
  1504.    begin
  1505.       show_core(first, last,
  1506.                 head => "characters in TR/TP code with case shifting",
  1507.                 side => "  ",
  1508.                 converted => case_visible'Access);
  1509.    end show_core_in_case_visible;
  1510.
  1511.    procedure show_core_in_case_normal (first, last : in KDF9.address) is
  1512.    begin
  1513.       show_core(first, last,
  1514.                 head => "characters in TR/TP Normal Case code",
  1515.                 side => "NC",
  1516.                 converted => case_normal'Access);
  1517.    end show_core_in_case_normal;
  1518.
  1519.    procedure show_core_in_case_shift (first, last : in KDF9.address) is
  1520.    begin
  1521.       show_core(first, last,
  1522.                 head => "characters in TR/TP Shift Case code",
  1523.                 side => "SC",
  1524.                 converted => case_shift'Access);
  1525.    end show_core_in_case_shift;
  1526.
  1527.    procedure show_core_in_print_code (first, last : in KDF9.address) is
  1528.    begin
  1529.       show_core(first, last,
  1530.                 head => "characters in LP code",
  1531.                 side => "LP",
  1532.                 converted => printer_code'Access);
  1533.    end show_core_in_print_code;
  1534.
  1535.    procedure show_core_in_card_code (first, last : in KDF9.address) is
  1536.    begin
  1537.       show_core(first, last,
  1538.                 head => "characters in CR/CP code",
  1539.                 side => "CP",
  1540.                 converted => card_code'Access);
  1541.    end show_core_in_card_code;
  1542.
  1543.    procedure show_core_in_Latin_1 (first, last : in KDF9.address) is
  1544.    begin
  1545.       show_core(first, last,
  1546.                 head => "words with bits 40-47 of each in Latin-1 code",
  1547.                 side => "L1",
  1548.                 converted => Latin_1_code'Access);
  1549.    end show_core_in_Latin_1;
  1550.
  1551.    procedure show_core_in_tape_code (first, last : in KDF9.address) is
  1552.    begin
  1553.       show_core_in_case_visible(first, last);
  1554.    end show_core_in_tape_code;
  1555.
  1556.    procedure save_core_image is
  1557.    begin
  1558.       BA := 0; -- Ensure that physical store is examined when running in boot mode.
  1559.       log("#");
  1560.       log(oct_of(get_whole_program_size, min_digits => 5));
  1561.       log_new_line;
  1562.       for address in 0 .. get_whole_program_size loop
  1563.          log("#");
  1564.          log(oct_of(KDF9.Q_part(address), min_digits => 5));
  1565.          log(" ");
  1566.          log_octal(fetch_word(address), width => 16);
  1567.          log_new_line;
  1568.       end loop;
  1569.       log_rule;
  1570.    end save_core_image;
  1571.
  1572.    procedure show_core_as_word_forms (start, finish : in KDF9.address; octal_option : in Boolean) is
  1573.
  1574.       first : constant KDF9.address := bounded_data_address(start);
  1575.       last  : constant KDF9.address := bounded_data_address(finish);
  1576.
  1577.       procedure show_word (address : KDF9.address) is
  1578.          word  : constant KDF9.word := fetch_word(address);
  1579.          label : constant String := data_label(address, octal_option);
  1580.       begin
  1581.          if label(1) = 'V' then
  1582.             log_new_line;
  1583.          end if;
  1584.          log(label);
  1585.          log_line(":");
  1586.          show_in_various_formats(word);
  1587.          log_new_line;
  1588.       end show_word;
  1589.
  1590.       procedure show_word_group (first, last  : KDF9.address) is
  1591.          last_address : KDF9.address := first;
  1592.          this_word, last_word : KDF9.word;
  1593.       begin
  1594.          if last in first | 0 then
  1595.             show_word(last);
  1596.             return;
  1597.          end if;
  1598.          this_word := fetch_word(first);
  1599.          last_word := this_word;
  1600.          show_word(first);
  1601.          for address in first+1 .. last-1 loop
  1602.             this_word := fetch_word(address);
  1603.             if this_word = last_word and address = last_address+1 then
  1604.                log_new_line;
  1605.                log_line("==========  ditto  ========");
  1606.             elsif this_word /= last_word then
  1607.                show_word(address);
  1608.                last_word := this_word;
  1609.                last_address := address;
  1610.             end if;
  1611.          end loop;
  1612.          if last > first then
  1613.             show_word(last);
  1614.          end if;
  1615.       end show_word_group;
  1616.
  1617.    begin
  1618.       if last < start then
  1619.          log_title(
  1620.                    "Address range #"
  1621.                  & oct_of(start)
  1622.                  & " .. #"
  1623.                  & oct_of(finish)
  1624.                  & "], to be given as 48-bit words, is outside the allocated core."
  1625.                   );
  1626.          log_rule;
  1627.          return;
  1628.       end if;
  1629.       BA := 0; -- Ensure that physical store is examined when running in boot mode.
  1630.       log_title("Core store interpreted as 48-bit words:");
  1631.       show_word_group(first, last);
  1632.       log_rule;
  1633.    end show_core_as_word_forms;
  1634.
  1635.    -- Each word of code space is described by a set of flags.
  1636.    -- Flags 0 .. 5 are set iff a jump order has that syllable as target.
  1637.    -- Flag 6 is set if the word is thought to be code, but not a target.
  1638.    -- Flag 7 is set if the word is thought to be addressed as data.
  1639.
  1640.    package word_flags is new generic_sets(member => KDF9.syllable_index);
  1641.    use word_flags;
  1642.
  1643.    is_a_code_word   : constant KDF9.syllable_index := 6;
  1644.    is_a_data_word   : constant KDF9.syllable_index := 7;
  1645.    all_jump_targets : constant word_flags.set := (6|7 => False, others => True);
  1646.
  1647.    analysis_flags   : array (KDF9.code_address) of word_flags.set;
  1648.
  1649.    function "/" (word : KDF9.code_address; flag : KDF9.syllable_index)
  1650.    return Boolean
  1651.    is (analysis_flags(word)/flag);
  1652.
  1653.    function is_a_jump_target (the_point : in KDF9.syllable_address)
  1654.    return Boolean
  1655.    is (analysis_flags(the_point.code_address)/the_point.syllable_index);
  1656.
  1657.    function is_a_jump_target (the_operand : in KDF9.code_address)
  1658.    return Boolean
  1659.    is ((analysis_flags(the_operand) and all_jump_targets) /= empty_set);
  1660.
  1661.    procedure clear_all_analysis_flags is
  1662.    begin
  1663.       analysis_flags := (others => empty_set);
  1664.    end clear_all_analysis_flags;
  1665.
  1666.    procedure unmark_as_a_data_word (the_operand : in KDF9.code_address) is
  1667.    begin
  1668.       analysis_flags(the_operand)(is_a_data_word) := False;
  1669.    end unmark_as_a_data_word;
  1670.
  1671.    procedure unmark_as_a_code_word (the_operand : in KDF9.code_address) is
  1672.    begin
  1673.       analysis_flags(the_operand)(is_a_code_word) := False;
  1674.    end unmark_as_a_code_word;
  1675.
  1676.    procedure mark_as_a_code_word (the_operand : in KDF9.code_address) is
  1677.    begin
  1678.       analysis_flags(the_operand)(is_a_code_word) := True;
  1679.       unmark_as_a_data_word(the_operand);
  1680.    end mark_as_a_code_word;
  1681.
  1682.    procedure mark_as_a_jump_target (the_point : in KDF9.syllable_address) is
  1683.    begin
  1684.       analysis_flags(the_point.code_address)(the_point.syllable_index) := True;
  1685.       mark_as_a_code_word(the_point.code_address);
  1686.    end mark_as_a_jump_target;
  1687.
  1688.    procedure mark_as_a_data_word (the_operand : in KDF9.code_address) is
  1689.    begin
  1690.       analysis_flags(the_operand)(is_a_data_word) := True;
  1691.       unmark_as_a_code_word(the_operand);
  1692.    end mark_as_a_data_word;
  1693.
  1694.    procedure mark_all_code_blocks (the_beginning : in KDF9.syllable_address) is
  1695.       address : KDF9.syllable_address := the_beginning;
  1696.    begin
  1697.       if address.code_address < 2 then
  1698.          return;  -- We already know this is code.
  1699.       end if;
  1700.       if address.syllable_index > 5 then
  1701.          return;  -- We have blundered into non-code words.
  1702.       end if;
  1703.       if is_a_jump_target(address) then
  1704.          return;  -- We have already handled this word.
  1705.       end if;
  1706.       -- Mark the first syllable of the block.
  1707.       mark_as_a_jump_target(the_beginning);
  1708.       -- Mark the destinations of all jumps in the block as code.
  1709.       loop
  1710.       -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1711.       exit when address.code_address = 8191;
  1712.          set_NIA_to(address);
  1713.          decode_the_next_order;
  1714.          if is_an_invalid_order(INS)                                                  or else
  1715.                (address.code_address/is_a_data_word and address.syllable_index = 0) then
  1716.             mark_as_a_data_word(address.code_address);
  1717.             return;
  1718.          else
  1719.             -- Assuming a valid code word, act on it.
  1720.             mark_as_a_code_word(address.code_address);
  1721.             case INS.kind is
  1722.                when normal_jump_order =>
  1723.                   if not is_a_jump_target(INS.target) then
  1724.                      -- Mark the jump's destination recursively.
  1725.                      -- N.B. EXIT is actioned only if it is of EXIT ARr type.
  1726.                      mark_all_code_blocks(INS.target);
  1727.                   end if;
  1728.                   increment_by_3(address);
  1729.                   if is_an_unconditional_jump(INS) then
  1730.                      -- What follows is either data or a jump target.
  1731.                      return;
  1732.                   end if;
  1733.                when one_syllable_order =>
  1734.                   increment_by_1(address);
  1735.                   if INS.order.syllable_0 = 0 then
  1736.                      -- This assumes that a valid code word does not contain DUMMY0.
  1737.                      -- That may not be true of code generated by KAlgol.
  1738.                      return;
  1739.                   end if;
  1740.                when two_syllable_order =>
  1741.                   if INS.compressed_opcode = JCqNZS then
  1742.                      -- Mark the preceding word.
  1743.                      mark_as_a_jump_target((address.code_address-1, 0));
  1744.                   end if;
  1745.                   increment_by_2(address);
  1746.                when data_access_order =>
  1747.                   increment_by_3(address);
  1748.             end case;
  1749.          end if;
  1750.       end loop;
  1751.    end mark_all_code_blocks;
  1752.
  1753.    procedure mark_all_data_blocks (the_beginning : in KDF9.syllable_address) is
  1754.       address : KDF9.syllable_address := the_beginning;
  1755.    begin
  1756.       if address.syllable_index > 5 then
  1757.          return;  -- We have blundered into non-code words.
  1758.       end if;
  1759.
  1760.    the_code_block_handler: loop
  1761.       -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1762.    exit the_code_block_handler when address.code_address = 8191;
  1763.
  1764.          -- Deal with the possibility that we actually have a word of instruction code.
  1765.          set_NIA_to(address);
  1766.          decode_the_next_order;
  1767.
  1768.          if (is_an_invalid_order(INS)                         or else
  1769.                address.code_address/is_a_data_word)     and then
  1770.                   not (address.code_address/is_a_code_word) then
  1771.
  1772.             -- This word is data: make sure it is not designated as code;
  1773.             --    and find the start of the next code block.
  1774.             for a in address.code_address .. 8190 loop
  1775.                address := (a, 0);
  1776.             exit when is_a_jump_target(a);
  1777.                unmark_as_a_code_word(a);
  1778.                mark_as_a_data_word(a);
  1779.             end loop;
  1780.    exit the_code_block_handler when address.code_address = 8190;
  1781.             -- Find the syllable at which the block starts.
  1782.             for s in KDF9.syllable_index'(0) .. 5 loop
  1783.                address.syllable_index := s;
  1784.             exit when is_a_jump_target(address);
  1785.             end loop;
  1786.
  1787.          else
  1788.
  1789.             -- We have a order, so act on it.
  1790.             case INS.kind is
  1791.                when data_access_order =>
  1792.                   -- Note the operand word as data, not code.
  1793.                   if INS.operand < 8192 then
  1794.                      declare
  1795.                         operand : constant KDF9.code_address
  1796.                                 := KDF9.code_address(INS.operand);
  1797.                      begin
  1798.                         if INS.compressed_opcode /= KDF9.decoding.SET and then
  1799.                               not is_a_jump_target(operand)               then
  1800.                            mark_as_a_data_word(operand);
  1801.                         end if;
  1802.                      end;
  1803.                   end if;
  1804.                   increment_by_3(address);
  1805.                when one_syllable_order =>
  1806.                   increment_by_1(address);
  1807.                when two_syllable_order =>
  1808.                   increment_by_2(address);
  1809.                when normal_jump_order =>
  1810.                   increment_by_3(address);
  1811.             end case;
  1812.          end if;
  1813.
  1814.       exit the_code_block_handler when address.code_address = KDF9.code_address'Last;
  1815.       end loop the_code_block_handler;
  1816.    end mark_all_data_blocks;
  1817.
  1818.    procedure reset_wrong_data_marks (the_beginning : in KDF9.syllable_address) is
  1819.       address : KDF9.syllable_address := the_beginning;
  1820.       locus   : KDF9.code_address;
  1821.    begin
  1822.       if address.syllable_index > 5 then
  1823.          return;  -- We have blundered into non-code words.
  1824.       end if;
  1825.       -- Unmark the first instruction of the block.
  1826.       unmark_as_a_data_word(address.code_address);
  1827.
  1828.       -- Unmark data marks on destinations of jumps.
  1829.       loop
  1830.       -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  1831.       exit when address.code_address = 8191;
  1832.          set_NIA_to(address);
  1833.          decode_the_next_order;
  1834.
  1835.          if is_an_invalid_order(INS)                          or else
  1836.                address.code_address/is_a_data_word       or else
  1837.                   not (address.code_address/is_a_code_word) then
  1838.             -- We have reached the end of the code block.
  1839.             return;
  1840.
  1841.          else
  1842.
  1843.             -- We have a valid order, so act on it.
  1844.             case INS.kind is
  1845.                when normal_jump_order =>
  1846.                   locus := address.code_address;
  1847.                   increment_by_3(address);
  1848.                   if INS.target.code_address/is_a_data_word    then
  1849.                      -- UNmark the jump's destination recursively.
  1850.                      reset_wrong_data_marks(INS.target);
  1851.                   end if;
  1852.                   if INS.compressed_opcode /= Jr          and then
  1853.                         INS.compressed_opcode /= EXIT_n   and then
  1854.                            locus /= address.code_address then
  1855.                      -- The order flows on, so the next word cannot be data.
  1856.                      unmark_as_a_data_word(address.code_address);
  1857.                   elsif not (address.code_address/is_a_data_word) then
  1858.                      -- The next syllable starts a block, iff it is not the end of a block.
  1859.                      set_NIA_to(address);
  1860.                      decode_the_next_order;
  1861.                      if not is_an_invalid_order(INS) then
  1862.                         mark_as_a_jump_target(address);
  1863.                      end if;
  1864.                   end if;
  1865.                when one_syllable_order =>
  1866.                   increment_by_1(address);
  1867.                when two_syllable_order =>
  1868.                   increment_by_2(address);
  1869.                when data_access_order =>
  1870.                   increment_by_3(address);
  1871.             end case;
  1872.          end if;
  1873.       exit when address.code_address = KDF9.code_address'Last;
  1874.       end loop;
  1875.    end reset_wrong_data_marks;
  1876.
  1877.    procedure mark_the_words_reachable_from (address : in KDF9.syllable_address) is
  1878.       start_point : KDF9.syllable_address;
  1879.    begin
  1880.       mark_as_a_jump_target(address);
  1881.       set_NIA_to(address);
  1882.       decode_the_next_order;
  1883.       if INS.kind = normal_jump_order then
  1884.          start_point := INS.target;
  1885.          mark_all_code_blocks(start_point);
  1886.          mark_all_data_blocks(start_point);
  1887.          reset_wrong_data_marks(start_point);
  1888.       end if;
  1889.    end mark_the_words_reachable_from;
  1890.
  1891.    procedure mark_all_jump_targets (start_point, end_point : in KDF9.syllable_address) is
  1892.       address : KDF9.syllable_address := start_point;
  1893.    begin
  1894.       mark_as_a_jump_target(address);
  1895.       loop
  1896.       exit when address.code_address > end_point.code_address;
  1897.       exit when address.code_address / is_a_data_word;
  1898.          set_NIA_to(address);
  1899.          decode_the_next_order;
  1900.          case INS.kind is
  1901.             when data_access_order =>
  1902.                increment_by_3(address);
  1903.             when one_syllable_order =>
  1904.                increment_by_1(address);
  1905.             when two_syllable_order =>
  1906.                increment_by_2(address);
  1907.             when normal_jump_order =>
  1908.                if INS.kind = normal_jump_order then
  1909.                   mark_as_a_jump_target(INS.target);
  1910.                end if;
  1911.                increment_by_3(address);
  1912.          end case;
  1913.       end loop;
  1914.    end mark_all_jump_targets;
  1915.
  1916.    procedure do_symbol_table_based_markup is
  1917.       subtype own is KDF9.code_address;
  1918.       T      : non_V_store_table renames the_WYZ_table;
  1919.       limit  : KDF9.Q_part;
  1920.    begin
  1921.       -- Mark the whole of core as data by default.
  1922.       for a in KDF9.code_address loop
  1923.          mark_as_a_data_word(a);
  1924.       end loop;
  1925.       -- Mark the code word of each Usercode routine.
  1926.       for e in 0 .. last_P_number loop
  1927.          -- Mark the order words of P[e].
  1928.          if e = last_P_number then
  1929.             limit := KDF9.Q_part(bounded_code_address(T.W_base).code_address);
  1930.          else
  1931.             limit := P_store_base(e+1).V_address;
  1932.             if limit = 0 then
  1933.                -- P(e+1) has no V stores, so use its code address instead.
  1934.                limit := P_store_base(e+1).P_address;
  1935.             end if;
  1936.          end if;
  1937.          for a in own(P_store_base(e).P_address) .. own(limit-1) loop
  1938.             mark_as_a_code_word(own(a));
  1939.          end loop;
  1940.          -- Ensure that internal labels of this routine are flagged.
  1941.          mark_all_jump_targets((own(P_store_base(e).P_address), 0), (own(limit), 0));
  1942.       end loop;
  1943.       -- Restore data marking of W0 in case limit = W_base.
  1944.       mark_as_a_data_word(own(bounded_code_address(T.W_base).code_address));
  1945.    end do_symbol_table_based_markup;
  1946.
  1947.    procedure markup_a_problem_program is
  1948.    begin
  1949.       if the_initial_jump_was_corrupted then
  1950.          -- We cannot sensibly locate the order words using E0  ...
  1951.          log_new_line;
  1952.          log_line("The initial jump, in E0U, has been corrupted!");
  1953.          log_new_line;
  1954.          show_core_as_syllables((0, syllable_index => 0), (0, syllable_index => 5));
  1955.          --  ... so restore it to the value it had on loading.
  1956.          restore_the_initial_jump;
  1957.          log_line("E0U has been restored to the value it had on loading.");
  1958.          log_new_line;
  1959.       end if;
  1960.
  1961.       if last_P_number = 0 then
  1962.          -- There is no symbol table, so we have to do a flow analysis.
  1963.          -- Mark all orders reachable from the initial jump in E0 and the restart jumps in E4.
  1964.
  1965.          mark_the_words_reachable_from((0, syllable_index => 0));
  1966.          mark_the_words_reachable_from((4, syllable_index => 0));
  1967.          mark_the_words_reachable_from((4, syllable_index => 3));
  1968.
  1969.          -- Mark the words between E0 and P0 as data, skipping E4.
  1970.          mark_as_a_data_word(1);
  1971.          mark_as_a_data_word(2);
  1972.          mark_as_a_data_word(3);
  1973.          set_NIA_to((0, syllable_index => 0));
  1974.          decode_the_next_order;
  1975.          for d in 5 .. INS.target.code_address-1 loop
  1976.             mark_as_a_data_word(d);
  1977.          end loop;
  1978.
  1979.       else
  1980.          -- We have a symbol table, enable 100% accurate markup.
  1981.          do_symbol_table_based_markup;
  1982.          mark_as_a_code_word(0);
  1983.          mark_as_a_data_word(1);
  1984.          mark_as_a_data_word(2);
  1985.          mark_as_a_data_word(3);
  1986.          mark_as_a_code_word(4);
  1987.          mark_as_a_data_word(5);
  1988.          mark_as_a_data_word(6);
  1989.          mark_as_a_data_word(7);
  1990.       end if;
  1991.
  1992.       the_program_has_been_analysed := True;
  1993.    end markup_a_problem_program;
  1994.
  1995.    -- This analysis assumes that the Director has much the same structure as KKT40E007UPU.
  1996.    procedure markup_a_Director (pre_run : in Boolean) is
  1997.    begin
  1998.       the_program_has_been_analysed := False;
  1999.       BA := 0;  -- Director starts at physical word 0.
  2000.
  2001.       -- It does not have a jump in E0U, unlike problem programs.
  2002.       -- Instead it has a fixed sequence of orders to reset the hardware.
  2003.       -- Before intialization, it is: K4; SHL+63; =+Q0; with the code: #3740416437675016.
  2004.       -- After intialization,  it is: Q0; SHL+63; =+Q0; with the code: #3620716437675016.
  2005.
  2006.        -- Check that we do actually have a Director to examine.
  2007.
  2008.       if pre_run then
  2009.          if fetch_word(0) /= 8#3740416437675016# then
  2010.             log_line("The loaded program is not a Director bootstrap!");
  2011.             return;
  2012.          else
  2013.             log_line("The loaded program is a Director bootstrap.");
  2014.          end if;
  2015.
  2016.          -- The jumps in E2 and E4 are absent until after Director's initialzation,
  2017.          --    so they are not present in a pre-run state.
  2018.          -- All 9 words of the bootstrap are filled with instructions.
  2019.          for w in code_address'(0) .. 8 loop
  2020.             mark_as_a_code_word(w);
  2021.          end loop;
  2022.          mark_as_a_jump_target((0, 0));
  2023.          the_program_has_been_analysed := True;
  2024.          return;
  2025.       end if;
  2026.
  2027.       if fetch_word(0) /= 8#3620716437675016# then
  2028.          log_line("The loaded program is not a Director!");
  2029.          return;
  2030.       else
  2031.          log_line("The loaded program is a Director.");
  2032.       end if;
  2033.
  2034.       -- An initialised Director has a number of jumps in words 2 and 4, but not word 0.
  2035.       -- Give up if these are absent.
  2036.
  2037.       set_NIA_to((2, syllable_index => 0));
  2038.       decode_the_next_order;
  2039.       if INS.kind /= normal_jump_order then
  2040.          log_line("An expected jump, in E2U, has not been found!");
  2041.          return;
  2042.       end if;
  2043.       mark_as_a_jump_target((2, syllable_index => 0));
  2044.       mark_the_words_reachable_from((2, syllable_index => 0));
  2045.       mark_as_a_jump_target(INS.target);
  2046.       set_NIA_to((4, syllable_index => 0));
  2047.       decode_the_next_order;
  2048.       if INS.kind /= normal_jump_order then
  2049.          log_line("An expected jump, in E4U, has not been found!");
  2050.          return;
  2051.       end if;
  2052.       mark_as_a_jump_target((4, syllable_index => 0));
  2053.       mark_the_words_reachable_from((4, syllable_index => 0));
  2054.       mark_as_a_jump_target(INS.target);
  2055.
  2056.       set_NIA_to((4, syllable_index => 3));
  2057.       decode_the_next_order;
  2058.       if INS.kind /= normal_jump_order then
  2059.          log_line("An expected jump, in E4L, has not been found!");
  2060.          return;
  2061.       end if;
  2062.       mark_as_a_jump_target((4, syllable_index => 3));
  2063.       mark_the_words_reachable_from((4, syllable_index => 3));
  2064.       mark_as_a_jump_target(INS.target);
  2065.
  2066.       -- E0 is marked because interrupts cause a jump to it, in effect.
  2067.       mark_as_a_jump_target((0, syllable_index => 0));
  2068.
  2069.       -- Mark E3 and E5 through AP0 - 1 as data words.
  2070.       mark_as_a_data_word(3);
  2071.       set_NIA_to((2, 0));
  2072.       decode_the_next_order;
  2073.       for d in 5 .. INS.target.code_address-1 loop
  2074.          mark_as_a_data_word(d);
  2075.       end loop;
  2076.
  2077.       the_program_has_been_analysed := True;
  2078.    end markup_a_Director;
  2079.
  2080.    procedure mark_all_code_blocks_and_data_blocks (pre_run : in Boolean) is
  2081.    begin
  2082.       clear_all_analysis_flags;
  2083.       if the_execution_mode = boot_mode  then
  2084.          markup_a_Director(pre_run);
  2085.       else
  2086.          markup_a_problem_program;
  2087.       end if;
  2088.    end mark_all_code_blocks_and_data_blocks;
  2089.
  2090.    procedure show_core_as_Usercode (first, last : in KDF9.syllable_address; octal_option : in Boolean) is
  2091.
  2092.       final       : constant KDF9.syllable_address := bounded_code_address(last);
  2093.       six_DUMMIES : constant KDF9.word := 8#0360741703607417#;
  2094.       prev_word   : KDF9.word := 8#0706050403020100#; -- invalid opcodes
  2095.       comparator  : KDF9.word := prev_word;
  2096.       address     : KDF9.syllable_address;
  2097.       this_word   : KDF9.word;
  2098.
  2099.       procedure show_a_block_of_orders (address : in out KDF9.syllable_address) is
  2100.
  2101.          function is_a_store_order (decoded : KDF9.decoded_order)
  2102.          return Boolean
  2103.          is (
  2104.              if decoded.kind = one_syllable_order then
  2105.                 False
  2106.              elsif decoded.kind = two_syllable_order then
  2107.                 (
  2108.                  case decoded.compressed_opcode is
  2109.                    when TO_MkMq   | TO_MkMqQ
  2110.                       | TO_MkMqH  | TO_MkMqQH
  2111.                       | TO_MkMqN  | TO_MkMqQN
  2112.                       | TO_MkMqHN | TO_MkMqQHN
  2113.                       | TO_Kq     | TO_LINK    => True,
  2114.                    when others                 => False
  2115.                 )
  2116.              elsif decoded.kind = data_access_order then
  2117.                 (
  2118.                  case decoded.compressed_opcode is
  2119.                     when TO_EaMq | TO_EaMqQ => True,
  2120.                     when others             => False
  2121.                 )
  2122.              else
  2123.                 False
  2124.             );
  2125.
  2126.          procedure set_line_at_minimum (tab : in Natural) is
  2127.          begin
  2128.             if panel_logger.column < tab then
  2129.                tab_log_to(tab);
  2130.             end if;
  2131.          end set_line_at_minimum;
  2132.
  2133.          procedure set_line_at (tab : in Natural) is
  2134.          begin
  2135.             if panel_logger.column > tab then
  2136.                log_new_line;
  2137.             end if;
  2138.             if panel_logger.column < tab then
  2139.                tab_log_to(tab);
  2140.             end if;
  2141.          end set_line_at;
  2142.
  2143.          procedure set_at_new_line is
  2144.          begin
  2145.             if panel_logger.column > 1 then
  2146.                log_new_line;
  2147.             end if;
  2148.          end set_at_new_line;
  2149.
  2150.       begin -- show_a_block_of_orders
  2151.          this_word := fetch_word(KDF9.address(address.code_address));
  2152.
  2153.          -- Handle data words and dummy words.
  2154.          if address.code_address/is_a_data_word then
  2155.             set_at_new_line;
  2156.          elsif this_word in not 0 | 0 | six_DUMMIES then
  2157.             -- The word is not worth logging.  Step on.
  2158.             address := (address.code_address+1, 0);
  2159.             return;
  2160.          end if;
  2161.
  2162.          loop
  2163.             if address.code_address/is_a_data_word then
  2164.                this_word := fetch_word(KDF9.address(address.code_address));
  2165.                -- Display a line of data.
  2166.                declare
  2167.                   label : constant String := data_label(KDF9.Q_part(address.code_address), octal_option);
  2168.                begin
  2169.                   if label(1..2) = "V0" then
  2170.                      -- The routine has V stores, so leave a gap here.
  2171.                      log_new_line;
  2172.                   end if;
  2173.                   log(label & ": ");
  2174.                end;
  2175.                if this_word = 0 then
  2176.                   log_line("zero");
  2177.                else
  2178.                   log_new_line;
  2179.                   show_in_various_formats(fetch_word(KDF9.address(address.code_address)));
  2180.                   log_new_line;
  2181.                end if;
  2182.          exit when address.code_address >= last.code_address;
  2183.                address := (address.code_address+1, 0);
  2184.             else
  2185.          exit; -- We have reached code.
  2186.             end if;
  2187.          end loop;
  2188.
  2189.          -- Handle instruction words.
  2190.          loop
  2191.          -- Setting NIA to 8191 LIVs, in accordance with the hardware, so avoid that.
  2192.          exit when address.code_address = 8191;
  2193.          exit when address.code_address > last.code_address;
  2194.             this_word := fetch_word(KDF9.address(address.code_address));
  2195.
  2196.             -- Suppress output of more than 1 of a block of equal values.
  2197.             if this_word = comparator and this_word = prev_word then
  2198.                -- The word is not worth logging.  Step on.
  2199.                address := (address.code_address+1, 0);
  2200.                return;
  2201.             end if;
  2202.
  2203.             if this_word in not 0 | 0 | six_DUMMIES then
  2204.                -- Take this word as the new basis for comparison.
  2205.                comparator := this_word;
  2206.             end if;
  2207.
  2208.             -- This updates the Instruction word buffers.  Nasty side effect that has to be undone!
  2209.             set_NIA_to(address);
  2210.             decode_the_next_order;
  2211.             if is_an_invalid_order(INS) then
  2212.                -- The word is not worth logging.  Step on.
  2213.                address := (address.code_address+1, 0);
  2214.                return;
  2215.             end if;
  2216.
  2217.             if is_a_jump_target(address) then
  2218.                -- Jumps go at the start of a fresh line for best visibility.
  2219.                -- Label the jump with its address at the start of the line for easy reference.
  2220.                set_at_new_line;
  2221.                if address.syllable_index = 0 then
  2222.                   declare
  2223.                      label : constant String := routine_name(address, octal_option);
  2224.                   begin
  2225.                      if label(1) = 'P' and then V_store_count(address) = 0 then
  2226.                         -- The routine has no V stores listed, so leave a gap here.
  2227.                         log_new_line;
  2228.                      end if;
  2229.                      log_line(label & ": ");
  2230.                   end;
  2231.                else
  2232.                   log_line("E" & oct_and_dec_of(address, octal_option, ", E", "") & ": ");
  2233.                end if;
  2234.             end if;
  2235.
  2236.             -- Set the tab position appropriately for the order type.
  2237.             case INS.kind is
  2238.                when one_syllable_order | data_access_order =>
  2239.                   set_line_at_minimum(first_tab);
  2240.                when two_syllable_order =>
  2241.                   case INS.compressed_opcode is
  2242.                      when JCqNZS =>
  2243.                         set_line_at(jump_tab);
  2244.                      when CT_PMB_PMC_BUSY_Qq
  2245.                         | PAR_Qq
  2246.                         | PMF_PMG_Qq
  2247.                         | PIA_PIC_CLO_TLO_Qq
  2248.                         | PIB_PID_Qq
  2249.                         | PIE_PIG_Qq
  2250.                         | PIF_PIH_Qq
  2251.                         | POA_POC_POE_POF_PMH_Qq
  2252.                         | POB_POD_Qq
  2253.                         | POG_POL_Qq
  2254.                         | POH_POK_Qq
  2255.                         | PMA_PMK_INT_Qq
  2256.                         | PMA_PMK_INT_Qq+1
  2257.                         | PMD_PME_PML_Qq
  2258.                         | PMD_PME_PML_Qq+1 =>
  2259.                         set_line_at(first_tab);
  2260.                      when TO_Kq =>
  2261.                         set_line_at(jump_tab);
  2262.                      when others =>
  2263.                         if panel_logger.column < first_tab then
  2264.                            set_line_at_minimum(first_tab);
  2265.                         end if;
  2266.                   end case;
  2267.                when normal_jump_order =>
  2268.                   set_line_at(jump_tab);
  2269.             end case;
  2270.
  2271.             -- Show the order in pseudo-Usercode format.
  2272.             log(the_full_name_of(INS, octal_option));
  2273.             log(closer(INS, address, octal_option));
  2274.
  2275.             case INS.kind is
  2276.                when one_syllable_order =>
  2277.                   increment_by_1(address);
  2278.                when two_syllable_order =>
  2279.                   increment_by_2(address);
  2280.                when normal_jump_order | data_access_order =>
  2281.                   increment_by_3(address);
  2282.             end case;
  2283.
  2284.             if address.code_address = last.code_address then
  2285.                -- All done with this block.
  2286.                log_new_line;
  2287.                return;
  2288.             end if;
  2289.
  2290.             if (address.code_address)/is_a_data_word then
  2291.                -- We have reached the end of the orders and are about to run into data.
  2292.                return;
  2293.             end if;
  2294.
  2295.             if is_a_store_order(INS)                                                 or else
  2296.                   (INS.kind = two_syllable_order and INS.compressed_opcode = JCqNZS) or else
  2297.                      INS.kind = normal_jump_order                                    or else
  2298.                         panel_logger.column > last_column                               then
  2299.                -- Make store to core and jump orders end their line for best visibility.
  2300.                log_new_line;
  2301.             elsif this_word = comparator and this_word /= prev_word then
  2302.                -- Display the placeholder of a suppressed group of equal words.
  2303.                log_line(" ...");
  2304.                address := (address.code_address+1, 0);
  2305.                if address.code_address > last.code_address or else
  2306.                      address.code_address/is_a_data_word           then
  2307.                   -- We have reached the end of the orders or are about to run into data.
  2308.                   return;
  2309.                end if;
  2310.             end if;
  2311.             prev_word := this_word;
  2312.
  2313.          end loop;
  2314.
  2315.       end show_a_block_of_orders;
  2316.
  2317.    begin -- show_core_as_Usercode
  2318.       if not the_program_has_been_analysed then
  2319.          mark_all_code_blocks_and_data_blocks(pre_run => False);
  2320.       end if;
  2321.       if the_program_has_been_analysed then
  2322.          log_line("Core store interpreted as instructions.");
  2323.           -- Ensure that physical store is examined when running in boot mode.
  2324.          BA := 0;
  2325.          address := first;
  2326.          loop
  2327.             show_a_block_of_orders(address);
  2328.             exit when address.code_address >= final.code_address;
  2329.          end loop;
  2330.          log_new_line;
  2331.          log_rule;
  2332.       else
  2333.          log_line(" ... Core store cannot be interpreted as instructions!");
  2334.          log_new_line;
  2335.       end if;
  2336.
  2337.       -- Restore NIA to its correct value for execution.
  2338.       set_NIA_to((0, syllable_index => 0));
  2339.    end show_core_as_Usercode;
  2340.
  2341.    procedure show_core_as_syllables (first, last : KDF9.syllable_address) is
  2342.
  2343.       address : KDF9.syllable_address;
  2344.
  2345.       procedure show_a_block is
  2346.
  2347.          procedure set_line_at (tab : Natural) is
  2348.          begin  -- set_line_at
  2349.             if panel_logger.column > tab then
  2350.                log_new_line;
  2351.             end if;
  2352.             if panel_logger.column < tab then
  2353.                tab_log_to(tab);
  2354.             end if;
  2355.          end set_line_at;
  2356.
  2357.       begin  -- show_a_block
  2358.          loop
  2359.             if address.syllable_index = 0 then
  2360.                log_new_line;
  2361.                log(oct_of(address) & ": ");
  2362.                set_line_at(jump_tab);
  2363.             end if;
  2364.             log(oct_of(fetch_syllable(address)) &  "; ");
  2365.             increment_by_1(address);
  2366.          exit when address.code_address > last.code_address;
  2367.          end loop;
  2368.          log_new_line;
  2369.       end show_a_block;
  2370.
  2371.     begin  -- show_core_as_syllables
  2372.        BA := 0; -- Ensure that physical store is examined when running in boot mode.
  2373.       log_line("Core store interpreted as order syllables.");
  2374.       address := bounded_code_address(first);
  2375.       loop
  2376.          exit when address.code_address > last.code_address;
  2377.          show_a_block;
  2378.       end loop;
  2379.       log_rule;
  2380.    end show_core_as_syllables;
  2381.
  2382.    procedure poke (address    : in KDF9.address;
  2383.                    sub_word   : in sub_word_flag;
  2384.                    position   : in KDF9.address;
  2385.                    value      : in KDF9.word) is
  2386.    begin
  2387.       case sub_word is
  2388.          when 'W' | 'w' =>
  2389.             store_word(value, address);
  2390.          when 'U' | 'u' =>
  2391.             store_halfword(value*2**24, address, 0);
  2392.          when 'L' | 'l' =>
  2393.             store_halfword(value*2**24, address, 1);
  2394.          when 'S' | 's' =>
  2395.             store_syllable(KDF9.syllable(value), address, KDF9.syllable_index(position));
  2396.          when 'C' | 'c' =>
  2397.             store_symbol(KDF9_char_sets.symbol(value), address, KDF9_char_sets.symbol_index(position));
  2398.       end case;
  2399.    end poke;
  2400.
  2401. end state_display;

Compiling: ../Source/state_display.ads
Source file time stamp: 2022-09-06 21:59:16
Compiled at: 2022-09-15 15:08:00

     1. -- Provide the comprehensive machine-state display panel KDF9 never had.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with dumping;
    18. with KDF9;
    19.
    20. use  dumping;
    21. use  KDF9;
    22.
    23. package state_display is
    24.
    25.    procedure show_all_prerun_dump_areas;
    26.
    27.    procedure show_CIA_and_NIA;
    28.
    29.    procedure show_V_and_T;
    30.
    31.    procedure show_NEST;
    32.
    33.    procedure show_SJNS;
    34.
    35.    procedure show_IO_register (the_Q_register : in KDF9.Q_register;
    36.                                width          : in Positive := 8;
    37.                                for_DR,
    38.                                for_FD,
    39.                                for_FH,
    40.                                for_seek,
    41.                                for_OUT         : in Boolean  := False);
    42.
    43.    procedure show_Q_register (the_Q_register : in KDF9.Q_register;
    44.                               width          : in Positive := 8);
    45.
    46.    procedure show_Q_store;
    47.
    48.    procedure show_registers;
    49.
    50.    procedure show_execution_context;
    51.
    52.    procedure long_witness;
    53.
    54.    procedure short_witness;
    55.
    56.    procedure log_an_external_trace_header (caption : in String := "");
    57.
    58.    procedure log_to_external_trace
    59.       with Inline => False;
    60.
    61.    procedure show_progress;
    62.
    63.    procedure show_Director_registers;
    64.
    65.    procedure show_retrospective_traces;
    66.
    67.    procedure show_current_state;
    68.
    69.    procedure show_final_state (because : String);
    70.
    71.    procedure mark_all_code_blocks_and_data_blocks (pre_run : in Boolean);
    72.
    73.    the_program_has_been_analysed : Boolean := False;
    74.
    75.    procedure save_core_image;
    76.
    77.    procedure show_core_as_word_forms (start, finish : in KDF9.address; octal_option : in Boolean);
    78.
    79.    procedure show_core_as_syllables (first, last : in KDF9.syllable_address);
    80.
    81.    procedure show_core_as_Usercode (first, last : in KDF9.syllable_address; octal_option : in Boolean);
    82.
    83.    procedure show_core_in_print_code (first, last : in KDF9.address);
    84.
    85.    procedure show_core_in_card_code (first, last : in KDF9.address);
    86.
    87.    procedure show_core_in_tape_code (first, last : in KDF9.address);
    88.
    89.    procedure show_core_in_case_normal (first, last : in KDF9.address);
    90.
    91.    procedure show_core_in_case_shift (first, last : in KDF9.address);
    92.
    93.    procedure show_core_in_Latin_1 (first, last : in KDF9.address);
    94.
    95.    -- poke is included here as it has the same relationship to dumping as show_core_*.
    96.    procedure poke (address    : in KDF9.address;
    97.                    sub_word   : in sub_word_flag;
    98.                    position   : in KDF9.address;
    99.                    value      : in KDF9.word);
   100.
   101.    -- Take note that an OUT 2 or OUT 0 has been obeyed.
   102.    procedure notify_state_display_of_final_ICR;
   103.
   104. end state_display;

 2401 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:01

     1. -- Emulation of the common functionality of a KDF9 "fast", i.e. word-by-word, devices.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.fast is
    18.
    19.    overriding
    20.    function is_open (the_buffer : fast.device)
    21.    return Boolean
    22.    is (the_buffer.stream.is_open);
    23.
    24.    overriding
    25.    procedure add_in_the_IO_CPU_time (the_buffer  : in fast.device;
    26.                                      bytes_moved : in KDF9.word) is
    27.       pragma Unreferenced(the_buffer);
    28.    begin
    29.       the_CPU_delta := the_CPU_delta + KDF9.us(bytes_moved + 7) / 8 * 6; -- 6s/word
    30.    end add_in_the_IO_CPU_time;
    31.
    32. end IOC.fast;

Compiling: ../Source/ioc-fast.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:01

     1. -- Emulation of the common functionality of a KDF9 "fast", i.e. word-by-word, devices.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. private with tracing;
    18.
    19. package IOC.fast is
    20.
    21.    --
    22.    -- This is the root type for all fast I/O device types.
    23.    --
    24.
    25.    type device is abstract new IOC.device with private;
    26.
    27. private
    28.
    29.    use tracing; pragma Warnings(Off, tracing);
    30.
    31.    type device is abstract new IOC.device with
    32.       record
    33.          switch_time,
    34.          latency_time,
    35.          elapsed_time  : KDF9.us := 0;
    36.          word_count,
    37.          switch_count,
    38.          latency_count : KDF9.word := 0;
    39.       end record;
    40.
    41.    overriding
    42.    function is_open (the_buffer : fast.device)
    43.    return Boolean;
    44.
    45.    overriding
    46.    procedure add_in_the_IO_CPU_time (the_buffer  : in fast.device;
    47.                                      bytes_moved : in KDF9.word);
    48.
    49. end IOC.fast;

 32 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-dr.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:01

     1. -- Emulation of a drum store.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.fast.DR is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    function as_DR_command (Q_operand : KDF9.Q_register; for_OUT : Boolean := False)
    22.    return String is
    23.       C, sector, track, drive :KDF9.Q_part;
    24.    begin
    25.       if for_OUT then
    26.          -- There is no buffer number.
    27.          C := Q_operand.C;
    28.       else
    29.          -- Get rid of the buffer number.
    30.          C := Q_operand.C / 16;
    31.       end if;
    32.       drive := C mod drums_per_system;
    33.       C := C  /  drums_per_system;
    34.       sector := C mod sectors_per_track;
    35.       track  := C mod sectors_per_drum / sectors_per_track;
    36.       return "D"
    37.            & dec_of(drive)
    38.            & "T"
    39.            & dec_of(track)
    40.            & "S"
    41.            & dec_of(sector);
    42.    end as_DR_command;
    43.
    44.    -- The host_IO stream for DR0 is used only to open and close the file.
    45.    -- I/O operations for the DR0 file are done with unmediated POSIX system calls.
    46.
    47.    function file_offset (sector_number : DR.drum_index)
    48.    return POSIX.file_position
    49.    is (bytes_per_sector * POSIX.file_position(sector_number));
    50.
    51.    procedure get (the_DR : in out DR.device; s : out sector; the_index : in KDF9.word) is
    52.       result : POSIX.file_position with Unreferenced;
    53.    begin
    54.       result := seek(fd_of(the_DR.stream), file_offset(the_index));
    55.       result := POSIX.file_position(read(fd_of(the_DR.stream), s, bytes_per_sector));
    56.    end get;
    57.
    58.    procedure put (the_DR : in out DR.device; s : in sector; the_index : in KDF9.word) is
    59.       result : POSIX.file_position with Unreferenced;
    60.    begin
    61.       result := seek(fd_of(the_DR.stream), file_offset(the_index));
    62.       result := POSIX.file_position(write(fd_of(the_DR.stream), s, bytes_per_sector));
    63.    end put;
    64.
    65.    overriding
    66.    procedure Initialize (the_DR : in out DR.device) is
    67.    begin
    68.       open(IOC.device(the_DR), rd_wr_mode);
    69.    exception
    70.       when others =>
    71.          trap_operator_error(the_DR.device_name + "cannot be opened for reading and writing");
    72.    end Initialize;
    73.
    74.    procedure keep_house (the_DR        : in out DR.device;
    75.                          transfer_size : in KDF9.word;
    76.                          busy_time     : out KDF9.us;
    77.                          from_core     : Boolean := True) is
    78.       full_sectors  : constant KDF9.word := transfer_size / bytes_per_sector;
    79.       residue       : constant KDF9.word := transfer_size mod bytes_per_sector;
    80.       total_sectors : constant KDF9.word := (if residue /= 0 then 1 else 0) + full_sectors;
    81.       gapping_time  : constant KDF9.us   := short_gap_time * KDF9.us(total_sectors-1)
    82.                                           + long_gap_time  * KDF9.us(total_sectors/sectors_per_track);
    83.    begin
    84.       the_DR.latency_count := the_DR.latency_count + 1;
    85.       the_DR.word_count := the_DR.word_count + transfer_size / 8;
    86.       if from_core then
    87.          add_in_the_IO_CPU_time(the_DR, bytes_moved => transfer_size);
    88.       end if;
    89.       busy_time :=  gapping_time + KDF9.us(transfer_size) * the_DR.quantum;
    90.    end keep_house;
    91.
    92.    procedure update_statistics (the_DR       : in out DR.device;
    93.                                 latency_time : in KDF9.us) is
    94.    begin
    95.       the_DR.latency_time := the_DR.latency_time + latency_time;
    96.    end update_statistics;
    97.
    98.    function angular_position (sector_number : sector_range)
    99.    return KDF9.us
   100.    is (KDF9.us(sector_number mod sectors_per_track * sector_time));
   101.
   102.    function latent_time (index : drum_index)
   103.    return KDF9.us is
   104.       sector_number : constant sector_range := sector_range(index mod sectors_per_track);
   105.       new_angle     : constant KDF9.us      := angular_position(sector_number);
   106.       old_angle     : constant KDF9.us      := the_clock_time mod track_time;
   107.       gap_time      : constant KDF9.us
   108.                     := (if old_angle > critical_time then short_gap_time else long_gap_time);
   109.       offset        : constant KDF9.us
   110.                     := (
   111.                         if   new_angle > old_angle
   112.                         then new_angle - old_angle
   113.                         else new_angle + track_time - old_angle
   114.                        );
   115.    begin
   116.       -- Hypothesis: we can pick up the next complete sector without a full latency delay,
   117.       --    if we are no closer to it than the start of its preceding inter-block gap.
   118.       return (if offset > gap_time then offset else track_time - offset);
   119.    end latent_time;
   120.
   121.    procedure validate_the_sector_number (the_DR : in out DR.device; sector_number : in KDF9.word) is
   122.    begin
   123.       if sector_number > sectors_per_system then
   124.          trap_failing_IO_operation(the_DR, "sector number too big =" & sector_number'Image);
   125.       end if;
   126.    end validate_the_sector_number;
   127.
   128.    function validated_drum_address (the_DR : in out DR.device; C_operand : KDF9.Q_part)
   129.    return KDF9.word is
   130.       result : constant KDF9.word := KDF9.word(C_operand / 16);
   131.    begin
   132.       -- We assume that the least significant 4 bits of the C operand are the buffer number,
   133.       --    that the next 2 bits specify one of 4 drums that can be fitted to the buffer,
   134.       --       and that the rest of the C operand is the sector number.
   135.       -- See the Drum Director KKT02E003UPU listing, routine P143 at label 1 et seq.
   136.       -- Returning C_operand / 16 treats the drums as consecutive sectors.
   137.       validate_the_sector_number(the_DR, result);
   138.       return result;
   139.    end validated_drum_address;
   140.
   141.    procedure increment (word_address : in out KDF9.address;
   142.                         symbol_nr    : in out KDF9_char_sets.symbol_index)
   143.       with Inline => True;
   144.
   145.    procedure increment (word_address : in out KDF9.address;
   146.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   147.    begin
   148.       if symbol_nr < 7 then
   149.          symbol_nr := symbol_nr + 1;
   150.       else
   151.          symbol_nr := 0;
   152.          word_address := word_address + 1;
   153.       end if;
   154.    end increment;
   155.
   156.    a_zero_sector   : constant DR.sector := (others => SP);
   157.
   158.    procedure read_drum (the_DR    : in out DR.device;
   159.                         Q_operand : in KDF9.Q_register) is
   160.       end_address  : constant KDF9.address := Q_operand.M;
   161.       next_address : KDF9.address := Q_operand.I;
   162.       the_sector   : DR.sector := a_zero_sector;
   163.       symbol_nr    : KDF9_char_sets.symbol_index;
   164.       size         : KDF9.word := 0;
   165.       the_index    : KDF9.word;
   166.       latency,
   167.       busy_time    : KDF9.us;
   168.    begin
   169.       check_addresses_and_lockouts(next_address, end_address);
   170.       the_index := validated_drum_address(the_DR, Q_operand.C);
   171.       latency := latent_time(the_index);
   172.       get(the_DR, the_sector, the_index);
   173.    sector_loop:
   174.       loop
   175.          if the_index > DR.drum_index'Last then
   176.             trap_failing_IO_operation(the_DR, "reading more would exceed the storage available");
   177.          end if;
   178.          symbol_nr := 0;
   179.       byte_loop:
   180.          for i in 1 .. bytes_per_sector loop
   181.             if symbol_nr = 0 then
   182.                store_word(0, next_address);
   183.             end if;
   184.             store_symbol(CN_TR(the_sector(i)), next_address, symbol_nr);
   185.             size := size + 1;
   186.          exit byte_loop when next_address = end_address and symbol_nr = 7;
   187.             increment(next_address, symbol_nr);
   188.          end loop byte_loop;
   189.       exit sector_loop when next_address = end_address and symbol_nr = 7;
   190.          validate_the_sector_number(the_DR, the_index);
   191.          get(the_DR, the_sector, the_index);
   192.          the_index := the_index + 1;
   193.       end loop sector_loop;
   194.       keep_house(the_DR, size, busy_time);
   195.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, input_operation);
   196.       lock_out_relative_addresses(Q_operand);
   197.       update_statistics(the_DR, latency);
   198.    end read_drum;
   199.
   200.    overriding
   201.    procedure PIA (the_DR      : in out DR.device;
   202.                   Q_operand   : in KDF9.Q_register;
   203.                   set_offline : in Boolean) is
   204.       pragma Unreferenced(set_offline);
   205.    begin
   206.       validate_transfer(the_DR, Q_operand);
   207.       validate_parity(the_DR);
   208.       read_drum(the_DR, Q_operand);
   209.    end PIA;
   210.
   211.    procedure read_drum_to_EM (the_DR    : in out DR.device;
   212.                               Q_operand : in KDF9.Q_register) is
   213.       end_address  : constant KDF9.address := Q_operand.M;
   214.       next_address : KDF9.address := Q_operand.I;
   215.       the_sector   : DR.sector := a_zero_sector;
   216.       at_EM        : Boolean := False;
   217.       symbol_nr    : KDF9_char_sets.symbol_index;
   218.       size         : KDF9.word := 0;
   219.       the_index    : KDF9.word;
   220.       latency,
   221.       busy_time    : KDF9.us;
   222.    begin
   223.       check_addresses_and_lockouts(next_address, end_address);
   224.       the_index := validated_drum_address(the_DR, Q_operand.C);
   225.       latency := latent_time(the_index);
   226.       get(the_DR, the_sector, the_index);
   227.    sector_loop:
   228.       loop
   229.          if the_index > DR.drum_index'Last then
   230.             trap_failing_IO_operation(the_DR, "reading more would exceed the storage available");
   231.          end if;
   232.          symbol_nr := 0;
   233.       byte_loop:
   234.          for i in 1 .. bytes_per_sector loop
   235.             if symbol_nr = 0 then
   236.                store_word(0, next_address);
   237.             end if;
   238.             store_symbol(CN_TR(the_sector(i)), next_address, symbol_nr);
   239.             size := size + 1;
   240.          at_EM := the_sector(i) = KDF9_char_sets.E_M;
   241.          exit byte_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   242.             increment(next_address, symbol_nr);
   243.          end loop byte_loop;
   244.          exit sector_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   245.          validate_the_sector_number(the_DR, the_index);
   246.          get(the_DR, the_sector, the_index);
   247.          the_index := the_index + 1;
   248.       end loop sector_loop;
   249.       keep_house(the_DR, size, busy_time);
   250.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, input_operation);
   251.       lock_out_relative_addresses(Q_operand);
   252.       update_statistics(the_DR, latency);
   253.    end read_drum_to_EM;
   254.
   255.    overriding
   256.    procedure PIB (the_DR      : in out DR.device;
   257.                   Q_operand   : in KDF9.Q_register;
   258.                   set_offline : in Boolean) is
   259.        pragma Unreferenced(set_offline);
   260.   begin
   261.       validate_transfer(the_DR, Q_operand);
   262.       validate_parity(the_DR);
   263.       read_drum_to_EM(the_DR, Q_operand);
   264.    end PIB;
   265.
   266.    overriding
   267.    procedure PIC (the_DR      : in out DR.device;
   268.                   Q_operand   : in KDF9.Q_register;
   269.                   set_offline : in Boolean) is
   270.    begin
   271.       PIA(the_DR, Q_operand, set_offline);
   272.    end PIC;
   273.
   274.    overriding
   275.    procedure PID (the_DR      : in out DR.device;
   276.                   Q_operand   : in KDF9.Q_register;
   277.                   set_offline : in Boolean) is
   278.    begin
   279.       PIB(the_DR, Q_operand, set_offline);
   280.    end PID;
   281.
   282.    overriding
   283.    procedure PIE (the_DR      : in out DR.device;
   284.                   Q_operand   : in KDF9.Q_register;
   285.                   set_offline : in Boolean) is
   286.    begin
   287.       PIA(the_DR, Q_operand, set_offline);
   288.    end PIE;
   289.
   290.    overriding
   291.    procedure PIF (the_DR      : in out DR.device;
   292.                   Q_operand   : in KDF9.Q_register;
   293.                   set_offline : in Boolean) is
   294.    begin
   295.       PIB(the_DR, Q_operand, set_offline);
   296.    end PIF;
   297.
   298.    overriding
   299.    procedure PIG (the_DR      : in out DR.device;
   300.                   Q_operand   : in KDF9.Q_register;
   301.                   set_offline : in Boolean) is
   302.    begin
   303.       PIA(the_DR, Q_operand, set_offline);
   304.    end PIG;
   305.
   306.    overriding
   307.    procedure PIH (the_DR      : in out DR.device;
   308.                   Q_operand   : in KDF9.Q_register;
   309.                   set_offline : in Boolean) is
   310.    begin
   311.       PIB(the_DR, Q_operand, set_offline);
   312.    end PIH;
   313.
   314.    procedure write_drum (the_DR    : in out DR.device;
   315.                          Q_operand : in KDF9.Q_register) is
   316.       end_address  : constant KDF9.address := Q_operand.M;
   317.       next_address : KDF9.address := Q_operand.I;
   318.       the_sector   : DR.sector := a_zero_sector;
   319.       symbol_nr    : KDF9_char_sets.symbol_index;
   320.       size         : KDF9.word := 0;
   321.       the_index    : KDF9.word;
   322.       latency,
   323.       busy_time    : KDF9.us;
   324.    begin
   325.       check_addresses_and_lockouts(next_address, end_address);
   326.       the_index := validated_drum_address(the_DR, Q_operand.C);
   327.       latency := latent_time(the_index);
   328.    sector_loop:
   329.       loop
   330.          symbol_nr := 0;
   331.       byte_loop:
   332.          for i in 1 .. bytes_per_sector loop
   333.             the_sector(i) := TP_CN(fetch_symbol(next_address, symbol_nr));
   334.             size := size + 1;
   335.          exit byte_loop when next_address = end_address and symbol_nr = 7;
   336.             increment(next_address, symbol_nr);
   337.          end loop byte_loop;
   338.          validate_the_sector_number(the_DR, the_index);
   339.          put(the_DR, the_sector, the_index);
   340.       exit sector_loop when next_address = end_address and symbol_nr = 7;
   341.          if the_index = DR.drum_index'Last then
   342.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   343.          else
   344.             the_index := the_index + 1;
   345.          end if;
   346.       end loop sector_loop;
   347.       keep_house(the_DR, size, busy_time);
   348.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   349.       lock_out_relative_addresses(Q_operand);
   350.       update_statistics(the_DR, latency);
   351.    end write_drum;
   352.
   353.    overriding
   354.    procedure POA (the_DR      : in out DR.device;
   355.                   Q_operand   : in KDF9.Q_register;
   356.                   set_offline : in Boolean) is
   357.       pragma Unreferenced(set_offline);
   358.    begin
   359.       validate_transfer(the_DR, Q_operand);
   360.       validate_parity(the_DR);
   361.       write_drum(the_DR, Q_operand);
   362.    end POA;
   363.
   364.    procedure write_drum_to_EM (the_DR    : in out DR.device;
   365.                                Q_operand : in KDF9.Q_register) is
   366.       end_address  : constant KDF9.address := Q_operand.M;
   367.       next_address : KDF9.address := Q_operand.I;
   368.       the_sector   : DR.sector := a_zero_sector;
   369.       at_EM        : Boolean := False;
   370.       size         : KDF9.word := 0;
   371.       symbol_nr    : KDF9_char_sets.symbol_index;
   372.       the_index    : KDF9.word;
   373.       latency,
   374.       busy_time    : KDF9.us;
   375.    begin
   376.       check_addresses_and_lockouts(next_address, end_address);
   377.       the_index := validated_drum_address(the_DR, Q_operand.C);
   378.       latency := latent_time(the_index);
   379.    sector_loop:
   380.       loop
   381.          if the_index > DR.drum_index'Last then
   382.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   383.          end if;
   384.          symbol_nr := 0;
   385.       byte_loop:
   386.          for i in 1 .. bytes_per_sector loop
   387.             the_sector(i) := TP_CN(fetch_symbol(next_address, symbol_nr));
   388.             size := size + 1;
   389.          at_EM := the_sector(i) = KDF9_char_sets.E_M;
   390.          exit byte_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   391.             increment(next_address, symbol_nr);
   392.          end loop byte_loop;
   393.          validate_the_sector_number(the_DR, the_index);
   394.          put(the_DR, the_sector, the_index);
   395.          exit sector_loop when at_EM or else (next_address = end_address and symbol_nr = 7);
   396.          the_index := the_index + 1;
   397.       end loop sector_loop;
   398.       keep_house(the_DR, size, busy_time);
   399.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   400.       lock_out_relative_addresses(Q_operand);
   401.       update_statistics(the_DR, latency);
   402.    end write_drum_to_EM;
   403.
   404.    overriding
   405.    procedure POB (the_DR      : in out DR.device;
   406.                   Q_operand   : in KDF9.Q_register;
   407.                   set_offline : in Boolean) is
   408.       pragma Unreferenced(set_offline);
   409.    begin
   410.       validate_transfer(the_DR, Q_operand);
   411.       validate_parity(the_DR);
   412.       write_drum_to_EM(the_DR, Q_operand);
   413.    end POB;
   414.
   415.    overriding
   416.    procedure POC (the_DR      : in out DR.device;
   417.                   Q_operand   : in KDF9.Q_register;
   418.                   set_offline : in Boolean) is
   419.    begin
   420.       POA(the_DR, Q_operand, set_offline);
   421.    end POC;
   422.
   423.    overriding
   424.    procedure POD (the_DR      : in out DR.device;
   425.                   Q_operand   : in KDF9.Q_register;
   426.                   set_offline : in Boolean) is
   427.    begin
   428.       POB(the_DR, Q_operand, set_offline);
   429.    end POD;
   430.
   431.    procedure write_zeroes (the_DR      : in out DR.device;
   432.                            Q_operand   : in KDF9.Q_register) is
   433.       start_address : constant KDF9.address := Q_operand.I;
   434.       end_address   : constant KDF9.address := Q_operand.M;
   435.       size      : KDF9.word := 0;
   436.       the_index : KDF9.word;
   437.       latency,
   438.       busy_time : KDF9.us;
   439.    begin
   440.       check_addresses_and_lockouts(start_address, end_address);
   441.       the_index := validated_drum_address(the_DR, Q_operand.C);
   442.       latency := latent_time(the_index);
   443.       for s in 1 .. (KDF9.word(end_address) - KDF9.word(start_address) + 128) / 128 loop
   444.          if the_index > DR.drum_index'Last then
   445.             trap_failing_IO_operation(the_DR, "writing more would exceed the storage available");
   446.          end if;
   447.          validate_the_sector_number(the_DR, the_index);
   448.          put(the_DR, a_zero_sector, the_index);
   449.          size := size + bytes_per_sector;
   450.          the_index := the_index + 1;
   451.       end loop;
   452.       keep_house(the_DR, size, busy_time, from_core => False);
   453.       start_data_transfer(the_DR, Q_operand, False, latency + busy_time, output_operation);
   454.       lock_out_relative_addresses(Q_operand);
   455.       update_statistics(the_DR, latency);
   456.    end write_zeroes;
   457.
   458.    overriding
   459.    procedure POE (the_DR      : in out DR.device;
   460.                   Q_operand   : in KDF9.Q_register;
   461.                   set_offline : in Boolean) is
   462.       pragma Unreferenced(set_offline);
   463.    begin
   464.       validate_transfer(the_DR, Q_operand);
   465.       write_zeroes(the_DR, Q_operand);
   466.    end POE;
   467.
   468.    overriding
   469.    procedure POF (the_DR      : in out DR.device;
   470.                   Q_operand   : in KDF9.Q_register;
   471.                   set_offline : in Boolean) is
   472.    begin
   473.       POE(the_DR, Q_operand, set_offline);
   474.    end POF;
   475.
   476.    overriding
   477.    procedure Finalize (the_DR : in out DR.device) is
   478.       transfer_time : constant KDF9.us := KDF9.us(the_DR.word_count) * 8 * the_DR.quantum;
   479.    begin
   480.       if the_DR.is_open then
   481.
   482.          if (the_final_state_is_wanted and the_log_is_wanted)    and then
   483.                (the_DR.word_count /= 0 or the_DR.latency_count /= 0) then
   484.             log_line
   485.                 (
   486.                  the_DR.device_name
   487.                + "on buffer #"
   488.                & oct_of(KDF9.Q_part(the_DR.number), 2)
   489.                + "spent:"
   490.                 );
   491.             log_line
   492.                 (
   493.                  "    "
   494.                & just_right(KDF9.us'Image(transfer_time / 1_000), 6)
   495.                + "ms in"
   496.                & the_DR.latency_count'Image
   497.                + "data transfer" & plurality(the_DR.latency_count)
   498.                + "totalling"
   499.                & KDF9.word'Image(the_DR.word_count)
   500.                + "word" & plurality(the_DR.word_count)
   501.                & ", and"
   502.                 );
   503.             log_line
   504.                 (
   505.                  "    "
   506.                & just_right(KDF9.us'Image(the_DR.latency_time / 1_000), 6)
   507.                + "ms in"
   508.                & the_DR.latency_count'Image
   509.                + "rotational latenc" & plurality(the_DR.latency_count, "y.", "ies.")
   510.                 );
   511.          end if;
   512.
   513.          close(IOC.device(the_DR));
   514.       end if;
   515.    end Finalize;
   516.
   517.    type DR_access is access DR.device;
   518.
   519.    DR0 : DR_access with Warnings => Off;
   520.
   521.    procedure enable (b : in KDF9.buffer_number) is
   522.    begin
   523.       if DR0_is_enabled then
   524.          trap_operator_error("more than one DR control unit has been configured");
   525.       end if;
   526.       DR0 := new DR.device (number => b, unit => 0);
   527.       DR0_is_enabled := True;
   528.       DR0_number := b;
   529.    end enable;
   530.
   531.    procedure replace_on_buffer (b : in KDF9.buffer_number) is
   532.    begin
   533.       if DR0_is_enabled and then
   534.             b = DR0.number  then
   535.          return;
   536.       end if;
   537.       buffer(b) := null;
   538.       enable(b);
   539.    end replace_on_buffer;
   540.
   541.    procedure remove_from_buffer (b : in KDF9.buffer_number) is
   542.    begin
   543.       if DR0_is_enabled and DR0_number = b then
   544.          buffer(b) := null;
   545.          DR0_is_enabled := False;
   546.       end if;
   547.    end remove_from_buffer;
   548.
   549. end IOC.fast.DR;

Compiling: ../Source/ioc-fast-dr.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:01

     1. -- Emulation of a drum store buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.DR is
    18.
    19.    type device is new fast.device with private;
    20.
    21.    overriding
    22.    procedure PIA (the_DR      : in out DR.device;
    23.                   Q_operand   : in KDF9.Q_register;
    24.                   set_offline : in Boolean);
    25.
    26.    overriding
    27.    procedure PIB (the_DR      : in out DR.device;
    28.                   Q_operand   : in KDF9.Q_register;
    29.                   set_offline : in Boolean);
    30.
    31.    overriding
    32.    procedure PIC (the_DR      : in out DR.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    overriding
    37.    procedure PID (the_DR      : in out DR.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    overriding
    42.    procedure PIE (the_DR      : in out DR.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    overriding
    47.    procedure PIF (the_DR      : in out DR.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    overriding
    52.    procedure PIG (the_DR      : in out DR.device;
    53.                   Q_operand   : in KDF9.Q_register;
    54.                   set_offline : in Boolean);
    55.
    56.    overriding
    57.    procedure PIH (the_DR      : in out DR.device;
    58.                   Q_operand   : in KDF9.Q_register;
    59.                   set_offline : in Boolean);
    60.
    61. -- PMA-PML, and POG-POL are inherited, as they have no new semantics for the drum.
    62.
    63.    overriding
    64.    procedure POA (the_DR      : in out DR.device;
    65.                   Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    overriding
    69.    procedure POB (the_DR      : in out DR.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean);
    72.
    73.    overriding
    74.    procedure POC (the_DR      : in out DR.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.    overriding
    78.    procedure POD (the_DR      : in out DR.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean);
    81.
    82.    overriding
    83.    procedure POE (the_DR      : in out DR.device;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    overriding
    88.    procedure POF (the_DR      : in out DR.device;
    89.                   Q_operand   : in KDF9.Q_register;
    90.                   set_offline : in Boolean);
    91.
    92.    procedure enable (b : in KDF9.buffer_number);
    93.
    94.    procedure replace_on_buffer (b : in KDF9.buffer_number);
    95.
    96.    procedure remove_from_buffer (b : in KDF9.buffer_number);
    97.
    98.    DR0_is_enabled : Boolean := False;
    99.
   100.    function as_DR_command (Q_operand : KDF9.Q_register; for_OUT : Boolean := False)
   101.    return String;
   102.
   103. private
   104.
   105.    -- For what little we know from EE of the drum geometry, see the Manual, App. 6, 4.
   106.    -- An additional and more helpful source is the SRLM, 103, Appendix 2, p.10-59-0,
   107.    --   which describes the drum used with the non-Time Sharing Director.
   108.    -- It says:
   109.    --   Drum revolution time     = 20.4   ms
   110.    --   Transfer time per sector =  2.15  ms
   111.    --   Short gap time           =  0.034 ms between successive sectors
   112.    --   Long gap time            =  2.97  ms after every 8th sector
   113.    -- Hence: Mean time per sector = revolution time/8 - short gap time - long gap time/8
   114.    --                             = 20.4 ms / 8       - 0.034          - 2.970 / 8
   115.    --                             = 2.145 ms, rounding correctly to 2.15 ms
   116.    -- This confirms 8 sectors per track, or 8192 characters per track, for 40 tracks per drum.
   117.
   118.    bytes_per_sector   : constant := 1024;
   119.    subtype byte_range is KDF9.word range 0 .. bytes_per_sector - 1;
   120.    subtype sector     is String(1..bytes_per_sector);
   121.
   122.    sectors_per_track  : constant := 8;
   123.    subtype sector_range is KDF9.word range 0 .. sectors_per_track - 1;
   124.
   125.    sectors_per_drum   : constant := 320;
   126.    drums_per_system   : constant := 4;
   127.    sectors_per_system : constant := sectors_per_drum * drums_per_system;
   128.    subtype drum_index is KDF9.word range 0 .. sectors_per_system - 1;
   129.
   130.    tracks_per_system   : constant := sectors_per_system / sectors_per_track;
   131.    subtype track_range is KDF9.word range 0 .. tracks_per_system - 1;
   132.
   133.    data_rate      : constant := 477_445;         -- chars/s
   134.    us_per_char    : constant := 1E6 / data_rate; -- ~2.1 s/char
   135.
   136.    -- The following times are in microseconds.
   137.    short_gap_time : constant := 34;
   138.    sector_time    : constant := bytes_per_sector * us_per_char + short_gap_time;
   139.    long_gap_time  : constant := 2_970;
   140.    track_time     : constant := sector_time * sectors_per_track + long_gap_time;
   141.    critical_time  : constant := sector_time * (sectors_per_track-1) - short_gap_time;
   142.
   143.    type drum is array (drum_index) of DR.sector;
   144.
   145.    type device is new fast.device with null record;
   146.
   147.    overriding
   148.    procedure Initialize (the_DR : in out DR.device);
   149.
   150.    overriding
   151.    procedure Finalize (the_DR : in out DR.device);
   152.
   153.    overriding
   154.    function kind (the_DR : DR.device)
   155.    return IOC.device_kind
   156.    is (DR_kind);
   157.
   158.    overriding
   159.    function quantum (the_DR : DR.device)
   160.    return KDF9.us
   161.    is (us_per_char);
   162.
   163.    DR0_number : KDF9.buffer_number := 0;
   164.
   165. end IOC.fast.DR;

 549 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-fd.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:01

     1. -- Emulation of a fixed disc drive.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.fast.FD is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    function as_FD_command (Q_operand : KDF9.Q_register; for_seek, for_FH : Boolean := False)
    22.    return String is
    23.       parameter : constant KDF9.Q_part := Q_operand.C / 16;
    24.       cylinder  : constant KDF9.Q_part := parameter mod seek_areas_per_platter;
    25.       residue   : constant KDF9.Q_part := parameter  /  seek_areas_per_platter;
    26.       platter   : constant KDF9.Q_part := residue mod main_discs_per_drive;
    27.       drive     : constant KDF9.Q_part := residue  /  main_discs_per_drive;
    28.    begin
    29.       -- The disc geometry and I/O command bits are as defined in the FD package.
    30.       if for_seek then
    31.          return "D" & dec_of(drive)
    32.               & "P" & dec_of(if for_FH then KDF9.Q_part'(the_fixed_head_platter) else platter)
    33.               & "C" & dec_of(cylinder);
    34.       else -- for data transfer, parameter is sector #, with maximum 96 sectors per track.
    35.          return " S" & (if parameter < 10 then "0" else "") & dec_of(parameter);
    36.       end if;
    37.    end as_FD_command;
    38.
    39.    overriding
    40.    procedure Initialize (the_FD : in out FD.device) is
    41.    begin
    42.       open(the_FD, rd_wr_mode);
    43.    exception
    44.       when others =>
    45.          trap_operator_error(the_FD.device_name + "cannot be opened for reading and writing");
    46.    end Initialize;
    47.
    48.    -- Hypothesis:
    49.    -- Where a specification of the Fixed Disc subsystem cannot be inferred from extant software,
    50.    -- such as the Eldon 2 Director, or the EE KDF9 Programming Manual,
    51.    -- then it is reasonable to extrapolate from the Data Products Corporation documents:
    52.    --    "SPECIFICATION FOR MODEL 5022 DISCfILE STORAGE SYSTEM", of December 1964, and
    53.    --    "GENERAL INFORMATION MANUAL dp/f-5022 DISCfILE STORAGE SYSTEM", of March 1965,
    54.    -- which describe an (at least) very similar model.
    55.    -- These document are referred to herein as "GIM".
    56.    -- Confirmation of much of this material has been gained from the ICT document:
    57.    --    "Data Disc Store 1956", of September 1964",
    58.    -- which describes the same device, offered as a fixed disc drive for the 1900 Series.
    59.    -- All three depict the drive as having a different division of tracks into sectors.
    60.
    61.    -- Hypothesis:
    62.    -- The locus is set by a PMA or PMD operation; the sector number is updated by a transfer.
    63.
    64.    -- Hypothesis:
    65.    -- A PMA or PMD command sets the sector number to 0.
    66.
    67.    -- Hypothesis:
    68.    -- If a transfer would increase the sector number past 95, the end-of-area flag is set,
    69.    --    and the sector number is set to 95.
    70.
    71.    function locus_from (Q_operand : KDF9.Q_register)
    72.    return FD.locus is
    73.       parameter : constant KDF9.Q_part := Q_operand.C / 16; -- remove the buffer number
    74.       seek_area : constant KDF9.Q_part := parameter mod seek_areas_per_platter;
    75.       platter   : constant KDF9.Q_part
    76.                 := parameter / seek_areas_per_platter mod platters_per_drive;
    77.       drive     : constant KDF9.Q_part
    78.                 := parameter / seek_areas_per_platter / platters_per_drive;
    79.    begin
    80.       -- Hypothesis:
    81.       -- Seeking to a new locus zeroizes the sector number and clears the end-of-area flag.
    82.       return (
    83.               drive_number      => drive,
    84.               platter_number    => platter,
    85.               seek_area_number  => seek_area,
    86.               sector_number     => 0,
    87.               has_fixed_heads   => False,
    88.               is_at_end_of_area => False
    89.              );
    90.    end locus_from;
    91.
    92.    function sector_span (Q_operand : KDF9.Q_register)
    93.    return KDF9.Q_part
    94.    is ((Q_operand.M - Q_operand.I + words_per_sector - 1) / words_per_sector);
    95.
    96.    procedure advance_the_sector_number (the_FD : in out FD.device) is
    97.    begin
    98.       if the_FD.locus.sector_number = FD.sector_range'Last then
    99.          the_FD.locus.is_at_end_of_area := True;
   100.       else
   101.          the_FD.locus.is_at_end_of_area := False;
   102.          the_FD.locus.sector_number := the_FD.locus.sector_number + 1;
   103.       end if;
   104.    end advance_the_sector_number;
   105.
   106.    procedure set_the_new_sector_number (the_FD    : in out FD.device;
   107.                                     Q_operand : in KDF9.Q_register) is
   108.       the_sector_number : constant KDF9.Q_part := (Q_operand.C / 16) and 8#177#;
   109.    begin
   110.       if the_sector_number in FD.sector_range then
   111.          the_FD.locus.is_at_end_of_area := False;
   112.          the_FD.locus.sector_number := the_sector_number;
   113.       else
   114.          the_FD.locus.is_at_end_of_area := True;
   115.          the_FD.locus.sector_number := FD.sector_range'Last;
   116.       end if;
   117.    end set_the_new_sector_number;
   118.
   119.    sectors_per_platter : constant := sectors_per_seek_area * seek_areas_per_platter;
   120.    sectors_per_drive   : constant := platters_per_drive  * sectors_per_platter;
   121.
   122.    function file_offset (locus : FD.locus)
   123.    return POSIX.file_position
   124.    is (
   125.        bytes_per_sector *
   126.                         ( POSIX.file_position(locus.drive_number)     * sectors_per_drive
   127.                         + POSIX.file_position(locus.platter_number)   * sectors_per_platter
   128.                         + POSIX.file_position(locus.seek_area_number) * sectors_per_seek_area
   129.                         + POSIX.file_position(locus.sector_number)    * 1
   130.                         )
   131.       );
   132.
   133.    function disc_busy_time (first : FD.sector_range; size : KDF9.word)
   134.    return KDF9.us is
   135.
   136.       function ceiling (first : FD.sector_range; size : KDF9.word)
   137.       return FD.sector_range is
   138.          length : constant KDF9.Q_part := sector_span((0, 1, KDF9.Q_part(size)));
   139.       begin
   140.          return FD.sector_range'Min(first + length - 1, FD.sector_range'Last);
   141.       end ceiling;
   142.
   143.       function time_for (bytes : KDF9.word; in_outer_zone : Boolean)
   144.       return KDF9.word
   145.       is (1E6 * bytes / (if in_outer_zone then outer_rate else inner_rate));
   146.
   147.       boundary   : constant := sectors_per_seek_area / 3 * 2;
   148.       last       : constant FD.sector_range := ceiling(first, size);
   149.       bytes_left : KDF9.word := size * 8;
   150.       total_time : KDF9.word := 0;
   151.
   152.    begin
   153.       for s in first .. last loop
   154.       exit when bytes_left < bytes_per_sector;
   155.          total_time := total_time + time_for(bytes_per_sector, in_outer_zone => s < boundary);
   156.          bytes_left := bytes_left - bytes_per_sector;
   157.       end loop;
   158.       if bytes_left /= 0 then
   159.          total_time := total_time + time_for(bytes_left, in_outer_zone => last < boundary);
   160.       end if;
   161.       return KDF9.us(total_time);
   162.    end disc_busy_time;
   163.
   164.    -- The rotational position of the disc is measured in term of the time,
   165.    --    in microseconds, taken to get to that position from sector 0.
   166.
   167.    rotation_time : constant := 60E3;  -- 1000 RPM => 60 ms = 60_000 KDF9.us
   168.    track_size    : constant := 16;    -- There are only 8 sectors per track in the inner zone.
   169.    sector_time   : constant := rotation_time / track_size;
   170.
   171.    function angular_position (sector_number : FD.sector_range)
   172.    return KDF9.us
   173.    is (-- This is <= rotation_time.
   174.        if sector_number < sectors_in_outer_zone then
   175.           KDF9.us(sector_number * sector_time)
   176.        else
   177.           -- Inner zone sectors are twice as long as in the outer zone.
   178.           -- Assumes (without evidence) that the inner zone is offset 1/2 sector from the outer.
   179.           KDF9.us((sector_number - sectors_in_outer_zone) * sector_time * 2 - sector_time/2)
   180.       );
   181.
   182.    function latent_time (the_FD : FD.device; latency_start_time : in KDF9.us)
   183.    return KDF9.us is
   184.       new_angle  : constant KDF9.us := angular_position(the_FD.locus.sector_number);
   185.       old_angle  : constant KDF9.us := latency_start_time mod rotation_time;
   186.       offset     : constant KDF9.us
   187.                  := (
   188.                      if   new_angle > old_angle
   189.                      then new_angle - old_angle
   190.                      else new_angle + rotation_time - old_angle
   191.                     );
   192.    begin
   193.       -- According to GIM, the minimum latency is one sector;
   194.       --    if less we have to go all the way around.
   195.       return (if offset > sector_time then offset else rotation_time - offset );
   196.    end latent_time;
   197.
   198.    -- These times come from the Manual, 6.1, and from GIM.
   199.    checking_time  : constant :=   47E3;
   200.    min_seek_time  : constant :=  109E3;
   201.    max_seek_time  : constant :=  321E3;
   202.    per_track_time : constant KDF9.us
   203.                   := KDF9.us(max_seek_time - min_seek_time) / seek_areas_per_platter;
   204.
   205.    -- A seek distance of 1 takes the minimum seek time: zero_seek_time + per_track_time.
   206.    zero_seek_time : constant KDF9.us := min_seek_time - per_track_time;
   207.
   208.    subtype seek_time_range is KDF9.us range 0 .. max_seek_time + checking_time;
   209.
   210.    function arm_seek_time (the_FD : FD.device)
   211.    return seek_time_range is
   212.       next   : FD.locus renames the_FD.target;
   213.       drive  : FD.drive_range renames next.drive_number;
   214.       here   : constant FD.seek_area_range := the_FD.comb(drive, next.platter_number);
   215.       there  : constant FD.seek_area_range := next.seek_area_number;
   216.       span   : constant FD.seek_area_range := (if here > there then here - there else there - here);
   217.       cost   : constant KDF9.us := KDF9.us(span) * per_track_time;
   218.    begin
   219.       if cost > 0 and next.platter_number /= the_fixed_head_platter then
   220.          -- Hypothesis:
   221.          return KDF9.us'Min(zero_seek_time + cost, max_seek_time) + checking_time;
   222.       else
   223.          -- Hypothesis:
   224.          -- A seek to the present position takes no time.
   225.          return 0;
   226.       end if;
   227.    end arm_seek_time;
   228.
   229.    -- These times come from GIM.
   230.    -- A switch to a different platter takes 26 ms on average, as specified in GIM.
   231.    -- This time is needed to power-down then power-up the arm actuators for the R/W heads.
   232.    drive_switch_time : constant :=  5_000;
   233.    arm_switch_time   : constant := 26_000;
   234.
   235.    function platter_switch_time (the_FD : FD.device)
   236.    return KDF9.us is
   237.       the_drive_time : KDF9.us;
   238.    begin
   239.       if the_FD.target.drive_number /= the_FD.locus.drive_number then
   240.          the_drive_time := drive_switch_time;
   241.       else
   242.          the_drive_time := 0;
   243.       end if;
   244.       -- Hypothesis:
   245.       -- Operating successively on the current platter, or working on the fixed-head platter,
   246.       --    incurs no arm switch time.
   247.       if the_FD.target.platter_number = the_FD.locus.platter_number or else
   248.             the_FD.target.platter_number = the_fixed_head_platter      then
   249.           return the_drive_time;
   250.        else
   251.           return the_drive_time + arm_switch_time;
   252.       end if;
   253.    end platter_switch_time;
   254.
   255.    procedure set_seek_target (the_FD       : in out FD.device;
   256.                               Q_operand    : in KDF9.Q_register;
   257.                               it_will_seek : out Boolean) is
   258.       here : FD.locus renames the_FD.locus;
   259.       next : FD.locus renames the_FD.target;
   260.    begin
   261.       it_will_seek := False;
   262.       next := locus_from(Q_operand);
   263.       next.has_fixed_heads := False;
   264.       if next.platter_number /= here.platter_number then
   265.          the_FD.switch_count := the_FD.switch_count +1;
   266.       end if;
   267.       if the_FD.comb(next.drive_number, here.platter_number) /= next.seek_area_number then
   268.          the_FD.seek_count := the_FD.seek_count + 1;
   269.          it_will_seek := True;
   270.       end if;
   271.     end set_seek_target;
   272.
   273.    procedure seek_to_the_target_area (the_FD      : in out FD.device;
   274.                                       seek_time,
   275.                                       switch_time : out seek_time_range) is
   276.       here : FD.locus renames the_FD.locus;
   277.       next : FD.locus renames the_FD.target;
   278.    begin
   279.       seek_time := arm_seek_time(the_FD);
   280.       switch_time := platter_switch_time(the_FD);
   281.       here := the_FD.target;
   282.       the_FD.comb(here.drive_number, here.platter_number) := next.seek_area_number;
   283.     end seek_to_the_target_area;
   284.
   285.    subtype sector_image is String(1 .. bytes_per_sector);
   286.
   287.    empty_sector : constant sector_image := (others => SP);
   288.    this_sector  : sector_image;
   289.
   290.    procedure get_next_sector (the_FD : in out FD.device) is
   291.       result : POSIX.file_position with Unreferenced;
   292.    begin
   293.       result := seek(fd_of(the_FD.stream), file_offset(the_FD.locus));
   294.       result := POSIX.file_position(read(fd_of(the_FD.stream), this_sector, bytes_per_sector));
   295.       the_FD.sector_count := the_FD.sector_count + 1;
   296.       advance_the_sector_number(the_FD);
   297.    end get_next_sector;
   298.
   299.    procedure keep_house (the_FD        : in out FD.device;
   300.                          transfer_size : in KDF9.word;
   301.                          busy_time     : out KDF9.us) is
   302.    begin
   303.       the_FD.latency_count := the_FD.latency_count + 1;
   304.       the_FD.word_count := the_FD.word_count + transfer_size;
   305.       add_in_the_IO_CPU_time(the_FD, bytes_moved => transfer_size*8);
   306.       busy_time := disc_busy_time(the_FD.locus.sector_number, transfer_size);
   307.    end keep_house;
   308.
   309.    procedure update_statistics (the_FD        : in out FD.device;
   310.                                 switch_time,
   311.                                 seek_time,
   312.                                 latency_time,
   313.                                 data_time     : in KDF9.us := 0) is
   314.    begin
   315.       the_FD.switch_time := the_FD.switch_time + switch_time;
   316.       the_FD.seek_time := the_FD.seek_time + seek_time;
   317.       the_FD.latency_time := the_FD.latency_time + latency_time;
   318.       the_FD.data_time := the_FD.data_time + data_time;
   319.       the_FD.elapsed_time := the_FD.elapsed_time
   320.                                  + switch_time
   321.                                  + seek_time
   322.                                  + latency_time
   323.                                  + data_time;
   324.     end update_statistics;
   325.
   326.    procedure read (the_FD        : in out FD.device;
   327.                    start_address,
   328.                    end_address   : in  KDF9.address;
   329.                    busy_time     : out KDF9.us;
   330.                    reading_to_EM : in  Boolean := False) is
   331.       size : KDF9.word := 0;
   332.       next : Natural := 0;
   333.       char : Character;
   334.    begin
   335.       check_addresses_and_lockouts(start_address, end_address);
   336.    word_loop:
   337.       for w in start_address .. end_address loop
   338.          if size mod bytes_per_sector = 0 then
   339.             this_sector := empty_sector;
   340.             get_next_sector(the_FD);
   341.          exit word_loop when the_FD.locus.is_at_end_of_area;
   342.             next := 0;
   343.          end if;
   344.          for c in KDF9_char_sets.symbol_index'Range loop
   345.             next := next + 1;
   346.             char := this_sector(next);
   347.             store_symbol(CN_TR(char), w, c);
   348.             size := size + 1;
   349.          exit word_loop when reading_to_EM and char = E_M;
   350.          end loop;
   351.       end loop word_loop;
   352.       keep_house(the_FD, (size+7)/8, busy_time);
   353.    end read;
   354.
   355.    procedure PI_all (the_FD         : in out FD.device;
   356.                      Q_operand      : in KDF9.Q_register;
   357.                      transfer_to_EM : in Boolean := False) is
   358.       the_present_time   : constant KDF9.us := the_clock_time;
   359.       latency_start_time : KDF9.us;
   360.       seek_duration,
   361.       switch_duration,
   362.       latency_duration,
   363.       data_duration,
   364.       total_duration     : KDF9.us;
   365.    begin
   366.       validate_device(the_FD);
   367.       validate_parity(the_FD);
   368.       seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   369.       set_the_new_sector_number(the_FD, Q_operand);
   370.       latency_start_time := the_present_time + seek_duration + switch_duration;
   371.       latency_duration := latent_time(the_FD, latency_start_time);
   372.
   373.       if the_FD.locus.is_at_end_of_area then
   374.          -- Cannot transfer past the last sector in a seek area.
   375.          trap_failing_IO_operation(the_FD, "attempt to read FD at the end of a seek area");
   376.       end if;
   377.
   378.       -- Read from the newly established position.
   379.       read(
   380.            the_FD,
   381.            Q_operand.I, Q_operand.M,
   382.            data_duration,
   383.            reading_to_EM => transfer_to_EM
   384.           );
   385.
   386.       total_duration := seek_duration + switch_duration + latency_duration + data_duration;
   387.       start_data_transfer(the_FD, Q_operand, False, total_duration, input_operation);
   388.       lock_out_relative_addresses(Q_operand);
   389.       update_statistics(
   390.                         the_FD,
   391.                         switch_time  => switch_duration,
   392.                         seek_time    => seek_duration,
   393.                         latency_time => latency_duration,
   394.                         data_time    => data_duration
   395.                        );
   396.    end PI_all;
   397.
   398.    overriding
   399.    procedure PIA (the_FD      : in out FD.device;
   400.                   Q_operand   : in KDF9.Q_register;
   401.                   set_offline : in Boolean) is
   402.       pragma Unreferenced(set_offline);
   403.    begin
   404.       PI_all(the_FD, Q_operand);
   405.    end PIA;
   406.
   407.    overriding
   408.    procedure PIB (the_FD      : in out FD.device;
   409.                   Q_operand   : in KDF9.Q_register;
   410.                   set_offline : in Boolean) is
   411.       pragma Unreferenced(set_offline);
   412.    begin
   413.       PI_all(the_FD, Q_operand, transfer_to_EM => True);
   414.    end PIB;
   415.
   416.    -- Set up FD parameters for a transfer in the fixed-head platter.
   417.    procedure prepare_fixed_head_transfer (the_FD      : in out FD.device;
   418.                                           Q_operand   : in KDF9.Q_register) is
   419.    begin
   420.       the_FD.target := locus_from(Q_operand);
   421.       the_FD.target.has_fixed_heads := True;
   422.       the_FD.target.platter_number := 16;
   423.       the_FD.switch_time := platter_switch_time(the_FD);
   424.       the_FD.locus := the_FD.target;
   425.       the_FD.switch_count := the_FD.switch_count + (if the_FD.switch_time = 0 then 0 else 1);
   426.    end prepare_fixed_head_transfer;
   427.
   428.    overriding
   429.    procedure PIC (the_FD      : in out FD.device;
   430.                   Q_operand   : in KDF9.Q_register;
   431.                   set_offline : in Boolean) is
   432.       pragma Unreferenced(set_offline);
   433.    begin
   434.       prepare_fixed_head_transfer(the_FD, Q_operand);
   435.       PI_all(the_FD, Q_operand);
   436.    end PIC;
   437.
   438.    overriding
   439.    procedure PID (the_FD      : in out FD.device;
   440.                   Q_operand   : in KDF9.Q_register;
   441.                   set_offline : in Boolean) is
   442.       pragma Unreferenced(set_offline);
   443.    begin
   444.       prepare_fixed_head_transfer(the_FD, Q_operand);
   445.       PI_all(the_FD, Q_operand, transfer_to_EM => True);
   446.    end PID;
   447.
   448.    -- Find the number of the next (first) sector to rotate into an accessible position.
   449.    function next_sector_number (the_FD : FD.device)
   450.    return FD.sector_range is
   451.       now        : constant KDF9.us := the_clock_time;
   452.       best_time  : KDF9.us          := KDF9.us'Last;
   453.       the_sector : FD.sector_range  := FD.sector_range'Last;
   454.    begin
   455.       for s in FD.sector_range loop
   456.          if latent_time(the_FD, now) in sector_time+1 .. 2*sector_time then
   457.             if latent_time(the_FD, now) <= best_time then
   458.                the_sector := s;
   459.                best_time := latent_time(the_FD, now);
   460.             end if;
   461.          end if;
   462.       end loop;
   463.       return the_sector;
   464.    end next_sector_number;
   465.
   466.    -- Modify the given command to apply to the next sector to come under the heads.
   467.    function for_next_sector (the_FD : FD.device; Q : KDF9.Q_register)
   468.    return KDF9.Q_register
   469.    is (
   470.        C => (Q.C and 8#174000#) or (Q.C and 8#17#) or (next_sector_number(the_FD)*16),
   471.        I => Q.I,
   472.        M => Q.M
   473.       );
   474.
   475.    overriding
   476.    procedure PIE (the_FD      : in out FD.device;
   477.                   Q_operand   : in KDF9.Q_register;
   478.                   set_offline : in Boolean) is
   479.       pragma Unreferenced(set_offline);
   480.    begin
   481.       validate_transfer(the_FD, Q_operand);
   482.       PI_all(the_FD, for_next_sector(the_FD, Q_operand));
   483.    end PIE;
   484.
   485.    overriding
   486.    procedure PIF (the_FD      : in out FD.device;
   487.                   Q_operand   : in KDF9.Q_register;
   488.                   set_offline : in Boolean) is
   489.       pragma Unreferenced(set_offline);
   490.    begin
   491.       validate_transfer(the_FD, Q_operand);
   492.       PI_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   493.    end PIF;
   494.
   495.    overriding
   496.    procedure PIG (the_FD      : in out FD.device;
   497.                   Q_operand   : in KDF9.Q_register;
   498.                   set_offline : in Boolean) is
   499.       pragma Unreferenced(set_offline);
   500.    begin
   501.       validate_transfer(the_FD, Q_operand);
   502.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   503.       PI_all(the_FD, for_next_sector(the_FD, Q_operand));
   504.    end PIG;
   505.
   506.    overriding
   507.    procedure PIH (the_FD      : in out FD.device;
   508.                   Q_operand   : in KDF9.Q_register;
   509.                   set_offline : in Boolean) is
   510.       pragma Unreferenced(set_offline);
   511.    begin
   512.       validate_transfer(the_FD, Q_operand);
   513.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   514.       PI_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   515.    end PIH;
   516.
   517.    -- Set up, but do not yet effect, a seek to the locus specified by the Q_operand.
   518.    -- This follows advice from David Holdsworth that seeks were not effected
   519.    --    until a data transfer operation was obeyed.
   520.    -- PMA does not lockout for a busy device.  This may not be authentic.
   521.    overriding
   522.    procedure PMA (the_FD      : in out FD.device;
   523.                   Q_operand   : in KDF9.Q_register;
   524.                   set_offline : in Boolean) is
   525.       a_seek_is_needed : Boolean := False;
   526.    begin
   527.       validate_device(the_FD);
   528.       validate_parity(the_FD);
   529.       set_seek_target(the_FD, Q_operand, a_seek_is_needed);
   530.       deal_with_a_busy_device(the_FD, 19, set_offline);
   531.       take_note_of_test(the_FD.device_name, Q_operand, a_seek_is_needed);
   532.    end PMA;
   533.
   534.    overriding
   535.    procedure PMB (the_FD      : in out FD.device;
   536.                   Q_operand   : in KDF9.Q_register;
   537.                   set_offline : in Boolean) is
   538.       pragma Unreferenced(Q_operand);
   539.       pragma Unreferenced(set_offline);
   540.    begin
   541.       validate_device(the_FD);
   542.       validate_parity(the_FD);
   543.       null;
   544.    end PMB;
   545.
   546.    overriding
   547.    procedure PMC (the_FD      : in out FD.device;
   548.                   Q_operand   : in KDF9.Q_register;
   549.                   set_offline : in Boolean) is
   550.       pragma Unreferenced(Q_operand);
   551.       pragma Unreferenced(set_offline);
   552.    begin
   553.       validate_device(the_FD);
   554.       validate_parity(the_FD);
   555.       null;
   556.    end PMC;
   557.
   558.    overriding
   559.    procedure PMD (the_FD      : in out FD.device;
   560.                   Q_operand   : in KDF9.Q_register;
   561.                   set_offline : in Boolean) is
   562.       -- clear out seek area # and platter#, leaving buffer # and drive #
   563.       platter_0        : constant KDF9.Q_part := Q_operand.C and 16#C00F#;
   564.       control_word     : KDF9.Q_register;
   565.       a_seek_is_needed : Boolean;
   566.       seek_duration,
   567.       switch_duration  : KDF9.us;
   568.    begin
   569.       validate_device(the_FD);
   570.       -- Hypothesis: drive reset clears the parity flag.
   571.       the_FD.is_abnormal := False;
   572.       -- In effect, do 16 PMA operations, but treat them as a single operation.
   573.       for p in KDF9.Q_part range 0..15 loop -- p is platter #
   574.          control_word := (platter_0 + p*16#400#, Q_operand.I, Q_operand.M);
   575.          set_seek_target(the_FD, control_word, a_seek_is_needed);
   576.          seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   577.          update_statistics(
   578.                            the_FD,
   579.                            switch_time  => switch_duration,
   580.                            seek_time    => seek_duration
   581.                           );
   582.       end loop;
   583.       deal_with_a_busy_device(the_FD, 16, set_offline);
   584.    end PMD;
   585.
   586.    overriding
   587.    procedure PMF (the_FD      : in out FD.device;
   588.                   Q_operand   : in KDF9.Q_register;
   589.                   set_offline : in Boolean) is
   590.    begin
   591.       validate_device(the_FD);
   592.       validate_parity(the_FD);
   593.       deal_with_a_busy_device(the_FD, 13, set_offline);
   594.       the_T_bit_is_set := the_FD.locus.is_at_end_of_area;
   595.       take_note_of_test(the_FD.device_name, Q_operand, the_T_bit_is_set);
   596.    end PMF;
   597.
   598.    procedure put_next_sector (the_FD : in out FD.device) is
   599.       result : POSIX.file_position with Unreferenced;
   600.    begin
   601.       result := seek(fd_of(the_FD.stream), file_offset(the_FD.locus));
   602.       result := POSIX.file_position(write(fd_of(the_FD.stream), this_sector, bytes_per_sector));
   603.       the_FD.sector_count := the_FD.sector_count + 1;
   604.       advance_the_sector_number(the_FD);
   605.       this_sector := empty_sector;
   606.    end put_next_sector;
   607.
   608.    procedure write (the_FD       : in out FD.device;
   609.                    start_address,
   610.                    end_address   : in KDF9.address;
   611.                    busy_time     : out KDF9.us;
   612.                    writing_to_EM : in  Boolean := False) is
   613.       size   : KDF9.word := 0;
   614.       next   : Natural := 0;
   615.       symbol : KDF9_char_sets.symbol;
   616.       char   : Character;
   617.    begin
   618.       check_addresses_and_lockouts(start_address, end_address);
   619.       this_sector := empty_sector;
   620.    word_loop:
   621.       for w in start_address .. end_address loop
   622.          for c in KDF9_char_sets.symbol_index'Range loop
   623.             symbol := fetch_symbol(w, c);
   624.             char := TP_CN(symbol);
   625.             next := next + 1;
   626.             this_sector(next) := char;
   627.             size := size + 1;
   628.             exit when writing_to_EM and char = E_M;
   629.          end loop;
   630.          if writing_to_EM and char = E_M then
   631.             put_next_sector(the_FD);
   632.             next := 0;
   633.             exit word_loop;
   634.          elsif size mod bytes_per_sector = 0 then
   635.             put_next_sector(the_FD);
   636.             next := 0;
   637.             exit word_loop when the_FD.locus.is_at_end_of_area;
   638.          end if;
   639.       end loop word_loop;
   640.       if next > 0 then
   641.          -- Write out any untransferred residue of less than a full sector.
   642.          put_next_sector(the_FD);
   643.       end if;
   644.       keep_house(the_FD, (size+7)/8, busy_time);
   645.    end write;
   646.
   647.    procedure PO_all (the_FD         : in out FD.device;
   648.                      Q_operand      : in KDF9.Q_register;
   649.                      transfer_to_EM : in Boolean := False) is
   650.       the_present_time   : constant KDF9.us := the_clock_time;
   651.       seek_duration,
   652.       switch_duration,
   653.       latency_duration,
   654.       data_duration,
   655.       total_duration     : KDF9.us;
   656.       latency_start_time : KDF9.us;
   657.    begin
   658.       validate_device(the_FD);
   659.       validate_parity(the_FD);
   660.       seek_to_the_target_area(the_FD, seek_duration, switch_duration);
   661.       set_the_new_sector_number(the_FD, Q_operand);
   662.       latency_start_time := the_present_time + seek_duration + switch_duration;
   663.       latency_duration := latent_time(the_FD, latency_start_time);
   664.
   665.       if the_FD.locus.is_at_end_of_area then
   666.          -- Cannot transfer past the last sector in a seek area.
   667.          trap_failing_IO_operation(the_FD, "attempt to write FD at the end of a seek area");
   668.       end if;
   669.
   670.       -- Write to the newly established position.
   671.       write(
   672.             the_FD,
   673.             Q_operand.I, Q_operand.M,
   674.             data_duration,
   675.             writing_to_EM => transfer_to_EM
   676.            );
   677.
   678.       total_duration := seek_duration + switch_duration + latency_duration + data_duration;
   679.       start_data_transfer(the_FD, Q_operand, False, total_duration, output_operation);
   680.       lock_out_relative_addresses(Q_operand);
   681.       update_statistics(
   682.                         the_FD,
   683.                         seek_time    => seek_duration,
   684.                         switch_time  => switch_duration,
   685.                         latency_time => latency_duration,
   686.                         data_time    => data_duration
   687.                        );
   688.    end PO_all;
   689.
   690.    overriding
   691.    procedure POA (the_FD      : in out FD.device;
   692.                   Q_operand   : in KDF9.Q_register;
   693.                   set_offline : in Boolean) is
   694.       pragma Unreferenced(set_offline);
   695.    begin
   696.       PO_all(the_FD, Q_operand);
   697.    end POA;
   698.
   699.    overriding
   700.    procedure POB (the_FD      : in out FD.device;
   701.                   Q_operand   : in KDF9.Q_register;
   702.                   set_offline : in Boolean) is
   703.       pragma Unreferenced(set_offline);
   704.    begin
   705.       PO_all(the_FD, Q_operand, transfer_to_EM => True);
   706.    end POB;
   707.
   708.    overriding
   709.    procedure POC (the_FD      : in out FD.device;
   710.                   Q_operand   : in KDF9.Q_register;
   711.                   set_offline : in Boolean) is
   712.       pragma Unreferenced(set_offline);
   713.    begin
   714.       prepare_fixed_head_transfer(the_FD, Q_operand);
   715.       PO_all(the_FD, Q_operand);
   716.    end POC;
   717.
   718.    overriding
   719.    procedure POD (the_FD      : in out FD.device;
   720.                   Q_operand   : in KDF9.Q_register;
   721.                   set_offline : in Boolean) is
   722.       pragma Unreferenced(set_offline);
   723.    begin
   724.       prepare_fixed_head_transfer(the_FD, Q_operand);
   725.       PO_all(the_FD, Q_operand, transfer_to_EM => True);
   726.    end POD;
   727.
   728.    overriding
   729.    procedure POE (the_FD      : in out FD.device;
   730.                   Q_operand   : in KDF9.Q_register;
   731.                   set_offline : in Boolean) is
   732.    begin
   733.       POC(the_FD, Q_operand, set_offline);
   734.    end POE;
   735.
   736.    overriding
   737.    procedure POF (the_FD      : in out FD.device;
   738.                   Q_operand   : in KDF9.Q_register;
   739.                   set_offline : in Boolean) is
   740.    begin
   741.       POA(the_FD, Q_operand, set_offline);
   742.    end POF;
   743.
   744.    overriding
   745.    procedure POG (the_FD      : in out FD.device;
   746.                   Q_operand   : in KDF9.Q_register;
   747.                   set_offline : in Boolean) is
   748.       pragma Unreferenced(set_offline);
   749.    begin
   750.       validate_transfer(the_FD, Q_operand);
   751.       PO_all(the_FD, for_next_sector(the_FD, Q_operand));
   752.    end POG;
   753.
   754.    overriding
   755.    procedure POH (the_FD      : in out FD.device;
   756.                   Q_operand   : in KDF9.Q_register;
   757.                   set_offline : in Boolean) is
   758.       pragma Unreferenced(set_offline);
   759.    begin
   760.       validate_transfer(the_FD, Q_operand);
   761.       PO_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   762.    end POH;
   763.
   764.    overriding
   765.    procedure POK (the_FD      : in out FD.device;
   766.                   Q_operand   : in KDF9.Q_register;
   767.                   set_offline : in Boolean) is
   768.       pragma Unreferenced(set_offline);
   769.    begin
   770.       validate_transfer(the_FD, Q_operand);
   771.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   772.       PO_all(the_FD, for_next_sector(the_FD, Q_operand), transfer_to_EM => True);
   773.    end POK;
   774.
   775.    overriding
   776.    procedure POL (the_FD      : in out FD.device;
   777.                   Q_operand   : in KDF9.Q_register;
   778.                   set_offline : in Boolean) is
   779.       pragma Unreferenced(set_offline);
   780.    begin
   781.       validate_transfer(the_FD, Q_operand);
   782.       prepare_fixed_head_transfer(the_FD, for_next_sector(the_FD, Q_operand));
   783.       PO_all(the_FD, for_next_sector(the_FD, Q_operand));
   784.    end POL;
   785.
   786.    overriding
   787.    procedure Finalize (the_FD : in out FD.device) is
   788.       buffer : constant String := oct_of(KDF9.Q_part(the_FD.number), 2);
   789.    begin
   790.       if the_FD.is_open then
   791.          if (the_final_state_is_wanted and the_log_is_wanted)    and then
   792.                (the_FD.word_count /= 0 or the_FD.latency_count /= 0  or
   793.                 the_FD.seek_count /= 0 or the_FD.switch_time   /= 0) then
   794.             log_line
   795.                    (
   796.                     the_FD.device_name
   797.                   + "on buffer #"
   798.                   & buffer
   799.                   + "spent:"
   800.                    );
   801.             log_line
   802.                    (
   803.                     "    "
   804.                   & just_right(KDF9.us'Image(the_FD.data_time / 1_000), 6)
   805.                   + "ms in"
   806.                   & the_FD.latency_count'Image
   807.                   + "data transfer" & plurality(the_FD.latency_count)
   808.                   + "totalling"
   809.                   & KDF9.word'Image(the_FD.word_count)
   810.                   + ("word" & plurality(the_FD.word_count))
   811.                   & ","
   812.                    );
   813.             log_line
   814.                    (
   815.                     "    "
   816.                   & just_right(KDF9.us'Image(the_FD.switch_time / 1_000), 6)
   817.                   + "ms in"
   818.                   & the_FD.switch_count'Image
   819.                   + ("platter switch" & plurality(the_FD.switch_count, "", "es"))
   820.                   & ","
   821.                    );
   822.             log_line
   823.                    (
   824.                     "    "
   825.                   & just_right(KDF9.us'Image(the_FD.latency_time / 1_000), 6)
   826.                   + "ms in"
   827.                   & the_FD.latency_count'Image
   828.                   + ("rotational latenc" & plurality(the_FD.latency_count, "y", "ies"))
   829.                   & ", and"
   830.                    );
   831.             log_line
   832.                    (
   833.                     "    "
   834.                   & just_right(KDF9.us'Image(the_FD.seek_time / 1_000), 6)
   835.                   + "ms in"
   836.                   & the_FD.seek_count'Image
   837.                   + ("seek" & plurality(the_FD.seek_count))
   838.                   & "."
   839.                    );
   840.          end if;
   841.          IOC.device(the_FD).Finalize;
   842.          close(the_FD);
   843.       end if;
   844.    end Finalize;
   845.
   846.    type FD_access is access FD.device;
   847.
   848.    FD0 : FD_access with Warnings => Off;
   849.
   850.    procedure enable (b : in KDF9.buffer_number) is
   851.    begin
   852.       if FD0_is_enabled then
   853.          trap_operator_error("more than one FD control unit has been configured");
   854.       end if;
   855.       FD0 := new FD.device (number => b, unit => 0);
   856.       FD0_is_enabled := True;
   857.       FD0_number := b;
   858.    end enable;
   859.
   860.    procedure replace_on_buffer (b : in KDF9.buffer_number) is
   861.    begin
   862.       if FD0 /= null    and then
   863.             b = FD0.number  then
   864.          return;
   865.       end if;
   866.       buffer(b) := null;
   867.       FD0 := null;
   868.       FD0_number := 0;
   869.       FD0_is_enabled := False;
   870.       enable(b);
   871.    end replace_on_buffer;
   872.
   873.    procedure remove_from_buffer (b : in KDF9.buffer_number) is
   874.    begin
   875.       if FD0 /= null    and then
   876.             b = FD0.number  then
   877.          buffer(b) := null;
   878.          FD0 := null;
   879.          FD0_number := 0;
   880.          FD0_is_enabled := False;
   881.       end if;
   882.    end remove_from_buffer;
   883.
   884. end IOC.fast.FD;

Compiling: ../Source/ioc-fast-fd.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:01

     1. -- Emulation of a fixed disc drive.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.FD is
    18.
    19.    type device is new fast.device with private;
    20.
    21.    overriding
    22.    procedure PIA (the_FD      : in out FD.device;
    23.                   Q_operand   : in KDF9.Q_register;
    24.                   set_offline : in Boolean);
    25.
    26.    overriding
    27.    procedure PIB (the_FD      : in out FD.device;
    28.                   Q_operand   : in KDF9.Q_register;
    29.                   set_offline : in Boolean);
    30.
    31.    overriding
    32.    procedure PIC (the_FD      : in out FD.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    overriding
    37.    procedure PID (the_FD      : in out FD.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    overriding
    42.    procedure PIE (the_FD      : in out FD.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    overriding
    47.    procedure PIF (the_FD      : in out FD.device;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    overriding
    52.    procedure PIG (the_FD      : in out FD.device;
    53.                   Q_operand   : in KDF9.Q_register;
    54.                   set_offline : in Boolean);
    55.
    56.    overriding
    57.    procedure PIH (the_FD      : in out FD.device;
    58.                   Q_operand   : in KDF9.Q_register;
    59.                   set_offline : in Boolean);
    60.
    61.    overriding
    62.    procedure PMA (the_FD      : in out FD.device;
    63.                   Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean);
    65.
    66.    overriding
    67.    procedure PMB (the_FD      : in out FD.device;
    68.                   Q_operand   : in KDF9.Q_register;
    69.                   set_offline : in Boolean);
    70.
    71.    overriding
    72.    procedure PMC (the_FD      : in out FD.device;
    73.                   Q_operand   : in KDF9.Q_register;
    74.                   set_offline : in Boolean);
    75.
    76.    overriding
    77.    procedure PMD (the_FD      : in out FD.device;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    overriding
    82.    procedure PMF (the_FD      : in out FD.device;
    83.                   Q_operand   : in KDF9.Q_register;
    84.                   set_offline : in Boolean);
    85.
    86.    overriding
    87.    procedure POA (the_FD      : in out FD.device;
    88.                   Q_operand   : in KDF9.Q_register;
    89.                   set_offline : in Boolean);
    90.
    91.    overriding
    92.    procedure POB (the_FD      : in out FD.device;
    93.                   Q_operand   : in KDF9.Q_register;
    94.                   set_offline : in Boolean);
    95.
    96.    overriding
    97.    procedure POC (the_FD      : in out FD.device;
    98.                   Q_operand   : in KDF9.Q_register;
    99.                   set_offline : in Boolean);
   100.
   101.    overriding
   102.    procedure POD (the_FD      : in out FD.device;
   103.                   Q_operand   : in KDF9.Q_register;
   104.                   set_offline : in Boolean);
   105.
   106.    overriding
   107.    procedure POE (the_FD      : in out FD.device;
   108.                   Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean);
   110.
   111.    overriding
   112.    procedure POF (the_FD      : in out FD.device;
   113.                   Q_operand   : in KDF9.Q_register;
   114.                   set_offline : in Boolean);
   115.
   116.    overriding
   117.    procedure POG (the_FD      : in out FD.device;
   118.                   Q_operand   : in KDF9.Q_register;
   119.                   set_offline : in Boolean);
   120.
   121.    overriding
   122.    procedure POH (the_FD      : in out FD.device;
   123.                   Q_operand   : in KDF9.Q_register;
   124.                   set_offline : in Boolean);
   125.
   126.    overriding
   127.    procedure POK (the_FD      : in out FD.device;
   128.                   Q_operand   : in KDF9.Q_register;
   129.                   set_offline : in Boolean);
   130.
   131.    overriding
   132.    procedure POL (the_FD      : in out FD.device;
   133.                   Q_operand   : in KDF9.Q_register;
   134.                   set_offline : in Boolean);
   135.
   136.    FD0_is_enabled : Boolean := False;
   137.
   138.    procedure enable (b : in KDF9.buffer_number);
   139.
   140.    procedure replace_on_buffer (b : in KDF9.buffer_number);
   141.
   142.    procedure remove_from_buffer (b : in KDF9.buffer_number);
   143.
   144.    function as_FD_command (Q_operand : KDF9.Q_register; for_seek, for_FH : Boolean := False)
   145.    return String;
   146.
   147. private
   148.
   149.    words_per_sector      : constant := 40;
   150.    bytes_per_sector      : constant := 8 * words_per_sector;
   151.
   152.    type sector_data      is array (KDF9.address range 0 .. bytes_per_sector-1)
   153.                          of KDF9_char_sets.symbol;
   154.
   155.    sectors_per_seek_area  : constant := 96;
   156.    sectors_in_outer_zone  : constant := 64;
   157.
   158.    subtype sector_range  is KDF9.Q_part range 0 .. sectors_per_seek_area-1;
   159.
   160.    type sector_array     is array (KDF9.Q_part range <>) of FD.sector_data;
   161.
   162.    subtype head_range    is KDF9.Q_part range 0 .. 7;
   163.
   164.    subtype inner_track   is FD.sector_array(FD.sector_range range 0 ..  7);
   165.    subtype outer_track   is FD.sector_array(FD.sector_range range 0 .. 15);
   166.
   167.    last_sector_for_head  : constant array (FD.head_range) of FD.sector_range
   168.                          := (0 .. 3 => FD.outer_track'Last,
   169.                              4 .. 7 => FD.inner_track'Last);
   170.
   171.    type outer_data       is array (FD.head_range range 0 .. 3) of FD.outer_track;
   172.    type inner_data       is array (FD.head_range range 4 .. 7) of FD.inner_track;
   173.
   174.    -- These rates come from the Manual, 6.1.
   175.    outer_rate : constant := 84_800;          -- bytes per second in the outer zone
   176.    inner_rate : constant := outer_rate / 2;  -- bytes per second in the outer zone
   177.
   178.    type track_set is
   179.       record
   180.          outer_zone : FD.outer_data;
   181.          inner_zone : FD.inner_data;
   182.       end record;
   183.
   184.    seek_areas_per_platter  : constant := 64;
   185.    subtype seek_area_range is KDF9.Q_part range 0 .. seek_areas_per_platter-1;
   186.
   187.    main_discs_per_drive    : constant := 16;
   188.    the_fixed_head_platter  : constant := 16;
   189.    platters_per_drive      : constant := main_discs_per_drive + 1;
   190.
   191.    subtype platter_range   is KDF9.Q_part range 0 .. platters_per_drive-1;
   192.
   193.    -- The Eldon 2 KDF9 at Leeds University had a 2-drive disc system.
   194.    -- This allows for the maximum number of drives possible.
   195.    number_of_drives : constant := 4;
   196.
   197.    subtype drive_range is KDF9.Q_part range 0 .. number_of_drives-1;
   198.
   199.    type locus is
   200.       record
   201.          drive_number      : FD.drive_range     := 0;
   202.          platter_number    : FD.platter_range   := 0;
   203.          seek_area_number  : FD.seek_area_range := 0;
   204.          sector_number     : FD.sector_range    := 0;
   205.          has_fixed_heads,
   206.          is_at_end_of_area : Boolean            := False;
   207.       end record;
   208.
   209.    -- The disc storage is actually implemented in an external file.
   210.    -- The comb and locus variables shadow the physical state of the drives.
   211.    -- They are used to derive a file address from the position established
   212.    --    by seek and transfer operations.
   213.
   214.    type comb_data is array (FD.drive_range, FD.platter_range) of FD.seek_area_range;
   215.
   216.    type device is new fast.device with
   217.       record
   218.          comb         : FD.comb_data := (others => (others => 0));
   219.          locus,
   220.          target       : FD.locus;
   221.          data_time,
   222.          seek_time    : KDF9.us := 0;
   223.          seek_count,
   224.          sector_count : KDF9.word := 0;
   225.       end record;
   226.
   227.    overriding
   228.    procedure Initialize (the_FD : in out FD.device);
   229.
   230.    overriding
   231.    procedure Finalize (the_FD : in out FD.device);
   232.
   233.    overriding
   234.    function kind (the_FD : FD.device)
   235.    return IOC.device_kind
   236.    is (FD_kind);
   237.
   238.    overriding
   239.    function quantum (the_FD : FD.device)
   240.    return KDF9.us
   241.    is ((1E6 + outer_rate - 1) / outer_rate);
   242.
   243.    FD0_number : KDF9.buffer_number := 0;
   244.
   245. end IOC.fast.FD;

 884 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-fast-tape.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:01

     1. -- Emulation of magnetic tape decks and buffers.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.IO_Exceptions;
    18.
    19. package body IOC.fast.tape is
    20.
    21.    --
    22.    -- Ada direct-access file management.
    23.    --
    24.
    25.    procedure open_RO (the_tape : in out tape.file; name : in String) is
    26.    begin
    27.       MT_slice_IO.Open(the_tape.reel, In_File, name);
    28.       the_tape.has_a_WP_ring := False;
    29.    exception
    30.       when others =>
    31.          trap_operator_error(abs name + "cannot be opened, even for reading");
    32.    end open_RO;
    33.
    34.    procedure open_RW (the_tape : in out tape.file; name : in String) is
    35.    begin
    36.       MT_slice_IO.Open(the_tape.reel, Inout_File, name);
    37.       the_tape.has_a_WP_ring := True;
    38.    exception
    39.       when Ada.IO_Exceptions.Use_Error =>
    40.          the_tape.has_a_WP_ring := False;
    41.          open_RO(the_tape, name);
    42.       when Ada.IO_Exceptions.Name_Error =>
    43.          trap_operator_error(abs name + "cannot be opened");
    44.    end open_RW;
    45.
    46.    procedure close (the_tape : in out tape.file) is
    47.    begin
    48.       if the_tape.has_a_WP_ring then
    49.          MT_slice_IO.Flush(the_tape.reel);
    50.       end if;
    51.       MT_slice_IO.Close(the_tape.reel);
    52.    end close;
    53.
    54.    overriding
    55.    function is_open (the_deck : tape.deck)
    56.    return Boolean
    57.    is (MT_slice_IO.Is_Open(the_deck.tape_file.reel));
    58.
    59. --
    60. --
    61.    -- Slice management.
    62. --
    63. --
    64.
    65.    procedure write_slice (the_tape : in out tape.file;
    66.                           slice    : in tape.slice) is
    67.    begin
    68.       the_tape.position := the_tape.position + 1;
    69.       MT_slice_IO.Write(the_tape.reel, slice, to => the_tape.position);
    70.       if slice.kind not in tape.gap_kind then
    71.          the_tape.last_data_index := Count'Max(the_tape.last_data_index, the_tape.position);
    72.       end if;
    73.    end write_slice;
    74.
    75.    procedure read_next_slice (the_tape : in out tape.file;
    76.                               slice    : out tape.slice) is
    77.    begin
    78.       if the_tape.last_data_index > 0 then
    79.          the_tape.position := the_tape.position + 1;
    80.          MT_slice_IO.Read(the_tape.reel, slice, from => the_tape.position);
    81.       else
    82.          trap_failing_IO_operation(Name(the_tape.reel), "is an empty file");
    83.       end if;
    84.    exception
    85.       when End_Error =>
    86.           trap_failing_IO_operation(Name(the_tape.reel), "cannot be moved forward at EOF");
    87.    end read_next_slice;
    88.
    89.    procedure read_prev_slice (the_tape : in out tape.file;
    90.                               slice    : out tape.slice) is
    91.    begin
    92.       if the_tape.position > 0 then
    93.          MT_slice_IO.Read(the_tape.reel, slice, from => the_tape.position);
    94.          the_tape.position := the_tape.position - 1;
    95.       else
    96.          trap_failing_IO_operation(Name(the_tape.reel), "cannot be moved backward at BTW");
    97.       end if;
    98.    end read_prev_slice;
    99.
   100.    procedure bound_the_written_data (the_tape : in out tape.file) is
   101.       the_slice : tape.slice;
   102.    begin
   103.       the_tape.position := Size(the_tape.reel);
   104.       if the_tape.position = 0 then
   105.          -- There is no data in the file.
   106.          the_tape.last_data_index := 0;
   107.          return;
   108.       end if;
   109.       -- Locate the last data slice (if any).
   110.       while the_tape.position > 0 loop
   111.          read_prev_slice(the_tape, the_slice);
   112.       exit when the_slice.kind not in tape.gap_kind;
   113.       end loop;
   114.       if the_slice.kind in tape.gap_kind then
   115.          the_tape.last_data_index := 0;
   116.       else
   117.          the_tape.last_data_index := the_tape.position + 1;
   118.       end if;
   119.       the_tape.position := 0;
   120.    end bound_the_written_data;
   121.
   122.    procedure reset (the_deck : in out tape.deck) is
   123.     begin
   124.       bound_the_written_data(the_deck.tape_file);
   125.       the_deck.is_LBM_flagged := False;
   126.       the_deck.is_abnormal := False;
   127.       the_deck.unwound_frames := 0;
   128.    end reset;
   129.
   130. --
   131. --
   132.    -- Tape physical characteristics.
   133. --
   134. --
   135.
   136.    -- The physical end of tape (PET) is signalled one maximum block length before the tape runs out.
   137.    --  So PET is signalled at max_block_size before the absolute maximum position
   138.    --    to avoid running past the end of the tape when a very large block is written.
   139.
   140.    -- There could be as little as 60 inches of tape between the End of Tape Warning (ETW) and PET.
   141.    -- See the Manual, 22.1.3, p.182.
   142.
   143.    overriding
   144.    procedure Initialize (the_deck : in out MT_deck) is
   145.    begin
   146.       the_deck.device_name := device_name_of(the_deck);
   147.       open_RW(the_deck.tape_file, the_deck.device_name);
   148.       Initialize(IOC.device(the_deck));
   149.       the_deck.terminator        := End_Message;
   150.       the_deck.recording_density := max_bits_per_inch;  -- bits / inch
   151.       the_deck.max_reel_length   := max_reel_length;    -- inches
   152.       the_deck.inter_block_gap := the_deck.recording_density / 3;
   153.       the_deck.tape_capacity   := the_deck.max_reel_length * the_deck.recording_density;
   154.       the_deck.PET_position    := the_deck.tape_capacity - max_block_size;
   155.       the_deck.ETW_position    := the_deck.PET_position - 60 * the_deck.recording_density;
   156.       reset(tape.deck(the_deck));
   157.    end Initialize;
   158.
   159.    overriding
   160.    procedure Initialize (the_deck : in out ST_deck) is
   161.    begin
   162.       the_deck.device_name := device_name_of(the_deck);
   163.       open_RW(the_deck.tape_file, the_deck.device_name);
   164.       Initialize(IOC.device(the_deck));
   165.       the_deck.terminator        := Group_Mark;
   166.       the_deck.recording_density := max_bits_per_inch/2;  -- bits / inch
   167.       the_deck.max_reel_length   := max_reel_length;      -- inches
   168.       the_deck.inter_block_gap := the_deck.recording_density / 3;
   169.       the_deck.tape_capacity   := the_deck.max_reel_length * the_deck.recording_density;
   170.       the_deck.PET_position    := the_deck.tape_capacity - max_block_size;
   171.       the_deck.ETW_position    := the_deck.PET_position - 60 * the_deck.recording_density;
   172.       reset(tape.deck(the_deck));
   173.    end Initialize;
   174.
   175.    function is_at_BTW (the_deck : tape.deck)
   176.    return Boolean
   177.    is (the_deck.is_open and then the_deck.tape_file.position = 0);
   178.
   179.    function holds_data (the_deck : tape.deck)
   180.    return Boolean
   181.    is (the_deck.is_open and then the_deck.tape_file.last_data_index > 0);
   182.
   183.    function is_at_ETW (the_deck : tape.deck)
   184.    return Boolean
   185.    is (the_deck.is_open and then the_deck.unwound_frames >= the_deck.ETW_position);
   186.
   187.    function is_at_PET (the_deck : tape.deck)
   188.    return Boolean
   189.    is (the_deck.is_open and then the_deck.unwound_frames >= the_deck.PET_position);
   190.
   191.    procedure deal_with_trying_to_pass_PET (the_deck : in out tape.deck;
   192.                                            do_this  : String) is
   193.    begin
   194.       if is_at_PET (the_deck) then
   195.          trap_failing_IO_operation(the_deck, "an attempt was made to" + do_this + "past PET");
   196.       end if;
   197.    end deal_with_trying_to_pass_PET;
   198.
   199.    -- There are cases that are invalid iff the tape is positioned beyond the last written block.
   200.    function is_at_EOD (the_deck : tape.deck)
   201.    return Boolean
   202.    is (the_deck.is_open and then the_deck.tape_file.position > the_deck.tape_file.last_data_index);
   203.
   204.    function tape_traversal_time (the_deck : tape.deck; tape_crossed : KDF9.word)
   205.    return KDF9.us
   206.    is (the_deck.quantum * KDF9.us(tape_crossed));
   207.
   208.    function data_transfer_time (the_deck   : tape.deck;
   209.                                 byte_count : KDF9.word)
   210.    return KDF9.us
   211.    is (the_deck.quantum * KDF9.us(byte_count));
   212.
   213.    -- This is the time the MT deck is busy traversing the interblock gap and the data block.
   214.    function MT_IO_time (the_deck  : tape.deck;
   215.                         Q_operand : in KDF9.Q_register)
   216.    return KDF9.us
   217.    is (KDF9.us(the_deck.inter_block_gap) + 8*KDF9.us(Q_operand.M-Q_operand.I+1) * the_deck.quantum);
   218.
   219.    overriding
   220.    function usage (the_deck : tape.deck)
   221.    return KDF9.word
   222.    is (the_deck.bytes_moved);
   223.
   224.    overriding
   225.    procedure close (the_deck : in out tape.deck) is
   226.    begin
   227.       the_deck.tape_file.close;
   228.    end close;
   229.
   230.    procedure update_statistics (the_deck    : in out tape.deck;
   231.                                 tape_crossed,
   232.                                 bytes_moved : in length_in_frames) is
   233.       real_time : KDF9.us;
   234.    begin
   235.       the_deck.bytes_moved := the_deck.bytes_moved + KDF9.word(bytes_moved);
   236.       real_time := tape_traversal_time(the_deck, KDF9.word(tape_crossed))
   237.                  + data_transfer_time (the_deck, KDF9.word(bytes_moved));
   238.       the_deck.elapsed_time := the_deck.elapsed_time + real_time;
   239.       add_in_the_IO_CPU_time(the_deck, KDF9.word(bytes_moved));
   240.       correct_transfer_time(the_deck, real_time);
   241.    end update_statistics;
   242.
   243. --
   244. --
   245.    -- Tape manipulations.
   246. --
   247. --
   248.
   249.    type movement is (forwards, backwards);
   250.
   251.    procedure note_tape_position (the_deck    : in out tape.deck;
   252.                                  direction   : in tape.movement;
   253.                                  tape_crossed,
   254.                                  bytes_moved : in length_in_frames) is
   255.    begin
   256.       if direction = forwards then
   257.          the_deck.unwound_frames := the_deck.unwound_frames
   258.                                   + tape.length_in_frames(tape_crossed + bytes_moved);
   259.       elsif tape.length_in_frames(tape_crossed + bytes_moved) > the_deck.unwound_frames then
   260.          the_deck.unwound_frames := 0;
   261.       else
   262.          the_deck.unwound_frames := the_deck.unwound_frames
   263.                                   - tape.length_in_frames(tape_crossed + bytes_moved);
   264.       end if;
   265.    end note_tape_position;
   266.
   267.    -- KDF9 MT operations.
   268.
   269.    -- Skip back over erased tape, leaving the_slice containing the next preceding data.
   270.    -- Postcondition: the_deck.is_at_BTW or else the_slice.kind not in tape.gap_kind
   271.    procedure skip_back_over_erasure (the_deck  : in out tape.deck;
   272.                                      the_slice : in out tape.slice;
   273.                                      crossed   : in out length_in_frames) is
   274.    begin
   275.       if the_deck.is_at_BTW then
   276.          return; -- We are as far back as we can go;
   277.       end if;
   278.       if the_slice.kind in data_kind then
   279.          return;  -- We have already found the preceding data block.
   280.       end if;
   281.       loop
   282.          read_prev_slice(the_deck.tape_file, the_slice);
   283.       exit when the_deck.is_at_BTW or else the_slice.kind not in tape.gap_kind;
   284.          crossed := crossed + the_slice.size;
   285.       end loop;
   286.    end skip_back_over_erasure;
   287.
   288.    -- Skip forward over erased tape, leaving the_slice containing the next following data.
   289.    -- Postcondition: the_deck.is_at_EOD or else the_slice.kind not in tape.gap_kind
   290.    procedure skip_forward_over_erasure (the_deck  : in out tape.deck;
   291.                                         the_slice : in out tape.slice;
   292.                                         crossed   : in out length_in_frames) is
   293.    begin
   294.       if the_slice.kind in data_slice then
   295.          return;
   296.       end if;
   297.       loop
   298.          read_next_slice(the_deck.tape_file, the_slice);
   299.       exit when the_deck.is_at_EOD or else the_slice.kind not in tape.gap_kind;
   300.          crossed := crossed + the_slice.size;
   301.       end loop;
   302.    end skip_forward_over_erasure;
   303.
   304. --
   305. --
   306.    -- Tape I/O.
   307. --
   308. --
   309.
   310.    -- Deal with blocks of invalid sizes.
   311.
   312.    -- 1081 buffers always write and read a whole number of words;
   313.    --    see Manual 22.1.5, p184, 2; and Appendix 7 3, p318.
   314.    overriding
   315.    procedure handle_any_abnormality (the_deck : in out MT_deck;
   316.                                      the_size : in length_in_frames) is
   317.    begin
   318.       the_deck.is_abnormal := the_deck.is_abnormal or (the_size mod 8 /= 0);
   319.    end handle_any_abnormality;
   320.
   321.    -- 3.4.7 of the EGDON 3 manual says that the 7-track tape buffer, due to a hardware
   322.    --    limitation, rejects blocks (other than tape marks) of less than 6 characters.
   323.    overriding
   324.    procedure handle_any_abnormality (the_deck : in out ST_deck;
   325.                                      the_size : in length_in_frames) is
   326.    begin
   327.       the_deck.is_abnormal := the_deck.is_abnormal or (the_size < 6);
   328.    end handle_any_abnormality;
   329.
   330.    procedure read_block (the_deck  : in out tape.deck;
   331.                          the_data  : out tape.block_storage;
   332.                          the_size  : out length_in_frames;
   333.                          direction : in movement := forwards) is
   334.       left,
   335.       right      : length_in_frames := 1;
   336.       block_size,
   337.       crossed    : length_in_frames := 0;
   338.       is_last,
   339.       is_flagged : Boolean := False;
   340.       the_slice  : tape.slice := a_NULL_slice;
   341.    begin
   342.       the_deck.is_LBM_flagged := False;
   343.
   344.       skip_forward_over_erasure(the_deck, the_slice, crossed);
   345.
   346.       -- Ensure that we are not beyond the end of valid data.
   347.       if the_deck.is_at_EOD then
   348.          trap_failing_IO_operation(
   349.                                    the_deck,
   350.                                    "there is no data past slice" & the_deck.tape_file.position'Image
   351.                                   );
   352.       end if;
   353.
   354.       if the_slice.kind in tape.tape_mark_kind then
   355.          -- Deal with a tape mark block; according to the Maual, Appendix 7, 2, p.317,
   356.          --    it reads as a single character with value #17.
   357.          block_size := 8;
   358.          the_data(1)    := KDF9_char_sets.TP_CN(KDF9_char_sets.Tape_Mark);
   359.          the_data(2..8) := (others => KDF9_char_sets.TP_CN(KDF9_char_sets.Blank_Space));
   360.          the_deck.is_LBM_flagged := True;
   361.       else
   362.          -- We have a bona fide data block.
   363.          the_size := 0;
   364.          -- Accumulate a series of slicefuls.
   365.          loop
   366.             right := left + the_slice.size - 1;
   367.             the_data(left .. right) := the_slice.data(1..the_slice.size);
   368.             block_size := block_size + the_slice.size;
   369.             left := left + the_slice.size;
   370.             is_flagged := is_flagged or the_slice.is_LBM_flagged;
   371.             is_last  := the_slice.is_last;
   372.          exit when is_last or block_size = max_block_size;
   373.             read_next_slice(the_deck.tape_file, the_slice);
   374.          end loop;
   375.          the_deck.is_LBM_flagged := is_flagged;
   376.       end if;
   377.       the_size := block_size;
   378.
   379.       note_tape_position(the_deck, direction,
   380.                         crossed + the_deck.inter_block_gap, bytes_moved => the_size);
   381.       update_statistics(the_deck,
   382.                         crossed + the_deck.inter_block_gap, bytes_moved => the_size);
   383.
   384.      if not is_last and block_size = max_block_size then
   385.          trap_failing_IO_operation(the_deck, "a magnetic tape block > 32KW");
   386.       end if;
   387.       handle_any_abnormality(the_deck, block_size);
   388.    end read_block;
   389.
   390.    procedure increment (word_address : in out KDF9.address;
   391.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   392.    begin
   393.       if symbol_nr < 7 then
   394.          symbol_nr := symbol_nr + 1;
   395.       else
   396.          symbol_nr := 0;
   397.          word_address := word_address + 1;
   398.       end if;
   399.    end increment;
   400.
   401.    tape_mark_data_word : constant KDF9.word := 8#17_00_00_00_00_00_00_00#;
   402.
   403.    procedure read (the_deck       : in out tape.deck;
   404.                    Q_operand      : in KDF9.Q_register;
   405.                    to_terminator  : in Boolean := False) is
   406.       start_address : constant KDF9.address := Q_operand.I;
   407.       end_address   : constant KDF9.address := Q_operand.M;
   408.       the_data : tape.block_storage;
   409.       s        : KDF9_char_sets.symbol_index;
   410.       w        : KDF9.address;
   411.       stored   : KDF9.word := 0;
   412.       the_size : length_in_frames;
   413.    begin
   414.       validate_device(the_deck);
   415.       check_addresses_and_lockouts(start_address, end_address);
   416.
   417.       read_block(the_deck, the_data, the_size);
   418.
   419.       if the_size mod 8 /= 0 and the_deck.kind = MT_kind then
   420.          -- Disregard an incomplete final word; see Manual, 22.1.5, p184, 2.
   421.          the_deck.is_abnormal := True;
   422.          the_size := the_size - the_size mod 8;
   423.       end if;
   424.
   425.       -- Store the relevant words.
   426.       w := start_address;
   427.       s := 0;
   428.       for i in 1 .. the_size loop
   429.          if s = 0 then
   430.             store_word(0, w);
   431.          end if;
   432.          store_symbol(CN_TR(the_data(i)), w, s);
   433.          stored := stored + 1;
   434.       exit when (w = end_address) and (s = 7);
   435.       exit when to_terminator and CN_TR(the_data(i)) = the_deck.terminator;
   436.          increment(w, s);
   437.       end loop;
   438.       if to_terminator then
   439.          correct_transfer_time(the_deck, stored);
   440.       end if;
   441.    end read;
   442.
   443.    procedure find_start_of_earlier_block (the_deck : in out tape.deck;
   444.                                           crossed  : in out length_in_frames) is
   445.       the_slice  : tape.slice := a_NULL_slice;
   446.       block_size : length_in_frames;
   447.    begin
   448.       if the_deck.is_at_BTW then
   449.          return; -- We have already gone as far back as possible.
   450.       end if;
   451.
   452.       -- Skip back over any erasures or tape marks.
   453.       skip_back_over_erasure(the_deck, the_slice, crossed);
   454.       crossed := crossed + the_deck.inter_block_gap;
   455.
   456.       if the_deck.is_at_BTW and the_slice.kind in tape.gap_kind then
   457.          the_deck.is_abnormal := True;
   458.          trap_failing_IO_operation(the_deck, "cannot move back, at BTW");
   459.       end if;
   460.
   461.       if not the_slice.is_last then
   462.          trap_failing_IO_operation(the_deck, "on-tape data is malformed");
   463.       end if;
   464.
   465.       -- We have reached the last slice of the block.
   466.       if the_deck.kind = ST_kind and the_slice.kind in tape_mark_kind then
   467.          block_size := 1;
   468.       else
   469.          block_size := the_slice.size;
   470.          -- Jump backwards over data slices until we reach the first of the block.
   471.          while not the_slice.is_first and then the_deck.tape_file.position > 0 loop
   472.             read_prev_slice(the_deck.tape_file, the_slice);
   473.             block_size := block_size + the_slice.size;
   474.          end loop;
   475.          handle_any_abnormality(the_deck, block_size);
   476.       end if;
   477.
   478.       crossed := crossed + block_size;
   479.    end find_start_of_earlier_block;
   480.
   481.    procedure decrement (word_address : in out KDF9.address;
   482.                         symbol_nr    : in out KDF9_char_sets.symbol_index) is
   483.    begin
   484.       if symbol_nr > 0 then
   485.          symbol_nr := symbol_nr - 1;
   486.       else
   487.          symbol_nr := 7;
   488.          word_address := word_address + 1;
   489.       end if;
   490.    end decrement;
   491.
   492.    procedure read_backwards (the_deck       : in out tape.deck;
   493.                              Q_operand      : in KDF9.Q_register;
   494.                              to_terminator  : in Boolean := False) is
   495.       start_address : constant KDF9.address := Q_operand.I;
   496.       end_address   : constant KDF9.address := Q_operand.M;
   497.       terminator    : constant KDF9_char_sets.symbol := the_deck.terminator;
   498.       the_data  : tape.block_storage;
   499.       s         : KDF9_char_sets.symbol_index;
   500.       w         : KDF9.address;
   501.       the_first,
   502.       the_last  : length_in_frames;
   503.       crossed   : length_in_frames := 0 with Warnings => Off;  -- Because its value is never used.
   504.    begin
   505.       validate_device(the_deck);
   506.       check_addresses_and_lockouts(start_address, end_address);
   507.
   508.       -- Locate the start of the previous block.
   509.       find_start_of_earlier_block(the_deck, crossed);
   510.
   511.       -- Read it normally, i.e. forwards.
   512.       read_block(the_deck, the_data, the_last, backwards);
   513.
   514.       -- And retrace our steps, to position the tape as if the block had been read backwards.
   515.       find_start_of_earlier_block(the_deck, crossed);
   516.
   517.       -- Disregard an incomplete first word; see Manual 22.1.5, p184, 2; and Appendix 7 3, p318.
   518.       if the_last mod 8 = 0 or the_deck.kind = ST_kind then
   519.          the_first := the_data'First;
   520.       elsif the_last = 1 and the_deck.kind = ST_kind then
   521.          -- See Manual, Appendix 7 2, p317.
   522.          store_word(tape_mark_data_word, start_address);
   523.       else
   524.          the_deck.is_abnormal := True;
   525.          the_first := the_data'First + the_last mod 8;
   526.       end if;
   527.
   528.       -- Store the relevant words.
   529.       w := start_address;
   530.       s := 7;
   531.       for i in reverse the_first .. the_last loop
   532.          if s = 7 then
   533.             store_word(0, w);
   534.          end if;
   535.          store_symbol(CN_TR(the_data(i)), w, s);
   536.       exit when to_terminator and CN_TR(the_data(i)) = terminator;
   537.          decrement(w, s);
   538.       end loop;
   539.    end read_backwards;
   540.
   541. --
   542. --
   543.    -- KDF9 tape input orders.
   544. --
   545. --
   546.
   547.    -- MFRQq
   548.    overriding
   549.    procedure PIA (the_deck    : in out tape.deck;
   550.                   Q_operand   : in KDF9.Q_register;
   551.                   set_offline : in Boolean) is
   552.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   553.    begin
   554.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   555.       read(the_deck, Q_operand, to_terminator => False);
   556.       lock_out_relative_addresses(Q_operand);
   557.    end PIA;
   558.
   559.    -- MFREQq
   560.    overriding
   561.    procedure PIB (the_deck    : in out tape.deck;
   562.                   Q_operand   : in KDF9.Q_register;
   563.                   set_offline : in Boolean) is
   564.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   565.    begin
   566.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   567.       read(the_deck, Q_operand, to_terminator => True);
   568.       lock_out_relative_addresses(Q_operand);
   569.    end PIB;
   570.
   571.    -- as PIA
   572.    overriding
   573.    procedure PIC (the_deck    : in out tape.deck;
   574.                   Q_operand   : in KDF9.Q_register;
   575.                   set_offline : in Boolean) is
   576.    begin
   577.       the_deck.PIA(Q_operand, set_offline);
   578.    end PIC;
   579.
   580.    -- as PIB
   581.    overriding
   582.    procedure PID (the_deck    : in out tape.deck;
   583.                   Q_operand   : in KDF9.Q_register;
   584.                   set_offline : in Boolean) is
   585.    begin
   586.       the_deck.PIB(Q_operand, set_offline);
   587.    end PID;
   588.
   589.    -- MBRQq
   590.    overriding
   591.    procedure PIE (the_deck    : in out tape.deck;
   592.                   Q_operand   : in KDF9.Q_register;
   593.                   set_offline : in Boolean) is
   594.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   595.    begin
   596.       if the_deck.is_at_BTW then
   597.          trap_illegal_instruction("MBRQq at BTW on" + the_deck.device_name);
   598.       end if;
   599.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   600.       read_backwards(the_deck, Q_operand, to_terminator => False);
   601.       if the_deck.kind = ST_kind then
   602.          the_deck.is_LBM_flagged := False;
   603.       end if;
   604.       lock_out_relative_addresses(Q_operand);
   605.    end PIE;
   606.
   607.    -- MBREQq
   608.    overriding
   609.    procedure PIF (the_deck    : in out tape.deck;
   610.                   Q_operand   : in KDF9.Q_register;
   611.                   set_offline : in Boolean) is
   612.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   613.    begin
   614.       if the_deck.is_at_BTW then
   615.          trap_illegal_instruction("MBREQq at BTW on" + the_deck.device_name);
   616.       end if;
   617.       start_data_transfer(the_deck, Q_operand, set_offline, time, input_operation);
   618.       read_backwards(the_deck, Q_operand, to_terminator => True);
   619.       if the_deck.kind = ST_kind then
   620.          the_deck.is_LBM_flagged := False;
   621.       end if;
   622.       lock_out_relative_addresses(Q_operand);
   623.    end PIF;
   624.
   625.    -- as PIE
   626.    overriding
   627.    procedure PIG (the_deck    : in out tape.deck;
   628.                   Q_operand   : in KDF9.Q_register;
   629.                   set_offline : in Boolean) is
   630.    begin
   631.       the_deck.PIE(Q_operand, set_offline);
   632.    end PIG;
   633.
   634.    -- as PIF
   635.    overriding
   636.    procedure PIH (the_deck    : in out tape.deck;
   637.                   Q_operand   : in KDF9.Q_register;
   638.                   set_offline : in Boolean) is
   639.    begin
   640.       the_deck.PIF(Q_operand, set_offline);
   641.    end PIH;
   642.
   643. --
   644. --
   645.    -- KDF9 tape movement and test orders.
   646. --
   647. --
   648.
   649.    procedure find_start_of_later_block (the_deck : in out tape.deck;
   650.                                         crossed  : in out length_in_frames) is
   651.       the_slice  : tape.slice := a_NULL_slice;
   652.       block_size : length_in_frames := 0;
   653.    begin
   654.       -- Skip over any erasures or tape marks.
   655.       skip_forward_over_erasure(the_deck, the_slice, crossed);
   656.       crossed := crossed + the_deck.inter_block_gap;
   657.
   658.       if not the_slice.is_first then
   659.          trap_failing_IO_operation(the_deck, "on-tape data is malformed");
   660.       end if;
   661.
   662.       -- We have reached the first slice of the block.
   663.       if the_deck.kind = ST_kind and the_slice.kind in tape_mark_kind then
   664.          block_size := 1;
   665.       else
   666.          block_size := the_slice.size;
   667.          -- Ignore data slices until we get to the last slice of the block.
   668.          while not the_slice.is_last loop
   669.             read_next_slice(the_deck.tape_file, the_slice);
   670.             block_size := block_size + the_slice.size;
   671.          end loop;
   672.          handle_any_abnormality(the_deck, block_size);
   673.       end if;
   674.
   675.       the_deck.is_LBM_flagged := the_slice.is_LBM_flagged;
   676.       crossed := crossed + block_size;
   677.    end find_start_of_later_block;
   678.
   679.    procedure skip_forwards (the_deck       : in out tape.deck;
   680.                             blocks_skipped : in KDF9.word) is
   681.       crossed : length_in_frames := 0;
   682.    begin
   683.       for i in 1 .. blocks_skipped loop
   684.          find_start_of_later_block(the_deck, crossed);
   685.       -- MFSKQq stops at an LBM-flagged block, or on count expiry.
   686.       -- Unlike MBSKQq it does record having seen an LBM-flagged block during the skipping.
   687.       -- See the Manual, 22.1.3, p.183, 1 and 22.1.9, p.188, -2.
   688.       exit when the_deck.is_LBM_flagged;
   689.       end loop;
   690.       note_tape_position(the_deck, forwards, crossed, bytes_moved => 0);
   691.       update_statistics(the_deck, crossed, bytes_moved => 0);
   692.    end skip_forwards;
   693.
   694.    -- MFSKQq
   695.    overriding
   696.    procedure PMA (the_deck    : in out tape.deck;
   697.                   Q_operand   : in KDF9.Q_register;
   698.                   set_offline : in Boolean) is
   699.    begin
   700.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   701.       if Q_operand.M = 0 then
   702.          skip_forwards(the_deck, 32768);  -- See Manual 22.1.9, p188, 1.
   703.       else
   704.          require_positive_count(Q_operand.M);
   705.          skip_forwards(the_deck, KDF9.word(Q_operand.M));
   706.       end if;
   707.    end PMA;
   708.
   709.    -- MBTQq
   710.    overriding
   711.    procedure PMB (the_deck    : in out tape.deck;
   712.                   Q_operand   : in KDF9.Q_register;
   713.                   set_offline : in Boolean) is
   714.    begin
   715.       validate_device(the_deck);
   716.       validate_parity(the_deck);
   717.       deal_with_a_busy_device(the_deck, 14, set_offline);
   718.       the_T_bit_is_set := the_deck.is_at_BTW and the_deck.holds_data;
   719.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   720.    end PMB;
   721.
   722.    -- MLBQq
   723.    overriding
   724.    procedure PMC (the_deck    : in out tape.deck;
   725.                   Q_operand   : in KDF9.Q_register;
   726.                   set_offline : in Boolean) is
   727.    begin
   728.       validate_device(the_deck);
   729.       validate_parity(the_deck);
   730.       deal_with_a_busy_device(the_deck, 14, set_offline);
   731.       the_T_bit_is_set := the_deck.is_LBM_flagged;
   732.       the_deck.is_LBM_flagged := False;
   733.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   734.    end PMC;
   735.
   736.    procedure skip_backwards (the_deck       : in out tape.deck;
   737.                              blocks_skipped : in KDF9.word) is
   738.       crossed : length_in_frames := 0;
   739.    begin
   740.       for i in 1 .. blocks_skipped loop
   741.       exit when the_deck.is_at_BTW;  -- I.e., the tape is fully rewound.
   742.          find_start_of_earlier_block(the_deck, crossed);
   743.       -- MBSKQq does not stop at an LBM-flagged block, only at BTW or count expiry.
   744.       -- It ignores LBM flags encountered during the skipping.
   745.       -- See the Manual, 22.1.3, p.183, 1 and 22.1.9, p.188, -2.
   746.       end loop;
   747.       note_tape_position(the_deck, backwards, crossed, bytes_moved => 0);
   748.       update_statistics(the_deck, crossed, bytes_moved => 0);
   749.    end skip_backwards;
   750.
   751.    -- MRWDQq
   752.    overriding
   753.    procedure PMD (the_deck    : in out tape.deck;
   754.                   Q_operand   : in KDF9.Q_register;
   755.                   set_offline : in Boolean) is
   756.       byte_count,
   757.       tape_length : length_in_frames := 0;
   758.       the_slice   : tape.slice;
   759.    begin  -- PMD
   760.       the_deck.is_abnormal := False;  -- See Manual 22.1.9, p.189, -2.
   761.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   762.       -- No motion takes place if the tape is at BTW; see Manual 22.1.9, p.190, 1.
   763.       if the_deck.tape_file.position > 0 then
   764.          -- Make sure we dont try to read past the end of data.
   765.          -- Spool back to the BTW, accumulating distances.
   766.          while the_deck.tape_file.position > 0 loop
   767.             read_prev_slice(the_deck.tape_file, the_slice);
   768.             case the_slice.kind is
   769.                when data_slice =>
   770.                   byte_count := byte_count + the_slice.size;
   771.                   if the_slice.is_first then
   772.                      tape_length := tape_length + the_deck.inter_block_gap;
   773.                   end if;
   774.                when GAP_slice
   775.                   | WIPE_slice =>
   776.                   tape_length := tape_length + the_slice.size;
   777.                when others =>
   778.                   null;
   779.             end case;
   780.          end loop;
   781.       else
   782.          -- No motion takes place; see Manual 22.1.9, p.190, 1.
   783.          null;
   784.       end if;
   785.
   786.       update_statistics(the_deck, tape_length + byte_count, bytes_moved => 0);
   787.
   788.       reset(the_deck);
   789.    end PMD;
   790.
   791.    -- MBSKQq
   792.    overriding
   793.    procedure PME (the_deck    : in out tape.deck;
   794.                   Q_operand   : in KDF9.Q_register;
   795.                   set_offline : in Boolean) is
   796.    begin
   797.       if the_deck.is_at_BTW then
   798.          trap_illegal_instruction("MBSKQq at BTW on" + the_deck.device_name);
   799.       end if;
   800.       start_data_transfer(the_deck, Q_operand, set_offline, 19);
   801.       if Q_operand.M = 0 then
   802.          skip_backwards(the_deck, 32768);  -- See Manual 22.1.9, p188, 1.
   803.       else
   804.          require_positive_count(Q_operand.M);
   805.          skip_backwards(the_deck, KDF9.word(Q_operand.M));
   806.       end if;
   807.    end PME;
   808.
   809.    -- METQq
   810.    overriding
   811.    procedure PMF (the_deck    : in out tape.deck;
   812.                   Q_operand   : in KDF9.Q_register;
   813.                   set_offline : in Boolean) is
   814.    begin
   815.       validate_device(the_deck);
   816.       validate_parity(the_deck);
   817.       deal_with_a_busy_device(the_deck, 13, set_offline);
   818.       the_T_bit_is_set := the_deck.is_at_ETW;
   819.       take_note_of_test(the_deck.device_name, Q_operand, the_T_bit_is_set);
   820.    end PMF;
   821.
   822.    -- PMKQq, forward skip, even parity, for character data with "group mark" (8#77#)
   823.    overriding
   824.    procedure PMK (the_deck    : in out tape.deck;
   825.                   Q_operand   : in KDF9.Q_register;
   826.                   set_offline : in Boolean) is
   827.    begin
   828.       if the_deck.kind = MT_kind then
   829.          trap_illegal_instruction("PMKQq on 1081 deck" + the_deck.device_name);
   830.       else
   831.          the_deck.PMA(Q_operand, set_offline);
   832.       end if;
   833.    end PMK;
   834.
   835.    -- PMLQq, backward skip, even parity, for character data with "group mark" (8#77#)
   836.    overriding
   837.    procedure PML (the_deck    : in out tape.deck;
   838.                   Q_operand   : in KDF9.Q_register;
   839.                   set_offline : in Boolean) is
   840.    begin
   841.       if the_deck.kind = MT_kind then
   842.          trap_illegal_instruction("PMLQq on 1081 deck" + the_deck.device_name);
   843.       else
   844.          the_deck.PMB(Q_operand, set_offline);
   845.       end if;
   846.    end PML;
   847.
   848. --
   849. --
   850.    -- KDF9 tape output orders.
   851. --
   852. --
   853.
   854.    procedure put_data_slice (the_deck   : in out tape.deck;
   855.                              data       : in tape.data_storage;
   856.                              size       : in length_in_frames;
   857.                              is_first,
   858.                              is_last,
   859.                              is_flagged : in Boolean) is
   860.       the_slice : tape.slice;
   861.    begin
   862.       the_slice := (
   863.                     data_slice,
   864.                     is_LBM_flagged => is_flagged,
   865.                     is_first => put_data_slice.is_first,
   866.                     is_last  => put_data_slice.is_last,
   867.                     size     => put_data_slice.size,
   868.                     data     => erased_gap_data
   869.                    );
   870.       the_slice.data(1 .. put_data_slice.size) := put_data_slice.data;
   871.       write_slice(the_deck.tape_file, the_slice);
   872.    end put_data_slice;
   873.
   874.    procedure write_block (the_deck       : in out tape.deck;
   875.                           the_data       : in tape.data_storage;
   876.                           is_LBM_flagged : in Boolean) is
   877.       remnant  : length_in_frames := the_data'Length;
   878.       from     : length_in_frames;
   879.       the_size : length_in_frames;
   880.    begin
   881.       if not the_deck.tape_file.has_a_WP_ring then
   882.          trap_operator_error(the_deck.device_name + "does not have a Write Permit Ring");
   883.       end if;
   884.
   885.       deal_with_trying_to_pass_PET(the_deck, "write");
   886.
   887.       the_deck.is_LBM_flagged := False;
   888.
   889.       -- Write the first (and possibly final) slice of the block.
   890.       the_size := (if remnant > slice_size_limit then slice_size_limit else remnant);
   891.       remnant := remnant - the_size;
   892.       from := the_data'First;
   893.       put_data_slice (
   894.                       the_deck,
   895.                       the_data(from .. the_size),
   896.                       the_size,
   897.                       is_first   => True,
   898.                       is_last    => remnant = 0,
   899.                       is_flagged => write_block.is_LBM_flagged
   900.                      );
   901.
   902.       -- Write any full slices, the last of which may be final.
   903.       while remnant >= slice_size_limit loop
   904.          deal_with_trying_to_pass_PET(the_deck, "write");
   905.          remnant := remnant - slice_size_limit;
   906.          from := from + slice_size_limit;
   907.          put_data_slice (
   908.                          the_deck,
   909.                          the_data(from .. from+slice_size_limit-1),
   910.                          slice_size_limit,
   911.                          is_first   => False,
   912.                          is_last    => remnant = 0,
   913.                          is_flagged => write_block.is_LBM_flagged
   914.                         );
   915.       end loop;
   916.
   917.       -- Write the residue as a final slice of the block.
   918.       if remnant > 0 then
   919.          put_data_slice (
   920.                          the_deck,
   921.                          the_data(from+slice_size_limit .. the_data'Last),
   922.                          remnant,
   923.                          is_first   => False,
   924.                          is_last    => True,
   925.                          is_flagged => write_block.is_LBM_flagged
   926.                         );
   927.       end if;
   928.
   929.       note_tape_position(the_deck, forwards,
   930.                         the_deck.inter_block_gap, bytes_moved => the_data'Length);
   931.       update_statistics(the_deck,
   932.                         the_deck.inter_block_gap, bytes_moved => the_data'Length);
   933.
   934.    end write_block;
   935.
   936.    procedure write (the_deck       : in out tape.deck;
   937.                     Q_operand      : in KDF9.Q_register;
   938.                     is_LBM_flagged : in Boolean := False) is
   939.       start_address : constant KDF9.address := Q_operand.I;
   940.       end_address   : constant KDF9.address := Q_operand.M;
   941.    begin
   942.       validate_device(the_deck);
   943.       check_addresses_and_lockouts(start_address, end_address);
   944.       declare
   945.          next_byte : length_in_frames := 1;
   946.          the_data  : tape.data_storage(1 .. length_in_frames(end_address-start_address+1)*8);
   947.       begin
   948.       word_loop:
   949.          for w in start_address .. end_address loop
   950.             for c in KDF9_char_sets.symbol_index'Range loop
   951.                the_data(next_byte) := TP_CN(fetch_symbol(w, c));
   952.                next_byte := next_byte + 1;
   953.             end loop;
   954.          end loop word_loop;
   955.          write_block(the_deck, the_data, is_LBM_flagged);
   956.       end;
   957.    end write;
   958.
   959.    procedure write_to_terminator (the_deck       : in out tape.deck;
   960.                                   Q_operand      : in KDF9.Q_register;
   961.                                   is_LBM_flagged : in Boolean := False) is
   962.       start_address : constant KDF9.address := Q_operand.I;
   963.       end_address   : constant KDF9.address := Q_operand.M;
   964.    begin
   965.       validate_device(the_deck);
   966.       check_addresses_and_lockouts(start_address, end_address);
   967.       declare
   968.          next_byte : length_in_frames := 1;
   969.          the_data  : tape.data_storage(1 .. length_in_frames(end_address-start_address+1)*8);
   970.          symbol    : KDF9_char_sets.symbol;
   971.       begin
   972.       word_loop:
   973.          for w in start_address .. end_address loop
   974.             for c in KDF9_char_sets.symbol_index'Range loop
   975.                symbol := fetch_symbol(w, c);
   976.                the_data(next_byte) := TP_CN(symbol);
   977.                next_byte := next_byte + 1;
   978.          exit word_loop when symbol = the_deck.terminator;
   979.             end loop;
   980.          end loop word_loop;
   981.          if the_deck.kind = MT_kind then
   982.             -- Pad out the last word to a full 8 symbols; 7-track decks do not do this.
   983.             while next_byte mod 8 /= 1 loop
   984.                the_data(next_byte) := TP_CN(0);
   985.                next_byte := next_byte + 1;
   986.             end loop;
   987.          end if;
   988.          write_block(the_deck, the_data(1 .. next_byte-1), is_LBM_flagged);
   989.          correct_transfer_time(the_deck, KDF9.word(next_byte-1));
   990.       end;
   991.    end write_to_terminator;
   992.
   993.    -- MWQq
   994.    overriding
   995.    procedure POA (the_deck    : in out tape.deck;
   996.                   Q_operand   : in KDF9.Q_register;
   997.                   set_offline : in Boolean) is
   998.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
   999.    begin
  1000.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1001.       write(the_deck, Q_operand);
  1002.       lock_out_relative_addresses(Q_operand);
  1003.    end POA;
  1004.
  1005.    -- MWEQq
  1006.    overriding
  1007.    procedure POB (the_deck    : in out tape.deck;
  1008.                   Q_operand   : in KDF9.Q_register;
  1009.                   set_offline : in Boolean) is
  1010.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1011.    begin
  1012.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1013.       write_to_terminator(the_deck, Q_operand);
  1014.       lock_out_relative_addresses(Q_operand);
  1015.    end POB;
  1016.
  1017.    procedure put_ST_tapemark_slice (the_deck    : in out tape.deck;
  1018.                                     Q_operand   : in KDF9.Q_register;
  1019.                                     set_offline : in Boolean;
  1020.                                     the_slice   : in tape.slice) is
  1021.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, (Q_operand.C, 0, 0));
  1022.    begin
  1023.       start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1024.       write_slice(the_deck.tape_file, the_slice);
  1025.    end put_ST_tapemark_slice;
  1026.
  1027.    -- MLWQq
  1028.    overriding
  1029.    procedure POC (the_deck    : in out tape.deck;
  1030.                   Q_operand   : in KDF9.Q_register;
  1031.                   set_offline : in Boolean) is
  1032.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1033.    begin
  1034.       if the_deck.kind = MT_kind then
  1035.          start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1036.          write(the_deck, Q_operand, is_LBM_flagged => True);
  1037.          lock_out_relative_addresses(Q_operand);
  1038.       else
  1039.          put_ST_tapemark_slice(the_deck, Q_operand, set_offline, odd_parity_tape_mark);
  1040.       end if;
  1041.    end POC;
  1042.
  1043.    -- MLWEQq
  1044.    overriding
  1045.    procedure POD (the_deck    : in out tape.deck;
  1046.                   Q_operand   : in KDF9.Q_register;
  1047.                   set_offline : in Boolean) is
  1048.       time : constant KDF9.us :=  22 + MT_IO_time(the_deck, Q_operand);
  1049.    begin
  1050.       if the_deck.kind = MT_kind then
  1051.          start_data_transfer(the_deck, Q_operand, set_offline, time, output_operation);
  1052.          write_to_terminator(the_deck, Q_operand, is_LBM_flagged => True);
  1053.          lock_out_relative_addresses(Q_operand);
  1054.       else
  1055.          put_ST_tapemark_slice(the_deck, Q_operand, set_offline, even_parity_tape_mark);
  1056.       end if;
  1057.    end POD;
  1058.
  1059.    procedure erase_tape_gap (the_deck     : in out tape.deck;
  1060.                              the_length   : in KDF9.Q_part; -- the_length is a number of words.
  1061.                              the_gap_kind : in tape.gap_kind) is
  1062.       crossing  : constant length_in_frames := length_in_frames(the_length) * 8;
  1063.       the_slice : tape.slice := (if the_gap_kind = GAP_slice then a_GAP_slice else a_WIPE_slice);
  1064.       remnant   : length_in_frames := crossing;
  1065.       old_slice : tape.slice;
  1066.       the_size  : length_in_frames;
  1067.    begin
  1068.       loop
  1069.          deal_with_trying_to_pass_PET(the_deck, "erase");
  1070.          the_size := length_in_frames'Min(remnant, slice_size_limit);
  1071.          remnant  := remnant - the_size;
  1072.
  1073.          the_slice.size := the_size;
  1074.
  1075.          if the_gap_kind = GAP_slice  and then
  1076.                not the_deck.is_at_EOD then
  1077.             -- Safety rules apply to erasing gaps; see the Manual, Appendix 6.8, p.314.
  1078.             read_next_slice(the_deck.tape_file, old_slice);
  1079.             if old_slice.kind /= WIPE_slice then
  1080.                trap_failing_IO_operation(
  1081.                                          the_deck,
  1082.                                          "a GAP of length"
  1083.                                        & the_length'Image
  1084.                                        + "words would overwrite data at slice"
  1085.                                        & the_deck.tape_file.position'Image
  1086.                                         );
  1087.             end if;
  1088.             -- Restore the writing position.
  1089.             read_prev_slice(the_deck.tape_file, old_slice);
  1090.          end if;
  1091.
  1092.          write_slice(the_deck.tape_file, the_slice);
  1093.       exit when remnant = 0;
  1094.       end loop;
  1095.
  1096.       the_deck.is_LBM_flagged := False;
  1097.       note_tape_position(the_deck, forwards, crossing, bytes_moved => 0);
  1098.       update_statistics(the_deck, crossing, bytes_moved => 0);
  1099.    end erase_tape_gap;
  1100.
  1101.    -- MGAPQq
  1102.    overriding
  1103.    procedure POE (the_deck    : in out tape.deck;
  1104.                   Q_operand   : in KDF9.Q_register;
  1105.                   set_offline : in Boolean) is
  1106.       time : constant KDF9.us := 19+IO_elapsed_time(the_deck, KDF9.word(Q_operand.M));
  1107.    begin
  1108.       if not the_deck.tape_file.has_a_WP_ring then
  1109.          trap_operator_error(the_deck.device_name + "does not have a Write Permit Ring");
  1110.       end if;
  1111.       require_positive_count(Q_operand.M);
  1112.       start_data_transfer(the_deck, Q_operand, set_offline, time);
  1113.       erase_tape_gap(the_deck, Q_operand.M, the_gap_kind => GAP_slice);
  1114.    end POE;
  1115.
  1116.    -- MWIPEQq
  1117.    overriding
  1118.    procedure POF (the_deck    : in out tape.deck;
  1119.                   Q_operand   : in KDF9.Q_register;
  1120.                   set_offline : in Boolean) is
  1121.       time : constant KDF9.us := 19+IO_elapsed_time(the_deck, KDF9.word(Q_operand.M));
  1122.    begin
  1123.       if not the_deck.tape_file.has_a_WP_ring then
  1124.          trap_operator_error(the_deck.device_name + "does not have a Write Permit Ring");
  1125.       end if;
  1126.       require_positive_count(Q_operand.M);
  1127.       start_data_transfer(the_deck, Q_operand, set_offline, time);
  1128.       erase_tape_gap(the_deck, Q_operand.M, the_gap_kind => WIPE_slice);
  1129.    end POF;
  1130.
  1131.    overriding
  1132.    procedure Finalize (the_deck : in out tape.deck) is
  1133.       the_deck_was_used : constant Boolean := the_deck.bytes_moved /= 0 or not the_deck.is_at_BTW;
  1134.       buffer            : constant String  := oct_of(KDF9.Q_part(the_deck.number), 2);
  1135.    begin
  1136.       if the_deck.is_open then
  1137.          if (the_final_state_is_wanted and the_log_is_wanted) and then
  1138.                the_deck_was_used                                  then
  1139.             log_line(
  1140.                      the_deck.device_name
  1141.                    + "on buffer #"
  1142.                    & buffer
  1143.                    + "transferred"
  1144.                    & the_deck.bytes_moved'Image
  1145.                    + ("character" & plurality(the_deck.bytes_moved))
  1146.                    & (
  1147.                       if    the_deck.is_at_PET then ", and is now at PET."
  1148.                       elsif the_deck.is_at_ETW then ", and is now at ETW."
  1149.                       else                          "."
  1150.                      )
  1151.                    );
  1152.          end if;
  1153.          close(the_deck.tape_file);
  1154.       end if;
  1155.    end Finalize;
  1156.
  1157.
  1158. --
  1159. --
  1160.    -- KDF9 tape configuration.
  1161. --
  1162. --
  1163.
  1164.    type tape_access is access tape.deck'Class;
  1165.    tape_deck         : array (IOC.unit_number range 0..14) of tape_access with Warnings => Off;
  1166.
  1167.    -- This cannot overflow, because there must be at least 2 non-tape buffers: FW0 and TR0.
  1168.    tape_units, ST_units : IOC.unit_number := 0;
  1169.
  1170.    procedure enable_MT_deck (b : in KDF9.buffer_number) is
  1171.    begin
  1172.       if tape_units > tape_deck'Last then
  1173.          trap_operator_error("too many tape decks specified");
  1174.       end if;
  1175.       tape_deck(tape_units) := new MT_deck (number => b, unit => tape_units-ST_units);
  1176.       tape_units := tape_units + 1;
  1177.    end enable_MT_deck;
  1178.
  1179.    procedure enable_ST_deck (b : in KDF9.buffer_number) is
  1180.    begin
  1181.       if tape_units > tape_deck'Last then
  1182.          trap_operator_error("too many tape decks specified");
  1183.       end if;
  1184.       tape_deck(tape_units) := new ST_deck (number => b, unit => ST_units);
  1185.       tape_units := tape_units + 1;
  1186.       ST_units   := ST_units + 1;
  1187.    end enable_ST_deck;
  1188.
  1189.    -- This is for use by Directors.
  1190.    procedure find_tape (the_label  : in  tape.data_storage;
  1191.                         its_number : out KDF9.buffer_number;
  1192.                         its_serial : out KDF9.word) is
  1193.
  1194.       function as_word (the_serial : tape.data_storage)
  1195.       return KDF9.word is
  1196.          word : KDF9.word := 0;
  1197.       begin
  1198.          for b in the_serial'Range loop
  1199.             word := (word * 2**6) or KDF9.word(CN_TR(the_serial(b)));
  1200.          end loop;
  1201.          return word;
  1202.       end as_word;
  1203.
  1204.       the_block : tape.data_storage(1 .. max_block_size);
  1205.       the_size  : length_in_frames;
  1206.
  1207.    begin -- find_tape
  1208.       for t in KDF9.buffer_number loop
  1209.          if buffer(t) /= null                      and then
  1210.                buffer(t).kind in MT_kind | ST_kind and then
  1211.                    is_unallocated(buffer(t))           then
  1212.             declare
  1213.                the_deck : tape.deck renames tape.deck(buffer(t).all);
  1214.             begin
  1215.                if the_deck.holds_data  and then
  1216.                      the_deck.is_at_BTW    then
  1217.                   -- Read the label.
  1218.                   -- After reading the label the tape must be set back to BTW,
  1219.                   -- as is required to emulate Director; see the Manual, 22.1, Ex. 1.
  1220.                   read_block(the_deck, the_block, the_size);
  1221.                   reset(the_deck);
  1222.                   if the_size >= 8+the_label'Length                and then
  1223.                         the_block(9 .. 8+the_label'Length) = the_label then
  1224.                      its_number := t;
  1225.                      its_serial := as_word(the_block(1 .. 8));
  1226.                      return;
  1227.                   end if;
  1228.                end if;
  1229.             end;
  1230.          end if;
  1231.       end loop;
  1232.       trap_operator_error(abs String(the_label) + "has not been mounted");
  1233.    end find_tape;
  1234.
  1235. end IOC.fast.tape;

Compiling: ../Source/ioc-fast-tape.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:01

     1. -- Emulation of magnetic tape decks and buffers.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18.
    19. private with Ada.Direct_IO;
    20. --
    21. private with IOC_tape_data;
    22.
    23. use  KDF9_char_sets;
    24.
    25. package IOC.fast.tape is
    26.
    27.    -- Both the EE 1081 (MT) and the Ampex TM-4 7-track (ST) decks are emulated.
    28.    --
    29.    -- EE 1081, 16-track tape deck.
    30.       -- The physical characteristics of the deck are taken from the Manual, 22.1.2, i.e.:
    31.       -- 0.3 inch interblock gap, 400 ch/inch density, 100 inch/s tape speed,
    32.       --    full-reel rewind time ~3 minutes.
    33.    --
    34.    -- Ampex TM-4, 7-track IBM-compatible, tape deck.
    35.       -- The physical characteristics of the deck are taken from the Ampex document:
    36.       --    TECHNICAL MANUAL FOR SDSTM-4 TAPE TRANSPORT of 1963/2/15.
    37.       -- Where alternative characteristics are described, this code uses those considered to be of
    38.       --    greatest data interchange compatibility, as this is how the deck was used on KDF9, i.e.:
    39.       -- 0.3 inch interblock gap, 200 ch/inch density, 75 inch/s tape speed,
    40.       --    full-reel rewind time ~3 minutes.
    41.    --
    42.
    43.    type deck is abstract new fast.device with private;
    44.
    45.    -- MRFQq
    46.    overriding
    47.    procedure PIA (the_deck    : in out tape.deck;
    48.                   Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    -- MFREQq
    52.    overriding
    53.    procedure PIB (the_deck    : in out tape.deck;
    54.                   Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    -- as PIA
    58.    overriding
    59.    procedure PIC (the_deck    : in out tape.deck;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    -- as PID
    64.    overriding
    65.    procedure PID (the_deck    : in out tape.deck;
    66.                   Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    -- MBRQq
    70.    overriding
    71.    procedure PIE (the_deck    : in out tape.deck;
    72.                   Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    -- MBREQq
    76.    overriding
    77.    procedure PIF (the_deck    : in out tape.deck;
    78.                   Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    -- as PIE
    82.    overriding
    83.    procedure PIG (the_deck    : in out tape.deck;
    84.                   Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    -- as PIF
    88.    overriding
    89.    procedure PIH (the_deck    : in out tape.deck;
    90.                   Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean);
    92.
    93.    -- MFSKQq, for odd parity on 7-track deck
    94.    overriding
    95.    procedure PMA (the_deck    : in out tape.deck;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean);
    98.
    99.    -- MBTQq
   100.    overriding
   101.    procedure PMB (the_deck    : in out tape.deck;
   102.                   Q_operand   : in KDF9.Q_register;
   103.                   set_offline : in Boolean);
   104.
   105.    -- MLBQq
   106.    overriding
   107.    procedure PMC (the_deck    : in out tape.deck;
   108.                   Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean);
   110.    -- MRWDQq
   111.    overriding
   112.    procedure PMD (the_deck    : in out tape.deck;
   113.                   Q_operand   : in KDF9.Q_register;
   114.                   set_offline : in Boolean);
   115.
   116.    -- MBSKQqMFSKQq, for odd parity on 7-track deck
   117.    overriding
   118.    procedure PME (the_deck    : in out tape.deck;
   119.                   Q_operand   : in KDF9.Q_register;
   120.                   set_offline : in Boolean);
   121.
   122.    -- METQq
   123.    overriding
   124.    procedure PMF (the_deck    : in out tape.deck;
   125.                   Q_operand   : in KDF9.Q_register;
   126.                   set_offline : in Boolean);
   127.
   128.    -- PMKQq, forward skip, even parity, for 7-track deck only
   129.    overriding
   130.    procedure PMK (the_deck    : in out tape.deck;
   131.                   Q_operand   : in KDF9.Q_register;
   132.                   set_offline : in Boolean);
   133.
   134.    -- PMLQq, backward skip, even parity, for 7-track deck only
   135.    overriding
   136.    procedure PML (the_deck    : in out tape.deck;
   137.                   Q_operand   : in KDF9.Q_register;
   138.                   set_offline : in Boolean);
   139.
   140.    -- MWQq
   141.    overriding
   142.    procedure POA (the_deck    : in out tape.deck;
   143.                   Q_operand   : in KDF9.Q_register;
   144.                   set_offline : in Boolean);
   145.
   146.    -- MWEQq
   147.    overriding
   148.    procedure POB (the_deck    : in out tape.deck;
   149.                   Q_operand   : in KDF9.Q_register;
   150.                   set_offline : in Boolean);
   151.
   152.    -- MLWQq
   153.    overriding
   154.    procedure POC (the_deck    : in out tape.deck;
   155.                   Q_operand   : in KDF9.Q_register;
   156.                   set_offline : in Boolean);
   157.
   158.    -- MLWEQq
   159.    overriding
   160.    procedure POD (the_deck    : in out tape.deck;
   161.                   Q_operand   : in KDF9.Q_register;
   162.                   set_offline : in Boolean);
   163.
   164.    -- MGAPQq
   165.    overriding
   166.    procedure POE (the_deck    : in out tape.deck;
   167.                   Q_operand   : in KDF9.Q_register;
   168.                   set_offline : in Boolean);
   169.
   170.    -- MWIPEQq
   171.    overriding
   172.    procedure POF (the_deck    : in out tape.deck;
   173.                   Q_operand   : in KDF9.Q_register;
   174.                   set_offline : in Boolean);
   175.
   176.    procedure enable_MT_deck (b : in KDF9.buffer_number);
   177.
   178.    procedure enable_ST_deck (b : in KDF9.buffer_number);
   179.
   180. private
   181.
   182.    use IOC_tape_data;
   183.
   184.    -- slice_size_limit must be set so that the slice size field fits into 1 byte,
   185.    --    thus avoiding endian-ness and portability issues.
   186.    pragma Compile_Time_Error (slice_size_limit > 255, "IOC_tape_data.slice_size_limit > 255");
   187.
   188.    -- I think that both types of tape for the KDF9 had a maximum reel length of 2400 feet.
   189.    -- I assume that the recording density of the 7-track deck was no greater than that of the 1081.
   190.
   191.    max_bits_per_inch      : constant := 400;
   192.    max_reel_length        : constant := 12 * 2400;
   193.    type length_in_frames is range 0 .. max_reel_length * max_bits_per_inch;
   194.    type data_storage     is array (tape.length_in_frames range <>) of Character;
   195.
   196.    -- Attempts to write a block of more than max_block_size/8 words will be rejected.
   197.    -- The largest recommended size, as stated in the Manual, 22.1.3, is 3000 words.
   198.    -- The present value cannot logically be exceeded, and so allows all possible usages.
   199.
   200.    max_block_size         : constant := 32768 * 8;
   201.    subtype block_range   is tape.length_in_frames range 0 .. max_block_size;
   202.    subtype block_storage is data_storage (tape.block_range range 1 .. max_block_size);
   203.
   204.    -- A data block consists of one or more slices:
   205.    --
   206.    -- 1. a block of data length <= slice_size_limit has 1 slice, with (is_last and is_first) = True;
   207.    --
   208.    -- 2. a longer block has 1 or more prior slices, which all have data length = slice_size_limit,
   209.    --       all of them having is_last = False, and the first of them having is_first = True;
   210.    --    and 1 final slice of data length <= slice_size_limit, with is_last = True.
   211.    --
   212.    -- The total data length of all the slices in a block is <= max_block_size.
   213.    --
   214.    -- GAP and WIPE slices represent erased lengths of tape.
   215.    -- They are implemented, in effect, as data slices with non-significant data.
   216.    --
   217.    -- Parity mark slices represent tape marks on IBM-compatible Ampex TM4 decks.
   218.    -- See Manual, Appendix 7, p.317.
   219.
   220.    type basis_kind is (data_slice,
   221.                        GAP_slice,
   222.                        NULL_slice,
   223.                        WIPE_slice,
   224.                        even_parity_mark,
   225.                        odd_parity_mark);
   226.
   227.    -- These representations make for easy inspection of a MT file (e.g. using the UNIX od command).
   228.    for basis_kind use (data_slice       => Character'Pos('D'),
   229.                        GAP_slice        => Character'Pos('G'),
   230.                        NULL_slice       => Character'Pos('N'),
   231.                        WIPE_slice       => Character'Pos('W'),
   232.                        even_parity_mark => Character'Pos('e'),
   233.                        odd_parity_mark  => Character'Pos('o'));
   234.
   235.    subtype gap_kind is tape.basis_kind
   236.       with Static_Predicate => gap_kind in GAP_slice | WIPE_slice;
   237.
   238.    subtype tape_mark_kind is tape.basis_kind
   239.       with Static_Predicate => tape_mark_kind in odd_parity_mark | even_parity_mark;
   240.
   241.    subtype data_kind is tape.basis_kind
   242.       with Static_Predicate => data_kind = data_slice;
   243.
   244.    subtype slice_range   is tape.block_range range 0 .. IOC_tape_data.slice_size_limit;
   245.    subtype slice_storage is data_storage (1 .. slice_range'Last);
   246.
   247.    tape_mark_data  : constant tape.slice_storage := (1 => tape_mark_sign, others => block_padding);
   248.    erased_gap_data : constant tape.slice_storage := (others => block_padding);
   249.
   250.    type slice is
   251.       record
   252.          kind              : tape.basis_kind;
   253.          is_first, is_last : Boolean;
   254.          is_LBM_flagged    : Boolean;
   255.          size              : tape.slice_range;
   256.          data              : tape.slice_storage; -- Only data(1 .. size) are valid.
   257.       end record
   258.    with Size => 8 * MT_record_length;
   259.
   260.    -- These two representation specifications put the kind and is_* fields at convenient positions
   261.    --    for easy inspection in a legible print of a MT file (e.g. using the UNIX od command).
   262.
   263.    -- The first byte contains the initial letter of the slice type (see basis_kind).
   264.
   265.    -- The second byte takes the following octal/ASCII values for non-tape mark slices:
   266.    --    000 = NUL  => no flags
   267.    --    001 = SOH  => first slice of block
   268.    --    010 = BEL  => last slice of block
   269.    --    011 = HT   => only slice of block (first and last)
   270.    --    100 = @    => LBM flag
   271.    --    101 = A    => first slice of block with LBM flag
   272.    --    110 = H    => last slice of block with LBM flag
   273.    --    111 = I    => only slice of block with LBM flag
   274.
   275.    for slice use
   276.       record
   277.          kind           at 0 range  0..7;
   278.          is_first       at 1 range  0..2;
   279.          is_last        at 1 range  3..5;
   280.          is_LBM_flagged at 1 range  6..7;
   281.          size           at 2 range  0..7;
   282.          data           at 3 range  0..8*slice_size_limit - 1;
   283.       end record;
   284.
   285.    even_parity_tape_mark : constant tape.slice := (even_parity_mark,
   286.                                                    is_first       => True,
   287.                                                    is_last        => True,
   288.                                                    is_LBM_flagged => True,
   289.                                                    size           => 1,
   290.                                                    data           => tape_mark_data);
   291.
   292.    odd_parity_tape_mark  : constant tape.slice := (odd_parity_mark,
   293.                                                    is_first       => True,
   294.                                                    is_last        => True,
   295.                                                    is_LBM_flagged => True,
   296.                                                    size           => 1,
   297.                                                    data           => tape_mark_data);
   298.
   299.    a_NULL_slice          : constant tape.slice := (NULL_slice,
   300.                                                    is_first       => False,
   301.                                                    is_last        => False,
   302.                                                    is_LBM_flagged => False,
   303.                                                    size           => 0,
   304.                                                    data           => erased_gap_data);
   305.
   306.    a_WIPE_slice          : constant tape.slice := (WIPE_slice,
   307.                                                    is_first       => True,
   308.                                                    is_last        => True,
   309.                                                    is_LBM_flagged => False,
   310.                                                    size           => 0,
   311.                                                    data           => erased_gap_data);
   312.
   313.    a_GAP_slice           : constant tape.slice := (GAP_slice,
   314.                                                    is_first       => True,
   315.                                                    is_last        => True,
   316.                                                    is_LBM_flagged => False,
   317.                                                    size           => 0,
   318.                                                    data           => erased_gap_data);
   319.
   320.    package MT_slice_IO is new Ada.Direct_IO(tape.slice);
   321.    use MT_slice_IO;
   322.
   323.    type file is tagged limited
   324.       record
   325.          has_a_WP_ring   : Boolean := True;
   326.          last_data_index : MT_slice_IO.Count := 0;
   327.          position        : MT_slice_IO.Count := 0;
   328.          reel            : MT_slice_IO.File_Type;
   329.       end record;
   330.
   331.    -- The complete deck type with its primitive operations.
   332.
   333.    type deck is new fast.device with
   334.       record
   335.          -- unwound_frames tallies the amount of tape wound from its spool to the takeup spool;
   336.          --    i.e. how much has to be wound back before being able to unload the tape.
   337.          unwound_frames    : tape.length_in_frames := 0;
   338.          bytes_moved       : KDF9.word := 0;
   339.          is_LBM_flagged    : Boolean   := False;
   340.          terminator        : KDF9_char_sets.symbol;
   341.          recording_density : tape.length_in_frames;
   342.          max_reel_length   : tape.length_in_frames;
   343.          inter_block_gap   : tape.length_in_frames;
   344.          tape_capacity     : tape.length_in_frames;
   345.          PET_position      : tape.length_in_frames;
   346.          ETW_position      : tape.length_in_frames;
   347.          model             : IOC.device_kind;
   348.          tape_file         : tape.file;
   349.       end record;
   350.
   351.    overriding
   352.    procedure Finalize (the_deck : in out tape.deck);
   353.
   354.    overriding
   355.    function quantum (the_deck : tape.deck)
   356.    return KDF9.us
   357.    is (tape.deck'Class(the_deck).quantum);
                                        |
        >>> warning: possible infinite recursion, Storage_Error may be raised at run time

   358.    pragma Warnings(Off, quantum);
   359.
   360.    overriding
   361.    function kind (the_deck : tape.deck)
   362.    return IOC.device_kind
   363.    is (tape.deck'Class(the_deck).kind);
                                        |
        >>> warning: possible infinite recursion, Storage_Error may be raised at run time

   364.    pragma Warnings(Off, kind);
   365.
   366.    procedure handle_any_abnormality (the_deck : in out tape.deck;
   367.                                      the_size : in length_in_frames)
   368.    is null;
   369.
   370.    overriding
   371.    function IO_elapsed_time_total (the_deck : tape.deck)
   372.    return KDF9.us
   373.    is (tape.deck'Class(the_deck).elapsed_time);
   374.    pragma Warnings(Off, IO_elapsed_time_total);
   375.
   376.    procedure open (the_deck : in out tape.deck;
   377.                    the_mode : in POSIX.access_mode)
   378.    is null;
   379.
   380.    overriding
   381.    function is_open (the_deck : tape.deck)
   382.    return Boolean;
   383.
   384.    overriding
   385.    function usage (the_deck : tape.deck)
   386.    return KDF9.word;
   387.
   388.    overriding
   389.    procedure close (the_deck : in out tape.deck);
   390.
   391.    overriding
   392.    procedure flush(the_deck : in out tape.deck) is null;
   393.
   394.    type MT_deck is new tape.deck with null record;
   395.
   396.    overriding
   397.    procedure Initialize (the_deck : in out MT_deck);
   398.
   399.    overriding
   400.    function kind (the_deck : MT_deck)
   401.    return IOC.device_kind
   402.    is (MT_kind);
   403.
   404.    overriding
   405.    function quantum (the_deck : MT_deck)
   406.    return KDF9.us
   407.    is (1E6 / 40E3);  -- ch/s
   408.
   409.    overriding
   410.    procedure handle_any_abnormality (the_deck : in out MT_deck;
   411.                                      the_size : in length_in_frames);
   412.
   413.    type ST_deck is new tape.deck with null record;
   414.
   415.    overriding
   416.    procedure Initialize (the_deck : in out ST_deck);
   417.
   418.    overriding
   419.    function kind (the_deck : ST_deck)
   420.    return IOC.device_kind
   421.    is (ST_kind);
   422.
   423.    overriding
   424.    function quantum (the_deck : ST_deck)
   425.    return KDF9.us
   426.    is (1E6 / 16E3);  -- ch/s
   427.
   428.    overriding
   429.    procedure handle_any_abnormality (the_deck : in out ST_deck;
   430.                                      the_size : in length_in_frames);
   431.
   432.
   433.    procedure find_tape (the_label  : in  tape.data_storage;
   434.                         its_number : out KDF9.buffer_number;
   435.                         its_serial : out KDF9.word);
   436.
   437. end IOC.fast.tape;


GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-gp.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of a Calcomp 564 graph plotter, switched to a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with plotter;
    18. with postscript;
    19.
    20. use  plotter;
    21. use  postscript;
    22.
    23. package body IOC.slow.shift.GP is
    24.
    25.    overriding
    26.    procedure Initialize (the_GP : in out GP.device) is
    27.    begin
    28.       -- Ready the graph plotter driver and PostScript output file.
    29.       the_GP.device_name := device_name_of(the_GP);
    30.       open(the_GP.stream, the_GP.device_name, write_mode);
    31.       IOC.device(the_GP).Initialize;
    32.       if the_GP.is_open then
    33.          truncate(the_GP.stream);
    34.          initialize_PS_output(the_GP.stream);
    35.          open_the_plot_file(the_GP.stream);
    36.       end if;
    37.    end Initialize;
    38.
    39.    overriding
    40.    procedure Finalize (the_GP : in out GP.device) is
    41.    begin
    42.       if the_GP.is_open           and then
    43.             the_GP.byte_count /= 0    then
    44.          if the_final_state_is_wanted then
    45.             log_line(
    46.                      the_GP.device_name
    47.                    + "on buffer #"
    48.                    & oct_of(KDF9.Q_part(the_GP.number), 2)
    49.                    + "made"
    50.                    & the_GP.byte_count'Image
    51.                    & plurality(the_GP.byte_count, " plotting step.", " plotting steps.")
    52.                     );
    53.          end if;
    54.          the_GP.byte_count := 0;
    55.          close_the_plot_file(the_GP.stream);
    56.          finalize_PS_output(the_GP.stream);
    57.       end if;
    58.    end Finalize;
    59.
    60.    -- the_T_bit_is_set (the buffer has been switched from a tape punch to a graph plotter)
    61.    overriding
    62.    procedure PMB (the_GP      : in out GP.device;
    63.                   Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean) is
    65.    begin
    66.       validate_device(the_GP);
    67.       validate_parity(the_GP);
    68.       deal_with_a_busy_device(the_GP, 13, set_offline);
    69.       the_T_bit_is_set := True;
    70.       take_note_of_test(the_GP.device_name, Q_operand, the_T_bit_is_set);
    71.    end PMB;
    72.
    73.    GP_lift_time : constant := 1E6 /  10;           -- 10 pen up/down movements per second.
    74.    lift_ratio   : constant := GP_lift_time / 200;  -- the number of steps made in a lift time
    75.
    76.    overriding
    77.    procedure do_output_housekeeping (the_GP      : in out GP.device;
    78.                                      size, lifts : in     KDF9.word) is
    79.    begin
    80.       add_in_the_IO_CPU_time(the_GP, size);
    81.       correct_transfer_time(the_GP, size - lifts + lifts * lift_ratio);
    82.    end do_output_housekeeping;
    83.
    84.    procedure put_symbols (the_GP    : in out GP.device;
    85.                           Q_operand : in KDF9.Q_register) is
    86.       start_address : constant KDF9.address := Q_operand.I;
    87.       end_address   : constant KDF9.address := Q_operand.M;
    88.       size    : KDF9.word := 0;
    89.       lifts   : KDF9.word := 0;
    90.       command : plotter.command;
    91.    begin
    92.       check_addresses_and_lockouts(start_address, end_address);
    93.    word_loop:
    94.       for w in start_address .. end_address loop
    95.          for c in KDF9_char_sets.symbol_index'Range loop
    96.             command := plotter.command(fetch_symbol(w, c));
    97.             perform(command, the_GP.stream);
    98.             size := size + 1;
    99.             the_GP.byte_count := the_GP.byte_count + 1;
   100.             if command in pen_up | pen_down then
   101.                -- These actions are much slower than plotting movements.
   102.                lifts := lifts + 1;
   103.             end if;
   104.          end loop;
   105.       end loop word_loop;
   106.       do_output_housekeeping (the_GP, size, lifts);
   107.    end put_symbols;
   108.
   109.    overriding
   110.    procedure POA (the_GP      : in out GP.device;
   111.                   Q_operand   : in KDF9.Q_register;
   112.                   set_offline : in Boolean) is
   113.    begin
   114.       start_slow_transfer(the_GP, Q_operand, set_offline, output_operation);
   115.       put_symbols(the_GP, Q_operand);
   116.       lock_out_relative_addresses(Q_operand);
   117.    end POA;
   118.
   119.    overriding
   120.    procedure POB (the_GP      : in out GP.device;
   121.                   Q_operand   : in KDF9.Q_register;
   122.                   set_offline : in Boolean) is
   123.    begin
   124.       -- See the Manual Appendix 6, 5.2, p.303.
   125.       POA(the_GP, Q_operand, set_offline);
   126.    end POB;
   127.
   128.    procedure put_words (the_GP    : in out GP.device;
   129.                         Q_operand : in KDF9.Q_register) is
   130.       start_address : constant KDF9.address := Q_operand.I;
   131.       end_address   : constant KDF9.address := Q_operand.M;
   132.       size    : KDF9.word := 0;
   133.       lifts   : KDF9.word := 0;
   134.       command : plotter.command;
   135.    begin
   136.       check_addresses_and_lockouts(start_address, end_address);
   137.       for w in start_address .. end_address loop
   138.          -- Ony the last 6 bits (character 7) of each word are used.
   139.          command := plotter.command(fetch_symbol(w, 7));
   140.          perform(command, the_GP.stream);
   141.          size := size + 1;
   142.          the_GP.byte_count := the_GP.byte_count + 1;
   143.          if command in pen_up | pen_down then
   144.             -- These actions are much slower than plotting movements.
   145.             lifts := lifts + 1;
   146.          end if;
   147.       end loop;
   148.       do_output_housekeeping (the_GP, size, lifts);
   149.    end put_words;
   150.
   151.    overriding
   152.    procedure POC (the_GP      : in out GP.device;
   153.                   Q_operand   : in KDF9.Q_register;
   154.                   set_offline : in Boolean) is
   155.    begin
   156.       start_slow_transfer(the_GP, Q_operand, set_offline, output_operation);
   157.       put_words(the_GP, Q_operand);
   158.       lock_out_relative_addresses(Q_operand);
   159.    end POC;
   160.
   161.    overriding
   162.    procedure POD (the_GP      : in out GP.device;
   163.                   Q_operand   : in KDF9.Q_register;
   164.                   set_offline : in Boolean) is
   165.    begin
   166.       -- See the Manual Appendix 6, 5.2, p.303.
   167.       POC(the_GP, Q_operand, set_offline);
   168.    end POD;
   169.
   170.    type GP_access is access GP.device;
   171.
   172.    GP0 : GP_access with Warnings => Off;
   173.
   174.    procedure enable (b : in KDF9.buffer_number) is
   175.    begin
   176.       GP0 := new GP.device (number => b, unit => 0);
   177.       GP0_number := b;
   178.    end enable;
   179.
   180.    procedure replace_on_buffer (b : in KDF9.buffer_number) is
   181.    begin
   182.       if GP0 /= null and then
   183.             b = GP0_number then
   184.          return;
   185.       end if;
   186.       buffer(b) := null;
   187.       enable(b);
   188.    end replace_on_buffer;
   189.
   190.    procedure notify_invalid_movement (from_x, from_y, step_x, step_y : in Integer) is
   191.    begin
   192.       trap_failing_IO_operation(
   193.                                 GP0.all,
   194.                                 "cannot move from <"
   195.                               & trimmed(from_x'Image)
   196.                               & ","
   197.                               & from_y'Image
   198.                               & "> by <"
   199.                               & trimmed(step_x'Image)
   200.                               & ","
   201.                               & step_y'Image
   202.                               & ">"
   203.                                );
   204.    end notify_invalid_movement;
   205.
   206. end IOC.slow.shift.GP;

Compiling: ../Source/ioc-slow-shift-gp.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of a Calcomp 564 graph plotter, switched to a tape punch buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.GP is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    overriding
    22.    procedure POA (the_GP      : in out GP.device;
    23.                   Q_operand   : in KDF9.Q_register;
    24.                   set_offline : in Boolean);
    25.
    26.    overriding
    27.    procedure POB (the_GP      : in out GP.device;
    28.                   Q_operand   : in KDF9.Q_register;
    29.                   set_offline : in Boolean);
    30.
    31.    overriding
    32.    procedure POC (the_GP      : in out GP.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    overriding
    37.    procedure POD (the_GP      : in out GP.device;
    38.                   Q_operand   : in KDF9.Q_register;
    39.                   set_offline : in Boolean);
    40.
    41.    -- the_T_bit_is_set (buffer is switched to graph plotter)
    42.    overriding
    43.    procedure PMB (the_GP      : in out GP.device;
    44.                   Q_operand   : in KDF9.Q_register;
    45.                   set_offline : in Boolean);
    46.
    47.    procedure enable (b : in KDF9.buffer_number);
    48.
    49.    procedure replace_on_buffer (b : in KDF9.buffer_number);
    50.
    51.    procedure notify_invalid_movement (from_x, from_y, step_x, step_y : in Integer)
    52.       with Inline => False;
    53.
    54. private
    55.
    56.    type device is new IOC.slow.shift.device with null record;
    57.
    58.    overriding
    59.    procedure Initialize (the_GP : in out GP.device);
    60.
    61.    overriding
    62.    procedure Finalize (the_GP : in out GP.device);
    63.
    64.    overriding
    65.    function kind (the_GP : GP.device)
    66.    return IOC.device_kind
    67.    is (GP_kind);
    68.
    69.    overriding
    70.    function quantum (the_GP : GP.device)
    71.    return KDF9.us
    72.    is (1E6 / 200);
    73.
    74.    overriding
    75.    procedure do_output_housekeeping (the_GP      : in out GP.device;
    76.                                      size, lifts : in     KDF9.word);
    77.
    78. end IOC.slow.shift.GP;

 206 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-fw.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of the FlexoWriter buffer: monitor typewriter functionality.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received the copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18. --
    19. with HCI;
    20.
    21. with imported_value_of;
    22.
    23. use  Ada.Text_IO;
    24. --
    25. use  HCI;
    26.
    27. package body IOC.slow.shift.FW is
    28.
    29.    function a_LF_was_just_read (the_FW : FW.device)
    30.    return Boolean
    31.    is (the_FW.mode = the_flexowriter_is_reading and then a_LF_was_just_read(the_FW.stream));
    32.
    33.    max_text_length : constant Positive := 64;  -- This is the limit imposed by NTSD and TSD.
    34.    min_text_length : constant Positive :=  2;  -- This is arbitrary, but seems reasonable.
    35.
    36.    type interaction is
    37.       record
    38.          text           : String(1 .. max_text_length);
    39.          prompt_length,
    40.          total_length   : Positive range 1 .. max_text_length;
    41.       end record;
    42.
    43.    max_interactions : constant Positive := 16; -- This is arbitrary, but seems reasonable.
    44.
    45.    interactions     : array (1 .. max_interactions) of FW.interaction;
    46.    next_interaction : Positive := 1;
    47.    last_interaction : Natural  := 0;
    48.
    49.     -- A '' denotes LF, and the '' denotes FF in an interaction text input.
    50.    LF_surrogate     : constant Character := '';
    51.    FF_surrogate     : constant Character := '';
    52.
    53.    -- These are the ANSI SGR terminal escape codes for styling FW output.
    54.
    55.    function escaped (name, default : String)
    56.    return String is
    57.       text   : constant String := imported_value_of(name, default);
    58.       result : String (1..text'Length);
    59.       i, j   : Positive;
    60.    begin
    61.       if text'Length < 6 then return ""; end if;
    62.       i := text'First;
    63.       j := 1;
    64.       while i <= text'Last-2 loop
    65.          if text(i..i+2) = "ESC" then
    66.             result(j) := ESC;
    67.             i := i + 3;
    68.          else
    69.             result(j) := text(i);
    70.             i := i + 1;
    71.          end if;
    72.          j := j + 1;
    73.       end loop;
    74.       result(j..j+1) := text(i..i+1);
    75.       return result(1..j+1);
    76.    end escaped;
    77.
    78.    red_font   : constant String := escaped("RED_FONT",   "ESC[0mESC[31m");
    79.    black_font : constant String := escaped("BLACK_FONT", "ESC[0mESC[30m");
    80.    underline  : constant String := escaped("UNDERLINE",  "ESC[4m");
    81.    plain_font : constant String := escaped("PLAIN_FONT", "ESC[0m");
    82.
    83.    procedure set_text_colour_to_red (the_flexowriter_output : in out host_IO.stream) is
    84.    begin
    85.       if realistic_FW_output_is_wanted and red_font /= "" then
    86.          put_escape_code(red_font, the_flexowriter_output);
    87.       end if;
    88.    end set_text_colour_to_red;
    89.
    90.    procedure set_text_colour_to_black (the_flexowriter_output : in out host_IO.stream) is
    91.    begin
    92.       if black_font /= "" then
    93.          put_escape_code(black_font, the_flexowriter_output);
    94.       end if;
    95.    end set_text_colour_to_black;
    96.
    97.    procedure set_text_style_to_underline (the_flexowriter_output : in out host_IO.stream) is
    98.    begin
    99.       if underline /= "" then
   100.          put_escape_code(underline, the_flexowriter_output);
   101.       end if;
   102.    end set_text_style_to_underline;
   103.
   104.    procedure set_text_style_to_plain (the_flexowriter_output : in out host_IO.stream) is
   105.    begin
   106.       if plain_font /= "" then
   107.          put_escape_code(plain_font, the_flexowriter_output);
   108.       end if;
   109.    end set_text_style_to_plain;
   110.
   111.    overriding
   112.    procedure Initialize (the_FW : in out FW.device) is
   113.
   114.       procedure complain (part_1         : in String;
   115.                           part_2, part_3 : in String := "")
   116.       with
   117.          No_Return
   118.       is
   119.          left_quote  : constant String := (if part_2 /= "" then  " """ else "");
   120.          right_quote : constant String := (if part_2 /= "" then  """ " else "");
   121.       begin
   122.          raise operator_error
   123.             with part_1 & left_quote & glyphs_for(part_2) & right_quote & part_3;
   124.       end complain;
   125.
   126.       the_data         : String(1 .. max_text_length+1);
   127.       the_data_length  : Natural;
   128.
   129.       interaction_file : Ada.Text_IO.File_Type;
   130.
   131.    begin -- Initialize
   132.       ensure_UI_is_open;
   133.       the_FW.mode := the_flexowriter_is_writing;
   134.       the_FW.device_name := device_name_of(the_FW);
   135.
   136.       if the_FW.device_name = "FW0" then
   137.          -- Attempt to open the command file for the console the_FW.
   138.          begin
   139.             Open(interaction_file, In_File, "FW0");
   140.          response_list_loop:
   141.             while not End_of_File(interaction_file) loop
   142.                if last_interaction = max_interactions then
   143.                   complain("The file FW0 contains too many prompts");
   144.                end if;
   145.                last_interaction := last_interaction + 1;
   146.                Get_Line(interaction_file, the_data, the_data_length);
   147.
   148.             exit response_list_loop when the_data_length = 0;
   149.
   150.                declare
   151.                   next   : FW.interaction renames interactions(last_interaction);
   152.                   this   : String  := the_data(1..the_data_length);
   153.                   length : Natural := 0;
   154.                begin
   155.                   if the_data_length > max_text_length then
   156.                      complain("The FW0 prompt", this, "is too long");
   157.                   end if;
   158.                   if the_data_length < min_text_length then
   159.                      complain("The FW0 prompt", this, "is too short");
   160.                   end if;
   161.
   162.                   for p in this'Range loop
   163.                      if this(p) = ';' then
   164.                         if length /= 0 then
   165.                            complain("The FW0 prompt", this, "contains 2 semicolons");
   166.                         end if;
   167.                         length := p;
   168.                      elsif this(p) = LF_surrogate then
   169.                         -- Convert '' to LF to allow for multi-line prompts.
   170.                         this(p) := LF;
   171.                      elsif this(p) = FF_surrogate then
   172.                         -- Convert '' to FF to allow for multi-line prompts.
   173.                         this(p) := FF;
   174.                      end if;
   175.                   end loop;
   176.
   177.                   if length = 0 then
   178.                      complain("The FW0 prompt", this, "contains no semicolon");
   179.                   end if;
   180.
   181.                   next.text(1..this'Length) := this;
   182.                   next.prompt_length        := length;
   183.                   next.total_length         := this'Length;
   184.                end;
   185.
   186.             end loop response_list_loop;
   187.
   188.          exception
   189.
   190.             when Name_Error =>
   191.                complain("The file FW0 is absent");
   192.             when Use_Error =>
   193.                complain("The file FW0 exists, but cannot be read");
   194.          end;
   195.       end if;
   196.
   197.       open(the_FW.stream, the_FW.device_name, read_mode, UI_in_FD);
   198.       open(the_FW.output, the_FW.device_name, write_mode, UI_out_FD);
   199.       IOC.device(the_FW).Initialize;
   200.       the_FW.current_case := KDF9_char_sets.Case_Normal;
   201.    end Initialize;
   202.
   203.    -- If authentic timing, the delay of length 0.1s is inserted between characters output
   204.    --    to the Flexowriter, with the aim of approximating the actual speed of its typing.
   205.    the_pause  : Duration := 0.0;
   206.
   207.    procedure set_the_duration_of_the_pause is
   208.    begin
   209.       if authentic_timing_is_enabled then
   210.          the_pause := 0.1;
   211.       else
   212.          the_pause := 0.0;
   213.       end if;
   214.    end set_the_duration_of_the_pause;
   215.
   216.    call_for_manual_input : constant String (1..2) := (others => BEL);
   217.
   218.    saved_output : String(1 .. max_text_length);
   219.    last_saved   : Natural range 0 .. max_text_length := 0;
   220.
   221.    procedure write_and_save (ch : Character; the_FW : in out FW.device) is
   222.    begin
   223.       delay the_pause;
   224.       if last_saved < max_text_length then
   225.          last_saved := last_saved + 1;
   226.          saved_output(last_saved) := ch;
   227.          put_byte(ch, the_FW.output);
   228.          flush(the_FW.output);
   229.       else
   230.          raise IO_error with "excessive output to FW";
   231.       end if;
   232.    end write_and_save;
   233.
   234.    procedure inject_a_response (the_FW     : in out FW.device;
   235.                                 the_prompt : in String;
   236.                                 the_size   : in out KDF9.word) is
   237.    begin
   238.       set_the_duration_of_the_pause;
   239.       for t in next_interaction .. last_interaction loop
   240.          declare
   241.             the : interaction renames interactions(t);
   242.          begin
   243.             if the.prompt_length = the.total_length then
   244.                -- A null response, so terminate the program.
   245.                raise exceptions.quit_request with "at the prompt: "& abs the_prompt;
   246.             end if;
   247.             next_interaction := next_interaction + 1;
   248.             if the.text(1..the.prompt_length-1) = the_prompt and then
   249.                   the.text(the.prompt_length-0) = ';'            then
   250.                inject(the.text(the.prompt_length+1..the.total_length) & LF, the_FW.stream);
   251.                the_size := the_size + KDF9.word(the.total_length-the.prompt_length);
   252.                for c of the.text(the.prompt_length+1..the.total_length) loop
   253.                   -- Human operators type more slowly than KDF9 buffers!
   254.                   delay the_pause * 4;
   255.                   write_and_save(c, the_FW);
   256.                end loop;
   257.                put_EOL(the_FW.output);
   258.                flush(the_FW.output);
   259.                the_FW.mode := the_flexowriter_is_reading;
   260.                return;
   261.             end if;
   262.          end;
   263.       end loop;
   264.       -- No canned response is available, so control reverts to the terminal.
   265.       -- Output an audible signal to notify the operator.
   266.       if noninteractive_usage_is_enabled then
   267.          raise input_is_impossible;
   268.       end if;
   269.       put_bytes(call_for_manual_input, the_FW.output);
   270.       flush(the_FW.output);
   271.       the_FW.mode := the_flexowriter_is_reading;
   272.    end inject_a_response;
   273.
   274.    -- TRQq
   275.    overriding
   276.    procedure PIA (the_FW      : in out FW.device;
   277.                   Q_operand   : in KDF9.Q_register;
   278.                   set_offline : in Boolean) is
   279.    begin
   280.       if noninteractive_usage_is_enabled then
   281.          raise input_is_impossible;
   282.       end if;
   283.       put_bytes(call_for_manual_input, the_FW.output);
   284.       flush(the_FW.output);
   285.       the_FW.mode := the_flexowriter_is_reading;
   286.       start_slow_transfer(the_FW, Q_operand, set_offline);
   287.       read(the_FW, Q_operand);
   288.       lock_out_relative_addresses(Q_operand);
   289.       reset(the_FW.stream);
   290.    end PIA;
   291.
   292.    -- TREQq
   293.    overriding
   294.    procedure PIB (the_FW      : in out FW.device;
   295.                   Q_operand   : in KDF9.Q_register;
   296.                   set_offline : in Boolean) is
   297.    begin
   298.       if noninteractive_usage_is_enabled then
   299.          raise input_is_impossible;
   300.       end if;
   301.       put_bytes(call_for_manual_input, the_FW.output);
   302.       flush(the_FW.output);
   303.       the_FW.mode := the_flexowriter_is_reading;
   304.       start_slow_transfer(the_FW, Q_operand, set_offline);
   305.       read_to_EM(the_FW, Q_operand);
   306.       lock_out_relative_addresses(Q_operand);
   307.       reset(the_FW.stream);
   308.    end PIB;
   309.
   310.    overriding
   311.    procedure PIC (the_FW      : in out FW.device;
   312.                   Q_operand   : in KDF9.Q_register;
   313.                   set_offline : in Boolean) is
   314.    begin
   315.       if noninteractive_usage_is_enabled then
   316.          raise input_is_impossible;
   317.       end if;
   318.       put_bytes(call_for_manual_input, the_FW.output);
   319.       flush(the_FW.output);
   320.       the_FW.mode := the_flexowriter_is_reading;
   321.       start_slow_transfer(the_FW, Q_operand, set_offline);
   322.       words_read(the_FW, Q_operand);
   323.       lock_out_relative_addresses(Q_operand);
   324.       reset(the_FW.stream);
   325.    end PIC;
   326.
   327.    overriding
   328.    procedure PID (the_FW      : in out FW.device;
   329.                   Q_operand   : in KDF9.Q_register;
   330.                   set_offline : in Boolean) is
   331.    begin
   332.       if noninteractive_usage_is_enabled then
   333.          raise input_is_impossible;
   334.       end if;
   335.       put_bytes(call_for_manual_input, the_FW.output);
   336.       flush(the_FW.output);
   337.       the_FW.mode := the_flexowriter_is_reading;
   338.       start_slow_transfer(the_FW, Q_operand, set_offline);
   339.       words_read_to_EM(the_FW, Q_operand);
   340.       lock_out_relative_addresses(Q_operand);
   341.       reset(the_FW.stream);
   342.    end PID;
   343.
   344.    overriding
   345.    procedure PIE (the_FW      : in out FW.device;
   346.                   Q_operand   : in KDF9.Q_register;
   347.                   set_offline : in Boolean) is
   348.    begin
   349.       PIA(the_FW, Q_operand, set_offline);
   350.    end PIE;
   351.
   352.    overriding
   353.    procedure PIF (the_FW      : in out FW.device;
   354.                   Q_operand   : in KDF9.Q_register;
   355.                   set_offline : in Boolean) is
   356.    begin
   357.       PIB(the_FW, Q_operand, set_offline);
   358.    end PIF;
   359.
   360.    overriding
   361.    procedure PIG (the_FW      : in out FW.device;
   362.                   Q_operand   : in KDF9.Q_register;
   363.                   set_offline : in Boolean) is
   364.    begin
   365.       PIC(the_FW, Q_operand, set_offline);
   366.    end PIG;
   367.
   368.    overriding
   369.    procedure PIH (the_FW      : in out FW.device;
   370.                   Q_operand   : in KDF9.Q_register;
   371.                   set_offline : in Boolean) is
   372.    begin
   373.       PID(the_FW, Q_operand, set_offline);
   374.    end PIH;
   375.
   376.    -- neat strips off any enclosing non-graphic characters from s.
   377.    function neat (s : String)
   378.    return String is
   379.       l : Positive := 1;
   380.       r : Natural  := 0;
   381.    begin
   382.       for i in s'Range loop
   383.          l := i;
   384.       exit when s(i) > SP and s(i) /= DEL;
   385.       end loop;
   386.       for i in reverse s'Range loop
   387.          r := i;
   388.       exit when s(i) > SP and s(i) /= DEL;
   389.       end loop;
   390.       return s(l..r);  -- s(1..0) yields the null string when s is the null string.
   391.    end neat;
   392.
   393.    overriding
   394.    procedure do_output_housekeeping (the_FW   : in out FW.device;
   395.                                      written,
   396.                                      fetched  : in KDF9.word) is
   397.    begin
   398.       flush(the_FW.stream);
   399.       add_in_the_IO_CPU_time(the_FW, fetched);
   400.       correct_transfer_time(the_FW, written);
   401.       the_FW.byte_count := the_FW.byte_count + fetched;
   402.    end do_output_housekeeping;
   403.
   404.    underlined : Boolean := False;
   405.
   406.   procedure put_symbols (the_FW         : in out FW.device;
   407.                           Q_operand      : in KDF9.Q_register;
   408.                           transfer_to_EM : in Boolean) is
   409.       start_address : constant KDF9.address := Q_operand.I;
   410.       end_address   : constant KDF9.address := Q_operand.M;
   411.       fill   : KDF9.word := 0;
   412.       size   : KDF9.word := 0;
   413.       symbol : KDF9_char_sets.symbol;
   414.       char   : Character;
   415.     begin
   416.       last_saved := 0;
   417.
   418.       check_addresses_and_lockouts(start_address, end_address);
   419.       set_the_duration_of_the_pause;
   420.       the_FW.mode := the_flexowriter_is_writing;
   421.       set_text_style_to_plain(the_FW.output);
   422.       set_text_colour_to_red(the_FW.output);
   423.
   424.       -- Ensure that any prompt occupies the buffer alone.
   425.       flush(the_FW.output);
   426.    word_loop:
   427.       for w in start_address .. end_address loop
   428.          for c in KDF9_char_sets.symbol_index'Range loop
   429.             case the_FW.mode is
   430.
   431.                when the_flexowriter_is_writing =>
   432.                   symbol := fetch_symbol(w, c);
   433.                   size := size + 1;
   434.
   435.                   if symbol = KDF9_char_sets.Word_Filler then
   436.                      fill := fill + 1;
   437.
   438.                   elsif symbol = KDF9_char_sets.Case_Shift then
   439.                      the_FW.current_case := KDF9_char_sets.Case_Shift;
   440.                      the_FW.shifts := the_FW.shifts + 1;
   441.
   442.                   elsif  symbol = KDF9_char_sets.Case_Normal then
   443.                      the_FW.current_case := KDF9_char_sets.Case_Normal;
   444.                      the_FW.shifts := the_FW.shifts + 1;
   445.
   446.                   else
   447.
   448.                      if the_FW.current_case = KDF9_char_sets.Case_Normal then
   449.                         char := TP_CN(symbol);
   450.                      else
   451.                         char := TP_CS(symbol);
   452.                      end if;
   453.
   454.                      if char = ';' then
   455.
   456.                         declare
   457.                            the_prompt : constant String := saved_output(1..last_saved);
   458.                         begin
   459.                            -- Must flush AFTER saving the prompt and BEFORE going black.
   460.                            flush(the_FW.output);
   461.                            set_text_colour_to_black(the_FW.output);
   462.                            set_text_style_to_plain(the_FW.output);
   463.                            write_and_save(';', the_FW);
   464.
   465.                            inject_a_response(the_FW, neat(the_prompt), size);
   466.
   467.                            the_FW.mode := the_flexowriter_is_reading;
   468.                            set_text_style_to_plain(the_FW.output);
   469.                         end;
   470.
   471.                      elsif flexowriter_output_is_wanted then
   472.
   473.                         if char = '_' then
   474.                            underlined := True;
   475.                            delay the_pause;
   476.                            do_not_put_byte(char, the_FW.output);
   477.                         else
   478.                            if underlined then
   479.                               set_text_style_to_underline(the_FW.output);
   480.                            end if;
   481.                            write_and_save(char, the_FW);
   482.                            if underlined then
   483.                               set_text_style_to_plain(the_FW.output);
   484.                               set_text_colour_to_red(the_FW.output);
   485.                               underlined := False;
   486.                            end if;
   487.                         end if;
   488.
   489.                      else
   490.                         do_not_put_byte(char, the_FW.output);
   491.                      end if;
   492.
   493.                      exit word_loop when transfer_to_EM and symbol = KDF9_char_sets.End_Message;
   494.                   end if;
   495.
   496.                when the_flexowriter_is_reading =>
   497.                   get_char(char, the_FW.stream);
   498.                   if case_of(char) not in both | the_FW.current_case then
   499.                      store_symbol(CN_TR(next_case(the_FW.current_case)), w, c);
   500.                      size := size + 1;
   501.                      the_FW.current_case := the_FW.current_case xor 1;
   502.                      back_off(the_FW.stream);
   503.                   else
   504.                      if the_FW.current_case = KDF9_char_sets.Case_Normal then
   505.                         symbol := CN_TR(char);
   506.                      else
   507.                         symbol := CS_TR(char);
   508.                      end if;
   509.                      store_symbol(symbol, w, c);
   510.                      size := size + 1;
   511.                      if transfer_to_EM and symbol = KDF9_char_sets.End_Message then
   512.                         for d in 1 .. 7-c loop
   513.                            store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
   514.                         end loop;
   515.                         exit word_loop;
   516.                      end if;
   517.                   end if;
   518.
   519.             end case;
   520.          end loop;
   521.       end loop word_loop;
   522.
   523.       flush(the_FW.output);
   524.       set_text_style_to_plain(the_FW.output);
   525.       set_text_colour_to_black(the_FW.output);
   526.       do_output_housekeeping(the_FW, written => size-fill, fetched => size);
   527.       flush(the_FW.output);
   528.    exception
   529.       when end_of_stream =>
   530.          flush(the_FW.output);
   531.          set_text_colour_to_black(the_FW.output);
   532.          set_text_style_to_plain(the_FW.output);
   533.          do_output_housekeeping(the_FW, written => size-fill, fetched => size);
   534.    end put_symbols;
   535.
   536.    overriding
   537.    procedure write (the_FW    : in out FW.device;
   538.                     Q_operand : in KDF9.Q_register) is
   539.    begin
   540.       put_symbols(the_FW, Q_operand, transfer_to_EM => False);
   541.    end write;
   542.
   543.    overriding
   544.    procedure write_to_EM (the_FW    : in out FW.device;
   545.                           Q_operand : in KDF9.Q_register) is
   546.    begin
   547.       put_symbols(the_FW, Q_operand, transfer_to_EM => True);
   548.    end write_to_EM;
   549.
   550.    -- TWQq
   551.    overriding
   552.    procedure POA (the_FW      : in out FW.device;
   553.                   Q_operand   : in KDF9.Q_register;
   554.                   set_offline : in Boolean) is
   555.    begin
   556.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   557.       write(the_FW, Q_operand);
   558.       lock_out_relative_addresses(Q_operand);
   559.       reset(the_FW.stream);
   560.    end POA;
   561.
   562.    -- TWEQq
   563.    overriding
   564.    procedure POB (the_FW      : in out FW.device;
   565.                   Q_operand   : in KDF9.Q_register;
   566.                   set_offline : in Boolean) is
   567.    begin
   568.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   569.       write_to_EM(the_FW, Q_operand);
   570.       lock_out_relative_addresses(Q_operand);
   571.       -- reset(the_FW.stream);
   572.    end POB;
   573.
   574.    procedure put_words (the_FW         : in out FW.device;
   575.                         Q_operand      : in KDF9.Q_register;
   576.                         transfer_to_EM : in Boolean := False) is
   577.       start_address : constant KDF9.address := Q_operand.I;
   578.       end_address   : constant KDF9.address := Q_operand.M;
   579.       size : KDF9.word := 0;
   580.       word : KDF9.word;
   581.       char : Character;
   582.    begin
   583.       last_saved := 0;
   584.
   585.       check_addresses_and_lockouts(start_address, end_address);
   586.       set_the_duration_of_the_pause;
   587.       the_FW.mode := the_flexowriter_is_writing;
   588.       set_text_style_to_plain(the_FW.output);
   589.       set_text_colour_to_red(the_FW.output);
   590.    word_loop:
   591.       for w in start_address .. end_address loop
   592.          case the_FW.mode is
   593.
   594.             when the_flexowriter_is_writing =>
   595.                word := fetch_word(w) and 8#377#;
   596.                size := size + 1;
   597.                char := Character'Val(word);
   598.                if word = KDF9_char_sets.Semi_Colon_tape_bits and then
   599.                      not the_FW.is_transcribing                  then
   600.                   -- Hypothesis: POC and POD act like POA and POB with respect to prompting;
   601.                   --    and change from writing to reading after the output of any word that has
   602.                   --       the KDF9 FW tape code for a semicolon in its least significant 8 bits.
   603.                   -- This takes effect iff the device is not "transcribing",
   604.                   --     i.e. not doing Latin-1 output transparently.
   605.                   declare
   606.                      the_prompt : constant String := saved_output(1..last_saved);
   607.                   begin
   608.                      -- Must flush AFTER saving the prompt and BEFORE going black.
   609.                      flush(the_FW.output);
   610.                      set_text_colour_to_black(the_FW.output);
   611.                      set_text_style_to_plain(the_FW.output);
   612.                      write_and_save(';', the_FW);
   613.                      inject_a_response(the_FW, neat(the_prompt), size);
   614.                      the_FW.mode := the_flexowriter_is_reading;
   615.                      set_text_style_to_plain(the_FW.output);
   616.                   end;
   617.                elsif flexowriter_output_is_wanted then
   618.                   if char = '_' then
   619.                      underlined := True;
   620.                      delay the_pause;
   621.                      do_not_put_byte(char, the_FW.output);
   622.                   else
   623.                      if underlined then
   624.                         set_text_style_to_underline(the_FW.output);
   625.                      end if;
   626.                      write_and_save(char, the_FW);
   627.                      if underlined then
   628.                         set_text_style_to_plain(the_FW.output);
   629.                         set_text_colour_to_red(the_FW.output);
   630.                         underlined := False;
   631.                      end if;
   632.                   end if;
   633.       exit word_loop when transfer_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   634.                end if;
   635.
   636.             when the_flexowriter_is_reading =>
   637.                get_char(char, the_FW.stream);
   638.                size := size + 1;
   639.                word := KDF9.word(Character'Pos(char));
   640.                store_word(word, w);
   641.       exit word_loop when transfer_to_EM and then word = KDF9_char_sets.End_Message_tape_bits;
   642.
   643.          end case;
   644.       end loop word_loop;
   645.
   646.       flush(the_FW.output);
   647.       set_text_colour_to_black(the_FW.output);
   648.       set_text_style_to_plain(the_FW.output);
   649.       do_output_housekeeping(the_FW, written => size, fetched => size);
   650.    exception
   651.       when end_of_stream =>
   652.          flush(the_FW.output);
   653.          set_text_colour_to_black(the_FW.output);
   654.          set_text_style_to_plain(the_FW.output);
   655.          do_output_housekeeping(the_FW, written => size, fetched => size);
   656.    end put_words;
   657.
   658.    overriding
   659.    procedure words_write (the_FW    : in out FW.device;
   660.                           Q_operand : in KDF9.Q_register) is
   661.    begin
   662.       put_words(the_FW, Q_operand, transfer_to_EM => False);
   663.    end words_write;
   664.
   665.    overriding
   666.    procedure words_write_to_EM (the_FW    : in out FW.device;
   667.                                 Q_operand : in KDF9.Q_register) is
   668.    begin
   669.       put_words(the_FW, Q_operand, transfer_to_EM => True);
   670.    end words_write_to_EM;
   671.
   672.    -- TWCQq
   673.    overriding
   674.    procedure POC (the_FW      : in out FW.device;
   675.                   Q_operand   : in KDF9.Q_register;
   676.                   set_offline : in Boolean) is
   677.    begin
   678.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   679.       words_write(the_FW, Q_operand);
   680.       lock_out_relative_addresses(Q_operand);
   681.    end POC;
   682.
   683.    -- TWECQq
   684.    overriding
   685.    procedure POD (the_FW      : in out FW.device;
   686.                   Q_operand   : in KDF9.Q_register;
   687.                   set_offline : in Boolean) is
   688.    begin
   689.       start_slow_transfer(the_FW, Q_operand, set_offline, output_operation);
   690.       words_write_to_EM(the_FW, Q_operand);
   691.       lock_out_relative_addresses(Q_operand);
   692.    end POD;
   693.
   694.    overriding
   695.    procedure Finalize (the_FW : in out FW.device) is
   696.       total : constant KDF9.word
   697.             := KDF9.word(the_FW.output.bytes_moved+the_FW.stream.bytes_moved) + the_FW.shifts;
   698.    begin
   699.       close(
   700.            the_FW,
   701.            "transferred",
   702.            total,
   703.            "character" & plurality(total)
   704.           );
   705.    end Finalize;
   706.
   707.    -- This is the monitor console Flexowriter.
   708.
   709.    type FW_access is access FW.device;
   710.
   711.    FW0 : FW_access with Warnings => Off;
   712.
   713.    already_enabled : Boolean := False;
   714.
   715.    procedure enable (b : in KDF9.buffer_number) is
   716.    begin
   717.       if already_enabled then
   718.          trap_operator_error("more than one FW unit has been configured");
   719.       end if;
   720.       if b /= 0 then
   721.          trap_operator_error("FW0 must be on buffer 0");
   722.       end if;
   723.       FW0 := new FW.device (number => b, unit => 0);
   724.       already_enabled := True;
   725.    end enable;
   726.
   727. end IOC.slow.shift.FW;

Compiling: ../Source/ioc-slow-shift-fw.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of a FlexoWriter buffer: monitor typewriter functionality.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.FW is
    18.
    19.    type device is new IOC.slow.shift.device with private;
    20.
    21.    function a_LF_was_just_read (the_FW : FW.device)
    22.    return Boolean;
    23.
    24.    -- TRQq
    25.    overriding
    26.    procedure PIA (the_FW      : in out FW.device;
    27.                   Q_operand   : in KDF9.Q_register;
    28.                   set_offline : in Boolean);
    29.
    30.    -- TREQq
    31.    overriding
    32.    procedure PIB (the_FW      : in out FW.device;
    33.                   Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    -- TRCQq character read
    37.    overriding
    38.    procedure PIC (the_FW      : in out FW.device;
    39.                   Q_operand   : in KDF9.Q_register;
    40.                   set_offline : in Boolean);
    41.
    42.    -- TRECQq character read to End_Message
    43.    overriding
    44.    procedure PID (the_FW      : in out FW.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    -- as PIA
    49.    overriding
    50.    procedure PIE (the_FW      : in out FW.device;
    51.                   Q_operand   : in KDF9.Q_register;
    52.                   set_offline : in Boolean);
    53.
    54.    -- as PIB
    55.    overriding
    56.    procedure PIF (the_FW      : in out FW.device;
    57.                   Q_operand   : in KDF9.Q_register;
    58.                   set_offline : in Boolean);
    59.
    60.    -- as PIC
    61.    overriding
    62.    procedure PIG (the_FW      : in out FW.device;
    63.                   Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean);
    65.
    66.    -- as PID
    67.    overriding
    68.    procedure PIH (the_FW      : in out FW.device;
    69.                   Q_operand   : in KDF9.Q_register;
    70.                   set_offline : in Boolean);
    71.
    72.    -- TWQq
    73.    overriding
    74.    procedure POA (the_FW      : in out FW.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.
    78.    -- TWEQq
    79.    overriding
    80.    procedure POB (the_FW      : in out FW.device;
    81.                   Q_operand   : in KDF9.Q_register;
    82.                   set_offline : in Boolean);
    83.
    84.    -- NB the following assumes that page 285 of the Manual is erroneous,
    85.    -- and that POC and POD for the Flexowriter are analogous to the tape punch,
    86.    -- as other sources, such as the "Usecode Digest", do in fact indicate.
    87.
    88.    -- TWCQq character write
    89.    overriding
    90.    procedure POC (the_FW      : in out FW.device;
    91.                   Q_operand   : in KDF9.Q_register;
    92.                   set_offline : in Boolean);
    93.
    94.    -- TWECQq character write to End_Message
    95.    overriding
    96.    procedure POD (the_FW      : in out FW.device;
    97.                   Q_operand   : in KDF9.Q_register;
    98.                   set_offline : in Boolean);
    99.
   100.    procedure enable (b : in KDF9.buffer_number);
   101.
   102. private
   103.
   104.    type flexowriter_mode is
   105.       (the_flexowriter_is_reading, the_flexowriter_is_writing);
   106.
   107.    -- The Flexowriter has separate input and output streams, to accommodate the console I/O API
   108.    --    of MS Windows, which requires separate pseudo-devices for input and output.
   109.    type device is new IOC.slow.shift.device with
   110.       record
   111.          output : host_IO.stream;
   112.          mode   : FW.flexowriter_mode;
   113.          shifts : KDF9.word := 0;
   114.       end record;
   115.
   116.    overriding
   117.    procedure Initialize (the_FW : in out FW.device);
   118.
   119.    overriding
   120.    procedure Finalize (the_FW : in out FW.device);
   121.
   122.    overriding
   123.    function kind (the_FW : FW.device)
   124.    return IOC.device_kind
   125.    is (FW_kind);
   126.
   127.    overriding
   128.    function quantum (the_FW : FW.device)
   129.    return KDF9.us
   130.    is (1E6 / 10);
   131.
   132.    overriding
   133.    procedure write (the_FW    : in out FW.device;
   134.                     Q_operand : in KDF9.Q_register);
   135.
   136.    overriding
   137.    procedure write_to_EM (the_FW    : in out FW.device;
   138.                           Q_operand : in KDF9.Q_register);
   139.    overriding
   140.    procedure words_write (the_FW    : in out FW.device;
   141.                           Q_operand : in KDF9.Q_register);
   142.
   143.    overriding
   144.    procedure words_write_to_EM (the_FW    : in out FW.device;
   145.                                 Q_operand : in KDF9.Q_register);
   146.
   147.    overriding
   148.    procedure do_output_housekeeping (the_FW   : in out FW.device;
   149.                                      written,
   150.                                      fetched  : in KDF9.word);
   151.
   152. end IOC.slow.shift.FW;

 727 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-shift-si.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of a standard interface buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.shift.SI is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_SI : in out SI.device) is
    23.    begin
    24.       -- Open the associated file.
    25.       open(IOC.device(the_SI), rd_wr_mode);
    26.    end Initialize;
    27.
    28.    overriding
    29.    procedure PIA (the_SI      : in out SI.device;
    30.                   Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean) is
    32.    begin
    33.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    34.       read(the_SI, Q_operand);
    35.       lock_out_relative_addresses(Q_operand);
    36.    end PIA;
    37.
    38.    overriding
    39.    procedure PIB (the_SI      : in out SI.device;
    40.                   Q_operand   : in KDF9.Q_register;
    41.                   set_offline : in Boolean) is
    42.    begin
    43.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    44.       read_to_EM(the_SI, Q_operand);
    45.       lock_out_relative_addresses(Q_operand);
    46.    end PIB;
    47.
    48.    overriding
    49.    procedure PIC (the_SI      : in out SI.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean) is
    52.    begin
    53.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    54.       words_read(the_SI, Q_operand);
    55.       lock_out_relative_addresses(Q_operand);
    56.    end PIC;
    57.
    58.    overriding
    59.    procedure PID (the_SI      : in out SI.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean) is
    62.    begin
    63.       start_slow_transfer(the_SI, Q_operand, set_offline, input_operation);
    64.       words_read_to_EM(the_SI, Q_operand);
    65.       lock_out_relative_addresses(Q_operand);
    66.    end PID;
    67.
    68.    overriding
    69.    procedure PIE (the_SI      : in out SI.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean) is
    72.    begin
    73.       -- as PIA: "parity off" has no effect on the data read in
    74.       PIA(the_SI, Q_operand, set_offline);
    75.    end PIE;
    76.
    77.    overriding
    78.    procedure PIF (the_SI      : in out SI.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean) is
    81.    begin
    82.       -- as PIB: "parity off" has no effect on the data read in
    83.       PIB(the_SI, Q_operand, set_offline);
    84.    end PIF;
    85.
    86.    overriding
    87.    procedure PIG (the_SI      : in out SI.device;
    88.                   Q_operand   : in KDF9.Q_register;
    89.                   set_offline : in Boolean) is
    90.    begin
    91.       PIC(the_SI, Q_operand, set_offline);
    92.    end PIG;
    93.
    94.    overriding
    95.    procedure PIH (the_SI      : in out SI.device;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean) is
    98.    begin
    99.       PID(the_SI, Q_operand, set_offline);
   100.    end PIH;
   101.
   102.    overriding
   103.    procedure PMB (the_SI      : in out SI.device;
   104.                   Q_operand   : in KDF9.Q_register;
   105.                   set_offline : in Boolean) is
   106.    begin
   107.       -- ee9's SI0 always asserts 8 channel mode.
   108.       validate_device(the_SI);
   109.       validate_parity(the_SI);
   110.       deal_with_a_busy_device(the_SI, 13, set_offline);
   111.       the_T_bit_is_set := True;
   112.       take_note_of_test(the_SI.device_name, Q_operand, the_T_bit_is_set);
   113.    end PMB;
   114.
   115.    overriding
   116.    procedure PMC (the_SI      : in out SI.device;
   117.                   Q_operand   : in KDF9.Q_register;
   118.                   set_offline : in Boolean) is
   119.    begin
   120.       PMB(the_SI, Q_operand, set_offline);
   121.    end PMC;
   122.
   123.    overriding
   124.    procedure POA (the_SI      : in out SI.device;
   125.                   Q_operand   : in KDF9.Q_register;
   126.                   set_offline : in Boolean) is
   127.    begin
   128.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   129.       write(the_SI, Q_operand);
   130.       lock_out_relative_addresses(Q_operand);
   131.    end POA;
   132.
   133.    overriding
   134.    procedure POB (the_SI      : in out SI.device;
   135.                   Q_operand   : in KDF9.Q_register;
   136.                   set_offline : in Boolean) is
   137.    begin
   138.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   139.       write_to_EM(the_SI, Q_operand);
   140.       lock_out_relative_addresses(Q_operand);
   141.    end POB;
   142.
   143.    overriding
   144.    procedure POC (the_SI      : in out SI.device;
   145.                   Q_operand   : in KDF9.Q_register;
   146.                   set_offline : in Boolean) is
   147.    begin
   148.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   149.       words_write(the_SI, Q_operand);
   150.       lock_out_relative_addresses(Q_operand);
   151.    end POC;
   152.
   153.    overriding
   154.    procedure POD (the_SI      : in out SI.device;
   155.                   Q_operand   : in KDF9.Q_register;
   156.                   set_offline : in Boolean) is
   157.    begin
   158.       start_slow_transfer(the_SI, Q_operand, set_offline, output_operation);
   159.       words_write_to_EM(the_SI, Q_operand);
   160.       lock_out_relative_addresses(Q_operand);
   161.    end POD;
   162.
   163.    overriding
   164.    procedure POE (the_SI      : in out SI.device;
   165.                   Q_operand   : in KDF9.Q_register;
   166.                   set_offline : in Boolean) is
   167.    begin
   168.       require_nonnegative_count(Q_operand.M);
   169.       output_a_gap(the_SI, Q_operand, set_offline, word_mode => False, text_mode => False);
   170.    end POE;
   171.
   172.    overriding
   173.    procedure POF (the_SI      : in out SI.device;
   174.                   Q_operand   : in KDF9.Q_register;
   175.                   set_offline : in Boolean) is
   176.    begin
   177.       require_nonnegative_count(Q_operand.M);
   178.       output_a_gap(the_SI, Q_operand, set_offline, word_mode => True, text_mode => False);
   179.    end POF;
   180.
   181.    overriding
   182.    procedure Finalize (the_SI : in out SI.device) is
   183.    begin
   184.       close(
   185.             the_SI,
   186.             "transferred",
   187.             the_SI.byte_count,
   188.             "character" & plurality(the_SI.byte_count)
   189.            );
   190.    end Finalize;
   191.
   192.    type SI_access is access SI.device;
   193.
   194.    SI0 : SI_access with Warnings => Off;
   195.    SI1 : SI_access with Warnings => Off;
   196.
   197.    unit : IOC.unit_number := 0;
   198.
   199.    procedure enable (b : in KDF9.buffer_number) is
   200.    begin
   201.       case unit is
   202.          when 0 =>
   203.             SI0 := new SI.device (number => b, unit => 0);
   204.             SI0_number := b;
   205.          when 1 =>
   206.             SI1 := new SI.device (number => b, unit => 1);
   207.             SI1_number := b;
   208.          when others =>
   209.             trap_operator_error("more than two SI units have been configured");
   210.       end case;
   211.       unit := unit + 1;
   212.    end enable;
   213.
   214.    procedure replace_on_buffer (b : in KDF9.buffer_number) is
   215.    begin
   216.       if SI0 /= null   and then
   217.             SI0.number = b then
   218.          return;
   219.       end if;
   220.       if SI1 /= null   and then
   221.             SI1.number = b then
   222.          return;
   223.       end if;
   224.       buffer(b) := null;
   225.       enable(b);
   226.    end replace_on_buffer;
   227.
   228.    function SI0_is_enabled
   229.    return Boolean
   230.    is (SI0 /= null or SI1 /= null);
   231.
   232. end IOC.slow.shift.SI;

Compiling: ../Source/ioc-slow-shift-si.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of a standard interface buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.shift.SI is
    18.
    19.    -- The Standard Interface Buffer is the KDF9 device about which least is presently known.
    20.    -- Anecdotal evidence suggests it is an implementation of the British Standard Interface (BSIF).
    21.    -- ee9 implements a best guess as to its functionality, based on the following considerations.
    22.
    23.    -- According to the Manual, Appendix 6.1, p.296,
    24.    --    the Standard Interface Buffer has orders that look very like the union of a TR and a TP.
    25.
    26.    -- However:
    27.
    28.    -- (a) PIE and PIF do a read with "parity off".
    29.    --     I think this relates to a feature of the BSIF,
    30.    --        whereby a source device can omit parity if it de-asserts its "parity valid" signal.
    31.    --     With such a device the KDF9 would need a way of ignoring spurious parity errors.
    32.    -- PIE/PIF act in exactly the same way as PIA/PIB as there will be no such error under ee9.
    33.
    34.    -- (b) PMB and PMC set the Test Register "if 8 channel set".  The BSIF is 8 data bits wide.
    35.    --     I think this signals that the KDF9 should use "character" orders to access all 8 bits,
    36.    --        and I think that the other orders access only the low-order 6 bits of the interface.
    37.    -- ee9 always asserts "8 channel set", as it is always capable of providing 8-bit bytes.
    38.
    39.    -- In any case, 6-bit transfers work in the same way as for paper tape readers and punches.
    40.
    41.    type device is new IOC.slow.shift.device with private;
    42.
    43.    overriding
    44.    procedure PIA (the_SI      : in out SI.device;
    45.                   Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    overriding
    49.    procedure PIB (the_SI      : in out SI.device;
    50.                   Q_operand   : in KDF9.Q_register;
    51.                   set_offline : in Boolean);
    52.
    53.    overriding
    54.    procedure PIC (the_SI      : in out SI.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    overriding
    59.    procedure PID (the_SI      : in out SI.device;
    60.                   Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    overriding
    64.    procedure PIE (the_SI      : in out SI.device;
    65.                   Q_operand   : in KDF9.Q_register;
    66.                   set_offline : in Boolean);
    67.
    68.    overriding
    69.    procedure PIF (the_SI      : in out SI.device;
    70.                   Q_operand   : in KDF9.Q_register;
    71.                   set_offline : in Boolean);
    72.
    73.    overriding
    74.    procedure PIG (the_SI      : in out SI.device;
    75.                   Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.
    78.    overriding
    79.    procedure PIH (the_SI      : in out SI.device;
    80.                   Q_operand   : in KDF9.Q_register;
    81.                   set_offline : in Boolean);
    82.
    83.    overriding
    84.    procedure PMB (the_SI      : in out SI.device;
    85.                   Q_operand   : in KDF9.Q_register;
    86.                   set_offline : in Boolean);
    87.
    88.    overriding
    89.    procedure PMC (the_SI      : in out SI.device;
    90.                   Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean);
    92.
    93.    overriding
    94.    procedure POA (the_SI      : in out SI.device;
    95.                   Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean);
    97.
    98.    overriding
    99.    procedure POB (the_SI      : in out SI.device;
   100.                   Q_operand   : in KDF9.Q_register;
   101.                   set_offline : in Boolean);
   102.
   103.    overriding
   104.    procedure POC (the_SI      : in out SI.device;
   105.                   Q_operand   : in KDF9.Q_register;
   106.                   set_offline : in Boolean);
   107.
   108.    overriding
   109.    procedure POD (the_SI      : in out SI.device;
   110.                   Q_operand   : in KDF9.Q_register;
   111.                   set_offline : in Boolean);
   112.
   113.    overriding
   114.    procedure POE (the_SI      : in out SI.device;
   115.                   Q_operand   : in KDF9.Q_register;
   116.                   set_offline : in Boolean);
   117.
   118.    overriding
   119.    procedure POF (the_SI      : in out SI.device;
   120.                   Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean);
   122.
   123.    procedure enable (b : in KDF9.buffer_number);
   124.
   125.    procedure replace_on_buffer (b : in KDF9.buffer_number);
   126.
   127.    function SI0_is_enabled
   128.    return Boolean;
   129.
   130. private
   131.
   132.    type device is new IOC.slow.shift.device with null record;
   133.
   134.    overriding
   135.    procedure Initialize (the_SI : in out SI.device);
   136.
   137.    overriding
   138.    procedure Finalize (the_SI : in out SI.device);
   139.
   140.    overriding
   141.    function kind (the_SI : SI.device)
   142.    return IOC.device_kind
   143.    is (SI_kind);
   144.
   145.    overriding
   146.    function quantum (the_SI : SI.device)
   147.    return KDF9.us
   148.    is (1E6 / 50E3); -- I am guessing 50_000 characters per second.
   149.
   150. end IOC.slow.shift.SI;

 232 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-slow-unit.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of the common functionality of "unit record" (i.e. LP, CP or CR) devices.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.unit is
    18.
    19.    overriding
    20.    function IO_elapsed_time_total (the_buffer : unit.device)
    21.    return KDF9.us is
    22.    begin
    23.       return IO_elapsed_time(the_buffer, the_buffer.unit_count);
    24.    end IO_elapsed_time_total;
    25.
    26.    overriding
    27.    function atomic_item_count (the_buffer : unit.device;
    28.                                Q_operand  : KDF9.Q_register)
    29.    return KDF9.word is
    30.       pragma Unreferenced(the_buffer);
    31.       pragma Unreferenced(Q_operand);
    32.    begin
    33.       return 1;
    34.    end atomic_item_count;
    35.
    36. end IOC.slow.unit;

Compiling: ../Source/ioc-slow-unit.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of the common functionality of "unit record" (i.e. LP, CP or CR) devices.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.slow.unit is
    18.
    19.    --
    20.    -- This is the root type for all unit-record I/O device types.
    21.    --
    22.
    23.    type device is abstract new IOC.slow.device with private;
    24.
    25. private
    26.
    27.    type device is abstract new IOC.slow.device with
    28.       record
    29.          unit_count : KDF9.word := 0;
    30.       end record;
    31.
    32.    overriding
    33.    function IO_elapsed_time_total (the_buffer : unit.device)
    34.    return KDF9.us;
    35.
    36.    overriding
    37.    function atomic_item_count (the_buffer : unit.device;
    38.                                Q_operand  : KDF9.Q_register)
    39.    return KDF9.word;
    40.
    41. end IOC.slow.unit;

 36 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-slow-unit-cp.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of a card punch buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.unit.CP is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_CP : in out CP.device) is
    23.    begin
    24.       open(the_CP, write_mode);
    25.    end Initialize;
    26.
    27.    procedure do_output_housekeeping (the_CP     : in out CP.device;
    28.                                      fetched    : in KDF9.word) is
    29.    begin
    30.       correct_transfer_time(the_CP, actual_length => 1);
    31.       add_in_the_IO_CPU_time(the_CP, fetched);
    32.    end do_output_housekeeping;
    33.
    34.    procedure write_card (the_CP        : in out CP.device;
    35.                          Q_operand     : in KDF9.Q_register;
    36.                          max_words     : in KDF9.address;
    37.                          writing_to_EM : in Boolean := False) is
    38.       start_address : constant KDF9.address := Q_operand.I;
    39.       end_address   : constant KDF9.address := Q_operand.M;
    40.       size : KDF9.word := 0;
    41.       char : Character;
    42.       byte : KDF9_char_sets.symbol;
    43.    begin
    44.       check_addresses_and_lockouts(start_address, end_address);
    45.    word_loop:
    46.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    47.          for c in KDF9_char_sets.symbol_index'Range loop
    48.             byte := fetch_symbol(w, c);
    49.             size := size + 1;
    50.             char := to_CP(byte);
    51.             put_byte(char, the_CP.stream);
    52.             exit word_loop when writing_to_EM and char = KDF9_char_sets.E_M;
    53.          end loop;
    54.       end loop word_loop;
    55.       put_EOL(the_CP.stream);
    56.       the_CP.unit_count := the_CP.unit_count + 1;
    57.       do_output_housekeeping(the_CP, fetched => size);
    58.    end write_card;
    59.
    60.    procedure words_write_card (the_CP        : in out CP.device;
    61.                                Q_operand     : in KDF9.Q_register;
    62.                                max_words     : in KDF9.address;
    63.                                writing_to_EM : in Boolean := False) is
    64.
    65.       start_address : constant KDF9.address := Q_operand.I;
    66.       end_address   : constant KDF9.address := Q_operand.M;
    67.       size : KDF9.word := 0;
    68.       char : Character;
    69.       byte : KDF9_char_sets.symbol;
    70.    begin
    71.       check_addresses_and_lockouts(start_address, end_address);
    72.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    73.          byte := KDF9_char_sets.symbol(fetch_word(w) and 8#77#);
    74.          size := size + 1;
    75.          char := to_CP(byte);
    76.          put_byte(char, the_CP.stream);
    77.       exit when writing_to_EM and char = KDF9_char_sets.E_M;
    78.       end loop;
    79.       put_EOL(the_CP.stream);
    80.       the_CP.unit_count := the_CP.unit_count + 1;
    81.       do_output_housekeeping(the_CP, fetched => size);
    82.    end words_write_card;
    83.
    84.    overriding
    85.    procedure POA (the_CP      : in out CP.device;
    86.                   Q_operand   : in KDF9.Q_register;
    87.                   set_offline : in Boolean) is
    88.    begin
    89.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
    90.       write_card(the_CP, Q_operand, max_words => 20);
    91.       lock_out_relative_addresses(Q_operand);
    92.    end POA;
    93.
    94.    overriding
    95.    procedure POB (the_CP      : in out CP.device;
    96.                   Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean) is
    98.    begin
    99.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   100.       write_card(the_CP, Q_operand, max_words => 20, writing_to_EM => True);
   101.       lock_out_relative_addresses(Q_operand);
   102.    end POB;
   103.
   104.    overriding
   105.    procedure POC (the_CP      : in out CP.device;
   106.                   Q_operand   : in KDF9.Q_register;
   107.                   set_offline : in Boolean) is
   108.    begin
   109.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   110.       words_write_card(the_CP, Q_operand, max_words => 160);
   111.       lock_out_relative_addresses(Q_operand);
   112.    end POC;
   113.
   114.    overriding
   115.    procedure POD (the_CP      : in out CP.device;
   116.                   Q_operand   : in KDF9.Q_register;
   117.                   set_offline : in Boolean) is
   118.    begin
   119.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   120.       words_write_card(the_CP, Q_operand, max_words => 160, writing_to_EM => True);
   121.       lock_out_relative_addresses(Q_operand);
   122.    end POD;
   123.
   124.    overriding
   125.    procedure POE (the_CP      : in out CP.device;
   126.                   Q_operand   : in KDF9.Q_register;
   127.                   set_offline : in Boolean) is
   128.    begin
   129.       POC(the_CP, Q_operand, set_offline);
   130.    end POE;
   131.
   132.    overriding
   133.    procedure POF (the_CP      : in out CP.device;
   134.                   Q_operand   : in KDF9.Q_register;
   135.                   set_offline : in Boolean) is
   136.    begin
   137.       POA(the_CP, Q_operand, set_offline);
   138.    end POF;
   139.
   140.    overriding
   141.    procedure POG (the_CP      : in out CP.device;
   142.                   Q_operand   : in KDF9.Q_register;
   143.                   set_offline : in Boolean) is
   144.    begin
   145.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   146.       write_card(the_CP, Q_operand, max_words => 10, writing_to_EM => False);
   147.       lock_out_relative_addresses(Q_operand);
   148.    end POG;
   149.
   150.    overriding
   151.    procedure POH (the_CP      : in out CP.device;
   152.                   Q_operand   : in KDF9.Q_register;
   153.                   set_offline : in Boolean) is
   154.    begin
   155.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   156.       write_card(the_CP, Q_operand, max_words => 10, writing_to_EM => True);
   157.       lock_out_relative_addresses(Q_operand);
   158.    end POH;
   159.
   160.    overriding
   161.    procedure POK (the_CP      : in out CP.device;
   162.                   Q_operand   : in KDF9.Q_register;
   163.                   set_offline : in Boolean) is
   164.    begin
   165.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   166.       -- See the Manual, p289.
   167.       words_write_card(the_CP, Q_operand, max_words => 80, writing_to_EM => True);
   168.       lock_out_relative_addresses(Q_operand);
   169.    end POK;
   170.
   171.    overriding
   172.    procedure POL (the_CP      : in out CP.device;
   173.                   Q_operand   : in KDF9.Q_register;
   174.                   set_offline : in Boolean) is
   175.    begin
   176.       start_slow_transfer(the_CP, Q_operand, set_offline, output_operation);
   177.       -- See the Manual, p289.
   178.       words_write_card(the_CP, Q_operand, max_words => 80, writing_to_EM => False);
   179.       lock_out_relative_addresses(Q_operand);
   180.    end POL;
   181.
   182.    overriding
   183.    procedure Finalize (the_CP : in out CP.device) is
   184.    begin
   185.       close(
   186.             the_CP,
   187.             "punched",
   188.             the_CP.unit_count,
   189.             "card" & plurality(the_CP.unit_count)
   190.            );
   191.    end Finalize;
   192.
   193.    type CP_access is access CP.device;
   194.
   195.    CP0 : CP_access with Warnings => Off;
   196.    CP1 : CP_access with Warnings => Off;
   197.
   198.    unit : IOC.unit_number := 0;
   199.
   200.    procedure enable (b : in KDF9.buffer_number) is
   201.    begin
   202.       case unit is
   203.          when 0 =>
   204.             CP0 := new CP.device (number => b, unit => 0);
   205.             CP0_number := b;
   206.          when 1 =>
   207.             CP1 := new CP.device (number => b, unit => 1);
   208.             CP1_number := b;
   209.          when others =>
   210.             trap_operator_error("more than two CP units have been configured");
   211.       end case;
   212.       unit := unit + 1;
   213.    end enable;
   214.
   215. end IOC.slow.unit.CP;

Compiling: ../Source/ioc-slow-unit-cp.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of a card punch buffer.
     2. -- Card punches are "unit record" devices: they cannot transfer less than a whole card.
     3. --
     4. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package IOC.slow.unit.CP is
    19.
    20.    type device is new IOC.slow.unit.device with private;
    21.
    22.    -- Punch binary mode.
    23.    overriding
    24.    procedure POA (the_CP      : in out CP.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    -- Punch binary mode to End Message.
    29.    overriding
    30.    procedure POB (the_CP      : in out CP.device;
    31.                   Q_operand   : in KDF9.Q_register;
    32.                   set_offline : in Boolean);
    33.
    34.    -- Punch binary character mode.
    35.    overriding
    36.    procedure POC (the_CP      : in out CP.device;
    37.                   Q_operand   : in KDF9.Q_register;
    38.                   set_offline : in Boolean);
    39.
    40.    -- Punch binary character mode to End Message.
    41.    overriding
    42.    procedure POD (the_CP      : in out CP.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    -- As POC.
    47.    overriding
    48.    procedure POE (the_CP      : in out CP.device;
    49.                   Q_operand   : in KDF9.Q_register;
    50.                   set_offline : in Boolean);
    51.
    52.    -- As POA.
    53.    overriding
    54.    procedure POF (the_CP      : in out CP.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    -- Punch alphanumeric mode.
    59.    overriding
    60.    procedure POG (the_CP      : in out CP.device;
    61.                   Q_operand   : in KDF9.Q_register;
    62.                   set_offline : in Boolean);
    63.
    64.    -- Punch alphanumeric mode to End Message.
    65.    overriding
    66.    procedure POH (the_CP      : in out CP.device;
    67.                   Q_operand   : in KDF9.Q_register;
    68.                   set_offline : in Boolean);
    69.
    70.    -- Punch alphanumeric character mode to End Message.
    71.    overriding
    72.    procedure POK (the_CP      : in out CP.device;
    73.                   Q_operand   : in KDF9.Q_register;
    74.                   set_offline : in Boolean);
    75.
    76.    -- Punch alphanumeric character mode.
    77.    overriding
    78.    procedure POL (the_CP      : in out CP.device;
    79.                   Q_operand   : in KDF9.Q_register;
    80.                   set_offline : in Boolean);
    81.
    82.    procedure enable (b : in KDF9.buffer_number);
    83.
    84. private
    85.
    86.    type device is new IOC.slow.unit.device with null record;
    87.
    88.    overriding
    89.    procedure Initialize (the_CP : in out CP.device);
    90.
    91.    overriding
    92.    procedure Finalize (the_CP : in out CP.device);
    93.
    94.    overriding
    95.    function kind (the_CP : CP.device)
    96.    return IOC.device_kind
    97.    is (CP_kind);
    98.
    99.    overriding
   100.    function quantum (the_CP : CP.device)
   101.    return KDF9.us
   102.    is (1E6 / (300 / 60)); -- 300 cards per minute.
   103.
   104. end IOC.slow.unit.CP;

 215 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-slow-unit-cr.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of a card reader buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.unit.CR is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_CR : in out CR.device) is
    23.    begin
    24.       open(the_CR, read_mode);
    25.    end Initialize;
    26.
    27.    blank_card : constant String(max_card_columns) := (others => SP);
    28.
    29.    procedure get_card_image (the_CR         : in out CR.device;
    30.                               size          : in out KDF9.word;
    31.                               max_columns   : in KDF9.address;
    32.                               reading_to_EM : in Boolean := False) is
    33.       max  : constant Positive := Positive(max_columns);
    34.       char : Character;
    35.    begin
    36.       -- Clear out the card image field.
    37.       the_CR.card_image(1..max) := blank_card(1..max);
    38.       -- Fill as much of the card image as possible with the next data line, padded out with
    39.       --    blanks, so that it is unnecessary to type all 80 or 160 characters.
    40.       -- For transfers to End Message, a line terminator must follow the E_M.
    41.       for i in 1 .. max loop
    42.          get_char_from_stream (char, the_CR);
    43.          size := size + 1;
    44.       exit when char = LF;
    45.          the_CR.card_image(i) := char;
    46.       exit when reading_to_EM and char = KDF9_char_sets.E_M;
    47.       end loop;
    48.       if char /= KDF9_char_sets.E_M then  -- The whole card was read.
    49.          size := KDF9.word(max);
    50.       end if;
    51.       the_CR.unit_count := the_CR.unit_count + 1;
    52.       -- Discard excess characters in the current data line.
    53.       while char /= LF loop
    54.          get_char_from_stream (char, the_CR);  -- N.B. do not update size for discards.
    55.       end loop;
    56.    exception
    57.       when end_of_stream =>
    58.          flush(the_CR.stream);
    59.          the_CR.is_abnormal := True;
    60.          raise;
    61.    end get_card_image;
    62.
    63.    procedure do_input_housekeeping (the_CR  : in out CR.device;
    64.                                     fetched : in KDF9.word) is
    65.    begin
    66.       add_in_the_IO_CPU_time(the_CR, fetched);
    67.       correct_transfer_time(the_CR, actual_length => 1);
    68.    end do_input_housekeeping;
    69.
    70.    procedure read_card (the_CR        : in out CR.device;
    71.                         Q_operand     : in KDF9.Q_register;
    72.                         max_words     : in KDF9.address;
    73.                         reading_to_EM : in Boolean := False) is
    74.       start_address : constant KDF9.address := Q_operand.I;
    75.       end_address   : constant KDF9.address := Q_operand.M;
    76.       size : KDF9.word := 0;
    77.       next : Natural := 0;
    78.       char : Character;
    79.       byte : KDF9_char_sets.symbol;
    80.    begin
    81.       check_addresses_and_lockouts(start_address, end_address);
    82.       get_card_image(the_CR, size, max_columns => max_words*8);
    83.    word_loop:
    84.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
    85.          for c in KDF9_char_sets.symbol_index'Range loop
    86.             next := next + 1;
    87.             char := the_CR.card_image(next);
    88.             byte := CR_in(char);
    89.             store_symbol(byte, w, c);
    90.             if reading_to_EM and byte = KDF9_char_sets.End_Message then
    91.                for d in 1 .. 7-c loop
    92.                   store_symbol(KDF9_char_sets.Blank_Space, w, c+d);
    93.                end loop;
    94.                exit word_loop;
    95.             end if;
    96.          end loop;
    97.       end loop word_loop;
    98.       do_input_housekeeping(the_CR, size);
    99.    exception
   100.       when end_of_stream =>
   101.          do_input_housekeeping(the_CR, size);
   102.    end read_card;
   103.
   104.    procedure words_read_card (the_CR        : in out CR.device;
   105.                               Q_operand     : in KDF9.Q_register;
   106.                               max_words     : in KDF9.address;
   107.                               reading_to_EM : in Boolean := False) is
   108.       start_address : constant KDF9.address := Q_operand.I;
   109.       end_address   : constant KDF9.address := Q_operand.M;
   110.       size : KDF9.word := 0;
   111.       next : Natural := 0;
   112.       char : Character;
   113.       word : KDF9.word;
   114.    begin
   115.       check_addresses_and_lockouts(start_address, end_address);
   116.       get_card_image(the_CR, size, max_columns => max_words);
   117.       if the_CR.is_abnormal then return; end if;
   118.       for w in start_address .. KDF9.address'Min(end_address, start_address+max_words-1) loop
   119.          next := next + 1;
   120.          char := the_CR.card_image(next);
   121.          word := KDF9.word(CR_in(char));
   122.          store_word(word, w);
   123.       exit when reading_to_EM and char = KDF9_char_sets.E_M;
   124.       end loop;
   125.       add_in_the_IO_CPU_time(the_CR, size);
   126.       correct_transfer_time(the_CR, actual_length => 1);
   127.    exception
   128.       when end_of_stream =>
   129.          flush(the_CR.stream);
   130.          add_in_the_IO_CPU_time(the_CR, size);
   131.          correct_transfer_time(the_CR, actual_length => 1);
   132.    end words_read_card;
   133.
   134.    overriding
   135.    procedure PIA (the_CR      : in out CR.device;
   136.                   Q_operand   : in KDF9.Q_register;
   137.                   set_offline : in Boolean) is
   138.    begin
   139.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   140.       read_card(the_CR, Q_operand, max_words => 20);
   141.       lock_out_relative_addresses(Q_operand);
   142.    end PIA;
   143.
   144.    overriding
   145.    procedure PIB (the_CR      : in out CR.device;
   146.                   Q_operand   : in KDF9.Q_register;
   147.                   set_offline : in Boolean) is
   148.    begin
   149.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   150.       read_card(the_CR, Q_operand, max_words => 20, reading_to_EM => True);
   151.       lock_out_relative_addresses(Q_operand);
   152.    end PIB;
   153.
   154.    overriding
   155.    procedure PIC (the_CR      : in out CR.device;
   156.                   Q_operand   : in KDF9.Q_register;
   157.                   set_offline : in Boolean) is
   158.    begin
   159.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   160.       words_read_card(the_CR, Q_operand, max_words => 160);
   161.       lock_out_relative_addresses(Q_operand);
   162.    end PIC;
   163.
   164.    overriding
   165.    procedure PID (the_CR      : in out CR.device;
   166.                   Q_operand   : in KDF9.Q_register;
   167.                   set_offline : in Boolean) is
   168.    begin
   169.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   170.       words_read_card(the_CR, Q_operand, max_words => 160, reading_to_EM => True);
   171.       lock_out_relative_addresses(Q_operand);
   172.    end PID;
   173.
   174.    overriding
   175.    procedure PIE (the_CR      : in out CR.device;
   176.                   Q_operand   : in KDF9.Q_register;
   177.                   set_offline : in Boolean) is
   178.    begin
   179.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   180.       read_card(the_CR, Q_operand, max_words => 10);
   181.       lock_out_relative_addresses(Q_operand);
   182.    end PIE;
   183.
   184.    overriding
   185.    procedure PIF (the_CR      : in out CR.device;
   186.                   Q_operand   : in KDF9.Q_register;
   187.                   set_offline : in Boolean) is
   188.    begin
   189.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   190.       read_card(the_CR, Q_operand, max_words => 10, reading_to_EM => True);
   191.       lock_out_relative_addresses(Q_operand);
   192.    end PIF;
   193.
   194.    overriding
   195.    procedure PIG (the_CR      : in out CR.device;
   196.                   Q_operand   : in KDF9.Q_register;
   197.                   set_offline : in Boolean) is
   198.    begin
   199.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   200.       words_read_card(the_CR, Q_operand, max_words => 80);
   201.       lock_out_relative_addresses(Q_operand);
   202.    end PIG;
   203.
   204.    overriding
   205.    procedure PIH (the_CR      : in out CR.device;
   206.                   Q_operand   : in KDF9.Q_register;
   207.                   set_offline : in Boolean) is
   208.    begin
   209.       start_slow_transfer(the_CR, Q_operand, set_offline, input_operation);
   210.       words_read_card(the_CR, Q_operand, max_words => 80, reading_to_EM => True);
   211.       lock_out_relative_addresses(Q_operand);
   212.    end PIH;
   213.
   214.    -- the_T_bit_is_set := (RECHECK switch is OFF). {It always is nowadays!}
   215.    overriding
   216.    procedure PMB (the_CR      : in out CR.device;
   217.                   Q_operand   : in KDF9.Q_register;
   218.                   set_offline : in Boolean) is
   219.    begin
   220.       validate_device(the_CR);
   221.       validate_parity(the_CR);
   222.       deal_with_a_busy_device(the_CR, 13, set_offline);
   223.       the_T_bit_is_set := True;
   224.       take_note_of_test(the_CR.device_name, Q_operand, the_T_bit_is_set);
   225.    end PMB;
   226.
   227.    overriding
   228.    procedure Finalize (the_CR : in out CR.device) is
   229.    begin
   230.       close(
   231.             the_CR,
   232.             "read",
   233.             the_CR.unit_count,
   234.             "card" & plurality(the_CR.unit_count)
   235.            );
   236.    end Finalize;
   237.
   238.    type CR_access is access CR.device;
   239.
   240.    CR0 : CR_access with Warnings => Off;
   241.    CR1 : CR_access with Warnings => Off;
   242.
   243.    unit : IOC.unit_number := 0;
   244.
   245.    procedure enable (b : in KDF9.buffer_number) is
   246.    begin
   247.       case unit is
   248.          when 0 =>
   249.             CR0 := new CR.device (number => b, unit => 0);
   250.             CR0_number := b;
   251.          when 1 =>
   252.             CR1 := new CR.device (number => b, unit => 1);
   253.             CR1_number := b;
   254.          when others =>
   255.             trap_operator_error("more than two CR units have been configured");
   256.       end case;
   257.       unit := unit + 1;
   258.    end enable;
   259.
   260. end IOC.slow.unit.CR;

Compiling: ../Source/ioc-slow-unit-cr.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of a card reader buffer.
     2. -- Card readers are "unit record" devices: they cannot transfer less than a whole card.
     3. --
     4. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package IOC.slow.unit.CR is
    19.
    20.    type device is new IOC.slow.unit.device with private;
    21.
    22.    -- Binary (undecoded) read
    23.    overriding
    24.    procedure PIA (the_CR      : in out CR.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    -- Binary (undecoded) read to End_Message
    29.    overriding
    30.    procedure PIB (the_CR      : in out CR.device;
    31.                   Q_operand   : in KDF9.Q_register;
    32.                   set_offline : in Boolean);
    33.
    34.    -- Binary (undecoded) character read
    35.    overriding
    36.    procedure PIC (the_CR      : in out CR.device;
    37.                   Q_operand   : in KDF9.Q_register;
    38.                   set_offline : in Boolean);
    39.
    40.    -- Binary (undecoded) character read to End_Message
    41.    overriding
    42.    procedure PID (the_CR      : in out CR.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    -- Alphanumeric (decoded) read
    47.    overriding
    48.    procedure PIE (the_CR      : in out CR.device;
    49.                   Q_operand   : in KDF9.Q_register;
    50.                   set_offline : in Boolean);
    51.
    52.    -- Alphanumeric (decoded) read to End_Message
    53.    overriding
    54.    procedure PIF (the_CR      : in out CR.device;
    55.                   Q_operand   : in KDF9.Q_register;
    56.                   set_offline : in Boolean);
    57.
    58.    -- Alphanumeric (decoded) character read
    59.    overriding
    60.    procedure PIG (the_CR      : in out CR.device;
    61.                   Q_operand   : in KDF9.Q_register;
    62.                   set_offline : in Boolean);
    63.
    64.    -- Alphanumeric (decoded) character read to End_Message
    65.    overriding
    66.    procedure PIH (the_CR      : in out CR.device;
    67.                   Q_operand   : in KDF9.Q_register;
    68.                   set_offline : in Boolean);
    69.
    70.    -- the_T_bit_is_set := (RECHECK switch is OFF)
    71.    overriding
    72.    procedure PMB (the_CR      : in out CR.device;
    73.                   Q_operand   : in KDF9.Q_register;
    74.                   set_offline : in Boolean);
    75.
    76.    procedure enable (b : in KDF9.buffer_number);
    77.
    78. private
    79.
    80.    subtype max_card_columns is Positive range 1 .. 160;
    81.
    82.    type device is new IOC.slow.unit.device with
    83.       record
    84.          card_image : String(max_card_columns);
    85.       end record;
    86.
    87.    overriding
    88.    procedure Initialize (the_CR : in out CR.device);
    89.
    90.    overriding
    91.    procedure Finalize (the_CR : in out CR.device);
    92.
    93.    overriding
    94.    function kind (the_CR : CR.device)
    95.    return IOC.device_kind
    96.    is (CR_kind);
    97.
    98.    overriding
    99.    function quantum (the_CR : CR.device)
   100.    return KDF9.us
   101.    is (1E6 / (600 / 60)); -- 600 cards per minute.
   102.
   103. end IOC.slow.unit.CR;

 260 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-the_locker_of.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Identify the buffer that caused a store lockout.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. function IOC.the_locker_of (address : KDF9.Q_part; found : out Boolean)
    18. return KDF9.Q_part is
    19.    candidate_time   : KDF9.us     := KDF9.us'Last;
    20.    candidate_number : KDF9.Q_part := 0;
    21. begin
    22.    -- Select the buffer actively doing DMA in the_group;
    23.    --    if there is more than one, choose the buffer with the earliest completion time.
    24.    -- The latter case should not arise in practice, but is allowed by the hardware.
    25.    found := False;
    26.    for b in buffer'Range loop
    27.       if buffer(b) /= null                                               and then
    28.             buffer(b).is_busy                                            and then
    29.                buffer(b).operation in input_operation | output_operation and then
    30.                   buffer(b).completion_time < candidate_time             and then
    31.                      group(address) in group(buffer(b).control_word.I)
    32.                                     .. group(buffer(b).control_word.M)       then
    33.          found := True;
    34.          candidate_number := b;
    35.          candidate_time   := buffer(b).completion_time;
    36.       end if;
    37.    end loop;
    38.    return candidate_number;
    39. end IOC.the_locker_of;

 39 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-slow-unit-lp.adb
Source file time stamp: 2022-08-13 20:11:44
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of a lineprinter buffer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.slow.unit.LP is
    18.
    19.    use KDF9_char_sets;
    20.
    21.    overriding
    22.    procedure Initialize (the_LP : in out LP.device) is
    23.    begin
    24.       open(the_LP, write_mode);
    25.    end Initialize;
    26.
    27.    max_LP_line_length : constant := 160;  -- This is a hardware limit.
    28.    max_LP_page_length : constant :=  66;  -- This is the length of a page of standard stationery.
    29.
    30.    -- The number of lines traversed by paper motion with a standard control loop.
    31.    function skip_length (the_LP : LP.device; symbol : KDF9_char_sets.symbol)
    32.    return KDF9.word
    33.    is (
    34.        if symbol = KDF9_char_sets.Page_Change
    35.        then max_LP_page_length - the_LP.unit_count mod max_LP_page_length
    36.        else 1
    37.       );
    38.
    39.    procedure do_output_housekeeping (the_LP   : in out LP.device;
    40.                                      old_count,
    41.                                      fetched  : in KDF9.word) is
    42.    begin
    43.       flush(the_LP.stream);
    44.       correct_transfer_time(the_LP, IO_elapsed_time(the_LP, the_LP.unit_count-old_count));
    45.       add_in_the_IO_CPU_time(the_LP, fetched);
    46.    end do_output_housekeeping;
    47.
    48.    next_column : Natural := 0;
    49.
    50.    procedure print (symbol : in KDF9_char_sets.symbol; the_LP : in out LP.device) is
    51.       char : constant Character := to_LP(symbol);
    52.    begin
    53.       if char /= KDF9_char_sets.W_F then
    54.          if symbol in KDF9_char_sets.Line_Shift | KDF9_char_sets.Page_Change then
    55.             the_LP.unit_count := the_LP.unit_count + skip_length(the_LP, symbol);
    56.             put_char(char, the_LP.stream);
    57.             next_column := 0;
    58.          elsif next_column < max_LP_line_length then
    59.             next_column := next_column + 1;
    60.             put_char(char, the_LP.stream);
    61.          end if;
    62.       end if;
    63.    end print;
    64.
    65.    -- It is unclear what should happen if more than max_LP_line_length printable characters
    66.    --    are sent to the printer before a LS or PC character, which empties the print matrix.
    67.    -- ee9 simply ignores the excess.
    68.
    69.    procedure put_symbols (the_LP        : in out LP.device;
    70.                           Q_operand     : in KDF9.Q_register;
    71.                           writing_to_EM : in Boolean) is
    72.       start_address : constant KDF9.address := Q_operand.I;
    73.       end_address   : constant KDF9.address := Q_operand.M;
    74.       count         : constant KDF9.word := the_LP.unit_count;
    75.       size   : KDF9.word := 0;
    76.       symbol : KDF9_char_sets.symbol;
    77.    begin
    78.       check_addresses_and_lockouts(start_address, end_address);
    79.    word_loop:
    80.       for w in start_address .. end_address loop
    81.          for c in KDF9_char_sets.symbol_index'Range loop
    82.             symbol := fetch_symbol(w, c);
    83.             size := size + 1;
    84.       -- Is this what should happen transfers on EM, leaving the print matrix ready for more data ??
    85.       exit word_loop when writing_to_EM and symbol = KDF9_char_sets.End_Message;
    86.             print(symbol, the_LP);
    87.          end loop;
    88.       end loop word_loop;
    89.       do_output_housekeeping(the_LP, old_count => count, fetched => size);
    90.    end put_symbols;
    91.
    92.    -- LPQq
    93.    overriding
    94.    procedure POA (the_LP      : in out LP.device;
    95.                   Q_operand   : in KDF9.Q_register;
    96.                   set_offline : in Boolean) is
    97.    begin
    98.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
    99.       put_symbols(the_LP, Q_operand, writing_to_EM => False);
   100.       lock_out_relative_addresses(Q_operand);
   101.    end POA;
   102.
   103.    -- LPEQq
   104.    overriding
   105.    procedure POB (the_LP      : in out LP.device;
   106.                   Q_operand   : in KDF9.Q_register;
   107.                   set_offline : in Boolean) is
   108.    begin
   109.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   110.       put_symbols(the_LP, Q_operand, writing_to_EM => True);
   111.       lock_out_relative_addresses(Q_operand);
   112.    end POB;
   113.
   114.    procedure put_words (the_LP        : in out LP.device;
   115.                         Q_operand     : in KDF9.Q_register;
   116.                         writing_to_EM : in Boolean) is
   117.       start_address : constant KDF9.address := Q_operand.I;
   118.       end_address   : constant KDF9.address := Q_operand.M;
   119.       count         : constant KDF9.word := the_LP.unit_count;
   120.       size   : KDF9.word := 0;
   121.       symbol : KDF9_char_sets.symbol;
   122.    begin
   123.       check_addresses_and_lockouts(start_address, end_address);
   124.       for w in start_address .. end_address loop
   125.          symbol := KDF9_char_sets.symbol(fetch_word(w) and 8#77#);
   126.          size := size + 1;
   127.       -- Is this what should happen transfers on EM, leaving the print matrix ready for more data ??
   128.       exit when writing_to_EM and symbol = KDF9_char_sets.End_Message;
   129.          print(symbol, the_LP);
   130.       end loop;
   131.       do_output_housekeeping(the_LP, old_count => count, fetched => size);
   132.    end put_words;
   133.
   134.    -- Character write ?? Usercode Digest and Manual conflict!
   135.    overriding
   136.    procedure POC (the_LP      : in out LP.device;
   137.                   Q_operand   : in KDF9.Q_register;
   138.                   set_offline : in Boolean) is
   139.    begin
   140.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   141.       put_words(the_LP, Q_operand, writing_to_EM => False);
   142.       lock_out_relative_addresses(Q_operand);
   143.    end POC;
   144.
   145.    -- Character write to End_Message ?? Usercode Digest and Manual conflict!
   146.    overriding
   147.    procedure POD (the_LP      : in out LP.device;
   148.                   Q_operand   : in KDF9.Q_register;
   149.                   set_offline : in Boolean) is
   150.    begin
   151.       start_slow_transfer(the_LP, Q_operand, set_offline, output_operation);
   152.       put_words(the_LP, Q_operand, writing_to_EM => True);
   153.       lock_out_relative_addresses(Q_operand);
   154.    end POD;
   155.
   156.    overriding
   157.    procedure Finalize (the_LP : in out LP.device) is
   158.    begin
   159.       close(
   160.             the_LP,
   161.             "printed",
   162.             the_LP.unit_count,
   163.             "line" & plurality(the_LP.unit_count)
   164.            );
   165.    end Finalize;
   166.
   167.    type LP_access is access LP.device;
   168.
   169.    LP0 : LP_access with Warnings => Off;
   170.    LP1 : LP_access with Warnings => Off;
   171.
   172.    unit : IOC.unit_number := 0;
   173.
   174.    procedure enable (b : in KDF9.buffer_number) is
   175.    begin
   176.       case unit is
   177.          when 0 =>
   178.             LP0 := new LP.device (number => b, unit => 0);
   179.             LP0_number := b;
   180.          when 1 =>
   181.             LP1 := new LP.device (number => b, unit => 1);
   182.             LP1_number := b;
   183.          when others =>
   184.             trap_operator_error("more than two LP units have been configured");
   185.       end case;
   186.       unit := unit + 1;
   187.    end enable;
   188.
   189. end IOC.slow.unit.LP;

Compiling: ../Source/ioc-slow-unit-lp.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- Emulation of a lineprinter buffer.
     2. -- Lineprinters are "unit record" devices: they cannot transfer less than a whole line.
     3. --
     4. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package IOC.slow.unit.LP is
    19.
    20.    type device is new IOC.slow.unit.device with private;
    21.
    22.    -- LPQq
    23.    overriding
    24.    procedure POA (the_LP      : in out LP.device;
    25.                   Q_operand   : in KDF9.Q_register;
    26.                   set_offline : in Boolean);
    27.
    28.    -- LPEQq
    29.    overriding
    30.    procedure POB (the_LP      : in out LP.device;
    31.                   Q_operand   : in KDF9.Q_register;
    32.                   set_offline : in Boolean);
    33.
    34.    -- Character write ??
    35.    overriding
    36.    procedure POC (the_LP      : in out LP.device;
    37.                   Q_operand   : in KDF9.Q_register;
    38.                   set_offline : in Boolean);
    39.
    40.    -- Character write to End_Message ??
    41.    overriding
    42.    procedure POD (the_LP      : in out LP.device;
    43.                   Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean);
    45.
    46.    procedure enable (b : in KDF9.buffer_number);
    47.
    48. private
    49.
    50.    type device is new IOC.slow.unit.device with null record;
    51.
    52.    overriding
    53.    procedure Initialize (the_LP : in out LP.device);
    54.
    55.    overriding
    56.    procedure Finalize (the_LP : in out LP.device);
    57.
    58.    overriding
    59.    function kind (the_LP : LP.device)
    60.    return IOC.device_kind
    61.    is (LP_kind);
    62.
    63.    overriding
    64.    function quantum (the_LP : LP.device)
    65.    return KDF9.us
    66.    is (1E6 / (900 / 60)); -- 900 lines per minute.
    67.
    68. end IOC.slow.unit.LP;

 189 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-cpu.adb
Source file time stamp: 2022-09-11 14:40:25
Compiled at: 2022-09-15 15:08:02

     1. -- Support for KDF9 CPU/ALU operations that are not automatically inherited from
     2. --   Ada types; and for types used in the internal functioning of the microcode.
     3. --
     4. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17. --
    18.
    19. package body KDF9.CPU is
    20.
    21. --
    22. --
    23.    --
    24.    -- KDF9 Arithmetic Control (AC) primitives representing Shift Control and associated units.
    25.    -- These units implement shifting, multiplication, division, and floating-point arithmetic.
    26.    --
    27. --
    28. --
    29.
    30.    KDF9_max_signed : constant CPU.s_64 := CPU.s_64(CPU.signed'Last);
    31.    KDF9_min_signed : constant CPU.s_64 := CPU.s_64(CPU.signed'First);
    32.
    33.    function as_word (u : CPU.u_64)
    34.    return KDF9.word
    35.    is (KDF9.word(u and KDF9.word_mask));
    36.
    37.    function as_word (s : CPU.s_64)
    38.    return KDF9.word is
    39.    begin
    40.       if s > KDF9_max_signed or s < KDF9_min_signed then
    41.          the_V_bit_is_set := True;
    42.       end if;
    43.       return as_word(unsign(s));
    44.    end as_word;
    45.
    46.    function contracted (P : KDF9.pair)
    47.    return KDF9.word is
    48.    begin
    49.       if resign(P.lsw) < 0 or (P.msw+1) > 1 then
    50.          the_V_bit_is_set := True;
    51.       end if;
    52.       return (P.lsw and not_sign_bit) or (P.msw and sign_bit);
    53.    end contracted;
    54.
    55.    function shift_time (amount : Natural)
    56.    return KDF9.us
    57.    is (KDF9.us(amount/16 + amount/8 mod 2 + (if amount mod 8 > 0 then 1 else 0)));
    58.
    59.    function normalize_time (amount : Natural)
    60.    return KDF9.us
    61.    is (KDF9.us(amount/8 + (if amount mod 8 > 0 then 1 else 0)));
    62.
    63.    function shift_word_left (W : KDF9.word; amount : word_shift_length)
    64.    return KDF9.word
    65.    is (as_word(shift_left(CPU.u_64(W), amount)));
    66.
    67.    function shift_word_right (W : KDF9.word; amount : word_shift_length)
    68.    return KDF9.word
    69.    is (KDF9.word(shift_right(CPU.u_64(W), amount)));
    70.
    71.    function rotate_word_left (W : KDF9.word; amount : word_shift_length)
    72.    return KDF9.word
    73.    is (shift_word_left(W, amount) or shift_word_right(W, 48-amount));
    74.
    75.    function rotate_word_right (W : KDF9.word; amount : word_shift_length)
    76.    return KDF9.word
    77.    is (shift_word_right(W, amount) or shift_word_left(W, 48-amount));
    78.
    79.    function shift_circular (W : KDF9.word; L : CPU.signed_Q_part)
    80.    return KDF9.word
    81.       -- The logic here conforms to 1.1 of EE Report K/GD.y.80, entitled
    82.       --    "KDF 9: SHIFTING AND SHIFT CONTROL".
    83.       -- Circular shifts were implemented by duplicating the operand, doing a double-length
    84.       --    shift of the two words, and selecting the appropriate word from the result.
    85.    is (
    86.        if abs L > 95  then 0
    87.        elsif  L < -48 then shift_word_right(W, Natural(-L-48))
    88.        elsif  L > +48 then shift_word_left(W, Natural(+L-48))
    89.        elsif  L < 0   then rotate_word_right(W, Natural(-L))
    90.        else                rotate_word_left(W, Natural(L))
    91.       );
    92.
    93.    function shift_logical (W : KDF9.word; L : CPU.signed_Q_part)
    94.    return KDF9.word
    95.    is
    96.       (
    97.        if abs L > 47 then 0
    98.        elsif  L < 0  then shift_word_right(W, Natural(-L))
    99.        else               shift_word_left(W, Natural(L))
   100.       );
   101.
   102.    function shift_pair_left (P : KDF9.pair; L : Natural)
   103.    return KDF9.pair is
   104.       result    : KDF9.pair;
   105.       crossover : KDF9.word;
   106.    begin
   107.       -- The logic here conforms to 3.2 of EE Report K/GD.y.80.
   108.       if L < 48 then
   109.          result.lsw := shift_word_left(P.lsw, L);
   110.          crossover  := shift_word_right(P.lsw, 48-L);
   111.          result.msw := shift_word_left(P.msw, L) or crossover;
   112.       elsif L < 96 then
   113.          result.lsw := 0;
   114.          result.msw := shift_word_left(P.lsw, L-48);
   115.       else
   116.          result.lsw := 0;
   117.          result.msw := 0;
   118.       end if;
   119.       return result;
   120.    end shift_pair_left;
   121.
   122.    function shift_pair_right (P : KDF9.pair; L : Natural)
   123.    return KDF9.pair is
   124.       result    : KDF9.pair;
   125.       crossover : KDF9.word;
   126.    begin
   127.       -- The logic here conforms to 3.2 of EE Report K/GD.y.80.
   128.       if L < 48 then
   129.          result.msw := shift_word_right(P.msw, L);
   130.          crossover  := shift_word_left(P.msw, 48-L);
   131.          result.lsw := shift_word_right(P.lsw, L) or crossover;
   132.       elsif L < 96 then
   133.          result.msw := 0;
   134.          result.lsw := shift_word_right(P.msw, L-48);
   135.       else
   136.          result.msw := 0;
   137.          result.lsw := 0;
   138.       end if;
   139.       return result;
   140.    end shift_pair_right;
   141.
   142.    function shift_logical (P : KDF9.pair; L : CPU.signed_Q_part)
   143.    return KDF9.pair
   144.    is (
   145.        if    L > 0 then shift_pair_left(P, Natural(L))
   146.        elsif L < 0 then shift_pair_right(P, Natural(-L))
   147.        else        P
   148.       );
   149.
   150.    function scale_down (W : KDF9.word; amount : Natural)
   151.    return KDF9.word is
   152.       unrounded, clearing : CPU.u_64;
   153.    begin
   154.       if amount = 0 then
   155.          return W;
   156.       elsif amount > 46 then
   157.          if resign(W) < 0 then
   158.             return KDF9.all_one_bits;
   159.          else
   160.             return 0;
   161.          end if;
   162.       else
   163.          -- It is undefined whether the intrinsic shift_right_arithmetic function,
   164.          --    operating on CPU.u_64, yields a rounded result.
   165.          -- So, any rounding it might do is completely suppressed.
   166.          unrounded := shift_right_arithmetic(shift_left(CPU.u_64(W),16), 16);
   167.          clearing  := - shift_left(1, amount);
   168.          return as_word(shift_right_arithmetic(unrounded and clearing, amount));
   169.       end if;
   170.    end scale_down;
   171.
   172.    function scale_down_and_round (W : KDF9.word; amount : Natural)
   173.    return KDF9.word is
   174.       unrounded, clearing, rounding : CPU.u_64;
   175.    begin
   176.       if amount = 0 then
   177.          return W;
   178.       elsif amount > 46 then
   179.          -- Rounding a negative number shifted 47 or more places converts -1 to 0.
   180.          return 0;
   181.       else
   182.          -- It is undefined whether the intrinsic shift_right_arithmetic,
   183.          --    operating on CPU.u_64, yields a rounded result.
   184.          -- So, any rounding it might do is suppressed,
   185.          --    and correct rounding is explicitly computed.
   186.          unrounded := shift_right_arithmetic(shift_left(CPU.u_64(W),16), 16);
   187.          rounding  := shift_right(unrounded, amount-1) and 1;
   188.          clearing  := - shift_left(1, amount);
   189.          unrounded := unrounded and clearing;
   190.          return as_word(shift_right_arithmetic(unrounded, amount) + rounding);
   191.       end if;
   192.    end scale_down_and_round;
   193.
   194.    function scale_up (W : KDF9.word; amount : Natural)
   195.    return KDF9.word is
   196.       M : constant Natural := Natural'Min(amount, 47);
   197.    begin
   198.       if resign(W) < 0 then
   199.          if scale_down(W, 47-M) /= all_one_bits or
   200.                resign(shift_word_left(W, M)) >= 0 then
   201.             -- See EE Report K/GD.y.80.,  1.1.
   202.             the_V_bit_is_set := True;
   203.          end if;
   204.          return shift_word_left(W, M);
   205.       else
   206.          if shift_word_right(W, 47-M) /= KDF9.word'(all_zero_bits) or
   207.                resign(shift_word_left(W, M)) < 0 then
   208.             -- See EE Report K/GD.y.80.,  1.1.
   209.             the_V_bit_is_set := True;
   210.          end if;
   211.          return shift_word_left(W, M);
   212.       end if;
   213.    end scale_up;
   214.
   215.    function shift_arithmetic (I : KDF9.word; L : CPU.signed_Q_part)
   216.    return KDF9.word is
   217.    begin
   218.    return (
   219.        if L < 0 then scale_down_and_round(I, Natural(-L))
   220.        else          scale_up(I, Natural(L))
   221.       );
   222.    end shift_arithmetic;
   223.
   224.    function scale_up (P : KDF9.pair; L : Natural)
   225.    return KDF9.pair is
   226.       result    : KDF9.pair;
   227.       crossover : KDF9.word;
   228.    begin
   229.       -- The logic here conforms to 3.2 of EE Report K/GD.y.80.
   230.       -- D0 of P.lsw is effectively ignored.
   231.       if L < 48 then
   232.          result.lsw := shift_word_left(P.lsw, L) and KDF9.not_sign_bit;
   233.          crossover  := shift_word_right(P.lsw and KDF9.not_sign_bit, 47-L);
   234.          result.msw := scale_up(P.msw, L) or crossover;
   235.       else
   236.          result.lsw := 0;
   237.          result.msw := (P.msw and KDF9.sign_bit) or (P.lsw and KDF9.not_sign_bit);
   238.          result.msw := scale_up(result.msw, Natural'Min(L, 94)-47);
   239.      end if;
   240.       return result;
   241.    end scale_up;
   242.
   243.    function scale_down (P : KDF9.pair; L : Natural)
   244.    return KDF9.pair is
   245.       result    : KDF9.pair;
   246.       crossover : KDF9.word;
   247.    begin
   248.       -- The logic here conforms to 3.2 of EE Report K/GD.y.80.
   249.       -- D0 of P.lsw is effectively ignored.
   250.       -- SHAD-n does NOT round, according to the Manual.
   251.       if L < 48 then
   252.          result.msw := scale_down(P.msw, L);
   253.          crossover  := shift_word_left(P.msw, 47-L) and KDF9.not_sign_bit;
   254.          result.lsw := shift_word_right(P.lsw and KDF9.not_sign_bit, L) or crossover;
   255.       else
   256.          result.msw := scale_down(P.msw, 47);
   257.          result.lsw := shift_word_right(P.msw, Natural'Min(L, +94)-47) and KDF9.not_sign_bit;
   258.       end if;
   259.       return result;
   260.    end scale_down;
   261.
   262.    function shift_arithmetic (P : KDF9.pair; L : CPU.signed_Q_part)
   263.    return KDF9.pair
   264.    is (
   265.        if    L < 0 then scale_down(P, Natural(-L))
   266.        elsif L > 0 then scale_up(P, Natural(L))
   267.        else             P -- See 1.1 of EE Report K/GD.y.80: this avoids clearing D0 of P.lsw.
   268.       );
   269.
   270.    -- Count the leading zeros of the absolute value of y, omitting the sign bit.
   271.    -- If y is 0, return 47.
   272.    function nr_leading_zeros (y : KDF9.word)
   273.    return Natural is
   274.       x : CPU.u_64;
   275.       r : Natural;
   276.    begin
   277.       if y = 0 then return 47; end if;
   278.       if resign(y) < 0 then
   279.          x := CPU.u_64(16#FFFF_FFFF_FFFF# and not y);
   280.       else
   281.          x := CPU.u_64(y);
   282.       end if;
   283.       -- Only 48 bits of x need be tested.
   284.       if (x and 16#FFFF_0000_0000#) /= 0 then
   285.          r := 32; x := shift_right(x, 32);
   286.       elsif (x and 16#FFFF_0000#) /= 0 then
   287.          r := 16; x := shift_right(x, 16);
   288.       else
   289.          r := 0;
   290.       end if;
   291.       if (x and 16#FF00#) /= 0 then
   292.          r := r + 8; x := shift_right(x, 8);
   293.       end if;
   294.       if (x and 16#F0#) /= 0 then
   295.          r := r + 4; x := shift_right(x, 4);
   296.       end if;
   297.       if (x and 16#C#) /= 0 then
   298.          r := r + 2; x := shift_right(x, 2);
   299.       end if;
   300.       if (x and 16#2#) /= 0 then
   301.          r := r + 1;
   302.       end if;
   303.       r := 47 - r - 1;  -- -1 discounts the sign bit.
   304.       return r;
   305.    end nr_leading_zeros;
   306.
   307.    procedure normalize (fraction, exponent : in out KDF9.word) is
   308.       sign_flag  : constant KDF9.word := shift_word_right(fraction and sign_bit, 1);
   309.       normalizer : Natural;
   310.    begin
   311.       if fraction = 0 then
   312.          exponent := 2#10_000_000#;  -- This yields 0 when biased positive.
   313.          return;
   314.       end if;
   315.
   316.       normalizer := nr_leading_zeros(fraction);
   317.       exponent := exponent - KDF9.word(normalizer);
   318.
   319.       -- shift_word_left is used, not _arithmetic, as D[1..normalizer] = D0
   320.       fraction := shift_word_left(fraction, normalizer);
   321.
   322.       the_CPU_delta := the_CPU_delta + normalize_time(normalizer);
   323.
   324.       -- scale_down_and_round may round up and overflow the fraction bits ...
   325.       fraction := scale_down_and_round(fraction, 8);
   326.       if (fraction and overflow_mask) /= shift_word_right(sign_flag, 7) then
   327.           -- ... so re-normalize; scale_down cannot round here.
   328.          fraction := scale_down(fraction, 1);
   329.          the_CPU_delta := the_CPU_delta + normalize_time(1);
   330.          exponent := exponent + 1;
   331.          the_CPU_delta := the_CPU_delta + 1;
   332.       end if;
   333.       fraction := fraction and mantissa_mask;
   334.
   335.       if resign(exponent) < -128 then
   336.          -- Deal with underflow.
   337.          fraction := 0;
   338.          exponent := 2#10_000_000#;  -- This yields 0 when biased positive.
   339.       elsif resign(exponent) > +127 then
   340.          -- Deal with overflow.
   341.          the_V_bit_is_set := True;
   342.          exponent := 2#01_111_111#;
   343.       end if;
   344.    end normalize;
   345.
   346.    function fraction_word (mantissa : CPU.f48)
   347.    return KDF9.word
   348.     -- shift_word_left must be used instead of scale_up to avoid a spurious overflow.
   349.    is (
   350.        (shift_word_left(as_word(mantissa), 8) and KDF9.not_sign_bit)
   351.           or
   352.        (as_word(mantissa) and sign_bit)
   353.       );
   354.
   355.    function masked_mantissa (F : CPU.f48)
   356.    return CPU.f48
   357.    is (as_f48(as_word(F) and mantissa_mask));
   358.
   359.    function scaler (F : CPU.f48)
   360.    return KDF9.word
   361.    is ((shift_word_right(as_word(F), 39) and 2#11_111_111#) - 128);
   362.
   363.    function normalized (full_fraction, scaler : KDF9.word)
   364.    return CPU.f48 is
   365.       E : KDF9.word := scaler;
   366.       F : KDF9.word := full_fraction;
   367.    begin
   368.       normalize(fraction => F, exponent => E);
   369.       return CPU.f48(shift_word_left((E + 128) and 2#11_111_111#, 39) or F);
   370.    end normalized;
   371.
   372.    function normalized  (R : CPU.f48)
   373.    return CPU.f48
   374.    is (normalized(full_fraction => fraction_word(R), scaler => scaler(R)));
   375.
   376.    function "-" (I : CPU.signed)
   377.    return KDF9.word
   378.    is (as_word(-CPU.s_64(I)));
   379.
   380.    function "abs" (I : CPU.signed)
   381.    return KDF9.word
   382.    is (as_word(abs CPU.s_64(I)));
   383.
   384.    function "+" (L, R : CPU.signed)
   385.    return KDF9.word
   386.    is (as_word(CPU.s_64(L) + CPU.s_64(R)));
   387.
   388.    function "-" (L, R : CPU.signed)
   389.    return KDF9.word
   390.    is (as_word(CPU.s_64(L) - CPU.s_64(R)));
   391.
   392.    function "*" (L, R : CPU.signed)
   393.    return KDF9.word
   394.    is (contracted(KDF9.pair'(unsign(L) * unsign(R))));
   395.
   396.    procedure do_DIVI (
   397.                       L         : in KDF9.word;
   398.                       R         : in KDF9.word;
   399.                       Quotient,
   400.                       Remainder : out KDF9.word
   401.                      ) is
   402.    begin
   403.       if R /= 0 then
   404.          Remainder := as_word(CPU.s_64(resign(L)) mod CPU.s_64(resign(R)));
   405.          Quotient  :=
   406.             as_word((CPU.s_64(resign(L)) - CPU.s_64(resign(Remainder))) / CPU.s_64(resign(R)));
   407.       else
   408.          the_V_bit_is_set := True;
   409.          Quotient  := L;  -- ??
   410.          Remainder := R;  -- ??
   411.       end if;
   412.    end do_DIVI;
   413.
   414.    function "*" (L, R : KDF9.word)
   415.    return CPU.fraction is
   416.    begin
   417.       if L = sign_bit and R = sign_bit then
   418.          the_V_bit_is_set := True;
   419.          return as_fraction(sign_bit);  -- The only case is L = R = -1.0 = L*R.
   420.       else
   421.          return as_fraction(L) * as_fraction(R);
   422.       end if;
   423.    end "*";
   424.
   425.    function "/" (L, R : KDF9.word)
   426.    return CPU.fraction is
   427.    begin
   428.       if R = 0 or L = sign_bit then
   429.          the_V_bit_is_set := True;
   430.          return as_fraction(L); -- ??
   431.       elsif R = sign_bit then
   432.          return -as_fraction(L);
   433.       elsif abs as_fraction(L) < abs as_fraction(R) then  -- abs is safe now.
   434.          return as_fraction(L) / as_fraction(R);
   435.       else
   436.          the_V_bit_is_set := True;
   437.          return as_fraction(L); -- ??
   438.       end if;
   439.    end "/";
   440.
   441.    function "+" (L, R : KDF9.pair)
   442.    return KDF9.pair is
   443.       carry, sum : CPU.s_64;
   444.       result     : KDF9.pair;
   445.    begin
   446.       sum := CPU.s_64(L.lsw and KDF9.not_sign_bit) + CPU.s_64(R.lsw and KDF9.not_sign_bit);
   447.       if unsign(sum) > KDF9.max_word then -- carry into msw
   448.          carry := 1;
   449.          result.lsw := KDF9.word(unsign(sum) and KDF9.not_sign_bit);
   450.       else
   451.          carry := 0;
   452.          result.lsw := KDF9.word(sum);
   453.       end if;
   454.       sum := CPU.s_64(resign(L.msw)) + CPU.s_64(resign(R.msw)) + carry;
   455.       result.msw := as_word(sum);
   456.       return result;
   457.    end "+";
   458.
   459.    function "-" (J : KDF9.pair)
   460.    return KDF9.pair is
   461.       borrow,
   462.       negative : CPU.s_64;
   463.       result   : KDF9.pair;
   464.    begin
   465.       negative := - CPU.s_64(J.lsw and KDF9.not_sign_bit);
   466.       if unsign(negative) > KDF9.max_word then -- borrow from msw
   467.          borrow := 1;
   468.          result.lsw := KDF9.word(unsign(negative) and KDF9.not_sign_bit);
   469.       else
   470.          borrow := 0;
   471.          result.lsw := KDF9.word(negative);
   472.       end if;
   473.       negative := - CPU.s_64(resign(J.msw)) - borrow;
   474.       result.msw := as_word(negative);
   475.       return result;
   476.    end "-";
   477.
   478.    function "-" (L, R : KDF9.pair)
   479.    return KDF9.pair is
   480.       borrow,
   481.       difference : CPU.s_64;
   482.       result     : KDF9.pair;
   483.    begin
   484.       difference := CPU.s_64(L.lsw and KDF9.not_sign_bit) - CPU.s_64(R.lsw and KDF9.not_sign_bit);
   485.       if unsign(difference) > KDF9.max_word then -- borrow from msw
   486.          borrow := 1;
   487.          result.lsw := KDF9.word(unsign(difference) and KDF9.not_sign_bit);
   488.       else
   489.          borrow := 0;
   490.          result.lsw := KDF9.word(difference);
   491.       end if;
   492.       difference := CPU.s_64(resign(L.msw)) - CPU.s_64(resign(R.msw)) - borrow;
   493.       result.msw := as_word(difference);
   494.       return result;
   495.    end "-";
   496.
   497.    function "*" (L, R : KDF9.word)
   498.    return KDF9.pair is
   499.       S, T, U, V, W : KDF9.word;
   500.       H, M, B       : KDF9.pair;
   501.    begin
   502.       if L = sign_bit then
   503.          if R = L then
   504.             -- L*R = (+1.0), which is not a valid fraction, so deal with overflow.
   505.             the_V_bit_is_set := True;
   506.             return (L, 0);
   507.          else
   508.             -- L*R = -R.
   509.             return -(R, 0);
   510.          end if;
   511.       end if;
   512.       if R = sign_bit then
   513.          -- L*R = -L.
   514.          return -(L, 0);
   515.       end if;
   516.       -- Now it is safe to take absolute values, as they cannot overflow.
   517.       S := scale_down(abs resign(L), 24);
   518.       T := abs resign(L) and halfword_mask;
   519.       U := scale_down(abs resign(R), 24);
   520.       V := abs resign(R) and halfword_mask;
   521.       H := ((S*U)*2, 0);
   522.       M := scale_down((KDF9.word'(S*V), 0), 1) + scale_down((KDF9.word'(T*U), 0), 1);
   523.       M := scale_down(M, 22);
   524.       W := rotate_word_left(KDF9.word'(T*V), 1);
   525.       B := (W and 1, shift_word_right(W, 1));
   526.       if resign(L xor R) < 0 then
   527.          return - (H + M + B);
   528.       else
   529.          return    H + M + B;
   530.       end if;
   531.    end "*";
   532.
   533.    f_64_small : constant := 2.0**(-63);
   534.    type f_64 is delta f_64_small range -1.0 .. +1.0 - f_64_small with Size => 64;
   535.
   536.    function scale_down (f : CPU.f_64; N : Natural)
   537.    return f_64
   538.    is (if N > 62 then 0.0 else f / 2**N);
   539.
   540.    function to_f_64 (w : KDF9.word)
   541.    return CPU.f_64
   542.    is (CPU.f_64(as_fraction(w)));
   543.
   544.    function to_word (f : CPU.f_64)
   545.    return KDF9.word
   546.    is (as_word(CPU.fraction(f)));
   547.
   548.    procedure long_division (
   549.                             L : in KDF9.pair;
   550.                             R : in KDF9.word; -- All callers must ensure that R /= 0.
   551.                             Q : out KDF9.word
   552.                            ) is
   553.       N  : KDF9.pair := L;
   554.       D  : KDF9.word;
   555.       Ls,
   556.       Rs,
   557.       Qs : CPU.f_64;
   558.       normalizer_N : Natural;
   559.       normalizer_R : Natural;
   560.       normalizer_Q : Integer;
   561.    begin
   562.       -- Normalize the dividend.
   563.       normalizer_N := nr_leading_zeros(N.msw);
   564.       if normalizer_N < 47 then
   565.          -- N.msw contains significant bits.
   566.          N := scale_up(N, normalizer_N);
   567.       else
   568.          -- All of the significant bits are in N.lsw, which is non-zero.
   569.          N := scale_up(N, 47);
   570.          normalizer_N := nr_leading_zeros(N.msw);
   571.          N := scale_up(N, normalizer_N);
   572.          normalizer_N := normalizer_N + 47;
   573.       end if;
   574.
   575.       -- Normalize the divisor.  All callers must ensure that R /= 0.
   576.       normalizer_R := nr_leading_zeros(R);
   577.       D := scale_up(R, normalizer_R);
   578.
   579.       -- Scale Ls and Rs so that the Ada fractional division cannot overflow.
   580.       Ls := scale_down(to_f_64(N.msw), 2);
   581.       Rs := scale_down(to_f_64(D), 1);
   582.
   583.       Qs := Ls / Rs;  -- Ada fractional division rounds, correctly for KDF9 DIV and DIVD.
   584.
   585.       -- Rescale the quotient.
   586.       normalizer_Q := 1 + normalizer_R - normalizer_N;
   587.       if normalizer_Q <= 0 then
   588.          -- Overflow is impossible.
   589.          Qs := scale_down(Qs, -normalizer_Q);
   590.          Q := to_word(Qs);
   591.       else
   592.          -- If Qs >= 0.5, then L/R >= 1.0 is not a representable result fraction.
   593.          -- If Qs < -0.5, then L/R < -1.0 is not a representable result fraction.
   594.          the_V_bit_is_set := Qs >= 0.5 or Qs < -0.5;
   595.          Q := scale_up(to_word(Qs), normalizer_Q);  -- A guess at the result for overflow ?? !!
   596.       end if;
   597.    end long_division;
   598.
   599.    procedure do_DIVD (
   600.                       L : in KDF9.pair;
   601.                       R : in KDF9.word;
   602.                       Q : out KDF9.word
   603.                      ) is
   604.       N : KDF9.pair;
   605.    begin
   606.       N.msw := L.msw;
   607.       -- Ignore an invalid D0 in the lsw of the dividend.
   608.       N.lsw := L.lsw and KDF9.not_sign_bit;
   609.
   610.       -- Deal quickly with a zero dividend, giving a zero result.
   611.       if (N.msw or N.lsw) = 0 then
   612.          Q := 0;
   613.          return;
   614.       end if;
   615.
   616.       -- Deal with division by 0.
   617.       if R = 0 then
   618.          the_V_bit_is_set := True;
   619.          Q := N.msw;  -- A guess at the result for division by zero ?? !!
   620.          return;
   621.       end if;
   622.
   623.       long_division(N, R, Q);
   624.    end do_DIVD;
   625.
   626.    procedure do_DIVR (
   627.                       L         : in KDF9.pair;
   628.                       R         : in KDF9.word;
   629.                       Quotient,
   630.                       Remainder : out KDF9.word
   631.                      ) is
   632.       N  : KDF9.pair := L;
   633.       D  : KDF9.word := R;
   634.       S  : Integer   := 1;
   635.       T  : KDF9.pair;
   636.    begin
   637.       -- Ignore an invalid D0 in the lsw of the dividend.
   638.       N.lsw := N.lsw and KDF9.not_sign_bit;
   639.
   640.       -- Deal quickly with a zero dividend, giving a zero result.
   641.       if (N.msw or N.lsw) = 0 then
   642.          Quotient  := 0;
   643.          Remainder := 0;
   644.          return;
   645.       end if;
   646.
   647.       -- Deal with division by 0.
   648.       if R = 0 then
   649.          the_V_bit_is_set := True;
   650.          -- A guess at the results for division by zero ?? !!
   651.          Quotient  := N.msw;
   652.          Remainder := 0;
   653.          return;
   654.       end if;
   655.
   656.       -- Convert to an unsigned division problem, and note whether it needs to be be converted back.
   657.       if resign(N.msw) < 0 then
   658.          N := - N;
   659.          S := - S;
   660.       end if;
   661.       if resign(R) < 0 then
   662.          D := - D;
   663.          S := - S;
   664.       end if;
   665.
   666.       -- Check for inevitable overflow, and deal with it separately.
   667.       if N.msw > D then
   668.          the_V_bit_is_set := True;
   669.          -- A guess at the results for overflow ?? !!
   670.          Quotient := (if S < 0 then -(N.msw / D) else N.msw / D);
   671.          T := L - (msw => Quotient*R, lsw => 0);
   672.          Remainder := T.msw;
   673.          return;
   674.       end if;
   675.
   676.       -- Overflow is now impossible, but the result may be rounded.
   677.       long_division(N, D, Quotient);
   678.
   679.       -- Undo any rounding effected by do_DIVD.
   680.       loop
   681.          T := N - Quotient * D;
   682.       exit when T.msw = 0;
   683.          Quotient := Quotient + 1;
   684.       end loop;
   685.       Quotient  := Quotient + T.lsw / D;
   686.
   687.       -- Correct the sign of the quotient and compute the remainder.
   688.       Quotient  := (if S < 0 then -Quotient else Quotient);
   689.       Remainder := contracted(L - Quotient*R);
   690.    end do_DIVR;
   691.
   692.    function host_float (X : CPU.f48)
   693.    return Long_Float is
   694.       -- Warn if Long_Float does not have at least the range of a KDF9 floating point number.
   695.       pragma Compile_Time_Warning(Long_Float'Last < 2.0**127,
   696.                                   "Long_Float does not have enough range for KDF9 f.p.");
   697.       -- Warn if Long_Float does not have at least the precision of a KDF9 floating point number.
   698.       pragma Compile_Time_Warning(Long_Float'Small > 1.0/2.0**39,
   699.                                   "Long_Float does not have enough precision for KDF9 f.p.");
   700.       W : constant KDF9.word  := fraction_word(masked_mantissa(X));
   701.       S : constant Long_Float := 2.0**Integer(resign(scaler(X)));
   702.    begin
   703.       return Long_Float(as_fraction(W)) * S;  -- Cannot overflow if warnings are absent.
   704.    end host_float;
   705.
   706.    -- Round a 48-bit floating-point number to 24-bit format.
   707.    function narrowed (R : CPU.f48)
   708.    return CPU.f48
   709.    is (normalized(fraction_word(R) + 2**23, scaler(R)));
   710.
   711.    overriding
   712.    function "-" (R : CPU.f48)
   713.    return CPU.f48 is
   714.       -- F is made half of a true fraction to prevent overflow when negating:
   715.       --    the result exponent is offset by 1, accordingly.
   716.       E : constant KDF9.word := scaler(R) + 1;
   717.       F : KDF9.word := scale_down_and_round(fraction_word(R), 1);
   718.    begin
   719.       F := as_word(CPU.u_64(-F));  -- "-" cannot overflow here.
   720.       return normalized(full_fraction => F, scaler => E);
   721.    end "-";
   722.
   723.    overriding
   724.    function "abs" (R : CPU.f48)
   725.    return CPU.f48
   726.    is (if resign(KDF9.word(R)) < 0 then - R else + R);
   727.
   728.    overriding
   729.    function "+" (L, R : CPU.f48)
   730.    return CPU.f48 is
   731.       -- B and D are made half of a true fraction to prevent overflow when
   732.       --    adding; the result exponent is offset by 1, accordingly.
   733.       A : constant KDF9.word := scaler(R);
   734.       B : KDF9.word := scale_down(fraction_word(R), 1);
   735.       C : constant KDF9.word := scaler(L);
   736.       D : KDF9.word := scale_down(fraction_word(L), 1);
   737.       E : KDF9.word;
   738.       F : KDF9.word;
   739.       N : Natural;
   740.    begin
   741.       if resign(A) >= resign(C) then
   742.          N := Natural'Min(Natural(resign(A-C)), 48);
   743.          D := scale_down_and_round(D, N);
   744.          E := A + 1;
   745.       else
   746.          N := Natural'Min(Natural(resign(C-A)), 48);
   747.          B := scale_down_and_round(B, N);
   748.          E := C + 1;
   749.       end if;
   750.       the_CPU_delta := the_CPU_delta + shift_time(N);
   751.       F := as_word(CPU.u_64(D + B));  -- "+" cannot overflow here.
   752.       return normalized(full_fraction => F, scaler => E);
   753.    end "+";
   754.
   755.    overriding
   756.    function "-" (L, R : CPU.f48)
   757.    return CPU.f48 is
   758.       -- See "+".
   759.       A : constant KDF9.word := scaler(R);
   760.       B : KDF9.word := scale_down(fraction_word(R), 1);
   761.       C : constant KDF9.word := scaler(L);
   762.       D : KDF9.word := scale_down(fraction_word(L), 1);
   763.       E : KDF9.word;
   764.       F : KDF9.word;
   765.       N : Natural;
   766.    begin
   767.       if resign(A) >= resign(C) then
   768.          N := Natural'Min(Natural(resign(A-C)), 48);
   769.          D := scale_down_and_round(D, N);
   770.          E := A + 1;
   771.       else
   772.          N := Natural'Min(Natural(resign(C-A)), 48);
   773.          B := scale_down_and_round(B, N);
   774.          E := C + 1;
   775.       end if;
   776.       the_CPU_delta := the_CPU_delta + shift_time(N);
   777.       F := as_word(CPU.u_64(D - B));  -- "-" cannot overflow here.
   778.       return normalized(full_fraction => F, scaler => E);
   779.    end "-";
   780.
   781.    overriding
   782.    function "*" (L, R : CPU.f48)
   783.    return CPU.f48 is
   784.       B, D, E, F : KDF9.word;
   785.    begin
   786.       if (KDF9.word(L) or KDF9.word(R)) = 0 then
   787.          return 0;
   788.       end if;
   789.       B := fraction_word(R);
   790.       D := fraction_word(L);
   791.       E := scaler(L) + scaler(R);
   792.       if (B = sign_bit) and (B = D) then
   793.           -- D*B = (+1), which is not a valid fraction, so treat specially.
   794.           B := B / 2;
   795.           D := D / 2;
   796.           E := E + 2;
   797.        end if;
   798.       F := as_word(as_fraction(D) * as_fraction(B));  -- "*" cannot overflow here.
   799.       return normalized(full_fraction => F, scaler => E);
   800.    end "*";
   801.
   802.    overriding
   803.    function "/" (L, R : CPU.f48)
   804.    return CPU.f48 is
   805.       D, N   : CPU.fraction;
   806.       Ln, Rn : CPU.f48;
   807.       Ls, Rs : KDF9.word;
   808.       E, F   : KDF9.word;
   809.    begin
   810.       Ln := normalized(L);
   811.       Rn := normalized(R);
   812.       if Rn = 0 then
   813.          the_V_bit_is_set := True;
   814.          return Ln;  -- ?? This result is not well defined in the Manual.
   815.       end if;
   816.       -- If Ln >= Rn then Ln/Rn >= 1, which is not a valid fraction;
   817.       --    so Ls and Rs are scaled to ensure that the division cannot overflow.
   818.       Ls := scale_down(fraction_word(Ln), 2);
   819.       Rs := scale_down(fraction_word(Rn), 1);
   820.       -- E is increased by 1 to compensate the quotient's scaling by 1/2.
   821.       E := scaler(Ln) - scaler(Rn) + 1;
   822.       N := abs as_fraction(Ls);  -- Ls was scaled down by 1/4, so "abs" cannot overflow.
   823.       D := abs as_fraction(Rs);  -- Rs was scaled down by 1/2, so "abs" cannot overflow.
   824.       if N = D then
   825.          -- Avoid the one remaining overflow case by further rescaling.
   826.          F := as_word(N / 2 / D);
   827.          E := E + 1;
   828.       else
   829.          F := as_word(N / D);
   830.       end if;
   831.       if resign(KDF9.word(L) xor KDF9.word(R)) < 0 then
   832.          -- The result is negative.
   833.          F := -F;
   834.       end if;
   835.       return normalized(full_fraction => F, scaler => E);
   836.    end "/";
   837.
   838.    overriding
   839.    function "<" (L, R : CPU.f48)
   840.    return Boolean is
   841.       s : constant KDF9.word := KDF9.word(L) xor KDF9.word(R);
   842.    begin
   843.       if resign(s) < 0 then
   844.          -- The signs differ: L<R iff L is negative.
   845.          return resign(KDF9.word(L)) < 0;
   846.       elsif resign(KDF9.word(L)) < 0 then
   847.          -- L and R are both negative, so invert lexicographical order.
   848.          return not (KDF9.word(L) < KDF9.word(R));
   849.       else
   850.          -- L and R are both non-negative: so use lexicographical order.
   851.          return KDF9.word(L) < KDF9.word(R);
   852.       end if;
   853.    end "<";
   854.
   855.    function fraction_pair (DF : CPU.f96)
   856.    return KDF9.pair is
   857.       P : KDF9.pair;
   858.    begin
   859.       P.msw := scale_down(fraction_word(DF.msw), 8);
   860.       P.lsw := fraction_word(DF.lsw) and KDF9.not_sign_bit;
   861.       return scale_up(P, 8);
   862.    end fraction_pair;
   863.
   864.    function scaler (DF : CPU.f96)
   865.    return KDF9.word
   866.    is (scaler(DF.msw));
   867.
   868.    function narrowed (DF : CPU.f96)
   869.    return CPU.f48 is
   870.       fraction : KDF9.pair := fraction_pair(DF) + (0, 2**46);
   871.    begin
   872.       reconstruct(fraction, scaler(DF));
   873.       return CPU.f48(fraction.msw);
   874.    end narrowed;
   875.
   876.    procedure reconstruct (frac   : in out KDF9.pair;
   877.                           scaler : in KDF9.word) is
   878.       KDF9_exponent :  KDF9.word := scaler + 128;
   879.       normalizer    : Natural;
   880.    begin
   881.       if (frac.msw or frac.lsw) = 0 then
   882.          return; -- frac is already normalized.
   883.       end if;
   884.
   885.       normalizer := nr_leading_zeros(frac.msw);
   886.
   887.       if normalizer = 47 then  -- frac.msw is zero, so frac.lsw is non-zero.
   888.          normalizer := 47 + nr_leading_zeros(frac.lsw);
   889.       end if;
   890.
   891.       KDF9_exponent := KDF9_exponent - KDF9.word(normalizer);
   892.
   893.       frac := scale_up(frac, normalizer);
   894.       the_CPU_delta := the_CPU_delta + shift_time(normalizer);
   895.
   896.       -- 96-bit shift_arithmetic does not round and so cannot overflow here.
   897.       frac := scale_down(frac, 8);
   898.       frac.lsw := scale_down(frac.lsw, 8);
   899.       -- Clear both scaler fields.
   900.       frac.msw := frac.msw and mantissa_mask;
   901.       frac.lsw := frac.lsw and mantissa_mask;
   902.       if resign(KDF9_exponent) < 0 then
   903.          -- Deal with underflow.
   904.          frac := (0, 0);
   905.          return;
   906.       elsif KDF9_exponent > 255 then
   907.          -- Deal with overflow.
   908.          the_V_bit_is_set := True;
   909.          KDF9_exponent := 255;
   910.       end if;
   911.
   912.       frac.msw := frac.msw or shift_word_left(KDF9_exponent and 8#377#, 39);
   913.       if KDF9_exponent < 39 then
   914.          frac.lsw := 0;
   915.       else
   916.          frac.lsw := frac.lsw or shift_word_left((KDF9_exponent-39) and 8#377#, 39);
   917.       end if;
   918.    end reconstruct;
   919.
   920.    function "-" (R : CPU.f96)
   921.    return CPU.f96
   922.    is (CPU.f96'(0, 0) - R);
   923.
   924.    function "+" (L, R : CPU.f96)
   925.    return CPU.f96 is
   926.       -- Scale fractions to prevent overflow; must adjust exponent accordingly.
   927.       L_exponent : constant KDF9.word := scaler(L);
   928.       R_exponent : constant KDF9.word := scaler(R);
   929.       L_fraction : KDF9.pair := scale_down(fraction_pair(L), 1);
   930.       R_fraction : KDF9.pair := scale_down(fraction_pair(R), 1);
   931.       exponent   : KDF9.word;
   932.       the_result : KDF9.pair;
   933.       aligner    : Natural;
   934.    begin
   935.       if resign(R_exponent) >= resign(L_exponent) then
   936.          aligner := Natural(resign(R_exponent-L_exponent));
   937.          aligner := Natural'Min(95, aligner);
   938.          L_fraction := scale_down(L_fraction, aligner);
   939.          exponent := R_exponent + 1;
   940.       else
   941.          aligner := Natural(resign(L_exponent-R_exponent));
   942.          aligner := Natural'Min(95, aligner);
   943.          R_fraction := scale_down(R_fraction, aligner);
   944.          exponent := L_exponent + 1;
   945.       end if;
   946.       the_CPU_delta := the_CPU_delta + shift_time(aligner);
   947.       the_result := L_fraction + R_fraction;  -- "+" cannot overflow here.
   948.       reconstruct(the_result, scaler => exponent);
   949.       return as_f96(the_result);
   950.    end "+";
   951.
   952.    function "-" (L, R : CPU.f96)
   953.    return CPU.f96 is
   954.       -- See "+".
   955.       L_exponent : constant KDF9.word := scaler(L);
   956.       R_exponent : constant KDF9.word := scaler(R);
   957.       L_fraction : KDF9.pair := scale_down(fraction_pair(L), 1);
   958.       R_fraction : KDF9.pair := scale_down(fraction_pair(R), 1);
   959.       exponent   : KDF9.word;
   960.       the_result : KDF9.pair;
   961.       aligner    : Natural;
   962.    begin
   963.       if resign(R_exponent) >= resign(L_exponent) then
   964.          aligner := Natural(resign(R_exponent-L_exponent));
   965.          aligner := Natural'Min(95, aligner);
   966.          L_fraction := scale_down(L_fraction, aligner);
   967.          exponent := R_exponent + 1;
   968.       else
   969.          aligner := Natural(resign(L_exponent-R_exponent));
   970.          aligner := Natural'Min(95, aligner);
   971.          R_fraction := scale_down(R_fraction, aligner);
   972.          exponent := L_exponent + 1;
   973.       end if;
   974.       the_CPU_delta := the_CPU_delta + shift_time(aligner);
   975.       the_result := L_fraction - R_fraction;  -- "-" cannot overflow here.
   976.       reconstruct(the_result, scaler => exponent);
   977.       return as_f96(the_result);
   978.    end "-";
   979.
   980.    function "*" (L, R : CPU.f48)
   981.    return CPU.f96 is
   982.       V_was_set : constant Boolean := the_V_bit_is_set;
   983.       LR        : KDF9.pair;
   984.    begin
   985.       the_V_bit_is_set := False;
   986.       LR := fraction_word(L) * fraction_word(R);
   987.       if the_V_bit_is_set then
   988.          -- The product is not a valid fixed-point fraction, but is actually OK,
   989.          --    so restore the orginal overflow state, and  ...
   990.          the_V_bit_is_set := V_was_set;
   991.          --  ... construct +1.0 in double-precision floating-point.
   992.          return as_f96((shift_word_left(2#0_10_000_001_1#, 38), 0));
   993.       end if;
   994.       reconstruct(LR, scaler => scaler(L) + scaler(R));
   995.       return as_f96(LR);
   996.    end "*";
   997.
   998.    function "/" (L : CPU.f96; R : CPU.f48)
   999.    return CPU.f48 is  -- aka DIVDF
  1000.       -- If L>=R, L/R>= 1, which is not a valid fraction; so Ls and Rs are
  1001.       --    scaled so that the division cannot overflow.
  1002.       Ls : constant KDF9.pair := scale_down(fraction_pair(L), 2);
  1003.       Rs : constant KDF9.word := scale_down(fraction_word(R), 1);
  1004.       -- E is increased by 1 to compensate the quotient's scaling by 1/2.
  1005.       E : constant KDF9.word  := scaler(L) - scaler(R) + 1;
  1006.       F : KDF9.word;
  1007.    begin
  1008.       if R = 0 then
  1009.          the_V_bit_is_set := True;
  1010.          return L.msw;  -- ?? This result is not well defined in the Manual.
  1011.       end if;
  1012.       do_DIVD(Ls, Rs, F);
  1013.       return normalized(full_fraction => F, scaler => E);
  1014.    end "/";
  1015.
  1016.    function number_of_1_bits_in (W : KDF9.word)
  1017.    return KDF9.word is
  1018.       u : constant CPU.u_64 := CPU.u_64(W);
  1019.       n :          CPU.u_64 := shift_right(u, 1) and 16#77_77_77_77_77_77_77_77#;
  1020.       x :          CPU.u_64 := u - n;
  1021.    begin
  1022.       n := shift_right(n, 1) and 16#77_77_77_77_77_77_77_77#;
  1023.       x := x - n;
  1024.       n := shift_right(n, 1) and 16#77_77_77_77_77_77_77_77#;
  1025.       x := x - n;
  1026.       x := (x + shift_right(x, 4)) and 16#0F_0F_0F_0F_0F_0F_0F_0F#;
  1027.       x := x * 16#01_01_01_01_01_01_01_01#;
  1028.       return KDF9.word(shift_right(x, CPU.u_64'Size-8));
  1029.    end number_of_1_bits_in;
  1030.
  1031.    procedure push (F : in CPU.f48) is
  1032.    begin
  1033.       push(KDF9.word(F));
  1034.    end push;
  1035.
  1036.    function pop
  1037.    return CPU.f48
  1038.    is (CPU.f48(KDF9.word'(pop)));
  1039.
  1040.    function read_top
  1041.    return CPU.f48
  1042.    is (CPU.f48(KDF9.word'(read_top)));
  1043.
  1044.    procedure write_top (F : in CPU.f48) is
  1045.    begin
  1046.       write_top(KDF9.word(F));
  1047.    end write_top;
  1048.
  1049.    procedure push (DF : in CPU.f96) is
  1050.       AB : constant KDF9.pair := as_pair(DF);
  1051.    begin
  1052.       push(AB);
  1053.    end push;
  1054.
  1055.    function pop
  1056.    return CPU.f96
  1057.    is (as_f96(pop));
  1058.
  1059.    function read_top
  1060.    return CPU.f96
  1061.    is (as_f96(read_top));
  1062.
  1063.    procedure write_top (DF : in CPU.f96) is
  1064.       AB : constant KDF9.pair := as_pair(DF);
  1065.    begin
  1066.       write_top(AB);
  1067.    end write_top;
  1068.
  1069. end KDF9.CPU;

Compiling: ../Source/kdf9-cpu.ads
Source file time stamp: 2022-06-22 20:09:32
Compiled at: 2022-09-15 15:08:02

     1. -- Support for KDF9 CPU/ALU operations that are not automatically inherited from
     2. --   Ada types; and for types used in the internal functioning of the microcode.
     3. --
     4. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. with Ada.Unchecked_Conversion;
    19.
    20. package KDF9.CPU is
    21.
    22. --
    23. --
    24.    --
    25.    -- 48-bit integer and fractional ALU types and operations
    26.    --
    27. --
    28. --
    29.
    30.    type signed is range -2**47 .. +2**47 - 1 with Size => KDF9.word'Size;
    31.
    32.    function unsign is new Ada.Unchecked_Conversion (CPU.signed, KDF9.word);
    33.
    34.    function resign is new Ada.Unchecked_Conversion (KDF9.word, CPU.signed);
    35.
    36.    function "-" (I : CPU.signed)
    37.    return KDF9.word
    38.       with Inline;
    39.
    40.    function "abs" (I : CPU.signed)
    41.    return KDF9.word
    42.       with Inline;
    43.
    44.    function "+" (L, R : CPU.signed)
    45.    return KDF9.word
    46.       with Inline;
    47.
    48.    function "-" (L, R : CPU.signed)
    49.    return KDF9.word
    50.       with Inline;
    51.
    52.    function "*" (L, R : CPU.signed)
    53.    return KDF9.word;
    54.
    55.    -- Determine the Quotient and Remainder of L/R, where:
    56.    --    sign(Remainder) = sign(R) and |Remainder| < |R|, i.e. Remainder = L mod R;
    57.    --    Quotient = (L - Remainder) / R.
    58.
    59.    procedure do_DIVI (
    60.                       L         : in KDF9.word;
    61.                       R         : in KDF9.word;
    62.                       Quotient,
    63.                       Remainder : out KDF9.word
    64.                      );
    65.
    66.    -- Inherited signed single-length integer division is removed from the type.
    67.
    68.    function "/" (L, R : CPU.signed)
    69.    return KDF9.word is abstract;
    70.
    71.    function "mod" (L, R : CPU.signed)
    72.    return KDF9.word is abstract;
    73.
    74.    -- Contract a double-word, setting the V bit if necessary.
    75.
    76.    function contracted (P : KDF9.pair)
    77.    return KDF9.word
    78.       with Inline;
    79.
    80. --
    81. --
    82.    -- Shifting operations with KDF9 semantics.
    83. --
    84. --
    85.
    86.    type signed_Q_part is range  -2**15 .. +2**15 - 1 with Size => KDF9.Q_part'Size;
    87.
    88.    function resign is new Ada.Unchecked_Conversion (KDF9.Q_part, CPU.signed_Q_part);
    89.
    90.    -- L>0 for left-shift, L<0 for right-shift.
    91.
    92.    function shift_logical (W : KDF9.word; L : CPU.signed_Q_part)
    93.    return KDF9.word
    94.       with Inline;
    95.
    96.    function shift_circular (W : KDF9.word; L : CPU.signed_Q_part)
    97.    return KDF9.word
    98.       with Inline;
    99.
   100.    -- shift_arithmetic rounds the result correctly.
   101.    function shift_arithmetic (I : KDF9.word; L : CPU.signed_Q_part)
   102.    return KDF9.word
   103.       with Inline;
   104.
   105.    -- number_of_1_bits_in counts the number of bits in W with value 1.
   106.    function number_of_1_bits_in (W : KDF9.word)
   107.    return KDF9.word
   108.       with Inline;
   109.
   110. --
   111. --
   112.    -- A fraction is a word W interpreted as the value W / 2**47;
   113. --
   114. --
   115.
   116.    KDF9_small : constant := 2.0**(-47);
   117.
   118.    type fraction is delta KDF9_small range -1.0 .. +1.0 - KDF9_small with Size => KDF9.word'Size;
   119.
   120.    function as_fraction is new Ada.Unchecked_Conversion (KDF9.word, CPU.fraction);
   121.
   122.    function as_word     is new Ada.Unchecked_Conversion (CPU.fraction, KDF9.word);
   123.
   124.    -- These operations treat the KDF9.word operands as full-word fractions,
   125.
   126.    function "*" (L, R : KDF9.word)
   127.    return CPU.fraction;
   128.
   129.    function "/" (L, R : KDF9.word)
   130.    return CPU.fraction;
   131.
   132.
   133. --
   134. --
   135.    --
   136.    -- 48-bit integer and fractional ALU operations
   137.    --
   138. --
   139. --
   140.
   141.    function "+" (L, R : KDF9.pair)
   142.    return KDF9.pair
   143.       with Inline;
   144.
   145.    function "-" (J : KDF9.pair)
   146.    return KDF9.pair
   147.       with Inline;
   148.
   149.    function "-" (L, R : KDF9.pair)
   150.    return KDF9.pair
   151.       with Inline;
   152.
   153.    -- 48 * 48 -> 96-bit, for XD, etc.
   154.
   155.    function "*" (L, R : KDF9.word)
   156.    return KDF9.pair;
   157.
   158.    procedure do_DIVD (
   159.                       L : in KDF9.pair;
   160.                       R : in KDF9.word;
   161.                       Q : out KDF9.word
   162.                      );
   163.
   164.    procedure do_DIVR (
   165.                       L         : in KDF9.pair;
   166.                       R         : in KDF9.word;
   167.                       Quotient,
   168.                       Remainder : out KDF9.word
   169.                      );
   170.
   171.    function shift_logical (P : KDF9.pair; L : CPU.signed_Q_part)
   172.    return KDF9.pair
   173.       with Inline;
   174.
   175.    function shift_arithmetic (P : KDF9.pair; L : CPU.signed_Q_part)
   176.    return KDF9.pair
   177.       with Inline;
   178.
   179.
   180. --
   181. --
   182.    --
   183.    -- 48-bit floating point ALU types and operations
   184.    --
   185. --
   186. --
   187.
   188.    -- This is a substrate for KDF9 floating point, not an Ada f.p. type.
   189.
   190.    type f48 is mod 2**48 with Size => KDF9.word'Size;
   191.
   192.    -- Remove useless substrate modular operations not, and, or, xor and mod.
   193.
   194.    overriding
   195.    function "not" (R : CPU.f48)
   196.    return CPU.f48 is abstract;
   197.
   198.    overriding
   199.    function "and" (L, R : CPU.f48)
   200.    return CPU.f48 is abstract;
   201.
   202.    overriding
   203.    function "or" (L, R : CPU.f48)
   204.    return CPU.f48 is abstract;
   205.
   206.    overriding
   207.    function "xor" (L, R : CPU.f48)
   208.    return CPU.f48 is abstract;
   209.
   210.    overriding
   211.    function "mod" (L, R : CPU.f48)
   212.    return CPU.f48 is abstract;
   213.
   214.    function as_word is new Ada.Unchecked_Conversion (CPU.f48, KDF9.word);
   215.
   216.    function as_f48  is new Ada.Unchecked_Conversion (KDF9.word, CPU.f48);
   217.
   218.    procedure push (F : in CPU.f48);
   219.
   220.    function pop
   221.    return CPU.f48
   222.       with Inline;
   223.
   224.    procedure write_top (F : in CPU.f48)
   225.       with Inline;
   226.
   227.    function read_top
   228.    return CPU.f48
   229.       with Inline;
   230.
   231.     -- Standardize a (possibly) non-normalized floating-point number.
   232.
   233.    function normalized  (R : CPU.f48)
   234.    return CPU.f48;
   235.
   236.    -- Convert a 47-bit fraction to a rounded, standardized 39-bit mantissa,
   237.    --    and adjust its exponent accordingly, setting overflow when necessary.
   238.
   239.    procedure normalize (fraction, exponent : in out KDF9.word)
   240.       with Inline;
   241.
   242.    -- Convert a 39-bit mantissa to a 47-bit fraction, preserving the sign.
   243.
   244.    function fraction_word (mantissa : CPU.f48)
   245.    return KDF9.word
   246.       with Inline;
   247.
   248.    -- The floating-point number with the exponent field set to 0.
   249.
   250.    function masked_mantissa (F : CPU.f48)
   251.    return CPU.f48
   252.       with Inline;
   253.
   254.    -- The algebraic scale-factor, not the hardware exponent, -128 <= scaler < +128.
   255.
   256.    function scaler (F : CPU.f48)
   257.    return KDF9.word
   258.       with Inline;
   259.
   260.     -- Synthesize a normalized floating-point number from its components.
   261.
   262.    function normalized (full_fraction, scaler : KDF9.word)
   263.    return CPU.f48
   264.       with Inline;
   265.
   266.    -- Round a 48-bit floating-point number to 24-bit format.
   267.
   268.    function narrowed (R : CPU.f48)
   269.    return CPU.f48;
   270.
   271.    overriding
   272.    function "-" (R : CPU.f48)
   273.    return CPU.f48;
   274.
   275.    overriding
   276.    function "abs" (R : CPU.f48)
   277.    return CPU.f48;
   278.
   279.    overriding
   280.    function "+" (L, R : CPU.f48)
   281.    return CPU.f48;
   282.
   283.    overriding
   284.    function "-" (L, R : CPU.f48)
   285.    return CPU.f48;
   286.
   287.    overriding
   288.    function "*" (L, R : CPU.f48)
   289.    return CPU.f48;
   290.
   291.    overriding
   292.    function "/" (L, R : CPU.f48)
   293.    return CPU.f48;
   294.
   295.    overriding
   296.    function "<" (L, R : CPU.f48)
   297.    return Boolean;
   298.
   299.    function host_float (X : CPU.f48)
   300.    return Long_Float;
   301.
   302.    exponent_mask : constant KDF9.word := KDF9.word'(2#11_111_111#) * 2**39;
   303.    mantissa_mask : constant KDF9.word := not exponent_mask;
   304.    frac_msb_mask : constant KDF9.word := 2**46;  -- M.S.B. of a 47-bit fraction
   305.    mant_msb_mask : constant KDF9.word := 2**38;  -- M.S.B. of a 39-bit mantissa
   306.    overflow_mask : constant KDF9.word := 2**39;  -- bit set on rounding overflow
   307.
   308.
   309. --
   310. --
   311.    --
   312.    -- 96-bit floating point ALU types and operations
   313.    --
   314. --
   315. --
   316.
   317.    type f96 is
   318.       record
   319.          msw, lsw : CPU.f48;
   320.       end record;
   321.
   322.    function as_pair is new Ada.Unchecked_Conversion (CPU.f96, KDF9.pair);
   323.
   324.    function as_f96  is new Ada.Unchecked_Conversion (KDF9.pair, CPU.f96);
   325.
   326.    procedure push (DF : in CPU.f96)
   327.       with Inline,
   328.            Pre => the_NEST_depth < 15
   329.                or else the_CPU_state = Director_state;
   330.
   331.    function pop
   332.    return CPU.f96
   333.       with Inline;
   334.
   335.    procedure write_top (DF : in CPU.f96)
   336.       with Inline;
   337.
   338.    function read_top
   339.    return CPU.f96
   340.       with Inline;
   341.
   342.    -- The algebraic scale-factor, not the hardware exponent, -128 <= scaler < +128.
   343.
   344.    function scaler (DF : CPU.f96)
   345.    return KDF9.word
   346.       with Inline;
   347.
   348.    -- Round a 96-bit double-precision floating-point number to 48 bit format.
   349.
   350.    function narrowed (DF : CPU.f96)
   351.    return CPU.f48
   352.       with Inline;
   353.
   354.    -- Derive a 96-bit fraction from the double-precision floating-point number,
   355.    --    with the mantissa bits in D9-D47 and D49-D87,
   356.    --       and with D1-D8 copies of the sign, D48 zero, and D87-D95 zero.
   357.
   358.    function fraction_pair (DF : CPU.f96)
   359.    return KDF9.pair
   360.       with Inline;
   361.
   362.    -- Convert 96-bit fraction, and an algebraic scale-factor exponent,
   363.    --    into a 96-bit floating point number, setting overflow when necessary.
   364.
   365.    procedure reconstruct (frac   : in out KDF9.pair;
   366.                           scaler : in KDF9.word);
   367.
   368.    function "-" (R : CPU.f96)
   369.    return CPU.f96;
   370.
   371.    function "+" (L, R : CPU.f96)
   372.    return CPU.f96;
   373.
   374.    function "-" (L, R : CPU.f96)
   375.    return CPU.f96;
   376.
   377.    function "*" (L, R : CPU.f48)
   378.    return CPU.f96;
   379.
   380.    function "/" (L : CPU.f96;
   381.                  R : CPU.f48)
   382.    return CPU.f48;
   383.
   384. ------------------------------------------------------------------------------------------------
   385.
   386. --
   387. --
   388.    --
   389.    -- These are the emulation host's register types and their operations.
   390.    --
   391. --
   392. --
   393.
   394.    type u_64 is mod 2**64 with Size => 64;
   395.
   396.    pragma Provide_Shift_Operators (u_64);
   397.
   398.    function as_word (u : CPU.u_64)
   399.    return KDF9.word
   400.       with Inline;
   401.
   402.    type s_64 is range -2**63 .. +2**63-1 with Size => 64;
   403.
   404.    -- The signed as_word sets the V bit if necessary.
   405.
   406.    function as_word (s : CPU.s_64)
   407.    return KDF9.word
   408.       with Inline;
   409.
   410.    function unsign is new Ada.Unchecked_Conversion(CPU.s_64, CPU.u_64);
   411.
   412.    function resign is new Ada.Unchecked_Conversion(CPU.u_64, CPU.s_64);
   413.
   414. --
   415. --
   416.    --
   417.    -- These are the 48-bit primitive, fixed-direction, shift operations.
   418.    --
   419. --
   420. --
   421.
   422.    function shift_time (amount : Natural)
   423.    return KDF9.us
   424.       with Inline;
   425.
   426.    subtype word_shift_length is Natural range 0..48;
   427.
   428.    function shift_word_left (W : KDF9.word; amount : word_shift_length)
   429.    return KDF9.word
   430.       with Inline;
   431.
   432.    function shift_word_right (W : KDF9.word; amount : word_shift_length)
   433.    return KDF9.word
   434.       with Inline;
   435.
   436.    function rotate_word_left (W : KDF9.word; amount : word_shift_length)
   437.    return KDF9.word
   438.       with Inline;
   439.
   440.    function rotate_word_right (W : KDF9.word; amount : word_shift_length)
   441.    return KDF9.word
   442.       with Inline;
   443.
   444. end KDF9.CPU;

 1069 lines: No errors


Compiling: /home/parallels/emulation/Source/kdf9-phu_store.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- The K5 operation data formats.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Unchecked_Conversion;
    18. --
    19. with KDF9.CPU;
    20.
    21. package body KDF9.PHU_store is
    22.
    23.    function short_PHU (p : KDF9.priority)
    24.    return KDF9.word is
    25.
    26.       use type KDF9.store.group_address;
    27.
    28.       type PHU_as_6_bits is mod 2**6
    29.          with Size => 6;
    30.
    31.       function as_6_bits is new Ada.Unchecked_Conversion(Source => PHU_store.PHU_subset,
    32.                                                          Target => short_PHU.PHU_as_6_bits);
    33.
    34.       the_reason    : PHU_store.blockage_kind;
    35.       the_parameter : KDF9.buffer_number;
    36.
    37.    begin
    38.       if not PHU(p).is_held_up then
    39.          return 0;  -- All fields are non-significant.
    40.       end if;
    41.
    42.       -- PHU(p).is_held_up, so other fields are valid.
    43.       the_reason := PHU(p).blockage.reason;
    44.       if the_reason = buffer_busy then
    45.          the_parameter := PHU(p).blockage.buffer_nr;
    46.       else
    47.          -- This is next to useless, but is what the K5 order actually did.
    48.          the_parameter := KDF9.buffer_number(PHU(p).blockage.group_nr mod 2**4);
    49.       end if;
    50.
    51.       return KDF9.word(as_6_bits((the_parameter, the_reason, True)));
    52.    end short_PHU;
    53.
    54.    function K5_operand
    55.    return KDF9.word
    56.    is (
    57.        KDF9.CPU.shift_word_left(short_PHU(0), 48-06) or
    58.        KDF9.CPU.shift_word_left(short_PHU(1), 48-12) or
    59.        KDF9.CPU.shift_word_left(short_PHU(2), 48-18) or
    60.        KDF9.CPU.shift_word_left(short_PHU(3), 48-24)
    61.       );
    62.
    63. end KDF9.PHU_store;

Compiling: ../Source/kdf9-phu_store.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:02

     1. -- The K5 operation data formats.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with System;
    18. --
    19. with KDF9.store;
    20.
    21. package KDF9.PHU_store is
    22.
    23.    -- PHU, the Program Hold-Up register is internal to I/O Control.
    24.    -- It has one element for each of the 4 program priority levels, 0..3.
    25.    -- A subset of its content is exposed to Director by means of the K5 order.
    26.
    27.    type blockage_kind is (buffer_busy, locked_core) with Size => 1;
    28.
    29.    type PHU_reason (reason : PHU_store.blockage_kind := buffer_busy) is
    30.       record
    31.          case reason is
    32.             when buffer_busy =>
    33.                buffer_nr : KDF9.buffer_number;
    34.                by_INTQq  : Boolean;
    35.             when locked_core =>
    36.                group_nr  : KDF9.store.group_address;
    37.          end case;
    38.       end record;
    39.
    40.    type PHU_register (is_held_up : Boolean := False) is
    41.       record
    42.          case is_held_up is
    43.             when False =>
    44.                null;
    45.             when True =>
    46.                blockage : PHU_reason;
    47.          end case;
    48.       end record;
    49.
    50.    idle_PHU : constant PHU_register := (is_held_up => False);
    51.
    52.    PHU : array (KDF9.priority) of PHU_store.PHU_register := (others => idle_PHU);
    53.
    54.    type PHU_subset is
    55.       record
    56.          parameter  : KDF9.buffer_number;
    57.          reason     : PHU_store.blockage_kind;
    58.          is_held_up : Boolean;
    59.       end record
    60.    with Size => 6, Bit_Order => System.Low_Order_First;
    61.
    62.    for  PHU_subset use
    63.       record
    64.          parameter  at 0 range 0 .. 3;
    65.          reason     at 0 range 4 .. 4;
    66.          is_held_up at 0 range 5 .. 5;
    67.       end record;
    68.
    69.    -- A K5_operand is a KDF9 word, D00-D47, with the content:
    70.    --    PHU_subset(0) in D00 .. D05
    71.    --    PHU_subset(1) in D06 .. D11
    72.    --    PHU_subset(2) in D12 .. D17
    73.    --    PHU_subset(3) in D18 .. D23
    74.    --    zeros         in D24 .. D47
    75.
    76.    function K5_operand
    77.    return KDF9.word;
    78.
    79. end KDF9.PHU_store;

 63 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-imaging.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- Provide basic data-KDF9.imaging operations for KDF9 data types.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18. with KDF9.CPU;
    19. with string_editing;
    20.
    21. use  KDF9_char_sets;
    22. use  KDF9.CPU;
    23. use  string_editing;
    24.
    25. package body KDF9.imaging is
    26.
    27.    digit_map : constant array (KDF9.halfword range 0 .. 15) of Character := "0123456789ABCDEF";
    28.
    29.    -- Return N as 3 octal digits.
    30.    function oct_of (N : KDF9.syllable)
    31.    return String
    32.    is (oct_of(KDF9.halfword(N))(6 .. 8));
    33.
    34.    -- Return N as 6 octal digits.
    35.    function oct_of (N : KDF9.field_of_16_bits)
    36.    return String is
    37.       value : KDF9.field_of_16_bits := N;
    38.       oct   : String(1 .. 6);
    39.    begin
    40.       for i in reverse oct'Range loop
    41.          oct(i) := digit_map(KDF9.halfword(value mod 8));
    42.          value := value / 8;
    43.       end loop;
    44.       return oct;
    45.    end oct_of;
    46.
    47.    -- Return N as 1 .. min_digits octal digits, with (partial) zero suppression.
    48.    function oct_of (N : KDF9.Q_part; min_digits : octal_width := 6)
    49.    return String is
    50.       oct : constant String(octal_width) := oct_of(KDF9.field_of_16_bits(N));
    51.    begin
    52.      if N = 0 then return (1..min_digits => '0'); end if;
    53.      for i in 1 .. 6-min_digits loop
    54.         if oct(i) /= '0' then
    55.            return oct(i .. 6);
    56.         end if;
    57.       end loop;
    58.       return oct(7-min_digits .. 6);
    59.    end oct_of;
    60.
    61.    -- Return N as 1 .. 5 decimal digits, with zero suppression and sign when neagtive.
    62.    function signed_dec_of (N : KDF9.Q_part)
    63.    return String is
    64.       dec : constant String := resign(N)'Image;
    65.    begin
    66.       return trimmed(dec);
    67.    end signed_dec_of;
    68.
    69.    -- Return N as #wwwwww, where w is an octal digits;
    70.    --    or as ddddd, where d is a decimal digit, according to octal_option.
    71.    function oct_or_dec_of (N : KDF9.Q_part; octal_option : Boolean)
    72.    return String is
    73.    begin
    74.       if octal_option then
    75.          return "#" & oct_of(N, min_digits => 1);
    76.       else
    77.          return trimmed(N'Image);
    78.       end if;
    79.    end oct_or_dec_of;
    80.
    81.    -- Return N as #wwwwww{ddddd}  OR as ddddd{#wwwwww}
    82.    --   where w is an octal digit and d is a decimal digit,
    83.    --   depending on the value of octal_first,
    84.    --   and { } represents the values of the insert and closer parameters.
    85.    function oct_and_dec_of (
    86.                             N           : KDF9.Q_part;
    87.                             octal_first : Boolean;
    88.                             insert      : String := "; (";
    89.                             closer      : String := ")"
    90.                            )
    91.    return String is
    92.       octal   : constant String := "#" & oct_of(N, min_digits => 1);
    93.       decimal : constant String := trimmed(N'Image);
    94.    begin
    95.       if octal_first then
    96.          return octal   & insert & decimal & closer;
    97.       else
    98.          return decimal & insert & octal   & closer;
    99.       end if;
   100.    end oct_and_dec_of;
   101.
   102.    -- Return N as decimal digits, with zero suppression.
   103.    function dec_of (N : KDF9.Q_part)
   104.    return String is
   105.       dec : constant String := N'Image;
   106.    begin
   107.       return trimmed(dec);
   108.    end dec_of;
   109.
   110.    -- Return N as up to 5 octal digits.
   111.    function oct_of (N : KDF9.code_address)
   112.    return String is
   113.       value : KDF9.code_address := N;
   114.       j     : Positive := 5;
   115.       oct   : String(1 .. 5);
   116.    begin
   117.       for i in reverse oct'Range loop
   118.          oct(i) := digit_map(KDF9.halfword(value mod 8));
   119.          value := value / 8;
   120.       end loop;
   121.       for i in oct'Range loop
   122.          if oct(i) /= '0' then j := i; exit; end if;
   123.       end loop;
   124.       return oct(j..5);
   125.    end oct_of;
   126.
   127.    -- Return N as decimal digits, with zero suppression.
   128.    function dec_of (N : KDF9.code_address)
   129.    return String
   130.    is (trimmed(N'Image));
   131.
   132.    -- Return N as 8 octal digits.
   133.    function oct_of (N : KDF9.halfword)
   134.    return String is
   135.       value : KDF9.halfword := N;
   136.       oct   : String(1 .. 8);
   137.    begin
   138.       for i in reverse oct'Range loop
   139.          oct(i) := digit_map(value mod 8);
   140.          value := value / 8;
   141.       end loop;
   142.       return oct;
   143.    end oct_of;
   144.
   145.    -- Return N as #wwwww/s, where w and s are octal digits.
   146.    function oct_of (N : KDF9.SJNS_link)
   147.    return String
   148.    is (
   149.        "#"
   150.       &  oct_of(N.code_address)
   151.       & '/'
   152.       & digit_map(KDF9.halfword(N.syllable_index))
   153.       );
   154.
   155.    -- Return N as #wwwww/s, where w and s are octal digits.
   156.    function oct_of (N : KDF9.syllable_address)
   157.    return String
   158.    is (oct_of(KDF9.SJNS_link(N)));
   159.
   160.    -- Return N as dddd/d, where d is a decimal digit.
   161.    function dec_of (N : KDF9.syllable_address)
   162.    return String
   163.    is (
   164.        trimmed(N.code_address'Image)
   165.             & '/'
   166.             & digit_map(KDF9.halfword(N.syllable_index))
   167.       );
   168.
   169.    -- Return N as #wwwww/s, where w and s are octal digits;
   170.    --    or as dddd/s, where d is a decimal digit, according to octal_option.
   171.    function oct_or_dec_of (N : KDF9.syllable_address; octal_option : Boolean)
   172.    return String
   173.    is (if octal_option then oct_of(N) else dec_of(N));
   174.
   175.    -- Return N as ##wwwww/s{ddddd/s}  OR as ddddd/s{#wwwwww/s}
   176.    --   where w, s is an octal digit and d is a decimal digit,
   177.    --   depending on the value of octal_first,
   178.    --   and { } represents the values of the insert and closer parameters.
   179.    function oct_and_dec_of (
   180.                             N           : KDF9.syllable_address;
   181.                             octal_first : Boolean;
   182.                             insert      : String := "; (";
   183.                             closer      : String := ")"
   184.                            )
   185.    return String is
   186.       octal   : constant String := oct_of(N);
   187.       decimal : constant String := dec_of(N);
   188.    begin
   189.       if octal_first then
   190.          return octal   & insert & decimal & closer;
   191.       else
   192.          return decimal & insert & octal   & closer;
   193.       end if;
   194.    end oct_and_dec_of;
   195.
   196.    -- Return N as 16 octal digits
   197.    function oct_of (N : KDF9.word)
   198.    return String is
   199.       value : KDF9.word := N;
   200.       oct   : String(1 .. 16);
   201.    begin
   202.       for i in reverse oct'Range loop
   203.          oct(i) := digit_map(KDF9.halfword(value mod 8));
   204.          value := value / 8;
   205.       end loop;
   206.       return oct;
   207.    end oct_of;
   208.
   209.    function plurality (count : KDF9.word; for_1 : String := ""; for_more : String := "s")
   210.    return String
   211.    is (if count /= 1 then for_more else for_1);
   212.
   213.    -- Return the 8-character Latin-1 string representing the 8 Case Normal characters in N.
   214.    function to_string (N : KDF9.word)
   215.    return word_as_byte_string is
   216.       word   : KDF9.word := N;
   217.       result : word_as_byte_string;
   218.    begin
   219.       for i in reverse 1 .. 8 loop
   220.          result(i) := KDF9_char_sets.TP_CN(KDF9_char_sets.symbol(word and 8#77#));
   221.          word := word / 64;
   222.       end loop;
   223.       return result;
   224.    end to_string;
   225.
   226.    -- Return the result of applying to_string to each word of a double-word.
   227.    function to_string (P : KDF9.pair)
   228.    return pair_as_byte_string is
   229.       result : pair_as_byte_string;
   230.    begin
   231.       result(1 ..  8) := to_string(P.msw);
   232.       result(9 .. 16) := to_string(P.lsw);
   233.       return result;
   234.    end to_string;
   235.
   236.    -- Like to_string, but with glyphs for format effectors.
   237.    function glyphs_for (N : KDF9.word)
   238.    return word_as_byte_string is
   239.       word   : KDF9.word := N;
   240.       glyphs : word_as_byte_string;
   241.    begin
   242.       for i in reverse 1..8 loop
   243.          glyphs(i) := glyph_for(to_CP(KDF9_char_sets.symbol(word and 8#77#)));
   244.          word := word / 64;
   245.       end loop;
   246.       return glyphs;
   247.    end glyphs_for;
   248.
   249.    function glyphs_for (S : String)
   250.    return String is
   251.       T : String (S'First..S'Last);
   252.    begin
   253.       for i in T'Range loop
   254.          T(i) := glyph_for(S(i));
   255.       end loop;
   256.       return T;
   257.    end glyphs_for;
   258.
   259. end KDF9.imaging;

Compiling: ../Source/kdf9-imaging.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- Provide basic data-KDF9.imaging operations for KDF9 data types.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.imaging is
    18.
    19.    subtype word_as_byte_string is String(1 .. 8);
    20.    subtype pair_as_byte_string is String(1 .. 16);
    21.
    22.    -- Return N as 3 octal digits.
    23.    function oct_of (N : KDF9.syllable)
    24.    return String;
    25.
    26.    -- Return N as 6 octal digits.
    27.    function oct_of (N : KDF9.field_of_16_bits)
    28.    return String;
    29.
    30.    subtype octal_width is Positive range 1 .. 6;
    31.
    32.    -- Return N as octal digits, with (partial) zero suppression.
    33.    -- The first (6-min_digits) are elided if '0'; all remaining digits are returned.
    34.    -- Up to 6 digits can be returned if the result is longer than min_digits.
    35.    -- If N is 0, the String (1..min_digits => '0') is returned.
    36.    function oct_of (N : KDF9.Q_part; min_digits : octal_width := 6)
    37.    return String;
    38.
    39.    -- Return N as 1 .. 5 decimal digits, with zero suppression and sign when neagtive.
    40.    function signed_dec_of (N : KDF9.Q_part)
    41.    return String;
    42.
    43.    -- Return N as 1 .. 6 decimal digits, with zero suppression.
    44.    function dec_of (N : KDF9.Q_part)
    45.    return String;
    46.
    47.    -- Return N as #wwwwww, where w is an octal digit;
    48.    --    or as ddddd, where d is a decimal digit, according to octal_option.
    49.    function oct_or_dec_of (N : KDF9.Q_part; octal_option : Boolean)
    50.    return String;
    51.
    52.    -- Return N as #wwwwww{ddddd}  OR as ddddd{#wwwwww}
    53.    --   where w is an octal digit and d is a decimal digit,
    54.    --   depending on the value of octal_first,
    55.    --   and { } represents the values of the insert and closer parameters.
    56.    function oct_and_dec_of (
    57.                             N           : KDF9.Q_part;
    58.                             octal_first : Boolean;
    59.                             insert      : String := "; (";
    60.                             closer      : String := ")"
    61.                            )
    62.    return String;
    63.
    64.    -- Return N as ##wwwww/s{ddddd/s}  OR as ddddd/s{#wwwwww/s}
    65.    --   where w, s is an octal digit and d is a decimal digit,
    66.    --   depending on the value of octal_first,
    67.    --   and { } represents the values of the insert and closer parameters.
    68.    function oct_and_dec_of (
    69.                             N           : KDF9.syllable_address;
    70.                             octal_first : Boolean;
    71.                             insert      : String := "; (";
    72.                             closer      : String := ")"
    73.                            )
    74.    return String;
    75.
    76.    -- Return N as up to 5 octal digits.
    77.    function oct_of (N : KDF9.code_address)
    78.    return String;
    79.
    80.    -- Return N as decimal digits, with zero suppression.
    81.    function dec_of (N : KDF9.code_address)
    82.    return String ;
    83.
    84.    -- Return N as 8 octal digits.
    85.    function oct_of (N : KDF9.halfword)
    86.    return String;
    87.
    88.    -- Return N as #wwwww/s, where w and s are octal digits.
    89.    function oct_of (N : KDF9.SJNS_link)
    90.    return String;
    91.
    92.    -- Return N as #wwwww/s, where w and s are octal digits.
    93.    function oct_of (N : KDF9.syllable_address)
    94.    return String;
    95.
    96.    -- Return N as dddd/d, where d is a decimal digit.
    97.    function dec_of (N : KDF9.syllable_address)
    98.    return String;
    99.
   100.    -- Return N as #wwwww/s, where w and s are octal digits;
   101.    --    or as dddd/s, where d is a decimal digit, according to octal_option.
   102.    function oct_or_dec_of (N : KDF9.syllable_address; octal_option : Boolean)
   103.    return String;
   104.
   105.    -- Return N as 16 octal digits.
   106.    function oct_of (N : KDF9.word)
   107.    return String;
   108.
   109.    -- Return the (pluralizing) suffix if count /= 1.
   110.    function plurality (count : KDF9.word; for_1 : String := ""; for_more : String := "s")
   111.    return String;
   112.
   113.    -- Return the 8-character Latin-1 string representing the 8 Case Normal characters in N.
   114.    function to_string (N : KDF9.word)
   115.    return word_as_byte_string;
   116.
   117.    -- Return the result of applying to_string to each word of a double-word.
   118.    function to_string (P : KDF9.pair)
   119.    return pair_as_byte_string;
   120.
   121.    -- Like to_string, but with glyphs for format effectors.
   122.    function glyphs_for (N : KDF9.word)
   123.    return word_as_byte_string;
   124.
   125.    function glyphs_for (S : String)
   126.    return String;
   127.
   128. end KDF9.imaging;

 259 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/tracing.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- Provide diagnostic trace, breakpoint, and watchpoint support.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9.imaging;
    18. with exceptions;
    19. with HCI;
    20. with KDF9.decoding;
    21. with KDF9.store;
    22. with state_display;
    23. with string_editing;
    24.
    25. use KDF9.imaging;
    26. use exceptions;
    27. use HCI;
    28. use KDF9;
    29. use KDF9.decoding;
    30. use KDF9.store;
    31. use state_display;
    32. use string_editing;
    33.
    34. package body tracing is
    35.
    36.    procedure clear_the_histogram is
    37.    begin
    38.       the_histogram := (others => 0);
    39.    end clear_the_histogram;
    40.
    41.    procedure clear_the_profile is
    42.    begin
    43.       the_profile := (others => 0);
    44.    end clear_the_profile;
    45.
    46.    procedure set_breakpoints (first, last : in KDF9.code_address) is
    47.    begin
    48.       for p in first .. last loop
    49.          breakpoints(p) := True;
    50.       end loop;
    51.    end set_breakpoints;
    52.
    53.    procedure handle_breakpoint is
    54.    begin
    55.       short_witness;
    56.       interact;
    57.       quit_if_requested;
    58.       change_diagnostic_mode_if_requested;
    59.    end handle_breakpoint;
    60.
    61.    procedure clear_all_watchpoints is
    62.    begin
    63.       fetchpoints := (others => False);
    64.       storepoints := (others => False);
    65.    end clear_all_watchpoints;
    66.
    67.    procedure set_fetch_points (first, last : in KDF9.address) is
    68.    begin
    69.       for p in first .. last loop
    70.          fetchpoints(p) := True;
    71.       end loop;
    72.    end set_fetch_points;
    73.
    74.    procedure set_store_points (first, last : in KDF9.address) is
    75.    begin
    76.       for p in first .. last loop
    77.          storepoints(p) := True;
    78.       end loop;
    79.    end set_store_points;
    80.
    81.    procedure clear_retro_FIFO is
    82.    begin
    83.       retro_FIFO_count := 0; retro_FIFO_index := 0;
    84.    end clear_retro_FIFO;
    85.
    86.    procedure take_note_of (the_IAR   : in KDF9.syllable_address;
    87.                            the_value : in KDF9.word) is
    88.    begin
    89.       if retrospective_tracing_is_enabled             and then
    90.             ICR in low_count .. high_count            and then
    91.                NIA_word_number in low_bound .. high_bound then
    92.          declare
    93.             the_note : constant retro_FIFO_entry
    94.                      := (
    95.                          location   => the_IAR,
    96.                          order      => INS.order,
    97.                          parameter  => the_value,
    98.                          ICR_value  => ICR,
    99.                          CPU_time   => the_CPU_time,
   100.                          nested     => the_NEST_depth,
   101.                          called     => the_SJNS_depth,
   102.                          V          => the_V_bit_is_set,
   103.                          T          => the_T_bit_is_set,
   104.                          D          => the_CPU_state = Director_state,
   105.                          level      => CPL
   106.                         );
   107.          begin
   108.             if retro_FIFO_count = 0 then
   109.                retro_FIFO(0) := the_note;
   110.                retro_FIFO_count := 1;
   111.             else
   112.                retro_FIFO_index := retro_FIFO_index + 1;
   113.                retro_FIFO(retro_FIFO_index) := the_note;
   114.                if retro_FIFO_count < FIFO_size then
   115.                   retro_FIFO_count := retro_FIFO_count + 1;
   116.                end if;
   117.             end if;
   118.          end;
   119.       end if;
   120.    end take_note_of;
   121.
   122.    procedure take_note_of (the_value : in KDF9.word) is
   123.    begin
   124.       take_note_of(CIA, the_value);
   125.    end take_note_of;
   126.
   127.    procedure clear_IOC_FIFO is
   128.    begin
   129.       IOC_FIFO_count := 0; IOC_FIFO_index := 0;
   130.    end clear_IOC_FIFO;
   131.
   132.    procedure register_IO_event (the_note : in IOC_FIFO_entry) is
   133.    begin
   134.       if peripheral_tracing_is_enabled                and then
   135.             ICR in low_count .. high_count            and then
   136.                NIA_word_number in low_bound .. high_bound then
   137.          if IOC_FIFO_count = 0 then
   138.             IOC_FIFO(0) := the_note;
   139.             IOC_FIFO_count := 1;
   140.          else
   141.             IOC_FIFO_index := IOC_FIFO_index + 1;
   142.             IOC_FIFO(IOC_FIFO_index) := the_note;
   143.             if IOC_FIFO_count < FIFO_size then
   144.                IOC_FIFO_count := IOC_FIFO_count + 1;
   145.             end if;
   146.          end if;
   147.       end if;
   148.    end register_IO_event;
   149.
   150.    procedure take_note_of_IO_start (
   151.                                     device_name     : in IOC.device_name;
   152.                                     completion_time : in KDF9.us;
   153.                                     control_word    : in KDF9.Q_register;
   154.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   155.                                    )
   156.    is
   157.       the_note : constant  IOC_FIFO_entry
   158.                :=
   159.                 (
   160.                  kind            => start_transfer,
   161.                  ICR_value       => ICR,
   162.                  order_address   => CIA,
   163.                  decoded_order   => INS,
   164.                  initiation_time => the_clock_time,
   165.                  device_name     => take_note_of_IO_start.device_name,
   166.                  completion_time => take_note_of_IO_start.completion_time,
   167.                  is_for_Director => (the_CPU_state = Director_state),
   168.                  priority_level  => CPL,
   169.                  context         => the_context,
   170.                  control_word    => take_note_of_IO_start.control_word,
   171.                  operation       => take_note_of_IO_start.operation
   172.                 );
   173.    begin
   174.       register_IO_event(the_note);
   175.    end take_note_of_IO_start;
   176.
   177.    procedure take_note_of_IO_finis (
   178.                                     ICR_value       : in KDF9.order_counter;
   179.                                     order_address   : in KDF9.syllable_address;
   180.                                     decoded_order   : in KDF9.decoded_order;
   181.                                     initiation_time : in KDF9.us;
   182.                                     device_name     : in IOC.device_name;
   183.                                     is_for_Director : Boolean;
   184.                                     priority_level  : in KDF9.priority;
   185.                                     completion_time : in KDF9.us;
   186.                                     control_word    : in KDF9.Q_register;
   187.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   188.                                    )
   189.    is
   190.       the_note : constant  IOC_FIFO_entry
   191.                :=
   192.                 (
   193.                  kind            => finis_transfer,
   194.                  ICR_value       => take_note_of_IO_finis.ICR_value,
   195.                  order_address   => take_note_of_IO_finis.order_address,
   196.                  decoded_order   => take_note_of_IO_finis.decoded_order,
   197.                  initiation_time => take_note_of_IO_finis.initiation_time,
   198.                  device_name     => take_note_of_IO_finis.device_name,
   199.                  is_for_Director => take_note_of_IO_finis.is_for_Director,
   200.                  priority_level  => take_note_of_IO_finis.priority_level,
   201.                  context         => the_context,
   202.                  completion_time => take_note_of_IO_finis.completion_time,
   203.                  control_word    => take_note_of_IO_finis.control_word,
   204.                  operation       => take_note_of_IO_finis.operation
   205.                 );
   206.
   207.    begin
   208.       register_IO_event(the_note);
   209.    end take_note_of_IO_finis;
   210.
   211.    procedure take_note_of_store_lockout (device_name : in IOC.device_name) is
   212.       the_note : constant  IOC_FIFO_entry
   213.                :=
   214.                 (
   215.                  kind            => store_lockout,
   216.                  ICR_value       => ICR,
   217.                  order_address   => CIA,
   218.                  decoded_order   => INS,
   219.                  initiation_time => the_clock_time,
   220.                  device_name     => take_note_of_store_lockout.device_name,
   221.                  is_for_Director => False,
   222.                  priority_level  => CPL,
   223.                  context         => the_context,
   224.                  data_address    => the_locked_out_address,
   225.                  operation       => IOC.some_other_operation
   226.                 );
   227.    begin
   228.       register_IO_event(the_note);
   229.    end take_note_of_store_lockout;
   230.
   231.    procedure take_note_of_buffer_lockout (device_name : in IOC.device_name;
   232.                                           operation   : in IOC.transfer_kind := IOC.some_other_operation) is
   233.       the_note : constant  IOC_FIFO_entry
   234.                :=
   235.                 (
   236.                  kind            => buffer_lockout,
   237.                  ICR_value       => ICR,
   238.                  order_address   => CIA,
   239.                  decoded_order   => INS,
   240.                  initiation_time => the_clock_time,
   241.                  device_name     => take_note_of_buffer_lockout.device_name,
   242.                  is_for_Director => False,
   243.                  priority_level  => CPL,
   244.                  context         => the_context,
   245.                  operation       => take_note_of_buffer_lockout.operation
   246.                 );
   247.    begin
   248.       register_IO_event(the_note);
   249.    end take_note_of_buffer_lockout;
   250.
   251.    procedure take_note_of_test (
   252.                                 device_name : in IOC.device_name;
   253.                                 Q_register  : in KDF9.Q_register;
   254.                                 status      : in Boolean
   255.                                )
   256.    is
   257.       the_note : constant  IOC_FIFO_entry
   258.                :=
   259.                 (
   260.                  kind            => buffer_status,
   261.                  ICR_value       => ICR+1,  -- ICR is not incremented until the end of an order.
   262.                  order_address   => CIA,
   263.                  decoded_order   => INS,
   264.                  initiation_time => the_clock_time,
   265.                  device_name     => take_note_of_test.device_name,
   266.                  is_for_Director => (the_CPU_state = Director_state),
   267.                  priority_level  => CPL,
   268.                  context         => the_context,
   269.                  Q_register      => take_note_of_test.Q_register,
   270.                  status          => take_note_of_test.status,
   271.                  operation       => IOC.some_other_operation
   272.                 );
   273.    begin
   274.       register_IO_event(the_note);
   275.    end take_note_of_test;
   276.
   277.    procedure clear_interrupt_FIFO is
   278.    begin
   279.       interrupt_FIFO_count := 0; interrupt_FIFO_index := 0;
   280.    end clear_interrupt_FIFO;
   281.
   282.    procedure take_note_of_interrupt (interrupt_code : in KDF9.interrupt_number; message : in String)
   283.    is
   284.       length  : constant Natural  := Natural'Min(message'Length, max_interrupt_message_length);
   285.       content : constant String   := message(message'First .. message'First+length-1);
   286.       padding : constant String   := (1 .. max_interrupt_message_length-length => ' ');
   287.    begin
   288.       declare
   289.          the_note : constant interrupt_FIFO_entry
   290.                   :=
   291.                    (
   292.                     interrupt_code => take_note_of_interrupt.interrupt_code,
   293.                     ICR_value      => ICR,
   294.                     order_address  => CIA,
   295.                     busy_time      => the_clock_time,
   296.                     priority_level => CPL,
   297.                     context        => the_context,
   298.                     message        => content & padding
   299.                    );
   300.       begin
   301.          if interrupt_tracing_is_enabled                 and then
   302.                ICR in low_count .. high_count            and then
   303.                   NIA_word_number in low_bound .. high_bound then
   304.             if interrupt_FIFO_count = 0 then
   305.                interrupt_FIFO(0) := the_note;
   306.                interrupt_FIFO_count := 1;
   307.             else
   308.                interrupt_FIFO_index := interrupt_FIFO_index + 1;
   309.                interrupt_FIFO(interrupt_FIFO_index) := the_note;
   310.                if interrupt_FIFO_count < FIFO_size then
   311.                   interrupt_FIFO_count := interrupt_FIFO_count + 1;
   312.                end if;
   313.             end if;
   314.          end if;
   315.       end;
   316.    end take_note_of_interrupt;
   317.
   318.    procedure add_INS_to_the_histogram is
   319.       syllable_0 : KDF9.syllable := INS.order.syllable_0;
   320.    begin
   321.       if INS.kind = normal_jump_order then
   322.          syllable_0 := (syllable_0 and 2#1111_0000#) or INS.Qq;
   323.       elsif INS.kind = data_access_order then
   324.          syllable_0 := (syllable_0 and 2#11_000_111#);
   325.       end if;
   326.       the_histogram(syllable_0) := the_histogram(syllable_0) + 1;
   327.    end add_INS_to_the_histogram;
   328.
   329.    procedure add_CIA_to_the_profile is
   330.    begin
   331.       the_profile(CIA.code_address) := the_profile(CIA.code_address) + 1;
   332.    end add_CIA_to_the_profile;
   333.
   334.    procedure preview_a_one_syllable_order is null;
   335.
   336.    procedure preview_a_two_syllable_order is
   337.    begin
   338.       case INS.compressed_opcode is
   339.          when TO_MkMq
   340.             | TO_MkMqQ
   341.             | TO_MkMqH
   342.             | TO_MkMqQH
   343.             | TO_MkMqN
   344.             | TO_MkMqQN
   345.             | TO_MkMqHN
   346.             | TO_MkMqQHN =>
   347.             the_trace_operand := read_top;
   348.          when others =>
   349.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   350.       end case;
   351.    end preview_a_two_syllable_order;
   352.
   353.    procedure preview_a_jump_order is
   354.    begin
   355.       case INS.compressed_opcode is
   356.          when JrEQ
   357.             | JrNE
   358.             | JrGTZ
   359.             | JrLTZ
   360.             | JrEQZ
   361.             | JrLEZ
   362.             | JrGEZ
   363.             | JrNEZ
   364.             | OS_OUT =>
   365.             if the_NEST_depth > 0 then
   366.                the_trace_operand := read_top;
   367.             end if;
   368.          when JrEN
   369.             | JrNEN =>
   370.             the_trace_operand := KDF9.word(the_NEST_depth);
   371.          when JrEJ
   372.             | JrNEJ =>
   373.             the_trace_operand := KDF9.word(the_SJNS_depth);
   374.          when EXIT_n
   375.             | EXITD =>
   376.             if the_SJNS_depth > 0 then
   377.                the_trace_operand := as_word(SJNS_top);
   378.             else
   379.                the_trace_operand := -1;
   380.             end if;
   381.          when JrCqZ
   382.             | JrCqNZ =>
   383.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   384.          when JrV
   385.             | JrNV =>
   386.             the_trace_operand := (if the_V_bit_is_set then 1 else 0);
   387.          when JrTR
   388.             | JrNTR =>
   389.             the_trace_operand := (if the_T_bit_is_set then 1 else 0);
   390.          when others =>
   391.             null;
   392.       end case;
   393.    end preview_a_jump_order;
   394.
   395.    procedure preview_a_data_access_order is
   396.    begin
   397.       case INS.compressed_opcode is
   398.          when TO_EaMq
   399.             | TO_EaMqQ =>
   400.             the_trace_operand := read_top;
   401.          when others =>
   402.             null;
   403.       end case;
   404.    end preview_a_data_access_order;
   405.
   406.    procedure look_back_at_a_one_syllable_order is
   407.       AB : KDF9.pair;
   408.    begin
   409.       case INS.compressed_opcode is
   410.          when XDF
   411.             | XPLUSF
   412.             | MINUSDF
   413.             | PLUSDF
   414.             | FLOATD
   415.             | NEGDF
   416.             | MAXF
   417.             | PERM
   418.             | CAB
   419.             | MAX
   420.             | XD
   421.             | NEGD
   422.             | DUPD
   423.             | DIVI
   424.             | STR
   425.             | REVD
   426.             | MINUSD
   427.             | PLUSD
   428.             | DIVR =>
   429.             AB := read_top;
   430.             the_trace_operand := AB.msw;
   431.          when others =>
   432.             if the_NEST_depth > 0 then
   433.                the_trace_operand := read_top;
   434.             end if;
   435.       end case;
   436.    end look_back_at_a_one_syllable_order;
   437.
   438.    procedure look_back_at_an_IO_order is null;
   439.
   440.    procedure look_back_at_a_two_syllable_order is
   441.       AB : KDF9.pair;
   442.    begin
   443.       case INS.compressed_opcode is
   444.          when MkMq
   445.             | MkMqQ
   446.             | MkMqH
   447.             | MkMqQH
   448.             | MkMqQN
   449.             | MkMqHN
   450.             | MkMqQHN
   451.             | QCIMq
   452.             | SHA
   453.             | SHL
   454.             | SHC
   455.             | TO_Kq
   456.             | Kk
   457.             | LINK =>
   458.             the_trace_operand := read_top;
   459.          when TO_MkMq
   460.             | TO_MkMqQ
   461.             | TO_MkMqH
   462.             | TO_MkMqQH
   463.             | TO_MkMqN
   464.             | TO_MkMqQN
   465.             | TO_MkMqHN
   466.             | TO_MkMqQHN =>
   467.             null;
   468.          when M_PLUS_Iq
   469.             | M_MINUS_Iq
   470.             | NCq
   471.             | DCq
   472.             | POS1_TO_Iq
   473.             | NEG1_TO_Iq
   474.             | POS2_TO_Iq
   475.             | NEG2_TO_Iq
   476.             | TO_RCIMq
   477.             | ADD_TO_QCIMq
   478.             | JCqNZS =>
   479.             the_trace_operand := as_word(the_Q_store(INS.Qq));
   480.          when CqTOQk
   481.             | IqTOQk
   482.             | MqTOQk
   483.             | QqTOQk
   484.             | CIqTOQk
   485.             | IMqTOQk
   486.             | CMqTOQk =>
   487.             the_trace_operand := as_word(the_Q_store(INS.Qk));
   488.          when SHLD
   489.             | SHAD
   490.             | MACC =>
   491.             AB := read_top;
   492.             the_trace_operand := AB.msw;
   493.          when TO_LINK =>
   494.             the_trace_operand := as_word(SJNS_top);
   495.          when others =>
   496.             look_back_at_an_IO_order;
   497.       end case;
   498.    end look_back_at_a_two_syllable_order;
   499.
   500.    procedure look_back_at_a_jump_order is
   501.       BA_image  : constant String := "BA #" & oct_of(BA);
   502.       NOL_image : constant String := "NOL"  & NOL'Image;
   503.    begin
   504.       case INS.compressed_opcode is
   505.          when Jr =>
   506.             the_trace_operand := as_word(SJNS_link(NIA));
   507.          when JSr =>
   508.             the_trace_operand := as_word(SJNS_top);
   509.          when EXITD =>
   510.             take_note_of_interrupt(EXITD_flag, BA_image + NOL_image + "@" + oct_of(NIA));
   511.          when others =>
   512.             null;
   513.       end case;
   514.    end look_back_at_a_jump_order;
   515.
   516.    procedure look_back_at_a_data_access_order is
   517.    begin
   518.       case INS.compressed_opcode is
   519.          when EaMq
   520.             | EaMqQ
   521.             | SET =>
   522.             the_trace_operand := read_top;
   523.          when others =>
   524.             null;
   525.       end case;
   526.    end look_back_at_a_data_access_order;
   527.
   528.    procedure act_on_any_fetchpoint is
   529.       use type watch_flags.set;
   530.    begin
   531.       if fetchpoints/the_trace_address then
   532.          log_new_line;
   533.          log("Fetch watchhpoint: N1 := [#" & oct_of(the_trace_address) & "]");
   534.          short_witness;
   535.          interact;
   536.          quit_if_requested;
   537.          change_diagnostic_mode_if_requested;
   538.       end if;
   539.    end act_on_any_fetchpoint;
   540.
   541.    procedure act_on_any_storepoint is
   542.       use type watch_flags.set;
   543.    begin
   544.       if storepoints/the_trace_address then
   545.          log_new_line;
   546.          log(
   547.              "Store watchpoint: #"
   548.            & oct_of(the_trace_address)
   549.            + ":= [N1] = #"
   550.            & oct_of(the_trace_operand)
   551.             );
   552.          short_witness;
   553.          interact;
   554.          quit_if_requested;
   555.          change_diagnostic_mode_if_requested;
   556.       end if;
   557.    end act_on_any_storepoint;
   558.
   559.    procedure act_on_any_two_syllable_order_watchpoints is
   560.    begin
   561.       case INS.compressed_opcode is
   562.          when MkMq
   563.             | MkMqQ
   564.             | MkMqH
   565.             | MkMqQH
   566.             | MkMqQN
   567.             | MkMqHN
   568.             | MkMqQHN =>
   569.             act_on_any_fetchpoint;
   570.          when TO_MkMq
   571.             | TO_MkMqQ
   572.             | TO_MkMqH
   573.             | TO_MkMqQH
   574.             | TO_MkMqN
   575.             | TO_MkMqQN
   576.             | TO_MkMqHN
   577.             | TO_MkMqQHN =>
   578.             act_on_any_storepoint;
   579.          when others =>
   580.             null;
   581.       end case;
   582.    end act_on_any_two_syllable_order_watchpoints;
   583.
   584.    procedure act_on_any_data_access_order_watchpoints is
   585.    begin
   586.       case INS.compressed_opcode is
   587.          when EaMq
   588.             | EaMqQ =>
   589.             act_on_any_fetchpoint;
   590.          when TO_EaMq
   591.             | TO_EaMqQ =>
   592.             act_on_any_storepoint;
   593.          when others =>
   594.             null;
   595.       end case;
   596.    end act_on_any_data_access_order_watchpoints;
   597.
   598. end tracing;

Compiling: ../Source/tracing.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- Provide diagnostic trace, breakpoint, and watchpoint support.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with generic_sets;
    18. with IOC;
    19. with KDF9;
    20. with settings;
    21.
    22. use  settings;
    23.
    24. package tracing is
    25.
    26.    -- Support for significant-operand evaluation and tracing.
    27.
    28.    the_trace_operand : KDF9.word;
    29.    the_trace_address : KDF9.address;
    30.
    31.    procedure preview_a_one_syllable_order;
    32.
    33.    procedure preview_a_two_syllable_order;
    34.
    35.    procedure preview_a_jump_order;
    36.
    37.    procedure preview_a_data_access_order;
    38.
    39.    procedure look_back_at_a_one_syllable_order;
    40.
    41.    procedure look_back_at_a_two_syllable_order;
    42.
    43.    procedure look_back_at_a_jump_order
    44.       with Inline => False;
    45.
    46.    procedure look_back_at_a_data_access_order;
    47.
    48.    -- Support for breakpoints.
    49.
    50.    package order_flags is new generic_sets(member => KDF9.code_address);
    51.
    52.    breakpoints : order_flags.set := order_flags.empty_set;
    53.
    54.    procedure set_breakpoints (first, last : in KDF9.code_address);
    55.
    56.    procedure handle_breakpoint;
    57.
    58.    -- Support for watchpoints.
    59.
    60.    package watch_flags is new generic_sets(member => KDF9.address);
    61.
    62.    fetchpoints : watch_flags.set := watch_flags.empty_set;
    63.    storepoints : watch_flags.set := watch_flags.empty_set;
    64.
    65.    procedure clear_all_watchpoints;
    66.
    67.    procedure set_fetch_points (first, last : in KDF9.address);
    68.
    69.    procedure set_store_points (first, last : in KDF9.address);
    70.
    71.    procedure act_on_any_two_syllable_order_watchpoints
    72.       with Inline => False;
    73.
    74.    procedure act_on_any_data_access_order_watchpoints
    75.       with Inline => False;
    76.
    77.
    78.    --
    79.    -- Retrospective tracing.
    80.    --
    81.
    82.    FIFO_size : constant := 256;
    83.
    84.    type FIFO_index is mod FIFO_size;
    85.
    86.    -- Support for all-instruction retrospective tracing.
    87.
    88.    type retro_FIFO_entry is
    89.       record
    90.          location  : KDF9.syllable_address;
    91.          order     : KDF9.syllable_group;
    92.          parameter : KDF9.word;
    93.          ICR_value : KDF9.order_counter;
    94.          CPU_time  : KDF9.us;
    95.          nested    : KDF9.NEST_depth;
    96.          called    : KDF9.SJNS_depth;
    97.          V, T, D   : Boolean;
    98.          level     : KDF9.priority;
    99.       end record;
   100.
   101.    retro_FIFO  : array (tracing.FIFO_index) of tracing.retro_FIFO_entry;
   102.
   103.    retro_FIFO_index : tracing.FIFO_index := 0;
   104.
   105.    retro_FIFO_count : Natural range 0 .. FIFO_size := 0;
   106.
   107.    procedure clear_retro_FIFO;
   108.
   109.    procedure take_note_of (the_value : in KDF9.word);
   110.
   111.    -- Support for retrospective peripheral I/O tracing.
   112.
   113.    type IOC_event_kind is (start_transfer,
   114.                            finis_transfer,
   115.                            buffer_lockout,
   116.                            store_lockout,
   117.                            buffer_status);
   118.
   119.
   120.    type IOC_FIFO_entry (kind : IOC_event_kind := start_transfer) is
   121.       record
   122.          ICR_value       : KDF9.order_counter;
   123.          order_address   : KDF9.syllable_address;
   124.          decoded_order   : KDF9.decoded_order;
   125.          initiation_time : KDF9.us;
   126.          device_name     : IOC.device_name;
   127.          is_for_Director : Boolean;
   128.          priority_level  : KDF9.priority;
   129.          context         : KDF9.context;
   130.          operation       : IOC.transfer_kind := IOC.some_other_operation;
   131.          case kind is
   132.             when start_transfer | finis_transfer =>
   133.                completion_time : KDF9.us;
   134.                control_word    : KDF9.Q_register;
   135.             when store_lockout =>
   136.                data_address : KDF9.Q_part;
   137.             when buffer_lockout =>
   138.                null;
   139.             when buffer_status =>
   140.                Q_register : KDF9.Q_register;
   141.                status     : Boolean;
   142.          end case;
   143.       end record;
   144.
   145.    IOC_FIFO  : array (tracing.FIFO_index) of tracing.IOC_FIFO_entry;
   146.
   147.    IOC_FIFO_index : tracing.FIFO_index := 0;
   148.
   149.    IOC_FIFO_count : Natural range 0 .. FIFO_size := 0;
   150.
   151.    procedure clear_IOC_FIFO;
   152.
   153.    procedure take_note_of_IO_start (
   154.                                     device_name     : in IOC.device_name;
   155.                                     completion_time : in KDF9.us;
   156.                                     control_word    : in KDF9.Q_register;
   157.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   158.                                    );
   159.
   160.    procedure take_note_of_IO_finis (
   161.                                     ICR_value       : in KDF9.order_counter;
   162.                                     order_address   : in KDF9.syllable_address;
   163.                                     decoded_order   : in KDF9.decoded_order;
   164.                                     initiation_time : in KDF9.us;
   165.                                     device_name     : in IOC.device_name;
   166.                                     is_for_Director : Boolean;
   167.                                     priority_level  : in KDF9.priority;
   168.                                     completion_time : in KDF9.us;
   169.                                     control_word    : in KDF9.Q_register;
   170.                                     operation       : in IOC.transfer_kind := IOC.some_other_operation
   171.                                    );
   172.
   173.    procedure take_note_of_store_lockout  (device_name : in IOC.device_name);
   174.
   175.    procedure take_note_of_buffer_lockout (device_name : in IOC.device_name;
   176.                                           operation   : in IOC.transfer_kind := IOC.some_other_operation);
   177.
   178.    procedure take_note_of_test (
   179.                                 device_name : in IOC.device_name;
   180.                                 Q_register  : in KDF9.Q_register;
   181.                                 status      : in Boolean
   182.                                 );
   183.
   184.
   185.    -- Support for retrospective interrupt-request tracing.
   186.
   187.    max_interrupt_message_length : constant := 100;
   188.    type interrupt_FIFO_entry is
   189.       record
   190.          interrupt_code : KDF9.interrupt_number;
   191.          ICR_value      : KDF9.order_counter;
   192.          order_address  : KDF9.syllable_address;
   193.          busy_time      : KDF9.us;
   194.          priority_level : KDF9.priority;
   195.          context        : KDF9.context;
   196.          message        : String (1..max_interrupt_message_length);
   197.       end record;
   198.
   199.    interrupt_FIFO  : array (tracing.FIFO_index) of tracing.interrupt_FIFO_entry;
   200.
   201.    interrupt_FIFO_index : tracing.FIFO_index := 0;
   202.
   203.    interrupt_FIFO_count : Natural range 0 .. FIFO_size := 0;
   204.
   205.    procedure clear_interrupt_FIFO;
   206.
   207.    procedure take_note_of_interrupt (interrupt_code : in KDF9.interrupt_number; message : in String)
   208.       with Inline => False;
   209.
   210.
   211.    -- Support for the instruction-type and instruction-word frequency histograms.
   212.
   213.    the_histogram : array (KDF9.syllable) of KDF9.order_counter;
   214.
   215.    procedure clear_the_histogram;
   216.
   217.    procedure add_INS_to_the_histogram
   218.       with Inline;
   219.
   220.    the_profile   : array (KDF9.code_address) of KDF9.order_counter;
   221.
   222.    procedure clear_the_profile;
   223.
   224.    procedure add_CIA_to_the_profile
   225.       with Inline;
   226.
   227. end tracing;

 598 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9_char_sets.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- The architecturally-defined character codes of the KDF9 computer.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Latin_1;
    18.
    19. use  Ada.Characters.Latin_1;
    20.
    21. package KDF9_char_sets is -- NB NOT a child of KDF9!
    22.
    23.    --
    24.    -- The KDF9 character. Each symbol occupies six bits, and they are packed 8 per word.
    25.    --
    26.
    27.    type symbol is mod 2**6;
    28.
    29.    type symbol_index is mod 8;
    30.
    31.    Blank_Space  : constant KDF9_char_sets.symbol := 8#00#;
    32.    Line_Shift   : constant KDF9_char_sets.symbol := 8#02#;
    33.    Page_Change  : constant KDF9_char_sets.symbol := 8#03#;
    34.    Tabulation   : constant KDF9_char_sets.symbol := 8#04#;
    35.    Case_Shift   : constant KDF9_char_sets.symbol := 8#06#;
    36.    Case_Normal  : constant KDF9_char_sets.symbol := 8#07#;
    37.    Tape_Mark    : constant KDF9_char_sets.symbol := 8#17#;
    38.    Semi_Colon   : constant KDF9_char_sets.symbol := 8#34#;
    39.    Upper_Case_D : constant KDF9_char_sets.symbol := 8#44#;
    40.    Upper_Case_M : constant KDF9_char_sets.symbol := 8#55#;
    41.    Upper_Case_P : constant KDF9_char_sets.symbol := 8#60#;
    42.    End_Message  : constant KDF9_char_sets.symbol := 8#75#;
    43.    Word_Filler  : constant KDF9_char_sets.symbol := 8#77#;
    44.    Group_Mark   : constant KDF9_char_sets.symbol := 8#77#;
    45.
    46.    --
    47.    -- These are the 8 bits of a paper tape frame containing these characters.
    48.    --
    49.    Semi_Colon_tape_bits  : constant := 8#074#;
    50.    End_Message_tape_bits : constant := 8#175#;
    51.
    52.    --
    53.    -- KDF9 <=> ISO Latin-1 character code inter-relationships.
    54.    --
    55.
    56.    type output_code_table is array (KDF9_char_sets.symbol) of Character;
    57.    type input_code_table  is array (Character)   of KDF9_char_sets.symbol;
    58.
    59.    C_N : constant Character := '';  -- Models KDF9's Case_Normal in legible Latin-1.
    60.    C_S : constant Character := '';  -- Models KDF9's Case_Shift  in legible Latin-1.
    61.    E_M : constant Character := '|';  -- Models KDF9's End_Message in legible Latin-1.
    62.    W_F : constant Character := '';  -- Models KDF9's Word Filler in legible Latin-1.
    63.
    64.    -- The Line Printer code:
    65.    --    W_F is used for values that have no printable representation.
    66.    to_LP : constant output_code_table
    67.          :=  (' ',  W_F,   LF,   FF,  W_F,  W_F,  '%',  ''',
    68.               ':',  '=',  '(',  ')',  '',  '*',  ',',  '/',
    69.               '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',
    70.               '8',  '9',  W_F,  '',  ';',  '+',  '-',  '.',
    71.               W_F,  'A',  'B',  'C',  'D',  'E',  'F',  'G',
    72.               'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O',
    73.               'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W',
    74.               'X',  'Y',  'Z',  W_F,  W_F,  W_F,  W_F,  W_F
    75.              );
    76.
    77.    -- The Card Reader code:
    78.    --    W_F is used for external characters that have no assigned punching.
    79.    CR_in : constant input_code_table
    80.          := (' ' => 8#00#,  '"' => 8#01#,  '' => 8#02#,  '' => 8#03#,
    81.              '' => 8#04#,  '#' => 8#05#,  '%' => 8#06#,  ''' => 8#07#,
    82.              ':' => 8#10#,  '=' => 8#11#,  '(' => 8#12#,  ')' => 8#13#,
    83.              '' => 8#14#,  '*' => 8#15#,  ',' => 8#16#,  '/' => 8#17#,
    84.              '0' => 8#20#,  '1' => 8#21#,  '2' => 8#22#,  '3' => 8#23#,
    85.              '4' => 8#24#,  '5' => 8#25#,  '6' => 8#26#,  '7' => 8#27#,
    86.              '8' => 8#30#,  '9' => 8#31#,  '_' => 8#32#,  '' => 8#33#,
    87.              ';' => 8#34#,  '+' => 8#35#,  '-' => 8#36#,  '.' => 8#37#,
    88.
    89.              '@' => 8#40#,  'A' => 8#41#,  'B' => 8#42#,  'C' => 8#43#,
    90.              'D' => 8#44#,  'E' => 8#45#,  'F' => 8#46#,  'G' => 8#47#,
    91.              'H' => 8#50#,  'I' => 8#51#,  'J' => 8#52#,  'K' => 8#53#,
    92.              'L' => 8#54#,  'M' => 8#55#,  'N' => 8#56#,  'O' => 8#57#,
    93.              'P' => 8#60#,  'Q' => 8#61#,  'R' => 8#62#,  'S' => 8#63#,
    94.              'T' => 8#64#,  'U' => 8#65#,  'V' => 8#66#,  'W' => 8#67#,
    95.              'X' => 8#70#,  'Y' => 8#71#,  'Z' => 8#72#,  '{' => 8#73#,
    96.              '}' => 8#74#,  E_M => 8#75#,  '\' => 8#76#,  W_F => 8#77#,
    97.
    98.                             'a' => 8#41#,  'b' => 8#42#,  'c' => 8#43#,
    99.              'd' => 8#44#,  'e' => 8#45#,  'f' => 8#46#,  'g' => 8#47#,
   100.              'h' => 8#50#,  'i' => 8#51#,  'j' => 8#52#,  'k' => 8#53#,
   101.              'l' => 8#54#,  'm' => 8#55#,  'n' => 8#56#,  'o' => 8#57#,
   102.              'p' => 8#60#,  'q' => 8#61#,  'r' => 8#62#,  's' => 8#63#,
   103.              't' => 8#64#,  'u' => 8#65#,  'v' => 8#66#,  'w' => 8#67#,
   104.              'x' => 8#70#,  'y' => 8#71#,  'z' => 8#72#,
   105.              others => Word_Filler
   106.             );
   107.
   108.    -- The Card Punch code:
   109.    to_CP : constant output_code_table
   110.          := (' ',  '"',  '',  '',  '',  '#',  '%',  ''',
   111.              ':',  '=',  '(',  ')',  '',  '*',  ',',  '/',
   112.              '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',
   113.              '8',  '9',  '_',  '',  ';',  '+',  '-',  '.',
   114.              '@',  'A',  'B',  'C',  'D',  'E',  'F',  'G',
   115.              'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O',
   116.              'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W',
   117.              'X',  'Y',  'Z',  '{',  '}',  E_M,  '\',  W_F
   118.             );
   119.
   120.    -- Two-shift devices expand the code by adopting alternative representations
   121.    --    depending on the current "shift".
   122.    -- The Flexowriter type cage really did shift up and down to bring the
   123.    --    appropriate glyph set into position.
   124.
   125.    subtype letter_case is KDF9_char_sets.symbol range Blank_Space .. Case_Normal;
   126.    both   : constant KDF9_char_sets.symbol := Blank_Space;
   127.    normal : constant KDF9_char_sets.symbol := Case_Normal;
   128.    shift  : constant KDF9_char_sets.symbol := Case_Shift;
   129.
   130.    case_of : constant input_code_table
   131.            := (' ' =>  both,  '"' =>  both,   LF =>  both,   FF =>  both,
   132.                 HT =>  both,  '#' =>  both,  C_S =>  both,  C_N =>  both,
   133.                '&' =>  both,  '?' =>  both,  '!' =>  both,  '%' =>  both,
   134.                ''' =>  both,  '$' =>  both,  '~' =>  both,  ':' => shift,
   135.                '^' => shift,  '[' => shift,  ']' => shift,  '<' => shift,
   136.                '>' => shift,  '=' => shift,  '' => shift,  '' => shift,
   137.                '(' => shift,  ')' => shift,  '_' =>  both,  '' => shift,
   138.                ';' =>  both,  '' => shift,  '*' => shift,  ',' => shift,
   139.
   140.                '@' =>  both,  'a' => shift,  'b' => shift,  'c' => shift,
   141.                'd' => shift,  'e' => shift,  'f' => shift,  'g' => shift,
   142.                'h' => shift,  'i' => shift,  'j' => shift,  'k' => shift,
   143.                'l' => shift,  'm' => shift,  'n' => shift,  'o' => shift,
   144.                'p' => shift,  'q' => shift,  'r' => shift,  's' => shift,
   145.                't' => shift,  'u' => shift,  'v' => shift,  'w' => shift,
   146.                'x' => shift,  'y' => shift,  'z' => shift,  '{' =>  both,
   147.                '}' =>  both,  E_M =>  both,  '\' =>  both,  W_F =>  both,
   148.                others => normal
   149.               );
   150.
   151.    next_case : constant array (shift .. normal) of Character := (normal => C_S, shift => C_N);
   152.
   153.    -- The Case Normal shift paper tape code:
   154.    TP_CN : constant output_code_table
   155.          := (' ',  '"',   LF,   FF,   HT,  '#',  C_S,  C_N,
   156.              '&',  '?',  '!',  '%',  ''',  '$',  '~',  '/',
   157.              '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',
   158.              '8',  '9',  '_',  '',  ';',  '+',  '-',  '.',
   159.              '@',  'A',  'B',  'C',  'D',  'E',  'F',  'G',
   160.              'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O',
   161.              'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W',
   162.              'X',  'Y',  'Z',  '{',  '}',  E_M,  '\',  W_F
   163.             );
   164.
   165.    CN_TR : constant input_code_table
   166.          := (' ' => 8#00#,  '"' => 8#01#,   LF => 8#02#,   FF => 8#03#,
   167.               HT => 8#04#,  '#' => 8#05#,  C_S => 8#06#,  C_N => 8#07#,
   168.              '&' => 8#10#,  '?' => 8#11#,  '!' => 8#12#,  '%' => 8#13#,
   169.              ''' => 8#14#,  '$' => 8#15#,  '~' => 8#16#,  '/' => 8#17#,
   170.              '0' => 8#20#,  '1' => 8#21#,  '2' => 8#22#,  '3' => 8#23#,
   171.              '4' => 8#24#,  '5' => 8#25#,  '6' => 8#26#,  '7' => 8#27#,
   172.              '8' => 8#30#,  '9' => 8#31#,  '_' => 8#32#,  '' => 8#33#,
   173.              ';' => 8#34#,  '+' => 8#35#,  '-' => 8#36#,  '.' => 8#37#,
   174.              '@' => 8#40#,  'A' => 8#41#,  'B' => 8#42#,  'C' => 8#43#,
   175.              'D' => 8#44#,  'E' => 8#45#,  'F' => 8#46#,  'G' => 8#47#,
   176.              'H' => 8#50#,  'I' => 8#51#,  'J' => 8#52#,  'K' => 8#53#,
   177.              'L' => 8#54#,  'M' => 8#55#,  'N' => 8#56#,  'O' => 8#57#,
   178.              'P' => 8#60#,  'Q' => 8#61#,  'R' => 8#62#,  'S' => 8#63#,
   179.              'T' => 8#64#,  'U' => 8#65#,  'V' => 8#66#,  'W' => 8#67#,
   180.              'X' => 8#70#,  'Y' => 8#71#,  'Z' => 8#72#,  '{' => 8#73#,
   181.              '}' => 8#74#,  E_M => 8#75#,  '\' => 8#76#,  W_F => 8#77#,
   182.              others => 0  -- This must be zero.
   183.             );
   184.
   185.    -- The Case Shift paper tape code:
   186.    TP_CS : constant output_code_table
   187.          := (' ',  '"',   LF,   FF,   HT,  '#',  C_S,  C_N,
   188.              '&',  '?',  '!',  '%',  ''',  '$',  '~',  ':',
   189.              '^',  '[',  ']',  '<',  '>',  '=',  '',  '',
   190.              '(',  ')',  '_',  '',  ';',  '',  '*',  ',',
   191.              '@',  'a',  'b',  'c',  'd',  'e',  'f',  'g',
   192.              'h',  'i',  'j',  'k',  'l',  'm',  'n',  'o',
   193.              'p',  'q',  'r',  's',  't',  'u',  'v',  'w',
   194.              'x',  'y',  'z',  '{',  '}',  E_M,  '\',  W_F
   195.             );
   196.
   197.    CS_TR : constant input_code_table
   198.          := (' ' => 8#00#,  '"' => 8#01#,   LF => 8#02#,   FF => 8#03#,
   199.               HT => 8#04#,  '#' => 8#05#,  C_S => 8#06#,  C_N => 8#07#,
   200.              '&' => 8#10#,  '?' => 8#11#,  '!' => 8#12#,  '%' => 8#13#,
   201.              ''' => 8#14#,  '$' => 8#15#,  '~' => 8#16#,  ':' => 8#17#,
   202.              '^' => 8#20#,  '[' => 8#21#,  ']' => 8#22#,  '<' => 8#23#,
   203.              '>' => 8#24#,  '=' => 8#25#,  '' => 8#26#,  '' => 8#27#,
   204.              '(' => 8#30#,  ')' => 8#31#,  '_' => 8#32#,  '' => 8#33#,
   205.              ';' => 8#34#,  '' => 8#35#,  '*' => 8#36#,  ',' => 8#37#,
   206.              '@' => 8#40#,  'a' => 8#41#,  'b' => 8#42#,  'c' => 8#43#,
   207.              'd' => 8#44#,  'e' => 8#45#,  'f' => 8#46#,  'g' => 8#47#,
   208.              'h' => 8#50#,  'i' => 8#51#,  'j' => 8#52#,  'k' => 8#53#,
   209.              'l' => 8#54#,  'm' => 8#55#,  'n' => 8#56#,  'o' => 8#57#,
   210.              'p' => 8#60#,  'q' => 8#61#,  'r' => 8#62#,  's' => 8#63#,
   211.              't' => 8#64#,  'u' => 8#65#,  'v' => 8#66#,  'w' => 8#67#,
   212.              'x' => 8#70#,  'y' => 8#71#,  'z' => 8#72#,  '{' => 8#73#,
   213.              '}' => 8#74#,  E_M => 8#75#,  '\' => 8#76#,  W_F => 8#77#,
   214.              others => 0  -- This must be zero.
   215.             );
   216.
   217.    function glyph_for (char : Character)
   218.    return Character
   219.    is (case char is
   220.            when LF     => '',
   221.            when FF     => '',
   222.            when HT     => '',
   223.            when others => char
   224.       );
   225.
   226.    --
   227.    -- Used when (un)packing 8-bit bytes for raw data I/O.
   228.    --
   229.
   230.    type octet_index is mod 6;
   231.
   232.    type octet is mod 2**8;
   233.
   234. end KDF9_char_sets;

 234 lines: No errors


Compiling: /home/parallels/emulation/Source/kdf9-store.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- KDF9 core store operations.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Unchecked_Conversion;
    18. --
    19. with KDF9.imaging;
    20. with KDF9.CPU;
    21.
    22. use  KDF9.imaging;
    23. use  KDF9.CPU;
    24.
    25. package body KDF9.store is
    26.
    27.    -- diagnose_invalid_address avoids secondary stack usage in the address validation procedures.
    28.    procedure diagnose_invalid_address (message : in String; address : in KDF9.word)
    29.       with Inline => False;
    30.
    31.    procedure diagnose_invalid_address (message : in String; address : in KDF9.word) is
    32.    begin
    33.       trap_illegal_instruction(message + "=" & address'Image);
    34.    end diagnose_invalid_address;
    35.
    36.    -- Check that EA, EA+BA are valid; LIV if invalid.
    37.    procedure validate_virtual_address (EA : in KDF9.Q_part)
    38.       with Inline => True;
    39.
    40.    procedure validate_virtual_address (EA : in KDF9.Q_part) is
    41.    begin
    42.       if EA > NOL and then the_CPU_state = program_state then
    43.          diagnose_invalid_address("NOL < virtual address", KDF9.word(EA));
    44.       end if;
    45.    end validate_virtual_address;
    46.
    47.    procedure if_user_mode_then_LOV (address_1 : KDF9.Q_part;
    48.                                     address_2 : KDF9.Q_part := 0;
    49.                                     solo      : Boolean     := True) is
    50.    begin
    51.       LOV_if_user_mode(
    52.                        if solo
    53.                        then "at #" & oct_of(address_1) + "(E" & dec_of(address_1) & ")"
    54.                        else "in #" & oct_of(address_1) & "..#" & oct_of(address_2)
    55.                       );
    56.    end if_user_mode_then_LOV;
    57.
    58.    function group (PA : KDF9.Q_part)
    59.    return KDF9.Q_part
    60.    is (PA / group_size);
    61.
    62.    procedure check_address_and_lockout (EA : in KDF9.Q_part) is
    63.       PA : constant KDF9.Q_part := EA + BA;
    64.    begin
    65.       validate_virtual_address(EA);
    66.       if locked_out(group(PA)) then
    67.          the_locked_out_address := PA;
    68.          if the_CPU_state /= Director_state then
    69.             if_user_mode_then_LOV(PA);
    70.          end if;
    71.       end if;
    72.    end check_address_and_lockout;
    73.
    74.    procedure validate_address_range (EA1, EA2 : in KDF9.Q_part) is
    75.    begin
    76.       if EA1 > EA2 then
    77.          diagnose_invalid_address("initial address > final address", KDF9.word(EA2));
    78.       end if;
    79.       validate_virtual_address(EA1);
    80.       validate_virtual_address(EA2);
    81.    end validate_address_range;
    82.
    83.    procedure check_addresses_and_lockouts (EA1, EA2 : in KDF9.Q_part) is
    84.        PA1 : constant KDF9.Q_part := EA1 + BA;
    85.        PA2 : constant KDF9.Q_part := EA2 + BA;
    86.    begin
    87.       validate_address_range (EA1, EA2);
    88.       if there_are_locks_in_physical_addresses(KDF9.Q_register'(C => 0, I => PA1, M => PA2)) then
    89.          if the_CPU_state /= Director_state then
    90.             if_user_mode_then_LOV(PA1, PA2, solo => False);
    91.          end if;
    92.       end if;
    93.    end check_addresses_and_lockouts;
    94.
    95.    function virtual_word_address (A1, A2 : in KDF9.Q_part)
    96.    return KDF9.address is
    97.    begin
    98.       return KDF9.address((KDF9.word(A1) + KDF9.word(A2)) and address_mask);
    99.    end virtual_word_address;
   100.
   101.    function signed is new Ada.Unchecked_Conversion (KDF9.Q_part, CPU.signed_Q_part);
   102.    function design is new Ada.Unchecked_Conversion (CPU.signed_Q_part, KDF9.Q_part);
   103.
   104.    -- A2 must be treated as a signed number.
   105.    function virtual_halfword_address (A1, A2 : in KDF9.Q_part)
   106.    return KDF9.address is
   107.    begin
   108.       return KDF9.address((KDF9.word(A1) + KDF9.word(design(signed(A2)/2))) and address_mask);
   109.    end virtual_halfword_address;
   110.
   111.    function fetch_symbol (EA : KDF9.address; index : KDF9_char_sets.symbol_index)
   112.    return KDF9_char_sets.symbol
   113.    is (KDF9_char_sets.symbol(shift_word_right(core(EA+BA), 42 - 6*Natural(index)) and 8#77#));
   114.
   115.    procedure store_symbol (value : in KDF9_char_sets.symbol;
   116.                            EA    : in KDF9.address;
   117.                            index : in KDF9_char_sets.symbol_index) is
   118.       place  : constant Natural   := 42 - 6*Natural(index);
   119.       mask   : constant KDF9.word := not shift_word_left(8#77#, place);
   120.       symbol : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   121.    begin
   122.       core(EA+BA) := (core(EA+BA) and mask) or symbol;
   123.    end store_symbol;
   124.
   125.    function fetch_octet (EA : KDF9.address; index : KDF9_char_sets.octet_index)
   126.    return KDF9_char_sets.octet is
   127.       place : constant Natural := 40 - 8*Natural(index);
   128.    begin
   129.       return KDF9_char_sets.octet(shift_word_right(core(EA+BA), place) and 8#377#);
   130.    end fetch_octet;
   131.
   132.    procedure store_octet  (value : in KDF9_char_sets.octet;
   133.                            EA    : in KDF9.address;
   134.                            index : in KDF9_char_sets.octet_index) is
   135.       place : constant Natural   := 40 - 8*Natural(index);
   136.       octet : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   137.       mask  : constant KDF9.word := not shift_word_left(8#377#, place);
   138.    begin
   139.       core(EA+BA) := (core(EA+BA) and mask) or octet;
   140.    end store_octet;
   141.
   142.    function fetch_syllable (EA : KDF9.syllable_address)
   143.    return KDF9.syllable is
   144.       address : constant KDF9.address := Q_part(EA.code_address) + BA;
   145.       place   : constant Natural      := 40 - 8*Natural(EA.syllable_index);
   146.    begin
   147.       return KDF9.syllable(shift_word_right(core(address), place) and 8#377#);
   148.    end fetch_syllable;
   149.
   150.    procedure store_syllable (value : in KDF9.syllable;
   151.                              EA    : in KDF9.address;
   152.                              index : in KDF9.syllable_index) is
   153.       place    : constant Natural   := 40 - 8*Natural(index);
   154.       syllable : constant KDF9.word := shift_word_left(KDF9.word(value), place);
   155.       mask     : constant KDF9.word := not shift_word_left(8#377#, place);
   156.    begin
   157.       core(EA+BA) := (core(EA+BA) and mask) or syllable;
   158.    end store_syllable;
   159.
   160.    function fetch_halfword (EA : KDF9.address; index : KDF9.halfword_number)
   161.    return KDF9.word
   162.    is (shift_word_left(shift_word_right(core(EA+BA), 24 - 24*Natural(index)), 24));
   163.
   164.    procedure store_halfword (value : in KDF9.word;
   165.                              EA    : in KDF9.address;
   166.                              index : in KDF9.halfword_number) is
   167.       place   : constant Natural   := 24 - 24*Natural(index);
   168.       half    : constant KDF9.word := shift_word_left(shift_word_right(value, 24), place);
   169.       mask    : constant KDF9.word := not shift_word_left(halfword_mask, place);
   170.    begin
   171.       core(EA+BA) := (core(EA+BA) and mask) or half;
   172.    end store_halfword;
   173.
   174.    function fetch_word (EA : KDF9.address)
   175.    return KDF9.word
   176.    is (core(EA+BA));
   177.
   178.    procedure store_word (value : in KDF9.word; EA : in KDF9.address) is
   179.    begin
   180.       core(EA+BA) := value;
   181.    end store_word;
   182.
   183.    function there_are_locks_in_relative_addresses (Q : KDF9.Q_register)
   184.    return Boolean is
   185.    begin
   186.       validate_address_range (Q.I, Q.M);
   187.       return there_are_locks_in_physical_addresses((0, Q.I+BA, Q.M+BA));
   188.    end there_are_locks_in_relative_addresses;
   189.
   190.    function there_are_locks_in_physical_addresses (Q : KDF9.Q_register)
   191.    return Boolean is
   192.    begin
   193.       for g in group(Q.I) .. group(Q.M) loop
   194.          if locked_out(g) then
   195.             the_locked_out_address := g * group_size;
   196.             return True;
   197.          end if;
   198.       end loop;
   199.       return False;
   200.    end there_are_locks_in_physical_addresses;
   201.
   202.    function is_unlocked (G : KDF9.store.group_address)
   203.    return Boolean is
   204.    begin
   205.       return not locked_out(KDF9.Q_part(G));
   206.    end is_unlocked;
   207.
   208.    procedure lock_out_relative_addresses (Q : in KDF9.Q_register) is
   209.    begin
   210.       validate_address_range (Q.I, Q.M);
   211.       lock_out_absolute_addresses((0, Q.I+BA, Q.M+BA));
   212.    end lock_out_relative_addresses;
   213.
   214.    procedure lock_out_absolute_addresses (Q : in KDF9.Q_register) is
   215.    begin
   216.       for g in group(Q.I) .. group(Q.M) loop
   217.          locked_out(g) := True;
   218.       end loop;
   219.    end lock_out_absolute_addresses;
   220.
   221.    procedure unlock_absolute_addresses (Q : in KDF9.Q_register) is
   222.    begin
   223.       for g in group(Q.I) .. group(Q.M) loop
   224.          locked_out(g) := False;
   225.       end loop;
   226.    end unlock_absolute_addresses;
   227.
   228. end KDF9.store;

Compiling: ../Source/kdf9-store.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- KDF9 core store operations.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9_char_sets;
    18.
    19. use  KDF9_char_sets;
    20.
    21. package KDF9.store is
    22.
    23.    --
    24.    -- Relative addresses may be either virtual or physical.
    25.    -- Virtual addresses are generated by problem programs and must be relativized by adding BA.
    26.    -- These addresses must also be validated to ensure they do not breach store limits.
    27.    -- Physical "relative" addresses are generated by Director, when BA is guaranteed to be 0,
    28.    --   so it has no effect, thus allowing the relative address routines to be used.
    29.    --
    30.    -- Absolute addresses are generated by I/O Control, which may be doing a transfer for either
    31.    --   a Director or a problem program, and must therefore ensure that BA is not added.
    32.    --
    33.
    34.    --
    35.    -- Parameters named EA are Effective "relative" Addresses.
    36.    --
    37.
    38.    function fetch_symbol (EA : KDF9.address; index : KDF9_char_sets.symbol_index)
    39.    return KDF9_char_sets.symbol;
    40.
    41.    function fetch_octet (EA : KDF9.address; index : KDF9_char_sets.octet_index)
    42.    return KDF9_char_sets.octet
    43.       with Inline;
    44.
    45.    function fetch_syllable (EA : KDF9.syllable_address)
    46.    return KDF9.syllable
    47.       with Inline;
    48.
    49.    function fetch_halfword (EA : KDF9.address; index : KDF9.halfword_number)
    50.    return KDF9.word
    51.       with Inline;
    52.
    53.    function fetch_word (EA : KDF9.address)
    54.    return KDF9.word
    55.       with Inline;
    56.
    57.    procedure store_symbol (value : in KDF9_char_sets.symbol;
    58.                            EA    : in KDF9.address;
    59.                            index : in KDF9_char_sets.symbol_index)
    60.       with Inline;
    61.
    62.    procedure store_octet  (value : in KDF9_char_sets.octet;
    63.                            EA    : in KDF9.address;
    64.                            index : in KDF9_char_sets.octet_index)
    65.       with Inline;
    66.
    67.    procedure store_syllable (value : in KDF9.syllable;
    68.                              EA    : in KDF9.address;
    69.                              index : in KDF9.syllable_index)
    70.       with Inline;
    71.
    72.    procedure store_halfword (value : in KDF9.word;
    73.                              EA    : in KDF9.address;
    74.                              index : in KDF9.halfword_number)
    75.       with Inline;
    76.
    77.    procedure store_word (value : in KDF9.word; EA : in KDF9.address)
    78.       with Inline;
    79.
    80.    -- Compute A1+A2 as a valid word address, mod 32K.
    81.    function virtual_word_address (A1, A2 : in KDF9.Q_part)
    82.    return KDF9.address
    83.       with Inline;
    84.
    85.    -- Check that A1+A2/2 as a valid word address, mod 32K.  A2 is treated as a signed number.
    86.    function virtual_halfword_address (A1, A2 : in KDF9.Q_part)
    87.    return KDF9.address
    88.       with Inline;
    89.
    90.    -- If a store access is locked out, its physical address is left here.
    91.    the_locked_out_address : KDF9.Q_part;
    92.
    93.    procedure if_user_mode_then_LOV (address_1 : KDF9.Q_part;
    94.                                     address_2 : KDF9.Q_part := 0;
    95.                                     solo      : Boolean     := True)
    96.       with Inline => False;
    97.
    98.    -- Check EA and lockout for EA.
    99.    procedure check_address_and_lockout (EA : in KDF9.Q_part)
   100.       with Inline;
   101.
   102.    -- Check that EA1, EA2, EA1+BA, EA2+BA are valid, and EA1 <= EA2.
   103.    --    LIV in any invalid case.
   104.    procedure validate_address_range (EA1, EA2 : in KDF9.Q_part);
   105.
   106.    -- Check EA1, EA2, and lockouts for EA1+BA .. EA2+BA.
   107.    procedure check_addresses_and_lockouts (EA1, EA2 : in KDF9.Q_part);
   108.
   109.    function there_are_locks_in_relative_addresses (Q : KDF9.Q_register)
   110.    return Boolean;
   111.
   112.    function there_are_locks_in_physical_addresses (Q : KDF9.Q_register)
   113.    return Boolean;
   114.
   115.    procedure lock_out_relative_addresses (Q : in KDF9.Q_register);
   116.
   117.    procedure lock_out_absolute_addresses (Q : in KDF9.Q_register);
   118.
   119.    procedure unlock_absolute_addresses (Q : in KDF9.Q_register);
   120.
   121.    -- The group size of 32 words is 1 physical core allocation unit and physical lockout unit.
   122.    group_size : constant := 32;
   123.
   124.    type group_address is mod 1024;
   125.
   126.     -- is_unlocked yields True if the designated group is NOT locked out.
   127.    function is_unlocked (G : KDF9.store.group_address)
   128.    return Boolean;
   129.
   130.    function group (PA : KDF9.Q_part)
   131.    return KDF9.Q_part
   132.       with Inline;
   133.
   134. private
   135.
   136.    type word_array is array (KDF9.Q_part range <>) of KDF9.word
   137.       with Component_Size => 64, Convention => C;
   138.
   139.    -- The core store of KDF9.  Must be zeroized before loading any software.
   140.    core : word_array (KDF9.Q_part range 0 .. KDF9.address'Last) := (others => 0);
   141.
   142.    -- The lockout store has one bit for every group_size words.
   143.    last_lockout : constant := KDF9.address'Last / group_size;
   144.    locked_out   : array (KDF9.Q_part range 0 .. last_lockout) of Boolean := (others => False);
   145.
   146. end KDF9.store;

 228 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/imported_value_of.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- Get the value of an environment variable.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Environment_Variables;
    18.
    19. function imported_value_of (name : in String; default : in String := "")
    20. return String is
    21. begin
    22.    return Ada.Environment_Variables.Value(name, default);
    23. end imported_value_of;

 23 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/os_specifics.adb
Source file time stamp: 2022-09-15 14:07:59
Compiled at: 2022-09-15 15:08:03

     1. -- Specific feature values and operation for the console terminal streams.
     2. -- This is the Linux, macOS and UNIX version.
     3. --
     4. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package body OS_specifics is
    19.
    20.    procedure make_transparent (fd : in Integer) is null;
    21.
    22.    function EOL
    23.    return String
    24.    is (1 => Character'Val(16#0A#));
    25.
    26.    function UI_in_name
    27.    return String
    28.    is ("/dev/tty");
    29.
    30.    function UI_out_name
    31.    return String
    32.    is ("/dev/tty");
    33.
    34. end OS_specifics;

Compiling: ../Source/os_specifics.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- Specific feature values and operation for the console terminal streams.
     2. -- This specification is the same for Windows, Linux, macOS and UNIX versions of ee9.
     3. --
     4. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package OS_specifics is
    19.
    20.    -- make_transparent sets the "binary" mode of I/O on Windows/Cygwin.
    21.    -- It does nothing on UNIX-family systems, where no such precaution is necessary.
    22.    procedure make_transparent (fd : in Integer);
    23.
    24.    -- UI_in_name returns the interactive input device name appropriate to the host OS, e.g.:
    25.    -- "/dev/tty"  for macOS/UNIX/Linux,
    26.    -- "CONIN$" for Windows.
    27.    function UI_in_name
    28.    return String;
    29.
    30.    -- UI_out_name returns the interactive output device name appropriate to the host OS, e.g.:
    31.    -- "/dev/tty"  for macOS/UNIX/Linux,
    32.    -- "CONOUT$" for Windows.
    33.    function UI_out_name
    34.    return String;
    35.
    36.    -- EOL returns the appropriate line terminator for the selected host OS, e.g.:
    37.    -- LF for macOS/UNIX/Linux,
    38.    -- CRLF for Windows.
    39.    function EOL
    40.    return String;
    41.
    42. end OS_specifics;

 34 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9_char_sets-framed.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- Convert a 6-bit KDF9 character to an 8-channel paper tape code frame.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- This program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. function KDF9_char_sets.framed (symbol : KDF9_char_sets.symbol)
    18. return Character is
    19.
    20.    parity_bits  : constant Natural := 2#00_010_000#;
    21.    channel_bits : constant Natural := 2#10_000_000#;
    22.    channel_8    : constant Natural := (if symbol = 0 then channel_bits else 0);
    23.    low_4_bits   : constant Natural := Natural(symbol and 2#001_111#);
    24.    top_2_bits   : constant Natural := Natural(symbol and 2#110_000#) * 2;
    25.
    26.    datum  : Natural;
    27.    parity : Natural;
    28.
    29. begin -- framed
    30.    if symbol = 0 then
    31.       parity := parity_bits;
    32.    else
    33.       datum := Natural(symbol); parity := 0;
    34.       while datum /= 0 loop
    35.          parity := parity + Natural(datum mod 2);
    36.          datum  := datum / 2;
    37.       end loop;
    38.       parity := (if parity mod 2 = 0 then 0 else parity_bits);
    39.    end if;
    40.    return Character'Val(channel_8 + top_2_bits + parity + low_4_bits);
    41. end KDF9_char_sets.framed;

 41 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/finalize_ee9.adb
Source file time stamp: 2022-09-06 22:35:51
Compiled at: 2022-09-15 15:08:03

     1. -- Shut down processing in preparation for a dignified exit.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Exceptions;
    18. --
    19. with HCI;
    20. with IOC;
    21. with logging.file;
    22. with logging.panel;
    23. with settings;
    24. with state_display;
    25.
    26. use  HCI;
    27. use  IOC;
    28. use  logging.file;
    29. use  logging.panel;
    30. use  settings;
    31. use  state_display;
    32.
    33. procedure finalize_ee9 (because : in String := "") is
    34.    core_file_name : constant String := "pascal_core";
    35.    reason         : constant String := (if because = "" then "Normal end of run" else because);
    36. begin
    37.    show_final_state(reason);
    38.    finalize_all_KDF9_buffers;
    39.    if core_file_is_enabled and because /= "" then
    40.       -- Make a final state dump for POST.
    41.       close(panel_logger);
    42.       close(file_logger);
    43.       open(file_logger, core_file_name);
    44.       show_final_state(reason);
    45.       save_core_image;
    46.       close(file_logger);
    47.    end if;
    48. exception
    49.    when error : others =>
    50.       log_line("Failure: " & Ada.Exceptions.Exception_Information(error));
    51. end finalize_ee9;

 51 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/disassembly-symbols.adb
Source file time stamp: 2022-09-06 22:03:34
Compiled at: 2022-09-15 15:08:03

     1. -- Map object code addresses to Usercode data_label addresses.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9.imaging;
    18. with string_editing;
    19.
    20. use  KDF9.imaging;
    21. use  string_editing;
    22.
    23. package body disassembly.symbols is
    24.
    25.    T : non_V_store_table renames the_WYZ_table;
    26.
    27.    procedure set_whole_program_data (size, E0_jump : in KDF9.word) is
    28.       safe_size   : constant KDF9.Q_part := KDF9.Q_part(size and 32767);
    29.       -- Construct an address from the jump order.
    30.       module_bit  : constant KDF9.word := E0_jump / 2**7 and 4096;
    31.       word_number : constant KDF9.word :=  E0_jump and 4095;
    32.       code_base   : constant KDF9.code_address := KDF9.code_address(module_bit + word_number);
    33.    begin
    34.       T.data_max := safe_size;
    35.       T.Z_base := safe_size-1;
    36.       if T.data_max <= 8191 then
    37.          T.code_max := KDF9.code_address(T.data_max);
    38.       else
    39.          T.code_max := 8191;
    40.       end if;
    41.       T.code_max := KDF9.code_address'Max(T.code_max, code_base);
    42.       if code_base > 8 then
    43.          P_store_base(0).V_address := 8;
    44.       else
    45.          P_store_base(0).V_address := 0;
    46.       end if;
    47.       P_store_base(0).P_address := KDF9.Q_part(code_base);
    48.       P_store_base(0).V_max := (if code_base <= 8 then 0 else Natural(code_base) - 8);
    49.    end set_whole_program_data;
    50.
    51.    function  get_whole_program_size
    52.    return KDF9.Q_part
    53.    is (T.Z_base and KDF9.address'Last);
    54.
    55.    procedure set_Y_size (size : in KDF9.Q_part) is
    56.    begin
    57.       T.Y_size := size;
    58.    end set_Y_size;
    59.
    60.    procedure set_W0 (address : in KDF9.Q_part) is
    61.    begin
    62.       T.W_base := address;
    63.    end set_W0;
    64.
    65.    procedure set_Y0 (address : in KDF9.Q_part) is
    66.    begin
    67.       T.Y_base := address;
    68.    end set_Y0;
    69.
    70.    procedure set_Yy0 (y : in Y_store_id; address : in KDF9.Q_part) is
    71.    begin
    72.       T.Yy_base(y) := address;
    73.    end set_Yy0;
    74.
    75.    P0_was_missing : Boolean := True;
    76.
    77.    procedure set_Z0 (address : in KDF9.Q_part) is
    78.       a : KDF9.Q_part;
    79.    begin
    80.       T.Z_base := address;
    81.       if T.Y_size = 0 or T.Y_base = KDF9.Q_part'Last then
    82.          T.Z_min := T.Z_base - 64;  -- This is an arbitrary allowance.
    83.       else
    84.          T.Z_min := T.Y_base + T.Y_size;
    85.       end if;
    86.
    87.       -- Z0 is the last regional symbol to be defined, so we can now bound the code and data areas.
    88.       a := KDF9.Q_part'Min(8191, T.Y_base);
    89.       a := KDF9.Q_part'Min(a, T.Yy_base('A'));
    90.       a := KDF9.Q_part'Min(a, T.W_base-1);
    91.       -- a is guaranteed to be < 8192.
    92.       T.code_max := KDF9.code_address(a);
    93.
    94.       T.Y_last := T.Y_base + T.Y_size;
    95.       T.data_max := KDF9.Q_part'Min(T.Z_base, 32767);
    96.       T.data_max := KDF9.Q_part'Min(T.Y_last, T.data_max);
    97.
    98.       if P0_was_missing then
    99.          P_store_base(0).P_address := 8 + KDF9.address(P_store_base(0).V_max);
   100.       end if;
   101.    end set_Z0;
   102.
   103.    procedure set_main_program_V_size (V_max : in Natural) is
   104.    begin
   105.       P_store_base(0).P_address := 0;
   106.       P_store_base(0).P_number := 0;
   107.       P_store_base(0).V_max := set_main_program_V_size.V_max;
   108.       P_store_base(0).V_address := 8;
   109.       P_store_base(1) := (8191, 8191, 8191, 8191);
   110.    end set_main_program_V_size;
   111.
   112.    procedure site_P0 (P_address : in KDF9.Q_part) is
   113.    begin
   114.       P_store_base(0).P_address := site_P0.P_address;
   115.       P0_was_missing := False;
   116.    end site_P0;
   117.
   118.    procedure site_Pp (P_number : in Natural; P_address : in KDF9.Q_part) is
   119.    begin
   120.       -- Handle P0 declarations specially.
   121.       if P_number = 0 then site_P0(P_address); return; end if;
   122.       last_P_number := last_P_number + 1;
   123.       if last_P_number = P_store_base'Last then
   124.          raise Program_Error with "number of P store bases >" & Integer'Image(P_store_base'Last-1);
   125.       end if;
   126.       P_store_base(last_P_number)   := (P_number, 0, P_address, 0);
   127.       P_store_base(last_P_number+1) := (8191, 8191, 8191, 8191);
   128.    end site_Pp;
   129.
   130.    procedure site_Pp (P_number : in Natural; P_address : in KDF9.Q_part; V_max : in Natural) is
   131.       V_address : constant KDF9.Q_part := P_address - KDF9.Q_part(V_max + 1);
   132.    begin
   133.       -- Handle P0 declarations specially.
   134.       if P_number = 0 then site_P0(P_address); return; end if;
   135.       last_P_number := last_P_number + 1;
   136.       if last_P_number = P_store_base'Last then
   137.          raise Program_Error with "number of P store bases >" & Integer'Image(P_store_base'Last-1);
   138.       end if;
   139.       P_store_base(last_P_number)   := (P_number, V_max, P_address, V_address);
   140.       P_store_base(last_P_number+1) := (8191, 8191, 8191, 8191);
   141.    end site_Pp;
   142.
   143.    function Y_symbol (address : KDF9.Q_part)
   144.    return String is
   145.       last_Y : KDF9.Q_part := KDF9.Q_part'Last;
   146.    begin
   147.       if T.Y_base = KDF9.Q_part'Last then
   148.          for y in reverse Y_store_id loop
   149.             if T.Yy_base(y) < KDF9.Q_part'Last then
   150.                last_Y := T.Yy_base(y);
   151.          exit;
   152.             end if;
   153.          end loop;
   154.       else
   155.          last_Y := T.Y_base;
   156.       end if;
   157.
   158.       if last_Y = KDF9.Q_part'Last then
   159.          return "Z" & trimmed(KDF9.Q_part'Image(T.Z_base - address));
   160.       end if;
   161.
   162.       if address >= T.Y_base then
   163.          return "Y" & trimmed(KDF9.Q_part'Image(address - T.Y_base));
   164.       end if;
   165.
   166.       for y in reverse Y_store_id loop
   167.          if address >= T.Yy_base(y) then
   168.             return "Y" & y & trimmed(KDF9.Q_part'Image(address - T.Yy_base(y))) ;
   169.          end if;
   170.       end loop;
   171.
   172.       if address >= T.W_base then
   173.          return "W" & trimmed(KDF9.Q_part'Image(address - T.W_base));
   174.       end if;
   175.       return "";
   176.    end Y_symbol;
   177.
   178.    function V_symbol (address : KDF9.Q_part)
   179.    return String is
   180.    begin
   181.       if address > 7 then
   182.          for p in reverse 0 .. last_P_number loop
   183.             if P_store_base(p).V_address /= 0                                  and then
   184.                address in P_store_base(p).V_address .. P_store_base(p).P_address-1 then
   185.                return "V"
   186.                     & trimmed(KDF9.Q_part'Image(address - P_store_base(p).V_address))
   187.                     & "P"
   188.                     & trimmed(Natural'Image(P_store_base(p).P_number));
   189.             end if;
   190.          end loop;
   191.       end if;
   192.       return "";
   193.    end V_symbol;
   194.
   195.    function V_store_count (address : KDF9.syllable_address)
   196.    return Natural is
   197.    begin
   198.       for p in 0 .. last_P_number loop
   199.          if P_store_base(p).P_address = KDF9.Q_part(address.code_address) then
   200.             return (if P_store_base(p).V_address = 0 then 0 else Natural(P_store_base(p).V_max+1));
   201.          end if;
   202.       end loop;
   203.       return 0; -- raise error??
   204.    end V_store_count;
   205.
   206.    function SET_operand (value : KDF9.Q_part; in_octal : Boolean)
   207.    return String is
   208.       smallish : constant Boolean := value < 256 or value > KDF9.Q_part'Last - 256;
   209.       negative : constant Boolean := value > 2**15 - 1;
   210.       place    : constant String  := oct_or_dec_of(value, in_octal);
   211.       E_store  : constant String  := "E" & place;
   212.       Y_store  : constant String  := Y_symbol(value);
   213.       name     : constant String  := (if Y_store = "" then V_symbol(value) else Y_store);
   214.       basis    : constant String  := (if smallish then place elsif name = "" then E_store else name);
   215.    begin
   216.       return
   217.          (if smallish or basis(basis'First) = 'E' then
   218.             (
   219.               if value < 8 then
   220.                  oct_of(value, 1)
   221.               elsif in_octal then
   222.                  "B"
   223.                & place(2..place'Last)
   224.                & (if value > 7 then ";("  & signed_dec_of(value) & ")" else "")
   225.               elsif negative then
   226.                  signed_dec_of(value)
   227.                & ";(#"
   228.                & oct_of(value, 1)
   229.                & ")"
   230.               else
   231.                  place
   232.                & (if value > 9 then ";(#" & oct_of(value, 1) & ")" else "")
   233.             )
   234.          else
   235.             "A"
   236.           & basis
   237.           & ";("
   238.           & oct_or_dec_of(value, not in_octal)
   239.           & ")"
   240.          );
   241.    end SET_operand;
   242.
   243.    function data_operand (address : KDF9.Q_part; in_octal : Boolean)
   244.    return String is
   245.       negative : constant Boolean := address > 2**15 - 10;
   246.       E_number : constant String  := (if negative
   247.                                       then Integer'Image(Integer(address) - 2**15)
   248.                                       else oct_and_dec_of(address, in_octal, ";(", ")")
   249.                                      );
   250.       E_store  : constant String := "E" & E_number;
   251.       Y_store  : constant String := Y_symbol(address);
   252.       name     : constant String := (if Y_store = "" then V_symbol(address) else Y_store);
   253.    begin
   254.       return (if name = "" or negative then E_store else name);
   255.    end data_operand;
   256.
   257.    function data_label (address : KDF9.Q_part; in_octal : Boolean)
   258.    return String is
   259.       E_name : constant String := "E" & oct_and_dec_of(address, in_octal, ", E", "");
   260.       name   : constant String := data_operand(address, in_octal);
   261.    begin
   262.       return (if name(1) = 'E' then E_name else name & ", " & E_name);
   263.    end data_label;
   264.
   265.    function code_operand (address : KDF9.syllable_address; in_octal : Boolean)
   266.    return String is
   267.    begin
   268.       for p in 0 .. last_P_number loop
   269.          if KDF9.Q_part(address.code_address) = P_store_base(p).P_address then
   270.             return "P" & trimmed(Natural'Image(P_store_base(p).P_number));
   271.          end if;
   272.       end loop;
   273.       return "E" & oct_or_dec_of(address, in_octal);
   274.    end code_operand;
   275.
   276.    function routine_name (address : KDF9.syllable_address; in_octal : Boolean)
   277.    return String is
   278.       word_address : constant KDF9.Q_part := KDF9.Q_part(address.code_address);
   279.       addendum     : constant String := "E" & oct_and_dec_of(word_address, in_octal, ", E", "");
   280.    begin
   281.       for p in 0 .. last_P_number loop
   282.          if word_address = P_store_base(p).P_address then
   283.             return "P"
   284.                  & trimmed(Natural'Image(P_store_base(p).P_number))
   285.                  & (
   286.                     if P_store_base(p).V_address /= 0
   287.                     then "V" & trimmed(P_store_base(p).V_max'Image)
   288.                     else ""
   289.                    )
   290.                  & ", "
   291.                  & addendum;
   292.          end if;
   293.       end loop;
   294.       return addendum;
   295.    end routine_name;
   296.
   297.    function a_routine_starts_at (address : KDF9.syllable_address)
   298.    return Boolean is
   299.       word_address : constant KDF9.Q_part := KDF9.Q_part(address.code_address);
   300.    begin
   301.       if last_P_number /= 0 then
   302.          for p in 0 .. last_P_number loop
   303.             if word_address = P_store_base(p).P_address then
   304.                return True;
   305.             end if;
   306.          end loop;
   307.       end if;
   308.       return False;
   309.    end a_routine_starts_at;
   310.
   311.    procedure clear_all_symbol_definitions is
   312.    begin
   313.       T.W_base   := 32767;
   314.       T.Yy_base := (others => 32767);
   315.       T.Y_base   := 32767;
   316.       T.Y_size   := 0;
   317.       T.Y_last   := 32767;
   318.       T.Z_min    := 32767;
   319.       T.Z_base   := 32767;
   320.       T.data_max := 32767;
   321.       T.code_max := 8191;
   322.       P_store_base  := (others => (0, 0, 0, 0));
   323.       last_P_number := 0;
   324.    end clear_all_symbol_definitions;
   325.
   326.    function bounded_code_address (address : KDF9.syllable_address)
   327.    return KDF9.syllable_address is
   328.       word_number : constant KDF9.code_address := address.code_address;
   329.    begin
   330.       return (KDF9.code_address'Min(T.code_max, word_number), 0);
   331.    end bounded_code_address;
   332.
   333.    function bounded_code_address (address : KDF9.Q_part)
   334.    return KDF9.syllable_address is
   335.       word_number : constant KDF9.code_address := KDF9.code_address(address);
   336.    begin
   337.       return bounded_code_address((word_number, 0));
   338.    end bounded_code_address;
   339.
   340.    function bounded_data_address (address : KDF9.Q_part)
   341.    return KDF9.Q_part is
   342.    begin
   343.       return KDF9.Q_part'Min(T.data_max, address);
   344.    end bounded_data_address;
   345.
   346. end disassembly.symbols;

Compiling: ../Source/disassembly-symbols.ads
Source file time stamp: 2022-09-06 21:53:24
Compiled at: 2022-09-15 15:08:03

     1.  -- Map object code addresses to Usercode data_label addresses.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package disassembly.symbols is
    18.
    19.    procedure clear_all_symbol_definitions;
    20.
    21.    procedure set_whole_program_data (size, E0_jump : in KDF9.word);
    22.    function  get_whole_program_size return KDF9.Q_part;
    23.
    24.    subtype Y_store_id is Character range 'A' ..'Z';
    25.
    26.    procedure set_main_program_V_size (V_max : in Natural);
    27.    procedure set_W0 (address : in KDF9.Q_part);
    28.    procedure set_Y0 (address : in KDF9.Q_part);
    29.    procedure set_Y_size (size : in KDF9.Q_part);
    30.    procedure set_Yy0 (y : in Y_store_id; address : in KDF9.Q_part);
    31.    procedure set_Z0 (address : in KDF9.Q_part);
    32.
    33.    procedure site_P0 (P_address : in KDF9.Q_part);
    34.    procedure site_Pp (P_number : in Natural; P_address : in KDF9.Q_part);
    35.    procedure site_Pp (P_number : in Natural; P_address : in KDF9.Q_part; V_max : in Natural);
    36.
    37.    function V_store_count (address : KDF9.syllable_address)
    38.    return Natural;
    39.
    40.    function code_operand (address : KDF9.syllable_address; in_octal : Boolean)
    41.    return String;
    42.
    43.    function data_operand (address : KDF9.Q_part; in_octal : Boolean)
    44.    return String;
    45.
    46.    function SET_operand (value : KDF9.Q_part; in_octal : Boolean)
    47.    return String;
    48.
    49.    function routine_name (address : KDF9.syllable_address; in_octal : Boolean)
    50.    return String;
    51.
    52.    function data_label (address : KDF9.Q_part; in_octal : Boolean)
    53.    return String;
    54.
    55.    function a_routine_starts_at (address : KDF9.syllable_address)
    56.    return Boolean;
    57.
    58.    function bounded_code_address (address : KDF9.syllable_address)
    59.    return KDF9.syllable_address;
    60.
    61.    function bounded_code_address (address : KDF9.Q_part)
    62.    return KDF9.syllable_address;
    63.
    64.    function bounded_data_address (address : KDF9.Q_part)
    65.    return KDF9.Q_part;
    66.
    67.    -- There physically cannot by more than 8191 routines.
    68.    subtype P_number_range is Natural range 0 .. 8191;
    69.
    70.    last_P_number : P_number_range := 0;
    71.
    72.    -- If V_address = 0 the routine has no V stores and V_max is unused.
    73.    type P_definition is
    74.    record
    75.       P_number  : Natural := 0;
    76.       V_max     : Natural := 0;
    77.       P_address : KDF9.Q_part := 0;
    78.       V_address : KDF9.Q_part := 0;
    79.    end record;
    80.
    81.    type P_definition_list is array (P_number_range range <>) of P_definition;
    82.
    83.    P_store_base : P_definition_list (P_number_range);
    84.
    85.    type address_list is array (Y_store_id) of KDF9.Q_part;
    86.
    87.    type non_V_store_table is
    88.       record
    89.          W_base   : KDF9.Q_part := 32767;
    90.          Yy_base  : address_list := (others => 32767);
    91.          Y_base   : KDF9.Q_part := 32767;
    92.          Y_size   : KDF9.Q_part := 0;
    93.          Y_last   : KDF9.Q_part := 32767;
    94.          Z_min    : KDF9.Q_part := 32767;
    95.          Z_base   : KDF9.Q_part := 32767;
    96.          data_max : KDF9.Q_part := 32767;
    97.          code_max : KDF9.code_address := 8191;
    98.       end record;
    99.
   100.    the_WYZ_table : non_V_store_table;
   101.
   102. end disassembly.symbols;

 346 lines: No errors


Compiling: /home/parallels/emulation/Source/disassembly.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- Produce dis-assembled instructions in an approximation to KDF9 Usercode.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9.imaging;
    18. with disassembly.symbols;
    19. with KDF9.CPU;
    20. with KDF9.decoding;
    21. with string_editing;
    22.
    23. use  KDF9.imaging;
    24. use  disassembly.symbols;
    25. use  KDF9.CPU;
    26. use  KDF9.decoding;
    27. use  string_editing;
    28.
    29. package body disassembly is
    30.
    31.    function flagged (flag : String; s : KDF9.syllable)
    32.    return String
    33.    is (flag & oct_of(s));
    34.
    35.    function machine_code (decoded : KDF9.decoded_order)
    36.    return String
    37.    is (
    38.        case decoded.kind is
    39.           when one_syllable_order => flagged("#", decoded.order.syllable_0),
    40.
    41.           when two_syllable_order => flagged("#", decoded.order.syllable_0)
    42.                                    & flagged(":", decoded.order.syllable_1),
    43.           when normal_jump_order
    44.              | data_access_order  => flagged("#", decoded.order.syllable_0)
    45.                                    & flagged(":", decoded.order.syllable_1)
    46.                                    & flagged(":", decoded.order.syllable_2)
    47.       );
    48.
    49.    function one_syllable_name (decoded : KDF9.decoded_order)
    50.    return String
    51.    is (
    52.        case decoded.compressed_opcode is
    53.           when ABS_9   => "ABS",
    54.           when ABSF    => "ABSF",
    55.           when AND_9   => "AND",
    56.           when BITS    => "BITS",
    57.           when CAB     => "CAB",
    58.           when CONT    => "CONT",
    59.           when DIV     => "/",
    60.           when DIVD    => "/D",
    61.           when DIVDF   => "/DF",
    62.           when DIVF    => "/F",
    63.           when DIVI    => "/I",
    64.           when DIVR    => "/R",
    65.           when DUMMY   => "DUMMY",
    66.           when DUP     => "DUP",
    67.           when DUPD    => "DUPD",
    68.           when ERASE   => "ERASE",
    69.           when FIX     => "FIX",
    70.           when FLOAT_9 => "FLOAT",
    71.           when FLOATD  => "FLOATD",
    72.           when FRB     => "FRB",
    73.           when MAX     => "MAX",
    74.           when MAXF    => "MAXF",
    75.           when MINUS   => "-",
    76.           when MINUSD  => "-D",
    77.           when MINUSDF => "-DF",
    78.           when MINUSF  => "-F",
    79.           when NEG     => "NEG",
    80.           when NEGD    => "NEGD",
    81.           when NEGDF   => "NEGDF",
    82.           when NEGF    => "NEGF",
    83.           when NEV     => "NEV",
    84.           when NOT_9   => "NOT",
    85.           when OR_9    => "OR",
    86.           when PERM    => "PERM",
    87.           when PLUS    => "+",
    88.           when PLUSD   => "+D",
    89.           when PLUSDF  => "+DF",
    90.           when PLUSF   => "+F",
    91.           when REV     => "REV",
    92.           when REVD    => "REVD",
    93.           when ROUND   => "ROUND",
    94.           when ROUNDF  => "ROUNDF",
    95.           when ROUNDH  => "ROUNDH",
    96.           when ROUNDHF => "ROUNDHF",
    97.           when SIGN    => "SIGN",
    98.           when SIGNF   => "SIGNF",
    99.           when STAND   => "STAND",
   100.           when STR     => "STR",
   101.           when TO_TR   => "=TR",
   102.           when TOB     => "TOB",
   103.           when VR      => "VR",
   104.           when X_frac  => "",
   105.           when XD      => "D",
   106.           when XDF     => "DF",
   107.           when XF      => "F",
   108.           when XPLUSF  => "+F",
   109.           when ZERO    => "ZERO",
   110.           when 0       => "DUMMY0",
   111.           when others  =>  machine_code(decoded)
   112.        );
   113.
   114.    function two_syllable_name (decoded : KDF9.decoded_order)
   115.    return String is
   116.
   117.       default : constant String := machine_code(decoded);
   118.       invalid : constant String := "";
   119.       k       : constant String := trimmed(decoded.Qk'Image);
   120.       q       : constant String := trimmed(decoded.Qq'Image);
   121.       opcode  : constant KDF9.compressed_opcode := (decoded.Qk and not manual_bit);
   122.       CT      : constant Boolean := (decoded.Qk and manual_bit) = 0;
   123.
   124.       function IO_order (stem : String)
   125.       return String
   126.       is (if stem = invalid then default else stem & "Q" & q);
   127.
   128.       function IO_name
   129.       return String
   130.       is (
   131.           case decoded.compressed_opcode is
   132.                when PIA_PIC_CLO_TLO_Qq =>
   133.                                    IO_order(case opcode is
   134.                                                when PIA_bits => "PIA",
   135.                                                when PIC_bits => "PIC",
   136.                                                when CLO_bits => "CLO",
   137.                                                when TLO_bits => "TLO",
   138.                                                when others   => invalid),
   139.                when PIB_PID_Qq =>
   140.                                    IO_order(case opcode is
   141.                                                when PIB_bits => "PIB",
   142.                                                when PID_bits => "PID",
   143.                                                when others   => invalid),
   144.                when PIE_PIG_Qq =>
   145.                                    IO_order(case opcode is
   146.                                                when PIE_bits => "PIE",
   147.                                                when PIG_bits => "PIG",
   148.                                                when others   => invalid),
   149.                when PIF_PIH_Qq =>
   150.                                    IO_order(case opcode is
   151.                                                when PIF_bits => "PIF",
   152.                                                when PIH_bits => "PIH",
   153.                                                when others   => invalid),
   154.                when PMA_PMK_INT_Qq =>
   155.                                    IO_order(case opcode is
   156.                                                when PMA_bits => "PMA",
   157.                                                when PMK_bits => "PMK",
   158.                                                when INT_bits => "INT",
   159.                                                when others   => invalid),
   160.                when CT_PMB_PMC_BUSY_Qq =>
   161.                                    IO_order(case opcode is
   162.                                                when PMB_bits  => "PMB",
   163.                                                when PMC_bits  => "PMC",
   164.                                                when BUSY_bits => "BUSY",
   165.                                                when CTQ_bits => (if CT then "CT" else "MANUAL"),
   166.                                                when others    => invalid),
   167.                when PMD_PME_PML_Qq =>
   168.                                    IO_order(case opcode is
   169.                                                when PMD_bits => "PMD",
   170.                                                when PME_bits => "PME",
   171.                                                when PML_bits => "PML",
   172.                                                when others   => invalid),
   173.                when PMF_PMG_Qq =>
   174.                                    IO_order(case opcode is
   175.                                                when PMF_bits => "PMF",
   176.                                                when PMG_bits => "PMG",
   177.                                                when others   => invalid),
   178.                when POA_POC_POE_POF_PMH_Qq =>
   179.                                    IO_order(case opcode is
   180.                                                when POA_bits => "POA",
   181.                                                when POC_bits => "POC",
   182.                                                when POE_bits => "POE",
   183.                                                when POF_bits => "POF",
   184.                                                when PMH_bits => "PMH",
   185.                                                when others   => invalid),
   186.                when POB_POD_Qq =>
   187.                                    IO_order(case opcode is
   188.                                                when POB_bits => "POB",
   189.                                                when POD_bits => "POD",
   190.                                                when others   => invalid),
   191.                when POG_POL_Qq =>
   192.                                    IO_order(case opcode is
   193.                                                when POG_bits => "POG",
   194.                                                when POL_bits => "POL",
   195.                                                when others   => invalid),
   196.                when POH_POK_Qq =>
   197.                                    IO_order(case opcode is
   198.                                                when POH_bits => "POH",
   199.                                                when POL_bits => "POK",
   200.                                                when others   => invalid),
   201.                when PAR_Qq =>      IO_order("PAR"),
   202.                when others =>      IO_order(invalid)
   203.          );
   204.
   205.       function indirect_store_name (suffix : String := "")
   206.       return String
   207.       is ("=M" & k & "M" & q & suffix);
   208.
   209.       function indirect_fetch_name (suffix : String := "")
   210.       return String
   211.       is ("M" & k & "M" & q & suffix);
   212.
   213.       function Qq_to_Qk_name (part : String)
   214.       return String
   215.       is (part & q & " TO Q" & k);
   216.
   217.       function Qq_name (action : String; suffix : String := "")
   218.       return String
   219.       is (action & q & suffix);
   220.
   221.       function shift_count
   222.       return String is
   223.          constant_flag : constant := 1;
   224.          fixed_shift   : CPU.signed_Q_part;
   225.       begin
   226.          if (decoded.order.syllable_1 and constant_flag) /= 0  then
   227.             fixed_shift := resign(KDF9.Q_part(decoded.order.syllable_1/2));
   228.             if fixed_shift > 63 then
   229.                fixed_shift := fixed_shift - 128;
   230.             end if;
   231.             return (if fixed_shift < 0 then "" else "+") & trimmed(fixed_shift'Image);
   232.          else
   233.             return "C" & q;
   234.          end if;
   235.       end shift_count;
   236.
   237.       function shift_name (action : String)
   238.       return String
   239.       is (action & shift_count);
   240.
   241.    begin -- two_syllable_name
   242.       return
   243.          (
   244.           case decoded.compressed_opcode is
   245.              when MkMq       => indirect_fetch_name,
   246.              when MkMqQ      => indirect_fetch_name(suffix => "Q"),
   247.              when MkMqH      => indirect_fetch_name(suffix => "H"),
   248.              when MkMqQH     => indirect_fetch_name(suffix => "QH"),
   249.              when MkMqN      => indirect_fetch_name(suffix => "N"),
   250.              when MkMqQN     => indirect_fetch_name(suffix => "QN"),
   251.              when MkMqHN     => indirect_fetch_name(suffix => "HN"),
   252.              when MkMqQHN    => indirect_fetch_name(suffix => "QHN"),
   253.
   254.              when TO_MkMq    => indirect_store_name,
   255.              when TO_MkMqQ   => indirect_store_name(suffix => "Q"),
   256.              when TO_MkMqH   => indirect_store_name(suffix => "H"),
   257.              when TO_MkMqQH  => indirect_store_name(suffix => "QH"),
   258.              when TO_MkMqN   => indirect_store_name(suffix => "N"),
   259.              when TO_MkMqQN  => indirect_store_name(suffix => "QN"),
   260.              when TO_MkMqHN  => indirect_store_name(suffix => "HN"),
   261.              when TO_MkMqQHN => indirect_store_name(suffix => "QHN"),
   262.
   263.              when M_PLUS_Iq  => Qq_name("M+I"),
   264.              when M_MINUS_Iq => Qq_name("M-I"),
   265.              when NCq        => Qq_name("NC"),
   266.              when DCq        => Qq_name("DC"),
   267.              when POS1_TO_Iq => Qq_name("I",  suffix => "=+1"),
   268.              when NEG1_TO_Iq => Qq_name("I",  suffix => "=-1"),
   269.              when POS2_TO_Iq => Qq_name("I",  suffix => "=+2"),
   270.              when NEG2_TO_Iq => Qq_name("I",  suffix => "=+2"),
   271.              when JCqNZS     => Qq_name("JC", suffix => "NZS"),
   272.
   273.              when MqTOQk     => Qq_to_Qk_name("M"),
   274.              when IqTOQk     => Qq_to_Qk_name("I"),
   275.              when IMqTOQk    => Qq_to_Qk_name("IM"),
   276.              when CqTOQk     => Qq_to_Qk_name("C"),
   277.              when CMqTOQk    => Qq_to_Qk_name("CM"),
   278.              when CIqTOQk    => Qq_to_Qk_name("CI"),
   279.              when QqTOQk     => Qq_to_Qk_name("Q"),
   280.              when QCIMq =>
   281.                 (
   282.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then  Qq_name("Q")
   283.                  elsif (decoded.Qk and M_part_choice) /= 0       then  Qq_name("M")
   284.                  elsif (decoded.Qk and C_part_choice) /= 0       then  Qq_name("C")
   285.                  elsif (decoded.Qk and I_part_choice) /= 0       then  Qq_name("I")
   286.                  else  default
   287.                 ),
   288.              when TO_RCIMq =>
   289.                 (
   290.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then Qq_name("=Q")
   291.                  elsif (decoded.Qk and M_part_choice) /= 0 then
   292.                     Qq_name(if (decoded.Qk and reset_choice) /= 0 then "=RM" else "=M")
   293.                  elsif (decoded.Qk and C_part_choice) /= 0 then
   294.                     Qq_name(if (decoded.Qk and reset_choice) /= 0 then "=RC" else "=C")
   295.                  elsif (decoded.Qk and I_part_choice) /= 0 then
   296.                     Qq_name(if (decoded.Qk and reset_choice) /= 0 then "=RI" else "=I")
   297.                  else default
   298.                 ),
   299.              when ADD_TO_QCIMq =>
   300.                 (
   301.                  if (decoded.Qk and all_Q_choice) = all_Q_choice then Qq_name("=+Q")
   302.                  elsif (decoded.Qk and M_part_choice) /= 0       then Qq_name("=+M")
   303.                  elsif (decoded.Qk and C_part_choice) /= 0       then Qq_name("=+C")
   304.                  elsif (decoded.Qk and I_part_choice) /= 0       then Qq_name("=+I")
   305.                  else  default
   306.                 ),
   307.
   308.              when SHA   => shift_name("SHA"),
   309.              when SHAD  => shift_name("SHAD"),
   310.              when MACC  => shift_name("+"),
   311.              when SHL   => shift_name("SHL"),
   312.              when SHLD  => shift_name("SHLD"),
   313.              when SHC   => shift_name("SHC"),
   314.
   315.              when TO_Kq =>
   316.                 (
   317.                  case decoded.Qq is
   318.                     when K0 => "=K0",
   319.                     when K1 => "=K1",
   320.                     when K2 => "=K2",
   321.                     when K3 => "=K3",
   322.                     when others => default
   323.                 ),
   324.              when Kk =>
   325.                 (
   326.                  case decoded.Qk is
   327.                    when K4 => "K4",
   328.                    when K5 => "K5",
   329.                    when K7 => "K7",
   330.                    when others => default
   331.                 ),
   332.
   333.              when LINK    => "LINK",
   334.              when TO_LINK => "=LINK",
   335.
   336.              when others  => IO_name
   337.           );
   338.    end two_syllable_name;
   339.
   340.    function closer (
   341.                     decoded  : KDF9.decoded_order;
   342.                     address  : KDF9.syllable_address := (0, 0);
   343.                     in_octal : Boolean := True
   344.                    )   return String
   345.    is (
   346.        if decoded.kind = normal_jump_order and decoded.compressed_opcode = JSr
   347.        then ";(LINK=" & oct_or_dec_of(address, in_octal) & "); "
   348.        else "; "
   349.       );
   350.
   351.    function normal_jump_name (
   352.                               decoded   : KDF9.decoded_order;
   353.                               in_octal  : Boolean := True
   354.                              )
   355.    return String is
   356.
   357.       the_target  : constant KDF9.syllable_address  := decoded.target;
   358.       the_symbol  : constant String := code_operand(the_target, in_octal);
   359.       num_remark  : constant String
   360.                   := (
   361.                       if   in_octal
   362.                       then ";("  & dec_of(KDF9.Q_part(the_target.code_address))
   363.                       else ";(#" & oct_of(the_target.code_address)
   364.                      )
   365.                   & ")";
   366.       sym_remark  : constant String
   367.                   := (
   368.                       if   in_octal
   369.                       then ";(#" & oct_of(the_target.code_address)
   370.                       else ";("  & dec_of(KDF9.Q_part(the_target.code_address))
   371.                      )
   372.                    & ")";
   373.       remark      : constant String
   374.                   := (if the_symbol(the_symbol'First) = 'E' then num_remark else sym_remark);
   375.
   376.       function jump (condition : String; name : String := "J")
   377.       return String
   378.       is (name & code_operand(the_target, in_octal) & condition & remark);
   379.
   380.       function leave (and_how : String)
   381.       return String
   382.       is ("EXIT" & and_how);
   383.
   384.    begin  -- normal_jump_name
   385.       return (
   386.               case decoded.compressed_opcode is
   387.                  when JrEQ   => jump("="),
   388.                  when JrGTZ  => jump("GTZ"),
   389.                  when JrLTZ  => jump("LTZ"),
   390.                  when JrEQZ  => jump("=Z"),
   391.                  when JrV    => jump("V"),
   392.                  when JrEN   => jump("EN"),
   393.                  when Jr     => jump(""),
   394.                  when JrEJ   => jump("EJ"),
   395.                  when JrTR   => jump("TR"),
   396.                  when JrNE   => jump(""),
   397.                  when JrLEZ  => jump("LEZ"),
   398.                  when JrGEZ  => jump("GEZ"),
   399.                  when JrNEZ  => jump("Z"),
   400.                  when JrNV   => jump("NV"),
   401.                  when JrNEN  => jump("NEN"),
   402.                  when JrNEJ  => jump("NEJ"),
   403.                  when JrNTR  => jump("NTR"),
   404.                  when JrCqZ  => jump("C" & trimmed(decoded.Qq'Image) & "Z"),
   405.                  when JrCqNZ => jump("C" & trimmed(decoded.Qq'Image) & "NZ"),
   406.                  when JSr    => jump("", name => "JS"),
   407.                  when OS_OUT => "OUT",
   408.                  when EXITD  => leave("D"),
   409.                  when EXIT_n =>
   410.                     -- Try to give the most helpful interpretation of the operand.
   411.                     (
   412.                      if the_target.syllable_index = 0 then  -- c.f. decode_a_jump_order.
   413.                         -- No halfword offset applies.
   414.                         (
   415.                          if the_target.code_address < 4 then
   416.                            leave(
   417.                                  if the_target.code_address = 0
   418.                                  then ""
   419.                                  else oct_of(KDF9.Q_part(2*the_target.code_address), 1)
   420.                                 )
   421.                          else
   422.                            leave("AE" & oct_or_dec_of((the_target.code_address, 0), in_octal))
   423.                         )
   424.                      elsif the_target.code_address < 4 then
   425.                         leave(oct_of(KDF9.Q_part(2*the_target.code_address + 1), 1))
   426.                      else
   427.                         leave("AE" & oct_or_dec_of((the_target.code_address, 3), in_octal))
   428.                     ),
   429.
   430.                  when others =>  machine_code(decoded)
   431.              );
   432.    end normal_jump_name;
   433.
   434.    function data_access_name (
   435.                               decoded       : KDF9.decoded_order;
   436.                               in_octal      : Boolean
   437.                              )
   438.    return String is
   439.       opcode        : constant KDF9.compressed_opcode := decoded.compressed_opcode;
   440.       operand       : KDF9.Q_part renames decoded.operand;
   441.       number        : constant String := oct_or_dec_of(operand, in_octal);
   442.       prefix        : constant String := (if in_octal then "#" else "E");
   443.       the_bare_name : constant String := (
   444.                                           if operand not in KDF9.address
   445.                                           then "E" & number
   446.                                           else data_operand(operand, in_octal)
   447.                                          );
   448.
   449.       Qq        : KDF9.Q_number    renames decoded.Qq;
   450.       M_suffix  : constant String  := (if Qq /= 0 then "M" & trimmed(Qq'Image) else "");
   451.       Q_suffix  : constant String  := (if opcode in EaMqQ | TO_EaMqQ then "Q" else "");
   452.       modifier  : constant String  := M_suffix & Q_suffix;
   453.       remark    : constant String
   454.                 := (
   455.                     if operand < 8 or the_bare_name(1) = 'E'
   456.                     then ""
   457.                     else ";(" & prefix  & number & ")"
   458.                    );
   459.
   460.       the_name : constant String := the_bare_name & modifier & remark;
   461.
   462.    begin
   463.       return
   464.              (
   465.               case opcode is
   466.                  when EaMq
   467.                     | EaMqQ    => the_name,
   468.                  when TO_EaMq
   469.                     | TO_EaMqQ => "=" & the_name,
   470.                  when SET      => "SET" & SET_operand(operand, in_octal),
   471.                  when others   => "?"
   472.              );
   473.    end data_access_name;
   474.
   475.    function the_full_name_of (order : KDF9.decoded_order; in_octal : Boolean)
   476.    return String is
   477.       result : constant String
   478.          := (
   479.              case order.kind is
   480.                 when one_syllable_order => one_syllable_name(order),
   481.                 when two_syllable_order => two_syllable_name(order),
   482.                 when normal_jump_order  => normal_jump_name(order, in_octal),
   483.                 when data_access_order  => data_access_name(order, in_octal)
   484.             );
   485.    begin
   486.       return (if result(1) /= '?' then result else "an INVALID order");
   487.    end the_full_name_of;
   488.
   489.    function the_code_and_name_of_INS
   490.    return String
   491.    is (machine_code(INS) & ", i.e. " & the_full_name_of(INS, in_octal => True));
   492.
   493.    function two_syllable_skeleton (encoding : KDF9.syllable)
   494.    return String is
   495.
   496.       function IO_skeleton
   497.       return String
   498.       is (
   499.           case encoding and 8#77# is
   500.              when POA_POC_POE_POF_PMH_Qq => "{POA|POC|POE|POF|PMH}Qq",
   501.              when PIA_PIC_CLO_TLO_Qq     => "{PIA|PIC|CLO|TLO}Qq",
   502.              when CT_PMB_PMC_BUSY_Qq     => "{BUSY|CT|MANUAL|PMB|PMC}Qq",
   503.              when PAR_Qq                 => "PARQq",
   504.              when PIB_PID_Qq             => "{PIB|PID}Qq",
   505.              when PIE_PIG_Qq             => "{PIE|PIG}Qq",
   506.              when PIF_PIH_Qq             => "{PIF|PIH}Qq",
   507.              when PMA_PMK_INT_Qq         => "{INT|PMA|PMK}Qq",
   508.              when PMD_PME_PML_Qq         => "{PMD|PME}Qq",
   509.              when PMF_PMG_Qq             => "{PMF|PMG}Qq",
   510.              when POB_POD_Qq             => "{POB|POD}Qq",
   511.              when POG_POL_Qq             => "{POG|POL}Qq",
   512.              when POH_POK_Qq             => "{POH|POK}Qq",
   513.              when others                 => "invalid IO group syllable #" & oct_of(encoding)
   514.          );
   515.
   516.    begin  -- two_syllable_skeleton
   517.       return
   518.          (
   519.           case encoding and 8#77# is
   520.              when MkMq         => "MkMq",
   521.              when MkMqQ        => "MkMqQ",
   522.              when MkMqH        => "MkMqH",
   523.              when MkMqQH       => "MkMqQH",
   524.              when MkMqN        => "MkMqN",
   525.              when MkMqQN       => "MkMqQN",
   526.              when MkMqHN       => "MkMqHN",
   527.              when MkMqQHN      => "MkMqQHN",
   528.
   529.              when TO_MkMq      => "=MkMq",
   530.              when TO_MkMqQ     => "=MkMqQ",
   531.              when TO_MkMqH     => "=MkMqH",
   532.              when TO_MkMqQH    => "=MkMqQH",
   533.              when TO_MkMqN     => "=MkMqN",
   534.              when TO_MkMqQN    => "=MkMqQN",
   535.              when TO_MkMqHN    => "=MkMqHN",
   536.              when TO_MkMqQHN   => "=MkMqQHN",
   537.
   538.              when JCqNZS       => "JCqNZS",
   539.              when M_PLUS_Iq    => "M+Iq",
   540.              when M_MINUS_Iq   => "M-Iq",
   541.              when NCq          => "NCq",
   542.              when DCq          => "DCq",
   543.              when POS1_TO_Iq   => "Iq=+1",
   544.              when NEG1_TO_Iq   => "Iq=-1",
   545.              when POS2_TO_Iq   => "Iq=+2",
   546.              when NEG2_TO_Iq   => "Iq=-2",
   547.
   548.              when MqTOQk       => "MqTOQk",
   549.              when IqTOQk       => "IqTOQk",
   550.              when IMqTOQk      => "IMqTOQk",
   551.              when CqTOQk       => "CqTOQk",
   552.              when CMqTOQk      => "CMqTOQk",
   553.              when CIqTOQk      => "CIqTOQk",
   554.              when QqTOQk       => "QqTOQk",
   555.
   556.              when QCIMq        => "{Q|C|I|M}q",
   557.              when TO_RCIMq     => "=[R]{Q|C|I|M}q",
   558.              when ADD_TO_QCIMq => "=+{Q|C|I|M}q",
   559.
   560.              when SHA          => "SHA",
   561.              when SHAD         => "SHAD",
   562.              when MACC         => "+",
   563.              when SHL          => "SHL",
   564.              when SHLD         => "SHLD",
   565.              when SHC          => "SHC",
   566.
   567.              when TO_Kq =>
   568.                 (
   569.                  case encoding / 16 mod 16 is
   570.                     when K0 => "=K0",
   571.                     when K1 => "=K1",
   572.                     when K2 => "=K2",
   573.                     when K3 => "=K3",
   574.                     when others => "=K?"
   575.                 ),
   576.              when Kk =>
   577.                 (
   578.                  case encoding mod 16 is
   579.                     when K4 => "K4",
   580.                     when K5 => "K5",
   581.                     when K7 => "K7",
   582.                     when others => "K?"
   583.                 ),
   584.
   585.              when LINK =>    "LINK",
   586.              when TO_LINK => "=LINK",
   587.
   588.              when others =>  IO_skeleton
   589.          );
   590.    end two_syllable_skeleton;
   591.
   592.    function normal_jump_skeleton (encoding : KDF9.syllable)
   593.    return String
   594.    is (
   595.        case encoding and 8#77# is
   596.           when JrCqZ  .. JrCqZ+2#1111#  => "JrCqZ",
   597.           when JrCqNZ .. JrCqNZ+2#1111# => "JrCqNZ",
   598.           when JrEQ   => "Jr=",
   599.           when JrGTZ  => "JrGTZ",
   600.           when JrLTZ  => "JrLTZ",
   601.           when JrEQZ  => "Jr=Z",
   602.           when JrV    => "JrV",
   603.           when JrEN   => "JrEN",
   604.           when Jr     => "Jr",
   605.           when JrEJ   => "JrEJ",
   606.           when JSr    => "JSr",
   607.           when JrTR   => "JrTR",
   608.           when EXIT_n => "EXIT",
   609.           when JrNE   => "Jr",
   610.           when JrLEZ  => "JrLEZ",
   611.           when JrGEZ  => "JrGEZ",
   612.           when JrNEZ  => "JrZ",
   613.           when JrNV   => "JrNV",
   614.           when JrNEN  => "JrNEN",
   615.           when JrNEJ  => "JrNEJ",
   616.           when JrNTR  => "JrNTR",
   617.           when OS_OUT => "OUT",
   618.           when EXITD  => "EXITD",
   619.           when others => "invalid jump group syllable #" & oct_of(encoding)
   620.       );
   621.
   622.    function data_access_skeleton (compressed_opcode : KDF9.compressed_opcode)
   623.    return String
   624.    is (
   625.        case compressed_opcode is
   626.           when EaMq     => "EeMq",
   627.           when TO_EaMq  => "=EeMq",
   628.           when EaMqQ    => "EeMqQ",
   629.           when TO_EaMqQ => "=EeMqQ",
   630.           when SET      => "SET",
   631.           when others   => "invalid data access compressed opcode #" & oct_of(compressed_opcode)
   632.       );
   633.
   634.    function the_short_name_of (syllable_0 : KDF9.syllable)
   635.    return String is
   636.       its_INS : KDF9.decoded_order := (order => (syllable_0, 0, 0), others => <>);
   637.    begin
   638.       decode(its_INS);
   639.       return
   640.          (
   641.           case KDF9.INS_kind(syllable_0 / 2**6) is
   642.              when one_syllable_order   => one_syllable_name(its_INS),
   643.              when two_syllable_order   => two_syllable_skeleton(syllable_0),
   644.              when normal_jump_order    => normal_jump_skeleton(syllable_0),
   645.              when data_access_order    => data_access_skeleton(its_INS.compressed_opcode)
   646.          );
   647.    end the_short_name_of;
   648.
   649. end disassembly;

Compiling: ../Source/disassembly.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- Produce dis-assembled instructions in an approximation to KDF9 Usercode.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9;
    18.
    19. use  KDF9;
    20.
    21. package disassembly is
    22.
    23.    function the_code_and_name_of_INS
    24.    return String;
    25.
    26.    function the_full_name_of (order : KDF9.decoded_order; in_octal : Boolean)
    27.    return String;
    28.
    29.    function closer (
    30.                     decoded  : KDF9.decoded_order;
    31.                     address  : KDF9.syllable_address := (0, 0);
    32.                     in_octal : Boolean := True
    33.                    )
    34.    return String;
    35.
    36.    function the_short_name_of (syllable_0 : KDF9.syllable)
    37.    return String;
    38.
    39. end disassembly;

 649 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- Implement the API (OUTs) of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9.imaging;
    18. with IOC.fast.DR.TSD_OUTs;
    19. with IOC.fast.FD.TSD_OUTs;
    20. with IOC.fast.tape.TSD_OUTs;
    21. with KDF9.CPU;
    22. with KDF9.store;
    23. with KDF9.TSD.peripherals;
    24. with KDF9.TSD.processes;
    25. with KDF9.TSD.spooling;
    26. with KDF9.TSD.timing;
    27. with settings;
    28. with string_editing;
    29. with tracing;
    30.
    31. use  KDF9.imaging;
    32. use  IOC.fast.DR.TSD_OUTs;
    33. use  IOC.fast.FD.TSD_OUTs;
    34. use  IOC.fast.tape.TSD_OUTs;
    35. use  KDF9.store;
    36. use  KDF9.TSD.peripherals;
    37. use  KDF9.TSD.processes;
    38. use  KDF9.TSD.spooling;
    39. use  KDF9.TSD.timing;
    40. use  settings;
    41. use  string_editing;
    42. use  tracing;
    43.
    44. package body KDF9.TSD is
    45.
    46.    procedure restore_the_IO_OUT_operands (OUT_number, parameter : KDF9.word) is
    47.    begin
    48.       push(parameter);
    49.       push(OUT_number);
    50.    end restore_the_IO_OUT_operands;
    51.
    52.    procedure do_OUT_95 is
    53.       Q             : constant KDF9.Q_register := as_Q(pop);
    54.       start_address : constant KDF9.address := Q.I;
    55.       end_address   :          KDF9.address := Q.M;
    56.    begin
    57.       the_trace_operand := as_word(Q);
    58.       validate_address_range(start_address, end_address);
    59.
    60.       if Q.C / 2 > 0 then
    61.          log_new_line;
    62.       end if;
    63.
    64.       end_address := KDF9.address'Min(end_address, start_address + 9);
    65.
    66.       declare
    67.          size : constant Positive := Positive(end_address - start_address + 1) * 8;
    68.          next : Positive := 1;
    69.          text : String(1 .. size);
    70.          char : KDF9_char_sets.symbol;
    71.       begin
    72.       word_loop:
    73.          for w in start_address .. end_address loop
    74.             for c in KDF9_char_sets.symbol_index'Range loop
    75.                char := fetch_symbol(w, c);
    76.                text(next) := to_CP(char);
    77.                next := next + 1;
    78.             end loop;
    79.          end loop word_loop;
    80.          log(text);
    81.       end;
    82.
    83.       if Q.C mod 2 = 1  then
    84.          log_new_line;
    85.       end if;
    86.    end do_OUT_95;
    87.
    88.    procedure do_OUT_96 is
    89.       use KDF9.CPU;
    90.       P    : constant KDF9.word := pop;
    91.       text : constant String    := glyphs_for(P);
    92.    begin
    93.       the_trace_operand := P;
    94.       log_line("N1 = "
    95.              & resign(P)'Image
    96.              + as_fraction(P)'Image
    97.              + host_float(as_f48(P))'Image
    98.              + "#"
    99.              & oct_of(P)
   100.              + abs text
   101.               );
   102.       push(P);
   103.    end do_OUT_96;
   104.
   105.    procedure remove_the_IO_OUT_operands renames KDF9.pop_pair;
   106.
   107.    -- Emulate a subset of the Time Sharing Director's OUT API.
   108.    procedure do_a_TSD_OUT (OUT_number : in KDF9.word) is
   109.    begin
   110.       -- Dismiss the OUT number in N1, allowing for an empty NEST, treated as OUT 0.
   111.       if the_NEST_depth > 0 then
   112.          pop;
   113.       end if;
   114.
   115.       case OUT_number is
   116.
   117.          when 0 =>
   118.             do_OUT_0;
   119.
   120.          when 1 =>
   121.             do_OUT_1;
   122.
   123.          when 2 =>
   124.             do_OUT_2;
   125.
   126.          when 3 =>
   127.             do_OUT_3;
   128.
   129.          when 4 =>
   130.             do_OUT_4;
   131.
   132.          when 5 =>
   133.             do_OUT_5;
   134.
   135.          when 6 =>
   136.             do_OUT_6;
   137.
   138.          when 7 =>
   139.             do_OUT_7;
   140.
   141.          when 8 =>
   142.             do_OUT_8;
   143.
   144.          when 9 =>
   145.             do_OUT_9;
   146.
   147.          when 10 =>
   148.             do_OUT_10;
   149.
   150.          when 11 =>
   151.             do_OUT_11;
   152.
   153.          when 12 =>
   154.             do_OUT_12;
   155.
   156.          when 13 =>
   157.             do_OUT_13;
   158.
   159.          when 14 =>
   160.             do_OUT_14;
   161.
   162.          when 16 =>
   163.             do_OUT_16;
   164.
   165.          when 17 =>
   166.             do_OUT_17;
   167.
   168.          when 41 =>
   169.             do_OUT_41;
   170.
   171.          when 42 =>
   172.             do_OUT_42;
   173.
   174.          when 43 =>
   175.             do_OUT_43;
   176.
   177.          when 44 =>
   178.             do_OUT_44;
   179.
   180.          when 45 =>
   181.             do_OUT_45;
   182.
   183.          when 47 =>
   184.             do_OUT_47;
   185.
   186.          when 95 =>
   187.             -- This is not a genuine TSD OUT, it prints the 8-character text in N1.
   188.             ensure_that_the_NEST_holds_an_operand;
   189.             do_OUT_95;
   190.
   191.          when 96 =>
   192.             -- This is not a genuine TSD OUT, it prints the integer value in N1.
   193.             ensure_that_the_NEST_holds_an_operand;
   194.             do_OUT_96;
   195.
   196.          when 97 =>
   197.             -- This is not a genuine TSD OUT, it gets an integer value from the command line.
   198.             -- The operand is the name of an environment variable.
   199.             -- The result is the numerical value of that variable.
   200.             ensure_that_the_NEST_holds_an_operand;
   201.             do_OUT_97;
   202.
   203.          when 98 =>
   204.             -- This is not a genuine TSD OUT, it is an ee9 'OUT' for setting FW output format.
   205.             ensure_that_the_NEST_holds_an_operand;
   206.             the_trace_operand := pop;
   207.             realistic_FW_output_is_wanted := the_trace_operand /= 0;
   208.
   209.          when 99 =>
   210.             -- This is not a genuine TSD OUT, it is an ee9 'OUT' for program instrumentation.
   211.             -- Get present value of the Instruction Count Register (ICR) from within ee9.
   212.             push(KDF9.word(ICR));
   213.             the_trace_operand := KDF9.word(ICR);
   214.
   215.          when others =>
   216.             push(OUT_number);
   217.             trap_failing_OUT(OUT_number, "is unknown, or not yet implemented");
   218.
   219.       end case;
   220.    end do_a_TSD_OUT;
   221.
   222. end KDF9.TSD;

Compiling: ../Source/kdf9-tsd.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:03

     1. -- Implement the API (OUTs) of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17.
    18. private with KDF9.imaging;
    19. private with exceptions;
    20. private with HCI;
    21. private with IOC.equipment;
    22. private with settings;
    23. private with state_display;
    24. private with string_editing;
    25. private with tracing;
    26.
    27. package KDF9.TSD is
    28.
    29.    procedure do_a_TSD_OUT (OUT_number : in KDF9.word);
    30.
    31.    -- Put the parameters of an I/O OUT back into the NEST in case the I/O order causes a lockout.
    32.    procedure restore_the_IO_OUT_operands (OUT_number, parameter : KDF9.word);
    33.
    34.    -- Remove the OUT parameters from the NEST after the I/O order completes without interrupting.
    35.    procedure remove_the_IO_OUT_operands;
    36.
    37. private
    38.
    39.    use KDF9.imaging;   pragma Warnings(Off, KDF9.imaging);
    40.    use exceptions;     pragma Warnings(Off, exceptions);
    41.    use HCI;            pragma Warnings(Off, HCI);
    42.    use IOC.equipment;  pragma Warnings(Off, IOC.equipment);
    43.    use settings;       pragma Warnings(Off, settings);
    44.    use state_display;  pragma Warnings(Off, state_display);
    45.    use string_editing; pragma Warnings(Off, string_editing);
    46.    use tracing;        pragma Warnings(Off, tracing);
    47.
    48. end KDF9.TSD;

 222 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/file_interfacing.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Provide an Ada.Text_IO interface to the file system of the real OS.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body file_interfacing is
    18.
    19.    procedure initialize (some_file : in out File_Type;
    20.                          mode      : in File_Mode;
    21.                          file_name : in String) is
    22.    begin
    23.       Open(some_file, mode, file_name);
    24.    exception
    25.       when others =>
    26.          if mode = Out_File then
    27.             Create(some_file, Out_File, file_name);
    28.          else
    29.             raise;
    30.          end if;
    31.    end initialize;
    32.
    33.    procedure finalize (some_file : in out File_Type;
    34.                        file_name : in String) is
    35.       pragma Unreferenced(file_name);
    36.    begin
    37.       Close(some_file);
    38.    end finalize;
    39.
    40. end file_interfacing;

Compiling: ../Source/file_interfacing.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Provide an Ada.Text_IO interface to the file system of the real OS.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18.
    19. use  Ada.Text_IO;
    20.
    21. package file_interfacing is
    22.
    23.    procedure initialize (some_file : in out File_Type;
    24.                          mode      : in File_Mode;
    25.                          file_name : in String);
    26.
    27.    procedure finalize (some_file : in out File_Type;
    28.                        file_name : in String);
    29.
    30. end file_interfacing;

 40 lines: No errors


Compiling: /home/parallels/emulation/Source/kdf9-tsd-timing.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Implement the timing OUTs of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body KDF9.TSD.timing is
    18.
    19.    -- This is the actual wall clock time at which the program was loaded.
    20.    -- If signature hashing is enabled, it stays at zero to get a repeatable hash.
    21.    the_time_of_loading : KDF9.us := 0;
    22.
    23.    -- Set the base for virtual elapsed time reckoning.
    24.    procedure set_the_time_of_loading (the_time : in KDF9.us) is
    25.    begin
    26.       the_time_of_loading := the_time;
    27.    end set_the_time_of_loading;
    28.
    29.    -- Return a time in s as 48-bit seconds to 23 integral places.
    30.    function OUT_time (microseconds : KDF9.us)
    31.    return KDF9.word is
    32.       -- The time was recorded by the hardware in units of 32 us, not 1 us.
    33.       truncated_time : constant KDF9.us := microseconds and not 31;
    34.    begin
    35.       if truncated_time < 2**23 * 1E6 then
    36.          -- 2**18 / 15625 = 2**24 / 1E6, with no risk of overflow in 64 bits.
    37.          return KDF9.word(truncated_time * 2**18 / 15625);
    38.       else
    39.          -- The virtual elapsed time overflows the 23-bit seconds field.
    40.          -- This would never have happened to a real KDF9, as 2**23 seconds is over three months.
    41.          -- No KDF9 could stay up that long!
    42.          -- However 2**23 KDF9 seconds pass in about 5 hours of ee9 real time,
    43.          --    so precautions have to be taken.
    44.          raise program_exit with "the KDF9 has been running too long, time > 2**23 seconds";
    45.       end if;
    46.    end OUT_time;
    47.
    48.    procedure do_OUT_3 is
    49.    begin
    50.       push(OUT_time(the_CPU_time));
    51.       the_trace_operand := read_top;
    52.    end do_OUT_3;
    53.
    54.    procedure do_OUT_9 is
    55.    begin
    56.       -- A TOD clock is simulated using the real TOD at which the program was
    57.       --    loaded, and the virtual time that has elapsed since.
    58.       push(OUT_time(the_time_of_loading + the_clock_time));
    59.       the_trace_operand := read_top;
    60.    end do_OUT_9;
    61.
    62.    procedure do_OUT_17 is
    63.    begin
    64.       ensure_that_the_NEST_has_room_for_2_results;
    65.       -- In program mode, the Elapsed Time is the same thing as the_clock_time.
    66.       push(OUT_time(the_clock_time));
    67.       push(OUT_time(the_CPU_time));
    68.       the_trace_operand := read_top;
    69.    end do_OUT_17;
    70.
    71. end KDF9.TSD.timing;

Compiling: ../Source/kdf9-tsd-timing.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Implement the timing OUTs of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.timing is
    18.
    19.    procedure do_OUT_3;
    20.
    21.    procedure do_OUT_9;
    22.
    23.    procedure do_OUT_17;
    24.
    25.    -- Set the base for virtual elapsed time reckoning.
    26.    procedure set_the_time_of_loading (the_time : in KDF9.us);
    27.
    28. end KDF9.TSD.timing;

 71 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/generic_sets.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Powersets of a discrete member type.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. -- generic
    18. --    type member is (<>);
    19. package body generic_sets is
    20.
    21.    function "/" (set : generic_sets.set; member : generic_sets.member)
    22.    return Boolean
    23.    is (set(member));
    24.
    25.    function "or" (set : generic_sets.set; member : generic_sets.member)
    26.    return generic_sets.set is
    27.    begin
    28.       return result : generic_sets.set := set do
    29.          result(member) := True;
    30.       end return;
    31.    end "or";
    32.
    33.    function "-" (set1, set2 : generic_sets.set)
    34.    return generic_sets.set is
    35.    begin -- Compute (set1 and not set2), avoiding need for a potentially large workspace.
    36.       return result : generic_sets.set := set1 do
    37.          for m in generic_sets.member loop
    38.             if set2(m) then
    39.                result(m) := False;
    40.             end if;
    41.          end loop;
    42.       end return;
    43.    end "-";
    44.
    45. end generic_sets;

Compiling: ../Source/generic_sets.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Powersets of a discrete member type.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. generic
    18.    type member is (<>);
    19. package generic_sets is
    20.
    21.    pragma Preelaborate;
    22.
    23. --
    24. -- This package implements only those set operations that are needed by ee9.
    25. --
    26.
    27.    type set is array (generic_sets.member) of Boolean
    28.       with Component_Size => 1;
    29.
    30.    empty_set : constant generic_sets.set := (others => False);
    31.
    32.    -- Test for membership of the set.
    33.    function "/" (set : generic_sets.set; member : generic_sets.member)
    34.    return Boolean with Inline;
    35.
    36.    -- Union of a set and a singleton.
    37.    function "or"  (set : generic_sets.set; member : generic_sets.member)
    38.    return generic_sets.set;
    39.
    40.    -- Computes (set1 and not set2).
    41.    function "-" (set1, set2 : generic_sets.set)
    42.    return generic_sets.set;
    43.
    44. end generic_sets;

 45 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/postscript.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Elementary Encapsulated PostScript (EPS) line drawing.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body postscript is
    18.
    19.    use host_IO;
    20.
    21.    -- A path is a series of vectors v1, v2, ..., vn such that the last point
    22.    --    of vi is the same as the first point of v(i+1),
    23.    --       and v1, ..., vn are all drawn in the same colour.
    24.    -- A new path is started by a jump to a non-contiguous point or by a change of pen colour.
    25.
    26.    there_is_an_open_path      : Boolean := False;
    27.    the_last_point_in_the_path : postscript.point := (0, 0);
    28.
    29.    -- The bounding box limits are set from the value of maximum_offset at the end of the plot.
    30.    maximum_offset             : postscript.point := (0, 0);
    31.
    32.    procedure ensure_separation (stream : in out host_IO.stream) is
    33.    begin
    34.       if column(stream) > 0 then
    35.          put_byte(' ', stream);
    36.       end if;
    37.    end ensure_separation;
    38.
    39.    procedure put (stream : in out host_IO.stream; PS_text : String) is
    40.    begin
    41.       put_bytes(PS_text, stream);
    42.    end put;
    43.
    44.    procedure put_unit (stream : in out host_IO.stream; PS_text : String) is
    45.    begin
    46.       ensure_separation(stream);
    47.       put(stream, PS_text);
    48.    end put_unit;
    49.
    50.    procedure put_line (stream : in out host_IO.stream; PS_text : String) is
    51.    begin
    52.       put(stream, PS_text);
    53.       put_EOL(stream);
    54.    end put_line;
    55.
    56.    procedure put_unit_line (stream : in out host_IO.stream; PS_text : String) is
    57.    begin
    58.       put_unit(stream, PS_text);
    59.       put_EOL(stream);
    60.    end put_unit_line;
    61.
    62.    procedure put_integer (stream : in out host_IO.stream; i : Integer) is
    63.       integer_image  : constant String := i'Image;
    64.    begin
    65.       ensure_separation(stream);
    66.       if integer_image(integer_image'First) /= ' ' then
    67.          put(stream, integer_image);
    68.       else  -- Suppress the nuisance blank character.
    69.          put(stream, integer_image(integer_image'First+1..integer_image'Last));
    70.       end if;
    71.    end put_integer;
    72.
    73.    procedure terminate_any_open_path (stream : in out host_IO.stream) is
    74.    begin
    75.       if there_is_an_open_path then
    76.          -- Draw the accumulated strokes.
    77.          put_unit_line(stream, "s");
    78.       end if;
    79.       there_is_an_open_path := False;
    80.    end terminate_any_open_path;
    81.
    82.    procedure draw_a_PS_vector (stream : in out host_IO.stream;
    83.                                initial,
    84.                                final  : in postscript.point) is
    85.
    86.       function largest_of (a, b, c : Natural)
    87.       return Natural
    88.       is (Natural'Max(a, Natural'Max(b, c)));
    89.
    90.    begin -- draw_a_PS_vector
    91.       if initial /= the_last_point_in_the_path then
    92.          -- This vector is not contiguous with the previous one.
    93.          terminate_any_open_path(stream);
    94.       end if;
    95.       if initial = final then
    96.          -- This vector is of length 0.
    97.          return;
    98.       end if;
    99.       maximum_offset.x := largest_of(maximum_offset.x, initial.x, final.x);
   100.       maximum_offset.y := largest_of(maximum_offset.y, initial.y, final.y);
   101.       if there_is_an_open_path then
   102.          -- Draw a line to the final point, extending the current path.
   103.          put_integer(stream, final.x);
   104.          put_integer(stream, final.y);
   105.          put_unit_line(stream, "l");
   106.       else
   107.          -- Move to the initial point, opening a fresh path, and draw a line to the final point.
   108.          put_integer(stream, final.x);
   109.          put_integer(stream, final.y);
   110.          put_integer(stream, initial.x);
   111.          put_integer(stream, initial.y);
   112.          put_unit_line(stream, "n");
   113.          there_is_an_open_path := True;
   114.       end if;
   115.       the_last_point_in_the_path := final;
   116.    end draw_a_PS_vector;
   117.
   118.    subtype RGB is String(1..11);
   119.    gamut : constant array (pen_colour) of RGB
   120.          := (
   121.                Black          => ".00 .00 .00",
   122.                Blue           => ".00 .00 1.0",
   123.                Brown          => ".60 .20 .00",
   124.                Cyan           => ".00 1.0 1.0",
   125.                Dark_Blue      => ".10 .10 .80",
   126.                Dark_Cyan      => ".20 .80 1.0",
   127.                Dark_Green     => ".00 .60 .40",
   128.                Dark_Grey      => ".50 .50 .50",
   129.                Dark_Magenta   => ".75 .25 .75",
   130.                Dark_Red       => ".75 .00 .00",
   131.                Green          => ".00 1.0 .00",
   132.                Grey           => ".80 .80 .80",
   133.                Magenta        => "1.0 .00 1.0",
   134.                Red            => "1.0 .00 .00",
   135.                White          => "1.0 1.0 1.0",
   136.                Yellow         => "1.0 1.0 .00"
   137.             );
   138.
   139.    subtype tip_breadth is String(1..4);
   140.    breadth : constant array (pen_tip_size) of tip_breadth
   141.            := (
   142.                Extra_Extra_Fine => "1.00",
   143.                Extra_Fine       => "2.00",
   144.                Fine             => "4.00",
   145.                Medium           => "6.00",
   146.                Medium_Broad     => "8.00",
   147.                Broad            => "10.0",
   148.                Extra_Broad      => "12.0"
   149.               );
   150.
   151.    the_colour   : pen_colour   := the_default_colour;
   152.    the_pen_size : pen_tip_size := the_default_tip_size;
   153.
   154.    procedure put_the_pen_settings (stream : in out host_IO.Stream) is
   155.    begin -- put_the_pen_settings
   156.       terminate_any_open_path(stream);
   157.       put_unit(stream, gamut(the_colour));
   158.       put_unit_line(stream, "setrgbcolor");
   159.       put_unit(stream, breadth(the_pen_size));
   160.       put_unit_line(stream, "setlinewidth");
   161.    end put_the_pen_settings;
   162.
   163.    procedure set_the_pen_properties (this_colour   : in pen_colour   := the_default_colour;
   164.                                      this_pen_size : in pen_tip_size := the_default_tip_size) is
   165.    begin -- set_the_pen_properties
   166.       the_colour := this_colour;
   167.       the_pen_size := this_pen_size;
   168.    end set_the_pen_properties;
   169.
   170.    -- We eventually seek back to the bounding box parametsrs using this, their file offset.
   171.    the_position_of_the_placeholders : Natural;
   172.
   173.    procedure initialize_PS_output (stream : in out host_IO.Stream) is
   174.
   175.    begin -- initialize_PS_output
   176.       put_line(stream, "%!PS-Adobe-3.0 EPSF-1.0");
   177.       put_unit(stream, "%%BoundingBox: ");
   178.
   179.       -- Note the file offset of the bounding box placeholders.
   180.       get_position(the_position_of_the_placeholders, stream);
   181.
   182.       -- Write the 12-column placeholders.
   183.       put_line(stream, "xxxxxxxxxxxx|yyyyyyyyyyyy");
   184.
   185.       put_line(stream, "% This graph was plotted by ee9, the GNU Ada KDF9 emulator.");
   186.       put_line(stream, "% For more information, see <http://www.findlayw.plus.com/KDF9>.");
   187.       put_line(stream, "save");
   188.
   189.       put_line(stream, "1 setlinecap");
   190.       put_line(stream, "1 setlinejoin");
   191.
   192.       put_the_pen_settings(stream);
   193.
   194.       put_line(stream, "0 792 translate");  -- Assumes a page of length 11"!
   195.
   196.       -- The plotter step was 0.005", which is the same as 0.36 PostScript points.
   197.       -- The scaling factor is set here to make the wabbit example fit an A4 page.
   198.       put_line(stream, "0.12 -0.12 scale");
   199.
   200.       put_line(stream, "/l { lineto } bind def");
   201.       put_line(stream, "/n { newpath moveto lineto } bind def");
   202.       put_line(stream, "/s { stroke } bind def");
   203.
   204.       put_line(stream, "save");
   205.    end initialize_PS_output;
   206.
   207.    procedure finalize_PS_output (stream : in out host_IO.Stream) is
   208.
   209.       subtype bound_string is String(1..12);
   210.
   211.       function bound_image (n : in Natural)
   212.       return bound_string is
   213.          n_image : constant String := n'Image;
   214.       begin
   215.          return b : bound_string := (others => ' ') do
   216.             b(b'Last-n_image'Length+1 .. b'Last) := n_image;
   217.          end return;
   218.       end bound_image;
   219.
   220.    begin -- finalize_PS_output
   221.       terminate_any_open_path(stream);
   222.       put_line(stream, "showpage");
   223.       put_line(stream, "restore");
   224.       put_line(stream, "restore");
   225.       put_line(stream, "% End of plot");
   226.
   227.       -- Go back to the bounding box placeholders in the output file.
   228.       set_position(the_position_of_the_placeholders, stream);
   229.
   230.       -- Overwrite them with the actual x and y co-ordinate bounds.
   231.       put(stream, bound_image(maximum_offset.x));
   232.       put(stream, " ");
   233.       put(stream, bound_image(maximum_offset.y));
   234.
   235.       close(stream);
   236.    end finalize_PS_output;
   237.
   238. end postscript;
   239.

Compiling: ../Source/postscript.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Elementary Encapsulated PostScript (EPS) line drawing.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with host_IO;
    18.
    19. package postscript is
    20.
    21.    type pen_colour is (
    22.                        Black,
    23.                        Blue,
    24.                        Brown,
    25.                        Cyan,
    26.                        Dark_Blue,
    27.                        Dark_Cyan,
    28.                        Dark_Green,
    29.                        Dark_Grey,
    30.                        Dark_Magenta,
    31.                        Dark_Red,
    32.                        Green,
    33.                        Grey,
    34.                        Magenta,
    35.                        Red,
    36.                        White,
    37.                        Yellow
    38.                       );
    39.
    40.    the_default_colour : constant pen_colour := Black;
    41.
    42.    type pen_tip_size is (
    43.                          Extra_Extra_Fine,
    44.                          Extra_Fine,
    45.                          Fine,
    46.                          Medium,
    47.                          Medium_Broad,
    48.                          Broad,
    49.                          Extra_Broad
    50.                         );
    51.
    52.    the_default_tip_size : constant pen_tip_size := Extra_Extra_Fine;
    53.
    54.    -- Choose the pen's colour and tip size.
    55.
    56.    procedure set_the_pen_properties (this_colour   : in pen_colour   := the_default_colour;
    57.                                      this_pen_size : in pen_tip_size := the_default_tip_size);
    58.
    59.    -- Drawing is done in terms of the plotter's co-ordinate system.
    60.    -- (0, 0) is the top left point of the drawing,
    61.    -- The x axis increases down the plot (long axis, direction of paper movement),
    62.    --    and the y axis increases across the plot (short axis, direction of pen movement).
    63.
    64.    type point is
    65.      record
    66.         x, y : Natural;  -- All physically possible co-ordinates are non-negative.
    67.      end record;
    68.
    69.    -- Draw a straight line from initial to final.
    70.    procedure draw_a_PS_vector (stream : in out host_IO.stream;
    71.                                initial,
    72.                                final  : in postscript.point);
    73.
    74.    -- Open the PostScript file and write the prelude, with a placeholder for the bounds.
    75.    procedure initialize_PS_output (stream : in out host_IO.Stream);
    76.
    77.    -- Close the PostScript file, having gone back to overwrite the bounding box placeholders.
    78.    procedure finalize_PS_output (stream : in out host_IO.Stream);
    79.
    80. end postscript;

 239 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/settings-io.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Settings-reader I/O support.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Characters.Latin_1;
    18. --
    19. with file_interfacing;
    20. with KDF9;
    21.
    22. use  Ada.Characters.Latin_1;
    23.
    24. package body settings.IO is
    25.
    26.    procedure open_options_file (file : in out File_Type; name : in String) is
    27.    begin
    28.       file_interfacing.initialize(file, in_file, name);
    29.       line_number := 1;
    30.    exception
    31.       when others =>
    32.          raise Status_Error with name;
    33.    end open_options_file;
    34.
    35.    procedure close_options_file (file : in out File_Type; name : in String) is
    36.    begin
    37.       file_interfacing.finalize(file, name);
    38.    end close_options_file;
    39.
    40.    comment_flag_character : constant Character := '|';
    41.
    42.    procedure skip_to_next_non_blank (file : File_Type) is
    43.       next_char : Character := ' ';
    44.       end_line  : Boolean;
    45.    begin
    46.       loop
    47.         look_ahead(file, next_char, end_line);
    48.       exit when end_line or else (next_char not in ' ' | HT);
    49.          get(file, next_char);
    50.       end loop;
    51.       if next_char = comment_flag_character then
    52.          while not end_of_line(file) loop
    53.             get(file, next_char);
    54.          end loop;
    55.       end if;
    56.    end skip_to_next_non_blank;
    57.
    58.    procedure ensure_not_at_end_of_line (file : File_Type) is
    59.    begin
    60.       skip_to_next_non_blank (file);
    61.       if end_of_line(file) then
    62.          raise Data_Error;
    63.       end if;
    64.    end ensure_not_at_end_of_line;
    65.
    66.    procedure skip_to_next_nonempty_line (file : in File_Type) is
    67.       flag     : Character;
    68.       end_line : Boolean;
    69.    begin
    70.       loop
    71.          look_ahead(file, flag, end_line);
    72.          if end_line                      or else
    73.                flag = comment_flag_character then
    74.             Skip_Line(file);
    75.             line_number := line_number + 1;
    76.          else
    77.             exit;
    78.          end if;
    79.       end loop;
    80.       if flag = comment_flag_character then
    81.          raise Data_Error;
    82.       end if;
    83.    end skip_to_next_nonempty_line;
    84.
    85.    digit_offset : constant := Character'Pos('0');
    86.
    87.    procedure get_octal (file : in File_Type; value : out KDF9.word) is
    88.       next_char : Character;
    89.       last_char : Character := '_';
    90.       place     : Natural   := 0;
    91.       end_line  : Boolean   := False;
    92.    begin
    93.       value := 0;
    94.       ensure_not_at_end_of_line(file);
    95.       get(file, next_char);
    96.       if next_char = '#' then
    97.          get(file, next_char);
    98.       else
    99.          raise Data_Error;
   100.       end if;
   101.       loop
   102.          if next_char in '0' .. '7' then
   103.             value := value*8 + KDF9.word(Character'Pos(next_char)-digit_offset);
   104.             place := place + 1;
   105.             if place > 16 then
   106.                raise Data_Error;
   107.             end if;
   108.          elsif next_char = '_' then
   109.             if place = 0 then
   110.                raise Data_Error;
   111.             end if;
   112.          else
   113.             if last_char = '_' or place = 0 then
   114.                raise Data_Error;
   115.             end if;
   116.             exit;
   117.          end if;
   118.          last_char := next_char;
   119.          look_ahead(file, next_char, end_line);
   120.       exit when end_line;
   121.          if next_char in '0' .. '7' or next_char = '_' then
   122.             get(file, next_char);
   123.          else
   124.             if last_char = '_' or place = 0 then
   125.                raise Data_Error;
   126.             end if;
   127.             exit;
   128.          end if;
   129.       end loop;
   130.    end get_octal;
   131.
   132.    procedure get_decimal (file : in File_Type; value : out KDF9.word) is
   133.       next_char : Character;
   134.       last_char : Character := '_';
   135.       place     : Natural   := 0;
   136.       negative  : Boolean   := False;
   137.       end_line  : Boolean   := False;
   138.    begin
   139.       value := 0;
   140.       ensure_not_at_end_of_line(file);
   141.       get(file, next_char);
   142.       if next_char = '-' then
   143.          negative := True;
   144.          get(file, next_char);
   145.       elsif next_char not in '0' .. '9' then
   146.          raise Data_Error with "get_decimal " & next_char;
   147.       end if;
   148.       loop
   149.          if next_char in '0' .. '9' then
   150.             value := value*10 + KDF9.word(Character'Pos(next_char)-digit_offset);
   151.             place := place + 1;
   152.             if place > 15 then
   153.                raise Data_Error;
   154.             end if;
   155.          elsif next_char = '_' then
   156.             if place = 0 then
   157.                raise Data_Error;
   158.             end if;
   159.          else
   160.             if last_char = '_' or place = 0 then
   161.                raise Data_Error;
   162.             end if;
   163.       exit;
   164.          end if;
   165.          last_char := next_char;
   166.          look_ahead(file, next_char, end_line);
   167.       exit when end_line;
   168.          if next_char in '0' .. '9' or next_char = '_' then
   169.             get(file, next_char);
   170.          else
   171.             if last_char = '_' or place = 0 then
   172.                raise Data_Error;
   173.             end if;
   174.       exit;
   175.          end if;
   176.       end loop;
   177.       if negative then
   178.          value := - value;
   179.       end if;
   180.    end get_decimal;
   181.
   182.    procedure get_word (file : in File_Type; value : out KDF9.word) is
   183.       next_char : Character;
   184.       end_line  : Boolean;
   185.    begin
   186.       ensure_not_at_end_of_line(file);
   187.       look_ahead(file, next_char, end_line);
   188.       pragma Unreferenced(end_line);
   189.       if next_char = '#' then
   190.          get_octal(file, value);
   191.       else
   192.          get_decimal(file, value);
   193.       end if;
   194.    end get_word;
   195.
   196.    procedure get_char (file : in File_Type; value : out Character) is
   197.       end_line : Boolean;
   198.       char     : Character;
   199.    begin
   200.       ensure_not_at_end_of_line(file);
   201.       look_ahead(file, char, end_line);
   202.       if end_line then
   203.          raise Data_Error;
   204.       end if;
   205.       if char /= ' ' then
   206.          get(file, value);
   207.       end if;
   208.    end get_char;
   209.
   210. end settings.IO;
   211.

Compiling: ../Source/settings-io.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Settings-reader I/O support.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with Ada.Text_IO;
    18. --
    19. with postscript;
    20.
    21. use  Ada.Text_IO;
    22.
    23. package settings.IO is
    24.
    25.    line_number : Natural := 0;
    26.
    27.    procedure open_options_file (file : in out File_Type; name : in String);
    28.
    29.    procedure close_options_file (file : in out File_Type; name : in String);
    30.
    31.    -- Check that the end of the line has not yet been reached, else raise Data_Error.
    32.    procedure ensure_not_at_end_of_line (file : in File_Type);
    33.
    34.    -- Move the reading position to the next non-blank or EOL, skipping comment.
    35.    procedure skip_to_next_non_blank (file : in File_Type);
    36.
    37.    -- Discard input until a non-empty line is reached,
    38.    --    leaving the reading position at the start of that line,
    39.    --    and incrementing line_number for each line terminator passed.
    40.    procedure skip_to_next_nonempty_line (file : in File_Type);
    41.
    42.    -- Read octal digits string as KDF9.word,
    43.    --    raising Data_Error on overflow or bad syntax.
    44.    procedure get_octal (file : in File_Type; value : out KDF9.word);
    45.
    46.    -- Read decimal digits string as KDF9.word,
    47.    --    raising Data_Error on overflow or bad syntax.
    48.    procedure get_decimal (file  : in File_Type; value : out KDF9.word);
    49.
    50.    -- Read an address as a KDF9.word in either octal or decimal,
    51.    --    using get_octal or get_decimal as indicated by the syntax.
    52.    procedure get_word (file : in File_Type; value : out KDF9.word);
    53.
    54.    -- Read the character value immediately following an octal or decimal number,
    55.    --    if it is not a space character; if it is a space, leave value unchanged.
    56.    procedure get_char (file : in File_Type; value : out Character);
    57.
    58.    package colour_IO is new Ada.Text_IO.Enumeration_IO(postscript.pen_colour);
    59.    package  width_IO is new Ada.Text_IO.Enumeration_IO(postscript.pen_tip_size);
    60.
    61. end settings.IO;

 211 lines: No errors


Compiling: /home/parallels/emulation/Source/kdf9-decoding.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- The "compressed_opcode" values are effective opcodes, partially decoded from the first syllable,
     2. --   and combined with opcode bits of the second syllable, where appropriate (e.g. in jumps).
     3. --
     4. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     5. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     6. --
     7. -- The ee9 program is free software; you can redistribute it and/or
     8. -- modify it under terms of the GNU General Public License as published
     9. -- by the Free Software Foundation; either version 3, or (at your option)
    10. -- any later version. This program is distributed in the hope that it
    11. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    12. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    13. -- See the GNU General Public License for more details. You should have
    14. -- received a copy of the GNU General Public License distributed with
    15. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    16. --
    17.
    18. package KDF9.decoding is
    19.
    20.    -- The compressed_opcode values for 1-syllable orders are equal to their full codes.
    21.
    22.    ALL_0    : constant KDF9.compressed_opcode := 2#000_000#;
    23.    VR       : constant KDF9.compressed_opcode := 2#000_001#;
    24.    TO_TR    : constant KDF9.compressed_opcode := 2#000_010#;
    25.    BITS     : constant KDF9.compressed_opcode := 2#000_011#;
    26.    XF       : constant KDF9.compressed_opcode := 2#000_100#;
    27.    XDF      : constant KDF9.compressed_opcode := 2#000_101#;
    28.    INV006   : constant KDF9.compressed_opcode := 2#000_110#;
    29.    XPLUSF   : constant KDF9.compressed_opcode := 2#000_111#;
    30.    NEGD     : constant KDF9.compressed_opcode := 2#001_000#;
    31.    OR_9     : constant KDF9.compressed_opcode := 2#001_001#;
    32.    PERM     : constant KDF9.compressed_opcode := 2#001_010#;
    33.    TOB      : constant KDF9.compressed_opcode := 2#001_011#;
    34.    ROUNDH   : constant KDF9.compressed_opcode := 2#001_100#;
    35.    NEV      : constant KDF9.compressed_opcode := 2#001_101#;
    36.    ROUND    : constant KDF9.compressed_opcode := 2#001_110#;
    37.    DUMMY    : constant KDF9.compressed_opcode := 2#001_111#;
    38.    ROUNDF   : constant KDF9.compressed_opcode := 2#010_000#;
    39.    ROUNDHF  : constant KDF9.compressed_opcode := 2#010_001#;
    40.    MINUSDF  : constant KDF9.compressed_opcode := 2#010_010#;
    41.    PLUSDF   : constant KDF9.compressed_opcode := 2#010_011#;
    42.    FLOAT_9  : constant KDF9.compressed_opcode := 2#010_100#;
    43.    FLOATD   : constant KDF9.compressed_opcode := 2#010_101#;
    44.    ABS_9    : constant KDF9.compressed_opcode := 2#010_110#;
    45.    NEG      : constant KDF9.compressed_opcode := 2#010_111#;
    46.    ABSF     : constant KDF9.compressed_opcode := 2#011_000#;
    47.    NEGF     : constant KDF9.compressed_opcode := 2#011_001#;
    48.    MAX      : constant KDF9.compressed_opcode := 2#011_010#;
    49.    NOT_9    : constant KDF9.compressed_opcode := 2#011_011#;
    50.    XD       : constant KDF9.compressed_opcode := 2#011_100#;
    51.    X_frac   : constant KDF9.compressed_opcode := 2#011_101#;
    52.    MINUS    : constant KDF9.compressed_opcode := 2#011_110#;
    53.    SIGN     : constant KDF9.compressed_opcode := 2#011_111#;
    54.    INV040   : constant KDF9.compressed_opcode := 2#100_000#;
    55.    ZERO     : constant KDF9.compressed_opcode := 2#100_001#;
    56.    DUP      : constant KDF9.compressed_opcode := 2#100_010#;
    57.    DUPD     : constant KDF9.compressed_opcode := 2#100_011#;
    58.    DIVI     : constant KDF9.compressed_opcode := 2#100_100#;
    59.    FIX      : constant KDF9.compressed_opcode := 2#100_101#;
    60.    INV046   : constant KDF9.compressed_opcode := 2#100_110#;
    61.    STR      : constant KDF9.compressed_opcode := 2#100_111#;
    62.    CONT     : constant KDF9.compressed_opcode := 2#101_000#;
    63.    REVD     : constant KDF9.compressed_opcode := 2#101_001#;
    64.    ERASE    : constant KDF9.compressed_opcode := 2#101_010#;
    65.    MINUSD   : constant KDF9.compressed_opcode := 2#101_011#;
    66.    AND_9    : constant KDF9.compressed_opcode := 2#101_100#;
    67.    INV055   : constant KDF9.compressed_opcode := 2#101_101#;
    68.    PLUS     : constant KDF9.compressed_opcode := 2#101_110#;
    69.    PLUSD    : constant KDF9.compressed_opcode := 2#101_111#;
    70.    DIV      : constant KDF9.compressed_opcode := 2#110_000#;
    71.    DIVD     : constant KDF9.compressed_opcode := 2#110_001#;
    72.    DIVF     : constant KDF9.compressed_opcode := 2#110_010#;
    73.    DIVDF    : constant KDF9.compressed_opcode := 2#110_011#;
    74.    DIVR     : constant KDF9.compressed_opcode := 2#110_100#;
    75.    REV      : constant KDF9.compressed_opcode := 2#110_101#;
    76.    CAB      : constant KDF9.compressed_opcode := 2#110_110#;
    77.    FRB      : constant KDF9.compressed_opcode := 2#110_111#;
    78.    STAND    : constant KDF9.compressed_opcode := 2#111_000#;
    79.    NEGDF    : constant KDF9.compressed_opcode := 2#111_001#;
    80.    MAXF     : constant KDF9.compressed_opcode := 2#111_010#;
    81.    INV073   : constant KDF9.compressed_opcode := 2#111_011#;
    82.    PLUSF    : constant KDF9.compressed_opcode := 2#111_100#;
    83.    MINUSF   : constant KDF9.compressed_opcode := 2#111_101#;
    84.    INV076   : constant KDF9.compressed_opcode := 2#111_110#;
    85.    SIGNF    : constant KDF9.compressed_opcode := 2#111_111#;
    86.
    87.
    88.    -- compressed_opcode values for 2-syllable indirect fetch and store orders
    89.
    90.    MkMq       : constant KDF9.compressed_opcode := 2#000_000#;
    91.    MkMqQ      : constant KDF9.compressed_opcode := 2#000_010#;
    92.    MkMqH      : constant KDF9.compressed_opcode := 2#000_100#;
    93.    MkMqQH     : constant KDF9.compressed_opcode := 2#000_110#;
    94.    MkMqN      : constant KDF9.compressed_opcode := 2#001_000#;
    95.    MkMqQN     : constant KDF9.compressed_opcode := 2#001_010#;
    96.    MkMqHN     : constant KDF9.compressed_opcode := 2#001_100#;
    97.    MkMqQHN    : constant KDF9.compressed_opcode := 2#001_110#;
    98.
    99.    TO_MkMq    : constant KDF9.compressed_opcode := 2#000_001#;
   100.    TO_MkMqQ   : constant KDF9.compressed_opcode := 2#000_011#;
   101.    TO_MkMqH   : constant KDF9.compressed_opcode := 2#000_101#;
   102.    TO_MkMqQH  : constant KDF9.compressed_opcode := 2#000_111#;
   103.    TO_MkMqN   : constant KDF9.compressed_opcode := 2#001_001#;
   104.    TO_MkMqQN  : constant KDF9.compressed_opcode := 2#001_011#;
   105.    TO_MkMqHN  : constant KDF9.compressed_opcode := 2#001_101#;
   106.    TO_MkMqQHN : constant KDF9.compressed_opcode := 2#001_111#;
   107.
   108.
   109.    -- compressed_opcode values for 2-syllable Q store orders
   110.
   111.    M_PLUS_Iq    : constant KDF9.compressed_opcode := 2#100_000#;
   112.    M_MINUS_Iq   : constant KDF9.compressed_opcode := 2#100_001#;
   113.    NCq          : constant KDF9.compressed_opcode := 2#100_010#;
   114.    DCq          : constant KDF9.compressed_opcode := 2#100_011#;
   115.    POS1_TO_Iq   : constant KDF9.compressed_opcode := 2#100_100#;
   116.    NEG1_TO_Iq   : constant KDF9.compressed_opcode := 2#100_101#;
   117.    POS2_TO_Iq   : constant KDF9.compressed_opcode := 2#100_110#;
   118.    NEG2_TO_Iq   : constant KDF9.compressed_opcode := 2#100_111#;
   119.
   120.    MqTOQk       : constant KDF9.compressed_opcode := 2#101_001#;
   121.    IqTOQk       : constant KDF9.compressed_opcode := 2#101_010#;
   122.    IMqTOQk      : constant KDF9.compressed_opcode := 2#101_011#;
   123.    CqTOQk       : constant KDF9.compressed_opcode := 2#101_100#;
   124.    CMqTOQk      : constant KDF9.compressed_opcode := 2#101_101#;
   125.    CIqTOQk      : constant KDF9.compressed_opcode := 2#101_110#;
   126.    QqTOQk       : constant KDF9.compressed_opcode := 2#101_111#;
   127.
   128.    SHA          : constant KDF9.compressed_opcode := 2#110_001#;
   129.    SHAD         : constant KDF9.compressed_opcode := 2#110_010#;
   130.    MACC         : constant KDF9.compressed_opcode := 2#110_011#;
   131.    SHL          : constant KDF9.compressed_opcode := 2#110_100#;
   132.    SHLD         : constant KDF9.compressed_opcode := 2#110_110#;
   133.    SHC          : constant KDF9.compressed_opcode := 2#110_111#;
   134.    constant_bit : constant := 1;
   135.
   136.    TO_RCIMq     : constant KDF9.compressed_opcode := 2#111_000#;
   137.    QCIMq        : constant KDF9.compressed_opcode := 2#111_001#;
   138.    ADD_TO_QCIMq : constant KDF9.compressed_opcode := 2#111_010#;
   139.
   140.    -- masks for Q store Qk bits
   141.
   142.    reset_choice  : constant := 2#0001#;
   143.    C_part_choice : constant := 2#1000#;
   144.    I_part_choice : constant := 2#0100#;
   145.    M_part_choice : constant := 2#0010#;
   146.    all_Q_choice  : constant := C_part_choice + I_part_choice + M_part_choice;
   147.
   148.
   149.    -- compressed_opcode values for 2-syllable SJNS orders
   150.
   151.    LINK    : constant KDF9.compressed_opcode := 2#111_011#;
   152.    TO_LINK : constant KDF9.compressed_opcode := 2#111_100#;
   153.
   154.
   155.    -- compressed_opcode values for 2-syllable Director-only orders
   156.
   157.    TO_Kq : constant KDF9.compressed_opcode := 2#111_101#;
   158.    K0    : constant := 2#1000#;
   159.    K1    : constant := 2#0100#;
   160.    K2    : constant := 2#0010#;
   161.    K3    : constant := 2#0001#;
   162.    Kk    : constant KDF9.compressed_opcode := 2#111_110#;
   163.    K4    : constant := 2#1000#;
   164.    K5    : constant := 2#0100#;
   165.    K7    : constant := 2#0001#;
   166.
   167.
   168.    -- compressed_opcode value for 2-syllable short-loop jump order
   169.
   170.    JCqNZS : constant KDF9.compressed_opcode := 2#111_111#;
   171.
   172.
   173.    -- compressed_opcode values for 2-syllable I/O orders
   174.
   175.    CT_PMB_PMC_BUSY_Qq     : constant KDF9.compressed_opcode := 2#010_000#;
   176.    PAR_Qq                 : constant KDF9.compressed_opcode := 2#010_001#;
   177.    PMF_PMG_Qq             : constant KDF9.compressed_opcode := 2#010_010#;
   178.    PIA_PIC_CLO_TLO_Qq     : constant KDF9.compressed_opcode := 2#010_100#;
   179.    PIB_PID_Qq             : constant KDF9.compressed_opcode := 2#010_101#;
   180.    PIE_PIG_Qq             : constant KDF9.compressed_opcode := 2#010_110#;
   181.    PIF_PIH_Qq             : constant KDF9.compressed_opcode := 2#010_111#;
   182.
   183.    POA_POC_POE_POF_PMH_Qq : constant KDF9.compressed_opcode := 2#011_000#;
   184.    POB_POD_Qq             : constant KDF9.compressed_opcode := 2#011_001#;
   185.    POG_POL_Qq             : constant KDF9.compressed_opcode := 2#011_010#;
   186.    POH_POK_Qq             : constant KDF9.compressed_opcode := 2#011_011#;
   187.    PMA_PMK_INT_Qq         : constant KDF9.compressed_opcode := 2#011_100#;
   188.    PMD_PME_PML_Qq         : constant KDF9.compressed_opcode := 2#011_110#;
   189.
   190.    -- masks for I/O opcode extension bits (Qk field)
   191.
   192.    PAR_bits  : constant := 2#0000#;
   193.
   194.    -- PIA_PIC_CLO_TLO_Qq:
   195.    PIA_bits  : constant := 2#0000#;
   196.    PIC_bits  : constant := 2#1000#;
   197.    CLO_bits  : constant := 2#0010#;
   198.    TLO_bits  : constant := 2#0100#;
   199.
   200.    -- PIB_PID_Qq:
   201.    PIB_bits  : constant := 2#0000#;
   202.    PID_bits  : constant := 2#1000#;
   203.
   204.    -- PIE_PIG_Qq:
   205.    PIE_bits  : constant := 2#0000#;
   206.    PIG_bits  : constant := 2#1000#;
   207.
   208.    -- PIF_PIH_Qq:
   209.    PIF_bits  : constant := 2#0000#;
   210.    PIH_bits  : constant := 2#1000#;
   211.
   212.    -- PMA_PMK_INT_Qq:
   213.    PMA_bits  : constant := 2#0000#;
   214.    PMK_bits  : constant := 2#0100#;
   215.    INT_bits  : constant := 2#0010#;
   216.
   217.    -- CT_PMB_PMC_BUSY_Qq:
   218.    CTQ_bits   : constant := 2#0000#;
   219.    PMB_bits   : constant := 2#1000#;
   220.    PMC_bits   : constant := 2#0100#;
   221.    BUSY_bits  : constant := 2#0010#;
   222.    manual_bit : constant := 2#0001#;
   223.
   224.    -- PMD_PME_PML_Qq:
   225.    PME_bits  : constant := 2#0000#;
   226.    PMD_bits  : constant := 2#1000#;
   227.    PML_bits  : constant := 2#0100#;
   228.
   229.    -- PMF_PMG_Qq:
   230.    PMF_bits  : constant := 2#0000#;
   231.    PMG_bits  : constant := 2#0100#;
   232.
   233.    -- POA_POC_POE_POF_PMH_Qq:
   234.    POA_bits  : constant := 2#0000#;
   235.    POC_bits  : constant := 2#1000#;
   236.    POE_bits  : constant := 2#1100#;
   237.    POF_bits  : constant := 2#0100#;
   238.    PMH_bits  : constant := 2#0010#;
   239.
   240.    -- POB_POD_Qq:
   241.    POB_bits  : constant := 2#0000#;
   242.    POD_bits  : constant := 2#1000#;
   243.
   244.    -- POG_POL_Qq:
   245.    POG_bits  : constant := 2#0000#;
   246.    POL_bits  : constant := 2#1000#;
   247.
   248.    -- POH_POK_Qq:
   249.    POH_bits  : constant := 2#0000#;
   250.    POK_bits  : constant := 2#1000#;
   251.
   252.
   253.    -- compressed_opcode values for normal jump orders
   254.
   255.    JrNE   : constant KDF9.compressed_opcode := 2#000_001#;
   256.    JrGEZ  : constant KDF9.compressed_opcode := 2#000_010#;
   257.    JrLEZ  : constant KDF9.compressed_opcode := 2#000_100#;
   258.    JrNEZ  : constant KDF9.compressed_opcode := 2#000_110#;
   259.    JrNV   : constant KDF9.compressed_opcode := 2#001_000#;
   260.    OS_OUT : constant KDF9.compressed_opcode := 2#001_001#;
   261.    JrNEN  : constant KDF9.compressed_opcode := 2#001_010#;
   262.    Jr     : constant KDF9.compressed_opcode := 2#001_011#;
   263.    JrNEJ  : constant KDF9.compressed_opcode := 2#001_100#;
   264.    JSr    : constant KDF9.compressed_opcode := 2#001_101#;
   265.    JrNTR  : constant KDF9.compressed_opcode := 2#001_110#;
   266.    EXIT_n : constant KDF9.compressed_opcode := 2#001_111#;  -- 0h0 in bits 5-7
   267.    JrEQ   : constant KDF9.compressed_opcode := 2#010_001#;
   268.    JrLTZ  : constant KDF9.compressed_opcode := 2#010_010#;
   269.    JrGTZ  : constant KDF9.compressed_opcode := 2#010_100#;
   270.    JrEQZ  : constant KDF9.compressed_opcode := 2#010_110#;
   271.    JrV    : constant KDF9.compressed_opcode := 2#011_000#;
   272.    JrEN   : constant KDF9.compressed_opcode := 2#011_010#;
   273.    JrEJ   : constant KDF9.compressed_opcode := 2#011_100#;
   274.    JrTR   : constant KDF9.compressed_opcode := 2#011_110#;
   275.    EXITD  : constant KDF9.compressed_opcode := 2#011_111#;  -- 010 in bits 5-7
   276.    JrCqZ  : constant KDF9.compressed_opcode := 2#100_000#;
   277.    JrCqNZ : constant KDF9.compressed_opcode := 2#110_000#;
   278.
   279.    EXIT_1_bit : constant := 2#010#;  -- 0h0 in bits 5-7 of EXIT syllable_0
   280.
   281.
   282.    -- compressed_opcode values for directly-addressed data access orders
   283.
   284.    EaMq     : constant KDF9.compressed_opcode := 2#000_000#;
   285.    TO_EaMq  : constant KDF9.compressed_opcode := 2#000_001#;
   286.    EaMqQ    : constant KDF9.compressed_opcode := 2#000_010#;
   287.    TO_EaMqQ : constant KDF9.compressed_opcode := 2#000_011#;
   288.    SET      : constant KDF9.compressed_opcode := 2#000_100#;
   289.
   290.
   291. end KDF9.decoding;

 291 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-egdon.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Implement the API (OUTs) of the EGDON Director.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body KDF9.EGDON is
    18.
    19.    procedure do_an_EGDON_OUT (OUT_number : in KDF9.word) is
    20.    begin
    21.       trap_unimplemented_feature("EGDON OUT" & OUT_number'Image);
    22.    end do_an_EGDON_OUT;
    23.
    24. end KDF9.EGDON;

Compiling: ../Source/kdf9-egdon.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Implement the API (OUTs) of the EGDON Director.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.EGDON is
    18.
    19.    procedure do_an_EGDON_OUT (OUT_number : in KDF9.word);
    20.
    21. end KDF9.EGDON;

 24 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-dispatcher.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- CPU I/O orders are dispatched here to device-specific handlers within the IOC type hierarchy.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with KDF9.PHU_store;
    18. with tracing;
    19.
    20. use  tracing;
    21.
    22. package body IOC.dispatcher is
    23.
    24.    --
    25.    --
    26.    -- CLO, SLO and TLO do not operate on a buffer, and so can be fully implemented here.
    27.    --
    28.    --
    29.
    30.    procedure CLO (Q_operand   : in KDF9.Q_register;
    31.                   set_offline : in Boolean) is
    32.       pragma Unreferenced(set_offline);
    33.       use  KDF9.PHU_store;
    34.    begin
    35.       -- This is a Director-only instruction.
    36.       take_note_of_test("   ", Q_operand, False);
    37.       unlock_absolute_addresses(Q_operand);
    38.       -- CLO also clears PHU[CPL].
    39.       PHU(CPL) := idle_PHU;
    40.       add_in_the_IO_lockout_CPU_time(Q_operand);
    41.    end CLO;
    42.
    43.    procedure SLO (Q_operand   : in KDF9.Q_register;
    44.                   set_offline : in Boolean) is
    45.       pragma Unreferenced(set_offline);
    46.    begin
    47.       -- This is a Director-only instruction.
    48.       take_note_of_test("   ", Q_operand, False);
    49.       lock_out_absolute_addresses(Q_operand);
    50.       add_in_the_IO_lockout_CPU_time(Q_operand);
    51.    end SLO;
    52.
    53.    procedure TLO (Q_operand   : in KDF9.Q_register;
    54.                   result      : out Boolean) is
    55.    begin
    56.       -- This is NOT Director-only.
    57.       result := there_are_locks_in_relative_addresses(Q_operand);
    58.       take_note_of_test("   ", Q_operand, result);
    59.       add_in_the_IO_lockout_CPU_time(Q_operand);
    60.    end TLO;
    61.
    62.    --
    63.    --
    64.    -- All other I/O orders do access a buffer, and so dispatch to the relevant device driver.
    65.    --
    66.    --
    67.
    68.    procedure BUSY (Q_operand   : in KDF9.Q_register;
    69.                    set_offline : in Boolean;
    70.                    result      : out Boolean) is
    71.    begin
    72.       buffer(Q_operand.C and buffer_number_mask).BUSY(Q_operand, set_offline, result);
    73.    end BUSY;
    74.
    75.    procedure PAR (Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean;
    77.                   result      : out Boolean) is
    78.    begin
    79.       buffer(Q_operand.C and buffer_number_mask).PAR(Q_operand, set_offline, result);
    80.    end PAR;
    81.
    82.    procedure MANUAL_CT (Q_operand   : in KDF9.Q_register;
    83.                         set_offline : in Boolean) is
    84.    begin
    85.       buffer(Q_operand.C and buffer_number_mask).MANUAL_CT(Q_operand, set_offline);
    86.    end MANUAL_CT;
    87.
    88.    procedure INT (Q_operand   : in KDF9.Q_register;
    89.                   set_offline : in Boolean) is
    90.    begin
    91.       buffer(Q_operand.C and buffer_number_mask).INT(Q_operand, set_offline);
    92.    end INT;
    93.
    94.    procedure PIA (Q_operand   : in KDF9.Q_register;
    95.                   set_offline : in Boolean) is
    96.    begin
    97.       buffer(Q_operand.C and buffer_number_mask).PIA(Q_operand, set_offline);
    98.       add_in_the_IO_lockout_CPU_time(Q_operand);
    99.    end PIA;
   100.
   101.    procedure PIB (Q_operand   : in KDF9.Q_register;
   102.                   set_offline : in Boolean) is
   103.    begin
   104.       buffer(Q_operand.C and buffer_number_mask).PIB(Q_operand, set_offline);
   105.       add_in_the_IO_lockout_CPU_time(Q_operand);
   106.    end PIB;
   107.
   108.    procedure PIC (Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean) is
   110.    begin
   111.       buffer(Q_operand.C and buffer_number_mask).PIC(Q_operand, set_offline);
   112.       add_in_the_IO_lockout_CPU_time(Q_operand);
   113.    end PIC;
   114.
   115.    procedure PID (Q_operand   : in KDF9.Q_register;
   116.                   set_offline : in Boolean) is
   117.    begin
   118.       buffer(Q_operand.C and buffer_number_mask).PID(Q_operand, set_offline);
   119.       add_in_the_IO_lockout_CPU_time(Q_operand);
   120.    end PID;
   121.
   122.    procedure PIE (Q_operand   : in KDF9.Q_register;
   123.                   set_offline : in Boolean) is
   124.    begin
   125.       buffer(Q_operand.C and buffer_number_mask).PIE(Q_operand, set_offline);
   126.       add_in_the_IO_lockout_CPU_time(Q_operand);
   127.    end PIE;
   128.
   129.    procedure PIF (Q_operand   : in KDF9.Q_register;
   130.                   set_offline : in Boolean) is
   131.    begin
   132.       buffer(Q_operand.C and buffer_number_mask).PIF(Q_operand, set_offline);
   133.       add_in_the_IO_lockout_CPU_time(Q_operand);
   134.    end PIF;
   135.
   136.    procedure PIG (Q_operand   : in KDF9.Q_register;
   137.                   set_offline : in Boolean) is
   138.    begin
   139.       buffer(Q_operand.C and buffer_number_mask).PIG(Q_operand, set_offline);
   140.       add_in_the_IO_lockout_CPU_time(Q_operand);
   141.    end PIG;
   142.
   143.    procedure PIH (Q_operand   : in KDF9.Q_register;
   144.                   set_offline : in Boolean) is
   145.    begin
   146.       buffer(Q_operand.C and buffer_number_mask).PIH(Q_operand, set_offline);
   147.       add_in_the_IO_lockout_CPU_time(Q_operand);
   148.    end PIH;
   149.
   150.    procedure PMA (Q_operand   : in KDF9.Q_register;
   151.                   set_offline : in Boolean) is
   152.    begin
   153.       buffer(Q_operand.C and buffer_number_mask).PMA(Q_operand, set_offline);
   154.    end PMA;
   155.
   156.    procedure PMB (Q_operand   : in KDF9.Q_register;
   157.                   set_offline : in Boolean) is
   158.    begin
   159.       buffer(Q_operand.C and buffer_number_mask).PMB(Q_operand, set_offline);
   160.    end PMB;
   161.
   162.    procedure PMC (Q_operand   : in KDF9.Q_register;
   163.                   set_offline : in Boolean) is
   164.    begin
   165.       buffer(Q_operand.C and buffer_number_mask).PMC(Q_operand, set_offline);
   166.    end PMC;
   167.
   168.    procedure PMD (Q_operand   : in KDF9.Q_register;
   169.                   set_offline : in Boolean) is
   170.    begin
   171.       buffer(Q_operand.C and buffer_number_mask).PMD(Q_operand, set_offline);
   172.    end PMD;
   173.
   174.    procedure PME (Q_operand   : in KDF9.Q_register;
   175.                   set_offline : in Boolean) is
   176.    begin
   177.       buffer(Q_operand.C and buffer_number_mask).PME(Q_operand, set_offline);
   178.    end PME;
   179.
   180.    procedure PMF (Q_operand   : in KDF9.Q_register;
   181.                   set_offline : in Boolean) is
   182.    begin
   183.       buffer(Q_operand.C and buffer_number_mask).PMF(Q_operand, set_offline);
   184.    end PMF;
   185.
   186.    procedure PMG (Q_operand   : in KDF9.Q_register;
   187.                   set_offline : in Boolean) is
   188.    begin
   189.       buffer(Q_operand.C and buffer_number_mask).PMG(Q_operand, set_offline);
   190.    end PMG;
   191.
   192.    procedure PMK (Q_operand   : in KDF9.Q_register;
   193.                   set_offline : in Boolean) is
   194.    begin
   195.       buffer(Q_operand.C and buffer_number_mask).PMK(Q_operand, set_offline);
   196.    end PMK;
   197.
   198.    procedure PML (Q_operand   : in KDF9.Q_register;
   199.                   set_offline : in Boolean) is
   200.    begin
   201.       buffer(Q_operand.C and buffer_number_mask).PML(Q_operand, set_offline);
   202.    end PML;
   203.
   204.    procedure POA (Q_operand   : in KDF9.Q_register;
   205.                   set_offline : in Boolean) is
   206.    begin
   207.       buffer(Q_operand.C and buffer_number_mask).POA(Q_operand, set_offline);
   208.       add_in_the_IO_lockout_CPU_time(Q_operand);
   209.    end POA;
   210.
   211.    procedure POB (Q_operand   : in KDF9.Q_register;
   212.                   set_offline : in Boolean) is
   213.    begin
   214.       buffer(Q_operand.C and buffer_number_mask).POB(Q_operand, set_offline);
   215.       add_in_the_IO_lockout_CPU_time(Q_operand);
   216.    end POB;
   217.
   218.    procedure POC (Q_operand   : in KDF9.Q_register;
   219.                   set_offline : in Boolean) is
   220.    begin
   221.       buffer(Q_operand.C and buffer_number_mask).POC(Q_operand, set_offline);
   222.       add_in_the_IO_lockout_CPU_time(Q_operand);
   223.    end POC;
   224.
   225.    procedure POD (Q_operand   : in KDF9.Q_register;
   226.                   set_offline : in Boolean) is
   227.    begin
   228.       buffer(Q_operand.C and buffer_number_mask).POD(Q_operand, set_offline);
   229.       add_in_the_IO_lockout_CPU_time(Q_operand);
   230.    end POD;
   231.
   232.    procedure POE (Q_operand   : in KDF9.Q_register;
   233.                   set_offline : in Boolean) is
   234.    begin
   235.       buffer(Q_operand.C and buffer_number_mask).POE(Q_operand, set_offline);
   236.    end POE;
   237.
   238.    procedure POF (Q_operand   : in KDF9.Q_register;
   239.                   set_offline : in Boolean) is
   240.    begin
   241.       buffer(Q_operand.C and buffer_number_mask).POF(Q_operand, set_offline);
   242.    end POF;
   243.
   244.    procedure POG (Q_operand   : in KDF9.Q_register;
   245.                   set_offline : in Boolean) is
   246.    begin
   247.       buffer(Q_operand.C and buffer_number_mask).POG(Q_operand, set_offline);
   248.    end POG;
   249.
   250.    procedure POH (Q_operand   : in KDF9.Q_register;
   251.                   set_offline : in Boolean) is
   252.    begin
   253.       buffer(Q_operand.C and buffer_number_mask).POH(Q_operand, set_offline);
   254.    end POH;
   255.
   256.    procedure POK (Q_operand   : in KDF9.Q_register;
   257.                   set_offline : in Boolean) is
   258.    begin
   259.       buffer(Q_operand.C and buffer_number_mask).POK(Q_operand, set_offline);
   260.    end POK;
   261.
   262.    procedure POL (Q_operand   : in KDF9.Q_register;
   263.                   set_offline : in Boolean) is
   264.    begin
   265.       buffer(Q_operand.C and buffer_number_mask).POL(Q_operand, set_offline);
   266.    end POL;
   267.
   268. end IOC.dispatcher;

Compiling: ../Source/ioc-dispatcher.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- CPU I/O orders are dispatched here to device-specific handlers within the IOC type hierarchy.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.dispatcher is
    18.
    19.    procedure MANUAL_CT (Q_operand   : in KDF9.Q_register;
    20.                         set_offline : in Boolean);
    21.
    22.    procedure BUSY (Q_operand   : in KDF9.Q_register;
    23.                    set_offline : in Boolean;
    24.                    result      : out Boolean);
    25.
    26.    procedure PAR (Q_operand   : in KDF9.Q_register;
    27.                   set_offline : in Boolean;
    28.                   result      : out Boolean);
    29.
    30.    procedure TLO (Q_operand   : in KDF9.Q_register;
    31.                   result      : out Boolean);
    32.
    33.    procedure CLO (Q_operand   : in KDF9.Q_register;
    34.                   set_offline : in Boolean);
    35.
    36.    procedure SLO (Q_operand   : in KDF9.Q_register;
    37.                   set_offline : in Boolean);
    38.
    39.    procedure INT (Q_operand   : in KDF9.Q_register;
    40.                   set_offline : in Boolean);
    41.
    42.    procedure PIA (Q_operand   : in KDF9.Q_register;
    43.                   set_offline : in Boolean);
    44.
    45.    procedure PIB (Q_operand   : in KDF9.Q_register;
    46.                   set_offline : in Boolean);
    47.
    48.    procedure PIC (Q_operand   : in KDF9.Q_register;
    49.                   set_offline : in Boolean);
    50.
    51.    procedure PID (Q_operand   : in KDF9.Q_register;
    52.                   set_offline : in Boolean);
    53.
    54.    procedure PIE (Q_operand   : in KDF9.Q_register;
    55.                   set_offline : in Boolean);
    56.
    57.    procedure PIF (Q_operand   : in KDF9.Q_register;
    58.                   set_offline : in Boolean);
    59.
    60.    procedure PIG (Q_operand   : in KDF9.Q_register;
    61.                   set_offline : in Boolean);
    62.
    63.    procedure PIH (Q_operand   : in KDF9.Q_register;
    64.                   set_offline : in Boolean);
    65.
    66.    procedure PMA (Q_operand   : in KDF9.Q_register;
    67.                   set_offline : in Boolean);
    68.
    69.    procedure PMB (Q_operand   : in KDF9.Q_register;
    70.                   set_offline : in Boolean);
    71.
    72.    procedure PMC (Q_operand   : in KDF9.Q_register;
    73.                   set_offline : in Boolean);
    74.
    75.    procedure PMD (Q_operand   : in KDF9.Q_register;
    76.                   set_offline : in Boolean);
    77.
    78.    procedure PME (Q_operand   : in KDF9.Q_register;
    79.                   set_offline : in Boolean);
    80.
    81.    procedure PMF (Q_operand   : in KDF9.Q_register;
    82.                   set_offline : in Boolean);
    83.
    84.    procedure PMG (Q_operand   : in KDF9.Q_register;
    85.                   set_offline : in Boolean);
    86.
    87.    procedure PMK (Q_operand   : in KDF9.Q_register;
    88.                   set_offline : in Boolean);
    89.
    90.    procedure PML (Q_operand   : in KDF9.Q_register;
    91.                   set_offline : in Boolean);
    92.
    93.    procedure POA (Q_operand   : in KDF9.Q_register;
    94.                   set_offline : in Boolean);
    95.
    96.    procedure POB (Q_operand   : in KDF9.Q_register;
    97.                   set_offline : in Boolean);
    98.
    99.    procedure POC (Q_operand   : in KDF9.Q_register;
   100.                   set_offline : in Boolean);
   101.
   102.    procedure POD (Q_operand   : in KDF9.Q_register;
   103.                   set_offline : in Boolean);
   104.
   105.    procedure POE (Q_operand   : in KDF9.Q_register;
   106.                   set_offline : in Boolean);
   107.
   108.    procedure POF (Q_operand   : in KDF9.Q_register;
   109.                   set_offline : in Boolean);
   110.
   111.    procedure POG (Q_operand   : in KDF9.Q_register;
   112.                   set_offline : in Boolean);
   113.
   114.    procedure POH (Q_operand   : in KDF9.Q_register;
   115.                   set_offline : in Boolean);
   116.
   117.    procedure POK (Q_operand   : in KDF9.Q_register;
   118.                   set_offline : in Boolean);
   119.
   120.    procedure POL (Q_operand   : in KDF9.Q_register;
   121.                   set_offline : in Boolean);
   122.
   123. end IOC.dispatcher;
   124.

 268 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd-processes.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Implement OUTs 0, 1 and 2 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with dumping;
    18. with IOC;
    19. with IOC.fast.DR.TSD_OUTs;
    20. with IOC.fast.FD.TSD_OUTs;
    21. with IOC.slow.shift.TR;
    22. with KDF9.CPU;
    23. with KDF9.store;
    24. with KDF9.TSD.peripherals;
    25. with string_editing;
    26.
    27. with imported_value_of;
    28.
    29. use  dumping;
    30. use  IOC;
    31. use  IOC.fast.DR.TSD_OUTs;
    32. use  IOC.fast.FD.TSD_OUTs;
    33. use  IOC.slow.shift.TR;
    34. use  KDF9.store;
    35. use  KDF9.TSD.peripherals;
    36. use  string_editing;
    37.
    38. package body KDF9.TSD.processes is
    39.
    40. --
    41. -- OUTs 0, 1 and 2 terminate execution in various ways and call for appropriate finalization.
    42. --
    43.
    44.    procedure free_any_allocated_tapes (OUT_number : in KDF9.word) is
    45.    begin
    46.       for b in KDF9.buffer_number loop
    47.          if buffer(b) /= null                      and then
    48.                buffer(b).kind in MT_kind | ST_kind and then
    49.                   is_allocated(buffer(b))              then
    50.             free_the_device_on_buffer(b, OUT_number);
    51.          end if;
    52.       end loop;
    53.    end free_any_allocated_tapes;
    54.
    55.
    56. --
    57. -- OUT 0: terminate the run.
    58. --
    59.
    60.    procedure do_OUT_0 is
    61.    begin
    62.       free_any_allocated_tapes(OUT_number => 0);
    63.       notify_state_display_of_final_ICR;
    64.       log_API_message("OUT 0: end of run");
    65.       raise program_exit;
    66.    end do_OUT_0;
    67.
    68.
    69. --
    70. -- OUT 1: terminate the run and overlay another program in a fresh start.
    71. --
    72.
    73.    procedure finalize_interim_diagnostics (OUT_number : in KDF9.word) is
    74.    begin
    75.       if the_log_is_wanted and pre_overlay_state_is_enabled then
    76.          show_final_state("before overlay by OUT" & OUT_number'Image);
    77.       end if;
    78.
    79.       -- Deal with any dump requests.
    80.       if the_log_is_wanted and nr_of_post_dumping_areas /= 0 then
    81.          log_new_line;
    82.          log_rule;
    83.          log_title("Post-run Dump:");
    84.          print_postrun_dump_areas;
    85.       end if;
    86.       remove_prerun_dump_areas;
    87.       remove_postrun_dump_areas;
    88.
    89.       -- Restart tracing.
    90.       clear_retro_FIFO;
    91.       clear_IOC_FIFO;
    92.       clear_the_histogram;
    93.       clear_the_profile;
    94.       the_profile_is_wanted := False;
    95.       the_INS_plot_is_wanted := False;
    96.       if the_external_trace_is_enabled then
    97.          log_an_external_trace_header("ee9: Restarting the run for OUT" & OUT_number'Image);
    98.       end if;
    99.    end finalize_interim_diagnostics;
   100.
   101.    procedure prepare_successor (new_limits : in KDF9.word; new_program_name : in String := "" ) is
   102.    begin
   103.       -- Set up any new options.
   104.       get_settings_from_file("2");
   105.       display_execution_modes(new_program_name);
   106.
   107.       -- Complete the core image.
   108.       poke_all_amendments;
   109.       save_the_initial_jump;
   110.       store_word(new_limits, 1);
   111.
   112.       -- Display initial dumps.
   113.       the_program_has_been_analysed := False;
   114.       show_all_prerun_dump_areas;
   115.
   116.       -- Establish the new CPU state.
   117.       reset_V_and_T;
   118.       set_NIA_to((0, 0));
   119.    end prepare_successor;
   120.
   121.    procedure do_OUT_1 is
   122.       P : KDF9.pair;
   123.       W : KDF9.word;
   124.    begin
   125.       -- Get the program name.
   126.       ensure_that_the_NEST_holds_2_operands;
   127.       P := pop;
   128.       P := KDF9.CPU.shift_logical(P, 24);
   129.
   130.       declare
   131.          program_name : constant String := trimmed(to_string(P));
   132.          overlay_name : constant String := imported_value_of("KDF9_BINARY", default => "Binary")
   133.                                          & "/"
   134.                                          & program_name;
   135.       begin
   136.          if program_name = "" then
   137.             trap_failing_OUT(1, "the given program name is an empty string");
   138.          end if;
   139.
   140.          if program_name = "KMW0201--UPU" then
   141.             -- The Whetstone Controller is trying to overlay itself with the Translator.
   142.             -- This is so inconvenient in practice that I simply prevent it.
   143.             notify_state_display_of_final_ICR;
   144.             log_API_message("OUT 1: ee9 will not return to the Whetstone Translator", skip => 2);
   145.             raise program_exit;
   146.          end if;
   147.
   148.          -- Tidy up the running program.
   149.          free_all_devices;
   150.          complete_all_extant_transfers;
   151.          notify_state_display_of_final_ICR;
   152.          finalize_interim_diagnostics(OUT_number => 1);
   153.          log_API_message("OUT 1: ICR ="
   154.                        & ICR'Image
   155.                        & "; RAN/EL ="
   156.                        & the_CPU_time'Image
   157.                        + "/"
   158.                        & KDF9.us'Image(the_clock_time)
   159.                        + "KDF9 us"
   160.                         );
   161.
   162.          -- The overlaid program inherits the predecessor's time and store limits.
   163.          W := fetch_word(1);
   164.          load_a_program(overlay_name);
   165.          prepare_successor(new_limits => W, new_program_name => overlay_name);
   166.
   167.          raise mode_change_request;
   168.       end;
   169.    end do_OUT_1;
   170.
   171.
   172. --
   173. -- OUT 2: terminate the run and then restart it with a program already in core.
   174. -- complete_TSD_OUT_2 is called by KDF9.microcode after it has finalized the OUT instruction.
   175. --
   176.
   177.    time_limit : KDF9.word;
   178.
   179.    procedure do_OUT_2 is
   180.    begin
   181.       ensure_that_the_NEST_holds_an_operand;
   182.       time_limit := pop;
   183.       the_trace_operand := time_limit;
   184.
   185.       -- Tidy up the running program.
   186.       free_any_allocated_tapes(OUT_number => 2);
   187.       free_any_reserved_disc_space;
   188.       free_any_reserved_drum_space;
   189.       notify_state_display_of_final_ICR;
   190.
   191.       raise OUT_2_restart;
   192.    end do_OUT_2;
   193.
   194.    procedure complete_TSD_OUT_2 is
   195.    begin
   196.       finalize_interim_diagnostics(OUT_number => 2);
   197.       if time_limit >= 2**24 then
   198.          trap_failing_OUT(2, "the new time limit =" & time_limit'Image & "s is too big");
   199.       end if;
   200.
   201.       log_API_message("OUT 2: ICR ="
   202.                     & ICR'Image
   203.                     & "; RAN/EL ="
   204.                     & the_CPU_time'Image
   205.                     + "/"
   206.                     & KDF9.us'Image(the_clock_time)
   207.                     + "KDF9 us"
   208.                     & "; new time limit ="
   209.                     & time_limit'Image
   210.                     & "s"
   211.                      );
   212.
   213.       --The successor has a new time limit and inherits the predecessor's store limit.
   214.       prepare_successor(new_limits => time_limit * 2**24 + fetch_halfword(1, 1) / 2**24);
   215.
   216.       reset_the_program_state;
   217.    end complete_TSD_OUT_2;
   218.
   219.
   220. --
   221. -- OUT 97: this not a genuine TSD OUT.
   222. --
   223.
   224.    procedure do_OUT_97 is
   225.       P      : constant KDF9.word := pop;
   226.       name   : constant String    := trimmed(to_string(P));
   227.       value  : constant String    := imported_value_of(name, "0");
   228.       number : KDF9.word;
   229.    begin
   230.       number := KDF9.word'Value(value);
   231.       the_trace_operand := number;
   232.       push(number);
   233.    exception
   234.       when others =>
   235.          trap_failing_OUT(97, name + "=" + abs value & ", not a valid integer");
   236.    end do_OUT_97;
   237.
   238. end KDF9.TSD.processes;

Compiling: ../Source/kdf9-tsd-processes.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Implement OUTs 0.. 2 and 5..7 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.processes is
    18.
    19.    procedure do_OUT_0
    20.       with No_Return, Inline => False;
    21.
    22.    procedure do_OUT_1
    23.       with No_Return, Inline => False;
    24.
    25.    procedure do_OUT_2
    26.       with No_Return, Inline => False;
    27.
    28.    procedure complete_TSD_OUT_2
    29.       with Inline => False;
    30.
    31.    procedure do_OUT_97
    32.       with Inline => False;
    33.
    34. end KDF9.TSD.processes;

 238 lines: No errors


Compiling: /home/parallels/emulation/Source/ioc-diagnostics.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Provide diagnostic output of the state of all the buffers.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with disassembly;
    18.
    19. with IOC.the_locker_of;
    20.
    21. procedure IOC.diagnostics is
    22.    Q : KDF9.Q_register;
    23.    B : KDF9.Q_part;
    24.    F : Boolean;
    25. begin
    26.    if not debugging_is_enabled then return; end if;
    27.    for g in Q_part'(0) .. 100 loop
    28.       if there_are_locks_in_physical_addresses(KDF9.Q_register'(0, 32*g, 32*g + 31)) then
    29.          output("there are locks in group" & g'Image & " PHY" & Q_part'(32*g)'Image);
    30.          B := the_locker_of(32*g, F);
    31.          output(", locked by" & B'Image & ":");
    32.          if F then output_line(buffer(B).device_name); else output_line("??"); end if;
    33.       end if;
    34.    end loop;
    35.    for the_buffer of buffer loop
    36.       if the_buffer /= null                        and then
    37.          the_buffer.initiation_time /= KDF9.us'Last    then
    38.          output_line;
    39.          output_line("Current state of buffer #" & oct_of(the_buffer.number, 2));
    40.          output_line("   device: " & the_buffer.device_name);
    41.          output_line("  is_busy: " & the_buffer.is_busy'Image);
    42.          output_line("operation: " & the_buffer.operation'Image);
    43.          output_line(" off_line: " & the_buffer.is_offline'Image);
    44.          output_line(" abnormal: " & the_buffer.is_abnormal'Image);
    45.          output_line(" Director: " & the_buffer.is_for_Director'Image);
    46.          output_line(" priority:"  & the_buffer.priority_level'Image);
    47.          output_line("initiated:"  & the_buffer.initiation_time'Image);
    48.          output_line("xfer_time:"  & the_buffer.transfer_time'Image);
    49.          output_line("completes:"  & the_buffer.completion_time'Image);
    50.          Q := the_buffer.control_word;
    51.          output_line(
    52.                      "  control: "
    53.                    & "Q"
    54.                    & Q.C'Image
    55.                    &"/"
    56.                    & Q.I'Image
    57.                    & "/"
    58.                    & Q.M'Image
    59.                     );
    60.          if Q.I <= KDF9.address'Last               and then
    61.              Q.M <= KDF9.address'Last              and then
    62.                 Q.I <= the_buffer.control_word.M then
    63.             output_line(
    64.                         "locked in:"
    65.                       & group(Q.I)'Image
    66.                       & ".."
    67.                       & group(Q.M)'Image
    68.                       & " is "
    69.                       & there_are_locks_in_physical_addresses(Q)'Image
    70.                        );
    71.          end if;
    72.          output_line("order ICR:"  & the_buffer.order_count'Image);
    73.          output_line("    order: " & disassembly.the_full_name_of(the_buffer.decoded_order, True));
    74.          output_line("@ address: " & oct_of(the_buffer.order_address));
    75.       end if;
    76.    end loop;
    77. end IOC.diagnostics;

 77 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc_tape_data.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- This contains information used by magnetic tape emulation.
     2. -- It is separated out to allow use in programs other than ee9
     3. --    without dragging in all the dependencies of IOC.
     4. --
     5. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     6. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     7. --
     8. -- The ee9 program is free software; you can redistribute it and/or
     9. -- modify it under terms of the GNU General Public License as published
    10. -- by the Free Software Foundation; either version 3, or (at your option)
    11. -- any later version. This program is distributed in the hope that it
    12. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    13. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    14. -- See the GNU General Public License for more details. You should have
    15. -- received a copy of the GNU General Public License distributed with
    16. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    17. --
    18.
    19. with Ada.Characters.Latin_1;
    20.
    21. use  Ada.Characters.Latin_1;
    22.
    23. package IOC_tape_data is -- NB NOT a child of IOC!
    24.
    25.    -- 81 is efficient for both card images and full 160-column print lines with final LS or PC.
    26.    slice_size_limit : constant := 81;
    27.
    28.    MT_record_length : constant := slice_size_limit + 3;
    29.
    30.    subtype valid_slice_kinds is Character
    31.       with Static_Predicate => valid_slice_kinds in 'D' | 'G' | 'W' | 'e' | 'o';
    32.
    33.    subtype erasure_kinds is Character
    34.       with Static_Predicate => erasure_kinds in 'G' | 'W';
    35.
    36.    subtype tape_mark_kinds is Character
    37.       with Static_Predicate => tape_mark_kinds in 'e' | 'o';
    38.
    39.    subtype valid_slice_flags is Character
    40.       with Static_Predicate => valid_slice_flags in NUL | SOH | BS | HT | '@' | 'A' | 'H' | 'I';
    41.
    42.    subtype final_slice_flags is Character
    43.       with Static_Predicate => final_slice_flags in BS | HT | 'H' | 'I';
    44.
    45.    subtype last_block_flags is Character
    46.       with Static_Predicate => last_block_flags in '@' | 'A' | 'H' | 'I';
    47.
    48.    -- This is the (only) character written to a 7-track tape mark block.
    49.    -- It is the  character on file, but is read back as #17 by the PI?Qq orders.
    50.    -- Section_Sign is appropriate because tape marks are used to delimit sections of a tape file.
    51.    -- See Manual, Appendix 7 2, p317.
    52.    tape_mark_sign  : constant Character := Section_Sign;
    53.
    54.    block_padding   : constant Character := Middle_Dot;
    55.
    56.    -- This subtype is used in the post-processing of OUT 8 spool tapes.
    57.    subtype OUT8_selection_characters is Character
    58.       with Static_Predicate => OUT8_selection_characters in '#' | '_' | '@' | '"';
    59.
    60. end IOC_tape_data;

 60 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/plotter.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Emulation of the plotting commands of the Calcomp 564 graph plotter.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.slow.shift.GP;
    18. with postscript;
    19.
    20. use  IOC.slow.shift.GP;
    21. use  postscript;
    22.
    23. package body plotter is
    24.
    25.    -- The plotter made equal movements in the x and y directions, in steps of 0.005 inches.
    26.    -- Each command moves the plotting position by at most 1 step,
    27.    --   in either the positive or negative direction of each axis.
    28.
    29.    type step is
    30.       record
    31.          dx, dy : Integer range -1 .. +1;
    32.       end record;
    33.
    34.    null_step : constant plotter.step := (0, 0);
    35.
    36.    function "+" (p : postscript.point; s : plotter.step)
    37.    return postscript.point
    38.    is ((p.x + s.dx, p.y + s.dy));
    39.
    40.    function "-" (p, q : postscript.point)
    41.    return plotter.step
    42.    is ((p.x - q.x, p.y - q.y));
    43.
    44.    -- The plotter drew on a roll of paper 29.5 inches wide and 120 feet long.
    45.    -- 29.5" is   5900 steps at 200 steps per inch = 59 * 100
    46.    -- 120'  is 288000 steps  = 200 per inch * 12 inches per foot * 120 feet.
    47.    -- This sets the boundaries of the plot.
    48.    -- It was physically impossible to move to a point beyond these limits.
    49.
    50.    plot_limit : constant postscript.point := (120*12*200, 59*100);
    51.
    52.    -- A vector is represented by a series of consecutive colinear plotter movements.
    53.    -- For better efficiency, the steps of a vector are accumulated until there is
    54.    --    a change of direction, a pen lift, or the need to close the plotter file.
    55.    -- On these events, any vector thus defined is drawn via a single PostScript command.
    56.
    57.    the_origin      : constant postscript.point := (0, 0);
    58.
    59.    plot_position,
    60.    start_position  : postscript.point := the_origin;
    61.
    62.    -- last_step retains the direction of the previous plotter step.
    63.    last_step       : plotter.step := null_step;
    64.
    65.    the_pen_is_down : Boolean := False;
    66.
    67.    procedure ensure_the_validity_of (from  : in postscript.point;
    68.                                      step  : in plotter.step) is
    69.    begin
    70.      if from.x + step.dx < 0                     or else
    71.            from.y + step.dy < 0                  or else
    72.               from.x + step.dx > plot_limit.x    or else
    73.                  from.y + step.dy > plot_limit.y    then
    74.         notify_invalid_movement(from.x, from.y, step.dx, step.dy);
    75.      end if;
    76.    end ensure_the_validity_of;
    77.
    78.    procedure jump_to (p : in postscript.point)
    79.      with Inline;
    80.
    81.    procedure jump_to (p : in postscript.point) is
    82.    begin
    83.      -- Posit a new vector starting at p.
    84.      last_step := null_step;
    85.      plot_position := p;
    86.      start_position := p;
    87.    end;
    88.
    89.    procedure jump_by (this_step : in plotter.step)
    90.      with Inline;
    91.
    92.    procedure jump_by (this_step : in plotter.step) is
    93.    begin
    94.      ensure_the_validity_of(from => plot_position, step => this_step);
    95.      jump_to(plot_position + this_step);
    96.    end jump_by;
    97.
    98.    procedure close_any_open_vector (stream : in out host_IO.stream) is
    99.    begin
   100.      if the_pen_is_down                and then
   101.            start_position /= plot_position then
   102.         draw_a_PS_vector(stream, start_position, plot_position);
   103.         start_position := plot_position;
   104.      end if;
   105.    end close_any_open_vector;
   106.
   107.    procedure perform (action : in plotter.command; stream : in out host_IO.stream) is
   108.
   109.      procedure draw_to (p : in postscript.point)
   110.         with Inline;
   111.
   112.      procedure draw_to (p : in postscript.point) is
   113.      begin
   114.         if (plot_position - p) = last_step then
   115.            -- p is colinear with the previous step, so merely extend the vector to p.
   116.            plot_position := p;
   117.         else
   118.            -- Draw the whole vector and start a new one.
   119.            draw_a_PS_vector(stream, start_position, plot_position);
   120.            last_step := plot_position - p;
   121.            start_position := plot_position;
   122.            plot_position := p;
   123.         end if;
   124.      end draw_to;
   125.
   126.      procedure draw_by (this_step : in plotter.step)
   127.         with Inline;
   128.
   129.      procedure draw_by (this_step : in plotter.step) is
   130.      begin
   131.         ensure_the_validity_of(from => plot_position, step => this_step);
   132.         draw_to(plot_position + this_step);
   133.      end draw_by;
   134.
   135.      procedure move_by (this_step : in plotter.step)
   136.         with Inline;
   137.
   138.      procedure move_by (this_step : in plotter.step) is
   139.      begin
   140.         -- Convert from Natural orientation of X axis to PostScript direction.
   141.         if the_pen_is_down then
   142.            draw_by((-this_step.dx, +this_step.dy));
   143.         else
   144.            jump_by((-this_step.dx, +this_step.dy));
   145.         end if;
   146.      end move_by;
   147.
   148.    begin -- perform
   149.      case action is
   150.         when dummy =>
   151.            null;
   152.         when pen_up =>
   153.            close_any_open_vector(stream);
   154.            the_pen_is_down := False;
   155.         when pen_down =>
   156.            the_pen_is_down := True;
   157.         when go_pY =>
   158.            move_by((+0, +1));
   159.         when go_nY =>
   160.            move_by((+0, -1));
   161.         when go_pX =>
   162.            move_by((+1, +0));
   163.         when go_nX =>
   164.            move_by((-1, +0));
   165.         when go_pXpY =>
   166.            move_by((+1, +1));
   167.         when go_nXnY =>
   168.            move_by((-1, -1));
   169.         when go_pXnY =>
   170.            move_by((+1, -1));
   171.         when go_nXpY =>
   172.            move_by((-1, +1));
   173.         when others =>
   174.            -- EM causes a 'peculiar' motion, according to the Manual, Appendix 5.2, p.303,
   175.            --    and other codes cause 'unpredictable' effects.
   176.            -- ee9 therefore performs an arbitrary, but safe, operation: moving to the origin.
   177.            close_any_open_vector(stream);
   178.            plot_position := the_origin;
   179.      end case;
   180.    end perform;
   181.
   182.    a_plot_is_open : Boolean := False;
   183.
   184.    procedure open_the_plot_file (stream : in out host_IO.stream) is
   185.    begin
   186.      if a_plot_is_open then
   187.         close_the_plot_file(stream);
   188.      end if;
   189.      plot_position := (0,0);
   190.      a_plot_is_open := True;
   191.    end open_the_plot_file;
   192.
   193.    procedure close_the_plot_file (stream : in out host_IO.stream) is
   194.    begin
   195.      if not a_plot_is_open then
   196.         return;
   197.      end if;
   198.      close_any_open_vector(stream);
   199.      a_plot_is_open := False;
   200.    end close_the_plot_file;
   201.
   202. end plotter;

Compiling: ../Source/plotter.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Emulation of the plotting commands of the Calcomp 564 graph plotter.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with host_IO;
    18. with KDF9_char_sets;
    19.
    20. use  host_IO;
    21.
    22. package plotter is
    23.
    24.    procedure open_the_plot_file (stream : in out host_IO.stream);
    25.
    26.    procedure close_the_plot_file (stream : in out host_IO.stream);
    27.
    28.    type command is new KDF9_char_sets.symbol;
    29.
    30.    -- The KDF9 plotting commands are defined in the Manual, Appendix 6, 5.3, pp. 303-304.
    31.
    32.    -- BUT there is obviously an error in the Manual, as only 9 of the claimed 11 command
    33.    --    codes are listed, and the last, go_nXnY, is coded inconsistently with the others.
    34.
    35.    -- Hypothesis: the table should read as follows:
    36.
    37.    dummy    : constant plotter.command := 2#000_000#;
    38.
    39.    pen_up   : constant plotter.command := 2#100_000#;
    40.    pen_down : constant plotter.command := 2#010_000#;
    41.
    42.    go_pY    : constant plotter.command := 2#001_000#;
    43.    go_nY    : constant plotter.command := 2#000_100#;
    44.    go_pX    : constant plotter.command := 2#000_010#;
    45.    go_nX    : constant plotter.command := 2#000_001#;
    46.
    47.    go_nXnY  : constant plotter.command := go_nX + go_nY;
    48.    go_pXnY  : constant plotter.command := go_pX + go_nY;
    49.    go_nXpY  : constant plotter.command := go_nX + go_pY;
    50.    go_pXpY  : constant plotter.command := go_pX + go_pY;
    51.
    52.    -- These encodings are consistent with the Calcomp plotter command codes used here:
    53.    --     ub.fnwi.uva.nl/computermuseum//calcomp565.html
    54.    -- which defines a full set of 11 commands, two of which are missing from the KDF9 list.
    55.
    56.    is_valid : constant array (plotter.command) of Boolean
    57.             := (dummy    |
    58.                 pen_up   |
    59.                 pen_down |
    60.                 go_pY    |
    61.                 go_nY    |
    62.                 go_pX    |
    63.                 go_nX    |
    64.                 go_pXnY  |
    65.                 go_nXpY  |
    66.                 go_pXpY  |
    67.                 go_nXnY  => True,
    68.                 others   => False
    69.                );
    70.
    71.    procedure perform (action : in plotter.command; stream : in out host_IO.stream);
    72.
    73. end plotter;

 202 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-dr-tsd_outs.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Implement the drum API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.dispatcher;
    18. with KDF9.TSD;
    19.
    20. use  IOC.dispatcher;
    21. use  KDF9.TSD;
    22.
    23. package body IOC.fast.DR.TSD_OUTs is
    24.
    25.    OUT13_was_done          : Boolean   := False;
    26.    last_reserved_DR_sector : KDF9.word := -1;
    27.
    28.    procedure free_any_reserved_drum_space is
    29.    begin
    30.       OUT13_was_done := False;
    31.       last_reserved_DR_sector := -1;
    32.    end free_any_reserved_drum_space;
    33.
    34.    Q : KDF9.Q_register;
    35.    W : KDF9.word;
    36.
    37.    procedure access_the_OUT_operand is
    38.    begin
    39.       ensure_that_the_NEST_holds_an_operand;
    40.       W := pop;
    41.       Q := as_Q(W);
    42.       the_trace_operand := W;
    43.     end access_the_OUT_operand;
    44.
    45.    procedure ensure_that_DR0_is_enabled (OUT_number : in KDF9.word) is
    46.    begin
    47.       if not DR0_is_enabled then
    48.          trap_failing_OUT(OUT_number, "there is no drum in this configuration");
    49.       end if;
    50.    end ensure_that_DR0_is_enabled;
    51.
    52.    procedure formulate_the_drum_transfer_operand (OUT_number : in KDF9.word) is
    53.       S : KDF9.word;
    54.    begin
    55.       ensure_that_DR0_is_enabled(OUT_number);
    56.       if not OUT13_was_done then
    57.          trap_failing_OUT(OUT_number, "obeyed before OUT 13");
    58.       end if;
    59.       S := KDF9.word(Q.C + (Q.M - Q.I + bytes_per_sector/2) / bytes_per_sector);
    60.       if S > last_reserved_DR_sector then
    61.          trap_failing_OUT(OUT_number, "too many drum sectors would be transferred");
    62.       end if;
    63.       Q := (Q.C*16 + DR0_number, Q.I, Q.M);
    64.       the_trace_operand := as_word(Q);
    65.    end formulate_the_drum_transfer_operand;
    66.
    67.    procedure do_OUT_11 is
    68.    begin
    69.       access_the_OUT_operand;
    70.       formulate_the_drum_transfer_operand(11);
    71.       restore_the_IO_OUT_operands(11, W);
    72.          POA(Q, False);
    73.       remove_the_IO_OUT_operands;
    74.    end do_OUT_11;
    75.
    76.    procedure do_OUT_12 is
    77.    begin
    78.       access_the_OUT_operand;
    79.       formulate_the_drum_transfer_operand(12);
    80.       restore_the_IO_OUT_operands(12, W);
    81.          PIA(Q, False);
    82.       remove_the_IO_OUT_operands;
    83.    end do_OUT_12;
    84.
    85.    procedure do_OUT_13 is
    86.    begin
    87.       access_the_OUT_operand;
    88.       ensure_that_DR0_is_enabled(13);
    89.       if OUT13_was_done then
    90.          trap_failing_OUT(13, "obeyed a second time");
    91.       end if;
    92.       if W > sectors_per_system or else
    93.             W = 0                  then
    94.          trap_failing_OUT(13, "demands an impossible number of drum sectors");
    95.       end if;
    96.       last_reserved_DR_sector := W - 1;
    97.       OUT13_was_done := True;
    98.       set_state_of(buffer(DR0_number), allocated => True);
    99.       log_API_message("OUT 13: allocated" & W'Image + "drum sectors");
   100.    end do_OUT_13;
   101.
   102.    procedure do_OUT_14 is
   103.    begin
   104.       -- I assume that the drum never experiences a parity error in ee9.
   105.       ensure_that_DR0_is_enabled(14);
   106.       if OUT13_was_done then
   107.          the_trace_operand := (sectors_per_system - last_reserved_DR_sector - 1) or 2**47;
   108.       else
   109.          the_trace_operand := sectors_per_system;
   110.       end if;
   111.       push(the_trace_operand);
   112.    end do_OUT_14;
   113.
   114. end IOC.fast.DR.TSD_OUTs;

Compiling: ../Source/ioc-fast-dr-tsd_outs.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Implement the drum API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.DR.TSD_OUTs is
    18.
    19.    procedure do_OUT_11;
    20.
    21.    procedure do_OUT_12;
    22.
    23.    procedure do_OUT_13;
    24.
    25.    procedure do_OUT_14;
    26.
    27.    procedure free_any_reserved_drum_space;
    28.
    29. end IOC.fast.DR.TSD_OUTs;

 114 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-fd-tsd_outs.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Implement the fixed disc API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC.dispatcher;
    18. with KDF9.TSD;
    19.
    20. use  IOC.dispatcher;
    21. use  KDF9.TSD;
    22.
    23. package body IOC.fast.FD.TSD_OUTs is
    24.
    25.    -- See the Manual, Appendix 6, 2 for the TSD FD OUTs.
    26.
    27.    claimable_discs              : constant := 8;
    28.    sectors_per_logical_block    : constant := 16;
    29.    logical_blocks_per_seek_area : constant := sectors_per_seek_area / sectors_per_logical_block;
    30.    logical_blocks_per_platter   : constant := seek_areas_per_platter * logical_blocks_per_seek_area;
    31.    sectors_per_platter          : constant := sectors_per_logical_block * logical_blocks_per_platter;
    32.
    33.    type reserved_disc_set is
    34.       record
    35.          claimed : Boolean := False;
    36.          size    : KDF9.Q_part range 0 .. claimable_discs;
    37.          sectors : KDF9.Q_part range 0 .. claimable_discs * sectors_per_platter;
    38.          start   : KDF9.Q_part range 0 .. claimable_discs;
    39.       end record;
    40.
    41.    disc_set             : array (KDF9.Q_part range 1 .. 2) of reserved_disc_set;
    42.    disc_sets_claimed    : KDF9.Q_part range 0 .. 2 := 0;
    43.    current_disc_set     : KDF9.Q_part range 1 .. 2;
    44.    discs_claimed_so_far : KDF9.Q_part := 0;
    45.
    46.    procedure free_any_reserved_disc_space is
    47.    begin
    48.       disc_sets_claimed := 0;
    49.       discs_claimed_so_far := 0;
    50.    end free_any_reserved_disc_space;
    51.
    52.    function FD_seek_parameter (OUT_number: KDF9.word; Q : KDF9.Q_register)
    53.    return KDF9.Q_register is
    54.       current_set : reserved_disc_set renames disc_set(current_disc_set);
    55.       block       : constant KDF9.Q_part := Q.C / sectors_per_logical_block;
    56.       seek_area   : constant KDF9.Q_part := block  /  (6 * current_set.size);
    57.       residue     : constant KDF9.Q_part := block mod (6 * current_set.size);
    58.       disc        : constant KDF9.Q_part := residue / 6 + current_set.start;
    59.       drive       : constant KDF9.Q_part := 0;  -- ee9 will reserve discs on drive 0 only.
    60.       parameter   : constant KDF9.Q_part
    61.                   := drive * seek_areas_per_platter * main_discs_per_drive
    62.                    + disc  * seek_areas_per_platter
    63.                    + seek_area;
    64.    begin
    65.       if Q.C >= disc_set(current_disc_set).sectors then
    66.          trap_failing_OUT(OUT_number, Q.C'Image + "exceeds the sector capacity of the selected set");
    67.       end if;
    68.       return (parameter * 16 + FD0_number,  Q.I, Q.M);
    69.    end FD_seek_parameter;
    70.
    71.    function FD_xfer_parameter (Q : KDF9.Q_register)
    72.    return KDF9.Q_register is
    73.       sector : constant KDF9.Q_part := Q.C mod 96;
    74.    begin
    75.       return (sector * 16 + FD0_number, Q.I, Q.M);
    76.    end FD_xfer_parameter;
    77.
    78.    Q : KDF9.Q_register;
    79.    W : KDF9.word;
    80.
    81.    procedure ensure_that_FD0_is_enabled (OUT_number : in KDF9.word) is
    82.    begin
    83.       if not FD0_is_enabled then
    84.          trap_failing_OUT(OUT_number, "there is no disc in this configuration");
    85.       end if;
    86.    end ensure_that_FD0_is_enabled;
    87.
    88.    procedure access_the_operand is
    89.    begin
    90.       ensure_that_the_NEST_holds_an_operand;
    91.       W := pop;
    92.       Q := as_Q(W);
    93.       the_trace_operand := W;
    94.    end access_the_operand;
    95.
    96.    procedure do_OUT_41 is
    97.       F       : KDF9.Q_part;
    98.       seek_Q,
    99.       write_Q : KDF9.Q_register;
   100.    begin
   101.       access_the_operand;
   102.       ensure_that_FD0_is_enabled(41);
   103.       if disc_sets_claimed = 0 then
   104.          trap_failing_OUT(41, "tries to write to FD0 with no discs reserved");
   105.       end if;
   106.       W := KDF9.word(Q.C) / 16;
   107.       F := Q.C mod 16 + (Q.M - Q.I + words_per_sector - 1)/words_per_sector;
   108.       if F >= sectors_per_logical_block then
   109.          trap_failing_OUT(41, "tries to write past the end of a logical block on FD0");
   110.       end if;
   111.       seek_Q  := FD_seek_parameter(41, Q);
   112.       write_Q := FD_xfer_parameter(Q);
   113.       the_trace_operand := as_word(write_Q);
   114.       restore_the_IO_OUT_operands(42, W);
   115.          PMA(seek_Q, False);
   116.          POA(write_Q, False);
   117.       remove_the_IO_OUT_operands;
   118.    end do_OUT_41;
   119.
   120.    procedure do_OUT_42 is
   121.       F      : KDF9.Q_part;
   122.       seek_Q,
   123.       read_Q : KDF9.Q_register;
   124.    begin
   125.       access_the_operand;
   126.       ensure_that_FD0_is_enabled(42);
   127.       if disc_sets_claimed = 0 then
   128.          trap_failing_OUT(42, "tries to read from FD0 with no discs reserved");
   129.       end if;
   130.       W := KDF9.word(Q.C) / 16;
   131.       F := Q.C mod 16 + (Q.M - Q.I + words_per_sector - 1)/words_per_sector;
   132.       if F >= sectors_per_logical_block then
   133.          trap_failing_OUT(42, "tries to read past the end of a logical block on FD0");
   134.       end if;
   135.       seek_Q := FD_seek_parameter(41, Q);
   136.       read_Q := FD_xfer_parameter(Q);
   137.       the_trace_operand := as_word(read_Q);
   138.       restore_the_IO_OUT_operands(42, W);
   139.          PMA(seek_Q, False);
   140.          PIA(read_Q, False);
   141.       remove_the_IO_OUT_operands;
   142.    end do_OUT_42;
   143.
   144.    procedure do_OUT_43 is
   145.       F : KDF9.Q_part;
   146.    begin
   147.       access_the_operand;
   148.       ensure_that_FD0_is_enabled(43);
   149.       if disc_sets_claimed = 0 then
   150.          trap_failing_OUT(43, "no FD0 discs have been reserved yet");
   151.       end if;
   152.       if W not in 0 | -1 then
   153.          trap_failing_OUT(43, "tries to select an impossible set of discs");
   154.       end if;
   155.       F := as_Q(-W).M + 1;
   156.       if F > disc_sets_claimed then
   157.          trap_failing_OUT(43, "tries to select an unreserved FD0 disc set");
   158.       end if;
   159.       current_disc_set := as_Q(-the_trace_operand).M + 1;
   160.    end do_OUT_43;
   161.
   162.    procedure do_OUT_44 is
   163.       F : KDF9.Q_part;
   164.    begin
   165.       access_the_operand;
   166.       ensure_that_FD0_is_enabled(44);
   167.       if disc_sets_claimed = 2 then
   168.          trap_failing_OUT(44, "tries to reserve more than two sets of FD0 discs");
   169.       end if;
   170.       F := as_Q(W).M;
   171.       if W not in 1..claimable_discs                        or else
   172.             discs_claimed_so_far + F not in 1..claimable_discs then
   173.          trap_failing_OUT(44, "tries to reserve more than 8 FD0 discs");
   174.       end if;
   175.       current_disc_set := disc_sets_claimed + 1;
   176.       disc_set(current_disc_set).claimed := True;
   177.       disc_set(current_disc_set).size := F;
   178.       disc_set(current_disc_set).sectors := F * sectors_per_platter;
   179.       disc_set(current_disc_set).start := discs_claimed_so_far;
   180.       discs_claimed_so_far := discs_claimed_so_far + F;
   181.       disc_sets_claimed := disc_sets_claimed + 1;
   182.       log_API_message(
   183.                       "OUT 44: reserved"
   184.                     & F'Image
   185.                     + "FD0 disc"
   186.                     & plurality(KDF9.word(F))
   187.                     + "in set"
   188.                     & current_disc_set'Image
   189.                      );
   190.       set_state_of(buffer(FD0_number), allocated => True);
   191.    end do_OUT_44;
   192.
   193.    procedure do_OUT_45 is
   194.       F : KDF9.Q_part;
   195.    begin
   196.       access_the_operand;
   197.       ensure_that_FD0_is_enabled(45);
   198.       if disc_sets_claimed = 0 then
   199.          trap_failing_OUT(45, "tries to release an unreserved set of FD0 discs");
   200.       end if;
   201.       if W not in 0 | -1 then
   202.          trap_failing_OUT(45, "tries to release an unknown set of FD0 discs");
   203.       end if;
   204.       F := as_Q(-W).M + 1;
   205.       if F > disc_sets_claimed then
   206.          trap_failing_OUT(45, "tries to release more FD0 disc sets than are reserved");
   207.       end if;
   208.       log_API_message(
   209.                       "OUT 45: released"
   210.                     & disc_set(F).size'Image
   211.                     + "FD0 disc"
   212.                     & plurality(KDF9.word(disc_set(F).size))
   213.                     + "from set"
   214.                     & F'Image
   215.                      );
   216.       discs_claimed_so_far := discs_claimed_so_far - disc_set(F).size;
   217.       current_disc_set := 1;
   218.       disc_sets_claimed := disc_sets_claimed - 1;
   219.       if F = 1 then
   220.          disc_set(1) := disc_set(2);
   221.          disc_set(2).claimed := False;
   222.       end if;
   223.    end do_OUT_45;
   224.
   225.    procedure do_OUT_47 is
   226.    begin
   227.       -- I assume that disc transfer parity errors never occur under ee9.
   228.       ensure_that_FD0_is_enabled(47);
   229.       if disc_sets_claimed = 0 then
   230.          trap_failing_OUT(47, "tries to check a transfer on unreserved FD0 discs");
   231.       end if;
   232.    end do_OUT_47;
   233.
   234. end IOC.fast.FD.TSD_OUTs;

Compiling: ../Source/ioc-fast-fd-tsd_outs.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Implement the fixed disc API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.FD.TSD_OUTs is
    18.
    19.    -- See the Manual, Appendix 6, 2 for the TSD FD OUTs.
    20.
    21.    procedure do_OUT_41;
    22.
    23.    procedure do_OUT_42;
    24.
    25.    procedure do_OUT_43;
    26.
    27.    procedure do_OUT_44;
    28.
    29.    procedure do_OUT_45;
    30.
    31.    procedure do_OUT_47;
    32.
    33.    procedure free_any_reserved_disc_space;
    34.
    35. end IOC.fast.FD.TSD_OUTs;

 234 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/ioc-fast-tape-tsd_outs.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Emulation of magnetic tape decks and buffers.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package body IOC.fast.tape.TSD_OUTs is
    18.
    19.    type short_label is new String(1 .. 8);
    20.    type long_label  is new String(1 .. 16);
    21.
    22.    function needs_rewinding (b : KDF9.buffer_number)
    23.    return Boolean is
    24.       the_deck : tape.deck renames tape.deck(buffer(b).all);
    25.    begin
    26.       return the_deck.is_open and then the_deck.tape_file.position > 0;
    27.    end needs_rewinding;
    28.
    29.    procedure log_allocation (OUT_number : in KDF9.word; name, buffer, TSN : in String) is
    30.    begin
    31.       log_API_message("OUT"
    32.                  & OUT_number'Image
    33.                  & ": requested "
    34.                  & name
    35.                  & " and got "
    36.                  & buffer
    37.                  & " with TSN "
    38.                  & abs TSN
    39.                   );
    40.    end log_allocation;
    41.
    42.    procedure do_OUT_4 is
    43.       B : KDF9.Q_part;
    44.       S : KDF9.word;
    45.       W : KDF9.word;
    46.    begin
    47.       ensure_that_the_NEST_holds_an_operand;
    48.       W := pop;
    49.       declare
    50.          label : constant short_label := short_label(to_string(W));
    51.          name  : constant String := (if W = 0 then "a ZERO tape" else " " & abs String(label));
    52.       begin
    53.          find_tape(tape.data_storage(label), B, S);
    54.          push(KDF9.word(B));
    55.          the_trace_operand := KDF9.word(B);
    56.          log_allocation(4, name, buffer(B).device_name, to_string(S));
    57.       end;
    58.       set_state_of(buffer(B), allocated => True);
    59.    end do_OUT_4;
    60.
    61.    procedure do_OUT_10 is
    62.       B : KDF9.Q_part;
    63.       P : KDF9.pair;
    64.       S : KDF9.word;
    65.    begin
    66.       ensure_that_the_NEST_holds_2_operands;
    67.       P := pop;
    68.       declare
    69.          label : constant long_label := long_label(to_string(P));
    70.       begin
    71.          find_tape(tape.data_storage(label), B, S);
    72.          push(S);
    73.          push(KDF9.word(B));
    74.          the_trace_operand := KDF9.word(B);
    75.          log_allocation(10, abs String(label), buffer(B).device_name, to_string(S));
    76.       end;
    77.       set_state_of(buffer(B), allocated => True);
    78.    end do_OUT_10;
    79.
    80. end IOC.fast.tape.TSD_OUTs;

Compiling: ../Source/ioc-fast-tape-tsd_outs.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:04

     1. -- Implement the magnetic tape API (OUTs) of the EE Time Sharing Director.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package IOC.fast.tape.TSD_OUTs is
    18.
    19.    procedure do_OUT_4;
    20.
    21.    procedure do_OUT_10;
    22.
    23.    function needs_rewinding (b : KDF9.buffer_number)
    24.    return Boolean;
    25.
    26. end IOC.fast.tape.TSD_OUTs;

 80 lines: No errors

GNAT 8.3.0
Copyright 1992-2018, Free Software Foundation, Inc.


Compiling: /home/parallels/emulation/Source/kdf9-tsd-peripherals.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:05

     1. -- Implement OUTs 5, 6 and 7 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC;
    18. with IOC.fast.tape.TSD_OUTs;
    19. with IOC.slow.shift.SI;
    20. with IOC.slow.shift.TR;
    21. with KDF9.store;
    22.
    23. use  IOC;
    24. use  IOC.fast.tape.TSD_OUTs;
    25. use  IOC.slow.shift.SI;
    26. use  IOC.slow.shift.TR;
    27. use  KDF9.store;
    28.
    29. package body KDF9.TSD.peripherals is
    30.
    31.    -- is_free_for_explicit_allocation keeps a note of explicitly requested allocations by OUT 5.
    32.    -- Implicit allocations by OUT 8 are done to prevent spurious LIVs on the output devices,
    33.    --    but they must not cause explicit reservations by OUT 5 to fail.
    34.
    35.    is_free_for_explicit_allocation : array(KDF9.buffer_number) of Boolean := (others => True);
    36.    is_implicitly_allocated_to_OUT8 : array(KDF9.buffer_number) of Boolean := (others => False);
    37.
    38.    procedure free_all_devices is
    39.    begin
    40.       is_free_for_explicit_allocation := (others => True);
    41.       is_implicitly_allocated_to_OUT8 := (others => False);
    42.       for b in KDF9.buffer_number loop
    43.          set_state_of(buffer(b), allocated => False);
    44.       end loop;
    45.       --  Keep FW0 online.
    46.       set_state_of(buffer(0), allocated => True);
    47.    end free_all_devices;
    48.
    49.    procedure let_OUT_8_use_the_device_on_buffer (B : in KDF9.buffer_number) is
    50.    begin
    51.       is_implicitly_allocated_to_OUT8(B) := True;
    52.       set_state_of(buffer(B), allocated => True);
    53.    end let_OUT_8_use_the_device_on_buffer;
    54.
    55.    -- These are the device-type codes to be given when requesting
    56.    --    the allocation of a peripheral with TSD OUT 5,
    57.    --       according to the Manual and the document:
    58.    --          "Service Routine Library Manual" 22.13, p22-28-0.
    59.
    60.    FW_OUT5_code : constant := 0;
    61.    TP_OUT5_code : constant := 1;
    62.    TR_OUT5_code : constant := 2;
    63.    LP_OUT5_code : constant := 3;
    64.    CR_OUT5_code : constant := 4;
    65.    FP_OUT5_code : constant := 5;      -- Ferranti 5-channel Tape punch
    66.    CP_OUT5_code : constant := 7;
    67.    GP_OUT5_code : constant := 8#20#;
    68.    SI_OUT5_code : constant := 8#21#;  -- Standard Interface, "Data Link, N.P.L. Special Buffer"
    69.    FE_OUT5_code : constant := 8#65#;  -- Tape buffer link for PDP-8 on Eldon2, and perhaps COTAN
    70.    UT_OUT5_code : constant := 8#67#;  -- Unlabelled Tape
    71.
    72.    procedure select_the_next_device_from_among
    73.       (device_A, device_B : in  KDF9.buffer_number;
    74.        chosen_device      : out KDF9.buffer_number;
    75.        wanted_type        : in String) is
    76.    begin
    77.       if device_A /= 0                            and then
    78.             is_free_for_explicit_allocation(device_A) then
    79.          chosen_device := device_A;
    80.       elsif device_B /= 0                         and then
    81.             is_free_for_explicit_allocation(device_B) then
    82.          chosen_device := device_B;
    83.       else
    84.          trap_failing_OUT(5, "there is no available device of type " & wanted_type);
    85.       end if;
    86.    end select_the_next_device_from_among;
    87.
    88.    procedure allocate_a_device is
    89.       B : KDF9.buffer_number;
    90.       W : KDF9.word;
    91.    begin
    92.       ensure_that_the_NEST_holds_an_operand;
    93.       W := read_top;
    94.
    95.       case W is
    96.          -- 8 was added to the code to pre-allocate a device.
    97.          -- I treat pre-allocating and allocating the same way here.
    98.          when FW_OUT5_code
    99.             | FW_OUT5_code+8 =>
   100.             B := 0;  -- Always allowed, no checking performed.
   101.          when TP_OUT5_code
   102.             | TP_OUT5_code+8
   103.             | FP_OUT5_code
   104.             | FP_OUT5_code+8 =>
   105.             select_the_next_device_from_among(TP0_number, TP1_number, B, "TP");
   106.          when TR_OUT5_code
   107.             | TR_OUT5_code+8 =>
   108.             -- TR0 is used for reading the bootstrap/problem program in KDF9 code.
   109.             -- When there is Latin-1 data it therefore needs to go in via TR1.
   110.             -- N.B. the TR devices must appear in this order.
   111.             select_the_next_device_from_among(TR1_number, TR0_number, B, "TR");
   112.             set_case(IOC.slow.shift.TR.device(buffer(B).all));
   113.          when LP_OUT5_code
   114.             | LP_OUT5_code+8 =>
   115.             select_the_next_device_from_among(LP0_number, LP1_number, B, "LP");
   116.          when CR_OUT5_code
   117.             | CR_OUT5_code+8 =>
   118.             select_the_next_device_from_among(CR0_number, CR1_number, B, "CR");
   119.          when CP_OUT5_code
   120.             | CP_OUT5_code+8 =>
   121.             select_the_next_device_from_among(CP0_number, CP1_number, B, "CP");
   122.          when GP_OUT5_code
   123.             | GP_OUT5_code+8 =>
   124.             -- There is only 1 graph plotter.
   125.             select_the_next_device_from_among(GP0_number, GP0_number, B, "GP");
   126.          when SI_OUT5_code =>
   127.             if SI0_is_enabled then
   128.                select_the_next_device_from_among(SI0_number, SI1_number, B, "SI");
   129.             else
   130.                trap_failing_OUT(5, "the SI buffer has not been enabled");
   131.             end if;
   132.          when FE_OUT5_code =>
   133.             trap_unimplemented_feature("PDP-8 Front End Tape buffers");
   134.          when UT_OUT5_code =>
   135.             trap_unimplemented_feature("Unlabelled Tape buffers");
   136.          when others =>
   137.             trap_failing_OUT(5, "unknown device type #" & oct_of(W));
   138.       end case;
   139.
   140.       is_free_for_explicit_allocation(B) := False;
   141.       set_state_of(buffer(B), allocated => True);
   142.
   143.       pop;
   144.       push(KDF9.word(B));
   145.       the_trace_operand := KDF9.word(B);
   146.
   147.       if buffer(B).all in IOC.slow.shift.device'Class and then
   148.             buffer(B).kind /= GP_kind                     then
   149.          log_API_message("OUT 5: requested a #"
   150.                        & oct_of(KDF9.Q_part(W), 2)
   151.                        & "  type and got "
   152.                        & device_name_of(buffer(B).all)
   153.                        & (
   154.                           if IOC.slow.shift.device(buffer(B).all).uses_Latin_1 then
   155.                              " in Latin-1 mode"
   156.                           else
   157.                              " in KDF9 mode"
   158.                          )
   159.                         );
   160.       else
   161.          log_API_message("OUT 5: requested a #"
   162.                        & oct_of(KDF9.Q_part(W), 2)
   163.                        & "  type and got "
   164.                        & device_name_of(buffer(B).all)
   165.                         );
   166.       end if;
   167.    end allocate_a_device;
   168.
   169.    procedure free_the_device_on_buffer (B : in KDF9.buffer_number; OUT_number : in KDF9.word) is
   170.    begin
   171.       if buffer(B).kind in MT_kind | ST_kind then
   172.          if needs_rewinding(b) then
   173.             PMD(buffer(B).all, KDF9.Q_register'(B, 0, 0), set_offline => (OUT_number = 6));
   174.          end if;
   175.       elsif OUT_number = 7 then
   176.          trap_failing_OUT(7, "device #" & oct_of(B, 2) & ", is not a tape deck");
   177.       end if;
   178.       is_free_for_explicit_allocation(B) := True;
   179.       set_state_of(buffer(B), allocated => is_implicitly_allocated_to_OUT8(B));
   180.       log_API_message("OUT" & OUT_number'Image & ": released " & device_name_of(buffer(B).all));
   181.    end free_the_device_on_buffer;
   182.
   183.    procedure deallocate_a_device (OUT_number : in KDF9.word) is
   184.       B : KDF9.Q_part;
   185.    begin
   186.       ensure_that_the_NEST_holds_an_operand;
   187.       the_trace_operand := pop;
   188.       if the_trace_operand > 15 then
   189.          notify_state_display_of_final_ICR;
   190.          trap_failing_OUT(OUT_number, "#" & oct_of(the_trace_operand) + "is not a valid buffer number");
   191.       end if;
   192.       B := KDF9.buffer_number(the_trace_operand);
   193.       if is_unallocated(buffer(B)) then
   194.          trap_failing_OUT(OUT_number, "device #" & oct_of(B, 2) + "is not allocated to this program");
   195.       end if;
   196.       free_the_device_on_buffer(B, OUT_number);
   197.    end deallocate_a_device;
   198.
   199.    procedure do_OUT_5 is
   200.    begin
   201.       allocate_a_device;
   202.    end do_OUT_5;
   203.
   204.    procedure do_OUT_6 is
   205.    begin
   206.       deallocate_a_device(OUT_number => 6);
   207.    end do_OUT_6;
   208.
   209.    procedure do_OUT_7 is
   210.    begin
   211.       deallocate_a_device(OUT_number => 7);
   212.    end do_OUT_7;
   213.
   214.
   215. end KDF9.TSD.peripherals;

Compiling: ../Source/kdf9-tsd-peripherals.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:05

     1. -- Implement 5, 6 and 7 of the EE Time Sharing Directors.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.peripherals is
    18.
    19.    procedure do_OUT_5;
    20.
    21.    procedure do_OUT_6;
    22.
    23.    procedure do_OUT_7;
    24.
    25.    procedure let_OUT_8_use_the_device_on_buffer (B : in KDF9.buffer_number);
    26.
    27.    procedure free_all_devices;
    28.
    29.    procedure free_the_device_on_buffer (B : in KDF9.buffer_number; OUT_number : in KDF9.word);
    30.
    31. end KDF9.TSD.peripherals;

 215 lines: No errors


Compiling: /home/parallels/emulation/Source/kdf9-tsd-spooling.adb
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:05

     1. -- Implement a subset of the Time Sharing Director's OUT 8 / OUT 16 spooling API.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. with IOC;
    18. with IOC.dispatcher;
    19. with IOC.slow.shift.FW;
    20. with KDF9.store;
    21. with KDF9.TSD.peripherals;
    22.
    23. use  IOC;
    24. use  IOC.dispatcher;
    25. use  IOC.slow.shift.FW;
    26. use  KDF9.store;
    27. use  KDF9.TSD.peripherals;
    28.
    29. package body KDF9.TSD.spooling is
    30.
    31.    procedure do_IO (this_OUT : in KDF9.word) is
    32.
    33.       function destination_device_for (the_stream : KDF9.word)
    34.       return IOC.device_number is
    35.          data_word  : constant String(1..16) := oct_of(the_stream);
    36.          the_device : IOC.device_number;
    37.          the_type   : String(1..2);
    38.       begin
    39.          case the_stream is
    40.             when 8#00# =>
    41.                return 0;
    42.             when 8#10# |8#12# |8#14# | 8#16# =>
    43.                the_device := TP0_number; the_type := "TP";
    44.             when 8#11# |8#13# |8#15# | 8#17# =>
    45.                the_device := TP1_number; the_type := "TP";
    46.             when 8#30#..8#37# =>
    47.                the_device := LP0_number; the_type := "LP";
    48.             when 8#50#..8#57# =>
    49.                the_device := TP1_number; the_type := "TP";
    50.             when 8#70#..8#77# =>
    51.                the_device := LP0_number; the_type := "LP";
    52.             when others =>
    53.                trap_failing_OUT(8, "invalid stream #" & data_word);
    54.          end case;
    55.          if the_device = 0 then
    56.             trap_operator_error("OUT 8 needs a" + the_type + "for stream #" & data_word(15..16));
    57.          end if;
    58.          return the_device;
    59.       end destination_device_for;
    60.
    61.       W, the_stream : KDF9.word;
    62.       Q, G    : KDF9.Q_register;
    63.
    64.       procedure prepare_output_to_FW0 is
    65.          message_prefix  : constant KDF9.word := 8#02_06_21_55_22_00_07_77#; -- LS CS [ m ] SP CN 
    66.          prompt_prefix   : constant KDF9.word := 8#02_06_21_61_22_00_07_77#; -- LS CS [ q ] SP CN 
    67.          OUT_16_prefix   : constant KDF9.word := 8#02_07_56_33_00_77_77_77#; -- LS CN N  SP    
    68.          filler_in_D0_D5 : constant KDF9.word := 8#77_00_00_00_00_00_00_00#; -- 
    69.          S               : KDF9_char_sets.symbol := KDF9_char_sets.Word_Filler;
    70.          the_prefix      : KDF9.word;
    71.       begin  -- prepare_output_to_FW0
    72.          -- The logic of FW streams is rather complex, to preserve the layout of the typescript.
    73.          -- There are three significant aspects.
    74.
    75.          -- 1. The message is truncated if longer than 8 words.
    76.          if Q.M - Q.I > 8 then
    77.             Q.M := Q.I + 8;
    78.          end if;
    79.
    80.          -- 2. It must not contain LS or HT;
    81.          --       nor ';' in the last word;
    82.          --          nor ';' other than in character position 7;
    83.          --    but anything after an End Message can safely be ignored.
    84.          word_loop: for w in Q.I+1 .. Q.M loop
    85.              for c in KDF9_char_sets.symbol_index'Range loop
    86.                 S := fetch_symbol(w, c);
    87.                 if S = KDF9_char_sets.Line_Shift                                 or else
    88.                       S = KDF9_char_sets.Tabulation                              or else
    89.                          ((S = KDF9_char_sets.Semi_Colon) and (c /= 7 or  w = Q.M)) then
    90.                    trap_failing_OUT(this_OUT, "invalid data for OUT 8 to FW");
    91.                 end if;
    92.          exit word_loop when S in KDF9_char_sets.Semi_Colon | KDF9_char_sets.End_Message;
    93.              end loop;
    94.          end loop word_loop;
    95.
    96.          the_prefix := (if S = KDF9_char_sets.Semi_Colon then prompt_prefix else message_prefix);
    97.          the_prefix := (if this_OUT = 16                 then OUT_16_prefix else the_prefix);
    98.
    99.          -- 3. Take a new line for each OUT 8 message to the FW.
   100.          --    Set up the format effector(s) in the first word of the OUT 8 area.
   101.          declare
   102.             package FW renames IOC.slow.shift.FW;
   103.             the_FW : FW.device renames FW.device(buffer(0).all);
   104.          begin
   105.             if a_LF_was_just_read(the_FW) then
   106.                -- Replace the redundant Line Shift with a Word Filler character.
   107.                store_word(the_prefix or filler_in_D0_D5, Q.I);
   108.             else
   109.                -- The initial Line Shift is needed.
   110.                store_word(the_prefix, Q.I);
   111.             end if;
   112.          end;
   113.       end prepare_output_to_FW0;
   114.
   115.       page_change : constant := 8#77_77_77_77_77_77_77_03#;  --  LP Page Change character
   116.
   117.    begin  -- do_IO
   118.       ensure_that_the_NEST_holds_an_operand;
   119.       W := pop;
   120.       Q := as_Q(W);
   121.       the_trace_operand := W;
   122.
   123.       -- A FW query has (only) D0 of the control word set.
   124.       if (Q.C and 8#1_00000#) /= 0 then
   125.          Q.C := 0;
   126.       end if;
   127.
   128.       if Q.C = Q.I and Q.I = Q.M then
   129.          -- The N2 parameter specifies stream closure.
   130.          flush(buffer(destination_device_for(KDF9.word(Q.C))).all);
   131.          return;
   132.       end if;
   133.
   134.       --
   135.       -- This must precede anything that might LOV, e.g. store accesses and I/O orders.
   136.       --
   137.       restore_the_IO_OUT_operands(this_OUT, W);
   138.       --
   139.       --
   140.       --
   141.
   142.       -- The (Q, from N2) parameter specifies a block starting with the stream number.
   143.       check_address_and_lockout(Q.I);
   144.       the_stream := fetch_word(Q.I);
   145.
   146.       Q.C := destination_device_for(the_stream);
   147.       let_OUT_8_use_the_device_on_buffer(Q.C);
   148.
   149.       check_address_and_lockout(Q.I+1);
   150.       G := as_Q(fetch_word(Q.I+1));
   151.
   152.       -- See the Manual, 12.6.1.
   153.       if G.C = 4095 and then G.I = 8#177777# then
   154.          -- The G parameter specifies output of a 'gap' suitable for the device.
   155.          if G.M = 0 then
   156.             -- Do nothing.
   157.             the_trace_operand := as_word(G);
   158.          elsif destination_device_for(the_stream) in TP0_number | TP1_number then
   159.             -- Write runout according to the character set mode of the punch.
   160.             G.M := (if G.M in 1 .. 511 then G.M else 120);
   161.             Q := (Q.C, 0, G.M);
   162.             the_trace_operand := as_word(Q);
   163.             POE(Q, False);
   164.          elsif destination_device_for(the_stream) = LP0_number then
   165.              -- Write a Page Change.
   166.             store_word(page_change, Q.I);
   167.             Q := (Q.C, Q.I, Q.I);
   168.             the_trace_operand := as_word(Q);
   169.             POA(Q, False);
   170.          end if;
   171.
   172.          --
   173.          --
   174.          remove_the_IO_OUT_operands;
   175.          --
   176.          --
   177.
   178.          return;
   179.       end if;
   180.
   181.       if Q.M <= Q.I then
   182.          trap_failing_OUT(8, "start address #" & oct_of(Q.I) & ", end address #" & oct_of(Q.M));
   183.       end if;
   184.
   185.       if Q.C = 0 then
   186.          -- The logic for FW streams is more complex, to preserve the layout of the typescript.
   187.          prepare_output_to_FW0;
   188.       else
   189.          -- For non-FW streams, the first word of the OUT 8 area is not transferred.
   190.          Q.I := Q.I + 1;
   191.       end if;
   192.       the_trace_operand := as_word(Q);
   193.
   194.       POB(Q, False);
   195.
   196.       --
   197.       --
   198.       remove_the_IO_OUT_operands;
   199.       --
   200.       --
   201.
   202.    end do_IO;
   203.
   204.    procedure do_OUT_8 is
   205.    begin
   206.       do_IO(this_OUT => 8);
   207.    end do_OUT_8;
   208.
   209.    procedure do_OUT_16 is
   210.    begin
   211.       do_IO(this_OUT => 16);
   212.    end do_OUT_16;
   213.
   214. end KDF9.TSD.spooling;

Compiling: ../Source/kdf9-tsd-spooling.ads
Source file time stamp: 2022-06-09 00:50:22
Compiled at: 2022-09-15 15:08:05

     1. -- Implement a subset of the Time Sharing Director's OUT 8 / OUT 16 spooling API.
     2. --
     3. -- This file is part of ee9 (9.0p), the GNU Ada emulator of the English Electric KDF9.
     4. -- Copyright (C) 2022, W. Findlay; all rights reserved.
     5. --
     6. -- The ee9 program is free software; you can redistribute it and/or
     7. -- modify it under terms of the GNU General Public License as published
     8. -- by the Free Software Foundation; either version 3, or (at your option)
     9. -- any later version. This program is distributed in the hope that it
    10. -- will be useful, but WITHOUT ANY WARRANTY; without even the implied
    11. -- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    12. -- See the GNU General Public License for more details. You should have
    13. -- received a copy of the GNU General Public License distributed with
    14. -- this program; see file COPYING. If not, see <http://www.gnu.org/licenses/>.
    15. --
    16.
    17. package KDF9.TSD.spooling is
    18.
    19.    procedure do_OUT_8;
    20.
    21.    procedure do_OUT_16;
    22.
    23. end KDF9.TSD.spooling;

 214 lines: No errors
