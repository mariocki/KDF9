!begin

   !library A0, A1, A12, A13, A15;

   !integer char, a;

   !integer lA, lB, lC, lD, lE, lF, lG, lH, lI, lJ, lK, lL, lM,
            lN, lO, lP, lQ, lR, lS, lT, lU, lV, lW, lX, lY, lZ;

   !procedure outch (ch); !value ch; !integer ch;
      !if ch != 64 !then charout(30, ch);

   !procedure divide (dividend, divisor, quotient, remainder);
         !value dividend, divisor;
         !integer dividend, divisor, quotient, remainder;
      !begin
      quotient := dividend !div divisor;
      remainder := dividend  -  divisor  *  quotient;
      !end divide;

   !procedure outint (a); !value a; !integer a;
      !begin
      !integer q, r, n;
      !if a < 0 !then
         !begin
         outch(30);
         a := abs(a)
         !end;
      divide(a, 10, q, r);
      !if q != 0 !then
         outint(q);
      outch(r+16)
      !end of outint;

   !integer nextch;

   !integer !procedure inpch;
      !begin
      charin(20, nextch);
      inpch := nextch;
      !end inpch;

   !integer !procedure next non blank;
      !begin
      lbl: !if nextch != 0 !then next non blank := inpch !else !goto lbl;
      !end next non blank;

   !integer !procedure inint;
      !begin
      !integer i, ch;
      i := 0;
   NEXT:
      ch := inpch;
      !if ch !ge 16 !and ch !le 25 !then
         !begin
         i := i * 10 + ch - 16;
         !goto NEXT;
         !end;
      inint := i;
      !end inint;

   !comment In the following, adapted from the UCA3 originals, calls on the EGDON
            error handling routine, P91, are replaced with inline quits (OUT 0);

   !integer !procedure iP (place); !value place; !integer place;
      !KDF9 0/0/0/0;
      {place}; DUP; =M3; DUP; V12P90; -; J101LTZ;
      102; V13P90; -; J103GEZ;
      104; M0M3; =Q3; C3;
      !EXIT;
      103; SET 10103; ZERO; OUT;
      101; SET 10101; ZERO; OUT;
      !ALGOL;

   !integer !procedure jP (place); !value place; !integer place;
      !KDF9 0/0/0/0;
      {place}; DUP; =M3; DUP; V12P90; -; J201LTZ;
      202; V13P90; -; J203GEZ;
      204; M0M3; =Q3; I3;
      !EXIT;
      203; SET 10203; ZERO; OUT;
      201; SET 10201; ZERO; OUT;
      !ALGOL;

   !integer !procedure kP (place); !value place; !integer place;
      !KDF9 0/0/0/0;
      {place}; DUP; =M3; DUP; V12P90; -; J301LTZ;
      302; V13P90; -; J303GEZ;
      304; M0M3; =Q3; M3;
      !EXIT;
      303; SET 10303; ZERO; OUT;
      301; SET 10301; ZERO; OUT;
      !ALGOL;

   !procedure setI (place, value); !value place, value; !integer place, value;
      !KDF9 0/0/0/0;
      {value}; =C6; {place}; DUP; DUP;
      =Q5; V12P90; -; J401LTZ;
      402; V13P90; -; J403GEZ;
      404; M0M5; =Q7; C6 TO Q7; -M0M5;
      !EXIT;
      403; SET 10403; ZERO; OUT;
      401; SET 10401; ZERO; OUT;
      !ALGOL;

   !procedure setJ (place, value); !value place, value; !integer place, value;
      !KDF9 0/0/0/0;
      {value}; =I6; {place}; DUP; DUP;
      =Q5; V12P90; -; J501LTZ;
      502; V13P90; -; J503GEZ;
      504; M0M5; =Q7; I6 TO Q7; -M0M5;
      !EXIT;
      503; SET 10503; ZERO; OUT;
      501; SET 10501; ZERO; OUT;
      !ALGOL;

   !procedure setK (place, value); !value place, value; !integer place, value;
      !KDF9 0/0/0/0;
      {value}; =M6; {place}; DUP; DUP;
      =Q5; V12P90; -; J601LTZ;
      602; V13P90; -; J603GEZ;
      604; M0M5; =Q7; M6 TO Q7; -M0M5;
      !EXIT;
      603; SET 10603; ZERO; OUT;
      601; SET 10601; ZERO; OUT;
      !ALGOL;

   !integer !procedure IJK (iPart, jPart, kPart);
      !value iPart, jPart, kPart;
      !integer iPart, jPart, kPart;
      !KDF9 0/0/0/0;
      11;  V14P90; DUP; DUP; J200=Z;
      110; V15P90; V16P90;   J300=;
      =Q4; =M0M4; Q4; =V15P90;
      111; DUP; =M4; M0M4; =M4; M4; =V14P90;
      =Q3; {kPart}; =M7; {jPart}; =I7; {iPart}; =C7;
      Q7; =M0M3; Q3;
      !EXIT;
      200; ( when available, JSP92, the garbage collector then J110);
      300; SET 11130; ZERO; OUT;
      !ALGOL;

   !integer !procedure combine (state, action); !value state, action; !integer state, action;
      !KDF9 0/0/0/0;
      {state}; SHL+6; {action}; OR;
      !EXIT;
      !ALGOL;

   !procedure split (rule, state, action); !value state; !integer rule, state, action;
      !KDF9 0/0/0/0;
      {rule}; DUP; SET B77; AND; ={action};
      SHL-6; SET B1777; AND; ={state};
      !EXIT;
      !ALGOL;

   !procedure clear the tape; !comment P9;
      !KDF9 0/0/0/0;
      V0=AYT0; V1=AYU0; V2=0; V4=0; V5=0; V6=0;
      V1; V0; -; =V2; V2; =RC5; ZERO; =V4;
      V2; SET 2; ÷I; ERASE; =V5; ZERO; =V6;
      *11; ZERO; =YT0M5Q; *J11C5NZS;
      !EXIT;
      !ALGOL;

   !procedure move the tape left;
      !KDF9 0/0/0/0;
      V6P9; SET7; J21=; NOT; NEG; =V6P9;
      !EXIT;
      21; ERASE; ZERO; =V6P9; V5P9; =RM5; V4P9; =YT0M5Q;
      M5; V2P9; J22=; =V5P9; YT0M5; =V4P9;
      !EXIT;
      22; SET 22; ZERO; OUT;
      !ALGOL;

   !procedure move the tape right;
      !KDF9 0/0/0/0;
      V6P9; DUP; J31=Z; NEG; NOT; =V6P9;
      !EXIT;
      31; ERASE; SET 7; =V6P9; V5P9; =RM5; V4P9; =YT0M5Q;
      M5; J32=Z; M-I5; M5; =V5P9; YT0M5; =V4P9;
      !EXIT;
      32; SET 32; ZERO; OUT;
      !ALGOL;

   !procedure write to tape (character); !value character; !integer character;
      !KDF9 0/0/0/0;
      SET 7; V6P9; -; SHL+1; DUP; SHL+1; +; =C8;
      {character}; DUP; SHLC8;
      SET B77; SHLC8; NOT; V4P9; AND;
      OR; =V4P9;
      !EXIT;
      !ALGOL;

   !integer !procedure read from tape;
      !KDF9 0/0/0/0;
      SET 7; V6P9; -; SHL+1; DUP; SHL+1; +; =C8;
      SET B77; SHLC8; NOT; V4P9; AND;
      NC8; SHLC8;
      !EXIT;
      !ALGOL;

   !integer !procedure CPU time in seconds;
   !KDF9 0/0/0/0;
   SET 3; OUT; (This is the same as OUT 122 in EGDON);
   SHA-24;
   !EXIT;
   !ALGOL;


   !integer !array LAV[1:1], ILF[1:1];
   !integer LSL, LAL, IDP, name tree;

   !integer !procedure insert rule (state, symbol, action, node);
         !value   state, symbol, action, node;
         !integer state, symbol, action, node;
         !comment insert a Turing machine rule (state, symbol, action) in the match tree at node;
      !begin
      !integer ch, trigger;
      trigger := combine(state, symbol);
      !if node = 0 !then
         insert rule := IJK(trigger, action, 0)
      !else
         !if kP(node) = 0 !then
            !begin
            !if action > jP(node)
               !then insert rule := IJK(trigger, action, IJK(node, -1, 0))
            !else
               !if action = jP(node) !then
                  !begin
                  insert rule := node;
                  outch(15);
                  setI(node, trigger);
                  outch(49);
                  outint(state);
                  !comment print SP, S, action, SP, REPLACED, NL;
                  !for ch := 0, lS, action, 0, lR, lE, lP, lL, lA, lC, lE, lD, 2 !do outch(ch)
                  !end
               !else
                  insert rule(IJK(trigger, action, IJK(0, 0, 0)))
            !end
         !else
            !begin
            insert rule := node;
            !if action <= jP(node) !then
               setK(node, IJK(insert rule(state, symbol, action, iP(kP(node))), -1, kP(kP(node))))
            !else
               setK(node, IJK(iP(kP(node)), -1, insert rule(state, symbol, action, kP(kP(node)))))
            !end
      !end of insert rule;

   !procedure print state;
      !begin
      !integer ch;
      outch(lQ);
      outint(current state);
      outch(lS);
      outch(current symbol);
      !if found !then
         !begin
         outch(action);
         outint(next state);
         !end
      !else
         !for ch := lN, lO, lT, 0, lF, lO, lU, lN, lD, 2 !do outch(ch);
      !end print state;

   !procedure print the tape expression;
      !begin
      !integer ch;
      !for ch := lT, lA, lP, lE, 2 !do outch(ch);
      print state;
      !end print the tape expression;


   !comment switch on the RULE TYPE of control card read;
   !switch CARDKIND := QCARD, TAPE, TEND, SKIP, HERE, DEBUG, LIST, END, STOP, TIME, DISC;

   !comment switch on the RULE TYPE of Turing machine rule being obeyed;
   !switch RULE TYPE := type 1 rule, type 2 rule, type 3 rule;

   !comment switch on the debugging mode;
   !switch DEBUG MODE  := rule found, debug mode 1, debug mode 2, debug mode 3;

   !integer incnt, hereq, debug mode;
   !Boolean tape input mode, found;

   !integer current state, current symbol, next state, next symbol, rule type;

   lA := 33;
   lB := lA + 1;
   lC := lB + 1;
   lD := lC + 1;
   lE := lD + 1;
   lF := lE + 1;
   lG := lF + 1;
   lH := lG + 1;
   lI := lH + 1;
   lJ := lI + 1;
   lK := lJ + 1;
   lL := lK + 1;
   lM := lL + 1;
   lN := lM + 1;
   lO := lN + 1;
   lP := lO + 1;
   lQ := lP + 1;
   lR := lQ + 1;
   lS := lR + 1;
   lT := lS + 1;
   lU := lT + 1;
   lV := lU + 1;
   lW := lV + 1;
   lX := lW + 1;
   lY := lX + 1;
   lZ := lY + 1;

   !comment set up the input scheme;
   nextch := 0;

   !comment set up the heap in the array LAV;
   set up the heap(LAV(1), LAV(LSL), LAV(LSL+1), LAV(LAL), IDP);
   clear list stack;

   !comment create a dynamic scope in the heap;
   begin list scope;

   !comment declare ILF as an array of pointers into the heap;
   declare list array(ILF, LIL);

   !comment set up the output buffering;
   !comment the EGDON routine DEFIOP(IDP, 0) is not supported;

      !begin
      !comment the following appalling code sets up the control card matching tree in the heap;
      !integer length, node c, node d, node e;
      !integer !array name [1:10]; !comment upper bound set generously;

      !integer !procedure make name branch (name length, switching code);
         !value name length, switching code;
         !integer name length, switching code;
         !comment enter a word, held in name(1..name length), and its switching code,
                  into the name-matching tree and return a pointer to its root;
         !begin
         !integer cell, i;
         cell := switching code;
         !for i := 1 !step 1 !until name length !do
            cell := IJK(cell, name(i), 0);
         make name branch := cell;
         !end of make name branch;

      !procedure add letter to name (letter); !value letter; !integer letter;
         !comment add a letter of a word to name, IN REVERSE ORDER;
         !begin
         name(length) := -letter;
         length := length - 1;
         !end of add letter to name;

      !comment declare heap pointers;
      declare list(name tree);
      begin list scope;
      declare list(node c);
      declare list(node d);
      declare list(node e);

      !comment set heap pointers to NIL;
      name tree := node d := node e := node c := 0;

      !comment build the control-card matching tree in the heap;

      !comment insert LIST;
      length := 5; !for char := lL, lI, lS, lT, 0, !do add letter to name(char);
      node e := make name branch(5, 7);

      !comment insert HERE;
      length := 5; !for char := lH, lE, lR, lE, 0, !do add letter to name(char);
      node d := make name branch(5, 5);
      setK(node d, node e);
      node e := node d;

      !comment insert END;
      length := 4; !for char := lE, lN, lD, 0, !do add letter to name(char);
      node d := make name branch(4, 8);
      setK(node d, node e);
      node e := node d;

      !comment insert ISC, the D of DISC goes in via DEBUG;
      length := 4; !for char := lI, lS, lC, 0 !do add letter to name(char);
      node c := make name branch(4, 11);

      !comment insert DEBUG;
      length := 6; !for char := lD, lE, lB, lU, lG, 0 !do add letter to name(char);
      node d := make name branch(6, 6);
      setK(node d, node e);
      node e := node d;
      setK(iP(node d), node c);

      !comment insert TOP, the S of STOP goes in via SKIP;
      length := 4; !for char := lT, lO, lP, 0, !do add letter to name(char);
      node c := make name branch(4, 9);

      !comment insert SKIP;
      length := 5; !for char := lS, lK, lI, lP, 0, !do add letter to name(char);
      node d := make name branch(5, 4);
      setK(node d, node e);
      node e := node d;
      node d := iP(node d);
      setK(node d, node c);

      !comment insert END, the T of TEND goes in via TAPE;
      length := 4; !for char := lE, lN, lD, 0 !do add letter to name(char);
      node c := make name branch(4, 3);

      !comment insert IME, the T of TIME goes in via TAPE;
      length := 4; !for char := lI, lM, lE, 0 !do add letter to name(char);
      node d := make name branch(4, 10);
      setK(node c, node d);

      !comment insert /TAPE;
      length := 6; !for char := 15, lT, lA, lP, lE, 0 !do add letter to name(char);
      node d := make name branch(6, 2);

      !comment finalize the name tree;
      setK(iP(node d), node e);
      setK(iP(iP(node d)), node c);
      node e := node d;
      setK(node e, IJK(IJK(1, 0, 0), lQ, 0));
      name tree := node e;

      !comment close the dynamic scope;
      end list scope;

      !end of setting up name tree with the control card matches;

SETUP:
   clear the tape;
   !for a := 0 !step 1 !until LIL !do ILF(a) := 0;
   incnt := hereq := debug mode := 0;
   tape input mode := found := !false;

   herep := 1;
   right limit := 32;
   left limit := 72;
   time limit := CPU time in seconds + 10;

skip past the end of the line:
   !if nextch != 2 !then !goto skip past the end of the line;

get a new line:
   inpch;

MAIN:  !comment switching on input RULE TYPE;
   !goto CARDKIND(treesw);

FAIL: !comment The nature of the line is not recognised.
               If we are in tape input mode
               then the line is added to the TM tape
               else it is ignored;
   !if tape input mode !then add to the tape !else !goto skip past the end of the line;

QCARD:
   !begin
   !integer this state, this symbol, action, next state;
   this state := inint; this symbol := inpch; action := inpch;
   !if action != 50 !and action != 44 !then
      nextch
   !else
      !if action = 50 !then action := 62 !else action := 63;
   next state := inpch;
   next state := inint;
   begin list scope;
   ILF(this state) := insert rule(next state, action, this symbol, ILF(this state));
   end list scope;
   !if this state != current state !or this symbol != current symbol !then
      !goto get a new line;
      !comment The Q card matches the current configuration of the Turing machine,
               so resume simulation;
   !end;

TICK:
   !if CPU time in seconds > time limit !then
      !begin
      !comment print /TIME UP;
      !for char := 15, 52, 41, 45, 37, 0, 53, 48, 64 !do outch(char);
      !comment the EGDON FDUMP is not supported;
      !end
   !else
      !begin
      split(find(current symbol, ILF(current state)), next state, next symbol);
      rule type := !if next symbol < 62 !then 1 !else next symbol-60
      !end;

   !comment Check for debugging modes and act accordingly;
   !goto DEBUG MODE(debug mode+1);

debug mode 3:
   print the tape expression;

debug mode 2:
   print state;
   !if found !then !goto RULE TYPE(rule type) !else !goto no rule found;

debug mode 1:
   print the tape expression;
   !if found !then !goto RULE TYPE(rule type) !else !goto no rule found;

rule found:
   !if found !then !goto RULE TYPE(rule type);

no rule found:
   !if debug mode = 2 !then print the tape expression;
   !goto get a new line;

type 1 rule:
   write to tape(next symbol); current symbol := next symbol; current state := next state; !goto TICK;

type 2 rule:
   move the tape left;  current symbol := read from tape; current state := next state; !goto TICK;

type 3 rule:
   move the tape right; current symbol := read from tape; current state := next state; !goto TICK;

TAPE:
   !if tape input mode !then add to the tape;
   incnt := herep := hereq := 0;
   tape input mode := !true;
   clear the tape;
   !goto skip past the end of the line;

TEND:
   !if !not tape input mode !or incnt = 0 !then !goto skip past the end of the line;
   !for a := incnt !step -1 !until herep !do move the tape right;
   herep := 1;
   tape input mode := !false;
   read from tape(current symbol);
   current state := hereq;

DNET:
   !if inpch != 2 !then !goto DNET;
   !goto TICK;

SKIP:
   !if tape input mode !then
      !begin
      !integer amount, i;
      amount := inint;
      !for i := 1 !step - !until amount !do
         !begin
         write to tape(0);
         move the tape left;
         end;
      incnt := incnt + amount;
      !goto get a new line
      !end;
   !goto skip past the end of the line;

HERE:
   !if tape input mode !then
      !begin
      next non blank;
      herep := incnt + 1;
      hereq := inint;
      !goto get a new line
      !end;
   !goto skip past the end of the line;

DEBUG:
   !if tape input mode !then add to the tape;
   debug mode := inint;
   !goto get a new line;

LIST:
   !if tape input mode !then add to the tape;
   left limit := inint;
   right limit := inint;
   !goto get a new line;

END:
   !if tape input mode !then add to the tape;
   end list scope;
   print the tape expression;
   !goto SETUP;

TIME:
   !if tape input mode !then add to the tape;
   time limit := CPU time in seconds + inint;
   !goto get a new line;

DISC:
   !if tape input mode !then add to the tape;
   !comment  is no longer relevant;
   !goto skip past the end of the line;

STOP:
   !if tape input mode !then add to the tape;
   !for char := 2, 15, lS, lT, lO, lP, lS, 2 !do outch(char);

   !end of inner block

!end of AMTSIM
|
