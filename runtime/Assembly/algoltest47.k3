
P
KALGOL000UPU PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING
PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING
PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING
------|
ST24000; TL99999;
V0004; YA0005; YB0000; YC0000;
RESTART; J100P299; J100P299;         (+ Official response to even restart );
PROGRAM;
( There is documentaton at the end of this file );
J1P0; 
   (+ defect in KAL3 assembler cannot handle P0 at the end );
(+ routines known to the Kalgol code generator );
   
P201; (prepare to goto exit from a procedure, resets stack to calling level)
   (N1 contains the goto label level number)
1; 
   Y0M1; =Q3;
   M3; =M1; I3; =M2;
   C3; J1±;
   ERASE; EXIT1;
   
P202V0; ;(+ real to integer conversion );
   V0 =B4321042410716400; ( FIX );
   DUP; FIX; SET47; -; DUP; =C4;
   SET-9; SIGN;
J99>Z;
   REV; ERASE;
   SHAC4;
   EXIT1;
99; 
   ( fail, number too big for accurate conversion  - 39 bit integer max* QUERY - wAlgol 39 bit limit
   wAlgol run time error 243 - I-type number out of 39-bit range);
   ERASE;
   SETAV0; REV; SET1;
JP299;
   
   
P203; (+ convert integer to real );
   SET47; FLOAT; EXIT1;
   
P204; (integer divide);
   DUPD; NEV; ( sign of result in D0 );
   CAB; ABS; ( First operand );
   CAB; ABS; ( Second operand );
   ÷I; ERASE; ( ÷I same as entier(a/b) for +ve operands );
   REV;
J2<Z;
   ( a jump not executed is quicker -- +ve result more common );
   EXIT1; ( see sect 3.3.4 of Algol report );
2; 
   NEG; EXIT1;
   
P205; (+set M3 for the frame of the non-local variable/parameter );
   (+N1; non-local level );
   Y0M1; =Q3; (+data link );
2; 
   C3;
J1=;
   (+is it this level );
   Y0M3; =Q3;
J2;
   
1; 
   ERASE;
   EXIT1; (+Q3 is setup for the frame and is used access the var. YyM3 );
   
P206; (+evaluate Thunk );
   (+ N1; parameter -/ARThunk/M1 );
   (+create a link -/LINK/M1 and put at the top of the stack );
   LINK; =I3; M1; =M3; Q3; =Y0M2Q;
   (+set the stack frame for the Thunk );
   =Q3; M3; =M1;
   I3; =LINK; EXIT;
   
P207; (+end Thunk );
   (+get the Thunk link off the stack );
   M-I2;
   Y0M2; =Q3;
   (+reset the stack and exit );
   M3; =M1; I3; =LINK; EXIT1;
   
P208; (+call formal proc );
   =LINK; EXIT;
   
P209V1; (+get indexed address of array element );
   (+N1; dimensions );
   (+N2; ArrayBox where Ipart -> DV rel. Y0, CPart physical origin rel Y0, Mpart log. origin rel Y0 );
   (+the indices are put on the stack );
   =V0; =V1;
   V0; NEG; =+M2; (+ set M2 to the first index );
   V1; SHL-16; SET1; +; =RM3; (+DV rel Y0 ); (hux); (need to add 1 to skip the *size* and point to Delta2);
   V0; SET1; -; =C3; (+dimensions ); ( Delta 1  is 1 so C3--, rubbish);
   (ZERO; ); (start with 1);
   Y0M2Q; (first index - times  Delta 1);
1; 
J2C3Z;
   
   Y0M2Q; (index); Y0M3Q; (Delta);×D; CONT; +;
J1; 
   
2; 
   (+ N1; we have sigma Dv×index );
   V1; =Q3; M3; +; (+logical origin + sigma Dv×index rel Y0 );
   V0; NEG; =+M2; (+reset stack );
   EXIT1;
   
P210V9; (array declarations)
   (+ own arrays can be used as parameter* );
   (+ supports own array whose Data is held in Z stores );
   (+ Z1 holds the amount of Z-store consumed - initialised as 2 );
   (+ addresses in DV are rel. Y0 );
   (+the code generated by B60 can set some parameters *negative* );
   (+why is unclear );
   (+if N1 is negative then the declaration is an own array );
   (+own array N1 ==-1 plus 3 other params, not own 3 prams, first one is positive );
   (+addresses in DV are relative to Y0 - so own starting at Zz are indexed from AZz - Ay0 );
   (+uses Q3 and Q4 (which is saved and restored) );
   ZERO; =V9; (+own array marker );
   DUP;
J4_>Z;
   (+ jump if not own );
   dup; =V9; (+-ve indicates own array );
   (+own arrays );
   (+N1; -number of arrays );
   (+N2; *Set1 marker );
   (+N3; number of bounds );
   (+N4; AYBb );
   (+ if own and array word - YBb - is non zero exit );
   (+N3 - number of bounds can be negative, reason unknown );
   ABS; =V0; ERASE; ABS; =V1; SETAY0; -; DUP; =V2; (+ relative to Y0 );
   =M3; Y0M3;
J11=Z;
   EXIT1;
4; 
   (+ordinary arrays );
   (+N1; number of arrays );
   (+N2; number of bounds );
   (+N3; AYy );
   =V0; (+V0; no. arrays );
   abs; =V1; (+V1; no. bounds );
   (N3); SETAY0; -; M1; +; =V2; (+V2; AYy - AY0 + M1 - rel to Y0 );
11; 
   Q4; =V3; (+V3; Q4 - saved and restored on exit);
   V2; =RM3; V0; =+M3; (SET1; =+M3; ); (+start of DV beyond V0 array boxes - rel Y0 );
(+calculate array size and set up Dope Vector );
   (need to step through all the bounds to compute the size, but not to to
   set DV1 (as 1) in the DopeVector
   The DV is size; Delta2, etc)
   M2; V1; -; DUP; =V5; (+V5; start of the bounds - rel Y0 );
   =RM4; (+to step through the bounds );
   V1; =C4; (+number of bounds );
   (+set up DV );
   SET1; (DELTA[0]);
   SET1; =V7; (hux - size is in DV)
1; 
   Y0M4Q; Y0M4Q; REV; -; (+ upper - lower +1);
   SET1; +;×D; CONT; (times D[i-1])
J10C4Z; 
   dup; =Y1M3Q; 
   (+D2, D3 etc. we dont store the last Di);
10; 
J1C4NZ;
   
   =V7;
   V2; =RM3; V0; =+M3; (+start of DV beyond V0 array boxes rel M0 );
   V7; =Y0M3; 
   (store the size in the first word of the DV );
   (+now compute Li×Di ); (to compute the Logical Origin offset);
   V2; =RM3; V0; =+M3; SET1; =+M3; (+start of DV beyond V0 array boxes rel Y0 );
   V5; =RM4; (+start of bounds - rel Y0 );
   V1; =C4;
   SET0;
   Y0M4Q; SET1;×D; CONT; +; (special case for A[i..] - Delta i is 1 and not stored)
   Y0M4Q; ERASE;
J21C4Z; 
   
2; 
   Y0M4Q; (Li); Y0M3Q; (Di);×D; CONT; +;
   Y0M4Q; ERASE; (+skip Upper bound );
J2C4NZ; 
   
21; 
   =V8; (+ sigma Li×Di );
   (+now set up the array box );
   V2; V0; +; =C3; (+dv address );
   V2; =RM4; (+address first array box - AYy );
17; 
   V0; =C4; (+no of arrays );
   M2; V1; -; =M2; (+reset M2 to before indices M2 is rel Y0 );
3; 
   (here we check the space for each of the declared arrays HUX SPACE)
   V7;
JSP287;
   
   V9;
J13 =Z;
   
   (+own );
   V7; Z1; +; =Z1; (+take space, for  data );
   SET AZ2; Z1; -; SETAy0; -; (+ actual Location rel. Y0 );
   =I3;
J14;
   
13; 
   M2; =I3; (+ actual Location  rel. to Ay0 - should be in C3 );
   V7; =+M2; (+take space for data );
14; 
   I3; V8; -; =M3; (+actual origin - sigma Li×Di =logical origin rel Y0 );
   C3; I3; =C3; =I3; (hux)
   Q3; =Y0M4Q;
   I3; C3; =I3; =C3;
J3C4NZ; 
   (+store array box );
   V3; =Q4;
   EXIT1;
   
P212; (+restore Q-stores on exit ); (+ used on exit from  non-simple Procedures)
   (+N1; no of Q-stores to restore, 1; 12 );
   NEG; DUP; =+M2;
   SETAR2; +; =LINK; EXIT; (+switch );
*1; 
   Y0M2Q; =Q4;
   *Y0M2Q; =Q5;
   *Y0M2Q; =Q6;
   *Y0M2Q; =Q7;
   *Y0M2Q; =Q8;
   *Y0M2Q; =Q9;
   *Y0M2Q; =Q10;
   *Y0M2Q; =Q11;
   *Y0M2Q; =Q12;
   *Y0M2Q; =Q13;
   *Y0M2Q; =Q14;
   *Y0M2Q; =Q15; (+ M2 will not be back to where it was before Q-store preservation );
*2; 
   EXIT1; (+ but in any case M2 is about to be overwritten );
   
P213V2; (+invalid address Thunk; );
   V0 =B4321702003417413;
   V1 =B0100540702602413;
   V2 =B0040563500000000;
   SETAV0; ZERO; SET1;
JP299;
   
   
P216; (+enter non-simple procedure );
   (+N1; No. Parameter locations + 2; );
   (+N2; fixed space required );
   (+N3; Q-store to be saved );
   (+N4; called by Level No. );
   (+Data link - set up in Q3 - has format; Calling Level No./ M2 of call frame/ M1 of call frame );
   M1TOQ3;
   M2; REV; -; DUP; =M1; =I3; (+recover the calling Stack Pointer );
   (Check for Space HUX SPACE)
   DUP;
JSP287;
   
   =+M2; (+inc. for fixed space required );
   (+time to call Q-saver );
   NEG; SETAR2; +; =LINK; EXIT; (+branch on Q-stores to save );
*1; 
   Q4; =Y0M2Q;
   *Q5; =Y0M2Q;
   *Q6; =Y0M2Q;
   *Q7; =Y0M2Q;
   *Q8; =Y0M2Q;
   *Q9; =Y0M2Q;
   *Q10; =Y0M2Q;
   *Q11; =Y0M2Q;
   *Q12; =Y0M2Q;
   *Q13; =Y0M2Q;
   *Q14; =Y0M2Q;
   *Q15; =Y0M2Q;
*2;
   (if the calling level is 0, now clear the space used for own array dope vector ie YB0 to YC0);
   DUP; J3±Z;
   SETAYB0; =RM4;
   SETAYC0; SETAYB0; -; =C4;
*4; 
   ZERO; =M0M4Q; *J4C4NZS;
3; 
   =C3; (+calling level- complete data link );
   Q3; =Y0M1; 
   (+data link );
   LINK; LINK; =Y1M1; =LINK; M2; M1;
   ( M2 is not clear - it is saved after the last parameter )
   (M1 is for access to non-local variables in non-recursive procs - stored in YAlevel);
   EXIT1;
   
P217; (compute the loop count :=a step b until c - a in M4 , c in C4 b in I4);
   M4; C4; -; Set1; +; I4;
JSP204;
   EXIT1;
   
P218V7; (+copy array by value );
   (+N1; SET-1 *** - no idea what this is for ); ( Possibly 0  is ordinary, -1 is own array; hux)
   (+N2; SETAYarrayword - this is the parameter location - rel. M1 ); (SURELY M0*)
   (+ this is updated to point to the copy location );
   (+uses Q4 );
   (+arrays are copied onto the stack );
   (+no checks on store limits );
   (+note that there is only one DopeVector for all copies );
   =V0; =V1; M2; =V4; (+new start address  for the array copy);
   V1; =M3; M1M3; DUP; =V5; =Q3; (+the array word in the parameters );
   M3; C3; -; =V2; (+ L - A; the logical offset - to set the new C3 ); (hux)
   (V2 is absolute - logical address)
   (+now get the size );
   I3;
   =M3; Y0M3; DUP; =C2; =V7; (+size);
   C3; =RM3; (physical location)
   (here we check the space for the copy HUX SPACE)
   C2;
JSP287;
   
*1; 
   Y0M3Q; =Y0M2Q;
J1C2NZS;
   (+copy);
   V1; =M3; (+address of the array word );
   (+update array word );
   V5; =Q4; V4; dup; =C4; V2; +; =M4; Q4; =M1M3; (hux)
   EXIT1;
   
P219; (+exit non-simple procedure );
   Y0M1; =Q3; (+data link );
   Y1M1; =LINK; (+address link );
   (+set caller frame );
   M3; =M1;
   I3; =M2;
   EXIT1;
   
P220; (+Switch Declaration );
   (+N1; AYy of space for sw elements );
   (+N2; number of elements );
   (+ set up Yy to no of elements/AYy/M2 );
   DUP; =M4; =I3; M1; =+I3; (+ make address of switch thunks rel. to M0)
   =C3; M2; =M3; Q3; =M1M4;
   EXIT1;
   
P221; (+evaluate formal (label) thunk );
   (+N1; -/AYy/address );
   =Q3;
   C3; DUP; =M1;
J1=Z;
   
   C3; =M1; YA0M1; =C3; ( m1 for the level in C3);
1; 
   Q3; EXIT1;
   
P222; (+evaluate switch );
   (+N1; nElements/AYy/M2 - M2 is the stack top for the block);
   (+index is in M3);
   (+Fetch the label Thunk into N1 );
   (+first check the index is valid i.e 0<M3×<nElement );
   (DUP; =M2; ); SHL+16; SHL-32; =I3; M+I3; M0M3; (+get the label thunk ); (+this address is relative to M0);
   =LINK; EXIT; (execute the switch thunk - leaves N1; M1/AYy/address ); EXIT1;
   
P223; (+exit to formal label );
   (+N1; M1/AYy/address );
   =Q3; C3; =M1; I3; =M2; M2M1; =M2; M3;
   =LINK; EXIT;
   
P228; (N1 =FSR; N2 =Number of Q*s to save);
   (+ used before entry to  Simple  Procedures);
   SET2; +;
   M2; PERM; (FSR, No Qs, M2)
   (Check for Space HUX SPACE)
   DUP;
JSP287;
   
   =+M2; (+inc. for fixed space required );
   NEG; SETAR2; +; =LINK; EXIT; (+branch on Q-stores to save );
*1; 
   Q4; =Y0M2Q;
   *Q5; =Y0M2Q;
   *Q6; =Y0M2Q;
   *Q7; =Y0M2Q;
   *Q8; =Y0M2Q;
   *Q9; =Y0M2Q;
   *Q10; =Y0M2Q;
   *Q11; =Y0M2Q;
   *Q12; =Y0M2Q;
   *Q13; =Y0M2Q;
   *Q14; =Y0M2Q;
   *Q15; =Y0M2Q;
*2; 
   =M2; (restore access to parameters);
   EXIT1;
   
P229; (N1 =FSR; N2 =Number of Q*s to restore);
   (on exit from simple procedures);
   M2; PERM; (FSR, No Qs, M2);
   SET2; +;
   =+M2; (+inc. for fixed space required );
   NEG; SETAR2; +; =LINK; EXIT; (+switch );
*1; 
   Y0M2Q; =Q4;
   *Y0M2Q; =Q5;
   *Y0M2Q; =Q6;
   *Y0M2Q; =Q7;
   *Y0M2Q; =Q8;
   *Y0M2Q; =Q9;
   *Y0M2Q; =Q10;
   *Y0M2Q; =Q11;
   *Y0M2Q; =Q12;
   *Y0M2Q; =Q13;
   *Y0M2Q; =Q14;
   *Y0M2Q; =Q15;
*2; 
   =M2;
   EXIT1;
   
P230; (get index increment for addressing 3D array [i,j,k )
   ( N2 =address Array definition N1 Number of dimensions*)
   ( Y0M2 =1 increment A [ i, ] Y1M2 =1 increment A[ ,j] etc);
   REV; SHL-16; =RM3; (Address of DVector);
   =C3; (Number of dimensions)
   C3; NEG; =+M2; (reset Stack)
   ZERO;
   Y0M2;
J1=Z;
   SET1; +; DC3; 
J3C3Z; 
   (Set1; )
1; 
   Y1M2;
J2=Z;
   Y1M3; +; DC3; 
J3C3Z; 
   
2; 
   Y2M2;
J3=Z;
   Y2M3; +;
3; 
   EXIT1;
(P230V2; (alternative get index increment for addressing 3D array [i,j,k )
   ( N2 =Array Word , N1 Number of dimensions*)
   (stack SET1 =Y0M2Q etc for increment i, j, k,  etc N1 dimensions)
   =V0; =V1;
   V0; Neg; =+M2; (reset Stack)
   V1; =Q4; I4; =RM3; V0; =C3;
   SET1; Y0M2Q; ;×D; CONT; DC3; (DV1 × selector)
1; 
   Y1M3Q; Y0M2Q;×D; CONT; +;
J1C3NZ;
   (add in the increment if selected)
   V0; Neg; =+M2; (reset Stack)
   EXIT1; (N* contains the sum of the constant index increment);
)
   
P231V2; ( exponentiate -- new code by DH Feb2017 );
   V0 =F1.0;
   V1 =B4321702003405403;
   V2 =B0260201300605635;
4; 
   REV; ( integer to integer power real result );
   SET47; FLOAT; REV; (QUERY see * about 39 bit integers)
1; 
   DUP;
J19=Z;
   ( real to integer power );
   DUP;
J11<Z;
   ( -ve exponent );
21; 
   V0; PERM; ( real to +ve integer power );
211; 
   SHC-1; STR;
J212=Z;
   
   PERM; DUP; PERM;×F; PERM; REV;
212; 
   REV; DUP;×F; REV; DUP; J211±Z;
   ERASE; ERASE; EXIT1;
11; 
   DUPD; ERASE;
J91=Z;
   ( zero mantissa );
   NEG;
JS21;
   V0; REV;÷F; EXIT1;
19; 
   ERASE;
J92=Z;
   ( 00 FAIL );
   V0;
J96V;
   EXIT1;
3; 
   REV; SET47; FLOAT; REV; ( integer to real power ); (QUERY see * about 39 bit integers)
2; 
   ( real to real power =exp(ln(x)×y) );
   REV; DUP;
J94<Z;
   (+ fail -ve  real );
JSP243; 
   REV; VR;×F;
JP238;
   
91; 
   SET1;
J99;
   
92; 
   SET2;
J99;
   
94; 
   SET4;
J99;
   
96; 
   SET6;
99; 
   SETAV1; PERM;
JP299;
   (+ fail );
   
P232; ( real to integer conversion );
JP202; 
   
   
P233V0; (+overflow check );
   V0 =B4322043547200000;
J1NEN; 
   ZERO; ( ensure that there is a value to print );
1; 
   SETAV0; REV; SET1;
JP299; 
   
( used in code procedures - maybe a precaution in case a thunk was used in a special procedure where there
is no frame - which doesn*t happen)
   
P234; EXIT1; (before calling scalar thunk)
   
P235; EXIT1; (after exit scalar Store thunk)
   
P236; EXIT1; (after exit scalar Fetch  thunk)
   
P237; EXIT1; (after fetching the Array word)
   
P238V9; (+ P47V7; (exp ENH-FGD); (argument in N1); );
   V0=Q3/1/AV6;
   V1=1.442695040888964/1;
   V2=B1067311107601054;
   V3=B2372617635665123;
   V4=B2567106670407501;
   V5=B6625327150150035;
   V6=B12436465/23;
   V7=F-89.0;
   V8=B4321004306716400; ( EXP failure string);
   V9=F+87.336544; ( ln of max possible floating point number );
   DUP; V7; -F;
J2<Z;
   
   DUP; V9; -F;
J3_>Z;
   
   DUP; FIX; NOT; NEG; =C15; V1;×; STR; VR;
   SHADC15; DUPD; ROUND; DUP; =Q15; -; CONT;
   DUP; DUP;×; SHA-7; DUP;
   V2;×; V3; +; REV; V4; +; V5; REV;÷; +;
   REV; SHA-4; DUPD; +; PERM; -; SHA1;÷;
   Q15; NOT; NEG; FLOAT;
J3V;
   
   REV; ERASE; EXIT1;
2; 
   ERASE; ZERO; EXIT1; ( exp(x),  x < -89 );
3; 
   SETAV8; REV; SET1;
JP299;
   ( exp(x),  x _> 87.3 );
   
P240V12; (+ P49V12; (sin CMW); (argument in N1); );
   V0=Q7/-1/AV7;
   V1=F+2.552557924805;
   V2=F-0.285261569181;
   V3=F+0.009118016007;
   V4=F-0.000136587514;
   V5=F+0.0000011849619;
   V6=F-0.000000006703;
   V7=F+0.000000000027;
   V8=F+0.636619772368;
   V9=F+2.0;
   V10=F+1.0;
   V11=Q3/1/AV12;
   V12=B16027063/23;
1; 
   V8;×F; DUP; SET4;
JS44;
   
   V9; -F; REV; SET2;
JS44;
   
   DUP; V10; -F;
J2<Z;
   
   V9; -F;
2; 
   DUP; DUPD;×F; DUP; +F; V10; -F; V0;
JS45;
   
   ×F; PERM; ZERO; SIGNF; REV; ZERO; SIGNF; NEV; J3±Z;
   NEGF;
3; 
   EXIT1;
44; 
   (modulo CMW); (m in N1, x in N2); (+ was P44 in Walgol );
   REV; DUP; =Q15; DUP;
J41=Z;
   
   REV; DUP; CAB; FIX; CAB; SHA-1; -; DUP;
J42>Z;
   
   ERASE; ERASE; Q15; DUP;
J41>Z;
   
   REV; SET47; FLOAT; +F; EXIT1;
41; 
   REV; ERASE; EXIT1;
42; 
   CAB; REV; =C15; SHA-1; REV; STR;
   SHADC15; ERASE; REV; FLOAT; EXIT1;
45; 
   (Cheby CMW); (Q-word in N1, argument in N2); (+ was P45 in Walgol );
   =Q15; DUP; +F; ZERO; M0M15Q; ZERO;
51; 
   ERASE; PERM; DUP; M0M15Q; -F; REVD; DUPD;×F;
   REVD; PERM; -F; PERM; REVD; REV;
J51C15NZ;
   
   -F; PERM; ERASE; ERASE; SETB40100; SHL+32;×F; EXIT1;
   
P242V0; (+ P40V0; (SQUARE ROOT,24.2.64); ( -ve argument already rejected ));
   V0=0.46429/2;
   FIX; DUP; SHLD-1; PERM;
J2<Z; 
   SHL-1;
2; 
   SHA-3; DUP; SHA+1; V0; +; (X0,M);
   DUPD;÷; +; (X1,M);
   DUPD;÷; REV; SHA-2; +; (X2,M);
   DUP; PERM;÷; +; (X3);
   REV; NOT; NEG; FLOAT;
   EXIT1;
   
P243V8; (+ P48V8; (ln ENH-FGH); (argument in N1); );
   V0=Q2/1/AV8;
   V1=-0.693147180559945/0;
   V2=+0.353553390593274/0;
   V3=+1.541342602720874/2;
   V4=+0.612053805720620/4;
   V5=+3.089532445011031/2;
   V6=-1.921406891324693/3;
   V7=+0.286369944871851/1;
   V8=B30463/15;
   FIX; SHA40; V1; DUP; SHA-8; PERM;×; -; REV; SHA-1;
   V2; DUPD; -; PERM; +;÷; DUP; SHA-1; DUP;×; DUP;
   V3; -; V4; REV;÷; V5; +; -; V6; REV;÷; V7; +;×;
   SHA-5; +; SET7; FLOAT; EXIT1;
   
P244V8; ( used WITH TEST i.e. Program Testing option);
   (if V0 is non-zero - contains the last label number)
   (outputs V0 and the assignment value in octal)
   V0 =0; (no tracing by default)
   V1 =B 1010101001010110;
   V2 =B 2020202000000020;
   V3 =B 2020202020202020;
   V4 =Q 0/AV5/AV8;
JP233V; 
   
   V0; J1±Z; EXIT1; (fastest possible exit when not tracing);
1; 
   DUP; V0; DUP; NOT; NEG; =V0;
   SHLD+3; V1; REV; FRB; V2; OR; =V6; (only 3 spaces not 4 as documented);
   ZERO; SHLD+24; V3; DUP; SHL-1; CAB; FRB; OR; =V7; (2nd to 5th digits );
   SHL-27; V3; DUP; SHL-1; CAB; FRB; OR; SHL+6; (6th 7th and 8th digits);
   NOT; NEG; NOT; NEG; =V8; (and a carriage return);
   SETB30; =V5; V4; SET8; OUT;
   VR; EXIT1; (a big line number may have set overflow);
   
P247V0; (+P209 but for 2-dimenions only );
   (+N1; arraybox );
   DUP; SHL-16; SET1; +; =RM3; (hux); (add 1 to skip size in DV);
   SET-2; =+M2; (+reset M2 ); (indices on TOS)
   SET 1; Y0M2;×D; CONT; Y1M2; Y0M3;×D; CONT; +;
   +; (i × 1 + j × delta j + logical origin); (need to mask M-part*)
   EXIT1;
   
P248V3; (+grand close );
   V0 =Q0/AV1/AV3;
   V1 =B30;
   V2 =B 4651565163504544;
   V3 =B 0045564463002002;
   V0; SET8; OUT;
   ZERO; =V1; V3; SETB75; OR; =V3; (+ convert to end message );
   V0; SET8; OUT;
   ZERO; OUT; ( should we exit instead );
   EXIT1;
   
P287; ( N1 contains amount required HUX SPACE
   If insufficient space then FAIL)
JSP298; 
   REV; -; DUP;
J1<Z;
   
   ERASE; EXIT1;
1; 
   ABS; SET7;
J109P299;
   
   
P298; ( The Amount of Core Storage Left  - for use by a code proc at user level
   up to the user to fail or find a way round HUX SPACE);
   SET AZ0; Z1; -; SETAY0; M2; +; -;
   (+ Z1 holds the amount of Z-store consumed - initialised as 2 );
   EXIT1;
(+ routines which we think were originally included in library A0 );
(+ but which are included here so as to avoid bulk in the text );
(+ for ease of diagnostics );
(+ at present they have interim implementations -- usually leading to execution error );
(+ These next 10 routines are documented as available to code precedures. );
   
P299V27; ( Catastrophic Failure Routine );
   V0 =B1212121212121212;
   V1 =B7777777777202020;
   V2 =B2020202020202020;
   V4 =B0253415447575400; ( P [C] KALGOL );
   V5 =B6462414345007777; ( P TRACE [DD]);
   V6 =B0037373737373717; ( P ..../ );
   V7 =B3737373737373702; ( P ....[C] );
   V8 =B4641515400202020; ( P FAIL [_] 000 );
   V9 =B0051560077777777; ( P [_] IN [*DDDD] );
   V10 =B3737377777777777; ( P ... [5D] );
   V11 =B7777777777777777;
   V13 =B7777777777777777;
   V14 =B7777777777777777;
   V15 =B0266415465450077; ( P [C]VALUE [*D] );
   V16 =B3737373737373737; ( P ........ );
   V17 =B3737373737373737; ( P ........ );
   V18 =B0057436441547702; ( P [_] OCTAL [DC] );
   V19 =B4321742007214024; ( terminated by operator in ABS );
   V20 =B0620603704007636;
   V21 =B0322223606415420;
   V22 =B0720603706416635;
   V23 =B4321540202200236; ( P290 not yet implemented );
   V24 =B1463207147437052;
   V25 =B1631705614432461;
   V26 =B1243105214634452;
   V27 =B1231677777777640;
J99EN; 
   
1; 
   V0; REV; FRB; V8; OR; =V8; ( failure number left in N1 );
J99EN; 
   ZERO; SHLD+24; ( value left in N2 );
   V2; DUP; SHL-1; CAB; FRB; OR; =V16;
   V2; DUP; SHL-1; CAB; SHL-24; FRB; OR; =V17;
J99EN; 
   SETAV10; =RM15; SET4; =C15; ( output buffer );
JS20P700; 
   ( print failure string );
99; 
   SETB30; =V3; ( always output on stream 30);
   Y0M1; SHL-32; ( level of caller - should be last level, but do not know where to find it );
   DUP; J10±Z; ERASE; Y-1M2; =Q15; Y0M15; SHL-32;
10; 
   V0; REV; FRB; V2; OR; SHL+6; SETB17; OR; =V6;
   Z0; ( last label passed );
   V0; REV; FRB; V2; OR; SHL+6; SETB02; OR; =V7;
   SETAV18; =RM15; SETAV3; =I15; Q15; SET8; OUT;
   V3P248; SETB400; OR; =V3P248; ( ENDS 4 after failure );
JP248; 
   ( Grand close );
100; 
   (even restart );
J101NEN; 
   ZERO;
101; 
   SETAV19; REV; SET1;
J1;
   
109; 
   (failure for facilities not yet implemented);
   (enter with failure value in N2, routine number in N1);
   ZERO; REV; ( entry point 0 by default -- printed as the value );
108; 
   (enter with failure value in N3, routine number - 290 in N1 entry label number in N2);
   SHL+8; V23; +; =V23; ( put in routine number );
   SETAV23; PERM;
J1;
   
   
P297; ( Next Input/Output Buffer );
   ZERO; SET7;
J109P299;
   
   
P290; ( Device Directory );
   ZERO; ZERO;
J109P299;
   
2; 
   SET2; ZERO;
J109P299;
   
   
P289V6; ( Input/Output Table Addressing );
   ZERO; SET-247;
J109P299;
   
(+ Holdsworth specific versions );
   
P700V255; (make string of ABS into KDF9 chars);
   V0 =B 0020000000000000;
   V1 =B 0021000000000000;
   V2 =B 0022000000000000;
   V3 =B 0023000000000000;
   V4 =B 0024000000000000;
   V5 =B 0025000000000000;
   V6 =B 0026000000000000;
   V7 =B 0027000000000000;
   V8 =B 0030000000000000;
   V9 =B 0031000000000000;
   V12 =B 0041000000000000;
   V13 =B 0042000000000000;
   V14 =B 0043000000000000;
   V15 =B 0044000000000000;
   V16 =B 0045000000000000;
   V17 =B 0046000000000000;
   V18 =B 0047000000000000;
   V19 =B 0050000000000000;
   V20 =B 0051000000000000;
   V21 =B 0052000000000000;
   V22 =B 0053000000000000;
   V23 =B 0054000000000000;
   V24 =B 0055000000000000;
   V25 =B 0056000000000000;
   V26 =B 0057000000000000;
   V27 =B 0060000000000000;
   V28 =B 0061000000000000;
   V29 =B 0062000000000000;
   V30 =B 0063000000000000;
   V31 =B 0064000000000000;
   V32 =B 0065000000000000;
   V33 =B 0066000000000000;
   V34 =B 0067000000000000;
   V35 =B 0070000000000000;
   V36 =B 0071000000000000;
   V37 =B 0072000000000000;
   V38 =B 0041000000000000;
   V39 =B 0042000000000000;
   V40 =B 0043000000000002;
   V41 =B 0044000000000000;
   V42 =B 0045000000000000;
   V43 =B 0046000000000000;
   V44 =B 0047000000000000;
   V45 =B 0050000000000000;
   V46 =B 0051000000000000;
   V47 =B 0052000000000000;
   V48 =B 0053000000000000;
   V49 =B 0054000000000000;
   V50 =B 0055000000000000;
   V51 =B 0056000000000000;
   V52 =B 0057000000000000;
   V53 =B 0060000000000000;
   V54 =B 0061000000000000;
   V55 =B 0062000000000000;
   V56 =B 0063000000000000;
   V57 =B 0064000000000000;
   V58 =B 0065000000000000;
   V59 =B 0066000000000000;
   V60 =B 0067000000000000;
   V61 =B 0070000000000000;
   V62 =B 0071000000000000;
   V63 =B 0072000000000000;
   V255 =B 0000000000000000;
   V174 =B 0004000000000000;
   V160 =B 0002000000000000;
   V11 =B 0037000000000000;
   V132 =B 0012000000000000;
   V137 =B 1200000000000000;
   V142 =B 0000000000000000;
   V177 =B 5565546400000000;
   V148 =B 0013000000000000;
   V152 =B 0034000000000000;
   V153 =B 1300000000000000;
   V158 =B 0000000000000000;
   V161 =B 0017000000000000;
   V162 =B 0011000000000000;
   V166 =B 0016000000000000;
   V185 =B 0010000000000000;
   V193 =B 0035000000000000;
   V209 =B 0036000000000000;
   V10 =B 0033000000000000; (subscript 10)
   V190 =B 0077000000000000;
   V192 =B 4154475754000000; (ALGOL)
   V240 =B 4570516400000000; (EXIT)
   V176 =B 5344463100000000; (KDF9)
   V147 =B 4156440000000000; (and)
   V72 =B 4162624171000000; (array)
   V140 =B 4245475156000000; (begin)
   V67 =B 4257575445415600; (boolean)
   V128 =B 4357555545566400; (comment)
   V145 =B 4451660000000000; (div)
   V214 =B 4457000000000000; (do)
   V165 =B 4554634500000000; (else)
   V156 =B 4556440000000000; (end)
   V195 =B 4561660000000000; (eqv)
   V205 =B 4641546345000000; (false)
   V134 =B 4657620000000000; (for)
   V178 =B 4745000000000000; (ge)
   V136 =B 4757645700000000; (goto)
   V194 =B 4764000000000000; (gt)
   V133 =B 5146000000000000; (if)
   V179 =B 5155600000000000; (imp)
   V66 =B 5156644547456200; (integer)
   V121 =B 5441424554000000; (label)
   V146 =B 5445000000000000; (le)
   V208 =B 5451426241627100; (library)
   V130 =B 5464000000000000; (lt)
   V210 =B 5645000000000000; (ne)
   V131 =B 5657640000000000; (not)
   V163 =B 5762000000000000; (or)
   V143 =B 5767560000000000; (own)
   V80 =B 6062574345446562; (procedure)
   V141 =B 6100000000000001; (q -- marker for special symbol)
   V65 =B 6245415400000000; (real)
   V224 =B 6345475545566400; (segment)
   V182 =B 6364456000000000; (step)
   V122 =B 6364625156470000; (string)
   V88 =B 6367516443500000; (switch)
   V149 =B 6450455600000000; (then)
   V221 =B 6462654500000000; (true)
   V157 =B 6500000000000000; (u)
   V198 =B 6556645154000000; (until)
   V129 =B 6560000000000000; (up)
   V159 =B 6641546545000000; (value)
   V150 =B 6750515445000000; (while)
   =RM15; (+ M15 addresses the current output word - need to subtract 1 at R22)
21; 
   SET100; =C15; (+ C15 the length of the buffer );
20; 
   CI0TOQ13; (+ C13 is the shift used to insert the most recent output character  I13 NZ when doing layout chars );
22; 
   M-I15; ( side entry from P288 (writetext));
   =RM14; (+ M14 addresses the current input word );
   SET-40; =C14; (+ C14 is the shift used to extract the current ABS, ignore initial quote );
1; 
J10C15Z;
   (+ ignore tail of overlength string );
   M0M14; SET8; =+C14; SHLC14; SETB377; AND; (+ next ABS );
   SETB235;
J4=;
   =M13; (+ stop if closing quote );
   V0M13; DUP; SHL-42;
J2=Z;
   (+ j if single char symbol );
   DUP; SETB77; AND; J9±Z; (+ bottom char set if special symbol, i.e. proc or string quote );
   SET7; SHLD+42;
6; 
J5C13NZ;
   
   ZERO; =M0M15QN; (+ initialise next output word );
   SET48; =C13;
5; 
   DUP; SHL-42; DUP;
J7=Z;
   (+ one char in N1 OR ZERO );
   SET-6; =+C13; SHLC13; M0M15; OR; =M0M15; ZERO;
7; 
   ERASE; SHLD+6; DUP; J6±Z;
   ERASE; ERASE; SET7; SHC-12; (+ end of sym, put in last quote );
2; 
   I13; J12±Z; (+ use char in bottom of word for layout stuff );
   SHL-36;
12; 
J3C13NZ;
   (+ J if current output not full );
   ZERO; =M0M15QN; (+ initialise next output word );
   SET48; =C13;
3; 
   SETB77; AND; (+ only needed for layout chars );
   SET2;
J13=;
   (+ treat newline specially to put always at the end of a word )
   SET-6; =+C13; SHLC13;
14; 
   M0M15; OR; =M0M15;
11; 
J1C14NZ;
   M+I14; SET-48; =C14; 
J1; 
   
4; 
   ERASE; I13; I0TOQ13; J11±Z; (+ finish if not doing layout characters );
   ZERO; NOT; SHLC13; NOT; M0M15; OR; =M0M15; (+ pad last word with dummies );
10; 
   EXIT1;
8; 
   SETB6245; SHC+12; V80; SET7; SHLD-6; ERASE;
J6;
   
9; 
   (special treatment for newline proc and string quote);
   V160;
J13=;
   (+ newline );
   V80; NEV;
J8=Z;
   (+ procedure -- the only ABS with more than 7 characters );
   I13=+1;
J11;
   (+ set layout marker and keep going );
13; 
   ERASE; (+ ensure carriage return is at the end of a word )
   ZERO; NOT; SHLC13;
   NOT; SETB75; -; (+ convert last dummy to cr );
   C0TOQ13;
J14;
   
   
P2V0; Y2M2; Y3M2; MRWDQ0; EXIT1;
P0;
*2;
   ERASE; SET-4; =+M2;
JSP2;
   EXIT1; V3=7;
*4;
   SET0; V1; SET2;
JSP216;
   ERASE; =Y3M1; 
   SET3; JSP205; Y2M3; SET1; -; JP233V; SET3; JSP205; =Y2M3;
   M+I2; M+I2; SET3;
JSP205;
   Y2M3; =Y0M2Q; 
   SETAR194; =I1; Q1; =Y0M2Q; 
   SETAR195; =I1; Q1; =Y0M2Q; 
   
J196; 
   
194; 
   M+I2; M+I2; SET4;
JS4;
JSP202; 
   
JP207; 
   
195; 
JP213;
   
196; 
   SETAR197; =I1; Q1; =Y0M2Q; 
   SETAR198; =I1; Q1; =Y0M2Q;
J199;
   
197; 
   SET3;
JSP205;
   Y3M3; JSP206; 
JP207; 
   
198; 
   SET3;
JSP205;
   Y4M3; JSP206; 
JP207; 
   
199; 
   SETAR200; =I1; Q1; =Y0M2Q; 
   SETAR201; =I1; Q1; =Y0M2Q;
J202;
   
200; 
   SET3;
JSP205;
   Y5M3; JSP206; 
JP207; 
   
201; 
   SET3;
JSP205;
   Y6M3; JSP206; 
JP207; 
   
202; 
   SETAR203; =I1; Q1; =Y0M2Q; 
   SETAR204; =I1; Q1; =Y0M2Q;
J205;
   
203; 
   SET3;
JSP205;
   Y7M3; JSP206; 
JP207; 
   
204; 
   SET3;
JSP205;
   Y8M3; JSP206; 
JP207; 
   
205; 
   SETAR206; =I1; Q1; =Y0M2Q; 
   SETAR207; =I1; Q1; =Y0M2Q;
J208;
   
206; 
   SET3;
JSP205;
   Y9M3; JSP206; 
JP207; 
   
207; 
   SET3;
JSP205;
   Y10M3; JSP206; 
JP207; 
   
208; 
   SET4;
JS3;
   SET3; JSP205; DUP; =Y13M3; 
   JP233V; =Y2M1;
   Y2M1;
JP219;
   V1=4;
*3;
   SET0; V2; SET13;
JSP216;
   ERASE; =Y14M1;
   Y2M1; ZERO; SIGN; SHA-1; NEG; NOT;
J210=Z;
   Y9M1; JSP206; =Y15M1; 
   Y11M1; JSP206; Y15M1; REV; +; JSP203; JP233V; =Y13M1; 
   
J209; 
   
210; 
   M+I2; M+I2; SET3;
JS4;
   ERASE;
209; 
   Y13M1;
JP219;
   V2=16;
1; 
   ZERO; DUP; SET2; DUP; =Z1; =RM2; =M1;
JS211;
JSP248; 
   ZERO; OUT;
211; 
   SET0; V0; SET2;
JSP216;
   =YA1; =Y3M1;
   M+I2; M+I2; SET30; =Y0M2Q; 
   M+I2; M+I2; SET10; =Y0M2Q; 
   SETAR212; =I1; Q1; =Y0M2Q; 
   SETAR213; =I1; Q1; =Y0M2Q;
J214;
   
212; 
   SET1;
JP207;
   
213; 
JP213;
   
214; 
   SETAR215; =I1; Q1; =Y0M2Q; 
   SETAR216; =I1; Q1; =Y0M2Q;
J217;
   
215; 
   SET1; NEG;
JP207;
   
216; 
JP213;
   
217; 
   SETAR218; =I1; Q1; =Y0M2Q; 
   SETAR219; =I1; Q1; =Y0M2Q;
J220;
   
218; 
   SET1; NEG;
JP207;
   
219; 
JP213;
   
220; 
   SETAR221; =I1; Q1; =Y0M2Q; 
   SETAR222; =I1; Q1; =Y0M2Q;
J223;
   
221; 
   SET1;
JP207;
   
222; 
JP213;
   
223; 
   SETAR224; =I1; Q1; =Y0M2Q; 
   SETAR225; =I1; Q1; =Y0M2Q;
J226;
   
224; 
   ZERO;
JP207;
   
225; 
JP213;
   
226; 
   SET1;
JS3;
JSP202; 
   =Y0M2Q; 
   SET1; JS2;
JP219; 
   V0=5;
FINISH;
|
