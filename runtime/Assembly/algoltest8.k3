
P
KALGOL000UPU PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING
PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING
PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING PADDING
------|
ST24000; TL99999;
V0031; YA0024; YB0000; YC0000;
RESTART; J100P299; J100P299;         (+ Official response to even restart );
PROGRAM;
( There is documentaton at the end of this file );
J1P0; 
   (+ defect in KAL3 assembler cannot handle P0 at the end );
(+ routines known to the Kalgol code generator );
   
P201; (prepare to goto exit from a procedure, resets stack to calling level)
   (N1 contains the goto label level number)
1; 
   Y0M1; =Q3;
   M3; =M1; I3; =M2;
   C3; J1±;
   ERASE; EXIT1;
   
P202V0; ;(+ real to integer conversion );
   V0 =B4321042410716400; ( FIX );
   DUP; FIX; SET47; -; DUP; =C4;
   SET-9; SIGN;
J99>Z;
   REV; ERASE;
   SHAC4;
   EXIT1;
99; 
   ( fail, number too big for accurate conversion  - 39 bit integer max* QUERY - wAlgol 39 bit limit
   wAlgol run time error 243 - I-type number out of 39-bit range);
   ERASE;
   SETAV0; REV; SET1;
JP299;
   
   
P203; (+ convert integer to real );
   SET47; FLOAT; EXIT1;
   
P204; (integer divide);
   DUPD; NEV; ( sign of result in D0 );
   CAB; ABS; ( First operand );
   CAB; ABS; ( Second operand );
   ÷I; ERASE; ( ÷I same as entier(a/b) for +ve operands );
   REV;
J2<Z;
   ( a jump not executed is quicker -- +ve result more common );
   EXIT1; ( see sect 3.3.4 of Algol report );
2; 
   NEG; EXIT1;
   
P205; (+set M3 for the frame of the non-local variable/parameter );
   (+N1; non-local level );
   Y0M1; =Q3; (+data link );
2; 
   C3;
J1=;
   (+is it this level );
   Y0M3; =Q3;
J2;
   
1; 
   ERASE;
   EXIT1; (+Q3 is setup for the frame and is used access the var. YyM3 );
   
P206; (+evaluate Thunk );
   (+ N1; parameter -/ARThunk/M1 );
   (+create a link -/LINK/M1 and put at the top of the stack );
   LINK; =I3; M1; =M3; Q3; =Y0M2Q;
   (+set the stack frame for the Thunk );
   =Q3; M3; =M1;
   I3; =LINK; EXIT;
   
P207; (+end Thunk );
   (+get the Thunk link off the stack );
   M-I2;
   Y0M2; =Q3;
   (+reset the stack and exit );
   M3; =M1; I3; =LINK; EXIT1;
   
P208; (+call formal proc );
   =LINK; EXIT;
   
P209V1; (+get indexed address of array element );
   (+N1; dimensions );
   (+N2; ArrayBox where Ipart -> DV rel. Y0, CPart physical origin rel Y0, Mpart log. origin rel Y0 );
   (+the indices are put on the stack );
   =V0; =V1;
   V0; NEG; =+M2; (+ set M2 to the first index );
   V1; SHL-16; SET1; +; =RM3; (+DV rel Y0 ); (hux); (need to add 1 to skip the *size* and point to Delta2);
   V0; SET1; -; =C3; (+dimensions ); ( Delta 1  is 1 so C3--, rubbish);
   (ZERO; ); (start with 1);
   Y0M2Q; (first index - times  Delta 1);
1; 
J2C3Z;
   
   Y0M2Q; (index); Y0M3Q; (Delta);×D; CONT; +;
J1; 
   
2; 
   (+ N1; we have sigma Dv×index );
   V1; =Q3; M3; +; (+logical origin + sigma Dv×index rel Y0 );
   V0; NEG; =+M2; (+reset stack );
   EXIT1;
   
P210V9; (array declarations)
   (+ own arrays can be used as parameter* );
   (+ supports own array whose Data is held in Z stores );
   (+ Z1 holds the amount of Z-store consumed - initialised as 2 );
   (+ addresses in DV are rel. Y0 );
   (+the code generated by B60 can set some parameters *negative* );
   (+why is unclear );
   (+if N1 is negative then the declaration is an own array );
   (+own array N1 ==-1 plus 3 other params, not own 3 prams, first one is positive );
   (+addresses in DV are relative to Y0 - so own starting at Zz are indexed from AZz - Ay0 );
   (+uses Q3 and Q4 (which is saved and restored) );
   ZERO; =V9; (+own array marker );
   DUP;
J4_>Z;
   (+ jump if not own );
   dup; =V9; (+-ve indicates own array );
   (+own arrays );
   (+N1; -number of arrays );
   (+N2; *Set1 marker );
   (+N3; number of bounds );
   (+N4; AYBb );
   (+ if own and array word - YBb - is non zero exit );
   (+N3 - number of bounds can be negative, reason unknown );
   ABS; =V0; ERASE; ABS; =V1; SETAY0; -; DUP; =V2; (+ relative to Y0 );
   =M3; Y0M3;
J11=Z;
   EXIT1;
4; 
   (+ordinary arrays );
   (+N1; number of arrays );
   (+N2; number of bounds );
   (+N3; AYy );
   =V0; (+V0; no. arrays );
   abs; =V1; (+V1; no. bounds );
   (N3); SETAY0; -; M1; +; =V2; (+V2; AYy - AY0 + M1 - rel to Y0 );
11; 
   Q4; =V3; (+V3; Q4 - saved and restored on exit);
   V2; =RM3; V0; =+M3; (SET1; =+M3; ); (+start of DV beyond V0 array boxes - rel Y0 );
(+calculate array size and set up Dope Vector );
   (need to step through all the bounds to compute the size, but not to to
   set DV1 (as 1) in the DopeVector
   The DV is size; Delta2, etc)
   M2; V1; -; DUP; =V5; (+V5; start of the bounds - rel Y0 );
   =RM4; (+to step through the bounds );
   V1; =C4; (+number of bounds );
   (+set up DV );
   SET1; (DELTA[0]);
   SET1; =V7; (hux - size is in DV)
1; 
   Y0M4Q; Y0M4Q; REV; -; (+ upper - lower +1);
   SET1; +;×D; CONT; (times D[i-1])
J10C4Z; 
   dup; =Y1M3Q; 
   (+D2, D3 etc. we dont store the last Di);
10; 
J1C4NZ;
   
   =V7;
   V2; =RM3; V0; =+M3; (+start of DV beyond V0 array boxes rel M0 );
   V7; =Y0M3; 
   (store the size in the first word of the DV );
   (+now compute Li×Di ); (to compute the Logical Origin offset);
   V2; =RM3; V0; =+M3; SET1; =+M3; (+start of DV beyond V0 array boxes rel Y0 );
   V5; =RM4; (+start of bounds - rel Y0 );
   V1; =C4;
   SET0;
   Y0M4Q; SET1;×D; CONT; +; (special case for A[i..] - Delta i is 1 and not stored)
   Y0M4Q; ERASE;
J21C4Z; 
   
2; 
   Y0M4Q; (Li); Y0M3Q; (Di);×D; CONT; +;
   Y0M4Q; ERASE; (+skip Upper bound );
J2C4NZ; 
   
21; 
   =V8; (+ sigma Li×Di );
   (+now set up the array box );
   V2; V0; +; =C3; (+dv address );
   V2; =RM4; (+address first array box - AYy );
17; 
   V0; =C4; (+no of arrays );
   M2; V1; -; =M2; (+reset M2 to before indices M2 is rel Y0 );
3; 
   (here we check the space for each of the declared arrays HUX SPACE)
   V7;
JSP287;
   
   V9;
J13 =Z;
   
   (+own );
   V7; Z1; +; =Z1; (+take space, for  data );
   SET AZ2; Z1; -; SETAy0; -; (+ actual Location rel. Y0 );
   =I3;
J14;
   
13; 
   M2; =I3; (+ actual Location  rel. to Ay0 - should be in C3 );
   V7; =+M2; (+take space for data );
14; 
   I3; V8; -; =M3; (+actual origin - sigma Li×Di =logical origin rel Y0 );
   C3; I3; =C3; =I3; (hux)
   Q3; =Y0M4Q;
   I3; C3; =I3; =C3;
J3C4NZ; 
   (+store array box );
   V3; =Q4;
   EXIT1;
   
P212; (+restore Q-stores on exit ); (+ used on exit from  non-simple Procedures)
   (+N1; no of Q-stores to restore, 1; 12 );
   NEG; DUP; =+M2;
   SETAR2; +; =LINK; EXIT; (+switch );
*1; 
   Y0M2Q; =Q4;
   *Y0M2Q; =Q5;
   *Y0M2Q; =Q6;
   *Y0M2Q; =Q7;
   *Y0M2Q; =Q8;
   *Y0M2Q; =Q9;
   *Y0M2Q; =Q10;
   *Y0M2Q; =Q11;
   *Y0M2Q; =Q12;
   *Y0M2Q; =Q13;
   *Y0M2Q; =Q14;
   *Y0M2Q; =Q15; (+ M2 will not be back to where it was before Q-store preservation );
*2; 
   EXIT1; (+ but in any case M2 is about to be overwritten );
   
P213V2; (+invalid address Thunk; );
   V0 =B4321702003417413;
   V1 =B0100540702602413;
   V2 =B0040563500000000;
   SETAV0; ZERO; SET1;
JP299;
   
   
P216; (+enter non-simple procedure );
   (+N1; No. Parameter locations + 2; );
   (+N2; fixed space required );
   (+N3; Q-store to be saved );
   (+N4; called by Level No. );
   (+Data link - set up in Q3 - has format; Calling Level No./ M2 of call frame/ M1 of call frame );
   M1TOQ3;
   M2; REV; -; DUP; =M1; =I3; (+recover the calling Stack Pointer );
   (Check for Space HUX SPACE)
   DUP;
JSP287;
   
   =+M2; (+inc. for fixed space required );
   (+time to call Q-saver );
   NEG; SETAR2; +; =LINK; EXIT; (+branch on Q-stores to save );
*1; 
   Q4; =Y0M2Q;
   *Q5; =Y0M2Q;
   *Q6; =Y0M2Q;
   *Q7; =Y0M2Q;
   *Q8; =Y0M2Q;
   *Q9; =Y0M2Q;
   *Q10; =Y0M2Q;
   *Q11; =Y0M2Q;
   *Q12; =Y0M2Q;
   *Q13; =Y0M2Q;
   *Q14; =Y0M2Q;
   *Q15; =Y0M2Q;
*2;
   (if the calling level is 0, now clear the space used for own array dope vector ie YB0 to YC0);
   DUP; J3±Z;
   SETAYB0; =RM4;
   SETAYC0; SETAYB0; -; =C4;
*4; 
   ZERO; =M0M4Q; *J4C4NZS;
3; 
   =C3; (+calling level- complete data link );
   Q3; =Y0M1; 
   (+data link );
   LINK; LINK; =Y1M1; =LINK; M2; M1;
   ( M2 is not clear - it is saved after the last parameter )
   (M1 is for access to non-local variables in non-recursive procs - stored in YAlevel);
   EXIT1;
   
P217; (compute the loop count :=a step b until c - a in M4 , c in C4 b in I4);
   M4; C4; -; Set1; +; I4;
JSP204;
   EXIT1;
   
P218V7; (+copy array by value );
   (+N1; SET-1 *** - no idea what this is for ); ( Possibly 0  is ordinary, -1 is own array; hux)
   (+N2; SETAYarrayword - this is the parameter location - rel. M1 ); (SURELY M0*)
   (+ this is updated to point to the copy location );
   (+uses Q4 );
   (+arrays are copied onto the stack );
   (+no checks on store limits );
   (+note that there is only one DopeVector for all copies );
   =V0; =V1; M2; =V4; (+new start address  for the array copy);
   V1; =M3; M1M3; DUP; =V5; =Q3; (+the array word in the parameters );
   M3; C3; -; =V2; (+ L - A; the logical offset - to set the new C3 ); (hux)
   (V2 is absolute - logical address)
   (+now get the size );
   I3;
   =M3; Y0M3; DUP; =C2; =V7; (+size);
   C3; =RM3; (physical location)
   (here we check the space for the copy HUX SPACE)
   C2;
JSP287;
   
*1; 
   Y0M3Q; =Y0M2Q;
J1C2NZS;
   (+copy);
   V1; =M3; (+address of the array word );
   (+update array word );
   V5; =Q4; V4; dup; =C4; V2; +; =M4; Q4; =M1M3; (hux)
   EXIT1;
   
P219; (+exit non-simple procedure );
   Y0M1; =Q3; (+data link );
   Y1M1; =LINK; (+address link );
   (+set caller frame );
   M3; =M1;
   I3; =M2;
   EXIT1;
   
P220; (+Switch Declaration );
   (+N1; AYy of space for sw elements );
   (+N2; number of elements );
   (+ set up Yy to no of elements/AYy/M2 );
   DUP; =M4; =I3; M1; =+I3; (+ make address of switch thunks rel. to M0)
   =C3; M2; =M3; Q3; =M1M4;
   EXIT1;
   
P221; (+evaluate formal (label) thunk );
   (+N1; -/AYy/address );
   =Q3;
   C3; DUP; =M1;
J1=Z;
   
   C3; =M1; YA0M1; =C3; ( m1 for the level in C3);
1; 
   Q3; EXIT1;
   
P222; (+evaluate switch );
   (+N1; nElements/AYy/M2 - M2 is the stack top for the block);
   (+index is in M3);
   (+Fetch the label Thunk into N1 );
   (+first check the index is valid i.e 0<M3×<nElement );
   (DUP; =M2; ); SHL+16; SHL-32; =I3; M+I3; M0M3; (+get the label thunk ); (+this address is relative to M0);
   =LINK; EXIT; (execute the switch thunk - leaves N1; M1/AYy/address ); EXIT1;
   
P223; (+exit to formal label );
   (+N1; M1/AYy/address );
   =Q3; C3; =M1; I3; =M2; M2M1; =M2; M3;
   =LINK; EXIT;
   
P228; (N1 =FSR; N2 =Number of Q*s to save);
   (+ used before entry to  Simple  Procedures);
   SET2; +;
   M2; PERM; (FSR, No Qs, M2)
   (Check for Space HUX SPACE)
   DUP;
JSP287;
   
   =+M2; (+inc. for fixed space required );
   NEG; SETAR2; +; =LINK; EXIT; (+branch on Q-stores to save );
*1; 
   Q4; =Y0M2Q;
   *Q5; =Y0M2Q;
   *Q6; =Y0M2Q;
   *Q7; =Y0M2Q;
   *Q8; =Y0M2Q;
   *Q9; =Y0M2Q;
   *Q10; =Y0M2Q;
   *Q11; =Y0M2Q;
   *Q12; =Y0M2Q;
   *Q13; =Y0M2Q;
   *Q14; =Y0M2Q;
   *Q15; =Y0M2Q;
*2; 
   =M2; (restore access to parameters);
   EXIT1;
   
P229; (N1 =FSR; N2 =Number of Q*s to restore);
   (on exit from simple procedures);
   M2; PERM; (FSR, No Qs, M2);
   SET2; +;
   =+M2; (+inc. for fixed space required );
   NEG; SETAR2; +; =LINK; EXIT; (+switch );
*1; 
   Y0M2Q; =Q4;
   *Y0M2Q; =Q5;
   *Y0M2Q; =Q6;
   *Y0M2Q; =Q7;
   *Y0M2Q; =Q8;
   *Y0M2Q; =Q9;
   *Y0M2Q; =Q10;
   *Y0M2Q; =Q11;
   *Y0M2Q; =Q12;
   *Y0M2Q; =Q13;
   *Y0M2Q; =Q14;
   *Y0M2Q; =Q15;
*2; 
   =M2;
   EXIT1;
   
P230; (get index increment for addressing 3D array [i,j,k )
   ( N2 =address Array definition N1 Number of dimensions*)
   ( Y0M2 =1 increment A [ i, ] Y1M2 =1 increment A[ ,j] etc);
   REV; SHL-16; =RM3; (Address of DVector);
   =C3; (Number of dimensions)
   C3; NEG; =+M2; (reset Stack)
   ZERO;
   Y0M2;
J1=Z;
   SET1; +; DC3; 
J3C3Z; 
   (Set1; )
1; 
   Y1M2;
J2=Z;
   Y1M3; +; DC3; 
J3C3Z; 
   
2; 
   Y2M2;
J3=Z;
   Y2M3; +;
3; 
   EXIT1;
(P230V2; (alternative get index increment for addressing 3D array [i,j,k )
   ( N2 =Array Word , N1 Number of dimensions*)
   (stack SET1 =Y0M2Q etc for increment i, j, k,  etc N1 dimensions)
   =V0; =V1;
   V0; Neg; =+M2; (reset Stack)
   V1; =Q4; I4; =RM3; V0; =C3;
   SET1; Y0M2Q; ;×D; CONT; DC3; (DV1 × selector)
1; 
   Y1M3Q; Y0M2Q;×D; CONT; +;
J1C3NZ;
   (add in the increment if selected)
   V0; Neg; =+M2; (reset Stack)
   EXIT1; (N* contains the sum of the constant index increment);
)
   
P231V2; ( exponentiate -- new code by DH Feb2017 );
   V0 =F1.0;
   V1 =B4321702003405403;
   V2 =B0260201300605635;
4; 
   REV; ( integer to integer power real result );
   SET47; FLOAT; REV; (QUERY see * about 39 bit integers)
1; 
   DUP;
J19=Z;
   ( real to integer power );
   DUP;
J11<Z;
   ( -ve exponent );
21; 
   V0; PERM; ( real to +ve integer power );
211; 
   SHC-1; STR;
J212=Z;
   
   PERM; DUP; PERM;×F; PERM; REV;
212; 
   REV; DUP;×F; REV; DUP; J211±Z;
   ERASE; ERASE; EXIT1;
11; 
   DUPD; ERASE;
J91=Z;
   ( zero mantissa );
   NEG;
JS21;
   V0; REV;÷F; EXIT1;
19; 
   ERASE;
J92=Z;
   ( 00 FAIL );
   V0;
J96V;
   EXIT1;
3; 
   REV; SET47; FLOAT; REV; ( integer to real power ); (QUERY see * about 39 bit integers)
2; 
   ( real to real power =exp(ln(x)×y) );
   REV; DUP;
J94<Z;
   (+ fail -ve  real );
JSP243; 
   REV; VR;×F;
JP238;
   
91; 
   SET1;
J99;
   
92; 
   SET2;
J99;
   
94; 
   SET4;
J99;
   
96; 
   SET6;
99; 
   SETAV1; PERM;
JP299;
   (+ fail );
   
P232; ( real to integer conversion );
JP202; 
   
   
P233V0; (+overflow check );
   V0 =B4322043547200000;
J1NEN; 
   ZERO; ( ensure that there is a value to print );
1; 
   SETAV0; REV; SET1;
JP299; 
   
( used in code procedures - maybe a precaution in case a thunk was used in a special procedure where there
is no frame - which doesn*t happen)
   
P234; EXIT1; (before calling scalar thunk)
   
P235; EXIT1; (after exit scalar Store thunk)
   
P236; EXIT1; (after exit scalar Fetch  thunk)
   
P237; EXIT1; (after fetching the Array word)
   
P238V9; (+ P47V7; (exp ENH-FGD); (argument in N1); );
   V0=Q3/1/AV6;
   V1=1.442695040888964/1;
   V2=B1067311107601054;
   V3=B2372617635665123;
   V4=B2567106670407501;
   V5=B6625327150150035;
   V6=B12436465/23;
   V7=F-89.0;
   V8=B4321004306716400; ( EXP failure string);
   V9=F+87.336544; ( ln of max possible floating point number );
   DUP; V7; -F;
J2<Z;
   
   DUP; V9; -F;
J3_>Z;
   
   DUP; FIX; NOT; NEG; =C15; V1;×; STR; VR;
   SHADC15; DUPD; ROUND; DUP; =Q15; -; CONT;
   DUP; DUP;×; SHA-7; DUP;
   V2;×; V3; +; REV; V4; +; V5; REV;÷; +;
   REV; SHA-4; DUPD; +; PERM; -; SHA1;÷;
   Q15; NOT; NEG; FLOAT;
J3V;
   
   REV; ERASE; EXIT1;
2; 
   ERASE; ZERO; EXIT1; ( exp(x),  x < -89 );
3; 
   SETAV8; REV; SET1;
JP299;
   ( exp(x),  x _> 87.3 );
   
P240V12; (+ P49V12; (sin CMW); (argument in N1); );
   V0=Q7/-1/AV7;
   V1=F+2.552557924805;
   V2=F-0.285261569181;
   V3=F+0.009118016007;
   V4=F-0.000136587514;
   V5=F+0.0000011849619;
   V6=F-0.000000006703;
   V7=F+0.000000000027;
   V8=F+0.636619772368;
   V9=F+2.0;
   V10=F+1.0;
   V11=Q3/1/AV12;
   V12=B16027063/23;
1; 
   V8;×F; DUP; SET4;
JS44;
   
   V9; -F; REV; SET2;
JS44;
   
   DUP; V10; -F;
J2<Z;
   
   V9; -F;
2; 
   DUP; DUPD;×F; DUP; +F; V10; -F; V0;
JS45;
   
   ×F; PERM; ZERO; SIGNF; REV; ZERO; SIGNF; NEV; J3±Z;
   NEGF;
3; 
   EXIT1;
44; 
   (modulo CMW); (m in N1, x in N2); (+ was P44 in Walgol );
   REV; DUP; =Q15; DUP;
J41=Z;
   
   REV; DUP; CAB; FIX; CAB; SHA-1; -; DUP;
J42>Z;
   
   ERASE; ERASE; Q15; DUP;
J41>Z;
   
   REV; SET47; FLOAT; +F; EXIT1;
41; 
   REV; ERASE; EXIT1;
42; 
   CAB; REV; =C15; SHA-1; REV; STR;
   SHADC15; ERASE; REV; FLOAT; EXIT1;
45; 
   (Cheby CMW); (Q-word in N1, argument in N2); (+ was P45 in Walgol );
   =Q15; DUP; +F; ZERO; M0M15Q; ZERO;
51; 
   ERASE; PERM; DUP; M0M15Q; -F; REVD; DUPD;×F;
   REVD; PERM; -F; PERM; REVD; REV;
J51C15NZ;
   
   -F; PERM; ERASE; ERASE; SETB40100; SHL+32;×F; EXIT1;
   
P242V0; (+ P40V0; (SQUARE ROOT,24.2.64); ( -ve argument already rejected ));
   V0=0.46429/2;
   FIX; DUP; SHLD-1; PERM;
J2<Z; 
   SHL-1;
2; 
   SHA-3; DUP; SHA+1; V0; +; (X0,M);
   DUPD;÷; +; (X1,M);
   DUPD;÷; REV; SHA-2; +; (X2,M);
   DUP; PERM;÷; +; (X3);
   REV; NOT; NEG; FLOAT;
   EXIT1;
   
P243V8; (+ P48V8; (ln ENH-FGH); (argument in N1); );
   V0=Q2/1/AV8;
   V1=-0.693147180559945/0;
   V2=+0.353553390593274/0;
   V3=+1.541342602720874/2;
   V4=+0.612053805720620/4;
   V5=+3.089532445011031/2;
   V6=-1.921406891324693/3;
   V7=+0.286369944871851/1;
   V8=B30463/15;
   FIX; SHA40; V1; DUP; SHA-8; PERM;×; -; REV; SHA-1;
   V2; DUPD; -; PERM; +;÷; DUP; SHA-1; DUP;×; DUP;
   V3; -; V4; REV;÷; V5; +; -; V6; REV;÷; V7; +;×;
   SHA-5; +; SET7; FLOAT; EXIT1;
   
P244V8; ( used WITH TEST i.e. Program Testing option);
   (if V0 is non-zero - contains the last label number)
   (outputs V0 and the assignment value in octal)
   V0 =0; (no tracing by default)
   V1 =B 1010101001010110;
   V2 =B 2020202000000020;
   V3 =B 2020202020202020;
   V4 =Q 0/AV5/AV8;
JP233V; 
   
   V0; J1±Z; EXIT1; (fastest possible exit when not tracing);
1; 
   DUP; V0; DUP; NOT; NEG; =V0;
   SHLD+3; V1; REV; FRB; V2; OR; =V6; (only 3 spaces not 4 as documented);
   ZERO; SHLD+24; V3; DUP; SHL-1; CAB; FRB; OR; =V7; (2nd to 5th digits );
   SHL-27; V3; DUP; SHL-1; CAB; FRB; OR; SHL+6; (6th 7th and 8th digits);
   NOT; NEG; NOT; NEG; =V8; (and a carriage return);
   SETB30; =V5; V4; SET8; OUT;
   VR; EXIT1; (a big line number may have set overflow);
   
P247V0; (+P209 but for 2-dimenions only );
   (+N1; arraybox );
   DUP; SHL-16; SET1; +; =RM3; (hux); (add 1 to skip size in DV);
   SET-2; =+M2; (+reset M2 ); (indices on TOS)
   SET 1; Y0M2;×D; CONT; Y1M2; Y0M3;×D; CONT; +;
   +; (i × 1 + j × delta j + logical origin); (need to mask M-part*)
   EXIT1;
   
P248V3; (+grand close );
   V0 =Q0/AV1/AV3;
   V1 =B30;
   V2 =B 4651565163504544;
   V3 =B 0045564463002002;
   V0; SET8; OUT;
   ZERO; =V1; V3; SETB75; OR; =V3; (+ convert to end message );
   V0; SET8; OUT;
   ZERO; OUT; ( should we exit instead );
   EXIT1;
   
P287; ( N1 contains amount required HUX SPACE
   If insufficient space then FAIL)
JSP298; 
   REV; -; DUP;
J1<Z;
   
   ERASE; EXIT1;
1; 
   ABS; SET7;
J109P299;
   
   
P298; ( The Amount of Core Storage Left  - for use by a code proc at user level
   up to the user to fail or find a way round HUX SPACE);
   SET AZ0; Z1; -; SETAY0; M2; +; -;
   (+ Z1 holds the amount of Z-store consumed - initialised as 2 );
   EXIT1;
(+ routines which we think were originally included in library A0 );
(+ but which are included here so as to avoid bulk in the text );
(+ for ease of diagnostics );
(+ at present they have interim implementations -- usually leading to execution error );
(+ These next 10 routines are documented as available to code precedures. );
   
P299V27; ( Catastrophic Failure Routine );
   V0 =B1212121212121212;
   V1 =B7777777777202020;
   V2 =B2020202020202020;
   V4 =B0253415447575400; ( P [C] KALGOL );
   V5 =B6462414345007777; ( P TRACE [DD]);
   V6 =B0037373737373717; ( P ..../ );
   V7 =B3737373737373702; ( P ....[C] );
   V8 =B4641515400202020; ( P FAIL [_] 000 );
   V9 =B0051560077777777; ( P [_] IN [*DDDD] );
   V10 =B3737377777777777; ( P ... [5D] );
   V11 =B7777777777777777;
   V13 =B7777777777777777;
   V14 =B7777777777777777;
   V15 =B0266415465450077; ( P [C]VALUE [*D] );
   V16 =B3737373737373737; ( P ........ );
   V17 =B3737373737373737; ( P ........ );
   V18 =B0057436441547702; ( P [_] OCTAL [DC] );
   V19 =B4321742007214024; ( terminated by operator in ABS );
   V20 =B0620603704007636;
   V21 =B0322223606415420;
   V22 =B0720603706416635;
   V23 =B4321540202200236; ( P290 not yet implemented );
   V24 =B1463207147437052;
   V25 =B1631705614432461;
   V26 =B1243105214634452;
   V27 =B1231677777777640;
J99EN; 
   
1; 
   V0; REV; FRB; V8; OR; =V8; ( failure number left in N1 );
J99EN; 
   ZERO; SHLD+24; ( value left in N2 );
   V2; DUP; SHL-1; CAB; FRB; OR; =V16;
   V2; DUP; SHL-1; CAB; SHL-24; FRB; OR; =V17;
J99EN; 
   SETAV10; =RM15; SET4; =C15; ( output buffer );
JS20P700; 
   ( print failure string );
99; 
   SETB30; =V3; ( always output on stream 30);
   Y0M1; SHL-32; ( level of caller - should be last level, but do not know where to find it );
   DUP; J10±Z; ERASE; Y-1M2; =Q15; Y0M15; SHL-32;
10; 
   V0; REV; FRB; V2; OR; SHL+6; SETB17; OR; =V6;
   Z0; ( last label passed );
   V0; REV; FRB; V2; OR; SHL+6; SETB02; OR; =V7;
   SETAV18; =RM15; SETAV3; =I15; Q15; SET8; OUT;
   V3P248; SETB400; OR; =V3P248; ( ENDS 4 after failure );
JP248; 
   ( Grand close );
100; 
   (even restart );
J101NEN; 
   ZERO;
101; 
   SETAV19; REV; SET1;
J1;
   
109; 
   (failure for facilities not yet implemented);
   (enter with failure value in N2, routine number in N1);
   ZERO; REV; ( entry point 0 by default -- printed as the value );
108; 
   (enter with failure value in N3, routine number - 290 in N1 entry label number in N2);
   SHL+8; V23; +; =V23; ( put in routine number );
   SETAV23; PERM;
J1;
   
   
P297; ( Next Input/Output Buffer );
   ZERO; SET7;
J109P299;
   
   
P290; ( Device Directory );
   ZERO; ZERO;
J109P299;
   
2; 
   SET2; ZERO;
J109P299;
   
   
P289V6; ( Input/Output Table Addressing );
   ZERO; SET-247;
J109P299;
   
(+ Holdsworth specific versions );
   
P700V255; (make string of ABS into KDF9 chars);
   V0 =B 0020000000000000;
   V1 =B 0021000000000000;
   V2 =B 0022000000000000;
   V3 =B 0023000000000000;
   V4 =B 0024000000000000;
   V5 =B 0025000000000000;
   V6 =B 0026000000000000;
   V7 =B 0027000000000000;
   V8 =B 0030000000000000;
   V9 =B 0031000000000000;
   V12 =B 0041000000000000;
   V13 =B 0042000000000000;
   V14 =B 0043000000000000;
   V15 =B 0044000000000000;
   V16 =B 0045000000000000;
   V17 =B 0046000000000000;
   V18 =B 0047000000000000;
   V19 =B 0050000000000000;
   V20 =B 0051000000000000;
   V21 =B 0052000000000000;
   V22 =B 0053000000000000;
   V23 =B 0054000000000000;
   V24 =B 0055000000000000;
   V25 =B 0056000000000000;
   V26 =B 0057000000000000;
   V27 =B 0060000000000000;
   V28 =B 0061000000000000;
   V29 =B 0062000000000000;
   V30 =B 0063000000000000;
   V31 =B 0064000000000000;
   V32 =B 0065000000000000;
   V33 =B 0066000000000000;
   V34 =B 0067000000000000;
   V35 =B 0070000000000000;
   V36 =B 0071000000000000;
   V37 =B 0072000000000000;
   V38 =B 0041000000000000;
   V39 =B 0042000000000000;
   V40 =B 0043000000000002;
   V41 =B 0044000000000000;
   V42 =B 0045000000000000;
   V43 =B 0046000000000000;
   V44 =B 0047000000000000;
   V45 =B 0050000000000000;
   V46 =B 0051000000000000;
   V47 =B 0052000000000000;
   V48 =B 0053000000000000;
   V49 =B 0054000000000000;
   V50 =B 0055000000000000;
   V51 =B 0056000000000000;
   V52 =B 0057000000000000;
   V53 =B 0060000000000000;
   V54 =B 0061000000000000;
   V55 =B 0062000000000000;
   V56 =B 0063000000000000;
   V57 =B 0064000000000000;
   V58 =B 0065000000000000;
   V59 =B 0066000000000000;
   V60 =B 0067000000000000;
   V61 =B 0070000000000000;
   V62 =B 0071000000000000;
   V63 =B 0072000000000000;
   V255 =B 0000000000000000;
   V174 =B 0004000000000000;
   V160 =B 0002000000000000;
   V11 =B 0037000000000000;
   V132 =B 0012000000000000;
   V137 =B 1200000000000000;
   V142 =B 0000000000000000;
   V177 =B 5565546400000000;
   V148 =B 0013000000000000;
   V152 =B 0034000000000000;
   V153 =B 1300000000000000;
   V158 =B 0000000000000000;
   V161 =B 0017000000000000;
   V162 =B 0011000000000000;
   V166 =B 0016000000000000;
   V185 =B 0010000000000000;
   V193 =B 0035000000000000;
   V209 =B 0036000000000000;
   V10 =B 0033000000000000; (subscript 10)
   V190 =B 0077000000000000;
   V192 =B 4154475754000000; (ALGOL)
   V240 =B 4570516400000000; (EXIT)
   V176 =B 5344463100000000; (KDF9)
   V147 =B 4156440000000000; (and)
   V72 =B 4162624171000000; (array)
   V140 =B 4245475156000000; (begin)
   V67 =B 4257575445415600; (boolean)
   V128 =B 4357555545566400; (comment)
   V145 =B 4451660000000000; (div)
   V214 =B 4457000000000000; (do)
   V165 =B 4554634500000000; (else)
   V156 =B 4556440000000000; (end)
   V195 =B 4561660000000000; (eqv)
   V205 =B 4641546345000000; (false)
   V134 =B 4657620000000000; (for)
   V178 =B 4745000000000000; (ge)
   V136 =B 4757645700000000; (goto)
   V194 =B 4764000000000000; (gt)
   V133 =B 5146000000000000; (if)
   V179 =B 5155600000000000; (imp)
   V66 =B 5156644547456200; (integer)
   V121 =B 5441424554000000; (label)
   V146 =B 5445000000000000; (le)
   V208 =B 5451426241627100; (library)
   V130 =B 5464000000000000; (lt)
   V210 =B 5645000000000000; (ne)
   V131 =B 5657640000000000; (not)
   V163 =B 5762000000000000; (or)
   V143 =B 5767560000000000; (own)
   V80 =B 6062574345446562; (procedure)
   V141 =B 6100000000000001; (q -- marker for special symbol)
   V65 =B 6245415400000000; (real)
   V224 =B 6345475545566400; (segment)
   V182 =B 6364456000000000; (step)
   V122 =B 6364625156470000; (string)
   V88 =B 6367516443500000; (switch)
   V149 =B 6450455600000000; (then)
   V221 =B 6462654500000000; (true)
   V157 =B 6500000000000000; (u)
   V198 =B 6556645154000000; (until)
   V129 =B 6560000000000000; (up)
   V159 =B 6641546545000000; (value)
   V150 =B 6750515445000000; (while)
   =RM15; (+ M15 addresses the current output word - need to subtract 1 at R22)
21; 
   SET100; =C15; (+ C15 the length of the buffer );
20; 
   CI0TOQ13; (+ C13 is the shift used to insert the most recent output character  I13 NZ when doing layout chars );
22; 
   M-I15; ( side entry from P288 (writetext));
   =RM14; (+ M14 addresses the current input word );
   SET-40; =C14; (+ C14 is the shift used to extract the current ABS, ignore initial quote );
1; 
J10C15Z;
   (+ ignore tail of overlength string );
   M0M14; SET8; =+C14; SHLC14; SETB377; AND; (+ next ABS );
   SETB235;
J4=;
   =M13; (+ stop if closing quote );
   V0M13; DUP; SHL-42;
J2=Z;
   (+ j if single char symbol );
   DUP; SETB77; AND; J9±Z; (+ bottom char set if special symbol, i.e. proc or string quote );
   SET7; SHLD+42;
6; 
J5C13NZ;
   
   ZERO; =M0M15QN; (+ initialise next output word );
   SET48; =C13;
5; 
   DUP; SHL-42; DUP;
J7=Z;
   (+ one char in N1 OR ZERO );
   SET-6; =+C13; SHLC13; M0M15; OR; =M0M15; ZERO;
7; 
   ERASE; SHLD+6; DUP; J6±Z;
   ERASE; ERASE; SET7; SHC-12; (+ end of sym, put in last quote );
2; 
   I13; J12±Z; (+ use char in bottom of word for layout stuff );
   SHL-36;
12; 
J3C13NZ;
   (+ J if current output not full );
   ZERO; =M0M15QN; (+ initialise next output word );
   SET48; =C13;
3; 
   SETB77; AND; (+ only needed for layout chars );
   SET2;
J13=;
   (+ treat newline specially to put always at the end of a word )
   SET-6; =+C13; SHLC13;
14; 
   M0M15; OR; =M0M15;
11; 
J1C14NZ;
   M+I14; SET-48; =C14; 
J1; 
   
4; 
   ERASE; I13; I0TOQ13; J11±Z; (+ finish if not doing layout characters );
   ZERO; NOT; SHLC13; NOT; M0M15; OR; =M0M15; (+ pad last word with dummies );
10; 
   EXIT1;
8; 
   SETB6245; SHC+12; V80; SET7; SHLD-6; ERASE;
J6;
   
9; 
   (special treatment for newline proc and string quote);
   V160;
J13=;
   (+ newline );
   V80; NEV;
J8=Z;
   (+ procedure -- the only ABS with more than 7 characters );
   I13=+1;
J11;
   (+ set layout marker and keep going );
13; 
   ERASE; (+ ensure carriage return is at the end of a word )
   ZERO; NOT; SHLC13;
   NOT; SETB75; -; (+ convert last dummy to cr );
   C0TOQ13;
J14;
   
   
P2V0; Y2M2; ABSF; EXIT1;
P0;
   
P3V0; Y2M2; ZERO; SIGNF; EXIT1;
P0;
   
P4V0; V0=B4323406615617715; Y2M2; DUP;
J1<Z;
   
   DUP;
J2=Z;
   
JSP242; 
   
2; 
   EXIT1;
1; 
   SETAV0; REV; SET1;
JP299;
   
P0;
   
P5V1; V0=B4323405614716400; Y2M2; DUP; J4±Z;
   EXIT1;
4; 
   DUP; FIX; REV; ERASE; DUP;
   SET37; -;
J5>Z;
   
   SET19; +;
J1_>Z;
   
   EXIT1;
1; 
JSP240;
   
   EXIT1;
5; 
   ERASE; SETAV0; REV; SET1;
JP299;
   
P0;
   
P6V3; Y2M2; DUP; J1±Z;
3; 
   ERASE; V2; EXIT1;
1; 
   DUP; FIX; REV; ERASE; DUP;
   SET37; -;
J2>Z;
   
   SET19; +;
J3<Z;
   
   V0; REV; -F;
JSP240;
   
   EXIT1;
2; 
   ERASE; SETAV1; REV; SET1;
JP299;
   
   V0=F+1.570796326795; V1=B4322406416116400; V2=F+1.0;
P0;
   
P7V17; V0=F0.019042127887; V1=F0.019042129240; V2=F0.038082414120; V3=F0.076666493927; V4=F0.121226383896;
   V5=F0.725940450930; (V6-V10usedforb); V11=Q6/1/0; V12=Q4/1/0; (V13usedfora); V14=F1.0; V15=F0.5;
   V16=B4322306712034446; V17=B1471640000000000; V14; =V13; (stolenfromP51inWalgol); Y2M2;
   DUP; DUP;×F; V14; +F;
JSP242; 
   
   =V6; V12; =Q15;
2; 
   V13; V6M15; +F; V15;×F;
   =V13; V13; V6M15Q;×F;
JSP242;
   
   =V6M15;
J2C15NZ;
   
   V11; =Q15; V0M15Q; ZERO; REV;
   FIX; FLOATD;
1; 
   V0M15; V5M15Q;×+F;
J1C15NZ;
   
   ROUNDF;÷F; EXIT1;
P0;
   
P8V1; V0=B4523046347200000; Y2M2; DUP;
J1_<Z;
   
JSP243; 
   
   EXIT1;
1; 
   SETAV0; REV; SET1;
JP299;
   
P0;
   
P9V0; Y2M2;
JSP238;
   
   EXIT1;
P0;
   
P10V1; V0=B4322506316227052; V1=B1571640000000000; Y2M2; FIX; DUP;
   SET39; -; DUP;
J3>Z;
   
   =C3;
J1>Z;
   
J2<Z; 
   
   ZERO; EXIT1;
2; 
   SET-1; EXIT1;
1; 
   SET-8; =+C3; SHLC3; NC3; SHLC3;
   NC3; SHAC3; EXIT1;
3; 
   ERASE; FLOAT; SETAV0; REV; SET1;
JSP299; 
   
P0;
   
P11V0; Y2M2;
JSP293;
   
   EXIT1; P293V40; (Open); V0=Q0/AV1/AV40; (+V-storesarepapertapeinputbuffer); SET20; NEV;
J1=Z; 
   
   EXIT1; (+interimversiononlydevs20and30allowed);
1; 
   V0; =Q15; SET2; SET5; OUT;
   =C15; (+Maxamountofdatais320chars); Q15; =V0;
2; 
   PREQ15; PARQ15; I15; =RM15; SET-48;
   =C15; Q15; =V0P295; EXIT1; P295V9;
   (GeneralCharacterandBasicSymbolHandling); V3=0; (+shiftindicator); V4=B0000023064507246; (blank,pound,semicolon,±,star,comma000012230322216246); V5=B0000523060350413; (blank,subten,semicolon,+,-,dot000012230301321013); V6=-1; (retainedbasicsymbol); V7=QB134601/B104631/B101302;
   (colon,uparrow,lhsq,rhsq,lt,gt); V8=QB121261/B110604/B112000; (=,times,idiv,bra,ket,000); V9=QB106616/B111235/B131000; (C15=0forLH-quote,1forstar,2for_<,3forRH-quote,4for_>);
10; 
   V6; REV; =V6;
J91<Z;
   
   (+retainbasicsymbol); SET10; SET5;
J109P299;
   
   (+errorifusedtwice);
4; 
   (+initialisebasicsymbolfetch);
3; 
   (+initialisecharacterfetch); ERASE; (+assumedv=20); V0; DUP;
JP299=Z;
   
   =Q13; EXIT1;
94; 
   V0P293; =Q15;
JS2P293;
   
   V0; =Q13;
5; 
J52C13NZ;
   
   (+fetchcharacter); SETAV40P293; M13; -;
J94=Z;
   
   (endofbuffer); M+I13; SET-48; =C13; (movetonextword);
52; 
   SET6; =+C13; M0M13; SHLC13; SETB77;
   AND;
91; 
   EXIT1;
8; 
   (+freezebasicsymbolfetch);
7; 
   (+freezecharacterfetch); Q13; =V0; EXIT1;
85; 
   =V3; (storeshiftcharandfetchanothersymbol);
6; 
   (+fetchbasicsymbol-onlylettersanddigits+afewothers); V6; ZERO; NOT; =V6; DUP;
J92_>Z; 
   
   ERASE;
JS5;
   
   DUP; SHL-5;
J86=Z;
   
   SETB25; -; SET26; V3; AND;
   +; EXIT2; (letter);
86; 
   DUP; J87±Z;
   ERASE; SETB236; EXIT2;
87; 
   DUP; NOT; NEG; SHL-4;
J88=Z;
   
   (Jifnot/ordigitetc); DUP; SETB32; -; DUP; SHL+3;
   =C15;
J89<Z;
   
   (Jif/ordigit); ERASE;
J70C15Z;
   
   (Jifunderline); V3; =M15; (shiftindicator); V5M15; SHLC15; SHL-40;
   DUP;
J96=Z;
   
   EXIT2; (charsbeyonddigits);
89; 
   V3; J93±Z;
   SETB20; -; DUP;
J92_>Z;
   
   (jIFdigit); ERASE; SETB241; (SLASH);
92; 
   EXIT2;
93; 
   (shifteddigit); ERASE; V8; V7; SHLDC15; ERASE;
   SETB377; AND; EXIT2;
88; 
   SHC-1; DUP; NEG; NOT; J84±Z;
   ERASE; SETB240; EXIT2; (carriagereturn);
84; 
   STR; NOT; REV; SET3; NEV;
J85=Z; 
   
   (SHIFTCHAR);
71; 
   NC15; ERASE; (C15=0forLH-quote,1forstar,2for_<,3forRH-quote,4for_>); C15; SHL+3; =C15; V9;
   SHLC15; SHL-40; EXIT2;
70; 
JS6;
   
J96; 
   
   C0TOQ15; SETB211;
J71=;
   
   DC15; DUP;
J71=Z;
   
   DC15; SETB202;
J71=;
   
   DC15; SETB231;
J71=;
   
   DC15; SETB302;
J71=;
   
96; 
   ERASE; SETB216; EXIT2; (+fetchbasicsymbol-toofancy-returnasterisk); (SET6; SET5;
J109P299;
   earlierfailureresponse);
12; 
   ERASE; (+initialisebasicsymboloutput-ignoredevicenumber); SETB177615; =V1; (+openingstringquote); M2TOQ8; (+keepstackpointer); EXIT1;
   V2=QB117256/B120240/0; (+space,tab,page**newline**);
18; 
   SHL+3; =C8; (+outputeditingsymbol); V2; SHLC8; SHL-40;
   (+dropthroughtooutputbasicsymbol);
14; 
   V1; DUP; (+outputbasicsymbol); NOT; SHL-40;
J141=Z;
   
   (+Jifwordnotfull); =Y0M2Q; 
   ZERO; NOT;
141; 
   SHL+8; OR; =V1; C0TOQ8; (+mysteryuseofJ116C8ZinP291); EXIT1;
16; 
   SETB235;
JS14;
   
   (+freezebasicsymboloutput); V1; NOT; ZERO;
161; 
   ERASE; ZERO; SHLD+8; DUP;
J161=Z;
   
   (+removedummiesatstartofword); SHLD-8; ERASE; NOT; =Y0M2Q; 
   (+partialwordtobuffer); M8;
   SETAY0; +; (+closingstringquotetousewritetext);
JS2P288;
   
   M8TOQ2; (+putthestackpointerback); VR; (+P291(write)sometimesleavesoverflowset); EXIT1; (+stolenfromKQX--usedinformat);
20; 
   ERASE;
1; 
   (FetchBSfromstringaddressinM14);
J189C13NZ;
   
   M0M14Q; =V8; SET6; =C13;
189; 
   V8; ZERO; SHLD+8; REV; =V8;
   DC13; SETB236;
J20=;
   
   SETB240;
J20=;
   
   SETB256;
J20=;
   
   EXIT1; (+unimplemented);
9; 
   SET9; SET5;
J108P299;
   
   (+retaincharacter);
11; 
   SET11; SET5;
J108P299;
   
   (+initialisecharacteroutput);
13; 
   SET13; SET5;
J108P299;
   
   (+outputcharacter);
15; 
   ZERO; SET15; SET5;
J108P299;
   
   (+freezecharacteroutput);
116; 
   SET116; SET5;
J108P299;
   
   (+outputcharacterswithautomaticcasemanagement); P288V41; (writetext--alsousedinR16P295); V0=Q0/1/AV0; (bufferforpartialline); ERASE; (ignoredevicenumberfornow);
2; 
   SETAY0; M2; +; DUP; PERM;
   NOT; NEG; =RM15; CI0TOQ13; SET100;
   =C15; (P700setupmissedoutbysideentry); V0; =Q14;
J10C14Z;
   
   (Jifthereisnoleft-overpartialline);
11; 
   M0M14Q; =M0M15Q;
J11C14NZ;
   
   (copyitatstartofoutputarea); M0M14N; NOT; (turndummiestozeros); DUP; SHL+42; J9±Z;
   (Jiflastsavedwordisfull); SETB77;
8; 
   DUPD; SET+6; =+C13; (findpositionofnextfreecharslot); SHLC13; AND;
J8=Z; 
   
   (Jifcharacterisdummy-1stcharisneverdummy); REV; ZERO; NOT; SHLC13; NEV;
   (invertthecharactersbacktonormalleavingtheblanks); M-I15; =M0M15Q; (andputthewordbackinthebuffer);
9; 
   ERASE;
10; 
JS22P700;
   
   (convertABStochars); SETAV0; =RM14; SETB102; DUP; (leave1inthenestforuselater); M0M15;
   NEV; SETB76; AND;
J3=Z;
   
   (N1=Zforanypaperfeed); =Y0M2; 
   (ifwescanbacktothisthereisnonewline-01canneverbeoutputbyP700); I15=-1; SET40; =C15; (forscanningbackwardstofindlastcr); M0M15Q;
4; 
   =M0M14QN; M0M15Q;
J6C15Z;
   
   DUP; SETB76; AND; NEG; NOT;
   NEG; NOT; J4±Z;
   NC14; I14=-1; (Readytounstackthesavedwords); M-I15; (lastwordtobeoutput); SETB102; NEV;
   (nonewlineinoutputstring);
3; 
   Q14; =V0; (stackofoutputheldovertonewline); SETB30; =Y0M2; 
   (alwaysoutputonstream30fornow); REV;
   =I15; (startofoutputkeptfromlabel2);
J12=Z;
   
   (jumpiftherewasnonewlinechar); C0TOQ15; Q15; SET8; OUT;
12; 
   EXIT1;
6; 
   M0M15; SET3; SETB177410;
J108P299;
   
   (failtoomuchoutputwithoutcr);
P0;
   
P12V0; Y2M2;
JSP292;
   
   EXIT1; (+P292ismissingfromKQX9101,soitusedtobeinruntime2.txt); P292V0; (Close); V0=QB106640/B116400/0; (_[_[c_]_]); ERASE; (interimversiononlydevs20and30actuallywork); V0P288;
   SHL-32;
J9=Z;
   
   (Jifnoincompletelinetoprint); SETAV0;
J2P288;
   
   (outputnewlinetoforceprinting);
9; 
   EXIT1;
21; 
   SET21; SET2;
J109P299;
   
   (don*tknowwhyweneedthis-perhapswedon*t);
P0;
   
P13V0; Y2M2;
JSP294;
   
   EXIT1; P294V12; (read); V2=B3244647411363215; V3=B1067311107601054; V4=B2372617635665123;
   V5=B2567106670407501; V6=B6625327150150035; V8=B4323345211424636; V9=0; V10=0;
   V11=B4100000000112235; V12=Q2/1/AV8; DUP; =V10;
JS4P295;
   
   CI0TOQ7; CI0TOQ8; SET10; ZERO;
J1NV;
   
   NOT;
1; 
   =V7; Q0TOQ9; ZERO; NOT; REV;
   I14; =M7;
J8;
   
*2; 
   DC9;
3; 
   DUPD;×D; J5±Z;
   REV; ERASE;
J2C9NZS;
   
4; 
   DUP; M8; +;
J7NV;
   
   DC9;
5; 
   DC7;
J24C8NZ;
   
6; 
   SET1; =+C9; REV;
7; 
   PERM; ERASE; M+I9;
8; 
JS6P295;
   
J34; 
   
   M7; I14; -; J35±Z;
23; 
   DUPD; =M8; -;
J10_>Z;
   
   REV; DUP;
J6C7NZ;
   
   I7=-1;
J9C8NZ;
   
   M8;
J6=Z;
   
9; 
J3_>Z;
   
   NOT; C0TOQ9;
J4;
   
10; 
   DUP; M8; -; NOT; DUP;
J15>Z; 
   
   I7=-1;
J25C8NZ;
   
J14=Z; 
   
   REV; DUP;
J11_>Z;
   
J13C9Z; 
   
   NOT;
13; 
   NEG;
11; 
   I8;
J12_>Z;
   
   NEG;
12; 
   I0TOQ8; =V0; Q9; =V1; Q0TOQ9;
   DC8; ZERO; NOT; REV; C0TOQ7;
J8; 
   
14; 
   I9; J26±Z;
   I9=+1;
J8;
   
15; 
   SET182;
J17=;
   
   SET198; J18±;
   ERASE; I8; I8=-1;
16; 
   J27±Z;
   I7=-1; REV; DUP;
J28_>Z;
   
   REV;
J8;
   
17; 
   ERASE; I8; I8=+1;
J16;
   
18; 
   ERASE; I7;
J8=Z;
   
   M8; SETB236;
J34=;
   
   SETB240;
J34=;
   
   SETB256;
J34=;
   
   ERASE;
36; 
   ERASE; DUP;
J19_>Z;
   
J29C9Z; 
   
   NOT;
19; 
   M9; I9; +; NEG; NOT;
J30=Z; 
   
   I8;
J20_>Z;
   
   NEG;
20; 
J21C8Z;
   
   V1; =Q9; =+C9; V0;
21; 
   C9; M9; -; M8;
JS10P295;
   
JS8P295; 
   
22; 
   V2;×D; SHAD+2; DUPD; ROUND;
   DUP; =Q8; ZERO; REV; -D;
   CONT; DUP; DUP;×; SHA-7;
   DUP; V3;×; V4; +;
   REV; V5; +; V6; REV;
   ÷; +; REV; SHA-4; DUPD;
   +; PERM; -; SHA+1;÷;
   REV; DUP; ZERO; FLOAT; FIX;
   NEG; =C9; ERASE; SHLC9;×;
   Q8; SET48; +; C9; -;
   REV; DUP;
J41=Z;
   
   ZERO; FLOAT; STR; PERM; ZERO;
   SHAD+8; CAB; +; SHAD-8; DUP;
J42_>Z; 
   
   ERASE;
41; 
   ERASE; ERASE; ZERO;
J43;
   
42; 
   CONT; REV; CONT;
43; 
J33V;
   
   V7; SHA+48; ERASE; EXIT1;
24; 
   ERASE; SET1;
31; 
   CAB; ERASE;
32; 
   V12; PERM; V10;
JS39;
   
J37; 
   
JS39; 
   
J38; 
   
J36; 
   
37; 
   DUP;
38; 
   SHL+8; OR; SHL+8; OR; SHL+16;
   V11; OR; =V9;
JP299;
   
25; 
   ERASE; ERASE; SET2;
J32;
   
26; 
   ERASE; SET3;
J32;
   
27; 
   ERASE; SET4;
J32;
   
28; 
   SET5;
J31;
   
29; 
   SET6;
J32;
   
30; 
   SET7;
J32;
   
33; 
   SET8;
J32;
   
34; 
   ERASE;
J8;
   
35; 
   M7; NOT; NEG; =I14; I7;
J23=Z; 
   
   =M8;
J36;
   
39; 
   SET10;÷I; REV; DUP; J40±Z;
   ERASE; SETB236; EXIT1;
40; 
   EXIT2;
P0;
   
P14V0; Y2M2; (readb00llan);
JS4P295;
   
   ZERO;
J2;
   
1; 
   SETB315; NEV;
J3=Z;
   
   DUP;
4; 
   ERASE;
2; 
JS6P295;
   
J4; 
   
   SETB335; J1±;
   ERASE; NOT;
3; 
JS8P295;
   
   EXIT1;
P0;
   
P15V0; Y4M2; Y3M2; Y2M2;
JSP291;
   
   EXIT1; P291V31; (PROCEDUREWRITE); V1=B1212121212121212; V2=B2020202020202020; V3=B2030446722743250;
   (1.024TO1I.P.); V4=B175/8; (1000/1024TO1I,P.); V5=B1463146314631463; (.8TO1I.P.); V6=B2400000000000000; (10/8TO1I.P.); V7=Q0/3/3; (INITIALSPACES/SIGN/EXPSIGN); V8=B0013573716200001;
   (FORMAT/DS/ZS/DPH/APM/; /C/NDP); V9=B0314631463146315; (.1); V10=B0024365605075341; (.01); V11=B0000150667056544; (.0001); V12=B0000000005274617; (.00000001); V13=B12;
   (10); V14=B144; (100); V15=B23420; (10000); V16=B575360400; (100000000); V20=Q12/11/1; (S/F/E); V25=B0000000377777775;
   V26=B0000000177777777; V29=B4323606713434452; V30=B4720000000000000;
101; 
   PERM;
102; 
   =V21;
103; 
   =V22; DUP; =V31;
JS12P295;
   
   ZERO; =V28; V21; ZERO; SHLD+24;
   REV; ZERO; SHLD+4; =C10; ZERO;
   SHLD+2; =I10; ZERO; SHLD+5; NEG;
   =C7; ZERO; SHLD+4; =C11; ZERO;
   SHLD+2; =M10; ZERO; SHLD+4; =M7;
   SHC+3; =I7; DUP; ZERO; REV;
   SHLDC7; BITS; NEG; NOT; =I11;
   BITS; =M11; V22; I13=+1; DUP;
J5_>Z; 
   
   NEGF; I13=-1; I10; J5±Z;
   SET2;
JS100;
   
1; 
JS80;
   
70; 
   M7; SHC-2;
J95<Z;
   
   I7; ZERO; =V27; J4±Z;
   C10; I10;
J2=Z;
   
   NOT; NEG;
2; 
   M10;
J3=Z;
   
   SET4; +;
3; 
   M7; SHC-1; SHL-47; +; M7;
   SETB4; AND; SHL-2; +; CAB;
   DUP; SHL+23; SET23; FLOAT; FIX;
   REV; ERASE; CAB; +; V31P295;
   SHL-24; C9; -; +; =V27;
   REV;
4; 
   I7; NOT; =C13; V31P295; SHL-24;
   C9; -;
J115=Z;
   
   SET2;
JS18P295;
   
115; 
   V20; =Q11; V7; =Q10; REV;
   ERASE; V8; ZERO; SHLD+24; PERM;
   ZERO; SHLD+5; =M7; ZERO; SHLD+3;
   =I7; SHL-32; =C7; SET11; =M13;
J7; 
   
5; 
   NC7;
JS80;
   
   C11; NEG; NOT; =M13; M10;
   J7±Z;
   M14; M11; -;
J69_>Z;
   
   M14; I11; +; DUP; =M15;
   M13; REV; -;
J7<Z;
   
   M15TOQ13; M13;
J7_>Z;
   
   M13; NOT; J6±Z;
   SET5; SHA+43; M13; NOT; NEG;
   =M13; ZERO; NOT; =TR;
J10;
   
6; 
   ERASE; ZERO;
J12;
   
7; 
   SET4; =RC15; ZERO; NOT; NEG;
   SHC-2; M13;
8; 
   SHC-1; DUP;
J9_>Z;
   
   REV; V9M15;×; REV;
9; 
   M+I15; DC15;
J8C15NZ;
   
   ERASE; SHA-4;
10; 
   +;
11; 
   DUP; SHL-43; SET10; -;
J113<Z;
   
   STR; SET10;÷D; M+I14; M10;
   J12±Z;
   M13; NOT; NEG; C11; NEV;
J110=Z; 
   
J110TR; 
   
   SET1; =+M13;
110; 
   M14; M11; -;
J71_>Z;
   
12; 
   ZERO; DUP; =TR; NOT; NEG;
   M13; SET4; =RC15;
13; 
   SHC-1; DUP;
J14_>Z;
   
   REV; V13M15;×D; CONT; REV;
14; 
   M+I15; DC15;
J13C15NZ;
   
   ERASE;×D; SHAD+4; REV; ERASE;
   DUP; =V0;
JS90;
   
   =V23; =V24; I10; NEG; NOT;
   SHL-1; J15±Z;
   SETB20; M7; OR; =M7;
15; 
   I11; M11; +; C11; -;
   ZERO; =RM15; I11; NOT; NEG;
   NOT; NEG; =M13;
J18_<Z;
   
   M14; C11; -; NOT; NEG;
   DUP;
J32<Z;
   
   I11; +;
72; 
   =C15;
18; 
   SET8; =RC11; M+I11; SET24; =C13;
   SHL+24; 
*16; 
   DUP;
J17<Z;
   
   SHL+1; DC13;
J16C13NZS;
   
   ERASE; SET3;
J74;
   
113; 
J12NTR;
   
J6; 
   
32; 
   I11; +; DUP;
J72_>Z;
   
   ERASE; ZERO;
J72;
   
17; 
   DC13; SHL+1;
J73C13Z;
   
   C0TOQ14; SET8; =RC12;
19; 
   DUP;
J21<Z;
   
98; 
   SETB76; SHC-6;
J26;
   
22; 
   SETB77; SHC-6;
26; 
   V17M12; SHLD+6; DC12; =V17M12; ERASE;
J24C12NZ; 
   
   M+I12; SET8; =C12;
24; 
   DC14;
29; 
   DC13; SHL+1;
J19C13NZ;
   
20; 
   M11;
J28=Z;
   
   V23M11; M-I11; NOT;
J20=Z;
   
   ERASE; SET4;
J74;
   
21; 
   M13;
J107=Z;
   
   M13; NEG; NOT; =M13;
107; 
J31C15Z;
   
   DC15; M13; SET2; -;
J98_>Z;
   
   ZERO;
J26;
   
31; 
   ZERO; V23M11; DC11; SHAD-6; =V23M11;
J25C11NZ; 
   
   M-I11; SET8; =C11;
25; 
   SHL+1; M7; SETB10; AND; J27±Z;
   SETB77; SHL+42; J26±;
   ERASE; ZERO;
J26;
   
27; 
   SETB77; SHL+42; J30±;
   M13;
J96=Z;
   
   ERASE; ZERO;
J26;
   
96; 
   ERASE; M7; SHL-4;
J98=Z;
   
   M+I15;
J29;
   
30; 
   M7; SHL-4;
J26=Z;
   
   M15;
J26=Z;
   
   ERASE; ERASE; SET5;
J74;
   
28; 
   ERASE; M15; DUP; =+C10; NEG;
   =+C7; I10;
J35=Z;
   
   I13;
J34<Z;
   
   I10; SHC-1;
J33<Z;
   
   SETB236;
J36;
   
33; 
   SETB301;
J36;
   
34; 
   SETB321;
J36;
   
35; 
   ZERO; NOT;
36; 
   =I10; NC14; C14; C7; -;
   M7; SHC-3;
J67_>Z;
   
   SETB13; =M13;
J77_<Z;
   
68; 
   M10;
J75=Z;
   
   V0;
J64=Z;
   
   C0TOQ13; M14; DUP;
J37_>Z;
   
   NEG; DC13;
37; 
JS90;
   
   NOT; J78±Z;
   ZERO; REV; SHAD-12; NOT; J79±Z;
   ZERO; SHLD+7;
JS40;
   
   SETB12;
JS14P295;
   
   SETB77;
J51=;
   
   C13;
J38<Z;
   
   M10; NEG; NOT; NEG; NOT;
   J50±Z;
   ZERO;
JS18P295;
   
J39; 
   
38; 
   SETB321;
JS14P295;
   
J39; 
   
50; 
   SETB301;
JS14P295;
   
J39; 
   
51; 
   M10; SET3;
J52=;
   
   ZERO;
JS18P295;
   
   C13;
J55<Z;
   
   NEG; NOT;
J56=Z;
   
53; 
   ERASE; ZERO;
JS18P295;
   
J58; 
   
52; 
   ERASE; C13;
J54<Z;
   
   SETB301;
JS14P295;
   
J53; 
   
54; 
   SETB321;
JS14P295;
   
J53; 
   
55; 
   ERASE; ERASE; SETB321;
J39;
   
56; 
   ERASE; SETB301;
39; 
JS14P295;
   
58; 
   SHC+6;
JS14P295;
   
66; 
   M7; SHC-1;
J57_>Z;
   
   SETB230;
JS14P295;
   
57; 
   I7; SHL-2; J63±Z;
   I7; =C7;
J60C7Z;
   
59; 
   SET2;
JS18P295;
   
   DC7;
J59C7NZ;
   
60; 
   M7; SHC-2;
J62_>Z;
   
   V27; DUP; =C14;
J62<Z;
   
J62C14Z; 
   
61; 
   DC14; ZERO;
JS18P295;
   
J61C14NZ; 
   
62; 
JS16P295;
   
   V28;
J111=Z;
   
   V28; V0P299;
JS12P295;
   
   SETB042;
JS14P295;
   
   SETB021;
JS14P295;
   
   DUP; SHL-6; DUP; J23±Z;
   ERASE; SETB236;
23; 
JS14P295;
   
   SHL+42; SHL-42;
JS14P295;
   
   SETB17;
JS14P295;
   
   V1; V31; FRB; DUP; SHL-12;
   DUP; J114±Z;
   ERASE; SETB236;
114; 
JS14P295;
   
   SHL+36; DUP; SHL-42;
JS14P295;
   
   SHL+6; SHL-42;
JS14P295;
   
J116C8Z; 
   
   SETB240;
JS14P295;
   
116; 
JS16P295;
   
111; 
   EXIT1;
63; 
   SET3;
JS18P295;
   
J60; 
   
64; 
JS40;
   
   SET4; =C14;
65; 
   ZERO;
JS18P295;
   
   DC14;
J65C14NZ;
   
J66; 
   
67; 
   M0TOQ13;
J68=Z;
   
   SET6;
J74;
   
69; 
   SET7;
JS100;
   
J70; 
   
71; 
   ERASE; ZERO; =TR; SET8;
JS100;
   
   V22;
J1;
   
73; 
   ERASE; SET9;
74; 
JS100;
   
   V21; SHL-24; V22;
J1;
   
75; 
JS40;
   
J66; 
   
77; 
   SET10;
J74;
   
78; 
   ERASE; SET11;
J74;
   
79; 
   ERASE; SET12;
J74;
   
95; 
   SETAV29; V22; SET1;
JP299;
   
40; 
J42C10Z;
   
41; 
   DC10; ZERO;
JS18P295;
   
J41C10NZ; 
   
42; 
   M7; SHC-2;
J43_>Z;
   
   SETB216;
JS14P295;
   
43; 
   I10;
J44<Z;
   
   I10;
JS14P295;
   
44; 
   SET8; C12; -; =C12; M13;
J88=Z; 
   
J112C7Z; 
   
46; 
J45C12NZ;
   
   M-I12; SET8; =C12;
45; 
   ZERO; V17M12; SHLD-6; =V17M12; SHC+6;
   M13;
J93=Z;
   
   C7; NEG; NOT;
J93=Z;
   
   SETB77;
J47=;
   
94; 
   SETB76;
J47=;
   
97; 
JS14P295;
   
48; 
   DC14; DC12; DC7;
J46C7NZ;
   
   M13;
J49=Z;
   
112; 
   M13;
JS14P295;
   
   M0TOQ13; C14TOQ7;
J46;
   
47; 
   ERASE; ZERO;
JS18P295;
   
J48; 
   
93; 
   SETB77; J94±;
   ERASE; ZERO;
J97;
   
49; 
   EXIT1;
88; 
J89C12NZ;
   
   M-I12; SET8; =C12;
89; 
   ZERO; V17M12; SHLD-6; =V17M12; SHC+6;
   SETB76;
J99=;
   
   SETB77;
J104=;
   
105; 
JS14P295;
   
106; 
   DC14; DC12; DC7;
J88C7NZ;
   
   EXIT1;
99; 
   ERASE; ZERO;
JS18P295;
   
J106; 
   
104; 
   ERASE; ZERO;
J105;
   
80; 
   DUP; =TR; ABSF; FIX; DUP;
   SHL-47; =M14; ABS; =C14; SETAV25;
   =RM15; SHA-1; DUP;
J109=Z;
   
   SET-10;
81; 
   =I14; M15M14H; SHA-24; =I15;
82; 
   C14; I14; DUP; PERM; +;
J83<Z; 
   
   =+C14; I15; =+C15; V3M14;×D;
   SHAD+1; ROUND;
J82;
   
83; 
   SHA-3;
J84=Z;
   
   SET2; =+M14; SET-3;
J81;
   
84; 
   M14; SHC-1;
J85<Z;
   
   NC14;
85; 
   DC14; NC14; STR; SHADC14;
J87;
   
86; 
   ERASE; SET10;×D; DC15;
87; 
   DUP;
J86=Z;
   
   SHAD-4; ERASE;
109; 
   C15; =M14; I14=+1;
J108NTR;
   
   NEG;
108; 
   EXIT1;
90; 
   DUP; J76±Z;
   NOT; DUP; SHL+6;
J92;
   
76; 
   V16; NEG; DUPD; +;
J91<Z;
   
   NEG;÷I; V1; REV; FRB;
91; 
   REV; V1; REV; FRB; V2;
   DUPD; REV; -; AND; V2;
   NEV; ZERO; FLOAT; FIX; NOT;
   NEG; =C15; ERASE; ZERO; NOT;
   STR; NEV; SHAC15; OR; REV;
   DUP;
J92_>Z;
   
   SHA-27; REV;
92; 
   REV; EXIT1;
100; 
   =V28; EXIT1;
P0;
   
P16V6; LINK; =Y0M2Q; 
   (format); V2=B0013573703034671; V5=B4321221604215035; V6=B4720000000000000;
   Y2M1; DUP; =V1; =RM14; SET2;
   SHC-8; =V0; Q0TOQ15; SET24; DUP;
   =C12; SHA-1; =C11; Q0TOQ13; IM0TOQ12;
   IM0TOQ11; Q12TOQ10; Q0TOQ9; ZERO;
JS27;
   
   SETB215; J32±;
   ERASE;
J2;
   
1; 
   REV; DUP; SHA+2; +; SHA+1;
   +;
2; 
JS27;
   
   DUP; SET10; -;
J1<Z;
   
   SETB70; (s); J26±;
   ERASE; DUP; SHL-4; J33±Z;
   DUP;
J23=Z;
   
   =V3; DC15;
3; 
   ZERO; DUP; NOT; NEG;
4; 
JS27;
   
J22C15Z; 
   
   SETB70; (s);
J13=;
   
5; 
   SETB51; (d);
J11=;
   
   SETB301; (+);
J14=;
   
   SETB321; (-);
J14=;
   
   SETB322; (±);
J14=;
   
   SETB13; (.);
J16=;
   
   DUP; (zero);
J17=Z;
   
   SETB63; (n);
J10=;
   
   SETB12; (10);
J18=;
   
   SETB230; (; );
J19=;
   
   SETB50; (c);
J20=;
   
   SETB65; (p);
J21=;
   
   SETB235; J31±;
6; 
   I12; J7±Z;
   SET24; C12; -;
J31=Z;
   
   ERASE; OR; =V4;
J8;
   
7; 
   C12; NEG; NOT; J31±Z;
   M11;
J31=Z;
   
   ERASE; ERASE; SETB3; DUP; PERM;
   AND; NEV; J34±Z;
8; 
   ZERO; M10; SHLD-3; ERASE; I9;
   SHLD-1; ERASE; SHL-1; I10; SHLD-1;
   ERASE; I13; SHLD-1; ERASE; M11;
   SHLD-2; ERASE; SET12; C11; -;
   SHLD-4; ERASE; SET24; C10; -;
   SHLD-5; ERASE; I11; SHLD-2; ERASE;
   V3; SHLD-4; ERASE; V4; SHLD-24;
   ERASE;
9; 
   M-I2; Y0M2; =LINK; EXIT1;
10; 
   (n); C11; SET12; -; J11±Z;
   I13=+1;
11; 
J31C9NZ;
   
   (d,zeroorterminator); I12; J12±Z;
   (EXM);
J31C11Z;
   
   (SFC>12); DC11;
12; 
   PERM; DUP; PERM; OR; REV;
   CAB; (insertdigitinfieldlayout);
13; 
   ERASE; SHL+1; DC12;
J32C12Z;
   
   (EFC>24); I10; J4±Z;
   (DPM); DC10;
J4C10NZ;
   
   (NDP);
J32;
   
14; 
   (+-±); SHC-4; DUP; SHL+46; REV; SHL-44;
   ROUND; (1=+,2=-,3=±); I12; J15±Z;
   (EXM); C12; SET24; -; J31±Z;
   (SFC=0); I11; J31±Z;
   (firstsign); =I11;
J4;
   
15; 
   (EXPSIGN); SET3; C12; -; J31±Z;
   M11; J31±Z;
   =M11;
J4;
   
16; 
   I10; J31±Z;
   (DPM); ERASE; I10=+1;
J4;
   
17; 
   (zero);
J12C9NZ;
   
   C11; SET12; -;
J31=Z;
   
   DC9;
J12;
   
18; 
   (subten); I12; J31±Z;
   I10;
J31=Z;
   
   I12=+1; ERASE; OR; DUP; =V4;
   SHLC10; SHL+24; BITS; NEG; NOT;
   J34±Z;
   SET3; =C12;
J3;
   
19; 
   (; ); I9; J31±Z;
   I9=+1; DC9; ERASE;
J4;
   
20; 
   (c); M10; SHL-2; J31±Z;
   DC9; ZERO; NOT; NEG; =+M10;
   ERASE;
J4;
   
21; 
   (p); M10; J31±Z;
   DC9; SET4; =M10; ERASE;
J4;
   
22; 
   SETB70; (s); J24±;
   ERASE; ERASE;
23; 
   NOT; NEG; DUP; DUP; SHL-4;
J4=Z; 
   
   NEG; NOT; =V3; DC15; ZERO;
   DUP; NOT; NEG; CAB;
J13;
   
24; 
   PERM; ERASE;
25; 
   =V3; DC15; ZERO; DUP; NOT;
   NEG; CAB;
J5;
   
26; 
   REV; DUP;
J25=Z;
   
J32; 
   
39; 
   ERASE;
27; 
   ZERO; V0;
28; 
   ZERO; SHLD+8; PERM; OR; DUP;
J29=Z; 
   
   =V0; SETB236;
J39=;
   
   SETB240;
J39=;
   
   SETB256;
J39=;
   
   EXIT1;
29; 
   ERASE; M0M14Q;
J28;
   
30; 
   ERASE;
31; 
   ERASE;
32; 
   ERASE;
33; 
   ERASE;
34; 
   V0P299;
JS12P295;
   
   SETAV5; =RM14;
35; 
JS1P295;
   
   SETB235;
J36=;
   
JS14P295; 
   
J35; 
   
36; 
   ERASE; V1; =RM14;
37; 
JS1P295;
   
   SETB235;
J38=;
   
JS14P295; 
   
J37; 
   
38; 
JS16P295;
   
   V2;
J9;
   
P0;
   
P17V0; Y3M2; V0; Y2M2;
JSP291;
   
   EXIT1; V0=B0013573703034651;
P0;
   
P18V0; Y3M2; Y2M2; (writeboolean);
JS12P295;
   
J2<Z; 
   
   SETB315;
1; 
JS14P295;
   
JS16P295; 
   
   EXIT1;
2; 
   SETB335;
J1;
   
P0;
   
P19V0; LINK; =Y0M2Q; 
   Y3M1; Y2M1;
JSP288;
   
   M-I2; Y0M2; =LINK; EXIT1; (P288nowinA1onaccountofbeingusedbyR16P295);
P0;
   V00001=B4321145214230464;
   V00002=B4342106415630451;
   V00003=B4322423547377777;
   V00004=B4322105511434615;
   V00005=B1611644643440616;
   V00006=B2410707113227070;
   V00007=B4323423513434215;
   V00008=B1211663577777777;
*2;
   ERASE; SET-3; =+M2;
JSP2;
   EXIT1; V30=6;
*3;
   ERASE; SET-3; =+M2;
JSP3;
   EXIT1; V29=6;
*4;
   ERASE; SET-3; =+M2;
JSP4;
   EXIT1; V28=6;
*5;
   ERASE; SET-3; =+M2;
JSP5;
   EXIT1; V27=6;
*6;
   ERASE; SET-3; =+M2;
JSP6;
   EXIT1; V26=6;
*7;
   ERASE; SET-3; =+M2;
JSP7;
   EXIT1; V25=6;
*8;
   ERASE; SET-3; =+M2;
JSP8;
   EXIT1; V24=6;
*9;
   ERASE; SET-3; =+M2;
JSP9;
   EXIT1; V23=6;
*10;
   ERASE; SET-3; =+M2;
JSP10;
   EXIT1; V22=6;
*11;
   ERASE; SET-3; =+M2;
JSP11;
   EXIT1; V21=6;
*12;
   ERASE; SET-3; =+M2;
JSP12;
   EXIT1; V20=6;
*13;
   ERASE; SET-3; =+M2;
JSP13;
   EXIT1; V19=6;
*14;
   ERASE; SET-3; =+M2;
JSP14;
   EXIT1; V18=6;
*15;
   ERASE; SET-5; =+M2;
JSP15;
   EXIT1; V17=8;
*17;
   ERASE; SET-4; =+M2;
JSP17;
   EXIT1; V15=7;
*18;
   ERASE; SET-4; =+M2;
JSP18;
   EXIT1; V14=7;
*16;
   SET0; V16; SET3;
JSP216;
   =YA16; =Y4M1; 
   JSP16; 
JP219; 
   V16=6;
*19;
   SET0; V13; SET4;
JSP216;
   =YA19; =Y5M1; 
   JSP19; 
JP219; 
   V13=7;
*20;
   SET0; V12; SET4;
JSP216;
   =YA20; =Y5M1;
   Y3M1;
JSP206;
   ZERO; JSP203; JP233V; REV; =M3; =Y0M3;
JP219; 
   V12=7;
*21;
   SET0; V11; SET4;
JSP216;
   =YA21; =Y5M1;
   Y3M1;
JSP206;
   ZERO; JSP203; JP233V; REV; =M3; =Y0M3;
   Y2M1;
JSP206;
JP233V; 
   =Y4M1;
   Y4M1;
JP219;
   V11=7;
*22;
   SET0; V10; SET4;
JSP216;
   =YA22; =Y5M1;
   Y3M1;
JSP206;
   ZERO; JSP203; JP233V; REV; =M3; =Y0M3;
   Y2M1;
JSP206;
JSP202; 
   JP233V; =Y4M1;
   Y4M1;
JP219;
   V10=7;
*23;
   SET0; V9; SET4;
JSP216;
   =YA23; =Y5M1;
   Y3M1;
JSP206;
   ZERO; JSP203; JP233V; REV; =M3; =Y0M3;
   Y2M1;
JSP206;
   ZERO; JSP203; SIGNF; SHA-1; NEG; JP233V; =Y4M1;
   Y4M1;
JP219;
   V9=7;
1; 
   ZERO; DUP; SET2; DUP; =Z1; =RM2; =M1;
JS194;
JSP248; 
   ZERO; OUT;
194; 
   SET0; V0; SET2;
JSP216;
   =YA1; =Y3M1;
   SET123;
JSP203;
JP233V; 
   =Y5M1;
   M2; =Y4M1;
   Y3M1; =M2;
   M+I2; M+I2; SET30; =Y0M2Q; 
   SETAV1; =Y0M2Q; 
   SET1;
JS19;
   
   SET123;
JSP203;
JP233V; 
   =Y5M1;
   M+I2; M+I2; SET30; =Y0M2Q; 
   Y5M1; =Y0M2Q; 
   SET1;
JS17;
   
   M+I2; M+I2; SET30; =Y0M2Q; 
   SETAV4; =Y0M2Q; 
   SET1;
JS19;
   
JP219; 
   V0=7;
FINISH;
|
