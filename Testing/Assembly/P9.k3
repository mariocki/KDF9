P
PINT|
ST32768;   TL 99999;
V3; YC8216; YP2304; YS18000; YT0;
RESTART; JP9; JP9;
PROGRAM;

P0; (P-code interpreter);

   (I use the following P-machine register names and KDF9 equivalents:);
   (PC = M1; op = M2; p = I2; q = C2;  FP = M3; TOS = C3; SP = M4; BOH = C4);
   (in the Zurich compiler's notation, mp = FP; ep = TOS; sp = SP; np = BOH);

   (FP is the Frame Pointer; it contains the KDF9 address of the first location in a stack frame);

   (SP is the Stack Pointer; it contains the KDF9 address of the top value in the evaluation stack);

   (TOS is the Top Of Stack; it contains the KDF9 address of the highest-used stack location);

   (BOH is the Base Of Heap; it contains the KDF9 address of the lowest location outside the heap);

   (AYS0 <= FP <= SP <= TOS < BOH = AYT0-s, where s is the size of the static data and heap);

   (0 <= PC < (AYP0-AYC0)*2);

   (YS is the P-machine data Store);
   (the P-Code is divided between halfwords in YC (op and q) and 6-bit fields in YP (p));
   (this is done because at least 30 bits are needed per order and I don't want to waste 18 of 48);
   (the YC, YP and YS stores are sized to allow self-compilation);

   (all simple data items are stored in halfwords, including reals as 24-bit floating point);
   (addresses are always halfword addresses; to access a word they must be divided by 2);
   (address scaling is done automatically by the KDF9's 'indirect' fetch and store operations);

   (Set up the initial P-machine state);

   (stack-related registers contain absolute KDF9 addresses);
   (PC contains an offset into the code store, YC/YP);
   ZERO;       =RM1; (PC);
   SET AYS0;   =M3;  (FP);
   SET AYS5;   =C3;  (TOS);
   SET AYS-1;  =RM4; (SP := FP-1);
   SET AYT0;   (KDF9 address of the top of the P-machine data store + 1);
   SET 4608;   (s, size of the static data and heap)
   -; =C4;     (BOH := maxstk+1);

   (Initialze instruction fetching);
   (MiMjH-style KDF9 indirect addressing is used to access halfwords efficiently);
   SET AYC0;   =M5;
   SET AYP0;   =M6;

   (here and later, Q7 and Q8 are scratch storage; Q9-Q15 can be used ad libitum elsewhere);
1001; (fetch-execute cycle);
   (get op and q);
   M5M1H; SHC+8; =Q2;   (Q2 = q/0/op);

   (get p);
   M1; SHC-2;    =Q8;   (Q8 = c<<14/0/h);
   M6M8H;               (N1 = p0:p1:p2:p3:000000000000000000000000);
   C8;                  (c<<14);
   SHL-14;       =M8;   (Q8 = c<<14/0/c);

   (map character position to shift);
   V0 =  6;
   V1 = 12;
   V2 = 18;
   V3 = 24;
   V0M8;         =C7;   (Q7 = 6c/0/0);
   SHCC7; SET B77; AND; (N1 = p);
   =I2;                 (Q2 = q/p/op);

   (advance PC);
   M+I1;

   (switch to case op, assumes 0 <= op <= 127);
   M2;  =LINK;
   EXIT AR1002;

*1002; (label 999 is for invalid opcodes);
   (lod); J1000; (case 0 has label 1000 because 0 is not a valid Usercode label);
*  (ldo); J1;
*  (str); J2;
*  (sro); J3;
*  (lda); J4;
*  (lao); J5;
*  (sto); J6;
*  (ldc); J7;
*  (lci); J8;
*  (ind); J9;
*  (inc); J10;
*  (mst); J11;
*  (cup); J12;
*  (ent); J13;
*  (ent); J14;
*  (csp); J15;
*  (ixa); J16;
*  (equ); J17;
*  (neq); J18;
*  (geq); J19;
*  (grt); J20;
*  (leq); J21;
*  (les); J22;
*  (ujp); J23;
*  (fjp); J24;
*  (xjp); J25;
*  (chk); J26;
*  (eof); J27;
*  (adi); J28;
*  (adr); J29;
*  (sbi); J30;
*  (sbr); J31;
*  (sgs); J32;
*  (flt); J33;
*  (flo); J34;
*  (trc); J35;
*  (ngi); J36;
*  (ngr); J37;
*  (sqi); J38;
*  (sqr); J39;
*  (abi); J40;
*  (abr); J41;
*  (not); J42;
*  (and); J43;
*  (ior); J44;
*  (dif); J45;
*  (int); J46;
*  (uni); J47;
*  (inn); J48;
*  (mod); J49;
*  (odd); J50;
*  (mpi); J51;
*  (mpr); J52;
*  (dvi); J53;
*  (dvr); J54;
*  (mov); J55;
*  (lca); J56;
*  (dec); J57;
*  (stp); J58;
*  (ord); J59;
*  (chr); J60;
*  (ucj); J61;
*  (xxx); J99;
*  (xxx); J99;
*  (xxx); J99;
*  (ldo); J65;
*  (ldo); J66;
*  (ldo); J67;
*  (ldo); J68;
*  (ldo); J69;
*  (str); J70;
*  (str); J71;
*  (str); J72;
*  (str); J73;
*  (str); J74;
*  (sro); J75;
*  (sro); J76;
*  (sro); J77;
*  (sro); J78;
*  (sro); J79;
*  (sto); J80;
*  (sto); J81;
*  (sto); J82;
*  (sto); J83;
*  (sto); J88;
*  (ind); J85;
*  (ind); J86;
*  (ind); J87;
*  (ind); J88;
*  (ind); J89;
*  (inc); J90;
*  (inc); J91;
*  (inc); J92;
*  (inc); J93;
*  (inc); J94;
*  (chk); J95; (chka);
*  (chk); J96;
*  (chk); J97;
*  (chk); J98;
*  (chk); J99;
*  (dec); J100;
*  (dec); J101;
*  (dec); J102;
*  (dec); J103;
*  (dec); J104;
*  (lod); J105;
*  (lod); J106;
*  (lod); J107;
*  (lod); J108;
*  (lod); J109;
*  (110); J999;
*  (111); J999;
*  (112); J999;
*  (113); J999;
*  (114); J999;
*  (115); J999;
*  (116); J999;
*  (117); J999;
*  (118); J999;
*  (119); J999;
*  (120); J999;
*  (121); J999;
*  (122); J999;
*  (123); J999;
*  (124); J999;
*  (125); J999;
*  (126); J999;
*  (127); J999;

*1000; 105; 106; 107; 108; 109; (lod);
      M+I4;
   JSP1; (base(p));
      C2; (q); +;  =M7; M0M7H; =M0M4H;
   J1001;

*1; 65; 66; 67; 68; 69; (ldo);
      M+I4;
      C2; (q); =M7; M0M7H; =M0M4H;
   J1001;

*2; 70; 71; 72; 73; 74; (str);

   JSP1; (base(p));
      C2; (q); +; =M7; M0M4H; =M0M7H;
      M-I4;
   J1001;

*3; 75; 76; 77; 78; 79; (sro);
      C2; (q); =M7; M0M4H; =M0M7H;
      M-I4;
   J1001;

*4; (lda);
      M+I4;
   JSP1; (base(p));
      C2; (q); +; =M0M4H;
   J1001;

*5; (lao);
      M+I4;
      C2; (q); =M0M4H;
   J1001;

*6; 80; 81; 82; 83; 84; (sto);
      M-I4;
      M0M4H;
      M-I4;
      M0M4H; SHL-24; =M8; =M0M8H;
   J1001;

*7; (ldc);
      M+I4;
      I2; (p); C2; (q); OR;
   J207=Z;
      C2; (q); =M0M4H;
   J1001;
207;
      SET B177777; (nil); =M0M4H;
   J1001;

*8; (lci);
      M+I4;
      C2; (q); =M8; M0M8H; =M0M4H;
   J1001;

*9; 85; 86; 87; 88; 89; (ind);
      M0M4H; SHL-24; C2; (q); +; =M8; M0M8H; =M0M4H;
   J1001;

*10; 90; 91; 92; 93; 94; (inc);
      M0M4H; C2; (q); SHA+24; +; =M0M4H;
   J1001;

*11; (mst);
      M+I4;                         (reserved;     SP := SP' + 1);
      M+I4;                         (reserved;     SP := SP' + 2);
   JSP1; (base(p));
      SHL+24; =M0M4QH;              (static link;  SP := SP' + 3);
      M3; (FP);  SHL+24; =M0M4QH;   (dynamic link; SP := SP' + 4);
      C3; (TOS); SHL+24; =M0M4QH;   (saved TOS;    SP := SP' + 5);
   J1001;

*12; (cup);
      M4; (SP); I2; (p); -; SET 4; -; =M3; (FP);
      M3 TO Q8; SET 4; =+M8;
      M1; (PC); SHL+24; =M0M8H;
      C2; (q); =M1; (PC);
   J1001;

*13; (ent);
      I2; (p); NEG; NOT;
   J213NEZ;
      M3; (FP); C2; (q); +; DUP; =M4; (SP);
      C4; (BOH); -;
   J1001LEZ;
      ZERO;
   JP2; (errori, store overflow when extending the stack);
213;
      M4; (SP); C2; (q); +; DUP; =C3; (TOS);
      C4; (BOH); -;
   J1001LEZ;
      ZERO;
   JP2; (errori, store overflow when extending the stack);

*14; (ret);
      M3; (FP); I2; (p);
   J214>Z;
      NEG; NOT; (adjust FP for a void procedure);
214;
      DUP; =M4; (SP);
      =RM8; SET 2; =+M8;
      M0M8QH; =M3; (FP);
      M0M8QH; =C3; (TOS);
      M0M8QH; =M1; (PC);
   J1001;

*15; (csp);
   JP998;

*16; (ixa);
      M0M4H; SHA-24; M-I4; C2; (q); XD; CONT; SHA+24; M0M4H; +; =M0M4H;
   J1001;

*17; (equ);
      M-I4;
      I2; (p); SET 5; NEV; J267=Z;
      (cases 0..6 - 5);
      I2; (p); SET 4; NEV; J277#Z;
      (case 4);
   JSP4; (set equality);
      =M0M4H;
   J1001;
277;
      (case 0..3);
      ZERO; M0M4H; M0M4HN; NEV; J287#Z;
      NOT; NEG;
287;
      =M0M4H;
   J1001;
267; (case 5);
   JSP3; (compare);
      =M0M4H;
   J1001;

*18; (neq);
      M-I4; I2; (p); SET 5; NEV; J218=Z;
      (cases 0..6 - 5);
      I2; (p); SET 4; NEV; J228#Z;
      (case 4);
   JSP4; (set equality);
      NEG; NOT;
      =M0M4H;
   J1001;
228;
      (case 0..3);
      ZERO; NOT; NEG; M0M4H; M0M4HN; NEV; J238#Z;
      ERASE; ZERO;
238;
      =M0M4H;
   J1001;
218; (case 5);
   JSP3; (compare);
      NEG; NOT;
      =M0M4H;
   J1001;

*19; (geq);
      M-I4; I2; (p); SET 5; NEV; J219=Z;
      (cases 0..6 - 5);
      I2; (p); J249#Z;
      SET 1;
   JP2; (errori);
249;
      I2; (p); SET 4; NEV; J229#Z;
      (case 4);
   JSP5; (subset);
      =M0M4H;
   J1001;
229;
      (case 0..3);
      ZERO; NOT; NEG; M0M4H; M0M4HN; NEV; J239#Z; (!!!);
      ERASE; ZERO;
239;
      =M0M4H;
   J1001;
219; (case 5);
   JSP3; (compare);
      ZERO; NOT; NEG; i1; =M8;YS1M8; i2; =M8;YS1M8; NEV; J259#Z; (!!!);
      ERASE; ZERO;
259;
      OR; =M0M4H;
   J1001;

   (.. etc !!!);
*20;
*21;
*22;

*23; (ujp);
      C2; (q); =M1; (PC);
   J1001;

*24; (fjp);
      M0M4H; M-I4; J1001=Z;
      C2; (q); =M1; (PC);
   J1001;

*25; (xjp);
      M0M4H; SHA-24; C2; (q); +; =M1; (PC);
      M-I4;
   J1001;

*26; 97; 98; 99; (chk);
      C2; (q); =M7; M0M4H; DUP; M0M8H; SIGN; SHA-1; REV;
      M0M8H; SIGN; SHA-1; OR;
   J1001#Z;
      SET 3;
   JP2; (errori);

*96; (chk r);
      C2; (q); =M7; M0M4H; DUP; M0M8; SIGNF; SHA-1; REV;
      M0M8; SIGNF; SHA-1; OR;
   J1001#Z;
      SET 3;
   JP2; (errori);

*95; (chka);
      M0M4H; DUP; C4; (BOH); SIGN; SHA-1; REV;
      SET AYT-1; (maxstr); C2; (q); -; SIGN; SHA-1; OR;
   J1001#Z;
      SET 2;
   JP2; (errori);

*27; (eof);
      M0M4H; ZERO; NOT; NEG; (input); NEV;
   J247#Z;
   JSP6; (eof); =M0M4H;
   J1001;
247;
      SET 4;
   JP2; (errori);

*28; (adi);
      M-I4;
      M0M4H; M0M4HN; +; =M0M4H;
   J1001;

*29; (adr);
      M-I4;
      M0M4H; M0M4HN; +F; =M0M4H;
   J1001;

*30; (sbi);
      M-I4;
      M0M4H; M0M4HN; -; =M0M4H;
   J1001;

*31; (sbr);
      M-I4;
      M0M4H; M0M4HN; -F; =M0M4H;
   J1001;

*32; (sgs);
      M0M4H; SHL-24; =C8; ZERO; NOT; NEG; SHLC8; =M0M4H;
   J1001;

*33; (flt);
      M0M4H; SET 47; FLOAT; =M0M4H;
   J1001;

*34; (flo);
      M0M4H; SET 47; FLOAT; =M0M4H;
   J1001;

*35; (trc);
      M0M4H; DUP; ABSF;
      FIX; SET 47; -; =C8; SHLC8;
      REV;
   J1001GEZ;
      NEG;
   J1001;

*36; (ngi);
      M0M4H; NEG; =M0M4H;
   J1001;

*37; (ngr);
      M0M4H; NEGF; =M0M4H;
   J1001;

*38; (sqi);
      M0M4H; DUP; XD; CONT; =M0M4H;
   J1001;

*39; (sqr);
      M0M4H; DUP; XF; =M0M4H;
   J1001;

*40; (abi);
      M0M4H; ABS; =M0M4H;
   J1001;

*41; (abr);
      M0M4H; ABSF; =M0M4H;
   J1001;

*42; (not);
      M0M4H; ZERO; NOT; NEG; NEV; =M0M4H;
   J1001;

*43; (and);
      M0M4H; AND; =M0M4H;
   J1001;

*44; (ior);
      M0M4H; OR; =M0M4H;
   J1001;

*45; (dif);
      MRWDQ0;

*46; (int);
      MRWDQ0;

*47; (uni);
      MRWDQ0;

*48; (inn);
      MRWDQ0;

*49; (mod);
      M-I4;
      M0M4H; M0M4HN; DIVI; REV; ERASE; =M0M4H;
   J1001;

*50; (odd);
      M0M4H; ZERO; NOT; NEG; AND; =M0M4H;
   J1001;

*51; (FPi);
      M-I4;
      M0M4H; M0M4HN; XD; CONT; =M0M4H;
   J1001;

*52; (FPr);
      M-I4;
      M0M4H; M0M4HN; XF; =M0M4H;
   J1001;

*53; (dvi);
      M-I4;
      M0M4H; M0M4HN; DIVI; ERASE; =M0M4H;
   J1001;

*54; (dvr);
      M-I4;
      M0M4H; M0M4HN; DIVF; =M0M4H;
   J1001;

*55; (mov);
      MRWDQ0;

*56; (lca);
      M-I4; C2; (q); =M0M4H;
   J1001;

*57; 100; 102; 103; 104; (dec);
      M0M4H; C2; (q); SHA+24; -; =M0M4H;
   J1001;

*101; (dec r ??);
      M0M4H; C2; (q); -; =M0M4H;
   J1001;

*58; (stp);
   JP9; (stop_run);

*59; (ord); 60; (chr);
   J1001;

*61; (ucj);
      SET 5;
   JP2; (errori);

998; (overflow detected);
      SET 6;
   JP2; (errori);

999; (invalid opcode failure);
      SET 7;
   JP2; (errori);

P1; (base: chase the static pointer chain to get an enclosing scope's frame pointer);
      M3;
      I2; (p); DUP;
   J1NEZ;
      ERASE;
   EXIT1;
*1;
      NEG; SET AR2; +; =LINK;
      =RM8; M+I8;
   EXIT; (goto AR2-p);
*     M0M8; =M8; M+I8; (p = 15);
*     M0M8; =M8; M+I8; (p = 14);
*     M0M8; =M8; M+I8; (p = 13);
*     M0M8; =M8; M+I8; (p = 12);
*     M0M8; =M8; M+I8; (p = 11);
*     M0M8; =M8; M+I8; (p = 10);
*     M0M8; =M8; M+I8; (p = 9);
*     M0M8; =M8; M+I8; (p = 8);
*     M0M8; =M8; M+I8; (p = 7);
*     M0M8; =M8; M+I8; (p = 6);
*     M0M8; =M8; M+I8; (p = 5);
*     M0M8; =M8; M+I8; (p = 4);
*     M0M8; =M8; M+I8; (p = 3);
*     M0M8; =M8; M+I8; (p = 2);
*     M0M8; EXIT1;     (p = 1);
*2;   MRWDQ0;          (p = 0);

P2V32; (errori);
      V0  = Q0/AV10/AV11;
      V1  = Q0/AV12/AV14;
      V2  = Q0/AV15/AV16;
      V3  = Q0/AV17/AV19;
      V4  = Q0/AV20/AV21;
      V5  = Q0/AV22/AV23;
      V6  = Q0/AV24/AV25;
      V7  = Q0/AV26/AV27;
      V8  = Q0/AV28/AV30;
      V9  = Q0/AV31/AV31;

      V10 = PSTORE$OV;
      V11 = PER$FLOW$;

      V12 = PCOMPARIS;
      V13 = PON$OF$AD;
      V14 = PDRESSES$;

      V15 = PBAD$POIN;
      V16 = PTER$$$$$;

      V17 = PVALUE$OU;
      V18 = PT$OF$RAN;
      V19 = PGE$$$$$$;

      V20 = PCODE$IN$;
      V21 = PERROR$$$;

      V22 = PCASE$IN$;
      V23 = PERROR$$$;

      V24 = POVERFLOW;
      V25 = P$ERROR$$;

      V26 = PEMULATIO;
      V27 = PN$ERROR$;

      V28 = PNORMAL$S;
      V29 = PTOP$REQU;
      V30 = PESTED$$$;

      V31 = PFAILURE$;

      =M8; V0M8; =Q7;
      M3M7; SET B02; OR; =M3M7;
      POAQ7;
      ZERO; OUT;

P3; (compare);
      M0M4H;   =RM7;
      YS1M4;   =RM8;
      C2 TO Q8;   (q);
      ZERO;       (interim result is FALSE);
*1;
      M3M7Q; M0M8QH; NEV;
   J2#Z;          (final result is FALSE);
   J1C8NZS;
      NOT; NEG;   (final result is TRUE);
2;
      EXIT1;

P4; (set equality)
      MRWDQ0;

P5; (set subset)
      MRWDQ0;

P6; (eof);
      MRWDQ0;

P9; (stop run);
      SET 8;
   JP2;

FINISH;
|
